var dZ = Object.defineProperty;
var fZ = (e, t, n) => t in e ? dZ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var no = (e, t, n) => fZ(e, typeof t != "symbol" ? t + "" : t, n);
var km = window;
function pZ(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const a in r)
        if (a !== "default" && !(a in e)) {
          const s = Object.getOwnPropertyDescriptor(r, a);
          s && Object.defineProperty(e, a, s.get ? s : {
            enumerable: !0,
            get: () => r[a]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
(function() {
  const t = document.createElement("link").relList;
  if (t && t.supports && t.supports("modulepreload")) return;
  for (const a of document.querySelectorAll('link[rel="modulepreload"]')) r(a);
  new MutationObserver((a) => {
    for (const s of a)
      if (s.type === "childList")
        for (const l of s.addedNodes) l.tagName === "LINK" && l.rel === "modulepreload" && r(l);
  }).observe(document, {
    childList: !0,
    subtree: !0
  });
  function n(a) {
    const s = {};
    return a.integrity && (s.integrity = a.integrity), a.referrerPolicy && (s.referrerPolicy = a.referrerPolicy), a.crossOrigin === "use-credentials" ? s.credentials = "include" : a.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s;
  }
  function r(a) {
    if (a.ep) return;
    a.ep = !0;
    const s = n(a);
    fetch(a.href, s);
  }
})();
function IR(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var lN = { exports: {} }, Uw = {};
var A1;
function mZ() {
  if (A1) return Uw;
  A1 = 1;
  var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.fragment");
  function n(r, a, s) {
    var l = null;
    if (s !== void 0 && (l = "" + s), a.key !== void 0 && (l = "" + a.key), "key" in a) {
      s = {};
      for (var c in a)
        c !== "key" && (s[c] = a[c]);
    } else s = a;
    return a = s.ref, {
      $$typeof: e,
      type: r,
      key: l,
      ref: a !== void 0 ? a : null,
      props: s
    };
  }
  return Uw.Fragment = t, Uw.jsx = n, Uw.jsxs = n, Uw;
}
var R1;
function hZ() {
  return R1 || (R1 = 1, lN.exports = mZ()), lN.exports;
}
var ka = hZ(), uN = { exports: {} }, Vw = {}, cN = { exports: {} }, dN = {};
var j1;
function gZ() {
  return j1 || (j1 = 1, (function(e) {
    function t($, K) {
      var q = $.length;
      $.push(K);
      e: for (; 0 < q; ) {
        var Z = q - 1 >>> 1, V = $[Z];
        if (0 < a(V, K))
          $[Z] = K, $[q] = V, q = Z;
        else break e;
      }
    }
    function n($) {
      return $.length === 0 ? null : $[0];
    }
    function r($) {
      if ($.length === 0) return null;
      var K = $[0], q = $.pop();
      if (q !== K) {
        $[0] = q;
        e: for (var Z = 0, V = $.length, F = V >>> 1; Z < F; ) {
          var Y = 2 * (Z + 1) - 1, U = $[Y], W = Y + 1, J = $[W];
          if (0 > a(U, q))
            W < V && 0 > a(J, U) ? ($[Z] = J, $[W] = q, Z = W) : ($[Z] = U, $[Y] = q, Z = Y);
          else if (W < V && 0 > a(J, q))
            $[Z] = J, $[W] = q, Z = W;
          else break e;
        }
      }
      return K;
    }
    function a($, K) {
      var q = $.sortIndex - K.sortIndex;
      return q !== 0 ? q : $.id - K.id;
    }
    if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      e.unstable_now = function() {
        return s.now();
      };
    } else {
      var l = Date, c = l.now();
      e.unstable_now = function() {
        return l.now() - c;
      };
    }
    var d = [], f = [], m = 1, h = null, v = 3, g = !1, b = !1, x = !1, w = !1, k = typeof setTimeout == "function" ? setTimeout : null, E = typeof clearTimeout == "function" ? clearTimeout : null, _ = typeof setImmediate < "u" ? setImmediate : null;
    function O($) {
      for (var K = n(f); K !== null; ) {
        if (K.callback === null) r(f);
        else if (K.startTime <= $)
          r(f), K.sortIndex = K.expirationTime, t(d, K);
        else break;
        K = n(f);
      }
    }
    function N($) {
      if (x = !1, O($), !b)
        if (n(d) !== null)
          b = !0, A || (A = !0, P());
        else {
          var K = n(f);
          K !== null && G(N, K.startTime - $);
        }
    }
    var A = !1, R = -1, D = 5, I = -1;
    function z() {
      return w ? !0 : !(e.unstable_now() - I < D);
    }
    function B() {
      if (w = !1, A) {
        var $ = e.unstable_now();
        I = $;
        var K = !0;
        try {
          e: {
            b = !1, x && (x = !1, E(R), R = -1), g = !0;
            var q = v;
            try {
              t: {
                for (O($), h = n(d); h !== null && !(h.expirationTime > $ && z()); ) {
                  var Z = h.callback;
                  if (typeof Z == "function") {
                    h.callback = null, v = h.priorityLevel;
                    var V = Z(
                      h.expirationTime <= $
                    );
                    if ($ = e.unstable_now(), typeof V == "function") {
                      h.callback = V, O($), K = !0;
                      break t;
                    }
                    h === n(d) && r(d), O($);
                  } else r(d);
                  h = n(d);
                }
                if (h !== null) K = !0;
                else {
                  var F = n(f);
                  F !== null && G(
                    N,
                    F.startTime - $
                  ), K = !1;
                }
              }
              break e;
            } finally {
              h = null, v = q, g = !1;
            }
            K = void 0;
          }
        } finally {
          K ? P() : A = !1;
        }
      }
    }
    var P;
    if (typeof _ == "function")
      P = function() {
        _(B);
      };
    else if (typeof MessageChannel < "u") {
      var H = new MessageChannel(), L = H.port2;
      H.port1.onmessage = B, P = function() {
        L.postMessage(null);
      };
    } else
      P = function() {
        k(B, 0);
      };
    function G($, K) {
      R = k(function() {
        $(e.unstable_now());
      }, K);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function($) {
      $.callback = null;
    }, e.unstable_forceFrameRate = function($) {
      0 > $ || 125 < $ ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : D = 0 < $ ? Math.floor(1e3 / $) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return v;
    }, e.unstable_next = function($) {
      switch (v) {
        case 1:
        case 2:
        case 3:
          var K = 3;
          break;
        default:
          K = v;
      }
      var q = v;
      v = K;
      try {
        return $();
      } finally {
        v = q;
      }
    }, e.unstable_requestPaint = function() {
      w = !0;
    }, e.unstable_runWithPriority = function($, K) {
      switch ($) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          $ = 3;
      }
      var q = v;
      v = $;
      try {
        return K();
      } finally {
        v = q;
      }
    }, e.unstable_scheduleCallback = function($, K, q) {
      var Z = e.unstable_now();
      switch (typeof q == "object" && q !== null ? (q = q.delay, q = typeof q == "number" && 0 < q ? Z + q : Z) : q = Z, $) {
        case 1:
          var V = -1;
          break;
        case 2:
          V = 250;
          break;
        case 5:
          V = 1073741823;
          break;
        case 4:
          V = 1e4;
          break;
        default:
          V = 5e3;
      }
      return V = q + V, $ = {
        id: m++,
        callback: K,
        priorityLevel: $,
        startTime: q,
        expirationTime: V,
        sortIndex: -1
      }, q > Z ? ($.sortIndex = q, t(f, $), n(d) === null && $ === n(f) && (x ? (E(R), R = -1) : x = !0, G(N, q - Z))) : ($.sortIndex = V, t(d, $), b || g || (b = !0, A || (A = !0, P()))), $;
    }, e.unstable_shouldYield = z, e.unstable_wrapCallback = function($) {
      var K = v;
      return function() {
        var q = v;
        v = K;
        try {
          return $.apply(this, arguments);
        } finally {
          v = q;
        }
      };
    };
  })(dN)), dN;
}
var P1;
function vZ() {
  return P1 || (P1 = 1, cN.exports = gZ()), cN.exports;
}
var fN = { exports: {} }, Ot = {};
var D1;
function yZ() {
  if (D1) return Ot;
  D1 = 1;
  var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.portal"), n = /* @__PURE__ */ Symbol.for("react.fragment"), r = /* @__PURE__ */ Symbol.for("react.strict_mode"), a = /* @__PURE__ */ Symbol.for("react.profiler"), s = /* @__PURE__ */ Symbol.for("react.consumer"), l = /* @__PURE__ */ Symbol.for("react.context"), c = /* @__PURE__ */ Symbol.for("react.forward_ref"), d = /* @__PURE__ */ Symbol.for("react.suspense"), f = /* @__PURE__ */ Symbol.for("react.memo"), m = /* @__PURE__ */ Symbol.for("react.lazy"), h = /* @__PURE__ */ Symbol.for("react.activity"), v = Symbol.iterator;
  function g(F) {
    return F === null || typeof F != "object" ? null : (F = v && F[v] || F["@@iterator"], typeof F == "function" ? F : null);
  }
  var b = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, x = Object.assign, w = {};
  function k(F, Y, U) {
    this.props = F, this.context = Y, this.refs = w, this.updater = U || b;
  }
  k.prototype.isReactComponent = {}, k.prototype.setState = function(F, Y) {
    if (typeof F != "object" && typeof F != "function" && F != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, F, Y, "setState");
  }, k.prototype.forceUpdate = function(F) {
    this.updater.enqueueForceUpdate(this, F, "forceUpdate");
  };
  function E() {
  }
  E.prototype = k.prototype;
  function _(F, Y, U) {
    this.props = F, this.context = Y, this.refs = w, this.updater = U || b;
  }
  var O = _.prototype = new E();
  O.constructor = _, x(O, k.prototype), O.isPureReactComponent = !0;
  var N = Array.isArray;
  function A() {
  }
  var R = { H: null, A: null, T: null, S: null }, D = Object.prototype.hasOwnProperty;
  function I(F, Y, U) {
    var W = U.ref;
    return {
      $$typeof: e,
      type: F,
      key: Y,
      ref: W !== void 0 ? W : null,
      props: U
    };
  }
  function z(F, Y) {
    return I(F.type, Y, F.props);
  }
  function B(F) {
    return typeof F == "object" && F !== null && F.$$typeof === e;
  }
  function P(F) {
    var Y = { "=": "=0", ":": "=2" };
    return "$" + F.replace(/[=:]/g, function(U) {
      return Y[U];
    });
  }
  var H = /\/+/g;
  function L(F, Y) {
    return typeof F == "object" && F !== null && F.key != null ? P("" + F.key) : Y.toString(36);
  }
  function G(F) {
    switch (F.status) {
      case "fulfilled":
        return F.value;
      case "rejected":
        throw F.reason;
      default:
        switch (typeof F.status == "string" ? F.then(A, A) : (F.status = "pending", F.then(
          function(Y) {
            F.status === "pending" && (F.status = "fulfilled", F.value = Y);
          },
          function(Y) {
            F.status === "pending" && (F.status = "rejected", F.reason = Y);
          }
        )), F.status) {
          case "fulfilled":
            return F.value;
          case "rejected":
            throw F.reason;
        }
    }
    throw F;
  }
  function $(F, Y, U, W, J) {
    var oe = typeof F;
    (oe === "undefined" || oe === "boolean") && (F = null);
    var fe = !1;
    if (F === null) fe = !0;
    else
      switch (oe) {
        case "bigint":
        case "string":
        case "number":
          fe = !0;
          break;
        case "object":
          switch (F.$$typeof) {
            case e:
            case t:
              fe = !0;
              break;
            case m:
              return fe = F._init, $(
                fe(F._payload),
                Y,
                U,
                W,
                J
              );
          }
      }
    if (fe)
      return J = J(F), fe = W === "" ? "." + L(F, 0) : W, N(J) ? (U = "", fe != null && (U = fe.replace(H, "$&/") + "/"), $(J, Y, U, "", function(ge) {
        return ge;
      })) : J != null && (B(J) && (J = z(
        J,
        U + (J.key == null || F && F.key === J.key ? "" : ("" + J.key).replace(
          H,
          "$&/"
        ) + "/") + fe
      )), Y.push(J)), 1;
    fe = 0;
    var ie = W === "" ? "." : W + ":";
    if (N(F))
      for (var ce = 0; ce < F.length; ce++)
        W = F[ce], oe = ie + L(W, ce), fe += $(
          W,
          Y,
          U,
          oe,
          J
        );
    else if (ce = g(F), typeof ce == "function")
      for (F = ce.call(F), ce = 0; !(W = F.next()).done; )
        W = W.value, oe = ie + L(W, ce++), fe += $(
          W,
          Y,
          U,
          oe,
          J
        );
    else if (oe === "object") {
      if (typeof F.then == "function")
        return $(
          G(F),
          Y,
          U,
          W,
          J
        );
      throw Y = String(F), Error(
        "Objects are not valid as a React child (found: " + (Y === "[object Object]" ? "object with keys {" + Object.keys(F).join(", ") + "}" : Y) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return fe;
  }
  function K(F, Y, U) {
    if (F == null) return F;
    var W = [], J = 0;
    return $(F, W, "", "", function(oe) {
      return Y.call(U, oe, J++);
    }), W;
  }
  function q(F) {
    if (F._status === -1) {
      var Y = F._result;
      Y = Y(), Y.then(
        function(U) {
          (F._status === 0 || F._status === -1) && (F._status = 1, F._result = U);
        },
        function(U) {
          (F._status === 0 || F._status === -1) && (F._status = 2, F._result = U);
        }
      ), F._status === -1 && (F._status = 0, F._result = Y);
    }
    if (F._status === 1) return F._result.default;
    throw F._result;
  }
  var Z = typeof reportError == "function" ? reportError : function(F) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var Y = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof F == "object" && F !== null && typeof F.message == "string" ? String(F.message) : String(F),
        error: F
      });
      if (!window.dispatchEvent(Y)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", F);
      return;
    }
    console.error(F);
  }, V = {
    map: K,
    forEach: function(F, Y, U) {
      K(
        F,
        function() {
          Y.apply(this, arguments);
        },
        U
      );
    },
    count: function(F) {
      var Y = 0;
      return K(F, function() {
        Y++;
      }), Y;
    },
    toArray: function(F) {
      return K(F, function(Y) {
        return Y;
      }) || [];
    },
    only: function(F) {
      if (!B(F))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return F;
    }
  };
  return Ot.Activity = h, Ot.Children = V, Ot.Component = k, Ot.Fragment = n, Ot.Profiler = a, Ot.PureComponent = _, Ot.StrictMode = r, Ot.Suspense = d, Ot.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = R, Ot.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(F) {
      return R.H.useMemoCache(F);
    }
  }, Ot.cache = function(F) {
    return function() {
      return F.apply(null, arguments);
    };
  }, Ot.cacheSignal = function() {
    return null;
  }, Ot.cloneElement = function(F, Y, U) {
    if (F == null)
      throw Error(
        "The argument must be a React element, but you passed " + F + "."
      );
    var W = x({}, F.props), J = F.key;
    if (Y != null)
      for (oe in Y.key !== void 0 && (J = "" + Y.key), Y)
        !D.call(Y, oe) || oe === "key" || oe === "__self" || oe === "__source" || oe === "ref" && Y.ref === void 0 || (W[oe] = Y[oe]);
    var oe = arguments.length - 2;
    if (oe === 1) W.children = U;
    else if (1 < oe) {
      for (var fe = Array(oe), ie = 0; ie < oe; ie++)
        fe[ie] = arguments[ie + 2];
      W.children = fe;
    }
    return I(F.type, J, W);
  }, Ot.createContext = function(F) {
    return F = {
      $$typeof: l,
      _currentValue: F,
      _currentValue2: F,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, F.Provider = F, F.Consumer = {
      $$typeof: s,
      _context: F
    }, F;
  }, Ot.createElement = function(F, Y, U) {
    var W, J = {}, oe = null;
    if (Y != null)
      for (W in Y.key !== void 0 && (oe = "" + Y.key), Y)
        D.call(Y, W) && W !== "key" && W !== "__self" && W !== "__source" && (J[W] = Y[W]);
    var fe = arguments.length - 2;
    if (fe === 1) J.children = U;
    else if (1 < fe) {
      for (var ie = Array(fe), ce = 0; ce < fe; ce++)
        ie[ce] = arguments[ce + 2];
      J.children = ie;
    }
    if (F && F.defaultProps)
      for (W in fe = F.defaultProps, fe)
        J[W] === void 0 && (J[W] = fe[W]);
    return I(F, oe, J);
  }, Ot.createRef = function() {
    return { current: null };
  }, Ot.forwardRef = function(F) {
    return { $$typeof: c, render: F };
  }, Ot.isValidElement = B, Ot.lazy = function(F) {
    return {
      $$typeof: m,
      _payload: { _status: -1, _result: F },
      _init: q
    };
  }, Ot.memo = function(F, Y) {
    return {
      $$typeof: f,
      type: F,
      compare: Y === void 0 ? null : Y
    };
  }, Ot.startTransition = function(F) {
    var Y = R.T, U = {};
    R.T = U;
    try {
      var W = F(), J = R.S;
      J !== null && J(U, W), typeof W == "object" && W !== null && typeof W.then == "function" && W.then(A, Z);
    } catch (oe) {
      Z(oe);
    } finally {
      Y !== null && U.types !== null && (Y.types = U.types), R.T = Y;
    }
  }, Ot.unstable_useCacheRefresh = function() {
    return R.H.useCacheRefresh();
  }, Ot.use = function(F) {
    return R.H.use(F);
  }, Ot.useActionState = function(F, Y, U) {
    return R.H.useActionState(F, Y, U);
  }, Ot.useCallback = function(F, Y) {
    return R.H.useCallback(F, Y);
  }, Ot.useContext = function(F) {
    return R.H.useContext(F);
  }, Ot.useDebugValue = function() {
  }, Ot.useDeferredValue = function(F, Y) {
    return R.H.useDeferredValue(F, Y);
  }, Ot.useEffect = function(F, Y) {
    return R.H.useEffect(F, Y);
  }, Ot.useEffectEvent = function(F) {
    return R.H.useEffectEvent(F);
  }, Ot.useId = function() {
    return R.H.useId();
  }, Ot.useImperativeHandle = function(F, Y, U) {
    return R.H.useImperativeHandle(F, Y, U);
  }, Ot.useInsertionEffect = function(F, Y) {
    return R.H.useInsertionEffect(F, Y);
  }, Ot.useLayoutEffect = function(F, Y) {
    return R.H.useLayoutEffect(F, Y);
  }, Ot.useMemo = function(F, Y) {
    return R.H.useMemo(F, Y);
  }, Ot.useOptimistic = function(F, Y) {
    return R.H.useOptimistic(F, Y);
  }, Ot.useReducer = function(F, Y, U) {
    return R.H.useReducer(F, Y, U);
  }, Ot.useRef = function(F) {
    return R.H.useRef(F);
  }, Ot.useState = function(F) {
    return R.H.useState(F);
  }, Ot.useSyncExternalStore = function(F, Y, U) {
    return R.H.useSyncExternalStore(
      F,
      Y,
      U
    );
  }, Ot.useTransition = function() {
    return R.H.useTransition();
  }, Ot.version = "19.2.3", Ot;
}
var I1;
function FS() {
  return I1 || (I1 = 1, fN.exports = yZ()), fN.exports;
}
var pN = { exports: {} }, qo = {};
var $1;
function bZ() {
  if ($1) return qo;
  $1 = 1;
  var e = FS();
  function t(d) {
    var f = "https://react.dev/errors/" + d;
    if (1 < arguments.length) {
      f += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var m = 2; m < arguments.length; m++)
        f += "&args[]=" + encodeURIComponent(arguments[m]);
    }
    return "Minified React error #" + d + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function n() {
  }
  var r = {
    d: {
      f: n,
      r: function() {
        throw Error(t(522));
      },
      D: n,
      C: n,
      L: n,
      m: n,
      X: n,
      S: n,
      M: n
    },
    p: 0,
    findDOMNode: null
  }, a = /* @__PURE__ */ Symbol.for("react.portal");
  function s(d, f, m) {
    var h = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: a,
      key: h == null ? null : "" + h,
      children: d,
      containerInfo: f,
      implementation: m
    };
  }
  var l = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function c(d, f) {
    if (d === "font") return "";
    if (typeof f == "string")
      return f === "use-credentials" ? f : "";
  }
  return qo.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r, qo.createPortal = function(d, f) {
    var m = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!f || f.nodeType !== 1 && f.nodeType !== 9 && f.nodeType !== 11)
      throw Error(t(299));
    return s(d, f, null, m);
  }, qo.flushSync = function(d) {
    var f = l.T, m = r.p;
    try {
      if (l.T = null, r.p = 2, d) return d();
    } finally {
      l.T = f, r.p = m, r.d.f();
    }
  }, qo.preconnect = function(d, f) {
    typeof d == "string" && (f ? (f = f.crossOrigin, f = typeof f == "string" ? f === "use-credentials" ? f : "" : void 0) : f = null, r.d.C(d, f));
  }, qo.prefetchDNS = function(d) {
    typeof d == "string" && r.d.D(d);
  }, qo.preinit = function(d, f) {
    if (typeof d == "string" && f && typeof f.as == "string") {
      var m = f.as, h = c(m, f.crossOrigin), v = typeof f.integrity == "string" ? f.integrity : void 0, g = typeof f.fetchPriority == "string" ? f.fetchPriority : void 0;
      m === "style" ? r.d.S(
        d,
        typeof f.precedence == "string" ? f.precedence : void 0,
        {
          crossOrigin: h,
          integrity: v,
          fetchPriority: g
        }
      ) : m === "script" && r.d.X(d, {
        crossOrigin: h,
        integrity: v,
        fetchPriority: g,
        nonce: typeof f.nonce == "string" ? f.nonce : void 0
      });
    }
  }, qo.preinitModule = function(d, f) {
    if (typeof d == "string")
      if (typeof f == "object" && f !== null) {
        if (f.as == null || f.as === "script") {
          var m = c(
            f.as,
            f.crossOrigin
          );
          r.d.M(d, {
            crossOrigin: m,
            integrity: typeof f.integrity == "string" ? f.integrity : void 0,
            nonce: typeof f.nonce == "string" ? f.nonce : void 0
          });
        }
      } else f == null && r.d.M(d);
  }, qo.preload = function(d, f) {
    if (typeof d == "string" && typeof f == "object" && f !== null && typeof f.as == "string") {
      var m = f.as, h = c(m, f.crossOrigin);
      r.d.L(d, m, {
        crossOrigin: h,
        integrity: typeof f.integrity == "string" ? f.integrity : void 0,
        nonce: typeof f.nonce == "string" ? f.nonce : void 0,
        type: typeof f.type == "string" ? f.type : void 0,
        fetchPriority: typeof f.fetchPriority == "string" ? f.fetchPriority : void 0,
        referrerPolicy: typeof f.referrerPolicy == "string" ? f.referrerPolicy : void 0,
        imageSrcSet: typeof f.imageSrcSet == "string" ? f.imageSrcSet : void 0,
        imageSizes: typeof f.imageSizes == "string" ? f.imageSizes : void 0,
        media: typeof f.media == "string" ? f.media : void 0
      });
    }
  }, qo.preloadModule = function(d, f) {
    if (typeof d == "string")
      if (f) {
        var m = c(f.as, f.crossOrigin);
        r.d.m(d, {
          as: typeof f.as == "string" && f.as !== "script" ? f.as : void 0,
          crossOrigin: m,
          integrity: typeof f.integrity == "string" ? f.integrity : void 0
        });
      } else r.d.m(d);
  }, qo.requestFormReset = function(d) {
    r.d.r(d);
  }, qo.unstable_batchedUpdates = function(d, f) {
    return d(f);
  }, qo.useFormState = function(d, f, m) {
    return l.H.useFormState(d, f, m);
  }, qo.useFormStatus = function() {
    return l.H.useHostTransitionStatus();
  }, qo.version = "19.2.3", qo;
}
var z1;
function K8() {
  if (z1) return pN.exports;
  z1 = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), pN.exports = bZ(), pN.exports;
}
var T1;
function wZ() {
  if (T1) return Vw;
  T1 = 1;
  var e = vZ(), t = FS(), n = K8();
  function r(o) {
    var i = "https://react.dev/errors/" + o;
    if (1 < arguments.length) {
      i += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var u = 2; u < arguments.length; u++)
        i += "&args[]=" + encodeURIComponent(arguments[u]);
    }
    return "Minified React error #" + o + "; visit " + i + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function a(o) {
    return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11);
  }
  function s(o) {
    var i = o, u = o;
    if (o.alternate) for (; i.return; ) i = i.return;
    else {
      o = i;
      do
        i = o, (i.flags & 4098) !== 0 && (u = i.return), o = i.return;
      while (o);
    }
    return i.tag === 3 ? u : null;
  }
  function l(o) {
    if (o.tag === 13) {
      var i = o.memoizedState;
      if (i === null && (o = o.alternate, o !== null && (i = o.memoizedState)), i !== null) return i.dehydrated;
    }
    return null;
  }
  function c(o) {
    if (o.tag === 31) {
      var i = o.memoizedState;
      if (i === null && (o = o.alternate, o !== null && (i = o.memoizedState)), i !== null) return i.dehydrated;
    }
    return null;
  }
  function d(o) {
    if (s(o) !== o)
      throw Error(r(188));
  }
  function f(o) {
    var i = o.alternate;
    if (!i) {
      if (i = s(o), i === null) throw Error(r(188));
      return i !== o ? null : o;
    }
    for (var u = o, p = i; ; ) {
      var y = u.return;
      if (y === null) break;
      var S = y.alternate;
      if (S === null) {
        if (p = y.return, p !== null) {
          u = p;
          continue;
        }
        break;
      }
      if (y.child === S.child) {
        for (S = y.child; S; ) {
          if (S === u) return d(y), o;
          if (S === p) return d(y), i;
          S = S.sibling;
        }
        throw Error(r(188));
      }
      if (u.return !== p.return) u = y, p = S;
      else {
        for (var j = !1, T = y.child; T; ) {
          if (T === u) {
            j = !0, u = y, p = S;
            break;
          }
          if (T === p) {
            j = !0, p = y, u = S;
            break;
          }
          T = T.sibling;
        }
        if (!j) {
          for (T = S.child; T; ) {
            if (T === u) {
              j = !0, u = S, p = y;
              break;
            }
            if (T === p) {
              j = !0, p = S, u = y;
              break;
            }
            T = T.sibling;
          }
          if (!j) throw Error(r(189));
        }
      }
      if (u.alternate !== p) throw Error(r(190));
    }
    if (u.tag !== 3) throw Error(r(188));
    return u.stateNode.current === u ? o : i;
  }
  function m(o) {
    var i = o.tag;
    if (i === 5 || i === 26 || i === 27 || i === 6) return o;
    for (o = o.child; o !== null; ) {
      if (i = m(o), i !== null) return i;
      o = o.sibling;
    }
    return null;
  }
  var h = Object.assign, v = /* @__PURE__ */ Symbol.for("react.element"), g = /* @__PURE__ */ Symbol.for("react.transitional.element"), b = /* @__PURE__ */ Symbol.for("react.portal"), x = /* @__PURE__ */ Symbol.for("react.fragment"), w = /* @__PURE__ */ Symbol.for("react.strict_mode"), k = /* @__PURE__ */ Symbol.for("react.profiler"), E = /* @__PURE__ */ Symbol.for("react.consumer"), _ = /* @__PURE__ */ Symbol.for("react.context"), O = /* @__PURE__ */ Symbol.for("react.forward_ref"), N = /* @__PURE__ */ Symbol.for("react.suspense"), A = /* @__PURE__ */ Symbol.for("react.suspense_list"), R = /* @__PURE__ */ Symbol.for("react.memo"), D = /* @__PURE__ */ Symbol.for("react.lazy"), I = /* @__PURE__ */ Symbol.for("react.activity"), z = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel"), B = Symbol.iterator;
  function P(o) {
    return o === null || typeof o != "object" ? null : (o = B && o[B] || o["@@iterator"], typeof o == "function" ? o : null);
  }
  var H = /* @__PURE__ */ Symbol.for("react.client.reference");
  function L(o) {
    if (o == null) return null;
    if (typeof o == "function")
      return o.$$typeof === H ? null : o.displayName || o.name || null;
    if (typeof o == "string") return o;
    switch (o) {
      case x:
        return "Fragment";
      case k:
        return "Profiler";
      case w:
        return "StrictMode";
      case N:
        return "Suspense";
      case A:
        return "SuspenseList";
      case I:
        return "Activity";
    }
    if (typeof o == "object")
      switch (o.$$typeof) {
        case b:
          return "Portal";
        case _:
          return o.displayName || "Context";
        case E:
          return (o._context.displayName || "Context") + ".Consumer";
        case O:
          var i = o.render;
          return o = o.displayName, o || (o = i.displayName || i.name || "", o = o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef"), o;
        case R:
          return i = o.displayName || null, i !== null ? i : L(o.type) || "Memo";
        case D:
          i = o._payload, o = o._init;
          try {
            return L(o(i));
          } catch {
          }
      }
    return null;
  }
  var G = Array.isArray, $ = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, K = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, q = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, Z = [], V = -1;
  function F(o) {
    return { current: o };
  }
  function Y(o) {
    0 > V || (o.current = Z[V], Z[V] = null, V--);
  }
  function U(o, i) {
    V++, Z[V] = o.current, o.current = i;
  }
  var W = F(null), J = F(null), oe = F(null), fe = F(null);
  function ie(o, i) {
    switch (U(oe, i), U(J, o), U(W, null), i.nodeType) {
      case 9:
      case 11:
        o = (o = i.documentElement) && (o = o.namespaceURI) ? dw(o) : 0;
        break;
      default:
        if (o = i.tagName, i = i.namespaceURI)
          i = dw(i), o = fw(i, o);
        else
          switch (o) {
            case "svg":
              o = 1;
              break;
            case "math":
              o = 2;
              break;
            default:
              o = 0;
          }
    }
    Y(W), U(W, o);
  }
  function ce() {
    Y(W), Y(J), Y(oe);
  }
  function ge(o) {
    o.memoizedState !== null && U(fe, o);
    var i = W.current, u = fw(i, o.type);
    i !== u && (U(J, o), U(W, u));
  }
  function re(o) {
    J.current === o && (Y(W), Y(J)), fe.current === o && (Y(fe), zs._currentValue = q);
  }
  var le, me;
  function ve(o) {
    if (le === void 0)
      try {
        throw Error();
      } catch (u) {
        var i = u.stack.trim().match(/\n( *(at )?)/);
        le = i && i[1] || "", me = -1 < u.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < u.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + le + o + me;
  }
  var xe = !1;
  function _e(o, i) {
    if (!o || xe) return "";
    xe = !0;
    var u = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var p = {
        DetermineComponentFrameRoot: function() {
          try {
            if (i) {
              var pe = function() {
                throw Error();
              };
              if (Object.defineProperty(pe.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(pe, []);
                } catch (se) {
                  var ae = se;
                }
                Reflect.construct(o, [], pe);
              } else {
                try {
                  pe.call();
                } catch (se) {
                  ae = se;
                }
                o.call(pe.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (se) {
                ae = se;
              }
              (pe = o()) && typeof pe.catch == "function" && pe.catch(function() {
              });
            }
          } catch (se) {
            if (se && ae && typeof se.stack == "string")
              return [se.stack, ae.stack];
          }
          return [null, null];
        }
      };
      p.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var y = Object.getOwnPropertyDescriptor(
        p.DetermineComponentFrameRoot,
        "name"
      );
      y && y.configurable && Object.defineProperty(
        p.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var S = p.DetermineComponentFrameRoot(), j = S[0], T = S[1];
      if (j && T) {
        var X = j.split(`
`), ne = T.split(`
`);
        for (y = p = 0; p < X.length && !X[p].includes("DetermineComponentFrameRoot"); )
          p++;
        for (; y < ne.length && !ne[y].includes(
          "DetermineComponentFrameRoot"
        ); )
          y++;
        if (p === X.length || y === ne.length)
          for (p = X.length - 1, y = ne.length - 1; 1 <= p && 0 <= y && X[p] !== ne[y]; )
            y--;
        for (; 1 <= p && 0 <= y; p--, y--)
          if (X[p] !== ne[y]) {
            if (p !== 1 || y !== 1)
              do
                if (p--, y--, 0 > y || X[p] !== ne[y]) {
                  var ue = `
` + X[p].replace(" at new ", " at ");
                  return o.displayName && ue.includes("<anonymous>") && (ue = ue.replace("<anonymous>", o.displayName)), ue;
                }
              while (1 <= p && 0 <= y);
            break;
          }
      }
    } finally {
      xe = !1, Error.prepareStackTrace = u;
    }
    return (u = o ? o.displayName || o.name : "") ? ve(u) : "";
  }
  function Ge(o, i) {
    switch (o.tag) {
      case 26:
      case 27:
      case 5:
        return ve(o.type);
      case 16:
        return ve("Lazy");
      case 13:
        return o.child !== i && i !== null ? ve("Suspense Fallback") : ve("Suspense");
      case 19:
        return ve("SuspenseList");
      case 0:
      case 15:
        return _e(o.type, !1);
      case 11:
        return _e(o.type.render, !1);
      case 1:
        return _e(o.type, !0);
      case 31:
        return ve("Activity");
      default:
        return "";
    }
  }
  function Xe(o) {
    try {
      var i = "", u = null;
      do
        i += Ge(o, u), u = o, o = o.return;
      while (o);
      return i;
    } catch (p) {
      return `
Error generating stack: ` + p.message + `
` + p.stack;
    }
  }
  var tt = Object.prototype.hasOwnProperty, nt = e.unstable_scheduleCallback, je = e.unstable_cancelCallback, cn = e.unstable_shouldYield, pt = e.unstable_requestPaint, Ce = e.unstable_now, Me = e.unstable_getCurrentPriorityLevel, he = e.unstable_ImmediatePriority, ye = e.unstable_UserBlockingPriority, Ee = e.unstable_NormalPriority, Te = e.unstable_LowPriority, Fe = e.unstable_IdlePriority, Ut = e.log, Vt = e.unstable_setDisableYieldValue, Xt = null, Nt = null;
  function kn(o) {
    if (typeof Ut == "function" && Vt(o), Nt && typeof Nt.setStrictMode == "function")
      try {
        Nt.setStrictMode(Xt, o);
      } catch {
      }
  }
  var Ae = Math.clz32 ? Math.clz32 : Bo, Ht = Math.log, Zt = Math.LN2;
  function Bo(o) {
    return o >>>= 0, o === 0 ? 32 : 31 - (Ht(o) / Zt | 0) | 0;
  }
  var Uo = 256, hn = 262144, On = 4194304;
  function _r(o) {
    var i = o & 42;
    if (i !== 0) return i;
    switch (o & -o) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
        return o & 261888;
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return o & 3932160;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return o & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return o;
    }
  }
  function Vo(o, i, u) {
    var p = o.pendingLanes;
    if (p === 0) return 0;
    var y = 0, S = o.suspendedLanes, j = o.pingedLanes;
    o = o.warmLanes;
    var T = p & 134217727;
    return T !== 0 ? (p = T & ~S, p !== 0 ? y = _r(p) : (j &= T, j !== 0 ? y = _r(j) : u || (u = T & ~o, u !== 0 && (y = _r(u))))) : (T = p & ~S, T !== 0 ? y = _r(T) : j !== 0 ? y = _r(j) : u || (u = p & ~o, u !== 0 && (y = _r(u)))), y === 0 ? 0 : i !== 0 && i !== y && (i & S) === 0 && (S = y & -y, u = i & -i, S >= u || S === 32 && (u & 4194048) !== 0) ? i : y;
  }
  function vr(o, i) {
    return (o.pendingLanes & ~(o.suspendedLanes & ~o.pingedLanes) & i) === 0;
  }
  function Zg(o, i) {
    switch (o) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return i + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return i + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function qd() {
    var o = On;
    return On <<= 1, (On & 62914560) === 0 && (On = 4194304), o;
  }
  function tu(o) {
    for (var i = [], u = 0; 31 > u; u++) i.push(o);
    return i;
  }
  function Ta(o, i) {
    o.pendingLanes |= i, i !== 268435456 && (o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0);
  }
  function ev(o, i, u, p, y, S) {
    var j = o.pendingLanes;
    o.pendingLanes = u, o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0, o.expiredLanes &= u, o.entangledLanes &= u, o.errorRecoveryDisabledLanes &= u, o.shellSuspendCounter = 0;
    var T = o.entanglements, X = o.expirationTimes, ne = o.hiddenUpdates;
    for (u = j & ~u; 0 < u; ) {
      var ue = 31 - Ae(u), pe = 1 << ue;
      T[ue] = 0, X[ue] = -1;
      var ae = ne[ue];
      if (ae !== null)
        for (ne[ue] = null, ue = 0; ue < ae.length; ue++) {
          var se = ae[ue];
          se !== null && (se.lane &= -536870913);
        }
      u &= ~pe;
    }
    p !== 0 && Gd(o, p, 0), S !== 0 && y === 0 && o.tag !== 0 && (o.suspendedLanes |= S & ~(j & ~i));
  }
  function Gd(o, i, u) {
    o.pendingLanes |= i, o.suspendedLanes &= ~i;
    var p = 31 - Ae(i);
    o.entangledLanes |= i, o.entanglements[p] = o.entanglements[p] | 1073741824 | u & 261930;
  }
  function Kd(o, i) {
    var u = o.entangledLanes |= i;
    for (o = o.entanglements; u; ) {
      var p = 31 - Ae(u), y = 1 << p;
      y & i | o[p] & i && (o[p] |= i), u &= ~y;
    }
  }
  function Yd(o, i) {
    var u = i & -i;
    return u = (u & 42) !== 0 ? 1 : nu(u), (u & (o.suspendedLanes | i)) !== 0 ? 0 : u;
  }
  function nu(o) {
    switch (o) {
      case 2:
        o = 1;
        break;
      case 8:
        o = 4;
        break;
      case 32:
        o = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        o = 128;
        break;
      case 268435456:
        o = 134217728;
        break;
      default:
        o = 0;
    }
    return o;
  }
  function ru(o) {
    return o &= -o, 2 < o ? 8 < o ? (o & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function Xd() {
    var o = K.p;
    return o !== 0 ? o : (o = window.event, o === void 0 ? 32 : Iw(o.type));
  }
  function Jd(o, i) {
    var u = K.p;
    try {
      return K.p = o, i();
    } finally {
      K.p = u;
    }
  }
  var Tr = Math.random().toString(36).slice(2), en = "__reactFiber$" + Tr, yn = "__reactProps$" + Tr, Ho = "__reactContainer$" + Tr, cl = "__reactEvents$" + Tr, dh = "__reactListeners$" + Tr, tv = "__reactHandles$" + Tr, Qd = "__reactResources$" + Tr, La = "__reactMarker$" + Tr;
  function ou(o) {
    delete o[en], delete o[yn], delete o[cl], delete o[dh], delete o[tv];
  }
  function na(o) {
    var i = o[en];
    if (i) return i;
    for (var u = o.parentNode; u; ) {
      if (i = u[Ho] || u[en]) {
        if (u = i.alternate, i.child !== null || u !== null && u.child !== null)
          for (o = bw(o); o !== null; ) {
            if (u = o[en]) return u;
            o = bw(o);
          }
        return i;
      }
      o = u, u = o.parentNode;
    }
    return null;
  }
  function ra(o) {
    if (o = o[en] || o[Ho]) {
      var i = o.tag;
      if (i === 5 || i === 6 || i === 13 || i === 31 || i === 26 || i === 27 || i === 3)
        return o;
    }
    return null;
  }
  function Na(o) {
    var i = o.tag;
    if (i === 5 || i === 26 || i === 27 || i === 6) return o.stateNode;
    throw Error(r(33));
  }
  function oa(o) {
    var i = o[Qd];
    return i || (i = o[Qd] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), i;
  }
  function Wt(o) {
    o[La] = !0;
  }
  var Zd = /* @__PURE__ */ new Set(), ef = {};
  function lo(o, i) {
    aa(o, i), aa(o + "Capture", i);
  }
  function aa(o, i) {
    for (ef[o] = i, o = 0; o < i.length; o++)
      Zd.add(i[o]);
  }
  var nv = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), od = {}, tf = {};
  function rv(o) {
    return tt.call(tf, o) ? !0 : tt.call(od, o) ? !1 : nv.test(o) ? tf[o] = !0 : (od[o] = !0, !1);
  }
  function Ji(o, i, u) {
    if (rv(i))
      if (u === null) o.removeAttribute(i);
      else {
        switch (typeof u) {
          case "undefined":
          case "function":
          case "symbol":
            o.removeAttribute(i);
            return;
          case "boolean":
            var p = i.toLowerCase().slice(0, 5);
            if (p !== "data-" && p !== "aria-") {
              o.removeAttribute(i);
              return;
            }
        }
        o.setAttribute(i, "" + u);
      }
  }
  function Qi(o, i, u) {
    if (u === null) o.removeAttribute(i);
    else {
      switch (typeof u) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          o.removeAttribute(i);
          return;
      }
      o.setAttribute(i, "" + u);
    }
  }
  function Er(o, i, u, p) {
    if (p === null) o.removeAttribute(u);
    else {
      switch (typeof p) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          o.removeAttribute(u);
          return;
      }
      o.setAttributeNS(i, u, "" + p);
    }
  }
  function Fn(o) {
    switch (typeof o) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return o;
      case "object":
        return o;
      default:
        return "";
    }
  }
  function nf(o) {
    var i = o.type;
    return (o = o.nodeName) && o.toLowerCase() === "input" && (i === "checkbox" || i === "radio");
  }
  function ov(o, i, u) {
    var p = Object.getOwnPropertyDescriptor(
      o.constructor.prototype,
      i
    );
    if (!o.hasOwnProperty(i) && typeof p < "u" && typeof p.get == "function" && typeof p.set == "function") {
      var y = p.get, S = p.set;
      return Object.defineProperty(o, i, {
        configurable: !0,
        get: function() {
          return y.call(this);
        },
        set: function(j) {
          u = "" + j, S.call(this, j);
        }
      }), Object.defineProperty(o, i, {
        enumerable: p.enumerable
      }), {
        getValue: function() {
          return u;
        },
        setValue: function(j) {
          u = "" + j;
        },
        stopTracking: function() {
          o._valueTracker = null, delete o[i];
        }
      };
    }
  }
  function dl(o) {
    if (!o._valueTracker) {
      var i = nf(o) ? "checked" : "value";
      o._valueTracker = ov(
        o,
        i,
        "" + o[i]
      );
    }
  }
  function rf(o) {
    if (!o) return !1;
    var i = o._valueTracker;
    if (!i) return !0;
    var u = i.getValue(), p = "";
    return o && (p = nf(o) ? o.checked ? "true" : "false" : o.value), o = p, o !== u ? (i.setValue(o), !0) : !1;
  }
  function Di(o) {
    if (o = o || (typeof document < "u" ? document : void 0), typeof o > "u") return null;
    try {
      return o.activeElement || o.body;
    } catch {
      return o.body;
    }
  }
  var av = /[\n"\\]/g;
  function Jn(o) {
    return o.replace(
      av,
      function(i) {
        return "\\" + i.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function Zi(o, i, u, p, y, S, j, T) {
    o.name = "", j != null && typeof j != "function" && typeof j != "symbol" && typeof j != "boolean" ? o.type = j : o.removeAttribute("type"), i != null ? j === "number" ? (i === 0 && o.value === "" || o.value != i) && (o.value = "" + Fn(i)) : o.value !== "" + Fn(i) && (o.value = "" + Fn(i)) : j !== "submit" && j !== "reset" || o.removeAttribute("value"), i != null ? au(o, j, Fn(i)) : u != null ? au(o, j, Fn(u)) : p != null && o.removeAttribute("value"), y == null && S != null && (o.defaultChecked = !!S), y != null && (o.checked = y && typeof y != "function" && typeof y != "symbol"), T != null && typeof T != "function" && typeof T != "symbol" && typeof T != "boolean" ? o.name = "" + Fn(T) : o.removeAttribute("name");
  }
  function of(o, i, u, p, y, S, j, T) {
    if (S != null && typeof S != "function" && typeof S != "symbol" && typeof S != "boolean" && (o.type = S), i != null || u != null) {
      if (!(S !== "submit" && S !== "reset" || i != null)) {
        dl(o);
        return;
      }
      u = u != null ? "" + Fn(u) : "", i = i != null ? "" + Fn(i) : u, T || i === o.value || (o.value = i), o.defaultValue = i;
    }
    p = p ?? y, p = typeof p != "function" && typeof p != "symbol" && !!p, o.checked = T ? o.checked : !!p, o.defaultChecked = !!p, j != null && typeof j != "function" && typeof j != "symbol" && typeof j != "boolean" && (o.name = j), dl(o);
  }
  function au(o, i, u) {
    i === "number" && Di(o.ownerDocument) === o || o.defaultValue === "" + u || (o.defaultValue = "" + u);
  }
  function Wo(o, i, u, p) {
    if (o = o.options, i) {
      i = {};
      for (var y = 0; y < u.length; y++)
        i["$" + u[y]] = !0;
      for (u = 0; u < o.length; u++)
        y = i.hasOwnProperty("$" + o[u].value), o[u].selected !== y && (o[u].selected = y), y && p && (o[u].defaultSelected = !0);
    } else {
      for (u = "" + Fn(u), i = null, y = 0; y < o.length; y++) {
        if (o[y].value === u) {
          o[y].selected = !0, p && (o[y].defaultSelected = !0);
          return;
        }
        i !== null || o[y].disabled || (i = o[y]);
      }
      i !== null && (i.selected = !0);
    }
  }
  function iv(o, i, u) {
    if (i != null && (i = "" + Fn(i), i !== o.value && (o.value = i), u == null)) {
      o.defaultValue !== i && (o.defaultValue = i);
      return;
    }
    o.defaultValue = u != null ? "" + Fn(u) : "";
  }
  function sv(o, i, u, p) {
    if (i == null) {
      if (p != null) {
        if (u != null) throw Error(r(92));
        if (G(p)) {
          if (1 < p.length) throw Error(r(93));
          p = p[0];
        }
        u = p;
      }
      u == null && (u = ""), i = u;
    }
    u = Fn(i), o.defaultValue = u, p = o.textContent, p === u && p !== "" && p !== null && (o.value = p), dl(o);
  }
  function Fa(o, i) {
    if (i) {
      var u = o.firstChild;
      if (u && u === o.lastChild && u.nodeType === 3) {
        u.nodeValue = i;
        return;
      }
    }
    o.textContent = i;
  }
  var rO = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function lv(o, i, u) {
    var p = i.indexOf("--") === 0;
    u == null || typeof u == "boolean" || u === "" ? p ? o.setProperty(i, "") : i === "float" ? o.cssFloat = "" : o[i] = "" : p ? o.setProperty(i, u) : typeof u != "number" || u === 0 || rO.has(i) ? i === "float" ? o.cssFloat = u : o[i] = ("" + u).trim() : o[i] = u + "px";
  }
  function uv(o, i, u) {
    if (i != null && typeof i != "object")
      throw Error(r(62));
    if (o = o.style, u != null) {
      for (var p in u)
        !u.hasOwnProperty(p) || i != null && i.hasOwnProperty(p) || (p.indexOf("--") === 0 ? o.setProperty(p, "") : p === "float" ? o.cssFloat = "" : o[p] = "");
      for (var y in i)
        p = i[y], i.hasOwnProperty(y) && u[y] !== p && lv(o, y, p);
    } else
      for (var S in i)
        i.hasOwnProperty(S) && lv(o, S, i[S]);
  }
  function af(o) {
    if (o.indexOf("-") === -1) return !1;
    switch (o) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var oO = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), aO = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function iu(o) {
    return aO.test("" + o) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : o;
  }
  function Lr() {
  }
  var sf = null;
  function lf(o) {
    return o = o.target || o.srcElement || window, o.correspondingUseElement && (o = o.correspondingUseElement), o.nodeType === 3 ? o.parentNode : o;
  }
  var Ba = null, Ua = null;
  function cv(o) {
    var i = ra(o);
    if (i && (o = i.stateNode)) {
      var u = o[yn] || null;
      e: switch (o = i.stateNode, i.type) {
        case "input":
          if (Zi(
            o,
            u.value,
            u.defaultValue,
            u.defaultValue,
            u.checked,
            u.defaultChecked,
            u.type,
            u.name
          ), i = u.name, u.type === "radio" && i != null) {
            for (u = o; u.parentNode; ) u = u.parentNode;
            for (u = u.querySelectorAll(
              'input[name="' + Jn(
                "" + i
              ) + '"][type="radio"]'
            ), i = 0; i < u.length; i++) {
              var p = u[i];
              if (p !== o && p.form === o.form) {
                var y = p[yn] || null;
                if (!y) throw Error(r(90));
                Zi(
                  p,
                  y.value,
                  y.defaultValue,
                  y.defaultValue,
                  y.checked,
                  y.defaultChecked,
                  y.type,
                  y.name
                );
              }
            }
            for (i = 0; i < u.length; i++)
              p = u[i], p.form === o.form && rf(p);
          }
          break e;
        case "textarea":
          iv(o, u.value, u.defaultValue);
          break e;
        case "select":
          i = u.value, i != null && Wo(o, !!u.multiple, i, !1);
      }
    }
  }
  var uf = !1;
  function dv(o, i, u) {
    if (uf) return o(i, u);
    uf = !0;
    try {
      var p = o(i);
      return p;
    } finally {
      if (uf = !1, (Ba !== null || Ua !== null) && (Gu(), Ba && (i = Ba, o = Ua, Ua = Ba = null, cv(i), o)))
        for (i = 0; i < o.length; i++) cv(o[i]);
    }
  }
  function es(o, i) {
    var u = o.stateNode;
    if (u === null) return null;
    var p = u[yn] || null;
    if (p === null) return null;
    u = p[i];
    e: switch (i) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (p = !p.disabled) || (o = o.type, p = !(o === "button" || o === "input" || o === "select" || o === "textarea")), o = !p;
        break e;
      default:
        o = !1;
    }
    if (o) return null;
    if (u && typeof u != "function")
      throw Error(
        r(231, i, typeof u)
      );
    return u;
  }
  var Fr = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), cf = !1;
  if (Fr)
    try {
      var ts = {};
      Object.defineProperty(ts, "passive", {
        get: function() {
          cf = !0;
        }
      }), window.addEventListener("test", ts, ts), window.removeEventListener("test", ts, ts);
    } catch {
      cf = !1;
    }
  var uo = null, df = null, su = null;
  function fv() {
    if (su) return su;
    var o, i = df, u = i.length, p, y = "value" in uo ? uo.value : uo.textContent, S = y.length;
    for (o = 0; o < u && i[o] === y[o]; o++) ;
    var j = u - o;
    for (p = 1; p <= j && i[u - p] === y[S - p]; p++) ;
    return su = y.slice(o, 1 < p ? 1 - p : void 0);
  }
  function lu(o) {
    var i = o.keyCode;
    return "charCode" in o ? (o = o.charCode, o === 0 && i === 13 && (o = 13)) : o = i, o === 10 && (o = 13), 32 <= o || o === 13 ? o : 0;
  }
  function uu() {
    return !0;
  }
  function pv() {
    return !1;
  }
  function Mn(o) {
    function i(u, p, y, S, j) {
      this._reactName = u, this._targetInst = y, this.type = p, this.nativeEvent = S, this.target = j, this.currentTarget = null;
      for (var T in o)
        o.hasOwnProperty(T) && (u = o[T], this[T] = u ? u(S) : S[T]);
      return this.isDefaultPrevented = (S.defaultPrevented != null ? S.defaultPrevented : S.returnValue === !1) ? uu : pv, this.isPropagationStopped = pv, this;
    }
    return h(i.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var u = this.nativeEvent;
        u && (u.preventDefault ? u.preventDefault() : typeof u.returnValue != "unknown" && (u.returnValue = !1), this.isDefaultPrevented = uu);
      },
      stopPropagation: function() {
        var u = this.nativeEvent;
        u && (u.stopPropagation ? u.stopPropagation() : typeof u.cancelBubble != "unknown" && (u.cancelBubble = !0), this.isPropagationStopped = uu);
      },
      persist: function() {
      },
      isPersistent: uu
    }), i;
  }
  var ia = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(o) {
      return o.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, cu = Mn(ia), ns = h({}, ia, { view: 0, detail: 0 }), iO = Mn(ns), ff, pf, rs, du = h({}, ns, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: hf,
    button: 0,
    buttons: 0,
    relatedTarget: function(o) {
      return o.relatedTarget === void 0 ? o.fromElement === o.srcElement ? o.toElement : o.fromElement : o.relatedTarget;
    },
    movementX: function(o) {
      return "movementX" in o ? o.movementX : (o !== rs && (rs && o.type === "mousemove" ? (ff = o.screenX - rs.screenX, pf = o.screenY - rs.screenY) : pf = ff = 0, rs = o), ff);
    },
    movementY: function(o) {
      return "movementY" in o ? o.movementY : pf;
    }
  }), mv = Mn(du), sO = h({}, du, { dataTransfer: 0 }), lO = Mn(sO), uO = h({}, ns, { relatedTarget: 0 }), mf = Mn(uO), cO = h({}, ia, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), dO = Mn(cO), fO = h({}, ia, {
    clipboardData: function(o) {
      return "clipboardData" in o ? o.clipboardData : window.clipboardData;
    }
  }), pO = Mn(fO), mO = h({}, ia, { data: 0 }), hv = Mn(mO), hO = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, gO = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, vO = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function yO(o) {
    var i = this.nativeEvent;
    return i.getModifierState ? i.getModifierState(o) : (o = vO[o]) ? !!i[o] : !1;
  }
  function hf() {
    return yO;
  }
  var bO = h({}, ns, {
    key: function(o) {
      if (o.key) {
        var i = hO[o.key] || o.key;
        if (i !== "Unidentified") return i;
      }
      return o.type === "keypress" ? (o = lu(o), o === 13 ? "Enter" : String.fromCharCode(o)) : o.type === "keydown" || o.type === "keyup" ? gO[o.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: hf,
    charCode: function(o) {
      return o.type === "keypress" ? lu(o) : 0;
    },
    keyCode: function(o) {
      return o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
    },
    which: function(o) {
      return o.type === "keypress" ? lu(o) : o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
    }
  }), wO = Mn(bO), xO = h({}, du, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), gv = Mn(xO), SO = h({}, ns, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: hf
  }), kO = Mn(SO), _O = h({}, ia, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), EO = Mn(_O), CO = h({}, du, {
    deltaX: function(o) {
      return "deltaX" in o ? o.deltaX : "wheelDeltaX" in o ? -o.wheelDeltaX : 0;
    },
    deltaY: function(o) {
      return "deltaY" in o ? o.deltaY : "wheelDeltaY" in o ? -o.wheelDeltaY : "wheelDelta" in o ? -o.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), OO = Mn(CO), MO = h({}, ia, {
    newState: 0,
    oldState: 0
  }), NO = Mn(MO), AO = [9, 13, 27, 32], gf = Fr && "CompositionEvent" in window, os = null;
  Fr && "documentMode" in document && (os = document.documentMode);
  var RO = Fr && "TextEvent" in window && !os, vv = Fr && (!gf || os && 8 < os && 11 >= os), yv = " ", bv = !1;
  function wv(o, i) {
    switch (o) {
      case "keyup":
        return AO.indexOf(i.keyCode) !== -1;
      case "keydown":
        return i.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function xv(o) {
    return o = o.detail, typeof o == "object" && "data" in o ? o.data : null;
  }
  var Va = !1;
  function jO(o, i) {
    switch (o) {
      case "compositionend":
        return xv(i);
      case "keypress":
        return i.which !== 32 ? null : (bv = !0, yv);
      case "textInput":
        return o = i.data, o === yv && bv ? null : o;
      default:
        return null;
    }
  }
  function PO(o, i) {
    if (Va)
      return o === "compositionend" || !gf && wv(o, i) ? (o = fv(), su = df = uo = null, Va = !1, o) : null;
    switch (o) {
      case "paste":
        return null;
      case "keypress":
        if (!(i.ctrlKey || i.altKey || i.metaKey) || i.ctrlKey && i.altKey) {
          if (i.char && 1 < i.char.length)
            return i.char;
          if (i.which) return String.fromCharCode(i.which);
        }
        return null;
      case "compositionend":
        return vv && i.locale !== "ko" ? null : i.data;
      default:
        return null;
    }
  }
  var DO = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function Sv(o) {
    var i = o && o.nodeName && o.nodeName.toLowerCase();
    return i === "input" ? !!DO[o.type] : i === "textarea";
  }
  function kv(o, i, u, p) {
    Ba ? Ua ? Ua.push(p) : Ua = [p] : Ba = p, i = ec(i, "onChange"), 0 < i.length && (u = new cu(
      "onChange",
      "change",
      null,
      u,
      p
    ), o.push({ event: u, listeners: i }));
  }
  var as = null, is = null;
  function IO(o) {
    aw(o, 0);
  }
  function fu(o) {
    var i = Na(o);
    if (rf(i)) return o;
  }
  function _v(o, i) {
    if (o === "change") return i;
  }
  var Ev = !1;
  if (Fr) {
    var vf;
    if (Fr) {
      var yf = "oninput" in document;
      if (!yf) {
        var Cv = document.createElement("div");
        Cv.setAttribute("oninput", "return;"), yf = typeof Cv.oninput == "function";
      }
      vf = yf;
    } else vf = !1;
    Ev = vf && (!document.documentMode || 9 < document.documentMode);
  }
  function Ov() {
    as && (as.detachEvent("onpropertychange", Mv), is = as = null);
  }
  function Mv(o) {
    if (o.propertyName === "value" && fu(is)) {
      var i = [];
      kv(
        i,
        is,
        o,
        lf(o)
      ), dv(IO, i);
    }
  }
  function $O(o, i, u) {
    o === "focusin" ? (Ov(), as = i, is = u, as.attachEvent("onpropertychange", Mv)) : o === "focusout" && Ov();
  }
  function zO(o) {
    if (o === "selectionchange" || o === "keyup" || o === "keydown")
      return fu(is);
  }
  function TO(o, i) {
    if (o === "click") return fu(i);
  }
  function LO(o, i) {
    if (o === "input" || o === "change")
      return fu(i);
  }
  function FO(o, i) {
    return o === i && (o !== 0 || 1 / o === 1 / i) || o !== o && i !== i;
  }
  var Bn = typeof Object.is == "function" ? Object.is : FO;
  function ss(o, i) {
    if (Bn(o, i)) return !0;
    if (typeof o != "object" || o === null || typeof i != "object" || i === null)
      return !1;
    var u = Object.keys(o), p = Object.keys(i);
    if (u.length !== p.length) return !1;
    for (p = 0; p < u.length; p++) {
      var y = u[p];
      if (!tt.call(i, y) || !Bn(o[y], i[y]))
        return !1;
    }
    return !0;
  }
  function Nv(o) {
    for (; o && o.firstChild; ) o = o.firstChild;
    return o;
  }
  function Av(o, i) {
    var u = Nv(o);
    o = 0;
    for (var p; u; ) {
      if (u.nodeType === 3) {
        if (p = o + u.textContent.length, o <= i && p >= i)
          return { node: u, offset: i - o };
        o = p;
      }
      e: {
        for (; u; ) {
          if (u.nextSibling) {
            u = u.nextSibling;
            break e;
          }
          u = u.parentNode;
        }
        u = void 0;
      }
      u = Nv(u);
    }
  }
  function Rv(o, i) {
    return o && i ? o === i ? !0 : o && o.nodeType === 3 ? !1 : i && i.nodeType === 3 ? Rv(o, i.parentNode) : "contains" in o ? o.contains(i) : o.compareDocumentPosition ? !!(o.compareDocumentPosition(i) & 16) : !1 : !1;
  }
  function jv(o) {
    o = o != null && o.ownerDocument != null && o.ownerDocument.defaultView != null ? o.ownerDocument.defaultView : window;
    for (var i = Di(o.document); i instanceof o.HTMLIFrameElement; ) {
      try {
        var u = typeof i.contentWindow.location.href == "string";
      } catch {
        u = !1;
      }
      if (u) o = i.contentWindow;
      else break;
      i = Di(o.document);
    }
    return i;
  }
  function bf(o) {
    var i = o && o.nodeName && o.nodeName.toLowerCase();
    return i && (i === "input" && (o.type === "text" || o.type === "search" || o.type === "tel" || o.type === "url" || o.type === "password") || i === "textarea" || o.contentEditable === "true");
  }
  var BO = Fr && "documentMode" in document && 11 >= document.documentMode, Ha = null, wf = null, ls = null, xf = !1;
  function Pv(o, i, u) {
    var p = u.window === u ? u.document : u.nodeType === 9 ? u : u.ownerDocument;
    xf || Ha == null || Ha !== Di(p) || (p = Ha, "selectionStart" in p && bf(p) ? p = { start: p.selectionStart, end: p.selectionEnd } : (p = (p.ownerDocument && p.ownerDocument.defaultView || window).getSelection(), p = {
      anchorNode: p.anchorNode,
      anchorOffset: p.anchorOffset,
      focusNode: p.focusNode,
      focusOffset: p.focusOffset
    }), ls && ss(ls, p) || (ls = p, p = ec(wf, "onSelect"), 0 < p.length && (i = new cu(
      "onSelect",
      "select",
      null,
      i,
      u
    ), o.push({ event: i, listeners: p }), i.target = Ha)));
  }
  function sa(o, i) {
    var u = {};
    return u[o.toLowerCase()] = i.toLowerCase(), u["Webkit" + o] = "webkit" + i, u["Moz" + o] = "moz" + i, u;
  }
  var Wa = {
    animationend: sa("Animation", "AnimationEnd"),
    animationiteration: sa("Animation", "AnimationIteration"),
    animationstart: sa("Animation", "AnimationStart"),
    transitionrun: sa("Transition", "TransitionRun"),
    transitionstart: sa("Transition", "TransitionStart"),
    transitioncancel: sa("Transition", "TransitionCancel"),
    transitionend: sa("Transition", "TransitionEnd")
  }, Sf = {}, Dv = {};
  Fr && (Dv = document.createElement("div").style, "AnimationEvent" in window || (delete Wa.animationend.animation, delete Wa.animationiteration.animation, delete Wa.animationstart.animation), "TransitionEvent" in window || delete Wa.transitionend.transition);
  function la(o) {
    if (Sf[o]) return Sf[o];
    if (!Wa[o]) return o;
    var i = Wa[o], u;
    for (u in i)
      if (i.hasOwnProperty(u) && u in Dv)
        return Sf[o] = i[u];
    return o;
  }
  var Iv = la("animationend"), $v = la("animationiteration"), zv = la("animationstart"), UO = la("transitionrun"), VO = la("transitionstart"), HO = la("transitioncancel"), Tv = la("transitionend"), Lv = /* @__PURE__ */ new Map(), kf = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  kf.push("scrollEnd");
  function yr(o, i) {
    Lv.set(o, i), lo(i, [o]);
  }
  var pu = typeof reportError == "function" ? reportError : function(o) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var i = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof o == "object" && o !== null && typeof o.message == "string" ? String(o.message) : String(o),
        error: o
      });
      if (!window.dispatchEvent(i)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", o);
      return;
    }
    console.error(o);
  }, tr = [], qa = 0, _f = 0;
  function mu() {
    for (var o = qa, i = _f = qa = 0; i < o; ) {
      var u = tr[i];
      tr[i++] = null;
      var p = tr[i];
      tr[i++] = null;
      var y = tr[i];
      tr[i++] = null;
      var S = tr[i];
      if (tr[i++] = null, p !== null && y !== null) {
        var j = p.pending;
        j === null ? y.next = y : (y.next = j.next, j.next = y), p.pending = y;
      }
      S !== 0 && Fv(u, y, S);
    }
  }
  function hu(o, i, u, p) {
    tr[qa++] = o, tr[qa++] = i, tr[qa++] = u, tr[qa++] = p, _f |= p, o.lanes |= p, o = o.alternate, o !== null && (o.lanes |= p);
  }
  function Ef(o, i, u, p) {
    return hu(o, i, u, p), gu(o);
  }
  function ua(o, i) {
    return hu(o, null, null, i), gu(o);
  }
  function Fv(o, i, u) {
    o.lanes |= u;
    var p = o.alternate;
    p !== null && (p.lanes |= u);
    for (var y = !1, S = o.return; S !== null; )
      S.childLanes |= u, p = S.alternate, p !== null && (p.childLanes |= u), S.tag === 22 && (o = S.stateNode, o === null || o._visibility & 1 || (y = !0)), o = S, S = S.return;
    return o.tag === 3 ? (S = o.stateNode, y && i !== null && (y = 31 - Ae(u), o = S.hiddenUpdates, p = o[y], p === null ? o[y] = [i] : p.push(i), i.lane = u | 536870912), S) : null;
  }
  function gu(o) {
    if (50 < As)
      throw As = 0, Dp = null, Error(r(185));
    for (var i = o.return; i !== null; )
      o = i, i = o.return;
    return o.tag === 3 ? o.stateNode : null;
  }
  var Ga = {};
  function WO(o, i, u, p) {
    this.tag = o, this.key = u, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = i, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = p, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Un(o, i, u, p) {
    return new WO(o, i, u, p);
  }
  function Cf(o) {
    return o = o.prototype, !(!o || !o.isReactComponent);
  }
  function Br(o, i) {
    var u = o.alternate;
    return u === null ? (u = Un(
      o.tag,
      i,
      o.key,
      o.mode
    ), u.elementType = o.elementType, u.type = o.type, u.stateNode = o.stateNode, u.alternate = o, o.alternate = u) : (u.pendingProps = i, u.type = o.type, u.flags = 0, u.subtreeFlags = 0, u.deletions = null), u.flags = o.flags & 65011712, u.childLanes = o.childLanes, u.lanes = o.lanes, u.child = o.child, u.memoizedProps = o.memoizedProps, u.memoizedState = o.memoizedState, u.updateQueue = o.updateQueue, i = o.dependencies, u.dependencies = i === null ? null : { lanes: i.lanes, firstContext: i.firstContext }, u.sibling = o.sibling, u.index = o.index, u.ref = o.ref, u.refCleanup = o.refCleanup, u;
  }
  function Bv(o, i) {
    o.flags &= 65011714;
    var u = o.alternate;
    return u === null ? (o.childLanes = 0, o.lanes = i, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = u.childLanes, o.lanes = u.lanes, o.child = u.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = u.memoizedProps, o.memoizedState = u.memoizedState, o.updateQueue = u.updateQueue, o.type = u.type, i = u.dependencies, o.dependencies = i === null ? null : {
      lanes: i.lanes,
      firstContext: i.firstContext
    }), o;
  }
  function vu(o, i, u, p, y, S) {
    var j = 0;
    if (p = o, typeof o == "function") Cf(o) && (j = 1);
    else if (typeof o == "string")
      j = XM(
        o,
        u,
        W.current
      ) ? 26 : o === "html" || o === "head" || o === "body" ? 27 : 5;
    else
      e: switch (o) {
        case I:
          return o = Un(31, u, i, y), o.elementType = I, o.lanes = S, o;
        case x:
          return ca(u.children, y, S, i);
        case w:
          j = 8, y |= 24;
          break;
        case k:
          return o = Un(12, u, i, y | 2), o.elementType = k, o.lanes = S, o;
        case N:
          return o = Un(13, u, i, y), o.elementType = N, o.lanes = S, o;
        case A:
          return o = Un(19, u, i, y), o.elementType = A, o.lanes = S, o;
        default:
          if (typeof o == "object" && o !== null)
            switch (o.$$typeof) {
              case _:
                j = 10;
                break e;
              case E:
                j = 9;
                break e;
              case O:
                j = 11;
                break e;
              case R:
                j = 14;
                break e;
              case D:
                j = 16, p = null;
                break e;
            }
          j = 29, u = Error(
            r(130, o === null ? "null" : typeof o, "")
          ), p = null;
      }
    return i = Un(j, u, i, y), i.elementType = o, i.type = p, i.lanes = S, i;
  }
  function ca(o, i, u, p) {
    return o = Un(7, o, p, i), o.lanes = u, o;
  }
  function Of(o, i, u) {
    return o = Un(6, o, null, i), o.lanes = u, o;
  }
  function Uv(o) {
    var i = Un(18, null, null, 0);
    return i.stateNode = o, i;
  }
  function Mf(o, i, u) {
    return i = Un(
      4,
      o.children !== null ? o.children : [],
      o.key,
      i
    ), i.lanes = u, i.stateNode = {
      containerInfo: o.containerInfo,
      pendingChildren: null,
      implementation: o.implementation
    }, i;
  }
  var Vv = /* @__PURE__ */ new WeakMap();
  function nr(o, i) {
    if (typeof o == "object" && o !== null) {
      var u = Vv.get(o);
      return u !== void 0 ? u : (i = {
        value: o,
        source: i,
        stack: Xe(i)
      }, Vv.set(o, i), i);
    }
    return {
      value: o,
      source: i,
      stack: Xe(i)
    };
  }
  var Ka = [], Ya = 0, yu = null, us = 0, rr = [], or = 0, co = null, Cr = 1, Or = "";
  function Ur(o, i) {
    Ka[Ya++] = us, Ka[Ya++] = yu, yu = o, us = i;
  }
  function Hv(o, i, u) {
    rr[or++] = Cr, rr[or++] = Or, rr[or++] = co, co = o;
    var p = Cr;
    o = Or;
    var y = 32 - Ae(p) - 1;
    p &= ~(1 << y), u += 1;
    var S = 32 - Ae(i) + y;
    if (30 < S) {
      var j = y - y % 5;
      S = (p & (1 << j) - 1).toString(32), p >>= j, y -= j, Cr = 1 << 32 - Ae(i) + y | u << y | p, Or = S + o;
    } else
      Cr = 1 << S | u << y | p, Or = o;
  }
  function Nf(o) {
    o.return !== null && (Ur(o, 1), Hv(o, 1, 0));
  }
  function Af(o) {
    for (; o === yu; )
      yu = Ka[--Ya], Ka[Ya] = null, us = Ka[--Ya], Ka[Ya] = null;
    for (; o === co; )
      co = rr[--or], rr[or] = null, Or = rr[--or], rr[or] = null, Cr = rr[--or], rr[or] = null;
  }
  function Wv(o, i) {
    rr[or++] = Cr, rr[or++] = Or, rr[or++] = co, Cr = i.id, Or = i.overflow, co = o;
  }
  var on = null, yt = null, Ke = !1, fo = null, ar = !1, Rf = Error(r(519));
  function po(o) {
    var i = Error(
      r(
        418,
        1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML",
        ""
      )
    );
    throw cs(nr(i, o)), Rf;
  }
  function qv(o) {
    var i = o.stateNode, u = o.type, p = o.memoizedProps;
    switch (i[en] = o, i[yn] = p, u) {
      case "dialog":
        Ue("cancel", i), Ue("close", i);
        break;
      case "iframe":
      case "object":
      case "embed":
        Ue("load", i);
        break;
      case "video":
      case "audio":
        for (u = 0; u < js.length; u++)
          Ue(js[u], i);
        break;
      case "source":
        Ue("error", i);
        break;
      case "img":
      case "image":
      case "link":
        Ue("error", i), Ue("load", i);
        break;
      case "details":
        Ue("toggle", i);
        break;
      case "input":
        Ue("invalid", i), of(
          i,
          p.value,
          p.defaultValue,
          p.checked,
          p.defaultChecked,
          p.type,
          p.name,
          !0
        );
        break;
      case "select":
        Ue("invalid", i);
        break;
      case "textarea":
        Ue("invalid", i), sv(i, p.value, p.defaultValue, p.children);
    }
    u = p.children, typeof u != "string" && typeof u != "number" && typeof u != "bigint" || i.textContent === "" + u || p.suppressHydrationWarning === !0 || uw(i.textContent, u) ? (p.popover != null && (Ue("beforetoggle", i), Ue("toggle", i)), p.onScroll != null && Ue("scroll", i), p.onScrollEnd != null && Ue("scrollend", i), p.onClick != null && (i.onclick = Lr), i = !0) : i = !1, i || po(o, !0);
  }
  function Gv(o) {
    for (on = o.return; on; )
      switch (on.tag) {
        case 5:
        case 31:
        case 13:
          ar = !1;
          return;
        case 27:
        case 3:
          ar = !0;
          return;
        default:
          on = on.return;
      }
  }
  function Xa(o) {
    if (o !== on) return !1;
    if (!Ke) return Gv(o), Ke = !0, !1;
    var i = o.tag, u;
    if ((u = i !== 3 && i !== 27) && ((u = i === 5) && (u = o.type, u = !(u !== "form" && u !== "button") || Yp(o.type, o.memoizedProps)), u = !u), u && yt && po(o), Gv(o), i === 13) {
      if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(r(317));
      yt = yw(o);
    } else if (i === 31) {
      if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(r(317));
      yt = yw(o);
    } else
      i === 27 ? (i = yt, Oo(o.type) ? (o = em, em = null, yt = o) : yt = i) : yt = on ? ir(o.stateNode.nextSibling) : null;
    return !0;
  }
  function da() {
    yt = on = null, Ke = !1;
  }
  function jf() {
    var o = fo;
    return o !== null && (jn === null ? jn = o : jn.push.apply(
      jn,
      o
    ), fo = null), o;
  }
  function cs(o) {
    fo === null ? fo = [o] : fo.push(o);
  }
  var Pf = F(null), fa = null, Vr = null;
  function mo(o, i, u) {
    U(Pf, i._currentValue), i._currentValue = u;
  }
  function Hr(o) {
    o._currentValue = Pf.current, Y(Pf);
  }
  function Df(o, i, u) {
    for (; o !== null; ) {
      var p = o.alternate;
      if ((o.childLanes & i) !== i ? (o.childLanes |= i, p !== null && (p.childLanes |= i)) : p !== null && (p.childLanes & i) !== i && (p.childLanes |= i), o === u) break;
      o = o.return;
    }
  }
  function If(o, i, u, p) {
    var y = o.child;
    for (y !== null && (y.return = o); y !== null; ) {
      var S = y.dependencies;
      if (S !== null) {
        var j = y.child;
        S = S.firstContext;
        e: for (; S !== null; ) {
          var T = S;
          S = y;
          for (var X = 0; X < i.length; X++)
            if (T.context === i[X]) {
              S.lanes |= u, T = S.alternate, T !== null && (T.lanes |= u), Df(
                S.return,
                u,
                o
              ), p || (j = null);
              break e;
            }
          S = T.next;
        }
      } else if (y.tag === 18) {
        if (j = y.return, j === null) throw Error(r(341));
        j.lanes |= u, S = j.alternate, S !== null && (S.lanes |= u), Df(j, u, o), j = null;
      } else j = y.child;
      if (j !== null) j.return = y;
      else
        for (j = y; j !== null; ) {
          if (j === o) {
            j = null;
            break;
          }
          if (y = j.sibling, y !== null) {
            y.return = j.return, j = y;
            break;
          }
          j = j.return;
        }
      y = j;
    }
  }
  function Ja(o, i, u, p) {
    o = null;
    for (var y = i, S = !1; y !== null; ) {
      if (!S) {
        if ((y.flags & 524288) !== 0) S = !0;
        else if ((y.flags & 262144) !== 0) break;
      }
      if (y.tag === 10) {
        var j = y.alternate;
        if (j === null) throw Error(r(387));
        if (j = j.memoizedProps, j !== null) {
          var T = y.type;
          Bn(y.pendingProps.value, j.value) || (o !== null ? o.push(T) : o = [T]);
        }
      } else if (y === fe.current) {
        if (j = y.alternate, j === null) throw Error(r(387));
        j.memoizedState.memoizedState !== y.memoizedState.memoizedState && (o !== null ? o.push(zs) : o = [zs]);
      }
      y = y.return;
    }
    o !== null && If(
      i,
      o,
      u,
      p
    ), i.flags |= 262144;
  }
  function bu(o) {
    for (o = o.firstContext; o !== null; ) {
      if (!Bn(
        o.context._currentValue,
        o.memoizedValue
      ))
        return !0;
      o = o.next;
    }
    return !1;
  }
  function pa(o) {
    fa = o, Vr = null, o = o.dependencies, o !== null && (o.firstContext = null);
  }
  function an(o) {
    return Kv(fa, o);
  }
  function wu(o, i) {
    return fa === null && pa(o), Kv(o, i);
  }
  function Kv(o, i) {
    var u = i._currentValue;
    if (i = { context: i, memoizedValue: u, next: null }, Vr === null) {
      if (o === null) throw Error(r(308));
      Vr = i, o.dependencies = { lanes: 0, firstContext: i }, o.flags |= 524288;
    } else Vr = Vr.next = i;
    return u;
  }
  var qO = typeof AbortController < "u" ? AbortController : function() {
    var o = [], i = this.signal = {
      aborted: !1,
      addEventListener: function(u, p) {
        o.push(p);
      }
    };
    this.abort = function() {
      i.aborted = !0, o.forEach(function(u) {
        return u();
      });
    };
  }, GO = e.unstable_scheduleCallback, KO = e.unstable_NormalPriority, It = {
    $$typeof: _,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function $f() {
    return {
      controller: new qO(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function ds(o) {
    o.refCount--, o.refCount === 0 && GO(KO, function() {
      o.controller.abort();
    });
  }
  var fs = null, zf = 0, Qa = 0, Za = null;
  function YO(o, i) {
    if (fs === null) {
      var u = fs = [];
      zf = 0, Qa = Fp(), Za = {
        status: "pending",
        value: void 0,
        then: function(p) {
          u.push(p);
        }
      };
    }
    return zf++, i.then(Yv, Yv), i;
  }
  function Yv() {
    if (--zf === 0 && fs !== null) {
      Za !== null && (Za.status = "fulfilled");
      var o = fs;
      fs = null, Qa = 0, Za = null;
      for (var i = 0; i < o.length; i++) (0, o[i])();
    }
  }
  function XO(o, i) {
    var u = [], p = {
      status: "pending",
      value: null,
      reason: null,
      then: function(y) {
        u.push(y);
      }
    };
    return o.then(
      function() {
        p.status = "fulfilled", p.value = i;
        for (var y = 0; y < u.length; y++) (0, u[y])(i);
      },
      function(y) {
        for (p.status = "rejected", p.reason = y, y = 0; y < u.length; y++)
          (0, u[y])(void 0);
      }
    ), p;
  }
  var Xv = $.S;
  $.S = function(o, i) {
    Pb = Ce(), typeof i == "object" && i !== null && typeof i.then == "function" && YO(o, i), Xv !== null && Xv(o, i);
  };
  var ma = F(null);
  function Tf() {
    var o = ma.current;
    return o !== null ? o : ut.pooledCache;
  }
  function xu(o, i) {
    i === null ? U(ma, ma.current) : U(ma, i.pool);
  }
  function Jv() {
    var o = Tf();
    return o === null ? null : { parent: It._currentValue, pool: o };
  }
  var ei = Error(r(460)), Lf = Error(r(474)), Su = Error(r(542)), ku = { then: function() {
  } };
  function Qv(o) {
    return o = o.status, o === "fulfilled" || o === "rejected";
  }
  function Zv(o, i, u) {
    switch (u = o[u], u === void 0 ? o.push(i) : u !== i && (i.then(Lr, Lr), i = u), i.status) {
      case "fulfilled":
        return i.value;
      case "rejected":
        throw o = i.reason, ty(o), o;
      default:
        if (typeof i.status == "string") i.then(Lr, Lr);
        else {
          if (o = ut, o !== null && 100 < o.shellSuspendCounter)
            throw Error(r(482));
          o = i, o.status = "pending", o.then(
            function(p) {
              if (i.status === "pending") {
                var y = i;
                y.status = "fulfilled", y.value = p;
              }
            },
            function(p) {
              if (i.status === "pending") {
                var y = i;
                y.status = "rejected", y.reason = p;
              }
            }
          );
        }
        switch (i.status) {
          case "fulfilled":
            return i.value;
          case "rejected":
            throw o = i.reason, ty(o), o;
        }
        throw ga = i, ei;
    }
  }
  function ha(o) {
    try {
      var i = o._init;
      return i(o._payload);
    } catch (u) {
      throw u !== null && typeof u == "object" && typeof u.then == "function" ? (ga = u, ei) : u;
    }
  }
  var ga = null;
  function ey() {
    if (ga === null) throw Error(r(459));
    var o = ga;
    return ga = null, o;
  }
  function ty(o) {
    if (o === ei || o === Su)
      throw Error(r(483));
  }
  var ti = null, ps = 0;
  function _u(o) {
    var i = ps;
    return ps += 1, ti === null && (ti = []), Zv(ti, o, i);
  }
  function ms(o, i) {
    i = i.props.ref, o.ref = i !== void 0 ? i : null;
  }
  function Eu(o, i) {
    throw i.$$typeof === v ? Error(r(525)) : (o = Object.prototype.toString.call(i), Error(
      r(
        31,
        o === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : o
      )
    ));
  }
  function ny(o) {
    function i(ee, Q) {
      if (o) {
        var te = ee.deletions;
        te === null ? (ee.deletions = [Q], ee.flags |= 16) : te.push(Q);
      }
    }
    function u(ee, Q) {
      if (!o) return null;
      for (; Q !== null; )
        i(ee, Q), Q = Q.sibling;
      return null;
    }
    function p(ee) {
      for (var Q = /* @__PURE__ */ new Map(); ee !== null; )
        ee.key !== null ? Q.set(ee.key, ee) : Q.set(ee.index, ee), ee = ee.sibling;
      return Q;
    }
    function y(ee, Q) {
      return ee = Br(ee, Q), ee.index = 0, ee.sibling = null, ee;
    }
    function S(ee, Q, te) {
      return ee.index = te, o ? (te = ee.alternate, te !== null ? (te = te.index, te < Q ? (ee.flags |= 67108866, Q) : te) : (ee.flags |= 67108866, Q)) : (ee.flags |= 1048576, Q);
    }
    function j(ee) {
      return o && ee.alternate === null && (ee.flags |= 67108866), ee;
    }
    function T(ee, Q, te, de) {
      return Q === null || Q.tag !== 6 ? (Q = Of(te, ee.mode, de), Q.return = ee, Q) : (Q = y(Q, te), Q.return = ee, Q);
    }
    function X(ee, Q, te, de) {
      var Oe = te.type;
      return Oe === x ? ue(
        ee,
        Q,
        te.props.children,
        de,
        te.key
      ) : Q !== null && (Q.elementType === Oe || typeof Oe == "object" && Oe !== null && Oe.$$typeof === D && ha(Oe) === Q.type) ? (Q = y(Q, te.props), ms(Q, te), Q.return = ee, Q) : (Q = vu(
        te.type,
        te.key,
        te.props,
        null,
        ee.mode,
        de
      ), ms(Q, te), Q.return = ee, Q);
    }
    function ne(ee, Q, te, de) {
      return Q === null || Q.tag !== 4 || Q.stateNode.containerInfo !== te.containerInfo || Q.stateNode.implementation !== te.implementation ? (Q = Mf(te, ee.mode, de), Q.return = ee, Q) : (Q = y(Q, te.children || []), Q.return = ee, Q);
    }
    function ue(ee, Q, te, de, Oe) {
      return Q === null || Q.tag !== 7 ? (Q = ca(
        te,
        ee.mode,
        de,
        Oe
      ), Q.return = ee, Q) : (Q = y(Q, te), Q.return = ee, Q);
    }
    function pe(ee, Q, te) {
      if (typeof Q == "string" && Q !== "" || typeof Q == "number" || typeof Q == "bigint")
        return Q = Of(
          "" + Q,
          ee.mode,
          te
        ), Q.return = ee, Q;
      if (typeof Q == "object" && Q !== null) {
        switch (Q.$$typeof) {
          case g:
            return te = vu(
              Q.type,
              Q.key,
              Q.props,
              null,
              ee.mode,
              te
            ), ms(te, Q), te.return = ee, te;
          case b:
            return Q = Mf(
              Q,
              ee.mode,
              te
            ), Q.return = ee, Q;
          case D:
            return Q = ha(Q), pe(ee, Q, te);
        }
        if (G(Q) || P(Q))
          return Q = ca(
            Q,
            ee.mode,
            te,
            null
          ), Q.return = ee, Q;
        if (typeof Q.then == "function")
          return pe(ee, _u(Q), te);
        if (Q.$$typeof === _)
          return pe(
            ee,
            wu(ee, Q),
            te
          );
        Eu(ee, Q);
      }
      return null;
    }
    function ae(ee, Q, te, de) {
      var Oe = Q !== null ? Q.key : null;
      if (typeof te == "string" && te !== "" || typeof te == "number" || typeof te == "bigint")
        return Oe !== null ? null : T(ee, Q, "" + te, de);
      if (typeof te == "object" && te !== null) {
        switch (te.$$typeof) {
          case g:
            return te.key === Oe ? X(ee, Q, te, de) : null;
          case b:
            return te.key === Oe ? ne(ee, Q, te, de) : null;
          case D:
            return te = ha(te), ae(ee, Q, te, de);
        }
        if (G(te) || P(te))
          return Oe !== null ? null : ue(ee, Q, te, de, null);
        if (typeof te.then == "function")
          return ae(
            ee,
            Q,
            _u(te),
            de
          );
        if (te.$$typeof === _)
          return ae(
            ee,
            Q,
            wu(ee, te),
            de
          );
        Eu(ee, te);
      }
      return null;
    }
    function se(ee, Q, te, de, Oe) {
      if (typeof de == "string" && de !== "" || typeof de == "number" || typeof de == "bigint")
        return ee = ee.get(te) || null, T(Q, ee, "" + de, Oe);
      if (typeof de == "object" && de !== null) {
        switch (de.$$typeof) {
          case g:
            return ee = ee.get(
              de.key === null ? te : de.key
            ) || null, X(Q, ee, de, Oe);
          case b:
            return ee = ee.get(
              de.key === null ? te : de.key
            ) || null, ne(Q, ee, de, Oe);
          case D:
            return de = ha(de), se(
              ee,
              Q,
              te,
              de,
              Oe
            );
        }
        if (G(de) || P(de))
          return ee = ee.get(te) || null, ue(Q, ee, de, Oe, null);
        if (typeof de.then == "function")
          return se(
            ee,
            Q,
            te,
            _u(de),
            Oe
          );
        if (de.$$typeof === _)
          return se(
            ee,
            Q,
            te,
            wu(Q, de),
            Oe
          );
        Eu(Q, de);
      }
      return null;
    }
    function we(ee, Q, te, de) {
      for (var Oe = null, Je = null, ke = Q, Le = Q = 0, We = null; ke !== null && Le < te.length; Le++) {
        ke.index > Le ? (We = ke, ke = null) : We = ke.sibling;
        var Qe = ae(
          ee,
          ke,
          te[Le],
          de
        );
        if (Qe === null) {
          ke === null && (ke = We);
          break;
        }
        o && ke && Qe.alternate === null && i(ee, ke), Q = S(Qe, Q, Le), Je === null ? Oe = Qe : Je.sibling = Qe, Je = Qe, ke = We;
      }
      if (Le === te.length)
        return u(ee, ke), Ke && Ur(ee, Le), Oe;
      if (ke === null) {
        for (; Le < te.length; Le++)
          ke = pe(ee, te[Le], de), ke !== null && (Q = S(
            ke,
            Q,
            Le
          ), Je === null ? Oe = ke : Je.sibling = ke, Je = ke);
        return Ke && Ur(ee, Le), Oe;
      }
      for (ke = p(ke); Le < te.length; Le++)
        We = se(
          ke,
          ee,
          Le,
          te[Le],
          de
        ), We !== null && (o && We.alternate !== null && ke.delete(
          We.key === null ? Le : We.key
        ), Q = S(
          We,
          Q,
          Le
        ), Je === null ? Oe = We : Je.sibling = We, Je = We);
      return o && ke.forEach(function(jo) {
        return i(ee, jo);
      }), Ke && Ur(ee, Le), Oe;
    }
    function Ne(ee, Q, te, de) {
      if (te == null) throw Error(r(151));
      for (var Oe = null, Je = null, ke = Q, Le = Q = 0, We = null, Qe = te.next(); ke !== null && !Qe.done; Le++, Qe = te.next()) {
        ke.index > Le ? (We = ke, ke = null) : We = ke.sibling;
        var jo = ae(ee, ke, Qe.value, de);
        if (jo === null) {
          ke === null && (ke = We);
          break;
        }
        o && ke && jo.alternate === null && i(ee, ke), Q = S(jo, Q, Le), Je === null ? Oe = jo : Je.sibling = jo, Je = jo, ke = We;
      }
      if (Qe.done)
        return u(ee, ke), Ke && Ur(ee, Le), Oe;
      if (ke === null) {
        for (; !Qe.done; Le++, Qe = te.next())
          Qe = pe(ee, Qe.value, de), Qe !== null && (Q = S(Qe, Q, Le), Je === null ? Oe = Qe : Je.sibling = Qe, Je = Qe);
        return Ke && Ur(ee, Le), Oe;
      }
      for (ke = p(ke); !Qe.done; Le++, Qe = te.next())
        Qe = se(ke, ee, Le, Qe.value, de), Qe !== null && (o && Qe.alternate !== null && ke.delete(Qe.key === null ? Le : Qe.key), Q = S(Qe, Q, Le), Je === null ? Oe = Qe : Je.sibling = Qe, Je = Qe);
      return o && ke.forEach(function(sN) {
        return i(ee, sN);
      }), Ke && Ur(ee, Le), Oe;
    }
    function st(ee, Q, te, de) {
      if (typeof te == "object" && te !== null && te.type === x && te.key === null && (te = te.props.children), typeof te == "object" && te !== null) {
        switch (te.$$typeof) {
          case g:
            e: {
              for (var Oe = te.key; Q !== null; ) {
                if (Q.key === Oe) {
                  if (Oe = te.type, Oe === x) {
                    if (Q.tag === 7) {
                      u(
                        ee,
                        Q.sibling
                      ), de = y(
                        Q,
                        te.props.children
                      ), de.return = ee, ee = de;
                      break e;
                    }
                  } else if (Q.elementType === Oe || typeof Oe == "object" && Oe !== null && Oe.$$typeof === D && ha(Oe) === Q.type) {
                    u(
                      ee,
                      Q.sibling
                    ), de = y(Q, te.props), ms(de, te), de.return = ee, ee = de;
                    break e;
                  }
                  u(ee, Q);
                  break;
                } else i(ee, Q);
                Q = Q.sibling;
              }
              te.type === x ? (de = ca(
                te.props.children,
                ee.mode,
                de,
                te.key
              ), de.return = ee, ee = de) : (de = vu(
                te.type,
                te.key,
                te.props,
                null,
                ee.mode,
                de
              ), ms(de, te), de.return = ee, ee = de);
            }
            return j(ee);
          case b:
            e: {
              for (Oe = te.key; Q !== null; ) {
                if (Q.key === Oe)
                  if (Q.tag === 4 && Q.stateNode.containerInfo === te.containerInfo && Q.stateNode.implementation === te.implementation) {
                    u(
                      ee,
                      Q.sibling
                    ), de = y(Q, te.children || []), de.return = ee, ee = de;
                    break e;
                  } else {
                    u(ee, Q);
                    break;
                  }
                else i(ee, Q);
                Q = Q.sibling;
              }
              de = Mf(te, ee.mode, de), de.return = ee, ee = de;
            }
            return j(ee);
          case D:
            return te = ha(te), st(
              ee,
              Q,
              te,
              de
            );
        }
        if (G(te))
          return we(
            ee,
            Q,
            te,
            de
          );
        if (P(te)) {
          if (Oe = P(te), typeof Oe != "function") throw Error(r(150));
          return te = Oe.call(te), Ne(
            ee,
            Q,
            te,
            de
          );
        }
        if (typeof te.then == "function")
          return st(
            ee,
            Q,
            _u(te),
            de
          );
        if (te.$$typeof === _)
          return st(
            ee,
            Q,
            wu(ee, te),
            de
          );
        Eu(ee, te);
      }
      return typeof te == "string" && te !== "" || typeof te == "number" || typeof te == "bigint" ? (te = "" + te, Q !== null && Q.tag === 6 ? (u(ee, Q.sibling), de = y(Q, te), de.return = ee, ee = de) : (u(ee, Q), de = Of(te, ee.mode, de), de.return = ee, ee = de), j(ee)) : u(ee, Q);
    }
    return function(ee, Q, te, de) {
      try {
        ps = 0;
        var Oe = st(
          ee,
          Q,
          te,
          de
        );
        return ti = null, Oe;
      } catch (ke) {
        if (ke === ei || ke === Su) throw ke;
        var Je = Un(29, ke, null, ee.mode);
        return Je.lanes = de, Je.return = ee, Je;
      }
    };
  }
  var va = ny(!0), ry = ny(!1), ho = !1;
  function Ff(o) {
    o.updateQueue = {
      baseState: o.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function Bf(o, i) {
    o = o.updateQueue, i.updateQueue === o && (i.updateQueue = {
      baseState: o.baseState,
      firstBaseUpdate: o.firstBaseUpdate,
      lastBaseUpdate: o.lastBaseUpdate,
      shared: o.shared,
      callbacks: null
    });
  }
  function go(o) {
    return { lane: o, tag: 0, payload: null, callback: null, next: null };
  }
  function vo(o, i, u) {
    var p = o.updateQueue;
    if (p === null) return null;
    if (p = p.shared, (Ze & 2) !== 0) {
      var y = p.pending;
      return y === null ? i.next = i : (i.next = y.next, y.next = i), p.pending = i, i = gu(o), Fv(o, null, u), i;
    }
    return hu(o, p, i, u), gu(o);
  }
  function hs(o, i, u) {
    if (i = i.updateQueue, i !== null && (i = i.shared, (u & 4194048) !== 0)) {
      var p = i.lanes;
      p &= o.pendingLanes, u |= p, i.lanes = u, Kd(o, u);
    }
  }
  function Uf(o, i) {
    var u = o.updateQueue, p = o.alternate;
    if (p !== null && (p = p.updateQueue, u === p)) {
      var y = null, S = null;
      if (u = u.firstBaseUpdate, u !== null) {
        do {
          var j = {
            lane: u.lane,
            tag: u.tag,
            payload: u.payload,
            callback: null,
            next: null
          };
          S === null ? y = S = j : S = S.next = j, u = u.next;
        } while (u !== null);
        S === null ? y = S = i : S = S.next = i;
      } else y = S = i;
      u = {
        baseState: p.baseState,
        firstBaseUpdate: y,
        lastBaseUpdate: S,
        shared: p.shared,
        callbacks: p.callbacks
      }, o.updateQueue = u;
      return;
    }
    o = u.lastBaseUpdate, o === null ? u.firstBaseUpdate = i : o.next = i, u.lastBaseUpdate = i;
  }
  var Vf = !1;
  function gs() {
    if (Vf) {
      var o = Za;
      if (o !== null) throw o;
    }
  }
  function vs(o, i, u, p) {
    Vf = !1;
    var y = o.updateQueue;
    ho = !1;
    var S = y.firstBaseUpdate, j = y.lastBaseUpdate, T = y.shared.pending;
    if (T !== null) {
      y.shared.pending = null;
      var X = T, ne = X.next;
      X.next = null, j === null ? S = ne : j.next = ne, j = X;
      var ue = o.alternate;
      ue !== null && (ue = ue.updateQueue, T = ue.lastBaseUpdate, T !== j && (T === null ? ue.firstBaseUpdate = ne : T.next = ne, ue.lastBaseUpdate = X));
    }
    if (S !== null) {
      var pe = y.baseState;
      j = 0, ue = ne = X = null, T = S;
      do {
        var ae = T.lane & -536870913, se = ae !== T.lane;
        if (se ? (He & ae) === ae : (p & ae) === ae) {
          ae !== 0 && ae === Qa && (Vf = !0), ue !== null && (ue = ue.next = {
            lane: 0,
            tag: T.tag,
            payload: T.payload,
            callback: null,
            next: null
          });
          e: {
            var we = o, Ne = T;
            ae = i;
            var st = u;
            switch (Ne.tag) {
              case 1:
                if (we = Ne.payload, typeof we == "function") {
                  pe = we.call(st, pe, ae);
                  break e;
                }
                pe = we;
                break e;
              case 3:
                we.flags = we.flags & -65537 | 128;
              case 0:
                if (we = Ne.payload, ae = typeof we == "function" ? we.call(st, pe, ae) : we, ae == null) break e;
                pe = h({}, pe, ae);
                break e;
              case 2:
                ho = !0;
            }
          }
          ae = T.callback, ae !== null && (o.flags |= 64, se && (o.flags |= 8192), se = y.callbacks, se === null ? y.callbacks = [ae] : se.push(ae));
        } else
          se = {
            lane: ae,
            tag: T.tag,
            payload: T.payload,
            callback: T.callback,
            next: null
          }, ue === null ? (ne = ue = se, X = pe) : ue = ue.next = se, j |= ae;
        if (T = T.next, T === null) {
          if (T = y.shared.pending, T === null)
            break;
          se = T, T = se.next, se.next = null, y.lastBaseUpdate = se, y.shared.pending = null;
        }
      } while (!0);
      ue === null && (X = pe), y.baseState = X, y.firstBaseUpdate = ne, y.lastBaseUpdate = ue, S === null && (y.shared.lanes = 0), So |= j, o.lanes = j, o.memoizedState = pe;
    }
  }
  function oy(o, i) {
    if (typeof o != "function")
      throw Error(r(191, o));
    o.call(i);
  }
  function ay(o, i) {
    var u = o.callbacks;
    if (u !== null)
      for (o.callbacks = null, o = 0; o < u.length; o++)
        oy(u[o], i);
  }
  var ni = F(null), Cu = F(0);
  function iy(o, i) {
    o = Zr, U(Cu, o), U(ni, i), Zr = o | i.baseLanes;
  }
  function Hf() {
    U(Cu, Zr), U(ni, ni.current);
  }
  function Wf() {
    Zr = Cu.current, Y(ni), Y(Cu);
  }
  var Vn = F(null), fr = null;
  function yo(o) {
    var i = o.alternate;
    U(At, At.current & 1), U(Vn, o), fr === null && (i === null || ni.current !== null || i.memoizedState !== null) && (fr = o);
  }
  function qf(o) {
    U(At, At.current), U(Vn, o), fr === null && (fr = o);
  }
  function sy(o) {
    o.tag === 22 ? (U(At, At.current), U(Vn, o), fr === null && (fr = o)) : bo();
  }
  function bo() {
    U(At, At.current), U(Vn, Vn.current);
  }
  function Hn(o) {
    Y(Vn), fr === o && (fr = null), Y(At);
  }
  var At = F(0);
  function Ou(o) {
    for (var i = o; i !== null; ) {
      if (i.tag === 13) {
        var u = i.memoizedState;
        if (u !== null && (u = u.dehydrated, u === null || Qp(u) || Zp(u)))
          return i;
      } else if (i.tag === 19 && (i.memoizedProps.revealOrder === "forwards" || i.memoizedProps.revealOrder === "backwards" || i.memoizedProps.revealOrder === "unstable_legacy-backwards" || i.memoizedProps.revealOrder === "together")) {
        if ((i.flags & 128) !== 0) return i;
      } else if (i.child !== null) {
        i.child.return = i, i = i.child;
        continue;
      }
      if (i === o) break;
      for (; i.sibling === null; ) {
        if (i.return === null || i.return === o) return null;
        i = i.return;
      }
      i.sibling.return = i.return, i = i.sibling;
    }
    return null;
  }
  var Wr = 0, ze = null, at = null, $t = null, Mu = !1, ri = !1, ya = !1, Nu = 0, ys = 0, oi = null, JO = 0;
  function kt() {
    throw Error(r(321));
  }
  function Gf(o, i) {
    if (i === null) return !1;
    for (var u = 0; u < i.length && u < o.length; u++)
      if (!Bn(o[u], i[u])) return !1;
    return !0;
  }
  function Kf(o, i, u, p, y, S) {
    return Wr = S, ze = i, i.memoizedState = null, i.updateQueue = null, i.lanes = 0, $.H = o === null || o.memoizedState === null ? Hy : up, ya = !1, S = u(p, y), ya = !1, ri && (S = uy(
      i,
      u,
      p,
      y
    )), ly(o), S;
  }
  function ly(o) {
    $.H = xs;
    var i = at !== null && at.next !== null;
    if (Wr = 0, $t = at = ze = null, Mu = !1, ys = 0, oi = null, i) throw Error(r(300));
    o === null || zt || (o = o.dependencies, o !== null && bu(o) && (zt = !0));
  }
  function uy(o, i, u, p) {
    ze = o;
    var y = 0;
    do {
      if (ri && (oi = null), ys = 0, ri = !1, 25 <= y) throw Error(r(301));
      if (y += 1, $t = at = null, o.updateQueue != null) {
        var S = o.updateQueue;
        S.lastEffect = null, S.events = null, S.stores = null, S.memoCache != null && (S.memoCache.index = 0);
      }
      $.H = Wy, S = i(u, p);
    } while (ri);
    return S;
  }
  function QO() {
    var o = $.H, i = o.useState()[0];
    return i = typeof i.then == "function" ? bs(i) : i, o = o.useState()[0], (at !== null ? at.memoizedState : null) !== o && (ze.flags |= 1024), i;
  }
  function Yf() {
    var o = Nu !== 0;
    return Nu = 0, o;
  }
  function Xf(o, i, u) {
    i.updateQueue = o.updateQueue, i.flags &= -2053, o.lanes &= ~u;
  }
  function Jf(o) {
    if (Mu) {
      for (o = o.memoizedState; o !== null; ) {
        var i = o.queue;
        i !== null && (i.pending = null), o = o.next;
      }
      Mu = !1;
    }
    Wr = 0, $t = at = ze = null, ri = !1, ys = Nu = 0, oi = null;
  }
  function bn() {
    var o = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return $t === null ? ze.memoizedState = $t = o : $t = $t.next = o, $t;
  }
  function Rt() {
    if (at === null) {
      var o = ze.alternate;
      o = o !== null ? o.memoizedState : null;
    } else o = at.next;
    var i = $t === null ? ze.memoizedState : $t.next;
    if (i !== null)
      $t = i, at = o;
    else {
      if (o === null)
        throw ze.alternate === null ? Error(r(467)) : Error(r(310));
      at = o, o = {
        memoizedState: at.memoizedState,
        baseState: at.baseState,
        baseQueue: at.baseQueue,
        queue: at.queue,
        next: null
      }, $t === null ? ze.memoizedState = $t = o : $t = $t.next = o;
    }
    return $t;
  }
  function Au() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function bs(o) {
    var i = ys;
    return ys += 1, oi === null && (oi = []), o = Zv(oi, o, i), i = ze, ($t === null ? i.memoizedState : $t.next) === null && (i = i.alternate, $.H = i === null || i.memoizedState === null ? Hy : up), o;
  }
  function Ru(o) {
    if (o !== null && typeof o == "object") {
      if (typeof o.then == "function") return bs(o);
      if (o.$$typeof === _) return an(o);
    }
    throw Error(r(438, String(o)));
  }
  function Qf(o) {
    var i = null, u = ze.updateQueue;
    if (u !== null && (i = u.memoCache), i == null) {
      var p = ze.alternate;
      p !== null && (p = p.updateQueue, p !== null && (p = p.memoCache, p != null && (i = {
        data: p.data.map(function(y) {
          return y.slice();
        }),
        index: 0
      })));
    }
    if (i == null && (i = { data: [], index: 0 }), u === null && (u = Au(), ze.updateQueue = u), u.memoCache = i, u = i.data[i.index], u === void 0)
      for (u = i.data[i.index] = Array(o), p = 0; p < o; p++)
        u[p] = z;
    return i.index++, u;
  }
  function qr(o, i) {
    return typeof i == "function" ? i(o) : i;
  }
  function ju(o) {
    var i = Rt();
    return Zf(i, at, o);
  }
  function Zf(o, i, u) {
    var p = o.queue;
    if (p === null) throw Error(r(311));
    p.lastRenderedReducer = u;
    var y = o.baseQueue, S = p.pending;
    if (S !== null) {
      if (y !== null) {
        var j = y.next;
        y.next = S.next, S.next = j;
      }
      i.baseQueue = y = S, p.pending = null;
    }
    if (S = o.baseState, y === null) o.memoizedState = S;
    else {
      i = y.next;
      var T = j = null, X = null, ne = i, ue = !1;
      do {
        var pe = ne.lane & -536870913;
        if (pe !== ne.lane ? (He & pe) === pe : (Wr & pe) === pe) {
          var ae = ne.revertLane;
          if (ae === 0)
            X !== null && (X = X.next = {
              lane: 0,
              revertLane: 0,
              gesture: null,
              action: ne.action,
              hasEagerState: ne.hasEagerState,
              eagerState: ne.eagerState,
              next: null
            }), pe === Qa && (ue = !0);
          else if ((Wr & ae) === ae) {
            ne = ne.next, ae === Qa && (ue = !0);
            continue;
          } else
            pe = {
              lane: 0,
              revertLane: ne.revertLane,
              gesture: null,
              action: ne.action,
              hasEagerState: ne.hasEagerState,
              eagerState: ne.eagerState,
              next: null
            }, X === null ? (T = X = pe, j = S) : X = X.next = pe, ze.lanes |= ae, So |= ae;
          pe = ne.action, ya && u(S, pe), S = ne.hasEagerState ? ne.eagerState : u(S, pe);
        } else
          ae = {
            lane: pe,
            revertLane: ne.revertLane,
            gesture: ne.gesture,
            action: ne.action,
            hasEagerState: ne.hasEagerState,
            eagerState: ne.eagerState,
            next: null
          }, X === null ? (T = X = ae, j = S) : X = X.next = ae, ze.lanes |= pe, So |= pe;
        ne = ne.next;
      } while (ne !== null && ne !== i);
      if (X === null ? j = S : X.next = T, !Bn(S, o.memoizedState) && (zt = !0, ue && (u = Za, u !== null)))
        throw u;
      o.memoizedState = S, o.baseState = j, o.baseQueue = X, p.lastRenderedState = S;
    }
    return y === null && (p.lanes = 0), [o.memoizedState, p.dispatch];
  }
  function ep(o) {
    var i = Rt(), u = i.queue;
    if (u === null) throw Error(r(311));
    u.lastRenderedReducer = o;
    var p = u.dispatch, y = u.pending, S = i.memoizedState;
    if (y !== null) {
      u.pending = null;
      var j = y = y.next;
      do
        S = o(S, j.action), j = j.next;
      while (j !== y);
      Bn(S, i.memoizedState) || (zt = !0), i.memoizedState = S, i.baseQueue === null && (i.baseState = S), u.lastRenderedState = S;
    }
    return [S, p];
  }
  function cy(o, i, u) {
    var p = ze, y = Rt(), S = Ke;
    if (S) {
      if (u === void 0) throw Error(r(407));
      u = u();
    } else u = i();
    var j = !Bn(
      (at || y).memoizedState,
      u
    );
    if (j && (y.memoizedState = u, zt = !0), y = y.queue, rp(py.bind(null, p, y, o), [
      o
    ]), y.getSnapshot !== i || j || $t !== null && $t.memoizedState.tag & 1) {
      if (p.flags |= 2048, ai(
        9,
        { destroy: void 0 },
        fy.bind(
          null,
          p,
          y,
          u,
          i
        ),
        null
      ), ut === null) throw Error(r(349));
      S || (Wr & 127) !== 0 || dy(p, i, u);
    }
    return u;
  }
  function dy(o, i, u) {
    o.flags |= 16384, o = { getSnapshot: i, value: u }, i = ze.updateQueue, i === null ? (i = Au(), ze.updateQueue = i, i.stores = [o]) : (u = i.stores, u === null ? i.stores = [o] : u.push(o));
  }
  function fy(o, i, u, p) {
    i.value = u, i.getSnapshot = p, my(i) && hy(o);
  }
  function py(o, i, u) {
    return u(function() {
      my(i) && hy(o);
    });
  }
  function my(o) {
    var i = o.getSnapshot;
    o = o.value;
    try {
      var u = i();
      return !Bn(o, u);
    } catch {
      return !0;
    }
  }
  function hy(o) {
    var i = ua(o, 2);
    i !== null && Pn(i, o, 2);
  }
  function tp(o) {
    var i = bn();
    if (typeof o == "function") {
      var u = o;
      if (o = u(), ya) {
        kn(!0);
        try {
          u();
        } finally {
          kn(!1);
        }
      }
    }
    return i.memoizedState = i.baseState = o, i.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: qr,
      lastRenderedState: o
    }, i;
  }
  function gy(o, i, u, p) {
    return o.baseState = u, Zf(
      o,
      at,
      typeof p == "function" ? p : qr
    );
  }
  function ZO(o, i, u, p, y) {
    if (Iu(o)) throw Error(r(485));
    if (o = i.action, o !== null) {
      var S = {
        payload: y,
        action: o,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(j) {
          S.listeners.push(j);
        }
      };
      $.T !== null ? u(!0) : S.isTransition = !1, p(S), u = i.pending, u === null ? (S.next = i.pending = S, vy(i, S)) : (S.next = u.next, i.pending = u.next = S);
    }
  }
  function vy(o, i) {
    var u = i.action, p = i.payload, y = o.state;
    if (i.isTransition) {
      var S = $.T, j = {};
      $.T = j;
      try {
        var T = u(y, p), X = $.S;
        X !== null && X(j, T), yy(o, i, T);
      } catch (ne) {
        np(o, i, ne);
      } finally {
        S !== null && j.types !== null && (S.types = j.types), $.T = S;
      }
    } else
      try {
        S = u(y, p), yy(o, i, S);
      } catch (ne) {
        np(o, i, ne);
      }
  }
  function yy(o, i, u) {
    u !== null && typeof u == "object" && typeof u.then == "function" ? u.then(
      function(p) {
        by(o, i, p);
      },
      function(p) {
        return np(o, i, p);
      }
    ) : by(o, i, u);
  }
  function by(o, i, u) {
    i.status = "fulfilled", i.value = u, wy(i), o.state = u, i = o.pending, i !== null && (u = i.next, u === i ? o.pending = null : (u = u.next, i.next = u, vy(o, u)));
  }
  function np(o, i, u) {
    var p = o.pending;
    if (o.pending = null, p !== null) {
      p = p.next;
      do
        i.status = "rejected", i.reason = u, wy(i), i = i.next;
      while (i !== p);
    }
    o.action = null;
  }
  function wy(o) {
    o = o.listeners;
    for (var i = 0; i < o.length; i++) (0, o[i])();
  }
  function xy(o, i) {
    return i;
  }
  function Sy(o, i) {
    if (Ke) {
      var u = ut.formState;
      if (u !== null) {
        e: {
          var p = ze;
          if (Ke) {
            if (yt) {
              t: {
                for (var y = yt, S = ar; y.nodeType !== 8; ) {
                  if (!S) {
                    y = null;
                    break t;
                  }
                  if (y = ir(
                    y.nextSibling
                  ), y === null) {
                    y = null;
                    break t;
                  }
                }
                S = y.data, y = S === "F!" || S === "F" ? y : null;
              }
              if (y) {
                yt = ir(
                  y.nextSibling
                ), p = y.data === "F!";
                break e;
              }
            }
            po(p);
          }
          p = !1;
        }
        p && (i = u[0]);
      }
    }
    return u = bn(), u.memoizedState = u.baseState = i, p = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: xy,
      lastRenderedState: i
    }, u.queue = p, u = By.bind(
      null,
      ze,
      p
    ), p.dispatch = u, p = tp(!1), S = lp.bind(
      null,
      ze,
      !1,
      p.queue
    ), p = bn(), y = {
      state: i,
      dispatch: null,
      action: o,
      pending: null
    }, p.queue = y, u = ZO.bind(
      null,
      ze,
      y,
      S,
      u
    ), y.dispatch = u, p.memoizedState = o, [i, u, !1];
  }
  function ky(o) {
    var i = Rt();
    return _y(i, at, o);
  }
  function _y(o, i, u) {
    if (i = Zf(
      o,
      i,
      xy
    )[0], o = ju(qr)[0], typeof i == "object" && i !== null && typeof i.then == "function")
      try {
        var p = bs(i);
      } catch (j) {
        throw j === ei ? Su : j;
      }
    else p = i;
    i = Rt();
    var y = i.queue, S = y.dispatch;
    return u !== i.memoizedState && (ze.flags |= 2048, ai(
      9,
      { destroy: void 0 },
      eM.bind(null, y, u),
      null
    )), [p, S, o];
  }
  function eM(o, i) {
    o.action = i;
  }
  function Ey(o) {
    var i = Rt(), u = at;
    if (u !== null)
      return _y(i, u, o);
    Rt(), i = i.memoizedState, u = Rt();
    var p = u.queue.dispatch;
    return u.memoizedState = o, [i, p, !1];
  }
  function ai(o, i, u, p) {
    return o = { tag: o, create: u, deps: p, inst: i, next: null }, i = ze.updateQueue, i === null && (i = Au(), ze.updateQueue = i), u = i.lastEffect, u === null ? i.lastEffect = o.next = o : (p = u.next, u.next = o, o.next = p, i.lastEffect = o), o;
  }
  function Cy() {
    return Rt().memoizedState;
  }
  function Pu(o, i, u, p) {
    var y = bn();
    ze.flags |= o, y.memoizedState = ai(
      1 | i,
      { destroy: void 0 },
      u,
      p === void 0 ? null : p
    );
  }
  function Du(o, i, u, p) {
    var y = Rt();
    p = p === void 0 ? null : p;
    var S = y.memoizedState.inst;
    at !== null && p !== null && Gf(p, at.memoizedState.deps) ? y.memoizedState = ai(i, S, u, p) : (ze.flags |= o, y.memoizedState = ai(
      1 | i,
      S,
      u,
      p
    ));
  }
  function Oy(o, i) {
    Pu(8390656, 8, o, i);
  }
  function rp(o, i) {
    Du(2048, 8, o, i);
  }
  function tM(o) {
    ze.flags |= 4;
    var i = ze.updateQueue;
    if (i === null)
      i = Au(), ze.updateQueue = i, i.events = [o];
    else {
      var u = i.events;
      u === null ? i.events = [o] : u.push(o);
    }
  }
  function My(o) {
    var i = Rt().memoizedState;
    return tM({ ref: i, nextImpl: o }), function() {
      if ((Ze & 2) !== 0) throw Error(r(440));
      return i.impl.apply(void 0, arguments);
    };
  }
  function Ny(o, i) {
    return Du(4, 2, o, i);
  }
  function Ay(o, i) {
    return Du(4, 4, o, i);
  }
  function Ry(o, i) {
    if (typeof i == "function") {
      o = o();
      var u = i(o);
      return function() {
        typeof u == "function" ? u() : i(null);
      };
    }
    if (i != null)
      return o = o(), i.current = o, function() {
        i.current = null;
      };
  }
  function jy(o, i, u) {
    u = u != null ? u.concat([o]) : null, Du(4, 4, Ry.bind(null, i, o), u);
  }
  function op() {
  }
  function Py(o, i) {
    var u = Rt();
    i = i === void 0 ? null : i;
    var p = u.memoizedState;
    return i !== null && Gf(i, p[1]) ? p[0] : (u.memoizedState = [o, i], o);
  }
  function Dy(o, i) {
    var u = Rt();
    i = i === void 0 ? null : i;
    var p = u.memoizedState;
    if (i !== null && Gf(i, p[1]))
      return p[0];
    if (p = o(), ya) {
      kn(!0);
      try {
        o();
      } finally {
        kn(!1);
      }
    }
    return u.memoizedState = [p, i], p;
  }
  function ap(o, i, u) {
    return u === void 0 || (Wr & 1073741824) !== 0 && (He & 261930) === 0 ? o.memoizedState = i : (o.memoizedState = u, o = Ib(), ze.lanes |= o, So |= o, u);
  }
  function Iy(o, i, u, p) {
    return Bn(u, i) ? u : ni.current !== null ? (o = ap(o, u, p), Bn(o, i) || (zt = !0), o) : (Wr & 42) === 0 || (Wr & 1073741824) !== 0 && (He & 261930) === 0 ? (zt = !0, o.memoizedState = u) : (o = Ib(), ze.lanes |= o, So |= o, i);
  }
  function $y(o, i, u, p, y) {
    var S = K.p;
    K.p = S !== 0 && 8 > S ? S : 8;
    var j = $.T, T = {};
    $.T = T, lp(o, !1, i, u);
    try {
      var X = y(), ne = $.S;
      if (ne !== null && ne(T, X), X !== null && typeof X == "object" && typeof X.then == "function") {
        var ue = XO(
          X,
          p
        );
        ws(
          o,
          i,
          ue,
          Gn(o)
        );
      } else
        ws(
          o,
          i,
          p,
          Gn(o)
        );
    } catch (pe) {
      ws(
        o,
        i,
        { then: function() {
        }, status: "rejected", reason: pe },
        Gn()
      );
    } finally {
      K.p = S, j !== null && T.types !== null && (j.types = T.types), $.T = j;
    }
  }
  function nM() {
  }
  function ip(o, i, u, p) {
    if (o.tag !== 5) throw Error(r(476));
    var y = zy(o).queue;
    $y(
      o,
      y,
      i,
      q,
      u === null ? nM : function() {
        return Ty(o), u(p);
      }
    );
  }
  function zy(o) {
    var i = o.memoizedState;
    if (i !== null) return i;
    i = {
      memoizedState: q,
      baseState: q,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: qr,
        lastRenderedState: q
      },
      next: null
    };
    var u = {};
    return i.next = {
      memoizedState: u,
      baseState: u,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: qr,
        lastRenderedState: u
      },
      next: null
    }, o.memoizedState = i, o = o.alternate, o !== null && (o.memoizedState = i), i;
  }
  function Ty(o) {
    var i = zy(o);
    i.next === null && (i = o.alternate.memoizedState), ws(
      o,
      i.next.queue,
      {},
      Gn()
    );
  }
  function sp() {
    return an(zs);
  }
  function Ly() {
    return Rt().memoizedState;
  }
  function Fy() {
    return Rt().memoizedState;
  }
  function rM(o) {
    for (var i = o.return; i !== null; ) {
      switch (i.tag) {
        case 24:
        case 3:
          var u = Gn();
          o = go(u);
          var p = vo(i, o, u);
          p !== null && (Pn(p, i, u), hs(p, i, u)), i = { cache: $f() }, o.payload = i;
          return;
      }
      i = i.return;
    }
  }
  function oM(o, i, u) {
    var p = Gn();
    u = {
      lane: p,
      revertLane: 0,
      gesture: null,
      action: u,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Iu(o) ? Uy(i, u) : (u = Ef(o, i, u, p), u !== null && (Pn(u, o, p), Vy(u, i, p)));
  }
  function By(o, i, u) {
    var p = Gn();
    ws(o, i, u, p);
  }
  function ws(o, i, u, p) {
    var y = {
      lane: p,
      revertLane: 0,
      gesture: null,
      action: u,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (Iu(o)) Uy(i, y);
    else {
      var S = o.alternate;
      if (o.lanes === 0 && (S === null || S.lanes === 0) && (S = i.lastRenderedReducer, S !== null))
        try {
          var j = i.lastRenderedState, T = S(j, u);
          if (y.hasEagerState = !0, y.eagerState = T, Bn(T, j))
            return hu(o, i, y, 0), ut === null && mu(), !1;
        } catch {
        }
      if (u = Ef(o, i, y, p), u !== null)
        return Pn(u, o, p), Vy(u, i, p), !0;
    }
    return !1;
  }
  function lp(o, i, u, p) {
    if (p = {
      lane: 2,
      revertLane: Fp(),
      gesture: null,
      action: p,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Iu(o)) {
      if (i) throw Error(r(479));
    } else
      i = Ef(
        o,
        u,
        p,
        2
      ), i !== null && Pn(i, o, 2);
  }
  function Iu(o) {
    var i = o.alternate;
    return o === ze || i !== null && i === ze;
  }
  function Uy(o, i) {
    ri = Mu = !0;
    var u = o.pending;
    u === null ? i.next = i : (i.next = u.next, u.next = i), o.pending = i;
  }
  function Vy(o, i, u) {
    if ((u & 4194048) !== 0) {
      var p = i.lanes;
      p &= o.pendingLanes, u |= p, i.lanes = u, Kd(o, u);
    }
  }
  var xs = {
    readContext: an,
    use: Ru,
    useCallback: kt,
    useContext: kt,
    useEffect: kt,
    useImperativeHandle: kt,
    useLayoutEffect: kt,
    useInsertionEffect: kt,
    useMemo: kt,
    useReducer: kt,
    useRef: kt,
    useState: kt,
    useDebugValue: kt,
    useDeferredValue: kt,
    useTransition: kt,
    useSyncExternalStore: kt,
    useId: kt,
    useHostTransitionStatus: kt,
    useFormState: kt,
    useActionState: kt,
    useOptimistic: kt,
    useMemoCache: kt,
    useCacheRefresh: kt
  };
  xs.useEffectEvent = kt;
  var Hy = {
    readContext: an,
    use: Ru,
    useCallback: function(o, i) {
      return bn().memoizedState = [
        o,
        i === void 0 ? null : i
      ], o;
    },
    useContext: an,
    useEffect: Oy,
    useImperativeHandle: function(o, i, u) {
      u = u != null ? u.concat([o]) : null, Pu(
        4194308,
        4,
        Ry.bind(null, i, o),
        u
      );
    },
    useLayoutEffect: function(o, i) {
      return Pu(4194308, 4, o, i);
    },
    useInsertionEffect: function(o, i) {
      Pu(4, 2, o, i);
    },
    useMemo: function(o, i) {
      var u = bn();
      i = i === void 0 ? null : i;
      var p = o();
      if (ya) {
        kn(!0);
        try {
          o();
        } finally {
          kn(!1);
        }
      }
      return u.memoizedState = [p, i], p;
    },
    useReducer: function(o, i, u) {
      var p = bn();
      if (u !== void 0) {
        var y = u(i);
        if (ya) {
          kn(!0);
          try {
            u(i);
          } finally {
            kn(!1);
          }
        }
      } else y = i;
      return p.memoizedState = p.baseState = y, o = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: o,
        lastRenderedState: y
      }, p.queue = o, o = o.dispatch = oM.bind(
        null,
        ze,
        o
      ), [p.memoizedState, o];
    },
    useRef: function(o) {
      var i = bn();
      return o = { current: o }, i.memoizedState = o;
    },
    useState: function(o) {
      o = tp(o);
      var i = o.queue, u = By.bind(null, ze, i);
      return i.dispatch = u, [o.memoizedState, u];
    },
    useDebugValue: op,
    useDeferredValue: function(o, i) {
      var u = bn();
      return ap(u, o, i);
    },
    useTransition: function() {
      var o = tp(!1);
      return o = $y.bind(
        null,
        ze,
        o.queue,
        !0,
        !1
      ), bn().memoizedState = o, [!1, o];
    },
    useSyncExternalStore: function(o, i, u) {
      var p = ze, y = bn();
      if (Ke) {
        if (u === void 0)
          throw Error(r(407));
        u = u();
      } else {
        if (u = i(), ut === null)
          throw Error(r(349));
        (He & 127) !== 0 || dy(p, i, u);
      }
      y.memoizedState = u;
      var S = { value: u, getSnapshot: i };
      return y.queue = S, Oy(py.bind(null, p, S, o), [
        o
      ]), p.flags |= 2048, ai(
        9,
        { destroy: void 0 },
        fy.bind(
          null,
          p,
          S,
          u,
          i
        ),
        null
      ), u;
    },
    useId: function() {
      var o = bn(), i = ut.identifierPrefix;
      if (Ke) {
        var u = Or, p = Cr;
        u = (p & ~(1 << 32 - Ae(p) - 1)).toString(32) + u, i = "_" + i + "R_" + u, u = Nu++, 0 < u && (i += "H" + u.toString(32)), i += "_";
      } else
        u = JO++, i = "_" + i + "r_" + u.toString(32) + "_";
      return o.memoizedState = i;
    },
    useHostTransitionStatus: sp,
    useFormState: Sy,
    useActionState: Sy,
    useOptimistic: function(o) {
      var i = bn();
      i.memoizedState = i.baseState = o;
      var u = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return i.queue = u, i = lp.bind(
        null,
        ze,
        !0,
        u
      ), u.dispatch = i, [o, i];
    },
    useMemoCache: Qf,
    useCacheRefresh: function() {
      return bn().memoizedState = rM.bind(
        null,
        ze
      );
    },
    useEffectEvent: function(o) {
      var i = bn(), u = { impl: o };
      return i.memoizedState = u, function() {
        if ((Ze & 2) !== 0)
          throw Error(r(440));
        return u.impl.apply(void 0, arguments);
      };
    }
  }, up = {
    readContext: an,
    use: Ru,
    useCallback: Py,
    useContext: an,
    useEffect: rp,
    useImperativeHandle: jy,
    useInsertionEffect: Ny,
    useLayoutEffect: Ay,
    useMemo: Dy,
    useReducer: ju,
    useRef: Cy,
    useState: function() {
      return ju(qr);
    },
    useDebugValue: op,
    useDeferredValue: function(o, i) {
      var u = Rt();
      return Iy(
        u,
        at.memoizedState,
        o,
        i
      );
    },
    useTransition: function() {
      var o = ju(qr)[0], i = Rt().memoizedState;
      return [
        typeof o == "boolean" ? o : bs(o),
        i
      ];
    },
    useSyncExternalStore: cy,
    useId: Ly,
    useHostTransitionStatus: sp,
    useFormState: ky,
    useActionState: ky,
    useOptimistic: function(o, i) {
      var u = Rt();
      return gy(u, at, o, i);
    },
    useMemoCache: Qf,
    useCacheRefresh: Fy
  };
  up.useEffectEvent = My;
  var Wy = {
    readContext: an,
    use: Ru,
    useCallback: Py,
    useContext: an,
    useEffect: rp,
    useImperativeHandle: jy,
    useInsertionEffect: Ny,
    useLayoutEffect: Ay,
    useMemo: Dy,
    useReducer: ep,
    useRef: Cy,
    useState: function() {
      return ep(qr);
    },
    useDebugValue: op,
    useDeferredValue: function(o, i) {
      var u = Rt();
      return at === null ? ap(u, o, i) : Iy(
        u,
        at.memoizedState,
        o,
        i
      );
    },
    useTransition: function() {
      var o = ep(qr)[0], i = Rt().memoizedState;
      return [
        typeof o == "boolean" ? o : bs(o),
        i
      ];
    },
    useSyncExternalStore: cy,
    useId: Ly,
    useHostTransitionStatus: sp,
    useFormState: Ey,
    useActionState: Ey,
    useOptimistic: function(o, i) {
      var u = Rt();
      return at !== null ? gy(u, at, o, i) : (u.baseState = o, [o, u.queue.dispatch]);
    },
    useMemoCache: Qf,
    useCacheRefresh: Fy
  };
  Wy.useEffectEvent = My;
  function cp(o, i, u, p) {
    i = o.memoizedState, u = u(p, i), u = u == null ? i : h({}, i, u), o.memoizedState = u, o.lanes === 0 && (o.updateQueue.baseState = u);
  }
  var dp = {
    enqueueSetState: function(o, i, u) {
      o = o._reactInternals;
      var p = Gn(), y = go(p);
      y.payload = i, u != null && (y.callback = u), i = vo(o, y, p), i !== null && (Pn(i, o, p), hs(i, o, p));
    },
    enqueueReplaceState: function(o, i, u) {
      o = o._reactInternals;
      var p = Gn(), y = go(p);
      y.tag = 1, y.payload = i, u != null && (y.callback = u), i = vo(o, y, p), i !== null && (Pn(i, o, p), hs(i, o, p));
    },
    enqueueForceUpdate: function(o, i) {
      o = o._reactInternals;
      var u = Gn(), p = go(u);
      p.tag = 2, i != null && (p.callback = i), i = vo(o, p, u), i !== null && (Pn(i, o, u), hs(i, o, u));
    }
  };
  function qy(o, i, u, p, y, S, j) {
    return o = o.stateNode, typeof o.shouldComponentUpdate == "function" ? o.shouldComponentUpdate(p, S, j) : i.prototype && i.prototype.isPureReactComponent ? !ss(u, p) || !ss(y, S) : !0;
  }
  function Gy(o, i, u, p) {
    o = i.state, typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(u, p), typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(u, p), i.state !== o && dp.enqueueReplaceState(i, i.state, null);
  }
  function ba(o, i) {
    var u = i;
    if ("ref" in i) {
      u = {};
      for (var p in i)
        p !== "ref" && (u[p] = i[p]);
    }
    if (o = o.defaultProps) {
      u === i && (u = h({}, u));
      for (var y in o)
        u[y] === void 0 && (u[y] = o[y]);
    }
    return u;
  }
  function Ky(o) {
    pu(o);
  }
  function Yy(o) {
    console.error(o);
  }
  function Xy(o) {
    pu(o);
  }
  function $u(o, i) {
    try {
      var u = o.onUncaughtError;
      u(i.value, { componentStack: i.stack });
    } catch (p) {
      setTimeout(function() {
        throw p;
      });
    }
  }
  function Jy(o, i, u) {
    try {
      var p = o.onCaughtError;
      p(u.value, {
        componentStack: u.stack,
        errorBoundary: i.tag === 1 ? i.stateNode : null
      });
    } catch (y) {
      setTimeout(function() {
        throw y;
      });
    }
  }
  function fp(o, i, u) {
    return u = go(u), u.tag = 3, u.payload = { element: null }, u.callback = function() {
      $u(o, i);
    }, u;
  }
  function Qy(o) {
    return o = go(o), o.tag = 3, o;
  }
  function Zy(o, i, u, p) {
    var y = u.type.getDerivedStateFromError;
    if (typeof y == "function") {
      var S = p.value;
      o.payload = function() {
        return y(S);
      }, o.callback = function() {
        Jy(i, u, p);
      };
    }
    var j = u.stateNode;
    j !== null && typeof j.componentDidCatch == "function" && (o.callback = function() {
      Jy(i, u, p), typeof y != "function" && (ko === null ? ko = /* @__PURE__ */ new Set([this]) : ko.add(this));
      var T = p.stack;
      this.componentDidCatch(p.value, {
        componentStack: T !== null ? T : ""
      });
    });
  }
  function aM(o, i, u, p, y) {
    if (u.flags |= 32768, p !== null && typeof p == "object" && typeof p.then == "function") {
      if (i = u.alternate, i !== null && Ja(
        i,
        u,
        y,
        !0
      ), u = Vn.current, u !== null) {
        switch (u.tag) {
          case 31:
          case 13:
            return fr === null ? Ku() : u.alternate === null && _t === 0 && (_t = 3), u.flags &= -257, u.flags |= 65536, u.lanes = y, p === ku ? u.flags |= 16384 : (i = u.updateQueue, i === null ? u.updateQueue = /* @__PURE__ */ new Set([p]) : i.add(p), zp(o, p, y)), !1;
          case 22:
            return u.flags |= 65536, p === ku ? u.flags |= 16384 : (i = u.updateQueue, i === null ? (i = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([p])
            }, u.updateQueue = i) : (u = i.retryQueue, u === null ? i.retryQueue = /* @__PURE__ */ new Set([p]) : u.add(p)), zp(o, p, y)), !1;
        }
        throw Error(r(435, u.tag));
      }
      return zp(o, p, y), Ku(), !1;
    }
    if (Ke)
      return i = Vn.current, i !== null ? ((i.flags & 65536) === 0 && (i.flags |= 256), i.flags |= 65536, i.lanes = y, p !== Rf && (o = Error(r(422), { cause: p }), cs(nr(o, u)))) : (p !== Rf && (i = Error(r(423), {
        cause: p
      }), cs(
        nr(i, u)
      )), o = o.current.alternate, o.flags |= 65536, y &= -y, o.lanes |= y, p = nr(p, u), y = fp(
        o.stateNode,
        p,
        y
      ), Uf(o, y), _t !== 4 && (_t = 2)), !1;
    var S = Error(r(520), { cause: p });
    if (S = nr(S, u), Ns === null ? Ns = [S] : Ns.push(S), _t !== 4 && (_t = 2), i === null) return !0;
    p = nr(p, u), u = i;
    do {
      switch (u.tag) {
        case 3:
          return u.flags |= 65536, o = y & -y, u.lanes |= o, o = fp(u.stateNode, p, o), Uf(u, o), !1;
        case 1:
          if (i = u.type, S = u.stateNode, (u.flags & 128) === 0 && (typeof i.getDerivedStateFromError == "function" || S !== null && typeof S.componentDidCatch == "function" && (ko === null || !ko.has(S))))
            return u.flags |= 65536, y &= -y, u.lanes |= y, y = Qy(y), Zy(
              y,
              o,
              u,
              p
            ), Uf(u, y), !1;
      }
      u = u.return;
    } while (u !== null);
    return !1;
  }
  var pp = Error(r(461)), zt = !1;
  function sn(o, i, u, p) {
    i.child = o === null ? ry(i, null, u, p) : va(
      i,
      o.child,
      u,
      p
    );
  }
  function eb(o, i, u, p, y) {
    u = u.render;
    var S = i.ref;
    if ("ref" in p) {
      var j = {};
      for (var T in p)
        T !== "ref" && (j[T] = p[T]);
    } else j = p;
    return pa(i), p = Kf(
      o,
      i,
      u,
      j,
      S,
      y
    ), T = Yf(), o !== null && !zt ? (Xf(o, i, y), Gr(o, i, y)) : (Ke && T && Nf(i), i.flags |= 1, sn(o, i, p, y), i.child);
  }
  function tb(o, i, u, p, y) {
    if (o === null) {
      var S = u.type;
      return typeof S == "function" && !Cf(S) && S.defaultProps === void 0 && u.compare === null ? (i.tag = 15, i.type = S, nb(
        o,
        i,
        S,
        p,
        y
      )) : (o = vu(
        u.type,
        null,
        p,
        i,
        i.mode,
        y
      ), o.ref = i.ref, o.return = i, i.child = o);
    }
    if (S = o.child, !xp(o, y)) {
      var j = S.memoizedProps;
      if (u = u.compare, u = u !== null ? u : ss, u(j, p) && o.ref === i.ref)
        return Gr(o, i, y);
    }
    return i.flags |= 1, o = Br(S, p), o.ref = i.ref, o.return = i, i.child = o;
  }
  function nb(o, i, u, p, y) {
    if (o !== null) {
      var S = o.memoizedProps;
      if (ss(S, p) && o.ref === i.ref)
        if (zt = !1, i.pendingProps = p = S, xp(o, y))
          (o.flags & 131072) !== 0 && (zt = !0);
        else
          return i.lanes = o.lanes, Gr(o, i, y);
    }
    return mp(
      o,
      i,
      u,
      p,
      y
    );
  }
  function rb(o, i, u, p) {
    var y = p.children, S = o !== null ? o.memoizedState : null;
    if (o === null && i.stateNode === null && (i.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), p.mode === "hidden") {
      if ((i.flags & 128) !== 0) {
        if (S = S !== null ? S.baseLanes | u : u, o !== null) {
          for (p = i.child = o.child, y = 0; p !== null; )
            y = y | p.lanes | p.childLanes, p = p.sibling;
          p = y & ~S;
        } else p = 0, i.child = null;
        return ob(
          o,
          i,
          S,
          u,
          p
        );
      }
      if ((u & 536870912) !== 0)
        i.memoizedState = { baseLanes: 0, cachePool: null }, o !== null && xu(
          i,
          S !== null ? S.cachePool : null
        ), S !== null ? iy(i, S) : Hf(), sy(i);
      else
        return p = i.lanes = 536870912, ob(
          o,
          i,
          S !== null ? S.baseLanes | u : u,
          u,
          p
        );
    } else
      S !== null ? (xu(i, S.cachePool), iy(i, S), bo(), i.memoizedState = null) : (o !== null && xu(i, null), Hf(), bo());
    return sn(o, i, y, u), i.child;
  }
  function Ss(o, i) {
    return o !== null && o.tag === 22 || i.stateNode !== null || (i.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), i.sibling;
  }
  function ob(o, i, u, p, y) {
    var S = Tf();
    return S = S === null ? null : { parent: It._currentValue, pool: S }, i.memoizedState = {
      baseLanes: u,
      cachePool: S
    }, o !== null && xu(i, null), Hf(), sy(i), o !== null && Ja(o, i, p, !0), i.childLanes = y, null;
  }
  function zu(o, i) {
    return i = Lu(
      { mode: i.mode, children: i.children },
      o.mode
    ), i.ref = o.ref, o.child = i, i.return = o, i;
  }
  function ab(o, i, u) {
    return va(i, o.child, null, u), o = zu(i, i.pendingProps), o.flags |= 2, Hn(i), i.memoizedState = null, o;
  }
  function iM(o, i, u) {
    var p = i.pendingProps, y = (i.flags & 128) !== 0;
    if (i.flags &= -129, o === null) {
      if (Ke) {
        if (p.mode === "hidden")
          return o = zu(i, p), i.lanes = 536870912, Ss(null, o);
        if (qf(i), (o = yt) ? (o = vw(
          o,
          ar
        ), o = o !== null && o.data === "&" ? o : null, o !== null && (i.memoizedState = {
          dehydrated: o,
          treeContext: co !== null ? { id: Cr, overflow: Or } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, u = Uv(o), u.return = i, i.child = u, on = i, yt = null)) : o = null, o === null) throw po(i);
        return i.lanes = 536870912, null;
      }
      return zu(i, p);
    }
    var S = o.memoizedState;
    if (S !== null) {
      var j = S.dehydrated;
      if (qf(i), y)
        if (i.flags & 256)
          i.flags &= -257, i = ab(
            o,
            i,
            u
          );
        else if (i.memoizedState !== null)
          i.child = o.child, i.flags |= 128, i = null;
        else throw Error(r(558));
      else if (zt || Ja(o, i, u, !1), y = (u & o.childLanes) !== 0, zt || y) {
        if (p = ut, p !== null && (j = Yd(p, u), j !== 0 && j !== S.retryLane))
          throw S.retryLane = j, ua(o, j), Pn(p, o, j), pp;
        Ku(), i = ab(
          o,
          i,
          u
        );
      } else
        o = S.treeContext, yt = ir(j.nextSibling), on = i, Ke = !0, fo = null, ar = !1, o !== null && Wv(i, o), i = zu(i, p), i.flags |= 4096;
      return i;
    }
    return o = Br(o.child, {
      mode: p.mode,
      children: p.children
    }), o.ref = i.ref, i.child = o, o.return = i, o;
  }
  function Tu(o, i) {
    var u = i.ref;
    if (u === null)
      o !== null && o.ref !== null && (i.flags |= 4194816);
    else {
      if (typeof u != "function" && typeof u != "object")
        throw Error(r(284));
      (o === null || o.ref !== u) && (i.flags |= 4194816);
    }
  }
  function mp(o, i, u, p, y) {
    return pa(i), u = Kf(
      o,
      i,
      u,
      p,
      void 0,
      y
    ), p = Yf(), o !== null && !zt ? (Xf(o, i, y), Gr(o, i, y)) : (Ke && p && Nf(i), i.flags |= 1, sn(o, i, u, y), i.child);
  }
  function ib(o, i, u, p, y, S) {
    return pa(i), i.updateQueue = null, u = uy(
      i,
      p,
      u,
      y
    ), ly(o), p = Yf(), o !== null && !zt ? (Xf(o, i, S), Gr(o, i, S)) : (Ke && p && Nf(i), i.flags |= 1, sn(o, i, u, S), i.child);
  }
  function sb(o, i, u, p, y) {
    if (pa(i), i.stateNode === null) {
      var S = Ga, j = u.contextType;
      typeof j == "object" && j !== null && (S = an(j)), S = new u(p, S), i.memoizedState = S.state !== null && S.state !== void 0 ? S.state : null, S.updater = dp, i.stateNode = S, S._reactInternals = i, S = i.stateNode, S.props = p, S.state = i.memoizedState, S.refs = {}, Ff(i), j = u.contextType, S.context = typeof j == "object" && j !== null ? an(j) : Ga, S.state = i.memoizedState, j = u.getDerivedStateFromProps, typeof j == "function" && (cp(
        i,
        u,
        j,
        p
      ), S.state = i.memoizedState), typeof u.getDerivedStateFromProps == "function" || typeof S.getSnapshotBeforeUpdate == "function" || typeof S.UNSAFE_componentWillMount != "function" && typeof S.componentWillMount != "function" || (j = S.state, typeof S.componentWillMount == "function" && S.componentWillMount(), typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount(), j !== S.state && dp.enqueueReplaceState(S, S.state, null), vs(i, p, S, y), gs(), S.state = i.memoizedState), typeof S.componentDidMount == "function" && (i.flags |= 4194308), p = !0;
    } else if (o === null) {
      S = i.stateNode;
      var T = i.memoizedProps, X = ba(u, T);
      S.props = X;
      var ne = S.context, ue = u.contextType;
      j = Ga, typeof ue == "object" && ue !== null && (j = an(ue));
      var pe = u.getDerivedStateFromProps;
      ue = typeof pe == "function" || typeof S.getSnapshotBeforeUpdate == "function", T = i.pendingProps !== T, ue || typeof S.UNSAFE_componentWillReceiveProps != "function" && typeof S.componentWillReceiveProps != "function" || (T || ne !== j) && Gy(
        i,
        S,
        p,
        j
      ), ho = !1;
      var ae = i.memoizedState;
      S.state = ae, vs(i, p, S, y), gs(), ne = i.memoizedState, T || ae !== ne || ho ? (typeof pe == "function" && (cp(
        i,
        u,
        pe,
        p
      ), ne = i.memoizedState), (X = ho || qy(
        i,
        u,
        X,
        p,
        ae,
        ne,
        j
      )) ? (ue || typeof S.UNSAFE_componentWillMount != "function" && typeof S.componentWillMount != "function" || (typeof S.componentWillMount == "function" && S.componentWillMount(), typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount()), typeof S.componentDidMount == "function" && (i.flags |= 4194308)) : (typeof S.componentDidMount == "function" && (i.flags |= 4194308), i.memoizedProps = p, i.memoizedState = ne), S.props = p, S.state = ne, S.context = j, p = X) : (typeof S.componentDidMount == "function" && (i.flags |= 4194308), p = !1);
    } else {
      S = i.stateNode, Bf(o, i), j = i.memoizedProps, ue = ba(u, j), S.props = ue, pe = i.pendingProps, ae = S.context, ne = u.contextType, X = Ga, typeof ne == "object" && ne !== null && (X = an(ne)), T = u.getDerivedStateFromProps, (ne = typeof T == "function" || typeof S.getSnapshotBeforeUpdate == "function") || typeof S.UNSAFE_componentWillReceiveProps != "function" && typeof S.componentWillReceiveProps != "function" || (j !== pe || ae !== X) && Gy(
        i,
        S,
        p,
        X
      ), ho = !1, ae = i.memoizedState, S.state = ae, vs(i, p, S, y), gs();
      var se = i.memoizedState;
      j !== pe || ae !== se || ho || o !== null && o.dependencies !== null && bu(o.dependencies) ? (typeof T == "function" && (cp(
        i,
        u,
        T,
        p
      ), se = i.memoizedState), (ue = ho || qy(
        i,
        u,
        ue,
        p,
        ae,
        se,
        X
      ) || o !== null && o.dependencies !== null && bu(o.dependencies)) ? (ne || typeof S.UNSAFE_componentWillUpdate != "function" && typeof S.componentWillUpdate != "function" || (typeof S.componentWillUpdate == "function" && S.componentWillUpdate(p, se, X), typeof S.UNSAFE_componentWillUpdate == "function" && S.UNSAFE_componentWillUpdate(
        p,
        se,
        X
      )), typeof S.componentDidUpdate == "function" && (i.flags |= 4), typeof S.getSnapshotBeforeUpdate == "function" && (i.flags |= 1024)) : (typeof S.componentDidUpdate != "function" || j === o.memoizedProps && ae === o.memoizedState || (i.flags |= 4), typeof S.getSnapshotBeforeUpdate != "function" || j === o.memoizedProps && ae === o.memoizedState || (i.flags |= 1024), i.memoizedProps = p, i.memoizedState = se), S.props = p, S.state = se, S.context = X, p = ue) : (typeof S.componentDidUpdate != "function" || j === o.memoizedProps && ae === o.memoizedState || (i.flags |= 4), typeof S.getSnapshotBeforeUpdate != "function" || j === o.memoizedProps && ae === o.memoizedState || (i.flags |= 1024), p = !1);
    }
    return S = p, Tu(o, i), p = (i.flags & 128) !== 0, S || p ? (S = i.stateNode, u = p && typeof u.getDerivedStateFromError != "function" ? null : S.render(), i.flags |= 1, o !== null && p ? (i.child = va(
      i,
      o.child,
      null,
      y
    ), i.child = va(
      i,
      null,
      u,
      y
    )) : sn(o, i, u, y), i.memoizedState = S.state, o = i.child) : o = Gr(
      o,
      i,
      y
    ), o;
  }
  function lb(o, i, u, p) {
    return da(), i.flags |= 256, sn(o, i, u, p), i.child;
  }
  var hp = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function gp(o) {
    return { baseLanes: o, cachePool: Jv() };
  }
  function vp(o, i, u) {
    return o = o !== null ? o.childLanes & ~u : 0, i && (o |= qn), o;
  }
  function ub(o, i, u) {
    var p = i.pendingProps, y = !1, S = (i.flags & 128) !== 0, j;
    if ((j = S) || (j = o !== null && o.memoizedState === null ? !1 : (At.current & 2) !== 0), j && (y = !0, i.flags &= -129), j = (i.flags & 32) !== 0, i.flags &= -33, o === null) {
      if (Ke) {
        if (y ? yo(i) : bo(), (o = yt) ? (o = vw(
          o,
          ar
        ), o = o !== null && o.data !== "&" ? o : null, o !== null && (i.memoizedState = {
          dehydrated: o,
          treeContext: co !== null ? { id: Cr, overflow: Or } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, u = Uv(o), u.return = i, i.child = u, on = i, yt = null)) : o = null, o === null) throw po(i);
        return Zp(o) ? i.lanes = 32 : i.lanes = 536870912, null;
      }
      var T = p.children;
      return p = p.fallback, y ? (bo(), y = i.mode, T = Lu(
        { mode: "hidden", children: T },
        y
      ), p = ca(
        p,
        y,
        u,
        null
      ), T.return = i, p.return = i, T.sibling = p, i.child = T, p = i.child, p.memoizedState = gp(u), p.childLanes = vp(
        o,
        j,
        u
      ), i.memoizedState = hp, Ss(null, p)) : (yo(i), yp(i, T));
    }
    var X = o.memoizedState;
    if (X !== null && (T = X.dehydrated, T !== null)) {
      if (S)
        i.flags & 256 ? (yo(i), i.flags &= -257, i = bp(
          o,
          i,
          u
        )) : i.memoizedState !== null ? (bo(), i.child = o.child, i.flags |= 128, i = null) : (bo(), T = p.fallback, y = i.mode, p = Lu(
          { mode: "visible", children: p.children },
          y
        ), T = ca(
          T,
          y,
          u,
          null
        ), T.flags |= 2, p.return = i, T.return = i, p.sibling = T, i.child = p, va(
          i,
          o.child,
          null,
          u
        ), p = i.child, p.memoizedState = gp(u), p.childLanes = vp(
          o,
          j,
          u
        ), i.memoizedState = hp, i = Ss(null, p));
      else if (yo(i), Zp(T)) {
        if (j = T.nextSibling && T.nextSibling.dataset, j) var ne = j.dgst;
        j = ne, p = Error(r(419)), p.stack = "", p.digest = j, cs({ value: p, source: null, stack: null }), i = bp(
          o,
          i,
          u
        );
      } else if (zt || Ja(o, i, u, !1), j = (u & o.childLanes) !== 0, zt || j) {
        if (j = ut, j !== null && (p = Yd(j, u), p !== 0 && p !== X.retryLane))
          throw X.retryLane = p, ua(o, p), Pn(j, o, p), pp;
        Qp(T) || Ku(), i = bp(
          o,
          i,
          u
        );
      } else
        Qp(T) ? (i.flags |= 192, i.child = o.child, i = null) : (o = X.treeContext, yt = ir(
          T.nextSibling
        ), on = i, Ke = !0, fo = null, ar = !1, o !== null && Wv(i, o), i = yp(
          i,
          p.children
        ), i.flags |= 4096);
      return i;
    }
    return y ? (bo(), T = p.fallback, y = i.mode, X = o.child, ne = X.sibling, p = Br(X, {
      mode: "hidden",
      children: p.children
    }), p.subtreeFlags = X.subtreeFlags & 65011712, ne !== null ? T = Br(
      ne,
      T
    ) : (T = ca(
      T,
      y,
      u,
      null
    ), T.flags |= 2), T.return = i, p.return = i, p.sibling = T, i.child = p, Ss(null, p), p = i.child, T = o.child.memoizedState, T === null ? T = gp(u) : (y = T.cachePool, y !== null ? (X = It._currentValue, y = y.parent !== X ? { parent: X, pool: X } : y) : y = Jv(), T = {
      baseLanes: T.baseLanes | u,
      cachePool: y
    }), p.memoizedState = T, p.childLanes = vp(
      o,
      j,
      u
    ), i.memoizedState = hp, Ss(o.child, p)) : (yo(i), u = o.child, o = u.sibling, u = Br(u, {
      mode: "visible",
      children: p.children
    }), u.return = i, u.sibling = null, o !== null && (j = i.deletions, j === null ? (i.deletions = [o], i.flags |= 16) : j.push(o)), i.child = u, i.memoizedState = null, u);
  }
  function yp(o, i) {
    return i = Lu(
      { mode: "visible", children: i },
      o.mode
    ), i.return = o, o.child = i;
  }
  function Lu(o, i) {
    return o = Un(22, o, null, i), o.lanes = 0, o;
  }
  function bp(o, i, u) {
    return va(i, o.child, null, u), o = yp(
      i,
      i.pendingProps.children
    ), o.flags |= 2, i.memoizedState = null, o;
  }
  function cb(o, i, u) {
    o.lanes |= i;
    var p = o.alternate;
    p !== null && (p.lanes |= i), Df(o.return, i, u);
  }
  function wp(o, i, u, p, y, S) {
    var j = o.memoizedState;
    j === null ? o.memoizedState = {
      isBackwards: i,
      rendering: null,
      renderingStartTime: 0,
      last: p,
      tail: u,
      tailMode: y,
      treeForkCount: S
    } : (j.isBackwards = i, j.rendering = null, j.renderingStartTime = 0, j.last = p, j.tail = u, j.tailMode = y, j.treeForkCount = S);
  }
  function db(o, i, u) {
    var p = i.pendingProps, y = p.revealOrder, S = p.tail;
    p = p.children;
    var j = At.current, T = (j & 2) !== 0;
    if (T ? (j = j & 1 | 2, i.flags |= 128) : j &= 1, U(At, j), sn(o, i, p, u), p = Ke ? us : 0, !T && o !== null && (o.flags & 128) !== 0)
      e: for (o = i.child; o !== null; ) {
        if (o.tag === 13)
          o.memoizedState !== null && cb(o, u, i);
        else if (o.tag === 19)
          cb(o, u, i);
        else if (o.child !== null) {
          o.child.return = o, o = o.child;
          continue;
        }
        if (o === i) break e;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === i)
            break e;
          o = o.return;
        }
        o.sibling.return = o.return, o = o.sibling;
      }
    switch (y) {
      case "forwards":
        for (u = i.child, y = null; u !== null; )
          o = u.alternate, o !== null && Ou(o) === null && (y = u), u = u.sibling;
        u = y, u === null ? (y = i.child, i.child = null) : (y = u.sibling, u.sibling = null), wp(
          i,
          !1,
          y,
          u,
          S,
          p
        );
        break;
      case "backwards":
      case "unstable_legacy-backwards":
        for (u = null, y = i.child, i.child = null; y !== null; ) {
          if (o = y.alternate, o !== null && Ou(o) === null) {
            i.child = y;
            break;
          }
          o = y.sibling, y.sibling = u, u = y, y = o;
        }
        wp(
          i,
          !0,
          u,
          null,
          S,
          p
        );
        break;
      case "together":
        wp(
          i,
          !1,
          null,
          null,
          void 0,
          p
        );
        break;
      default:
        i.memoizedState = null;
    }
    return i.child;
  }
  function Gr(o, i, u) {
    if (o !== null && (i.dependencies = o.dependencies), So |= i.lanes, (u & i.childLanes) === 0)
      if (o !== null) {
        if (Ja(
          o,
          i,
          u,
          !1
        ), (u & i.childLanes) === 0)
          return null;
      } else return null;
    if (o !== null && i.child !== o.child)
      throw Error(r(153));
    if (i.child !== null) {
      for (o = i.child, u = Br(o, o.pendingProps), i.child = u, u.return = i; o.sibling !== null; )
        o = o.sibling, u = u.sibling = Br(o, o.pendingProps), u.return = i;
      u.sibling = null;
    }
    return i.child;
  }
  function xp(o, i) {
    return (o.lanes & i) !== 0 ? !0 : (o = o.dependencies, !!(o !== null && bu(o)));
  }
  function sM(o, i, u) {
    switch (i.tag) {
      case 3:
        ie(i, i.stateNode.containerInfo), mo(i, It, o.memoizedState.cache), da();
        break;
      case 27:
      case 5:
        ge(i);
        break;
      case 4:
        ie(i, i.stateNode.containerInfo);
        break;
      case 10:
        mo(
          i,
          i.type,
          i.memoizedProps.value
        );
        break;
      case 31:
        if (i.memoizedState !== null)
          return i.flags |= 128, qf(i), null;
        break;
      case 13:
        var p = i.memoizedState;
        if (p !== null)
          return p.dehydrated !== null ? (yo(i), i.flags |= 128, null) : (u & i.child.childLanes) !== 0 ? ub(o, i, u) : (yo(i), o = Gr(
            o,
            i,
            u
          ), o !== null ? o.sibling : null);
        yo(i);
        break;
      case 19:
        var y = (o.flags & 128) !== 0;
        if (p = (u & i.childLanes) !== 0, p || (Ja(
          o,
          i,
          u,
          !1
        ), p = (u & i.childLanes) !== 0), y) {
          if (p)
            return db(
              o,
              i,
              u
            );
          i.flags |= 128;
        }
        if (y = i.memoizedState, y !== null && (y.rendering = null, y.tail = null, y.lastEffect = null), U(At, At.current), p) break;
        return null;
      case 22:
        return i.lanes = 0, rb(
          o,
          i,
          u,
          i.pendingProps
        );
      case 24:
        mo(i, It, o.memoizedState.cache);
    }
    return Gr(o, i, u);
  }
  function fb(o, i, u) {
    if (o !== null)
      if (o.memoizedProps !== i.pendingProps)
        zt = !0;
      else {
        if (!xp(o, u) && (i.flags & 128) === 0)
          return zt = !1, sM(
            o,
            i,
            u
          );
        zt = (o.flags & 131072) !== 0;
      }
    else
      zt = !1, Ke && (i.flags & 1048576) !== 0 && Hv(i, us, i.index);
    switch (i.lanes = 0, i.tag) {
      case 16:
        e: {
          var p = i.pendingProps;
          if (o = ha(i.elementType), i.type = o, typeof o == "function")
            Cf(o) ? (p = ba(o, p), i.tag = 1, i = sb(
              null,
              i,
              o,
              p,
              u
            )) : (i.tag = 0, i = mp(
              null,
              i,
              o,
              p,
              u
            ));
          else {
            if (o != null) {
              var y = o.$$typeof;
              if (y === O) {
                i.tag = 11, i = eb(
                  null,
                  i,
                  o,
                  p,
                  u
                );
                break e;
              } else if (y === R) {
                i.tag = 14, i = tb(
                  null,
                  i,
                  o,
                  p,
                  u
                );
                break e;
              }
            }
            throw i = L(o) || o, Error(r(306, i, ""));
          }
        }
        return i;
      case 0:
        return mp(
          o,
          i,
          i.type,
          i.pendingProps,
          u
        );
      case 1:
        return p = i.type, y = ba(
          p,
          i.pendingProps
        ), sb(
          o,
          i,
          p,
          y,
          u
        );
      case 3:
        e: {
          if (ie(
            i,
            i.stateNode.containerInfo
          ), o === null) throw Error(r(387));
          p = i.pendingProps;
          var S = i.memoizedState;
          y = S.element, Bf(o, i), vs(i, p, null, u);
          var j = i.memoizedState;
          if (p = j.cache, mo(i, It, p), p !== S.cache && If(
            i,
            [It],
            u,
            !0
          ), gs(), p = j.element, S.isDehydrated)
            if (S = {
              element: p,
              isDehydrated: !1,
              cache: j.cache
            }, i.updateQueue.baseState = S, i.memoizedState = S, i.flags & 256) {
              i = lb(
                o,
                i,
                p,
                u
              );
              break e;
            } else if (p !== y) {
              y = nr(
                Error(r(424)),
                i
              ), cs(y), i = lb(
                o,
                i,
                p,
                u
              );
              break e;
            } else
              for (o = i.stateNode.containerInfo, o.nodeType === 9 ? o = o.body : o = o.nodeName === "HTML" ? o.ownerDocument.body : o, yt = ir(o.firstChild), on = i, Ke = !0, fo = null, ar = !0, u = ry(
                i,
                null,
                p,
                u
              ), i.child = u; u; )
                u.flags = u.flags & -3 | 4096, u = u.sibling;
          else {
            if (da(), p === y) {
              i = Gr(
                o,
                i,
                u
              );
              break e;
            }
            sn(o, i, p, u);
          }
          i = i.child;
        }
        return i;
      case 26:
        return Tu(o, i), o === null ? (u = kw(
          i.type,
          null,
          i.pendingProps,
          null
        )) ? i.memoizedState = u : Ke || (u = i.type, o = i.pendingProps, p = tc(
          oe.current
        ).createElement(u), p[en] = i, p[yn] = o, ln(p, u, o), Wt(p), i.stateNode = p) : i.memoizedState = kw(
          i.type,
          o.memoizedProps,
          i.pendingProps,
          o.memoizedState
        ), null;
      case 27:
        return ge(i), o === null && Ke && (p = i.stateNode = ww(
          i.type,
          i.pendingProps,
          oe.current
        ), on = i, ar = !0, y = yt, Oo(i.type) ? (em = y, yt = ir(p.firstChild)) : yt = y), sn(
          o,
          i,
          i.pendingProps.children,
          u
        ), Tu(o, i), o === null && (i.flags |= 4194304), i.child;
      case 5:
        return o === null && Ke && ((y = p = yt) && (p = zM(
          p,
          i.type,
          i.pendingProps,
          ar
        ), p !== null ? (i.stateNode = p, on = i, yt = ir(p.firstChild), ar = !1, y = !0) : y = !1), y || po(i)), ge(i), y = i.type, S = i.pendingProps, j = o !== null ? o.memoizedProps : null, p = S.children, Yp(y, S) ? p = null : j !== null && Yp(y, j) && (i.flags |= 32), i.memoizedState !== null && (y = Kf(
          o,
          i,
          QO,
          null,
          null,
          u
        ), zs._currentValue = y), Tu(o, i), sn(o, i, p, u), i.child;
      case 6:
        return o === null && Ke && ((o = u = yt) && (u = TM(
          u,
          i.pendingProps,
          ar
        ), u !== null ? (i.stateNode = u, on = i, yt = null, o = !0) : o = !1), o || po(i)), null;
      case 13:
        return ub(o, i, u);
      case 4:
        return ie(
          i,
          i.stateNode.containerInfo
        ), p = i.pendingProps, o === null ? i.child = va(
          i,
          null,
          p,
          u
        ) : sn(o, i, p, u), i.child;
      case 11:
        return eb(
          o,
          i,
          i.type,
          i.pendingProps,
          u
        );
      case 7:
        return sn(
          o,
          i,
          i.pendingProps,
          u
        ), i.child;
      case 8:
        return sn(
          o,
          i,
          i.pendingProps.children,
          u
        ), i.child;
      case 12:
        return sn(
          o,
          i,
          i.pendingProps.children,
          u
        ), i.child;
      case 10:
        return p = i.pendingProps, mo(i, i.type, p.value), sn(o, i, p.children, u), i.child;
      case 9:
        return y = i.type._context, p = i.pendingProps.children, pa(i), y = an(y), p = p(y), i.flags |= 1, sn(o, i, p, u), i.child;
      case 14:
        return tb(
          o,
          i,
          i.type,
          i.pendingProps,
          u
        );
      case 15:
        return nb(
          o,
          i,
          i.type,
          i.pendingProps,
          u
        );
      case 19:
        return db(o, i, u);
      case 31:
        return iM(o, i, u);
      case 22:
        return rb(
          o,
          i,
          u,
          i.pendingProps
        );
      case 24:
        return pa(i), p = an(It), o === null ? (y = Tf(), y === null && (y = ut, S = $f(), y.pooledCache = S, S.refCount++, S !== null && (y.pooledCacheLanes |= u), y = S), i.memoizedState = { parent: p, cache: y }, Ff(i), mo(i, It, y)) : ((o.lanes & u) !== 0 && (Bf(o, i), vs(i, null, null, u), gs()), y = o.memoizedState, S = i.memoizedState, y.parent !== p ? (y = { parent: p, cache: p }, i.memoizedState = y, i.lanes === 0 && (i.memoizedState = i.updateQueue.baseState = y), mo(i, It, p)) : (p = S.cache, mo(i, It, p), p !== y.cache && If(
          i,
          [It],
          u,
          !0
        ))), sn(
          o,
          i,
          i.pendingProps.children,
          u
        ), i.child;
      case 29:
        throw i.pendingProps;
    }
    throw Error(r(156, i.tag));
  }
  function Kr(o) {
    o.flags |= 4;
  }
  function Sp(o, i, u, p, y) {
    if ((i = (o.mode & 32) !== 0) && (i = !1), i) {
      if (o.flags |= 16777216, (y & 335544128) === y)
        if (o.stateNode.complete) o.flags |= 8192;
        else if (Lb()) o.flags |= 8192;
        else
          throw ga = ku, Lf;
    } else o.flags &= -16777217;
  }
  function pb(o, i) {
    if (i.type !== "stylesheet" || (i.state.loading & 4) !== 0)
      o.flags &= -16777217;
    else if (o.flags |= 16777216, !Mw(i))
      if (Lb()) o.flags |= 8192;
      else
        throw ga = ku, Lf;
  }
  function Fu(o, i) {
    i !== null && (o.flags |= 4), o.flags & 16384 && (i = o.tag !== 22 ? qd() : 536870912, o.lanes |= i, ui |= i);
  }
  function ks(o, i) {
    if (!Ke)
      switch (o.tailMode) {
        case "hidden":
          i = o.tail;
          for (var u = null; i !== null; )
            i.alternate !== null && (u = i), i = i.sibling;
          u === null ? o.tail = null : u.sibling = null;
          break;
        case "collapsed":
          u = o.tail;
          for (var p = null; u !== null; )
            u.alternate !== null && (p = u), u = u.sibling;
          p === null ? i || o.tail === null ? o.tail = null : o.tail.sibling = null : p.sibling = null;
      }
  }
  function bt(o) {
    var i = o.alternate !== null && o.alternate.child === o.child, u = 0, p = 0;
    if (i)
      for (var y = o.child; y !== null; )
        u |= y.lanes | y.childLanes, p |= y.subtreeFlags & 65011712, p |= y.flags & 65011712, y.return = o, y = y.sibling;
    else
      for (y = o.child; y !== null; )
        u |= y.lanes | y.childLanes, p |= y.subtreeFlags, p |= y.flags, y.return = o, y = y.sibling;
    return o.subtreeFlags |= p, o.childLanes = u, i;
  }
  function lM(o, i, u) {
    var p = i.pendingProps;
    switch (Af(i), i.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return bt(i), null;
      case 1:
        return bt(i), null;
      case 3:
        return u = i.stateNode, p = null, o !== null && (p = o.memoizedState.cache), i.memoizedState.cache !== p && (i.flags |= 2048), Hr(It), ce(), u.pendingContext && (u.context = u.pendingContext, u.pendingContext = null), (o === null || o.child === null) && (Xa(i) ? Kr(i) : o === null || o.memoizedState.isDehydrated && (i.flags & 256) === 0 || (i.flags |= 1024, jf())), bt(i), null;
      case 26:
        var y = i.type, S = i.memoizedState;
        return o === null ? (Kr(i), S !== null ? (bt(i), pb(i, S)) : (bt(i), Sp(
          i,
          y,
          null,
          p,
          u
        ))) : S ? S !== o.memoizedState ? (Kr(i), bt(i), pb(i, S)) : (bt(i), i.flags &= -16777217) : (o = o.memoizedProps, o !== p && Kr(i), bt(i), Sp(
          i,
          y,
          o,
          p,
          u
        )), null;
      case 27:
        if (re(i), u = oe.current, y = i.type, o !== null && i.stateNode != null)
          o.memoizedProps !== p && Kr(i);
        else {
          if (!p) {
            if (i.stateNode === null)
              throw Error(r(166));
            return bt(i), null;
          }
          o = W.current, Xa(i) ? qv(i) : (o = ww(y, p, u), i.stateNode = o, Kr(i));
        }
        return bt(i), null;
      case 5:
        if (re(i), y = i.type, o !== null && i.stateNode != null)
          o.memoizedProps !== p && Kr(i);
        else {
          if (!p) {
            if (i.stateNode === null)
              throw Error(r(166));
            return bt(i), null;
          }
          if (S = W.current, Xa(i))
            qv(i);
          else {
            var j = tc(
              oe.current
            );
            switch (S) {
              case 1:
                S = j.createElementNS(
                  "http://www.w3.org/2000/svg",
                  y
                );
                break;
              case 2:
                S = j.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  y
                );
                break;
              default:
                switch (y) {
                  case "svg":
                    S = j.createElementNS(
                      "http://www.w3.org/2000/svg",
                      y
                    );
                    break;
                  case "math":
                    S = j.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      y
                    );
                    break;
                  case "script":
                    S = j.createElement("div"), S.innerHTML = "<script><\/script>", S = S.removeChild(
                      S.firstChild
                    );
                    break;
                  case "select":
                    S = typeof p.is == "string" ? j.createElement("select", {
                      is: p.is
                    }) : j.createElement("select"), p.multiple ? S.multiple = !0 : p.size && (S.size = p.size);
                    break;
                  default:
                    S = typeof p.is == "string" ? j.createElement(y, { is: p.is }) : j.createElement(y);
                }
            }
            S[en] = i, S[yn] = p;
            e: for (j = i.child; j !== null; ) {
              if (j.tag === 5 || j.tag === 6)
                S.appendChild(j.stateNode);
              else if (j.tag !== 4 && j.tag !== 27 && j.child !== null) {
                j.child.return = j, j = j.child;
                continue;
              }
              if (j === i) break e;
              for (; j.sibling === null; ) {
                if (j.return === null || j.return === i)
                  break e;
                j = j.return;
              }
              j.sibling.return = j.return, j = j.sibling;
            }
            i.stateNode = S;
            e: switch (ln(S, y, p), y) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                p = !!p.autoFocus;
                break e;
              case "img":
                p = !0;
                break e;
              default:
                p = !1;
            }
            p && Kr(i);
          }
        }
        return bt(i), Sp(
          i,
          i.type,
          o === null ? null : o.memoizedProps,
          i.pendingProps,
          u
        ), null;
      case 6:
        if (o && i.stateNode != null)
          o.memoizedProps !== p && Kr(i);
        else {
          if (typeof p != "string" && i.stateNode === null)
            throw Error(r(166));
          if (o = oe.current, Xa(i)) {
            if (o = i.stateNode, u = i.memoizedProps, p = null, y = on, y !== null)
              switch (y.tag) {
                case 27:
                case 5:
                  p = y.memoizedProps;
              }
            o[en] = i, o = !!(o.nodeValue === u || p !== null && p.suppressHydrationWarning === !0 || uw(o.nodeValue, u)), o || po(i, !0);
          } else
            o = tc(o).createTextNode(
              p
            ), o[en] = i, i.stateNode = o;
        }
        return bt(i), null;
      case 31:
        if (u = i.memoizedState, o === null || o.memoizedState !== null) {
          if (p = Xa(i), u !== null) {
            if (o === null) {
              if (!p) throw Error(r(318));
              if (o = i.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(r(557));
              o[en] = i;
            } else
              da(), (i.flags & 128) === 0 && (i.memoizedState = null), i.flags |= 4;
            bt(i), o = !1;
          } else
            u = jf(), o !== null && o.memoizedState !== null && (o.memoizedState.hydrationErrors = u), o = !0;
          if (!o)
            return i.flags & 256 ? (Hn(i), i) : (Hn(i), null);
          if ((i.flags & 128) !== 0)
            throw Error(r(558));
        }
        return bt(i), null;
      case 13:
        if (p = i.memoizedState, o === null || o.memoizedState !== null && o.memoizedState.dehydrated !== null) {
          if (y = Xa(i), p !== null && p.dehydrated !== null) {
            if (o === null) {
              if (!y) throw Error(r(318));
              if (y = i.memoizedState, y = y !== null ? y.dehydrated : null, !y) throw Error(r(317));
              y[en] = i;
            } else
              da(), (i.flags & 128) === 0 && (i.memoizedState = null), i.flags |= 4;
            bt(i), y = !1;
          } else
            y = jf(), o !== null && o.memoizedState !== null && (o.memoizedState.hydrationErrors = y), y = !0;
          if (!y)
            return i.flags & 256 ? (Hn(i), i) : (Hn(i), null);
        }
        return Hn(i), (i.flags & 128) !== 0 ? (i.lanes = u, i) : (u = p !== null, o = o !== null && o.memoizedState !== null, u && (p = i.child, y = null, p.alternate !== null && p.alternate.memoizedState !== null && p.alternate.memoizedState.cachePool !== null && (y = p.alternate.memoizedState.cachePool.pool), S = null, p.memoizedState !== null && p.memoizedState.cachePool !== null && (S = p.memoizedState.cachePool.pool), S !== y && (p.flags |= 2048)), u !== o && u && (i.child.flags |= 8192), Fu(i, i.updateQueue), bt(i), null);
      case 4:
        return ce(), o === null && Hp(i.stateNode.containerInfo), bt(i), null;
      case 10:
        return Hr(i.type), bt(i), null;
      case 19:
        if (Y(At), p = i.memoizedState, p === null) return bt(i), null;
        if (y = (i.flags & 128) !== 0, S = p.rendering, S === null)
          if (y) ks(p, !1);
          else {
            if (_t !== 0 || o !== null && (o.flags & 128) !== 0)
              for (o = i.child; o !== null; ) {
                if (S = Ou(o), S !== null) {
                  for (i.flags |= 128, ks(p, !1), o = S.updateQueue, i.updateQueue = o, Fu(i, o), i.subtreeFlags = 0, o = u, u = i.child; u !== null; )
                    Bv(u, o), u = u.sibling;
                  return U(
                    At,
                    At.current & 1 | 2
                  ), Ke && Ur(i, p.treeForkCount), i.child;
                }
                o = o.sibling;
              }
            p.tail !== null && Ce() > Wu && (i.flags |= 128, y = !0, ks(p, !1), i.lanes = 4194304);
          }
        else {
          if (!y)
            if (o = Ou(S), o !== null) {
              if (i.flags |= 128, y = !0, o = o.updateQueue, i.updateQueue = o, Fu(i, o), ks(p, !0), p.tail === null && p.tailMode === "hidden" && !S.alternate && !Ke)
                return bt(i), null;
            } else
              2 * Ce() - p.renderingStartTime > Wu && u !== 536870912 && (i.flags |= 128, y = !0, ks(p, !1), i.lanes = 4194304);
          p.isBackwards ? (S.sibling = i.child, i.child = S) : (o = p.last, o !== null ? o.sibling = S : i.child = S, p.last = S);
        }
        return p.tail !== null ? (o = p.tail, p.rendering = o, p.tail = o.sibling, p.renderingStartTime = Ce(), o.sibling = null, u = At.current, U(
          At,
          y ? u & 1 | 2 : u & 1
        ), Ke && Ur(i, p.treeForkCount), o) : (bt(i), null);
      case 22:
      case 23:
        return Hn(i), Wf(), p = i.memoizedState !== null, o !== null ? o.memoizedState !== null !== p && (i.flags |= 8192) : p && (i.flags |= 8192), p ? (u & 536870912) !== 0 && (i.flags & 128) === 0 && (bt(i), i.subtreeFlags & 6 && (i.flags |= 8192)) : bt(i), u = i.updateQueue, u !== null && Fu(i, u.retryQueue), u = null, o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (u = o.memoizedState.cachePool.pool), p = null, i.memoizedState !== null && i.memoizedState.cachePool !== null && (p = i.memoizedState.cachePool.pool), p !== u && (i.flags |= 2048), o !== null && Y(ma), null;
      case 24:
        return u = null, o !== null && (u = o.memoizedState.cache), i.memoizedState.cache !== u && (i.flags |= 2048), Hr(It), bt(i), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(r(156, i.tag));
  }
  function uM(o, i) {
    switch (Af(i), i.tag) {
      case 1:
        return o = i.flags, o & 65536 ? (i.flags = o & -65537 | 128, i) : null;
      case 3:
        return Hr(It), ce(), o = i.flags, (o & 65536) !== 0 && (o & 128) === 0 ? (i.flags = o & -65537 | 128, i) : null;
      case 26:
      case 27:
      case 5:
        return re(i), null;
      case 31:
        if (i.memoizedState !== null) {
          if (Hn(i), i.alternate === null)
            throw Error(r(340));
          da();
        }
        return o = i.flags, o & 65536 ? (i.flags = o & -65537 | 128, i) : null;
      case 13:
        if (Hn(i), o = i.memoizedState, o !== null && o.dehydrated !== null) {
          if (i.alternate === null)
            throw Error(r(340));
          da();
        }
        return o = i.flags, o & 65536 ? (i.flags = o & -65537 | 128, i) : null;
      case 19:
        return Y(At), null;
      case 4:
        return ce(), null;
      case 10:
        return Hr(i.type), null;
      case 22:
      case 23:
        return Hn(i), Wf(), o !== null && Y(ma), o = i.flags, o & 65536 ? (i.flags = o & -65537 | 128, i) : null;
      case 24:
        return Hr(It), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function mb(o, i) {
    switch (Af(i), i.tag) {
      case 3:
        Hr(It), ce();
        break;
      case 26:
      case 27:
      case 5:
        re(i);
        break;
      case 4:
        ce();
        break;
      case 31:
        i.memoizedState !== null && Hn(i);
        break;
      case 13:
        Hn(i);
        break;
      case 19:
        Y(At);
        break;
      case 10:
        Hr(i.type);
        break;
      case 22:
      case 23:
        Hn(i), Wf(), o !== null && Y(ma);
        break;
      case 24:
        Hr(It);
    }
  }
  function _s(o, i) {
    try {
      var u = i.updateQueue, p = u !== null ? u.lastEffect : null;
      if (p !== null) {
        var y = p.next;
        u = y;
        do {
          if ((u.tag & o) === o) {
            p = void 0;
            var S = u.create, j = u.inst;
            p = S(), j.destroy = p;
          }
          u = u.next;
        } while (u !== y);
      }
    } catch (T) {
      ot(i, i.return, T);
    }
  }
  function wo(o, i, u) {
    try {
      var p = i.updateQueue, y = p !== null ? p.lastEffect : null;
      if (y !== null) {
        var S = y.next;
        p = S;
        do {
          if ((p.tag & o) === o) {
            var j = p.inst, T = j.destroy;
            if (T !== void 0) {
              j.destroy = void 0, y = i;
              var X = u, ne = T;
              try {
                ne();
              } catch (ue) {
                ot(
                  y,
                  X,
                  ue
                );
              }
            }
          }
          p = p.next;
        } while (p !== S);
      }
    } catch (ue) {
      ot(i, i.return, ue);
    }
  }
  function hb(o) {
    var i = o.updateQueue;
    if (i !== null) {
      var u = o.stateNode;
      try {
        ay(i, u);
      } catch (p) {
        ot(o, o.return, p);
      }
    }
  }
  function gb(o, i, u) {
    u.props = ba(
      o.type,
      o.memoizedProps
    ), u.state = o.memoizedState;
    try {
      u.componentWillUnmount();
    } catch (p) {
      ot(o, i, p);
    }
  }
  function Es(o, i) {
    try {
      var u = o.ref;
      if (u !== null) {
        switch (o.tag) {
          case 26:
          case 27:
          case 5:
            var p = o.stateNode;
            break;
          case 30:
            p = o.stateNode;
            break;
          default:
            p = o.stateNode;
        }
        typeof u == "function" ? o.refCleanup = u(p) : u.current = p;
      }
    } catch (y) {
      ot(o, i, y);
    }
  }
  function Mr(o, i) {
    var u = o.ref, p = o.refCleanup;
    if (u !== null)
      if (typeof p == "function")
        try {
          p();
        } catch (y) {
          ot(o, i, y);
        } finally {
          o.refCleanup = null, o = o.alternate, o != null && (o.refCleanup = null);
        }
      else if (typeof u == "function")
        try {
          u(null);
        } catch (y) {
          ot(o, i, y);
        }
      else u.current = null;
  }
  function vb(o) {
    var i = o.type, u = o.memoizedProps, p = o.stateNode;
    try {
      e: switch (i) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          u.autoFocus && p.focus();
          break e;
        case "img":
          u.src ? p.src = u.src : u.srcSet && (p.srcset = u.srcSet);
      }
    } catch (y) {
      ot(o, o.return, y);
    }
  }
  function kp(o, i, u) {
    try {
      var p = o.stateNode;
      RM(p, o.type, u, i), p[yn] = i;
    } catch (y) {
      ot(o, o.return, y);
    }
  }
  function yb(o) {
    return o.tag === 5 || o.tag === 3 || o.tag === 26 || o.tag === 27 && Oo(o.type) || o.tag === 4;
  }
  function _p(o) {
    e: for (; ; ) {
      for (; o.sibling === null; ) {
        if (o.return === null || yb(o.return)) return null;
        o = o.return;
      }
      for (o.sibling.return = o.return, o = o.sibling; o.tag !== 5 && o.tag !== 6 && o.tag !== 18; ) {
        if (o.tag === 27 && Oo(o.type) || o.flags & 2 || o.child === null || o.tag === 4) continue e;
        o.child.return = o, o = o.child;
      }
      if (!(o.flags & 2)) return o.stateNode;
    }
  }
  function Ep(o, i, u) {
    var p = o.tag;
    if (p === 5 || p === 6)
      o = o.stateNode, i ? (u.nodeType === 9 ? u.body : u.nodeName === "HTML" ? u.ownerDocument.body : u).insertBefore(o, i) : (i = u.nodeType === 9 ? u.body : u.nodeName === "HTML" ? u.ownerDocument.body : u, i.appendChild(o), u = u._reactRootContainer, u != null || i.onclick !== null || (i.onclick = Lr));
    else if (p !== 4 && (p === 27 && Oo(o.type) && (u = o.stateNode, i = null), o = o.child, o !== null))
      for (Ep(o, i, u), o = o.sibling; o !== null; )
        Ep(o, i, u), o = o.sibling;
  }
  function Bu(o, i, u) {
    var p = o.tag;
    if (p === 5 || p === 6)
      o = o.stateNode, i ? u.insertBefore(o, i) : u.appendChild(o);
    else if (p !== 4 && (p === 27 && Oo(o.type) && (u = o.stateNode), o = o.child, o !== null))
      for (Bu(o, i, u), o = o.sibling; o !== null; )
        Bu(o, i, u), o = o.sibling;
  }
  function bb(o) {
    var i = o.stateNode, u = o.memoizedProps;
    try {
      for (var p = o.type, y = i.attributes; y.length; )
        i.removeAttributeNode(y[0]);
      ln(i, p, u), i[en] = o, i[yn] = u;
    } catch (S) {
      ot(o, o.return, S);
    }
  }
  var Yr = !1, Tt = !1, Cp = !1, wb = typeof WeakSet == "function" ? WeakSet : Set, tn = null;
  function cM(o, i) {
    if (o = o.containerInfo, Gp = lc, o = jv(o), bf(o)) {
      if ("selectionStart" in o)
        var u = {
          start: o.selectionStart,
          end: o.selectionEnd
        };
      else
        e: {
          u = (u = o.ownerDocument) && u.defaultView || window;
          var p = u.getSelection && u.getSelection();
          if (p && p.rangeCount !== 0) {
            u = p.anchorNode;
            var y = p.anchorOffset, S = p.focusNode;
            p = p.focusOffset;
            try {
              u.nodeType, S.nodeType;
            } catch {
              u = null;
              break e;
            }
            var j = 0, T = -1, X = -1, ne = 0, ue = 0, pe = o, ae = null;
            t: for (; ; ) {
              for (var se; pe !== u || y !== 0 && pe.nodeType !== 3 || (T = j + y), pe !== S || p !== 0 && pe.nodeType !== 3 || (X = j + p), pe.nodeType === 3 && (j += pe.nodeValue.length), (se = pe.firstChild) !== null; )
                ae = pe, pe = se;
              for (; ; ) {
                if (pe === o) break t;
                if (ae === u && ++ne === y && (T = j), ae === S && ++ue === p && (X = j), (se = pe.nextSibling) !== null) break;
                pe = ae, ae = pe.parentNode;
              }
              pe = se;
            }
            u = T === -1 || X === -1 ? null : { start: T, end: X };
          } else u = null;
        }
      u = u || { start: 0, end: 0 };
    } else u = null;
    for (Kp = { focusedElem: o, selectionRange: u }, lc = !1, tn = i; tn !== null; )
      if (i = tn, o = i.child, (i.subtreeFlags & 1028) !== 0 && o !== null)
        o.return = i, tn = o;
      else
        for (; tn !== null; ) {
          switch (i = tn, S = i.alternate, o = i.flags, i.tag) {
            case 0:
              if ((o & 4) !== 0 && (o = i.updateQueue, o = o !== null ? o.events : null, o !== null))
                for (u = 0; u < o.length; u++)
                  y = o[u], y.ref.impl = y.nextImpl;
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((o & 1024) !== 0 && S !== null) {
                o = void 0, u = i, y = S.memoizedProps, S = S.memoizedState, p = u.stateNode;
                try {
                  var we = ba(
                    u.type,
                    y
                  );
                  o = p.getSnapshotBeforeUpdate(
                    we,
                    S
                  ), p.__reactInternalSnapshotBeforeUpdate = o;
                } catch (Ne) {
                  ot(
                    u,
                    u.return,
                    Ne
                  );
                }
              }
              break;
            case 3:
              if ((o & 1024) !== 0) {
                if (o = i.stateNode.containerInfo, u = o.nodeType, u === 9)
                  Jp(o);
                else if (u === 1)
                  switch (o.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      Jp(o);
                      break;
                    default:
                      o.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((o & 1024) !== 0) throw Error(r(163));
          }
          if (o = i.sibling, o !== null) {
            o.return = i.return, tn = o;
            break;
          }
          tn = i.return;
        }
  }
  function xb(o, i, u) {
    var p = u.flags;
    switch (u.tag) {
      case 0:
      case 11:
      case 15:
        Jr(o, u), p & 4 && _s(5, u);
        break;
      case 1:
        if (Jr(o, u), p & 4)
          if (o = u.stateNode, i === null)
            try {
              o.componentDidMount();
            } catch (j) {
              ot(u, u.return, j);
            }
          else {
            var y = ba(
              u.type,
              i.memoizedProps
            );
            i = i.memoizedState;
            try {
              o.componentDidUpdate(
                y,
                i,
                o.__reactInternalSnapshotBeforeUpdate
              );
            } catch (j) {
              ot(
                u,
                u.return,
                j
              );
            }
          }
        p & 64 && hb(u), p & 512 && Es(u, u.return);
        break;
      case 3:
        if (Jr(o, u), p & 64 && (o = u.updateQueue, o !== null)) {
          if (i = null, u.child !== null)
            switch (u.child.tag) {
              case 27:
              case 5:
                i = u.child.stateNode;
                break;
              case 1:
                i = u.child.stateNode;
            }
          try {
            ay(o, i);
          } catch (j) {
            ot(u, u.return, j);
          }
        }
        break;
      case 27:
        i === null && p & 4 && bb(u);
      case 26:
      case 5:
        Jr(o, u), i === null && p & 4 && vb(u), p & 512 && Es(u, u.return);
        break;
      case 12:
        Jr(o, u);
        break;
      case 31:
        Jr(o, u), p & 4 && _b(o, u);
        break;
      case 13:
        Jr(o, u), p & 4 && Eb(o, u), p & 64 && (o = u.memoizedState, o !== null && (o = o.dehydrated, o !== null && (u = bM.bind(
          null,
          u
        ), LM(o, u))));
        break;
      case 22:
        if (p = u.memoizedState !== null || Yr, !p) {
          i = i !== null && i.memoizedState !== null || Tt, y = Yr;
          var S = Tt;
          Yr = p, (Tt = i) && !S ? Qr(
            o,
            u,
            (u.subtreeFlags & 8772) !== 0
          ) : Jr(o, u), Yr = y, Tt = S;
        }
        break;
      case 30:
        break;
      default:
        Jr(o, u);
    }
  }
  function Sb(o) {
    var i = o.alternate;
    i !== null && (o.alternate = null, Sb(i)), o.child = null, o.deletions = null, o.sibling = null, o.tag === 5 && (i = o.stateNode, i !== null && ou(i)), o.stateNode = null, o.return = null, o.dependencies = null, o.memoizedProps = null, o.memoizedState = null, o.pendingProps = null, o.stateNode = null, o.updateQueue = null;
  }
  var wt = null, Nn = !1;
  function Xr(o, i, u) {
    for (u = u.child; u !== null; )
      kb(o, i, u), u = u.sibling;
  }
  function kb(o, i, u) {
    if (Nt && typeof Nt.onCommitFiberUnmount == "function")
      try {
        Nt.onCommitFiberUnmount(Xt, u);
      } catch {
      }
    switch (u.tag) {
      case 26:
        Tt || Mr(u, i), Xr(
          o,
          i,
          u
        ), u.memoizedState ? u.memoizedState.count-- : u.stateNode && (u = u.stateNode, u.parentNode.removeChild(u));
        break;
      case 27:
        Tt || Mr(u, i);
        var p = wt, y = Nn;
        Oo(u.type) && (wt = u.stateNode, Nn = !1), Xr(
          o,
          i,
          u
        ), Ds(u.stateNode), wt = p, Nn = y;
        break;
      case 5:
        Tt || Mr(u, i);
      case 6:
        if (p = wt, y = Nn, wt = null, Xr(
          o,
          i,
          u
        ), wt = p, Nn = y, wt !== null)
          if (Nn)
            try {
              (wt.nodeType === 9 ? wt.body : wt.nodeName === "HTML" ? wt.ownerDocument.body : wt).removeChild(u.stateNode);
            } catch (S) {
              ot(
                u,
                i,
                S
              );
            }
          else
            try {
              wt.removeChild(u.stateNode);
            } catch (S) {
              ot(
                u,
                i,
                S
              );
            }
        break;
      case 18:
        wt !== null && (Nn ? (o = wt, hw(
          o.nodeType === 9 ? o.body : o.nodeName === "HTML" ? o.ownerDocument.body : o,
          u.stateNode
        ), vi(o)) : hw(wt, u.stateNode));
        break;
      case 4:
        p = wt, y = Nn, wt = u.stateNode.containerInfo, Nn = !0, Xr(
          o,
          i,
          u
        ), wt = p, Nn = y;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        wo(2, u, i), Tt || wo(4, u, i), Xr(
          o,
          i,
          u
        );
        break;
      case 1:
        Tt || (Mr(u, i), p = u.stateNode, typeof p.componentWillUnmount == "function" && gb(
          u,
          i,
          p
        )), Xr(
          o,
          i,
          u
        );
        break;
      case 21:
        Xr(
          o,
          i,
          u
        );
        break;
      case 22:
        Tt = (p = Tt) || u.memoizedState !== null, Xr(
          o,
          i,
          u
        ), Tt = p;
        break;
      default:
        Xr(
          o,
          i,
          u
        );
    }
  }
  function _b(o, i) {
    if (i.memoizedState === null && (o = i.alternate, o !== null && (o = o.memoizedState, o !== null))) {
      o = o.dehydrated;
      try {
        vi(o);
      } catch (u) {
        ot(i, i.return, u);
      }
    }
  }
  function Eb(o, i) {
    if (i.memoizedState === null && (o = i.alternate, o !== null && (o = o.memoizedState, o !== null && (o = o.dehydrated, o !== null))))
      try {
        vi(o);
      } catch (u) {
        ot(i, i.return, u);
      }
  }
  function dM(o) {
    switch (o.tag) {
      case 31:
      case 13:
      case 19:
        var i = o.stateNode;
        return i === null && (i = o.stateNode = new wb()), i;
      case 22:
        return o = o.stateNode, i = o._retryCache, i === null && (i = o._retryCache = new wb()), i;
      default:
        throw Error(r(435, o.tag));
    }
  }
  function Uu(o, i) {
    var u = dM(o);
    i.forEach(function(p) {
      if (!u.has(p)) {
        u.add(p);
        var y = wM.bind(null, o, p);
        p.then(y, y);
      }
    });
  }
  function An(o, i) {
    var u = i.deletions;
    if (u !== null)
      for (var p = 0; p < u.length; p++) {
        var y = u[p], S = o, j = i, T = j;
        e: for (; T !== null; ) {
          switch (T.tag) {
            case 27:
              if (Oo(T.type)) {
                wt = T.stateNode, Nn = !1;
                break e;
              }
              break;
            case 5:
              wt = T.stateNode, Nn = !1;
              break e;
            case 3:
            case 4:
              wt = T.stateNode.containerInfo, Nn = !0;
              break e;
          }
          T = T.return;
        }
        if (wt === null) throw Error(r(160));
        kb(S, j, y), wt = null, Nn = !1, S = y.alternate, S !== null && (S.return = null), y.return = null;
      }
    if (i.subtreeFlags & 13886)
      for (i = i.child; i !== null; )
        Cb(i, o), i = i.sibling;
  }
  var br = null;
  function Cb(o, i) {
    var u = o.alternate, p = o.flags;
    switch (o.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        An(i, o), Rn(o), p & 4 && (wo(3, o, o.return), _s(3, o), wo(5, o, o.return));
        break;
      case 1:
        An(i, o), Rn(o), p & 512 && (Tt || u === null || Mr(u, u.return)), p & 64 && Yr && (o = o.updateQueue, o !== null && (p = o.callbacks, p !== null && (u = o.shared.hiddenCallbacks, o.shared.hiddenCallbacks = u === null ? p : u.concat(p))));
        break;
      case 26:
        var y = br;
        if (An(i, o), Rn(o), p & 512 && (Tt || u === null || Mr(u, u.return)), p & 4) {
          var S = u !== null ? u.memoizedState : null;
          if (p = o.memoizedState, u === null)
            if (p === null)
              if (o.stateNode === null) {
                e: {
                  p = o.type, u = o.memoizedProps, y = y.ownerDocument || y;
                  t: switch (p) {
                    case "title":
                      S = y.getElementsByTagName("title")[0], (!S || S[La] || S[en] || S.namespaceURI === "http://www.w3.org/2000/svg" || S.hasAttribute("itemprop")) && (S = y.createElement(p), y.head.insertBefore(
                        S,
                        y.querySelector("head > title")
                      )), ln(S, p, u), S[en] = o, Wt(S), p = S;
                      break e;
                    case "link":
                      var j = Cw(
                        "link",
                        "href",
                        y
                      ).get(p + (u.href || ""));
                      if (j) {
                        for (var T = 0; T < j.length; T++)
                          if (S = j[T], S.getAttribute("href") === (u.href == null || u.href === "" ? null : u.href) && S.getAttribute("rel") === (u.rel == null ? null : u.rel) && S.getAttribute("title") === (u.title == null ? null : u.title) && S.getAttribute("crossorigin") === (u.crossOrigin == null ? null : u.crossOrigin)) {
                            j.splice(T, 1);
                            break t;
                          }
                      }
                      S = y.createElement(p), ln(S, p, u), y.head.appendChild(S);
                      break;
                    case "meta":
                      if (j = Cw(
                        "meta",
                        "content",
                        y
                      ).get(p + (u.content || ""))) {
                        for (T = 0; T < j.length; T++)
                          if (S = j[T], S.getAttribute("content") === (u.content == null ? null : "" + u.content) && S.getAttribute("name") === (u.name == null ? null : u.name) && S.getAttribute("property") === (u.property == null ? null : u.property) && S.getAttribute("http-equiv") === (u.httpEquiv == null ? null : u.httpEquiv) && S.getAttribute("charset") === (u.charSet == null ? null : u.charSet)) {
                            j.splice(T, 1);
                            break t;
                          }
                      }
                      S = y.createElement(p), ln(S, p, u), y.head.appendChild(S);
                      break;
                    default:
                      throw Error(r(468, p));
                  }
                  S[en] = o, Wt(S), p = S;
                }
                o.stateNode = p;
              } else
                Ow(
                  y,
                  o.type,
                  o.stateNode
                );
            else
              o.stateNode = Ew(
                y,
                p,
                o.memoizedProps
              );
          else
            S !== p ? (S === null ? u.stateNode !== null && (u = u.stateNode, u.parentNode.removeChild(u)) : S.count--, p === null ? Ow(
              y,
              o.type,
              o.stateNode
            ) : Ew(
              y,
              p,
              o.memoizedProps
            )) : p === null && o.stateNode !== null && kp(
              o,
              o.memoizedProps,
              u.memoizedProps
            );
        }
        break;
      case 27:
        An(i, o), Rn(o), p & 512 && (Tt || u === null || Mr(u, u.return)), u !== null && p & 4 && kp(
          o,
          o.memoizedProps,
          u.memoizedProps
        );
        break;
      case 5:
        if (An(i, o), Rn(o), p & 512 && (Tt || u === null || Mr(u, u.return)), o.flags & 32) {
          y = o.stateNode;
          try {
            Fa(y, "");
          } catch (we) {
            ot(o, o.return, we);
          }
        }
        p & 4 && o.stateNode != null && (y = o.memoizedProps, kp(
          o,
          y,
          u !== null ? u.memoizedProps : y
        )), p & 1024 && (Cp = !0);
        break;
      case 6:
        if (An(i, o), Rn(o), p & 4) {
          if (o.stateNode === null)
            throw Error(r(162));
          p = o.memoizedProps, u = o.stateNode;
          try {
            u.nodeValue = p;
          } catch (we) {
            ot(o, o.return, we);
          }
        }
        break;
      case 3:
        if (oc = null, y = br, br = nc(i.containerInfo), An(i, o), br = y, Rn(o), p & 4 && u !== null && u.memoizedState.isDehydrated)
          try {
            vi(i.containerInfo);
          } catch (we) {
            ot(o, o.return, we);
          }
        Cp && (Cp = !1, Ob(o));
        break;
      case 4:
        p = br, br = nc(
          o.stateNode.containerInfo
        ), An(i, o), Rn(o), br = p;
        break;
      case 12:
        An(i, o), Rn(o);
        break;
      case 31:
        An(i, o), Rn(o), p & 4 && (p = o.updateQueue, p !== null && (o.updateQueue = null, Uu(o, p)));
        break;
      case 13:
        An(i, o), Rn(o), o.child.flags & 8192 && o.memoizedState !== null != (u !== null && u.memoizedState !== null) && (Hu = Ce()), p & 4 && (p = o.updateQueue, p !== null && (o.updateQueue = null, Uu(o, p)));
        break;
      case 22:
        y = o.memoizedState !== null;
        var X = u !== null && u.memoizedState !== null, ne = Yr, ue = Tt;
        if (Yr = ne || y, Tt = ue || X, An(i, o), Tt = ue, Yr = ne, Rn(o), p & 8192)
          e: for (i = o.stateNode, i._visibility = y ? i._visibility & -2 : i._visibility | 1, y && (u === null || X || Yr || Tt || wa(o)), u = null, i = o; ; ) {
            if (i.tag === 5 || i.tag === 26) {
              if (u === null) {
                X = u = i;
                try {
                  if (S = X.stateNode, y)
                    j = S.style, typeof j.setProperty == "function" ? j.setProperty("display", "none", "important") : j.display = "none";
                  else {
                    T = X.stateNode;
                    var pe = X.memoizedProps.style, ae = pe != null && pe.hasOwnProperty("display") ? pe.display : null;
                    T.style.display = ae == null || typeof ae == "boolean" ? "" : ("" + ae).trim();
                  }
                } catch (we) {
                  ot(X, X.return, we);
                }
              }
            } else if (i.tag === 6) {
              if (u === null) {
                X = i;
                try {
                  X.stateNode.nodeValue = y ? "" : X.memoizedProps;
                } catch (we) {
                  ot(X, X.return, we);
                }
              }
            } else if (i.tag === 18) {
              if (u === null) {
                X = i;
                try {
                  var se = X.stateNode;
                  y ? gw(se, !0) : gw(X.stateNode, !1);
                } catch (we) {
                  ot(X, X.return, we);
                }
              }
            } else if ((i.tag !== 22 && i.tag !== 23 || i.memoizedState === null || i === o) && i.child !== null) {
              i.child.return = i, i = i.child;
              continue;
            }
            if (i === o) break e;
            for (; i.sibling === null; ) {
              if (i.return === null || i.return === o) break e;
              u === i && (u = null), i = i.return;
            }
            u === i && (u = null), i.sibling.return = i.return, i = i.sibling;
          }
        p & 4 && (p = o.updateQueue, p !== null && (u = p.retryQueue, u !== null && (p.retryQueue = null, Uu(o, u))));
        break;
      case 19:
        An(i, o), Rn(o), p & 4 && (p = o.updateQueue, p !== null && (o.updateQueue = null, Uu(o, p)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        An(i, o), Rn(o);
    }
  }
  function Rn(o) {
    var i = o.flags;
    if (i & 2) {
      try {
        for (var u, p = o.return; p !== null; ) {
          if (yb(p)) {
            u = p;
            break;
          }
          p = p.return;
        }
        if (u == null) throw Error(r(160));
        switch (u.tag) {
          case 27:
            var y = u.stateNode, S = _p(o);
            Bu(o, S, y);
            break;
          case 5:
            var j = u.stateNode;
            u.flags & 32 && (Fa(j, ""), u.flags &= -33);
            var T = _p(o);
            Bu(o, T, j);
            break;
          case 3:
          case 4:
            var X = u.stateNode.containerInfo, ne = _p(o);
            Ep(
              o,
              ne,
              X
            );
            break;
          default:
            throw Error(r(161));
        }
      } catch (ue) {
        ot(o, o.return, ue);
      }
      o.flags &= -3;
    }
    i & 4096 && (o.flags &= -4097);
  }
  function Ob(o) {
    if (o.subtreeFlags & 1024)
      for (o = o.child; o !== null; ) {
        var i = o;
        Ob(i), i.tag === 5 && i.flags & 1024 && i.stateNode.reset(), o = o.sibling;
      }
  }
  function Jr(o, i) {
    if (i.subtreeFlags & 8772)
      for (i = i.child; i !== null; )
        xb(o, i.alternate, i), i = i.sibling;
  }
  function wa(o) {
    for (o = o.child; o !== null; ) {
      var i = o;
      switch (i.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          wo(4, i, i.return), wa(i);
          break;
        case 1:
          Mr(i, i.return);
          var u = i.stateNode;
          typeof u.componentWillUnmount == "function" && gb(
            i,
            i.return,
            u
          ), wa(i);
          break;
        case 27:
          Ds(i.stateNode);
        case 26:
        case 5:
          Mr(i, i.return), wa(i);
          break;
        case 22:
          i.memoizedState === null && wa(i);
          break;
        case 30:
          wa(i);
          break;
        default:
          wa(i);
      }
      o = o.sibling;
    }
  }
  function Qr(o, i, u) {
    for (u = u && (i.subtreeFlags & 8772) !== 0, i = i.child; i !== null; ) {
      var p = i.alternate, y = o, S = i, j = S.flags;
      switch (S.tag) {
        case 0:
        case 11:
        case 15:
          Qr(
            y,
            S,
            u
          ), _s(4, S);
          break;
        case 1:
          if (Qr(
            y,
            S,
            u
          ), p = S, y = p.stateNode, typeof y.componentDidMount == "function")
            try {
              y.componentDidMount();
            } catch (ne) {
              ot(p, p.return, ne);
            }
          if (p = S, y = p.updateQueue, y !== null) {
            var T = p.stateNode;
            try {
              var X = y.shared.hiddenCallbacks;
              if (X !== null)
                for (y.shared.hiddenCallbacks = null, y = 0; y < X.length; y++)
                  oy(X[y], T);
            } catch (ne) {
              ot(p, p.return, ne);
            }
          }
          u && j & 64 && hb(S), Es(S, S.return);
          break;
        case 27:
          bb(S);
        case 26:
        case 5:
          Qr(
            y,
            S,
            u
          ), u && p === null && j & 4 && vb(S), Es(S, S.return);
          break;
        case 12:
          Qr(
            y,
            S,
            u
          );
          break;
        case 31:
          Qr(
            y,
            S,
            u
          ), u && j & 4 && _b(y, S);
          break;
        case 13:
          Qr(
            y,
            S,
            u
          ), u && j & 4 && Eb(y, S);
          break;
        case 22:
          S.memoizedState === null && Qr(
            y,
            S,
            u
          ), Es(S, S.return);
          break;
        case 30:
          break;
        default:
          Qr(
            y,
            S,
            u
          );
      }
      i = i.sibling;
    }
  }
  function Op(o, i) {
    var u = null;
    o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (u = o.memoizedState.cachePool.pool), o = null, i.memoizedState !== null && i.memoizedState.cachePool !== null && (o = i.memoizedState.cachePool.pool), o !== u && (o != null && o.refCount++, u != null && ds(u));
  }
  function Mp(o, i) {
    o = null, i.alternate !== null && (o = i.alternate.memoizedState.cache), i = i.memoizedState.cache, i !== o && (i.refCount++, o != null && ds(o));
  }
  function wr(o, i, u, p) {
    if (i.subtreeFlags & 10256)
      for (i = i.child; i !== null; )
        Mb(
          o,
          i,
          u,
          p
        ), i = i.sibling;
  }
  function Mb(o, i, u, p) {
    var y = i.flags;
    switch (i.tag) {
      case 0:
      case 11:
      case 15:
        wr(
          o,
          i,
          u,
          p
        ), y & 2048 && _s(9, i);
        break;
      case 1:
        wr(
          o,
          i,
          u,
          p
        );
        break;
      case 3:
        wr(
          o,
          i,
          u,
          p
        ), y & 2048 && (o = null, i.alternate !== null && (o = i.alternate.memoizedState.cache), i = i.memoizedState.cache, i !== o && (i.refCount++, o != null && ds(o)));
        break;
      case 12:
        if (y & 2048) {
          wr(
            o,
            i,
            u,
            p
          ), o = i.stateNode;
          try {
            var S = i.memoizedProps, j = S.id, T = S.onPostCommit;
            typeof T == "function" && T(
              j,
              i.alternate === null ? "mount" : "update",
              o.passiveEffectDuration,
              -0
            );
          } catch (X) {
            ot(i, i.return, X);
          }
        } else
          wr(
            o,
            i,
            u,
            p
          );
        break;
      case 31:
        wr(
          o,
          i,
          u,
          p
        );
        break;
      case 13:
        wr(
          o,
          i,
          u,
          p
        );
        break;
      case 23:
        break;
      case 22:
        S = i.stateNode, j = i.alternate, i.memoizedState !== null ? S._visibility & 2 ? wr(
          o,
          i,
          u,
          p
        ) : Cs(o, i) : S._visibility & 2 ? wr(
          o,
          i,
          u,
          p
        ) : (S._visibility |= 2, ii(
          o,
          i,
          u,
          p,
          (i.subtreeFlags & 10256) !== 0 || !1
        )), y & 2048 && Op(j, i);
        break;
      case 24:
        wr(
          o,
          i,
          u,
          p
        ), y & 2048 && Mp(i.alternate, i);
        break;
      default:
        wr(
          o,
          i,
          u,
          p
        );
    }
  }
  function ii(o, i, u, p, y) {
    for (y = y && ((i.subtreeFlags & 10256) !== 0 || !1), i = i.child; i !== null; ) {
      var S = o, j = i, T = u, X = p, ne = j.flags;
      switch (j.tag) {
        case 0:
        case 11:
        case 15:
          ii(
            S,
            j,
            T,
            X,
            y
          ), _s(8, j);
          break;
        case 23:
          break;
        case 22:
          var ue = j.stateNode;
          j.memoizedState !== null ? ue._visibility & 2 ? ii(
            S,
            j,
            T,
            X,
            y
          ) : Cs(
            S,
            j
          ) : (ue._visibility |= 2, ii(
            S,
            j,
            T,
            X,
            y
          )), y && ne & 2048 && Op(
            j.alternate,
            j
          );
          break;
        case 24:
          ii(
            S,
            j,
            T,
            X,
            y
          ), y && ne & 2048 && Mp(j.alternate, j);
          break;
        default:
          ii(
            S,
            j,
            T,
            X,
            y
          );
      }
      i = i.sibling;
    }
  }
  function Cs(o, i) {
    if (i.subtreeFlags & 10256)
      for (i = i.child; i !== null; ) {
        var u = o, p = i, y = p.flags;
        switch (p.tag) {
          case 22:
            Cs(u, p), y & 2048 && Op(
              p.alternate,
              p
            );
            break;
          case 24:
            Cs(u, p), y & 2048 && Mp(p.alternate, p);
            break;
          default:
            Cs(u, p);
        }
        i = i.sibling;
      }
  }
  var Os = 8192;
  function si(o, i, u) {
    if (o.subtreeFlags & Os)
      for (o = o.child; o !== null; )
        Nb(
          o,
          i,
          u
        ), o = o.sibling;
  }
  function Nb(o, i, u) {
    switch (o.tag) {
      case 26:
        si(
          o,
          i,
          u
        ), o.flags & Os && o.memoizedState !== null && JM(
          u,
          br,
          o.memoizedState,
          o.memoizedProps
        );
        break;
      case 5:
        si(
          o,
          i,
          u
        );
        break;
      case 3:
      case 4:
        var p = br;
        br = nc(o.stateNode.containerInfo), si(
          o,
          i,
          u
        ), br = p;
        break;
      case 22:
        o.memoizedState === null && (p = o.alternate, p !== null && p.memoizedState !== null ? (p = Os, Os = 16777216, si(
          o,
          i,
          u
        ), Os = p) : si(
          o,
          i,
          u
        ));
        break;
      default:
        si(
          o,
          i,
          u
        );
    }
  }
  function Ab(o) {
    var i = o.alternate;
    if (i !== null && (o = i.child, o !== null)) {
      i.child = null;
      do
        i = o.sibling, o.sibling = null, o = i;
      while (o !== null);
    }
  }
  function Ms(o) {
    var i = o.deletions;
    if ((o.flags & 16) !== 0) {
      if (i !== null)
        for (var u = 0; u < i.length; u++) {
          var p = i[u];
          tn = p, jb(
            p,
            o
          );
        }
      Ab(o);
    }
    if (o.subtreeFlags & 10256)
      for (o = o.child; o !== null; )
        Rb(o), o = o.sibling;
  }
  function Rb(o) {
    switch (o.tag) {
      case 0:
      case 11:
      case 15:
        Ms(o), o.flags & 2048 && wo(9, o, o.return);
        break;
      case 3:
        Ms(o);
        break;
      case 12:
        Ms(o);
        break;
      case 22:
        var i = o.stateNode;
        o.memoizedState !== null && i._visibility & 2 && (o.return === null || o.return.tag !== 13) ? (i._visibility &= -3, Vu(o)) : Ms(o);
        break;
      default:
        Ms(o);
    }
  }
  function Vu(o) {
    var i = o.deletions;
    if ((o.flags & 16) !== 0) {
      if (i !== null)
        for (var u = 0; u < i.length; u++) {
          var p = i[u];
          tn = p, jb(
            p,
            o
          );
        }
      Ab(o);
    }
    for (o = o.child; o !== null; ) {
      switch (i = o, i.tag) {
        case 0:
        case 11:
        case 15:
          wo(8, i, i.return), Vu(i);
          break;
        case 22:
          u = i.stateNode, u._visibility & 2 && (u._visibility &= -3, Vu(i));
          break;
        default:
          Vu(i);
      }
      o = o.sibling;
    }
  }
  function jb(o, i) {
    for (; tn !== null; ) {
      var u = tn;
      switch (u.tag) {
        case 0:
        case 11:
        case 15:
          wo(8, u, i);
          break;
        case 23:
        case 22:
          if (u.memoizedState !== null && u.memoizedState.cachePool !== null) {
            var p = u.memoizedState.cachePool.pool;
            p != null && p.refCount++;
          }
          break;
        case 24:
          ds(u.memoizedState.cache);
      }
      if (p = u.child, p !== null) p.return = u, tn = p;
      else
        e: for (u = o; tn !== null; ) {
          p = tn;
          var y = p.sibling, S = p.return;
          if (Sb(p), p === u) {
            tn = null;
            break e;
          }
          if (y !== null) {
            y.return = S, tn = y;
            break e;
          }
          tn = S;
        }
    }
  }
  var fM = {
    getCacheForType: function(o) {
      var i = an(It), u = i.data.get(o);
      return u === void 0 && (u = o(), i.data.set(o, u)), u;
    },
    cacheSignal: function() {
      return an(It).controller.signal;
    }
  }, pM = typeof WeakMap == "function" ? WeakMap : Map, Ze = 0, ut = null, Be = null, He = 0, rt = 0, Wn = null, xo = !1, li = !1, Np = !1, Zr = 0, _t = 0, So = 0, xa = 0, Ap = 0, qn = 0, ui = 0, Ns = null, jn = null, Rp = !1, Hu = 0, Pb = 0, Wu = 1 / 0, qu = null, ko = null, qt = 0, _o = null, ci = null, eo = 0, jp = 0, Pp = null, Db = null, As = 0, Dp = null;
  function Gn() {
    return (Ze & 2) !== 0 && He !== 0 ? He & -He : $.T !== null ? Fp() : Xd();
  }
  function Ib() {
    if (qn === 0)
      if ((He & 536870912) === 0 || Ke) {
        var o = hn;
        hn <<= 1, (hn & 3932160) === 0 && (hn = 262144), qn = o;
      } else qn = 536870912;
    return o = Vn.current, o !== null && (o.flags |= 32), qn;
  }
  function Pn(o, i, u) {
    (o === ut && (rt === 2 || rt === 9) || o.cancelPendingCommit !== null) && (di(o, 0), Eo(
      o,
      He,
      qn,
      !1
    )), Ta(o, u), ((Ze & 2) === 0 || o !== ut) && (o === ut && ((Ze & 2) === 0 && (xa |= u), _t === 4 && Eo(
      o,
      He,
      qn,
      !1
    )), Nr(o));
  }
  function $b(o, i, u) {
    if ((Ze & 6) !== 0) throw Error(r(327));
    var p = !u && (i & 127) === 0 && (i & o.expiredLanes) === 0 || vr(o, i), y = p ? gM(o, i) : $p(o, i, !0), S = p;
    do {
      if (y === 0) {
        li && !p && Eo(o, i, 0, !1);
        break;
      } else {
        if (u = o.current.alternate, S && !mM(u)) {
          y = $p(o, i, !1), S = !1;
          continue;
        }
        if (y === 2) {
          if (S = i, o.errorRecoveryDisabledLanes & S)
            var j = 0;
          else
            j = o.pendingLanes & -536870913, j = j !== 0 ? j : j & 536870912 ? 536870912 : 0;
          if (j !== 0) {
            i = j;
            e: {
              var T = o;
              y = Ns;
              var X = T.current.memoizedState.isDehydrated;
              if (X && (di(T, j).flags |= 256), j = $p(
                T,
                j,
                !1
              ), j !== 2) {
                if (Np && !X) {
                  T.errorRecoveryDisabledLanes |= S, xa |= S, y = 4;
                  break e;
                }
                S = jn, jn = y, S !== null && (jn === null ? jn = S : jn.push.apply(
                  jn,
                  S
                ));
              }
              y = j;
            }
            if (S = !1, y !== 2) continue;
          }
        }
        if (y === 1) {
          di(o, 0), Eo(o, i, 0, !0);
          break;
        }
        e: {
          switch (p = o, S = y, S) {
            case 0:
            case 1:
              throw Error(r(345));
            case 4:
              if ((i & 4194048) !== i) break;
            case 6:
              Eo(
                p,
                i,
                qn,
                !xo
              );
              break e;
            case 2:
              jn = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(r(329));
          }
          if ((i & 62914560) === i && (y = Hu + 300 - Ce(), 10 < y)) {
            if (Eo(
              p,
              i,
              qn,
              !xo
            ), Vo(p, 0, !0) !== 0) break e;
            eo = i, p.timeoutHandle = pw(
              zb.bind(
                null,
                p,
                u,
                jn,
                qu,
                Rp,
                i,
                qn,
                xa,
                ui,
                xo,
                S,
                "Throttled",
                -0,
                0
              ),
              y
            );
            break e;
          }
          zb(
            p,
            u,
            jn,
            qu,
            Rp,
            i,
            qn,
            xa,
            ui,
            xo,
            S,
            null,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    Nr(o);
  }
  function zb(o, i, u, p, y, S, j, T, X, ne, ue, pe, ae, se) {
    if (o.timeoutHandle = -1, pe = i.subtreeFlags, pe & 8192 || (pe & 16785408) === 16785408) {
      pe = {
        stylesheets: null,
        count: 0,
        imgCount: 0,
        imgBytes: 0,
        suspenseyImages: [],
        waitingForImages: !0,
        waitingForViewTransition: !1,
        unsuspend: Lr
      }, Nb(
        i,
        S,
        pe
      );
      var we = (S & 62914560) === S ? Hu - Ce() : (S & 4194048) === S ? Pb - Ce() : 0;
      if (we = QM(
        pe,
        we
      ), we !== null) {
        eo = S, o.cancelPendingCommit = we(
          Wb.bind(
            null,
            o,
            i,
            S,
            u,
            p,
            y,
            j,
            T,
            X,
            ue,
            pe,
            null,
            ae,
            se
          )
        ), Eo(o, S, j, !ne);
        return;
      }
    }
    Wb(
      o,
      i,
      S,
      u,
      p,
      y,
      j,
      T,
      X
    );
  }
  function mM(o) {
    for (var i = o; ; ) {
      var u = i.tag;
      if ((u === 0 || u === 11 || u === 15) && i.flags & 16384 && (u = i.updateQueue, u !== null && (u = u.stores, u !== null)))
        for (var p = 0; p < u.length; p++) {
          var y = u[p], S = y.getSnapshot;
          y = y.value;
          try {
            if (!Bn(S(), y)) return !1;
          } catch {
            return !1;
          }
        }
      if (u = i.child, i.subtreeFlags & 16384 && u !== null)
        u.return = i, i = u;
      else {
        if (i === o) break;
        for (; i.sibling === null; ) {
          if (i.return === null || i.return === o) return !0;
          i = i.return;
        }
        i.sibling.return = i.return, i = i.sibling;
      }
    }
    return !0;
  }
  function Eo(o, i, u, p) {
    i &= ~Ap, i &= ~xa, o.suspendedLanes |= i, o.pingedLanes &= ~i, p && (o.warmLanes |= i), p = o.expirationTimes;
    for (var y = i; 0 < y; ) {
      var S = 31 - Ae(y), j = 1 << S;
      p[S] = -1, y &= ~j;
    }
    u !== 0 && Gd(o, u, i);
  }
  function Gu() {
    return (Ze & 6) === 0 ? (Rs(0), !1) : !0;
  }
  function Ip() {
    if (Be !== null) {
      if (rt === 0)
        var o = Be.return;
      else
        o = Be, Vr = fa = null, Jf(o), ti = null, ps = 0, o = Be;
      for (; o !== null; )
        mb(o.alternate, o), o = o.return;
      Be = null;
    }
  }
  function di(o, i) {
    var u = o.timeoutHandle;
    u !== -1 && (o.timeoutHandle = -1, DM(u)), u = o.cancelPendingCommit, u !== null && (o.cancelPendingCommit = null, u()), eo = 0, Ip(), ut = o, Be = u = Br(o.current, null), He = i, rt = 0, Wn = null, xo = !1, li = vr(o, i), Np = !1, ui = qn = Ap = xa = So = _t = 0, jn = Ns = null, Rp = !1, (i & 8) !== 0 && (i |= i & 32);
    var p = o.entangledLanes;
    if (p !== 0)
      for (o = o.entanglements, p &= i; 0 < p; ) {
        var y = 31 - Ae(p), S = 1 << y;
        i |= o[y], p &= ~S;
      }
    return Zr = i, mu(), u;
  }
  function Tb(o, i) {
    ze = null, $.H = xs, i === ei || i === Su ? (i = ey(), rt = 3) : i === Lf ? (i = ey(), rt = 4) : rt = i === pp ? 8 : i !== null && typeof i == "object" && typeof i.then == "function" ? 6 : 1, Wn = i, Be === null && (_t = 1, $u(
      o,
      nr(i, o.current)
    ));
  }
  function Lb() {
    var o = Vn.current;
    return o === null ? !0 : (He & 4194048) === He ? fr === null : (He & 62914560) === He || (He & 536870912) !== 0 ? o === fr : !1;
  }
  function Fb() {
    var o = $.H;
    return $.H = xs, o === null ? xs : o;
  }
  function Bb() {
    var o = $.A;
    return $.A = fM, o;
  }
  function Ku() {
    _t = 4, xo || (He & 4194048) !== He && Vn.current !== null || (li = !0), (So & 134217727) === 0 && (xa & 134217727) === 0 || ut === null || Eo(
      ut,
      He,
      qn,
      !1
    );
  }
  function $p(o, i, u) {
    var p = Ze;
    Ze |= 2;
    var y = Fb(), S = Bb();
    (ut !== o || He !== i) && (qu = null, di(o, i)), i = !1;
    var j = _t;
    e: do
      try {
        if (rt !== 0 && Be !== null) {
          var T = Be, X = Wn;
          switch (rt) {
            case 8:
              Ip(), j = 6;
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              Vn.current === null && (i = !0);
              var ne = rt;
              if (rt = 0, Wn = null, fi(o, T, X, ne), u && li) {
                j = 0;
                break e;
              }
              break;
            default:
              ne = rt, rt = 0, Wn = null, fi(o, T, X, ne);
          }
        }
        hM(), j = _t;
        break;
      } catch (ue) {
        Tb(o, ue);
      }
    while (!0);
    return i && o.shellSuspendCounter++, Vr = fa = null, Ze = p, $.H = y, $.A = S, Be === null && (ut = null, He = 0, mu()), j;
  }
  function hM() {
    for (; Be !== null; ) Ub(Be);
  }
  function gM(o, i) {
    var u = Ze;
    Ze |= 2;
    var p = Fb(), y = Bb();
    ut !== o || He !== i ? (qu = null, Wu = Ce() + 500, di(o, i)) : li = vr(
      o,
      i
    );
    e: do
      try {
        if (rt !== 0 && Be !== null) {
          i = Be;
          var S = Wn;
          t: switch (rt) {
            case 1:
              rt = 0, Wn = null, fi(o, i, S, 1);
              break;
            case 2:
            case 9:
              if (Qv(S)) {
                rt = 0, Wn = null, Vb(i);
                break;
              }
              i = function() {
                rt !== 2 && rt !== 9 || ut !== o || (rt = 7), Nr(o);
              }, S.then(i, i);
              break e;
            case 3:
              rt = 7;
              break e;
            case 4:
              rt = 5;
              break e;
            case 7:
              Qv(S) ? (rt = 0, Wn = null, Vb(i)) : (rt = 0, Wn = null, fi(o, i, S, 7));
              break;
            case 5:
              var j = null;
              switch (Be.tag) {
                case 26:
                  j = Be.memoizedState;
                case 5:
                case 27:
                  var T = Be;
                  if (j ? Mw(j) : T.stateNode.complete) {
                    rt = 0, Wn = null;
                    var X = T.sibling;
                    if (X !== null) Be = X;
                    else {
                      var ne = T.return;
                      ne !== null ? (Be = ne, Yu(ne)) : Be = null;
                    }
                    break t;
                  }
              }
              rt = 0, Wn = null, fi(o, i, S, 5);
              break;
            case 6:
              rt = 0, Wn = null, fi(o, i, S, 6);
              break;
            case 8:
              Ip(), _t = 6;
              break e;
            default:
              throw Error(r(462));
          }
        }
        vM();
        break;
      } catch (ue) {
        Tb(o, ue);
      }
    while (!0);
    return Vr = fa = null, $.H = p, $.A = y, Ze = u, Be !== null ? 0 : (ut = null, He = 0, mu(), _t);
  }
  function vM() {
    for (; Be !== null && !cn(); )
      Ub(Be);
  }
  function Ub(o) {
    var i = fb(o.alternate, o, Zr);
    o.memoizedProps = o.pendingProps, i === null ? Yu(o) : Be = i;
  }
  function Vb(o) {
    var i = o, u = i.alternate;
    switch (i.tag) {
      case 15:
      case 0:
        i = ib(
          u,
          i,
          i.pendingProps,
          i.type,
          void 0,
          He
        );
        break;
      case 11:
        i = ib(
          u,
          i,
          i.pendingProps,
          i.type.render,
          i.ref,
          He
        );
        break;
      case 5:
        Jf(i);
      default:
        mb(u, i), i = Be = Bv(i, Zr), i = fb(u, i, Zr);
    }
    o.memoizedProps = o.pendingProps, i === null ? Yu(o) : Be = i;
  }
  function fi(o, i, u, p) {
    Vr = fa = null, Jf(i), ti = null, ps = 0;
    var y = i.return;
    try {
      if (aM(
        o,
        y,
        i,
        u,
        He
      )) {
        _t = 1, $u(
          o,
          nr(u, o.current)
        ), Be = null;
        return;
      }
    } catch (S) {
      if (y !== null) throw Be = y, S;
      _t = 1, $u(
        o,
        nr(u, o.current)
      ), Be = null;
      return;
    }
    i.flags & 32768 ? (Ke || p === 1 ? o = !0 : li || (He & 536870912) !== 0 ? o = !1 : (xo = o = !0, (p === 2 || p === 9 || p === 3 || p === 6) && (p = Vn.current, p !== null && p.tag === 13 && (p.flags |= 16384))), Hb(i, o)) : Yu(i);
  }
  function Yu(o) {
    var i = o;
    do {
      if ((i.flags & 32768) !== 0) {
        Hb(
          i,
          xo
        );
        return;
      }
      o = i.return;
      var u = lM(
        i.alternate,
        i,
        Zr
      );
      if (u !== null) {
        Be = u;
        return;
      }
      if (i = i.sibling, i !== null) {
        Be = i;
        return;
      }
      Be = i = o;
    } while (i !== null);
    _t === 0 && (_t = 5);
  }
  function Hb(o, i) {
    do {
      var u = uM(o.alternate, o);
      if (u !== null) {
        u.flags &= 32767, Be = u;
        return;
      }
      if (u = o.return, u !== null && (u.flags |= 32768, u.subtreeFlags = 0, u.deletions = null), !i && (o = o.sibling, o !== null)) {
        Be = o;
        return;
      }
      Be = o = u;
    } while (o !== null);
    _t = 6, Be = null;
  }
  function Wb(o, i, u, p, y, S, j, T, X) {
    o.cancelPendingCommit = null;
    do
      Xu();
    while (qt !== 0);
    if ((Ze & 6) !== 0) throw Error(r(327));
    if (i !== null) {
      if (i === o.current) throw Error(r(177));
      if (S = i.lanes | i.childLanes, S |= _f, ev(
        o,
        u,
        S,
        j,
        T,
        X
      ), o === ut && (Be = ut = null, He = 0), ci = i, _o = o, eo = u, jp = S, Pp = y, Db = p, (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0 ? (o.callbackNode = null, o.callbackPriority = 0, xM(Ee, function() {
        return Xb(), null;
      })) : (o.callbackNode = null, o.callbackPriority = 0), p = (i.flags & 13878) !== 0, (i.subtreeFlags & 13878) !== 0 || p) {
        p = $.T, $.T = null, y = K.p, K.p = 2, j = Ze, Ze |= 4;
        try {
          cM(o, i, u);
        } finally {
          Ze = j, K.p = y, $.T = p;
        }
      }
      qt = 1, qb(), Gb(), Kb();
    }
  }
  function qb() {
    if (qt === 1) {
      qt = 0;
      var o = _o, i = ci, u = (i.flags & 13878) !== 0;
      if ((i.subtreeFlags & 13878) !== 0 || u) {
        u = $.T, $.T = null;
        var p = K.p;
        K.p = 2;
        var y = Ze;
        Ze |= 4;
        try {
          Cb(i, o);
          var S = Kp, j = jv(o.containerInfo), T = S.focusedElem, X = S.selectionRange;
          if (j !== T && T && T.ownerDocument && Rv(
            T.ownerDocument.documentElement,
            T
          )) {
            if (X !== null && bf(T)) {
              var ne = X.start, ue = X.end;
              if (ue === void 0 && (ue = ne), "selectionStart" in T)
                T.selectionStart = ne, T.selectionEnd = Math.min(
                  ue,
                  T.value.length
                );
              else {
                var pe = T.ownerDocument || document, ae = pe && pe.defaultView || window;
                if (ae.getSelection) {
                  var se = ae.getSelection(), we = T.textContent.length, Ne = Math.min(X.start, we), st = X.end === void 0 ? Ne : Math.min(X.end, we);
                  !se.extend && Ne > st && (j = st, st = Ne, Ne = j);
                  var ee = Av(
                    T,
                    Ne
                  ), Q = Av(
                    T,
                    st
                  );
                  if (ee && Q && (se.rangeCount !== 1 || se.anchorNode !== ee.node || se.anchorOffset !== ee.offset || se.focusNode !== Q.node || se.focusOffset !== Q.offset)) {
                    var te = pe.createRange();
                    te.setStart(ee.node, ee.offset), se.removeAllRanges(), Ne > st ? (se.addRange(te), se.extend(Q.node, Q.offset)) : (te.setEnd(Q.node, Q.offset), se.addRange(te));
                  }
                }
              }
            }
            for (pe = [], se = T; se = se.parentNode; )
              se.nodeType === 1 && pe.push({
                element: se,
                left: se.scrollLeft,
                top: se.scrollTop
              });
            for (typeof T.focus == "function" && T.focus(), T = 0; T < pe.length; T++) {
              var de = pe[T];
              de.element.scrollLeft = de.left, de.element.scrollTop = de.top;
            }
          }
          lc = !!Gp, Kp = Gp = null;
        } finally {
          Ze = y, K.p = p, $.T = u;
        }
      }
      o.current = i, qt = 2;
    }
  }
  function Gb() {
    if (qt === 2) {
      qt = 0;
      var o = _o, i = ci, u = (i.flags & 8772) !== 0;
      if ((i.subtreeFlags & 8772) !== 0 || u) {
        u = $.T, $.T = null;
        var p = K.p;
        K.p = 2;
        var y = Ze;
        Ze |= 4;
        try {
          xb(o, i.alternate, i);
        } finally {
          Ze = y, K.p = p, $.T = u;
        }
      }
      qt = 3;
    }
  }
  function Kb() {
    if (qt === 4 || qt === 3) {
      qt = 0, pt();
      var o = _o, i = ci, u = eo, p = Db;
      (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0 ? qt = 5 : (qt = 0, ci = _o = null, Yb(o, o.pendingLanes));
      var y = o.pendingLanes;
      if (y === 0 && (ko = null), ru(u), i = i.stateNode, Nt && typeof Nt.onCommitFiberRoot == "function")
        try {
          Nt.onCommitFiberRoot(
            Xt,
            i,
            void 0,
            (i.current.flags & 128) === 128
          );
        } catch {
        }
      if (p !== null) {
        i = $.T, y = K.p, K.p = 2, $.T = null;
        try {
          for (var S = o.onRecoverableError, j = 0; j < p.length; j++) {
            var T = p[j];
            S(T.value, {
              componentStack: T.stack
            });
          }
        } finally {
          $.T = i, K.p = y;
        }
      }
      (eo & 3) !== 0 && Xu(), Nr(o), y = o.pendingLanes, (u & 261930) !== 0 && (y & 42) !== 0 ? o === Dp ? As++ : (As = 0, Dp = o) : As = 0, Rs(0);
    }
  }
  function Yb(o, i) {
    (o.pooledCacheLanes &= i) === 0 && (i = o.pooledCache, i != null && (o.pooledCache = null, ds(i)));
  }
  function Xu() {
    return qb(), Gb(), Kb(), Xb();
  }
  function Xb() {
    if (qt !== 5) return !1;
    var o = _o, i = jp;
    jp = 0;
    var u = ru(eo), p = $.T, y = K.p;
    try {
      K.p = 32 > u ? 32 : u, $.T = null, u = Pp, Pp = null;
      var S = _o, j = eo;
      if (qt = 0, ci = _o = null, eo = 0, (Ze & 6) !== 0) throw Error(r(331));
      var T = Ze;
      if (Ze |= 4, Rb(S.current), Mb(
        S,
        S.current,
        j,
        u
      ), Ze = T, Rs(0, !1), Nt && typeof Nt.onPostCommitFiberRoot == "function")
        try {
          Nt.onPostCommitFiberRoot(Xt, S);
        } catch {
        }
      return !0;
    } finally {
      K.p = y, $.T = p, Yb(o, i);
    }
  }
  function Jb(o, i, u) {
    i = nr(u, i), i = fp(o.stateNode, i, 2), o = vo(o, i, 2), o !== null && (Ta(o, 2), Nr(o));
  }
  function ot(o, i, u) {
    if (o.tag === 3)
      Jb(o, o, u);
    else
      for (; i !== null; ) {
        if (i.tag === 3) {
          Jb(
            i,
            o,
            u
          );
          break;
        } else if (i.tag === 1) {
          var p = i.stateNode;
          if (typeof i.type.getDerivedStateFromError == "function" || typeof p.componentDidCatch == "function" && (ko === null || !ko.has(p))) {
            o = nr(u, o), u = Qy(2), p = vo(i, u, 2), p !== null && (Zy(
              u,
              p,
              i,
              o
            ), Ta(p, 2), Nr(p));
            break;
          }
        }
        i = i.return;
      }
  }
  function zp(o, i, u) {
    var p = o.pingCache;
    if (p === null) {
      p = o.pingCache = new pM();
      var y = /* @__PURE__ */ new Set();
      p.set(i, y);
    } else
      y = p.get(i), y === void 0 && (y = /* @__PURE__ */ new Set(), p.set(i, y));
    y.has(u) || (Np = !0, y.add(u), o = yM.bind(null, o, i, u), i.then(o, o));
  }
  function yM(o, i, u) {
    var p = o.pingCache;
    p !== null && p.delete(i), o.pingedLanes |= o.suspendedLanes & u, o.warmLanes &= ~u, ut === o && (He & u) === u && (_t === 4 || _t === 3 && (He & 62914560) === He && 300 > Ce() - Hu ? (Ze & 2) === 0 && di(o, 0) : Ap |= u, ui === He && (ui = 0)), Nr(o);
  }
  function Qb(o, i) {
    i === 0 && (i = qd()), o = ua(o, i), o !== null && (Ta(o, i), Nr(o));
  }
  function bM(o) {
    var i = o.memoizedState, u = 0;
    i !== null && (u = i.retryLane), Qb(o, u);
  }
  function wM(o, i) {
    var u = 0;
    switch (o.tag) {
      case 31:
      case 13:
        var p = o.stateNode, y = o.memoizedState;
        y !== null && (u = y.retryLane);
        break;
      case 19:
        p = o.stateNode;
        break;
      case 22:
        p = o.stateNode._retryCache;
        break;
      default:
        throw Error(r(314));
    }
    p !== null && p.delete(i), Qb(o, u);
  }
  function xM(o, i) {
    return nt(o, i);
  }
  var Ju = null, pi = null, Tp = !1, Qu = !1, Lp = !1, Co = 0;
  function Nr(o) {
    o !== pi && o.next === null && (pi === null ? Ju = pi = o : pi = pi.next = o), Qu = !0, Tp || (Tp = !0, kM());
  }
  function Rs(o, i) {
    if (!Lp && Qu) {
      Lp = !0;
      do
        for (var u = !1, p = Ju; p !== null; ) {
          if (o !== 0) {
            var y = p.pendingLanes;
            if (y === 0) var S = 0;
            else {
              var j = p.suspendedLanes, T = p.pingedLanes;
              S = (1 << 31 - Ae(42 | o) + 1) - 1, S &= y & ~(j & ~T), S = S & 201326741 ? S & 201326741 | 1 : S ? S | 2 : 0;
            }
            S !== 0 && (u = !0, nw(p, S));
          } else
            S = He, S = Vo(
              p,
              p === ut ? S : 0,
              p.cancelPendingCommit !== null || p.timeoutHandle !== -1
            ), (S & 3) === 0 || vr(p, S) || (u = !0, nw(p, S));
          p = p.next;
        }
      while (u);
      Lp = !1;
    }
  }
  function SM() {
    Zb();
  }
  function Zb() {
    Qu = Tp = !1;
    var o = 0;
    Co !== 0 && PM() && (o = Co);
    for (var i = Ce(), u = null, p = Ju; p !== null; ) {
      var y = p.next, S = ew(p, i);
      S === 0 ? (p.next = null, u === null ? Ju = y : u.next = y, y === null && (pi = u)) : (u = p, (o !== 0 || (S & 3) !== 0) && (Qu = !0)), p = y;
    }
    qt !== 0 && qt !== 5 || Rs(o), Co !== 0 && (Co = 0);
  }
  function ew(o, i) {
    for (var u = o.suspendedLanes, p = o.pingedLanes, y = o.expirationTimes, S = o.pendingLanes & -62914561; 0 < S; ) {
      var j = 31 - Ae(S), T = 1 << j, X = y[j];
      X === -1 ? ((T & u) === 0 || (T & p) !== 0) && (y[j] = Zg(T, i)) : X <= i && (o.expiredLanes |= T), S &= ~T;
    }
    if (i = ut, u = He, u = Vo(
      o,
      o === i ? u : 0,
      o.cancelPendingCommit !== null || o.timeoutHandle !== -1
    ), p = o.callbackNode, u === 0 || o === i && (rt === 2 || rt === 9) || o.cancelPendingCommit !== null)
      return p !== null && p !== null && je(p), o.callbackNode = null, o.callbackPriority = 0;
    if ((u & 3) === 0 || vr(o, u)) {
      if (i = u & -u, i === o.callbackPriority) return i;
      switch (p !== null && je(p), ru(u)) {
        case 2:
        case 8:
          u = ye;
          break;
        case 32:
          u = Ee;
          break;
        case 268435456:
          u = Fe;
          break;
        default:
          u = Ee;
      }
      return p = tw.bind(null, o), u = nt(u, p), o.callbackPriority = i, o.callbackNode = u, i;
    }
    return p !== null && p !== null && je(p), o.callbackPriority = 2, o.callbackNode = null, 2;
  }
  function tw(o, i) {
    if (qt !== 0 && qt !== 5)
      return o.callbackNode = null, o.callbackPriority = 0, null;
    var u = o.callbackNode;
    if (Xu() && o.callbackNode !== u)
      return null;
    var p = He;
    return p = Vo(
      o,
      o === ut ? p : 0,
      o.cancelPendingCommit !== null || o.timeoutHandle !== -1
    ), p === 0 ? null : ($b(o, p, i), ew(o, Ce()), o.callbackNode != null && o.callbackNode === u ? tw.bind(null, o) : null);
  }
  function nw(o, i) {
    if (Xu()) return null;
    $b(o, i, !0);
  }
  function kM() {
    IM(function() {
      (Ze & 6) !== 0 ? nt(
        he,
        SM
      ) : Zb();
    });
  }
  function Fp() {
    if (Co === 0) {
      var o = Qa;
      o === 0 && (o = Uo, Uo <<= 1, (Uo & 261888) === 0 && (Uo = 256)), Co = o;
    }
    return Co;
  }
  function rw(o) {
    return o == null || typeof o == "symbol" || typeof o == "boolean" ? null : typeof o == "function" ? o : iu("" + o);
  }
  function ow(o, i) {
    var u = i.ownerDocument.createElement("input");
    return u.name = i.name, u.value = i.value, o.id && u.setAttribute("form", o.id), i.parentNode.insertBefore(u, i), o = new FormData(o), u.parentNode.removeChild(u), o;
  }
  function _M(o, i, u, p, y) {
    if (i === "submit" && u && u.stateNode === y) {
      var S = rw(
        (y[yn] || null).action
      ), j = p.submitter;
      j && (i = (i = j[yn] || null) ? rw(i.formAction) : j.getAttribute("formAction"), i !== null && (S = i, j = null));
      var T = new cu(
        "action",
        "action",
        null,
        p,
        y
      );
      o.push({
        event: T,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (p.defaultPrevented) {
                if (Co !== 0) {
                  var X = j ? ow(y, j) : new FormData(y);
                  ip(
                    u,
                    {
                      pending: !0,
                      data: X,
                      method: y.method,
                      action: S
                    },
                    null,
                    X
                  );
                }
              } else
                typeof S == "function" && (T.preventDefault(), X = j ? ow(y, j) : new FormData(y), ip(
                  u,
                  {
                    pending: !0,
                    data: X,
                    method: y.method,
                    action: S
                  },
                  S,
                  X
                ));
            },
            currentTarget: y
          }
        ]
      });
    }
  }
  for (var Bp = 0; Bp < kf.length; Bp++) {
    var Up = kf[Bp], EM = Up.toLowerCase(), CM = Up[0].toUpperCase() + Up.slice(1);
    yr(
      EM,
      "on" + CM
    );
  }
  yr(Iv, "onAnimationEnd"), yr($v, "onAnimationIteration"), yr(zv, "onAnimationStart"), yr("dblclick", "onDoubleClick"), yr("focusin", "onFocus"), yr("focusout", "onBlur"), yr(UO, "onTransitionRun"), yr(VO, "onTransitionStart"), yr(HO, "onTransitionCancel"), yr(Tv, "onTransitionEnd"), aa("onMouseEnter", ["mouseout", "mouseover"]), aa("onMouseLeave", ["mouseout", "mouseover"]), aa("onPointerEnter", ["pointerout", "pointerover"]), aa("onPointerLeave", ["pointerout", "pointerover"]), lo(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), lo(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), lo("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), lo(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), lo(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), lo(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var js = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), OM = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(js)
  );
  function aw(o, i) {
    i = (i & 4) !== 0;
    for (var u = 0; u < o.length; u++) {
      var p = o[u], y = p.event;
      p = p.listeners;
      e: {
        var S = void 0;
        if (i)
          for (var j = p.length - 1; 0 <= j; j--) {
            var T = p[j], X = T.instance, ne = T.currentTarget;
            if (T = T.listener, X !== S && y.isPropagationStopped())
              break e;
            S = T, y.currentTarget = ne;
            try {
              S(y);
            } catch (ue) {
              pu(ue);
            }
            y.currentTarget = null, S = X;
          }
        else
          for (j = 0; j < p.length; j++) {
            if (T = p[j], X = T.instance, ne = T.currentTarget, T = T.listener, X !== S && y.isPropagationStopped())
              break e;
            S = T, y.currentTarget = ne;
            try {
              S(y);
            } catch (ue) {
              pu(ue);
            }
            y.currentTarget = null, S = X;
          }
      }
    }
  }
  function Ue(o, i) {
    var u = i[cl];
    u === void 0 && (u = i[cl] = /* @__PURE__ */ new Set());
    var p = o + "__bubble";
    u.has(p) || (iw(i, o, 2, !1), u.add(p));
  }
  function Vp(o, i, u) {
    var p = 0;
    i && (p |= 4), iw(
      u,
      o,
      p,
      i
    );
  }
  var Zu = "_reactListening" + Math.random().toString(36).slice(2);
  function Hp(o) {
    if (!o[Zu]) {
      o[Zu] = !0, Zd.forEach(function(u) {
        u !== "selectionchange" && (OM.has(u) || Vp(u, !1, o), Vp(u, !0, o));
      });
      var i = o.nodeType === 9 ? o : o.ownerDocument;
      i === null || i[Zu] || (i[Zu] = !0, Vp("selectionchange", !1, i));
    }
  }
  function iw(o, i, u, p) {
    switch (Iw(i)) {
      case 2:
        var y = tN;
        break;
      case 8:
        y = nN;
        break;
      default:
        y = am;
    }
    u = y.bind(
      null,
      i,
      u,
      o
    ), y = void 0, !cf || i !== "touchstart" && i !== "touchmove" && i !== "wheel" || (y = !0), p ? y !== void 0 ? o.addEventListener(i, u, {
      capture: !0,
      passive: y
    }) : o.addEventListener(i, u, !0) : y !== void 0 ? o.addEventListener(i, u, {
      passive: y
    }) : o.addEventListener(i, u, !1);
  }
  function Wp(o, i, u, p, y) {
    var S = p;
    if ((i & 1) === 0 && (i & 2) === 0 && p !== null)
      e: for (; ; ) {
        if (p === null) return;
        var j = p.tag;
        if (j === 3 || j === 4) {
          var T = p.stateNode.containerInfo;
          if (T === y) break;
          if (j === 4)
            for (j = p.return; j !== null; ) {
              var X = j.tag;
              if ((X === 3 || X === 4) && j.stateNode.containerInfo === y)
                return;
              j = j.return;
            }
          for (; T !== null; ) {
            if (j = na(T), j === null) return;
            if (X = j.tag, X === 5 || X === 6 || X === 26 || X === 27) {
              p = S = j;
              continue e;
            }
            T = T.parentNode;
          }
        }
        p = p.return;
      }
    dv(function() {
      var ne = S, ue = lf(u), pe = [];
      e: {
        var ae = Lv.get(o);
        if (ae !== void 0) {
          var se = cu, we = o;
          switch (o) {
            case "keypress":
              if (lu(u) === 0) break e;
            case "keydown":
            case "keyup":
              se = wO;
              break;
            case "focusin":
              we = "focus", se = mf;
              break;
            case "focusout":
              we = "blur", se = mf;
              break;
            case "beforeblur":
            case "afterblur":
              se = mf;
              break;
            case "click":
              if (u.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              se = mv;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              se = lO;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              se = kO;
              break;
            case Iv:
            case $v:
            case zv:
              se = dO;
              break;
            case Tv:
              se = EO;
              break;
            case "scroll":
            case "scrollend":
              se = iO;
              break;
            case "wheel":
              se = OO;
              break;
            case "copy":
            case "cut":
            case "paste":
              se = pO;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              se = gv;
              break;
            case "toggle":
            case "beforetoggle":
              se = NO;
          }
          var Ne = (i & 4) !== 0, st = !Ne && (o === "scroll" || o === "scrollend"), ee = Ne ? ae !== null ? ae + "Capture" : null : ae;
          Ne = [];
          for (var Q = ne, te; Q !== null; ) {
            var de = Q;
            if (te = de.stateNode, de = de.tag, de !== 5 && de !== 26 && de !== 27 || te === null || ee === null || (de = es(Q, ee), de != null && Ne.push(
              Ps(Q, de, te)
            )), st) break;
            Q = Q.return;
          }
          0 < Ne.length && (ae = new se(
            ae,
            we,
            null,
            u,
            ue
          ), pe.push({ event: ae, listeners: Ne }));
        }
      }
      if ((i & 7) === 0) {
        e: {
          if (ae = o === "mouseover" || o === "pointerover", se = o === "mouseout" || o === "pointerout", ae && u !== sf && (we = u.relatedTarget || u.fromElement) && (na(we) || we[Ho]))
            break e;
          if ((se || ae) && (ae = ue.window === ue ? ue : (ae = ue.ownerDocument) ? ae.defaultView || ae.parentWindow : window, se ? (we = u.relatedTarget || u.toElement, se = ne, we = we ? na(we) : null, we !== null && (st = s(we), Ne = we.tag, we !== st || Ne !== 5 && Ne !== 27 && Ne !== 6) && (we = null)) : (se = null, we = ne), se !== we)) {
            if (Ne = mv, de = "onMouseLeave", ee = "onMouseEnter", Q = "mouse", (o === "pointerout" || o === "pointerover") && (Ne = gv, de = "onPointerLeave", ee = "onPointerEnter", Q = "pointer"), st = se == null ? ae : Na(se), te = we == null ? ae : Na(we), ae = new Ne(
              de,
              Q + "leave",
              se,
              u,
              ue
            ), ae.target = st, ae.relatedTarget = te, de = null, na(ue) === ne && (Ne = new Ne(
              ee,
              Q + "enter",
              we,
              u,
              ue
            ), Ne.target = te, Ne.relatedTarget = st, de = Ne), st = de, se && we)
              t: {
                for (Ne = MM, ee = se, Q = we, te = 0, de = ee; de; de = Ne(de))
                  te++;
                de = 0;
                for (var Oe = Q; Oe; Oe = Ne(Oe))
                  de++;
                for (; 0 < te - de; )
                  ee = Ne(ee), te--;
                for (; 0 < de - te; )
                  Q = Ne(Q), de--;
                for (; te--; ) {
                  if (ee === Q || Q !== null && ee === Q.alternate) {
                    Ne = ee;
                    break t;
                  }
                  ee = Ne(ee), Q = Ne(Q);
                }
                Ne = null;
              }
            else Ne = null;
            se !== null && sw(
              pe,
              ae,
              se,
              Ne,
              !1
            ), we !== null && st !== null && sw(
              pe,
              st,
              we,
              Ne,
              !0
            );
          }
        }
        e: {
          if (ae = ne ? Na(ne) : window, se = ae.nodeName && ae.nodeName.toLowerCase(), se === "select" || se === "input" && ae.type === "file")
            var Je = _v;
          else if (Sv(ae))
            if (Ev)
              Je = LO;
            else {
              Je = zO;
              var ke = $O;
            }
          else
            se = ae.nodeName, !se || se.toLowerCase() !== "input" || ae.type !== "checkbox" && ae.type !== "radio" ? ne && af(ne.elementType) && (Je = _v) : Je = TO;
          if (Je && (Je = Je(o, ne))) {
            kv(
              pe,
              Je,
              u,
              ue
            );
            break e;
          }
          ke && ke(o, ae, ne), o === "focusout" && ne && ae.type === "number" && ne.memoizedProps.value != null && au(ae, "number", ae.value);
        }
        switch (ke = ne ? Na(ne) : window, o) {
          case "focusin":
            (Sv(ke) || ke.contentEditable === "true") && (Ha = ke, wf = ne, ls = null);
            break;
          case "focusout":
            ls = wf = Ha = null;
            break;
          case "mousedown":
            xf = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            xf = !1, Pv(pe, u, ue);
            break;
          case "selectionchange":
            if (BO) break;
          case "keydown":
          case "keyup":
            Pv(pe, u, ue);
        }
        var Le;
        if (gf)
          e: {
            switch (o) {
              case "compositionstart":
                var We = "onCompositionStart";
                break e;
              case "compositionend":
                We = "onCompositionEnd";
                break e;
              case "compositionupdate":
                We = "onCompositionUpdate";
                break e;
            }
            We = void 0;
          }
        else
          Va ? wv(o, u) && (We = "onCompositionEnd") : o === "keydown" && u.keyCode === 229 && (We = "onCompositionStart");
        We && (vv && u.locale !== "ko" && (Va || We !== "onCompositionStart" ? We === "onCompositionEnd" && Va && (Le = fv()) : (uo = ue, df = "value" in uo ? uo.value : uo.textContent, Va = !0)), ke = ec(ne, We), 0 < ke.length && (We = new hv(
          We,
          o,
          null,
          u,
          ue
        ), pe.push({ event: We, listeners: ke }), Le ? We.data = Le : (Le = xv(u), Le !== null && (We.data = Le)))), (Le = RO ? jO(o, u) : PO(o, u)) && (We = ec(ne, "onBeforeInput"), 0 < We.length && (ke = new hv(
          "onBeforeInput",
          "beforeinput",
          null,
          u,
          ue
        ), pe.push({
          event: ke,
          listeners: We
        }), ke.data = Le)), _M(
          pe,
          o,
          ne,
          u,
          ue
        );
      }
      aw(pe, i);
    });
  }
  function Ps(o, i, u) {
    return {
      instance: o,
      listener: i,
      currentTarget: u
    };
  }
  function ec(o, i) {
    for (var u = i + "Capture", p = []; o !== null; ) {
      var y = o, S = y.stateNode;
      if (y = y.tag, y !== 5 && y !== 26 && y !== 27 || S === null || (y = es(o, u), y != null && p.unshift(
        Ps(o, y, S)
      ), y = es(o, i), y != null && p.push(
        Ps(o, y, S)
      )), o.tag === 3) return p;
      o = o.return;
    }
    return [];
  }
  function MM(o) {
    if (o === null) return null;
    do
      o = o.return;
    while (o && o.tag !== 5 && o.tag !== 27);
    return o || null;
  }
  function sw(o, i, u, p, y) {
    for (var S = i._reactName, j = []; u !== null && u !== p; ) {
      var T = u, X = T.alternate, ne = T.stateNode;
      if (T = T.tag, X !== null && X === p) break;
      T !== 5 && T !== 26 && T !== 27 || ne === null || (X = ne, y ? (ne = es(u, S), ne != null && j.unshift(
        Ps(u, ne, X)
      )) : y || (ne = es(u, S), ne != null && j.push(
        Ps(u, ne, X)
      ))), u = u.return;
    }
    j.length !== 0 && o.push({ event: i, listeners: j });
  }
  var NM = /\r\n?/g, AM = /\u0000|\uFFFD/g;
  function lw(o) {
    return (typeof o == "string" ? o : "" + o).replace(NM, `
`).replace(AM, "");
  }
  function uw(o, i) {
    return i = lw(i), lw(o) === i;
  }
  function it(o, i, u, p, y, S) {
    switch (u) {
      case "children":
        typeof p == "string" ? i === "body" || i === "textarea" && p === "" || Fa(o, p) : (typeof p == "number" || typeof p == "bigint") && i !== "body" && Fa(o, "" + p);
        break;
      case "className":
        Qi(o, "class", p);
        break;
      case "tabIndex":
        Qi(o, "tabindex", p);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Qi(o, u, p);
        break;
      case "style":
        uv(o, p, S);
        break;
      case "data":
        if (i !== "object") {
          Qi(o, "data", p);
          break;
        }
      case "src":
      case "href":
        if (p === "" && (i !== "a" || u !== "href")) {
          o.removeAttribute(u);
          break;
        }
        if (p == null || typeof p == "function" || typeof p == "symbol" || typeof p == "boolean") {
          o.removeAttribute(u);
          break;
        }
        p = iu("" + p), o.setAttribute(u, p);
        break;
      case "action":
      case "formAction":
        if (typeof p == "function") {
          o.setAttribute(
            u,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof S == "function" && (u === "formAction" ? (i !== "input" && it(o, i, "name", y.name, y, null), it(
            o,
            i,
            "formEncType",
            y.formEncType,
            y,
            null
          ), it(
            o,
            i,
            "formMethod",
            y.formMethod,
            y,
            null
          ), it(
            o,
            i,
            "formTarget",
            y.formTarget,
            y,
            null
          )) : (it(o, i, "encType", y.encType, y, null), it(o, i, "method", y.method, y, null), it(o, i, "target", y.target, y, null)));
        if (p == null || typeof p == "symbol" || typeof p == "boolean") {
          o.removeAttribute(u);
          break;
        }
        p = iu("" + p), o.setAttribute(u, p);
        break;
      case "onClick":
        p != null && (o.onclick = Lr);
        break;
      case "onScroll":
        p != null && Ue("scroll", o);
        break;
      case "onScrollEnd":
        p != null && Ue("scrollend", o);
        break;
      case "dangerouslySetInnerHTML":
        if (p != null) {
          if (typeof p != "object" || !("__html" in p))
            throw Error(r(61));
          if (u = p.__html, u != null) {
            if (y.children != null) throw Error(r(60));
            o.innerHTML = u;
          }
        }
        break;
      case "multiple":
        o.multiple = p && typeof p != "function" && typeof p != "symbol";
        break;
      case "muted":
        o.muted = p && typeof p != "function" && typeof p != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (p == null || typeof p == "function" || typeof p == "boolean" || typeof p == "symbol") {
          o.removeAttribute("xlink:href");
          break;
        }
        u = iu("" + p), o.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          u
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        p != null && typeof p != "function" && typeof p != "symbol" ? o.setAttribute(u, "" + p) : o.removeAttribute(u);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        p && typeof p != "function" && typeof p != "symbol" ? o.setAttribute(u, "") : o.removeAttribute(u);
        break;
      case "capture":
      case "download":
        p === !0 ? o.setAttribute(u, "") : p !== !1 && p != null && typeof p != "function" && typeof p != "symbol" ? o.setAttribute(u, p) : o.removeAttribute(u);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        p != null && typeof p != "function" && typeof p != "symbol" && !isNaN(p) && 1 <= p ? o.setAttribute(u, p) : o.removeAttribute(u);
        break;
      case "rowSpan":
      case "start":
        p == null || typeof p == "function" || typeof p == "symbol" || isNaN(p) ? o.removeAttribute(u) : o.setAttribute(u, p);
        break;
      case "popover":
        Ue("beforetoggle", o), Ue("toggle", o), Ji(o, "popover", p);
        break;
      case "xlinkActuate":
        Er(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          p
        );
        break;
      case "xlinkArcrole":
        Er(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          p
        );
        break;
      case "xlinkRole":
        Er(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          p
        );
        break;
      case "xlinkShow":
        Er(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          p
        );
        break;
      case "xlinkTitle":
        Er(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          p
        );
        break;
      case "xlinkType":
        Er(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          p
        );
        break;
      case "xmlBase":
        Er(
          o,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          p
        );
        break;
      case "xmlLang":
        Er(
          o,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          p
        );
        break;
      case "xmlSpace":
        Er(
          o,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          p
        );
        break;
      case "is":
        Ji(o, "is", p);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < u.length) || u[0] !== "o" && u[0] !== "O" || u[1] !== "n" && u[1] !== "N") && (u = oO.get(u) || u, Ji(o, u, p));
    }
  }
  function qp(o, i, u, p, y, S) {
    switch (u) {
      case "style":
        uv(o, p, S);
        break;
      case "dangerouslySetInnerHTML":
        if (p != null) {
          if (typeof p != "object" || !("__html" in p))
            throw Error(r(61));
          if (u = p.__html, u != null) {
            if (y.children != null) throw Error(r(60));
            o.innerHTML = u;
          }
        }
        break;
      case "children":
        typeof p == "string" ? Fa(o, p) : (typeof p == "number" || typeof p == "bigint") && Fa(o, "" + p);
        break;
      case "onScroll":
        p != null && Ue("scroll", o);
        break;
      case "onScrollEnd":
        p != null && Ue("scrollend", o);
        break;
      case "onClick":
        p != null && (o.onclick = Lr);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!ef.hasOwnProperty(u))
          e: {
            if (u[0] === "o" && u[1] === "n" && (y = u.endsWith("Capture"), i = u.slice(2, y ? u.length - 7 : void 0), S = o[yn] || null, S = S != null ? S[u] : null, typeof S == "function" && o.removeEventListener(i, S, y), typeof p == "function")) {
              typeof S != "function" && S !== null && (u in o ? o[u] = null : o.hasAttribute(u) && o.removeAttribute(u)), o.addEventListener(i, p, y);
              break e;
            }
            u in o ? o[u] = p : p === !0 ? o.setAttribute(u, "") : Ji(o, u, p);
          }
    }
  }
  function ln(o, i, u) {
    switch (i) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        Ue("error", o), Ue("load", o);
        var p = !1, y = !1, S;
        for (S in u)
          if (u.hasOwnProperty(S)) {
            var j = u[S];
            if (j != null)
              switch (S) {
                case "src":
                  p = !0;
                  break;
                case "srcSet":
                  y = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(r(137, i));
                default:
                  it(o, i, S, j, u, null);
              }
          }
        y && it(o, i, "srcSet", u.srcSet, u, null), p && it(o, i, "src", u.src, u, null);
        return;
      case "input":
        Ue("invalid", o);
        var T = S = j = y = null, X = null, ne = null;
        for (p in u)
          if (u.hasOwnProperty(p)) {
            var ue = u[p];
            if (ue != null)
              switch (p) {
                case "name":
                  y = ue;
                  break;
                case "type":
                  j = ue;
                  break;
                case "checked":
                  X = ue;
                  break;
                case "defaultChecked":
                  ne = ue;
                  break;
                case "value":
                  S = ue;
                  break;
                case "defaultValue":
                  T = ue;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (ue != null)
                    throw Error(r(137, i));
                  break;
                default:
                  it(o, i, p, ue, u, null);
              }
          }
        of(
          o,
          S,
          T,
          X,
          ne,
          j,
          y,
          !1
        );
        return;
      case "select":
        Ue("invalid", o), p = j = S = null;
        for (y in u)
          if (u.hasOwnProperty(y) && (T = u[y], T != null))
            switch (y) {
              case "value":
                S = T;
                break;
              case "defaultValue":
                j = T;
                break;
              case "multiple":
                p = T;
              default:
                it(o, i, y, T, u, null);
            }
        i = S, u = j, o.multiple = !!p, i != null ? Wo(o, !!p, i, !1) : u != null && Wo(o, !!p, u, !0);
        return;
      case "textarea":
        Ue("invalid", o), S = y = p = null;
        for (j in u)
          if (u.hasOwnProperty(j) && (T = u[j], T != null))
            switch (j) {
              case "value":
                p = T;
                break;
              case "defaultValue":
                y = T;
                break;
              case "children":
                S = T;
                break;
              case "dangerouslySetInnerHTML":
                if (T != null) throw Error(r(91));
                break;
              default:
                it(o, i, j, T, u, null);
            }
        sv(o, p, y, S);
        return;
      case "option":
        for (X in u)
          u.hasOwnProperty(X) && (p = u[X], p != null) && (X === "selected" ? o.selected = p && typeof p != "function" && typeof p != "symbol" : it(o, i, X, p, u, null));
        return;
      case "dialog":
        Ue("beforetoggle", o), Ue("toggle", o), Ue("cancel", o), Ue("close", o);
        break;
      case "iframe":
      case "object":
        Ue("load", o);
        break;
      case "video":
      case "audio":
        for (p = 0; p < js.length; p++)
          Ue(js[p], o);
        break;
      case "image":
        Ue("error", o), Ue("load", o);
        break;
      case "details":
        Ue("toggle", o);
        break;
      case "embed":
      case "source":
      case "link":
        Ue("error", o), Ue("load", o);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (ne in u)
          if (u.hasOwnProperty(ne) && (p = u[ne], p != null))
            switch (ne) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(r(137, i));
              default:
                it(o, i, ne, p, u, null);
            }
        return;
      default:
        if (af(i)) {
          for (ue in u)
            u.hasOwnProperty(ue) && (p = u[ue], p !== void 0 && qp(
              o,
              i,
              ue,
              p,
              u,
              void 0
            ));
          return;
        }
    }
    for (T in u)
      u.hasOwnProperty(T) && (p = u[T], p != null && it(o, i, T, p, u, null));
  }
  function RM(o, i, u, p) {
    switch (i) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var y = null, S = null, j = null, T = null, X = null, ne = null, ue = null;
        for (se in u) {
          var pe = u[se];
          if (u.hasOwnProperty(se) && pe != null)
            switch (se) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                X = pe;
              default:
                p.hasOwnProperty(se) || it(o, i, se, null, p, pe);
            }
        }
        for (var ae in p) {
          var se = p[ae];
          if (pe = u[ae], p.hasOwnProperty(ae) && (se != null || pe != null))
            switch (ae) {
              case "type":
                S = se;
                break;
              case "name":
                y = se;
                break;
              case "checked":
                ne = se;
                break;
              case "defaultChecked":
                ue = se;
                break;
              case "value":
                j = se;
                break;
              case "defaultValue":
                T = se;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (se != null)
                  throw Error(r(137, i));
                break;
              default:
                se !== pe && it(
                  o,
                  i,
                  ae,
                  se,
                  p,
                  pe
                );
            }
        }
        Zi(
          o,
          j,
          T,
          X,
          ne,
          ue,
          S,
          y
        );
        return;
      case "select":
        se = j = T = ae = null;
        for (S in u)
          if (X = u[S], u.hasOwnProperty(S) && X != null)
            switch (S) {
              case "value":
                break;
              case "multiple":
                se = X;
              default:
                p.hasOwnProperty(S) || it(
                  o,
                  i,
                  S,
                  null,
                  p,
                  X
                );
            }
        for (y in p)
          if (S = p[y], X = u[y], p.hasOwnProperty(y) && (S != null || X != null))
            switch (y) {
              case "value":
                ae = S;
                break;
              case "defaultValue":
                T = S;
                break;
              case "multiple":
                j = S;
              default:
                S !== X && it(
                  o,
                  i,
                  y,
                  S,
                  p,
                  X
                );
            }
        i = T, u = j, p = se, ae != null ? Wo(o, !!u, ae, !1) : !!p != !!u && (i != null ? Wo(o, !!u, i, !0) : Wo(o, !!u, u ? [] : "", !1));
        return;
      case "textarea":
        se = ae = null;
        for (T in u)
          if (y = u[T], u.hasOwnProperty(T) && y != null && !p.hasOwnProperty(T))
            switch (T) {
              case "value":
                break;
              case "children":
                break;
              default:
                it(o, i, T, null, p, y);
            }
        for (j in p)
          if (y = p[j], S = u[j], p.hasOwnProperty(j) && (y != null || S != null))
            switch (j) {
              case "value":
                ae = y;
                break;
              case "defaultValue":
                se = y;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (y != null) throw Error(r(91));
                break;
              default:
                y !== S && it(o, i, j, y, p, S);
            }
        iv(o, ae, se);
        return;
      case "option":
        for (var we in u)
          ae = u[we], u.hasOwnProperty(we) && ae != null && !p.hasOwnProperty(we) && (we === "selected" ? o.selected = !1 : it(
            o,
            i,
            we,
            null,
            p,
            ae
          ));
        for (X in p)
          ae = p[X], se = u[X], p.hasOwnProperty(X) && ae !== se && (ae != null || se != null) && (X === "selected" ? o.selected = ae && typeof ae != "function" && typeof ae != "symbol" : it(
            o,
            i,
            X,
            ae,
            p,
            se
          ));
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var Ne in u)
          ae = u[Ne], u.hasOwnProperty(Ne) && ae != null && !p.hasOwnProperty(Ne) && it(o, i, Ne, null, p, ae);
        for (ne in p)
          if (ae = p[ne], se = u[ne], p.hasOwnProperty(ne) && ae !== se && (ae != null || se != null))
            switch (ne) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (ae != null)
                  throw Error(r(137, i));
                break;
              default:
                it(
                  o,
                  i,
                  ne,
                  ae,
                  p,
                  se
                );
            }
        return;
      default:
        if (af(i)) {
          for (var st in u)
            ae = u[st], u.hasOwnProperty(st) && ae !== void 0 && !p.hasOwnProperty(st) && qp(
              o,
              i,
              st,
              void 0,
              p,
              ae
            );
          for (ue in p)
            ae = p[ue], se = u[ue], !p.hasOwnProperty(ue) || ae === se || ae === void 0 && se === void 0 || qp(
              o,
              i,
              ue,
              ae,
              p,
              se
            );
          return;
        }
    }
    for (var ee in u)
      ae = u[ee], u.hasOwnProperty(ee) && ae != null && !p.hasOwnProperty(ee) && it(o, i, ee, null, p, ae);
    for (pe in p)
      ae = p[pe], se = u[pe], !p.hasOwnProperty(pe) || ae === se || ae == null && se == null || it(o, i, pe, ae, p, se);
  }
  function cw(o) {
    switch (o) {
      case "css":
      case "script":
      case "font":
      case "img":
      case "image":
      case "input":
      case "link":
        return !0;
      default:
        return !1;
    }
  }
  function jM() {
    if (typeof performance.getEntriesByType == "function") {
      for (var o = 0, i = 0, u = performance.getEntriesByType("resource"), p = 0; p < u.length; p++) {
        var y = u[p], S = y.transferSize, j = y.initiatorType, T = y.duration;
        if (S && T && cw(j)) {
          for (j = 0, T = y.responseEnd, p += 1; p < u.length; p++) {
            var X = u[p], ne = X.startTime;
            if (ne > T) break;
            var ue = X.transferSize, pe = X.initiatorType;
            ue && cw(pe) && (X = X.responseEnd, j += ue * (X < T ? 1 : (T - ne) / (X - ne)));
          }
          if (--p, i += 8 * (S + j) / (y.duration / 1e3), o++, 10 < o) break;
        }
      }
      if (0 < o) return i / o / 1e6;
    }
    return navigator.connection && (o = navigator.connection.downlink, typeof o == "number") ? o : 5;
  }
  var Gp = null, Kp = null;
  function tc(o) {
    return o.nodeType === 9 ? o : o.ownerDocument;
  }
  function dw(o) {
    switch (o) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function fw(o, i) {
    if (o === 0)
      switch (i) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return o === 1 && i === "foreignObject" ? 0 : o;
  }
  function Yp(o, i) {
    return o === "textarea" || o === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.children == "bigint" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null;
  }
  var Xp = null;
  function PM() {
    var o = window.event;
    return o && o.type === "popstate" ? o === Xp ? !1 : (Xp = o, !0) : (Xp = null, !1);
  }
  var pw = typeof setTimeout == "function" ? setTimeout : void 0, DM = typeof clearTimeout == "function" ? clearTimeout : void 0, mw = typeof Promise == "function" ? Promise : void 0, IM = typeof queueMicrotask == "function" ? queueMicrotask : typeof mw < "u" ? function(o) {
    return mw.resolve(null).then(o).catch($M);
  } : pw;
  function $M(o) {
    setTimeout(function() {
      throw o;
    });
  }
  function Oo(o) {
    return o === "head";
  }
  function hw(o, i) {
    var u = i, p = 0;
    do {
      var y = u.nextSibling;
      if (o.removeChild(u), y && y.nodeType === 8)
        if (u = y.data, u === "/$" || u === "/&") {
          if (p === 0) {
            o.removeChild(y), vi(i);
            return;
          }
          p--;
        } else if (u === "$" || u === "$?" || u === "$~" || u === "$!" || u === "&")
          p++;
        else if (u === "html")
          Ds(o.ownerDocument.documentElement);
        else if (u === "head") {
          u = o.ownerDocument.head, Ds(u);
          for (var S = u.firstChild; S; ) {
            var j = S.nextSibling, T = S.nodeName;
            S[La] || T === "SCRIPT" || T === "STYLE" || T === "LINK" && S.rel.toLowerCase() === "stylesheet" || u.removeChild(S), S = j;
          }
        } else
          u === "body" && Ds(o.ownerDocument.body);
      u = y;
    } while (u);
    vi(i);
  }
  function gw(o, i) {
    var u = o;
    o = 0;
    do {
      var p = u.nextSibling;
      if (u.nodeType === 1 ? i ? (u._stashedDisplay = u.style.display, u.style.display = "none") : (u.style.display = u._stashedDisplay || "", u.getAttribute("style") === "" && u.removeAttribute("style")) : u.nodeType === 3 && (i ? (u._stashedText = u.nodeValue, u.nodeValue = "") : u.nodeValue = u._stashedText || ""), p && p.nodeType === 8)
        if (u = p.data, u === "/$") {
          if (o === 0) break;
          o--;
        } else
          u !== "$" && u !== "$?" && u !== "$~" && u !== "$!" || o++;
      u = p;
    } while (u);
  }
  function Jp(o) {
    var i = o.firstChild;
    for (i && i.nodeType === 10 && (i = i.nextSibling); i; ) {
      var u = i;
      switch (i = i.nextSibling, u.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          Jp(u), ou(u);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (u.rel.toLowerCase() === "stylesheet") continue;
      }
      o.removeChild(u);
    }
  }
  function zM(o, i, u, p) {
    for (; o.nodeType === 1; ) {
      var y = u;
      if (o.nodeName.toLowerCase() !== i.toLowerCase()) {
        if (!p && (o.nodeName !== "INPUT" || o.type !== "hidden"))
          break;
      } else if (p) {
        if (!o[La])
          switch (i) {
            case "meta":
              if (!o.hasAttribute("itemprop")) break;
              return o;
            case "link":
              if (S = o.getAttribute("rel"), S === "stylesheet" && o.hasAttribute("data-precedence"))
                break;
              if (S !== y.rel || o.getAttribute("href") !== (y.href == null || y.href === "" ? null : y.href) || o.getAttribute("crossorigin") !== (y.crossOrigin == null ? null : y.crossOrigin) || o.getAttribute("title") !== (y.title == null ? null : y.title))
                break;
              return o;
            case "style":
              if (o.hasAttribute("data-precedence")) break;
              return o;
            case "script":
              if (S = o.getAttribute("src"), (S !== (y.src == null ? null : y.src) || o.getAttribute("type") !== (y.type == null ? null : y.type) || o.getAttribute("crossorigin") !== (y.crossOrigin == null ? null : y.crossOrigin)) && S && o.hasAttribute("async") && !o.hasAttribute("itemprop"))
                break;
              return o;
            default:
              return o;
          }
      } else if (i === "input" && o.type === "hidden") {
        var S = y.name == null ? null : "" + y.name;
        if (y.type === "hidden" && o.getAttribute("name") === S)
          return o;
      } else return o;
      if (o = ir(o.nextSibling), o === null) break;
    }
    return null;
  }
  function TM(o, i, u) {
    if (i === "") return null;
    for (; o.nodeType !== 3; )
      if ((o.nodeType !== 1 || o.nodeName !== "INPUT" || o.type !== "hidden") && !u || (o = ir(o.nextSibling), o === null)) return null;
    return o;
  }
  function vw(o, i) {
    for (; o.nodeType !== 8; )
      if ((o.nodeType !== 1 || o.nodeName !== "INPUT" || o.type !== "hidden") && !i || (o = ir(o.nextSibling), o === null)) return null;
    return o;
  }
  function Qp(o) {
    return o.data === "$?" || o.data === "$~";
  }
  function Zp(o) {
    return o.data === "$!" || o.data === "$?" && o.ownerDocument.readyState !== "loading";
  }
  function LM(o, i) {
    var u = o.ownerDocument;
    if (o.data === "$~") o._reactRetry = i;
    else if (o.data !== "$?" || u.readyState !== "loading")
      i();
    else {
      var p = function() {
        i(), u.removeEventListener("DOMContentLoaded", p);
      };
      u.addEventListener("DOMContentLoaded", p), o._reactRetry = p;
    }
  }
  function ir(o) {
    for (; o != null; o = o.nextSibling) {
      var i = o.nodeType;
      if (i === 1 || i === 3) break;
      if (i === 8) {
        if (i = o.data, i === "$" || i === "$!" || i === "$?" || i === "$~" || i === "&" || i === "F!" || i === "F")
          break;
        if (i === "/$" || i === "/&") return null;
      }
    }
    return o;
  }
  var em = null;
  function yw(o) {
    o = o.nextSibling;
    for (var i = 0; o; ) {
      if (o.nodeType === 8) {
        var u = o.data;
        if (u === "/$" || u === "/&") {
          if (i === 0)
            return ir(o.nextSibling);
          i--;
        } else
          u !== "$" && u !== "$!" && u !== "$?" && u !== "$~" && u !== "&" || i++;
      }
      o = o.nextSibling;
    }
    return null;
  }
  function bw(o) {
    o = o.previousSibling;
    for (var i = 0; o; ) {
      if (o.nodeType === 8) {
        var u = o.data;
        if (u === "$" || u === "$!" || u === "$?" || u === "$~" || u === "&") {
          if (i === 0) return o;
          i--;
        } else u !== "/$" && u !== "/&" || i++;
      }
      o = o.previousSibling;
    }
    return null;
  }
  function ww(o, i, u) {
    switch (i = tc(u), o) {
      case "html":
        if (o = i.documentElement, !o) throw Error(r(452));
        return o;
      case "head":
        if (o = i.head, !o) throw Error(r(453));
        return o;
      case "body":
        if (o = i.body, !o) throw Error(r(454));
        return o;
      default:
        throw Error(r(451));
    }
  }
  function Ds(o) {
    for (var i = o.attributes; i.length; )
      o.removeAttributeNode(i[0]);
    ou(o);
  }
  var sr = /* @__PURE__ */ new Map(), xw = /* @__PURE__ */ new Set();
  function nc(o) {
    return typeof o.getRootNode == "function" ? o.getRootNode() : o.nodeType === 9 ? o : o.ownerDocument;
  }
  var to = K.d;
  K.d = {
    f: FM,
    r: BM,
    D: UM,
    C: VM,
    L: HM,
    m: WM,
    X: GM,
    S: qM,
    M: KM
  };
  function FM() {
    var o = to.f(), i = Gu();
    return o || i;
  }
  function BM(o) {
    var i = ra(o);
    i !== null && i.tag === 5 && i.type === "form" ? Ty(i) : to.r(o);
  }
  var mi = typeof document > "u" ? null : document;
  function Sw(o, i, u) {
    var p = mi;
    if (p && typeof i == "string" && i) {
      var y = Jn(i);
      y = 'link[rel="' + o + '"][href="' + y + '"]', typeof u == "string" && (y += '[crossorigin="' + u + '"]'), xw.has(y) || (xw.add(y), o = { rel: o, crossOrigin: u, href: i }, p.querySelector(y) === null && (i = p.createElement("link"), ln(i, "link", o), Wt(i), p.head.appendChild(i)));
    }
  }
  function UM(o) {
    to.D(o), Sw("dns-prefetch", o, null);
  }
  function VM(o, i) {
    to.C(o, i), Sw("preconnect", o, i);
  }
  function HM(o, i, u) {
    to.L(o, i, u);
    var p = mi;
    if (p && o && i) {
      var y = 'link[rel="preload"][as="' + Jn(i) + '"]';
      i === "image" && u && u.imageSrcSet ? (y += '[imagesrcset="' + Jn(
        u.imageSrcSet
      ) + '"]', typeof u.imageSizes == "string" && (y += '[imagesizes="' + Jn(
        u.imageSizes
      ) + '"]')) : y += '[href="' + Jn(o) + '"]';
      var S = y;
      switch (i) {
        case "style":
          S = hi(o);
          break;
        case "script":
          S = gi(o);
      }
      sr.has(S) || (o = h(
        {
          rel: "preload",
          href: i === "image" && u && u.imageSrcSet ? void 0 : o,
          as: i
        },
        u
      ), sr.set(S, o), p.querySelector(y) !== null || i === "style" && p.querySelector(Is(S)) || i === "script" && p.querySelector($s(S)) || (i = p.createElement("link"), ln(i, "link", o), Wt(i), p.head.appendChild(i)));
    }
  }
  function WM(o, i) {
    to.m(o, i);
    var u = mi;
    if (u && o) {
      var p = i && typeof i.as == "string" ? i.as : "script", y = 'link[rel="modulepreload"][as="' + Jn(p) + '"][href="' + Jn(o) + '"]', S = y;
      switch (p) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          S = gi(o);
      }
      if (!sr.has(S) && (o = h({ rel: "modulepreload", href: o }, i), sr.set(S, o), u.querySelector(y) === null)) {
        switch (p) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (u.querySelector($s(S)))
              return;
        }
        p = u.createElement("link"), ln(p, "link", o), Wt(p), u.head.appendChild(p);
      }
    }
  }
  function qM(o, i, u) {
    to.S(o, i, u);
    var p = mi;
    if (p && o) {
      var y = oa(p).hoistableStyles, S = hi(o);
      i = i || "default";
      var j = y.get(S);
      if (!j) {
        var T = { loading: 0, preload: null };
        if (j = p.querySelector(
          Is(S)
        ))
          T.loading = 5;
        else {
          o = h(
            { rel: "stylesheet", href: o, "data-precedence": i },
            u
          ), (u = sr.get(S)) && tm(o, u);
          var X = j = p.createElement("link");
          Wt(X), ln(X, "link", o), X._p = new Promise(function(ne, ue) {
            X.onload = ne, X.onerror = ue;
          }), X.addEventListener("load", function() {
            T.loading |= 1;
          }), X.addEventListener("error", function() {
            T.loading |= 2;
          }), T.loading |= 4, rc(j, i, p);
        }
        j = {
          type: "stylesheet",
          instance: j,
          count: 1,
          state: T
        }, y.set(S, j);
      }
    }
  }
  function GM(o, i) {
    to.X(o, i);
    var u = mi;
    if (u && o) {
      var p = oa(u).hoistableScripts, y = gi(o), S = p.get(y);
      S || (S = u.querySelector($s(y)), S || (o = h({ src: o, async: !0 }, i), (i = sr.get(y)) && nm(o, i), S = u.createElement("script"), Wt(S), ln(S, "link", o), u.head.appendChild(S)), S = {
        type: "script",
        instance: S,
        count: 1,
        state: null
      }, p.set(y, S));
    }
  }
  function KM(o, i) {
    to.M(o, i);
    var u = mi;
    if (u && o) {
      var p = oa(u).hoistableScripts, y = gi(o), S = p.get(y);
      S || (S = u.querySelector($s(y)), S || (o = h({ src: o, async: !0, type: "module" }, i), (i = sr.get(y)) && nm(o, i), S = u.createElement("script"), Wt(S), ln(S, "link", o), u.head.appendChild(S)), S = {
        type: "script",
        instance: S,
        count: 1,
        state: null
      }, p.set(y, S));
    }
  }
  function kw(o, i, u, p) {
    var y = (y = oe.current) ? nc(y) : null;
    if (!y) throw Error(r(446));
    switch (o) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof u.precedence == "string" && typeof u.href == "string" ? (i = hi(u.href), u = oa(
          y
        ).hoistableStyles, p = u.get(i), p || (p = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, u.set(i, p)), p) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (u.rel === "stylesheet" && typeof u.href == "string" && typeof u.precedence == "string") {
          o = hi(u.href);
          var S = oa(
            y
          ).hoistableStyles, j = S.get(o);
          if (j || (y = y.ownerDocument || y, j = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, S.set(o, j), (S = y.querySelector(
            Is(o)
          )) && !S._p && (j.instance = S, j.state.loading = 5), sr.has(o) || (u = {
            rel: "preload",
            as: "style",
            href: u.href,
            crossOrigin: u.crossOrigin,
            integrity: u.integrity,
            media: u.media,
            hrefLang: u.hrefLang,
            referrerPolicy: u.referrerPolicy
          }, sr.set(o, u), S || YM(
            y,
            o,
            u,
            j.state
          ))), i && p === null)
            throw Error(r(528, ""));
          return j;
        }
        if (i && p !== null)
          throw Error(r(529, ""));
        return null;
      case "script":
        return i = u.async, u = u.src, typeof u == "string" && i && typeof i != "function" && typeof i != "symbol" ? (i = gi(u), u = oa(
          y
        ).hoistableScripts, p = u.get(i), p || (p = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, u.set(i, p)), p) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(r(444, o));
    }
  }
  function hi(o) {
    return 'href="' + Jn(o) + '"';
  }
  function Is(o) {
    return 'link[rel="stylesheet"][' + o + "]";
  }
  function _w(o) {
    return h({}, o, {
      "data-precedence": o.precedence,
      precedence: null
    });
  }
  function YM(o, i, u, p) {
    o.querySelector('link[rel="preload"][as="style"][' + i + "]") ? p.loading = 1 : (i = o.createElement("link"), p.preload = i, i.addEventListener("load", function() {
      return p.loading |= 1;
    }), i.addEventListener("error", function() {
      return p.loading |= 2;
    }), ln(i, "link", u), Wt(i), o.head.appendChild(i));
  }
  function gi(o) {
    return '[src="' + Jn(o) + '"]';
  }
  function $s(o) {
    return "script[async]" + o;
  }
  function Ew(o, i, u) {
    if (i.count++, i.instance === null)
      switch (i.type) {
        case "style":
          var p = o.querySelector(
            'style[data-href~="' + Jn(u.href) + '"]'
          );
          if (p)
            return i.instance = p, Wt(p), p;
          var y = h({}, u, {
            "data-href": u.href,
            "data-precedence": u.precedence,
            href: null,
            precedence: null
          });
          return p = (o.ownerDocument || o).createElement(
            "style"
          ), Wt(p), ln(p, "style", y), rc(p, u.precedence, o), i.instance = p;
        case "stylesheet":
          y = hi(u.href);
          var S = o.querySelector(
            Is(y)
          );
          if (S)
            return i.state.loading |= 4, i.instance = S, Wt(S), S;
          p = _w(u), (y = sr.get(y)) && tm(p, y), S = (o.ownerDocument || o).createElement("link"), Wt(S);
          var j = S;
          return j._p = new Promise(function(T, X) {
            j.onload = T, j.onerror = X;
          }), ln(S, "link", p), i.state.loading |= 4, rc(S, u.precedence, o), i.instance = S;
        case "script":
          return S = gi(u.src), (y = o.querySelector(
            $s(S)
          )) ? (i.instance = y, Wt(y), y) : (p = u, (y = sr.get(S)) && (p = h({}, u), nm(p, y)), o = o.ownerDocument || o, y = o.createElement("script"), Wt(y), ln(y, "link", p), o.head.appendChild(y), i.instance = y);
        case "void":
          return null;
        default:
          throw Error(r(443, i.type));
      }
    else
      i.type === "stylesheet" && (i.state.loading & 4) === 0 && (p = i.instance, i.state.loading |= 4, rc(p, u.precedence, o));
    return i.instance;
  }
  function rc(o, i, u) {
    for (var p = u.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), y = p.length ? p[p.length - 1] : null, S = y, j = 0; j < p.length; j++) {
      var T = p[j];
      if (T.dataset.precedence === i) S = T;
      else if (S !== y) break;
    }
    S ? S.parentNode.insertBefore(o, S.nextSibling) : (i = u.nodeType === 9 ? u.head : u, i.insertBefore(o, i.firstChild));
  }
  function tm(o, i) {
    o.crossOrigin == null && (o.crossOrigin = i.crossOrigin), o.referrerPolicy == null && (o.referrerPolicy = i.referrerPolicy), o.title == null && (o.title = i.title);
  }
  function nm(o, i) {
    o.crossOrigin == null && (o.crossOrigin = i.crossOrigin), o.referrerPolicy == null && (o.referrerPolicy = i.referrerPolicy), o.integrity == null && (o.integrity = i.integrity);
  }
  var oc = null;
  function Cw(o, i, u) {
    if (oc === null) {
      var p = /* @__PURE__ */ new Map(), y = oc = /* @__PURE__ */ new Map();
      y.set(u, p);
    } else
      y = oc, p = y.get(u), p || (p = /* @__PURE__ */ new Map(), y.set(u, p));
    if (p.has(o)) return p;
    for (p.set(o, null), u = u.getElementsByTagName(o), y = 0; y < u.length; y++) {
      var S = u[y];
      if (!(S[La] || S[en] || o === "link" && S.getAttribute("rel") === "stylesheet") && S.namespaceURI !== "http://www.w3.org/2000/svg") {
        var j = S.getAttribute(i) || "";
        j = o + j;
        var T = p.get(j);
        T ? T.push(S) : p.set(j, [S]);
      }
    }
    return p;
  }
  function Ow(o, i, u) {
    o = o.ownerDocument || o, o.head.insertBefore(
      u,
      i === "title" ? o.querySelector("head > title") : null
    );
  }
  function XM(o, i, u) {
    if (u === 1 || i.itemProp != null) return !1;
    switch (o) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof i.precedence != "string" || typeof i.href != "string" || i.href === "")
          break;
        return !0;
      case "link":
        if (typeof i.rel != "string" || typeof i.href != "string" || i.href === "" || i.onLoad || i.onError)
          break;
        return i.rel === "stylesheet" ? (o = i.disabled, typeof i.precedence == "string" && o == null) : !0;
      case "script":
        if (i.async && typeof i.async != "function" && typeof i.async != "symbol" && !i.onLoad && !i.onError && i.src && typeof i.src == "string")
          return !0;
    }
    return !1;
  }
  function Mw(o) {
    return !(o.type === "stylesheet" && (o.state.loading & 3) === 0);
  }
  function JM(o, i, u, p) {
    if (u.type === "stylesheet" && (typeof p.media != "string" || matchMedia(p.media).matches !== !1) && (u.state.loading & 4) === 0) {
      if (u.instance === null) {
        var y = hi(p.href), S = i.querySelector(
          Is(y)
        );
        if (S) {
          i = S._p, i !== null && typeof i == "object" && typeof i.then == "function" && (o.count++, o = ac.bind(o), i.then(o, o)), u.state.loading |= 4, u.instance = S, Wt(S);
          return;
        }
        S = i.ownerDocument || i, p = _w(p), (y = sr.get(y)) && tm(p, y), S = S.createElement("link"), Wt(S);
        var j = S;
        j._p = new Promise(function(T, X) {
          j.onload = T, j.onerror = X;
        }), ln(S, "link", p), u.instance = S;
      }
      o.stylesheets === null && (o.stylesheets = /* @__PURE__ */ new Map()), o.stylesheets.set(u, i), (i = u.state.preload) && (u.state.loading & 3) === 0 && (o.count++, u = ac.bind(o), i.addEventListener("load", u), i.addEventListener("error", u));
    }
  }
  var rm = 0;
  function QM(o, i) {
    return o.stylesheets && o.count === 0 && sc(o, o.stylesheets), 0 < o.count || 0 < o.imgCount ? function(u) {
      var p = setTimeout(function() {
        if (o.stylesheets && sc(o, o.stylesheets), o.unsuspend) {
          var S = o.unsuspend;
          o.unsuspend = null, S();
        }
      }, 6e4 + i);
      0 < o.imgBytes && rm === 0 && (rm = 62500 * jM());
      var y = setTimeout(
        function() {
          if (o.waitingForImages = !1, o.count === 0 && (o.stylesheets && sc(o, o.stylesheets), o.unsuspend)) {
            var S = o.unsuspend;
            o.unsuspend = null, S();
          }
        },
        (o.imgBytes > rm ? 50 : 800) + i
      );
      return o.unsuspend = u, function() {
        o.unsuspend = null, clearTimeout(p), clearTimeout(y);
      };
    } : null;
  }
  function ac() {
    if (this.count--, this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
      if (this.stylesheets) sc(this, this.stylesheets);
      else if (this.unsuspend) {
        var o = this.unsuspend;
        this.unsuspend = null, o();
      }
    }
  }
  var ic = null;
  function sc(o, i) {
    o.stylesheets = null, o.unsuspend !== null && (o.count++, ic = /* @__PURE__ */ new Map(), i.forEach(ZM, o), ic = null, ac.call(o));
  }
  function ZM(o, i) {
    if (!(i.state.loading & 4)) {
      var u = ic.get(o);
      if (u) var p = u.get(null);
      else {
        u = /* @__PURE__ */ new Map(), ic.set(o, u);
        for (var y = o.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), S = 0; S < y.length; S++) {
          var j = y[S];
          (j.nodeName === "LINK" || j.getAttribute("media") !== "not all") && (u.set(j.dataset.precedence, j), p = j);
        }
        p && u.set(null, p);
      }
      y = i.instance, j = y.getAttribute("data-precedence"), S = u.get(j) || p, S === p && u.set(null, y), u.set(j, y), this.count++, p = ac.bind(this), y.addEventListener("load", p), y.addEventListener("error", p), S ? S.parentNode.insertBefore(y, S.nextSibling) : (o = o.nodeType === 9 ? o.head : o, o.insertBefore(y, o.firstChild)), i.state.loading |= 4;
    }
  }
  var zs = {
    $$typeof: _,
    Provider: null,
    Consumer: null,
    _currentValue: q,
    _currentValue2: q,
    _threadCount: 0
  };
  function eN(o, i, u, p, y, S, j, T, X) {
    this.tag = 1, this.containerInfo = o, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = tu(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = tu(0), this.hiddenUpdates = tu(null), this.identifierPrefix = p, this.onUncaughtError = y, this.onCaughtError = S, this.onRecoverableError = j, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = X, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function Nw(o, i, u, p, y, S, j, T, X, ne, ue, pe) {
    return o = new eN(
      o,
      i,
      u,
      j,
      X,
      ne,
      ue,
      pe,
      T
    ), i = 1, S === !0 && (i |= 24), S = Un(3, null, null, i), o.current = S, S.stateNode = o, i = $f(), i.refCount++, o.pooledCache = i, i.refCount++, S.memoizedState = {
      element: p,
      isDehydrated: u,
      cache: i
    }, Ff(S), o;
  }
  function Aw(o) {
    return o ? (o = Ga, o) : Ga;
  }
  function Rw(o, i, u, p, y, S) {
    y = Aw(y), p.context === null ? p.context = y : p.pendingContext = y, p = go(i), p.payload = { element: u }, S = S === void 0 ? null : S, S !== null && (p.callback = S), u = vo(o, p, i), u !== null && (Pn(u, o, i), hs(u, o, i));
  }
  function jw(o, i) {
    if (o = o.memoizedState, o !== null && o.dehydrated !== null) {
      var u = o.retryLane;
      o.retryLane = u !== 0 && u < i ? u : i;
    }
  }
  function om(o, i) {
    jw(o, i), (o = o.alternate) && jw(o, i);
  }
  function Pw(o) {
    if (o.tag === 13 || o.tag === 31) {
      var i = ua(o, 67108864);
      i !== null && Pn(i, o, 67108864), om(o, 67108864);
    }
  }
  function Dw(o) {
    if (o.tag === 13 || o.tag === 31) {
      var i = Gn();
      i = nu(i);
      var u = ua(o, i);
      u !== null && Pn(u, o, i), om(o, i);
    }
  }
  var lc = !0;
  function tN(o, i, u, p) {
    var y = $.T;
    $.T = null;
    var S = K.p;
    try {
      K.p = 2, am(o, i, u, p);
    } finally {
      K.p = S, $.T = y;
    }
  }
  function nN(o, i, u, p) {
    var y = $.T;
    $.T = null;
    var S = K.p;
    try {
      K.p = 8, am(o, i, u, p);
    } finally {
      K.p = S, $.T = y;
    }
  }
  function am(o, i, u, p) {
    if (lc) {
      var y = im(p);
      if (y === null)
        Wp(
          o,
          i,
          p,
          uc,
          u
        ), $w(o, p);
      else if (oN(
        y,
        o,
        i,
        u,
        p
      ))
        p.stopPropagation();
      else if ($w(o, p), i & 4 && -1 < rN.indexOf(o)) {
        for (; y !== null; ) {
          var S = ra(y);
          if (S !== null)
            switch (S.tag) {
              case 3:
                if (S = S.stateNode, S.current.memoizedState.isDehydrated) {
                  var j = _r(S.pendingLanes);
                  if (j !== 0) {
                    var T = S;
                    for (T.pendingLanes |= 2, T.entangledLanes |= 2; j; ) {
                      var X = 1 << 31 - Ae(j);
                      T.entanglements[1] |= X, j &= ~X;
                    }
                    Nr(S), (Ze & 6) === 0 && (Wu = Ce() + 500, Rs(0));
                  }
                }
                break;
              case 31:
              case 13:
                T = ua(S, 2), T !== null && Pn(T, S, 2), Gu(), om(S, 2);
            }
          if (S = im(p), S === null && Wp(
            o,
            i,
            p,
            uc,
            u
          ), S === y) break;
          y = S;
        }
        y !== null && p.stopPropagation();
      } else
        Wp(
          o,
          i,
          p,
          null,
          u
        );
    }
  }
  function im(o) {
    return o = lf(o), sm(o);
  }
  var uc = null;
  function sm(o) {
    if (uc = null, o = na(o), o !== null) {
      var i = s(o);
      if (i === null) o = null;
      else {
        var u = i.tag;
        if (u === 13) {
          if (o = l(i), o !== null) return o;
          o = null;
        } else if (u === 31) {
          if (o = c(i), o !== null) return o;
          o = null;
        } else if (u === 3) {
          if (i.stateNode.current.memoizedState.isDehydrated)
            return i.tag === 3 ? i.stateNode.containerInfo : null;
          o = null;
        } else i !== o && (o = null);
      }
    }
    return uc = o, null;
  }
  function Iw(o) {
    switch (o) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (Me()) {
          case he:
            return 2;
          case ye:
            return 8;
          case Ee:
          case Te:
            return 32;
          case Fe:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var lm = !1, Mo = null, No = null, Ao = null, Ts = /* @__PURE__ */ new Map(), Ls = /* @__PURE__ */ new Map(), Ro = [], rN = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function $w(o, i) {
    switch (o) {
      case "focusin":
      case "focusout":
        Mo = null;
        break;
      case "dragenter":
      case "dragleave":
        No = null;
        break;
      case "mouseover":
      case "mouseout":
        Ao = null;
        break;
      case "pointerover":
      case "pointerout":
        Ts.delete(i.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Ls.delete(i.pointerId);
    }
  }
  function Fs(o, i, u, p, y, S) {
    return o === null || o.nativeEvent !== S ? (o = {
      blockedOn: i,
      domEventName: u,
      eventSystemFlags: p,
      nativeEvent: S,
      targetContainers: [y]
    }, i !== null && (i = ra(i), i !== null && Pw(i)), o) : (o.eventSystemFlags |= p, i = o.targetContainers, y !== null && i.indexOf(y) === -1 && i.push(y), o);
  }
  function oN(o, i, u, p, y) {
    switch (i) {
      case "focusin":
        return Mo = Fs(
          Mo,
          o,
          i,
          u,
          p,
          y
        ), !0;
      case "dragenter":
        return No = Fs(
          No,
          o,
          i,
          u,
          p,
          y
        ), !0;
      case "mouseover":
        return Ao = Fs(
          Ao,
          o,
          i,
          u,
          p,
          y
        ), !0;
      case "pointerover":
        var S = y.pointerId;
        return Ts.set(
          S,
          Fs(
            Ts.get(S) || null,
            o,
            i,
            u,
            p,
            y
          )
        ), !0;
      case "gotpointercapture":
        return S = y.pointerId, Ls.set(
          S,
          Fs(
            Ls.get(S) || null,
            o,
            i,
            u,
            p,
            y
          )
        ), !0;
    }
    return !1;
  }
  function zw(o) {
    var i = na(o.target);
    if (i !== null) {
      var u = s(i);
      if (u !== null) {
        if (i = u.tag, i === 13) {
          if (i = l(u), i !== null) {
            o.blockedOn = i, Jd(o.priority, function() {
              Dw(u);
            });
            return;
          }
        } else if (i === 31) {
          if (i = c(u), i !== null) {
            o.blockedOn = i, Jd(o.priority, function() {
              Dw(u);
            });
            return;
          }
        } else if (i === 3 && u.stateNode.current.memoizedState.isDehydrated) {
          o.blockedOn = u.tag === 3 ? u.stateNode.containerInfo : null;
          return;
        }
      }
    }
    o.blockedOn = null;
  }
  function cc(o) {
    if (o.blockedOn !== null) return !1;
    for (var i = o.targetContainers; 0 < i.length; ) {
      var u = im(o.nativeEvent);
      if (u === null) {
        u = o.nativeEvent;
        var p = new u.constructor(
          u.type,
          u
        );
        sf = p, u.target.dispatchEvent(p), sf = null;
      } else
        return i = ra(u), i !== null && Pw(i), o.blockedOn = u, !1;
      i.shift();
    }
    return !0;
  }
  function Tw(o, i, u) {
    cc(o) && u.delete(i);
  }
  function aN() {
    lm = !1, Mo !== null && cc(Mo) && (Mo = null), No !== null && cc(No) && (No = null), Ao !== null && cc(Ao) && (Ao = null), Ts.forEach(Tw), Ls.forEach(Tw);
  }
  function dc(o, i) {
    o.blockedOn === i && (o.blockedOn = null, lm || (lm = !0, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      aN
    )));
  }
  var fc = null;
  function Lw(o) {
    fc !== o && (fc = o, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      function() {
        fc === o && (fc = null);
        for (var i = 0; i < o.length; i += 3) {
          var u = o[i], p = o[i + 1], y = o[i + 2];
          if (typeof p != "function") {
            if (sm(p || u) === null)
              continue;
            break;
          }
          var S = ra(u);
          S !== null && (o.splice(i, 3), i -= 3, ip(
            S,
            {
              pending: !0,
              data: y,
              method: u.method,
              action: p
            },
            p,
            y
          ));
        }
      }
    ));
  }
  function vi(o) {
    function i(X) {
      return dc(X, o);
    }
    Mo !== null && dc(Mo, o), No !== null && dc(No, o), Ao !== null && dc(Ao, o), Ts.forEach(i), Ls.forEach(i);
    for (var u = 0; u < Ro.length; u++) {
      var p = Ro[u];
      p.blockedOn === o && (p.blockedOn = null);
    }
    for (; 0 < Ro.length && (u = Ro[0], u.blockedOn === null); )
      zw(u), u.blockedOn === null && Ro.shift();
    if (u = (o.ownerDocument || o).$$reactFormReplay, u != null)
      for (p = 0; p < u.length; p += 3) {
        var y = u[p], S = u[p + 1], j = y[yn] || null;
        if (typeof S == "function")
          j || Lw(u);
        else if (j) {
          var T = null;
          if (S && S.hasAttribute("formAction")) {
            if (y = S, j = S[yn] || null)
              T = j.formAction;
            else if (sm(y) !== null) continue;
          } else T = j.action;
          typeof T == "function" ? u[p + 1] = T : (u.splice(p, 3), p -= 3), Lw(u);
        }
      }
  }
  function Fw() {
    function o(S) {
      S.canIntercept && S.info === "react-transition" && S.intercept({
        handler: function() {
          return new Promise(function(j) {
            return y = j;
          });
        },
        focusReset: "manual",
        scroll: "manual"
      });
    }
    function i() {
      y !== null && (y(), y = null), p || setTimeout(u, 20);
    }
    function u() {
      if (!p && !navigation.transition) {
        var S = navigation.currentEntry;
        S && S.url != null && navigation.navigate(S.url, {
          state: S.getState(),
          info: "react-transition",
          history: "replace"
        });
      }
    }
    if (typeof navigation == "object") {
      var p = !1, y = null;
      return navigation.addEventListener("navigate", o), navigation.addEventListener("navigatesuccess", i), navigation.addEventListener("navigateerror", i), setTimeout(u, 100), function() {
        p = !0, navigation.removeEventListener("navigate", o), navigation.removeEventListener("navigatesuccess", i), navigation.removeEventListener("navigateerror", i), y !== null && (y(), y = null);
      };
    }
  }
  function um(o) {
    this._internalRoot = o;
  }
  pc.prototype.render = um.prototype.render = function(o) {
    var i = this._internalRoot;
    if (i === null) throw Error(r(409));
    var u = i.current, p = Gn();
    Rw(u, p, o, i, null, null);
  }, pc.prototype.unmount = um.prototype.unmount = function() {
    var o = this._internalRoot;
    if (o !== null) {
      this._internalRoot = null;
      var i = o.containerInfo;
      Rw(o.current, 2, null, o, null, null), Gu(), i[Ho] = null;
    }
  };
  function pc(o) {
    this._internalRoot = o;
  }
  pc.prototype.unstable_scheduleHydration = function(o) {
    if (o) {
      var i = Xd();
      o = { blockedOn: null, target: o, priority: i };
      for (var u = 0; u < Ro.length && i !== 0 && i < Ro[u].priority; u++) ;
      Ro.splice(u, 0, o), u === 0 && zw(o);
    }
  };
  var Bw = t.version;
  if (Bw !== "19.2.3")
    throw Error(
      r(
        527,
        Bw,
        "19.2.3"
      )
    );
  K.findDOMNode = function(o) {
    var i = o._reactInternals;
    if (i === void 0)
      throw typeof o.render == "function" ? Error(r(188)) : (o = Object.keys(o).join(","), Error(r(268, o)));
    return o = f(i), o = o !== null ? m(o) : null, o = o === null ? null : o.stateNode, o;
  };
  var iN = {
    bundleType: 0,
    version: "19.2.3",
    rendererPackageName: "react-dom",
    currentDispatcherRef: $,
    reconcilerVersion: "19.2.3"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var mc = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!mc.isDisabled && mc.supportsFiber)
      try {
        Xt = mc.inject(
          iN
        ), Nt = mc;
      } catch {
      }
  }
  return Vw.createRoot = function(o, i) {
    if (!a(o)) throw Error(r(299));
    var u = !1, p = "", y = Ky, S = Yy, j = Xy;
    return i != null && (i.unstable_strictMode === !0 && (u = !0), i.identifierPrefix !== void 0 && (p = i.identifierPrefix), i.onUncaughtError !== void 0 && (y = i.onUncaughtError), i.onCaughtError !== void 0 && (S = i.onCaughtError), i.onRecoverableError !== void 0 && (j = i.onRecoverableError)), i = Nw(
      o,
      1,
      !1,
      null,
      null,
      u,
      p,
      null,
      y,
      S,
      j,
      Fw
    ), o[Ho] = i.current, Hp(o), new um(i);
  }, Vw.hydrateRoot = function(o, i, u) {
    if (!a(o)) throw Error(r(299));
    var p = !1, y = "", S = Ky, j = Yy, T = Xy, X = null;
    return u != null && (u.unstable_strictMode === !0 && (p = !0), u.identifierPrefix !== void 0 && (y = u.identifierPrefix), u.onUncaughtError !== void 0 && (S = u.onUncaughtError), u.onCaughtError !== void 0 && (j = u.onCaughtError), u.onRecoverableError !== void 0 && (T = u.onRecoverableError), u.formState !== void 0 && (X = u.formState)), i = Nw(
      o,
      1,
      !0,
      i,
      u ?? null,
      p,
      y,
      X,
      S,
      j,
      T,
      Fw
    ), i.context = Aw(null), u = i.current, p = Gn(), p = nu(p), y = go(p), y.callback = null, vo(u, y, p), u = p, i.current.lanes = u, Ta(i, u), Nr(i), o[Ho] = i.current, Hp(o), new pc(i);
  }, Vw.version = "19.2.3", Vw;
}
var L1;
function xZ() {
  if (L1) return uN.exports;
  L1 = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), uN.exports = wZ(), uN.exports;
}
var SZ = xZ(), M = FS();
const jt = /* @__PURE__ */ IR(M), BS = /* @__PURE__ */ pZ({
  __proto__: null,
  default: jt
}, [M]);
var Xm = K8();
const Bh = /* @__PURE__ */ IR(Xm), kZ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ArrayBufferDataStructure() {
    return hH;
  },
  get CTypeStructure() {
    return gH;
  },
  get DataPreviewViewRendererToHandlePreviewRenderer() {
    return Dq;
  },
  get DataStructure() {
    return Nl;
  },
  get DataViewRendererToDataPreviewViewRenderer() {
    return Ra;
  },
  get DataViewRendererToInputRenderer() {
    return Iq;
  },
  get DataViewRendererToOverlayRenderer() {
    return pC;
  },
  get FuncNodes() {
    return m1;
  },
  get FuncNodesRenderer() {
    return LJ;
  },
  get FuncNodesWorker() {
    return Q4;
  },
  get JSONStructure() {
    return vd;
  },
  get LATEST_VERSION() {
    return TJ;
  },
  get TextStructure() {
    return vH;
  },
  get deep_merge() {
    return Ed;
  },
  get deep_update() {
    return LR;
  },
  get object_factory_maker() {
    return US;
  },
  get useFuncNodesContext() {
    return Sn;
  },
  get useIOGetFullValue() {
    return vk;
  },
  get useIOStore() {
    return hr;
  },
  get useIOValueStore() {
    return v_e;
  },
  get useNodeStore() {
    return Ri;
  },
  get useSetIOValue() {
    return Zm;
  },
  get useSetIOValueOptions() {
    return g_e;
  },
  get useWorkerApi() {
    return Oa;
  }
}, Symbol.toStringTag, { value: "Module" }));
function Gc(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var F1 = { exports: {} }, Hw = {}, B1;
function _Z() {
  if (B1) return Hw;
  B1 = 1;
  var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.fragment");
  function n(r, a, s) {
    var l = null;
    if (s !== void 0 && (l = "" + s), a.key !== void 0 && (l = "" + a.key), "key" in a) {
      s = {};
      for (var c in a)
        c !== "key" && (s[c] = a[c]);
    } else s = a;
    return a = s.ref, {
      $$typeof: e,
      type: r,
      key: l,
      ref: a !== void 0 ? a : null,
      props: s
    };
  }
  return Hw.Fragment = t, Hw.jsx = n, Hw.jsxs = n, Hw;
}
var U1;
function EZ() {
  return U1 || (U1 = 1, F1.exports = _Z()), F1.exports;
}
var C = EZ(), mN = { exports: {} }, Ww = {}, V1 = { exports: {} }, H1 = {}, W1;
function CZ() {
  return W1 || (W1 = 1, (function(e) {
    function t($, K) {
      var q = $.length;
      $.push(K);
      e: for (; 0 < q; ) {
        var Z = q - 1 >>> 1, V = $[Z];
        if (0 < a(V, K))
          $[Z] = K, $[q] = V, q = Z;
        else break e;
      }
    }
    function n($) {
      return $.length === 0 ? null : $[0];
    }
    function r($) {
      if ($.length === 0) return null;
      var K = $[0], q = $.pop();
      if (q !== K) {
        $[0] = q;
        e: for (var Z = 0, V = $.length, F = V >>> 1; Z < F; ) {
          var Y = 2 * (Z + 1) - 1, U = $[Y], W = Y + 1, J = $[W];
          if (0 > a(U, q))
            W < V && 0 > a(J, U) ? ($[Z] = J, $[W] = q, Z = W) : ($[Z] = U, $[Y] = q, Z = Y);
          else if (W < V && 0 > a(J, q))
            $[Z] = J, $[W] = q, Z = W;
          else break e;
        }
      }
      return K;
    }
    function a($, K) {
      var q = $.sortIndex - K.sortIndex;
      return q !== 0 ? q : $.id - K.id;
    }
    if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      e.unstable_now = function() {
        return s.now();
      };
    } else {
      var l = Date, c = l.now();
      e.unstable_now = function() {
        return l.now() - c;
      };
    }
    var d = [], f = [], m = 1, h = null, v = 3, g = !1, b = !1, x = !1, w = !1, k = typeof setTimeout == "function" ? setTimeout : null, E = typeof clearTimeout == "function" ? clearTimeout : null, _ = typeof setImmediate < "u" ? setImmediate : null;
    function O($) {
      for (var K = n(f); K !== null; ) {
        if (K.callback === null) r(f);
        else if (K.startTime <= $)
          r(f), K.sortIndex = K.expirationTime, t(d, K);
        else break;
        K = n(f);
      }
    }
    function N($) {
      if (x = !1, O($), !b)
        if (n(d) !== null)
          b = !0, A || (A = !0, P());
        else {
          var K = n(f);
          K !== null && G(N, K.startTime - $);
        }
    }
    var A = !1, R = -1, D = 5, I = -1;
    function z() {
      return w ? !0 : !(e.unstable_now() - I < D);
    }
    function B() {
      if (w = !1, A) {
        var $ = e.unstable_now();
        I = $;
        var K = !0;
        try {
          e: {
            b = !1, x && (x = !1, E(R), R = -1), g = !0;
            var q = v;
            try {
              t: {
                for (O($), h = n(d); h !== null && !(h.expirationTime > $ && z()); ) {
                  var Z = h.callback;
                  if (typeof Z == "function") {
                    h.callback = null, v = h.priorityLevel;
                    var V = Z(
                      h.expirationTime <= $
                    );
                    if ($ = e.unstable_now(), typeof V == "function") {
                      h.callback = V, O($), K = !0;
                      break t;
                    }
                    h === n(d) && r(d), O($);
                  } else r(d);
                  h = n(d);
                }
                if (h !== null) K = !0;
                else {
                  var F = n(f);
                  F !== null && G(
                    N,
                    F.startTime - $
                  ), K = !1;
                }
              }
              break e;
            } finally {
              h = null, v = q, g = !1;
            }
            K = void 0;
          }
        } finally {
          K ? P() : A = !1;
        }
      }
    }
    var P;
    if (typeof _ == "function")
      P = function() {
        _(B);
      };
    else if (typeof MessageChannel < "u") {
      var H = new MessageChannel(), L = H.port2;
      H.port1.onmessage = B, P = function() {
        L.postMessage(null);
      };
    } else
      P = function() {
        k(B, 0);
      };
    function G($, K) {
      R = k(function() {
        $(e.unstable_now());
      }, K);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function($) {
      $.callback = null;
    }, e.unstable_forceFrameRate = function($) {
      0 > $ || 125 < $ ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : D = 0 < $ ? Math.floor(1e3 / $) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return v;
    }, e.unstable_next = function($) {
      switch (v) {
        case 1:
        case 2:
        case 3:
          var K = 3;
          break;
        default:
          K = v;
      }
      var q = v;
      v = K;
      try {
        return $();
      } finally {
        v = q;
      }
    }, e.unstable_requestPaint = function() {
      w = !0;
    }, e.unstable_runWithPriority = function($, K) {
      switch ($) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          $ = 3;
      }
      var q = v;
      v = $;
      try {
        return K();
      } finally {
        v = q;
      }
    }, e.unstable_scheduleCallback = function($, K, q) {
      var Z = e.unstable_now();
      switch (typeof q == "object" && q !== null ? (q = q.delay, q = typeof q == "number" && 0 < q ? Z + q : Z) : q = Z, $) {
        case 1:
          var V = -1;
          break;
        case 2:
          V = 250;
          break;
        case 5:
          V = 1073741823;
          break;
        case 4:
          V = 1e4;
          break;
        default:
          V = 5e3;
      }
      return V = q + V, $ = {
        id: m++,
        callback: K,
        priorityLevel: $,
        startTime: q,
        expirationTime: V,
        sortIndex: -1
      }, q > Z ? ($.sortIndex = q, t(f, $), n(d) === null && $ === n(f) && (x ? (E(R), R = -1) : x = !0, G(N, q - Z))) : ($.sortIndex = V, t(d, $), b || g || (b = !0, A || (A = !0, P()))), $;
    }, e.unstable_shouldYield = z, e.unstable_wrapCallback = function($) {
      var K = v;
      return function() {
        var q = v;
        v = K;
        try {
          return $.apply(this, arguments);
        } finally {
          v = q;
        }
      };
    };
  })(H1)), H1;
}
var q1;
function OZ() {
  return q1 || (q1 = 1, V1.exports = CZ()), V1.exports;
}
var G1;
function MZ() {
  if (G1) return Ww;
  G1 = 1;
  var e = OZ(), t = jt, n = Bh;
  function r(o) {
    var i = "https://react.dev/errors/" + o;
    if (1 < arguments.length) {
      i += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var u = 2; u < arguments.length; u++)
        i += "&args[]=" + encodeURIComponent(arguments[u]);
    }
    return "Minified React error #" + o + "; visit " + i + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function a(o) {
    return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11);
  }
  function s(o) {
    var i = o, u = o;
    if (o.alternate) for (; i.return; ) i = i.return;
    else {
      o = i;
      do
        i = o, (i.flags & 4098) !== 0 && (u = i.return), o = i.return;
      while (o);
    }
    return i.tag === 3 ? u : null;
  }
  function l(o) {
    if (o.tag === 13) {
      var i = o.memoizedState;
      if (i === null && (o = o.alternate, o !== null && (i = o.memoizedState)), i !== null) return i.dehydrated;
    }
    return null;
  }
  function c(o) {
    if (o.tag === 31) {
      var i = o.memoizedState;
      if (i === null && (o = o.alternate, o !== null && (i = o.memoizedState)), i !== null) return i.dehydrated;
    }
    return null;
  }
  function d(o) {
    if (s(o) !== o)
      throw Error(r(188));
  }
  function f(o) {
    var i = o.alternate;
    if (!i) {
      if (i = s(o), i === null) throw Error(r(188));
      return i !== o ? null : o;
    }
    for (var u = o, p = i; ; ) {
      var y = u.return;
      if (y === null) break;
      var S = y.alternate;
      if (S === null) {
        if (p = y.return, p !== null) {
          u = p;
          continue;
        }
        break;
      }
      if (y.child === S.child) {
        for (S = y.child; S; ) {
          if (S === u) return d(y), o;
          if (S === p) return d(y), i;
          S = S.sibling;
        }
        throw Error(r(188));
      }
      if (u.return !== p.return) u = y, p = S;
      else {
        for (var j = !1, T = y.child; T; ) {
          if (T === u) {
            j = !0, u = y, p = S;
            break;
          }
          if (T === p) {
            j = !0, p = y, u = S;
            break;
          }
          T = T.sibling;
        }
        if (!j) {
          for (T = S.child; T; ) {
            if (T === u) {
              j = !0, u = S, p = y;
              break;
            }
            if (T === p) {
              j = !0, p = S, u = y;
              break;
            }
            T = T.sibling;
          }
          if (!j) throw Error(r(189));
        }
      }
      if (u.alternate !== p) throw Error(r(190));
    }
    if (u.tag !== 3) throw Error(r(188));
    return u.stateNode.current === u ? o : i;
  }
  function m(o) {
    var i = o.tag;
    if (i === 5 || i === 26 || i === 27 || i === 6) return o;
    for (o = o.child; o !== null; ) {
      if (i = m(o), i !== null) return i;
      o = o.sibling;
    }
    return null;
  }
  var h = Object.assign, v = /* @__PURE__ */ Symbol.for("react.element"), g = /* @__PURE__ */ Symbol.for("react.transitional.element"), b = /* @__PURE__ */ Symbol.for("react.portal"), x = /* @__PURE__ */ Symbol.for("react.fragment"), w = /* @__PURE__ */ Symbol.for("react.strict_mode"), k = /* @__PURE__ */ Symbol.for("react.profiler"), E = /* @__PURE__ */ Symbol.for("react.consumer"), _ = /* @__PURE__ */ Symbol.for("react.context"), O = /* @__PURE__ */ Symbol.for("react.forward_ref"), N = /* @__PURE__ */ Symbol.for("react.suspense"), A = /* @__PURE__ */ Symbol.for("react.suspense_list"), R = /* @__PURE__ */ Symbol.for("react.memo"), D = /* @__PURE__ */ Symbol.for("react.lazy"), I = /* @__PURE__ */ Symbol.for("react.activity"), z = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel"), B = Symbol.iterator;
  function P(o) {
    return o === null || typeof o != "object" ? null : (o = B && o[B] || o["@@iterator"], typeof o == "function" ? o : null);
  }
  var H = /* @__PURE__ */ Symbol.for("react.client.reference");
  function L(o) {
    if (o == null) return null;
    if (typeof o == "function")
      return o.$$typeof === H ? null : o.displayName || o.name || null;
    if (typeof o == "string") return o;
    switch (o) {
      case x:
        return "Fragment";
      case k:
        return "Profiler";
      case w:
        return "StrictMode";
      case N:
        return "Suspense";
      case A:
        return "SuspenseList";
      case I:
        return "Activity";
    }
    if (typeof o == "object")
      switch (o.$$typeof) {
        case b:
          return "Portal";
        case _:
          return o.displayName || "Context";
        case E:
          return (o._context.displayName || "Context") + ".Consumer";
        case O:
          var i = o.render;
          return o = o.displayName, o || (o = i.displayName || i.name || "", o = o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef"), o;
        case R:
          return i = o.displayName || null, i !== null ? i : L(o.type) || "Memo";
        case D:
          i = o._payload, o = o._init;
          try {
            return L(o(i));
          } catch {
          }
      }
    return null;
  }
  var G = Array.isArray, $ = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, K = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, q = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, Z = [], V = -1;
  function F(o) {
    return { current: o };
  }
  function Y(o) {
    0 > V || (o.current = Z[V], Z[V] = null, V--);
  }
  function U(o, i) {
    V++, Z[V] = o.current, o.current = i;
  }
  var W = F(null), J = F(null), oe = F(null), fe = F(null);
  function ie(o, i) {
    switch (U(oe, i), U(J, o), U(W, null), i.nodeType) {
      case 9:
      case 11:
        o = (o = i.documentElement) && (o = o.namespaceURI) ? dw(o) : 0;
        break;
      default:
        if (o = i.tagName, i = i.namespaceURI)
          i = dw(i), o = fw(i, o);
        else
          switch (o) {
            case "svg":
              o = 1;
              break;
            case "math":
              o = 2;
              break;
            default:
              o = 0;
          }
    }
    Y(W), U(W, o);
  }
  function ce() {
    Y(W), Y(J), Y(oe);
  }
  function ge(o) {
    o.memoizedState !== null && U(fe, o);
    var i = W.current, u = fw(i, o.type);
    i !== u && (U(J, o), U(W, u));
  }
  function re(o) {
    J.current === o && (Y(W), Y(J)), fe.current === o && (Y(fe), zs._currentValue = q);
  }
  var le, me;
  function ve(o) {
    if (le === void 0)
      try {
        throw Error();
      } catch (u) {
        var i = u.stack.trim().match(/\n( *(at )?)/);
        le = i && i[1] || "", me = -1 < u.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < u.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + le + o + me;
  }
  var xe = !1;
  function _e(o, i) {
    if (!o || xe) return "";
    xe = !0;
    var u = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var p = {
        DetermineComponentFrameRoot: function() {
          try {
            if (i) {
              var pe = function() {
                throw Error();
              };
              if (Object.defineProperty(pe.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(pe, []);
                } catch (se) {
                  var ae = se;
                }
                Reflect.construct(o, [], pe);
              } else {
                try {
                  pe.call();
                } catch (se) {
                  ae = se;
                }
                o.call(pe.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (se) {
                ae = se;
              }
              (pe = o()) && typeof pe.catch == "function" && pe.catch(function() {
              });
            }
          } catch (se) {
            if (se && ae && typeof se.stack == "string")
              return [se.stack, ae.stack];
          }
          return [null, null];
        }
      };
      p.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var y = Object.getOwnPropertyDescriptor(
        p.DetermineComponentFrameRoot,
        "name"
      );
      y && y.configurable && Object.defineProperty(
        p.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var S = p.DetermineComponentFrameRoot(), j = S[0], T = S[1];
      if (j && T) {
        var X = j.split(`
`), ne = T.split(`
`);
        for (y = p = 0; p < X.length && !X[p].includes("DetermineComponentFrameRoot"); )
          p++;
        for (; y < ne.length && !ne[y].includes(
          "DetermineComponentFrameRoot"
        ); )
          y++;
        if (p === X.length || y === ne.length)
          for (p = X.length - 1, y = ne.length - 1; 1 <= p && 0 <= y && X[p] !== ne[y]; )
            y--;
        for (; 1 <= p && 0 <= y; p--, y--)
          if (X[p] !== ne[y]) {
            if (p !== 1 || y !== 1)
              do
                if (p--, y--, 0 > y || X[p] !== ne[y]) {
                  var ue = `
` + X[p].replace(" at new ", " at ");
                  return o.displayName && ue.includes("<anonymous>") && (ue = ue.replace("<anonymous>", o.displayName)), ue;
                }
              while (1 <= p && 0 <= y);
            break;
          }
      }
    } finally {
      xe = !1, Error.prepareStackTrace = u;
    }
    return (u = o ? o.displayName || o.name : "") ? ve(u) : "";
  }
  function Ge(o, i) {
    switch (o.tag) {
      case 26:
      case 27:
      case 5:
        return ve(o.type);
      case 16:
        return ve("Lazy");
      case 13:
        return o.child !== i && i !== null ? ve("Suspense Fallback") : ve("Suspense");
      case 19:
        return ve("SuspenseList");
      case 0:
      case 15:
        return _e(o.type, !1);
      case 11:
        return _e(o.type.render, !1);
      case 1:
        return _e(o.type, !0);
      case 31:
        return ve("Activity");
      default:
        return "";
    }
  }
  function Xe(o) {
    try {
      var i = "", u = null;
      do
        i += Ge(o, u), u = o, o = o.return;
      while (o);
      return i;
    } catch (p) {
      return `
Error generating stack: ` + p.message + `
` + p.stack;
    }
  }
  var tt = Object.prototype.hasOwnProperty, nt = e.unstable_scheduleCallback, je = e.unstable_cancelCallback, cn = e.unstable_shouldYield, pt = e.unstable_requestPaint, Ce = e.unstable_now, Me = e.unstable_getCurrentPriorityLevel, he = e.unstable_ImmediatePriority, ye = e.unstable_UserBlockingPriority, Ee = e.unstable_NormalPriority, Te = e.unstable_LowPriority, Fe = e.unstable_IdlePriority, Ut = e.log, Vt = e.unstable_setDisableYieldValue, Xt = null, Nt = null;
  function kn(o) {
    if (typeof Ut == "function" && Vt(o), Nt && typeof Nt.setStrictMode == "function")
      try {
        Nt.setStrictMode(Xt, o);
      } catch {
      }
  }
  var Ae = Math.clz32 ? Math.clz32 : Bo, Ht = Math.log, Zt = Math.LN2;
  function Bo(o) {
    return o >>>= 0, o === 0 ? 32 : 31 - (Ht(o) / Zt | 0) | 0;
  }
  var Uo = 256, hn = 262144, On = 4194304;
  function _r(o) {
    var i = o & 42;
    if (i !== 0) return i;
    switch (o & -o) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
        return o & 261888;
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return o & 3932160;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return o & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return o;
    }
  }
  function Vo(o, i, u) {
    var p = o.pendingLanes;
    if (p === 0) return 0;
    var y = 0, S = o.suspendedLanes, j = o.pingedLanes;
    o = o.warmLanes;
    var T = p & 134217727;
    return T !== 0 ? (p = T & ~S, p !== 0 ? y = _r(p) : (j &= T, j !== 0 ? y = _r(j) : u || (u = T & ~o, u !== 0 && (y = _r(u))))) : (T = p & ~S, T !== 0 ? y = _r(T) : j !== 0 ? y = _r(j) : u || (u = p & ~o, u !== 0 && (y = _r(u)))), y === 0 ? 0 : i !== 0 && i !== y && (i & S) === 0 && (S = y & -y, u = i & -i, S >= u || S === 32 && (u & 4194048) !== 0) ? i : y;
  }
  function vr(o, i) {
    return (o.pendingLanes & ~(o.suspendedLanes & ~o.pingedLanes) & i) === 0;
  }
  function Zg(o, i) {
    switch (o) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return i + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return i + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function qd() {
    var o = On;
    return On <<= 1, (On & 62914560) === 0 && (On = 4194304), o;
  }
  function tu(o) {
    for (var i = [], u = 0; 31 > u; u++) i.push(o);
    return i;
  }
  function Ta(o, i) {
    o.pendingLanes |= i, i !== 268435456 && (o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0);
  }
  function ev(o, i, u, p, y, S) {
    var j = o.pendingLanes;
    o.pendingLanes = u, o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0, o.expiredLanes &= u, o.entangledLanes &= u, o.errorRecoveryDisabledLanes &= u, o.shellSuspendCounter = 0;
    var T = o.entanglements, X = o.expirationTimes, ne = o.hiddenUpdates;
    for (u = j & ~u; 0 < u; ) {
      var ue = 31 - Ae(u), pe = 1 << ue;
      T[ue] = 0, X[ue] = -1;
      var ae = ne[ue];
      if (ae !== null)
        for (ne[ue] = null, ue = 0; ue < ae.length; ue++) {
          var se = ae[ue];
          se !== null && (se.lane &= -536870913);
        }
      u &= ~pe;
    }
    p !== 0 && Gd(o, p, 0), S !== 0 && y === 0 && o.tag !== 0 && (o.suspendedLanes |= S & ~(j & ~i));
  }
  function Gd(o, i, u) {
    o.pendingLanes |= i, o.suspendedLanes &= ~i;
    var p = 31 - Ae(i);
    o.entangledLanes |= i, o.entanglements[p] = o.entanglements[p] | 1073741824 | u & 261930;
  }
  function Kd(o, i) {
    var u = o.entangledLanes |= i;
    for (o = o.entanglements; u; ) {
      var p = 31 - Ae(u), y = 1 << p;
      y & i | o[p] & i && (o[p] |= i), u &= ~y;
    }
  }
  function Yd(o, i) {
    var u = i & -i;
    return u = (u & 42) !== 0 ? 1 : nu(u), (u & (o.suspendedLanes | i)) !== 0 ? 0 : u;
  }
  function nu(o) {
    switch (o) {
      case 2:
        o = 1;
        break;
      case 8:
        o = 4;
        break;
      case 32:
        o = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        o = 128;
        break;
      case 268435456:
        o = 134217728;
        break;
      default:
        o = 0;
    }
    return o;
  }
  function ru(o) {
    return o &= -o, 2 < o ? 8 < o ? (o & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function Xd() {
    var o = K.p;
    return o !== 0 ? o : (o = window.event, o === void 0 ? 32 : Iw(o.type));
  }
  function Jd(o, i) {
    var u = K.p;
    try {
      return K.p = o, i();
    } finally {
      K.p = u;
    }
  }
  var Tr = Math.random().toString(36).slice(2), en = "__reactFiber$" + Tr, yn = "__reactProps$" + Tr, Ho = "__reactContainer$" + Tr, cl = "__reactEvents$" + Tr, dh = "__reactListeners$" + Tr, tv = "__reactHandles$" + Tr, Qd = "__reactResources$" + Tr, La = "__reactMarker$" + Tr;
  function ou(o) {
    delete o[en], delete o[yn], delete o[cl], delete o[dh], delete o[tv];
  }
  function na(o) {
    var i = o[en];
    if (i) return i;
    for (var u = o.parentNode; u; ) {
      if (i = u[Ho] || u[en]) {
        if (u = i.alternate, i.child !== null || u !== null && u.child !== null)
          for (o = bw(o); o !== null; ) {
            if (u = o[en]) return u;
            o = bw(o);
          }
        return i;
      }
      o = u, u = o.parentNode;
    }
    return null;
  }
  function ra(o) {
    if (o = o[en] || o[Ho]) {
      var i = o.tag;
      if (i === 5 || i === 6 || i === 13 || i === 31 || i === 26 || i === 27 || i === 3)
        return o;
    }
    return null;
  }
  function Na(o) {
    var i = o.tag;
    if (i === 5 || i === 26 || i === 27 || i === 6) return o.stateNode;
    throw Error(r(33));
  }
  function oa(o) {
    var i = o[Qd];
    return i || (i = o[Qd] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), i;
  }
  function Wt(o) {
    o[La] = !0;
  }
  var Zd = /* @__PURE__ */ new Set(), ef = {};
  function lo(o, i) {
    aa(o, i), aa(o + "Capture", i);
  }
  function aa(o, i) {
    for (ef[o] = i, o = 0; o < i.length; o++)
      Zd.add(i[o]);
  }
  var nv = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), od = {}, tf = {};
  function rv(o) {
    return tt.call(tf, o) ? !0 : tt.call(od, o) ? !1 : nv.test(o) ? tf[o] = !0 : (od[o] = !0, !1);
  }
  function Ji(o, i, u) {
    if (rv(i))
      if (u === null) o.removeAttribute(i);
      else {
        switch (typeof u) {
          case "undefined":
          case "function":
          case "symbol":
            o.removeAttribute(i);
            return;
          case "boolean":
            var p = i.toLowerCase().slice(0, 5);
            if (p !== "data-" && p !== "aria-") {
              o.removeAttribute(i);
              return;
            }
        }
        o.setAttribute(i, "" + u);
      }
  }
  function Qi(o, i, u) {
    if (u === null) o.removeAttribute(i);
    else {
      switch (typeof u) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          o.removeAttribute(i);
          return;
      }
      o.setAttribute(i, "" + u);
    }
  }
  function Er(o, i, u, p) {
    if (p === null) o.removeAttribute(u);
    else {
      switch (typeof p) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          o.removeAttribute(u);
          return;
      }
      o.setAttributeNS(i, u, "" + p);
    }
  }
  function Fn(o) {
    switch (typeof o) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return o;
      case "object":
        return o;
      default:
        return "";
    }
  }
  function nf(o) {
    var i = o.type;
    return (o = o.nodeName) && o.toLowerCase() === "input" && (i === "checkbox" || i === "radio");
  }
  function ov(o, i, u) {
    var p = Object.getOwnPropertyDescriptor(
      o.constructor.prototype,
      i
    );
    if (!o.hasOwnProperty(i) && typeof p < "u" && typeof p.get == "function" && typeof p.set == "function") {
      var y = p.get, S = p.set;
      return Object.defineProperty(o, i, {
        configurable: !0,
        get: function() {
          return y.call(this);
        },
        set: function(j) {
          u = "" + j, S.call(this, j);
        }
      }), Object.defineProperty(o, i, {
        enumerable: p.enumerable
      }), {
        getValue: function() {
          return u;
        },
        setValue: function(j) {
          u = "" + j;
        },
        stopTracking: function() {
          o._valueTracker = null, delete o[i];
        }
      };
    }
  }
  function dl(o) {
    if (!o._valueTracker) {
      var i = nf(o) ? "checked" : "value";
      o._valueTracker = ov(
        o,
        i,
        "" + o[i]
      );
    }
  }
  function rf(o) {
    if (!o) return !1;
    var i = o._valueTracker;
    if (!i) return !0;
    var u = i.getValue(), p = "";
    return o && (p = nf(o) ? o.checked ? "true" : "false" : o.value), o = p, o !== u ? (i.setValue(o), !0) : !1;
  }
  function Di(o) {
    if (o = o || (typeof document < "u" ? document : void 0), typeof o > "u") return null;
    try {
      return o.activeElement || o.body;
    } catch {
      return o.body;
    }
  }
  var av = /[\n"\\]/g;
  function Jn(o) {
    return o.replace(
      av,
      function(i) {
        return "\\" + i.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function Zi(o, i, u, p, y, S, j, T) {
    o.name = "", j != null && typeof j != "function" && typeof j != "symbol" && typeof j != "boolean" ? o.type = j : o.removeAttribute("type"), i != null ? j === "number" ? (i === 0 && o.value === "" || o.value != i) && (o.value = "" + Fn(i)) : o.value !== "" + Fn(i) && (o.value = "" + Fn(i)) : j !== "submit" && j !== "reset" || o.removeAttribute("value"), i != null ? au(o, j, Fn(i)) : u != null ? au(o, j, Fn(u)) : p != null && o.removeAttribute("value"), y == null && S != null && (o.defaultChecked = !!S), y != null && (o.checked = y && typeof y != "function" && typeof y != "symbol"), T != null && typeof T != "function" && typeof T != "symbol" && typeof T != "boolean" ? o.name = "" + Fn(T) : o.removeAttribute("name");
  }
  function of(o, i, u, p, y, S, j, T) {
    if (S != null && typeof S != "function" && typeof S != "symbol" && typeof S != "boolean" && (o.type = S), i != null || u != null) {
      if (!(S !== "submit" && S !== "reset" || i != null)) {
        dl(o);
        return;
      }
      u = u != null ? "" + Fn(u) : "", i = i != null ? "" + Fn(i) : u, T || i === o.value || (o.value = i), o.defaultValue = i;
    }
    p = p ?? y, p = typeof p != "function" && typeof p != "symbol" && !!p, o.checked = T ? o.checked : !!p, o.defaultChecked = !!p, j != null && typeof j != "function" && typeof j != "symbol" && typeof j != "boolean" && (o.name = j), dl(o);
  }
  function au(o, i, u) {
    i === "number" && Di(o.ownerDocument) === o || o.defaultValue === "" + u || (o.defaultValue = "" + u);
  }
  function Wo(o, i, u, p) {
    if (o = o.options, i) {
      i = {};
      for (var y = 0; y < u.length; y++)
        i["$" + u[y]] = !0;
      for (u = 0; u < o.length; u++)
        y = i.hasOwnProperty("$" + o[u].value), o[u].selected !== y && (o[u].selected = y), y && p && (o[u].defaultSelected = !0);
    } else {
      for (u = "" + Fn(u), i = null, y = 0; y < o.length; y++) {
        if (o[y].value === u) {
          o[y].selected = !0, p && (o[y].defaultSelected = !0);
          return;
        }
        i !== null || o[y].disabled || (i = o[y]);
      }
      i !== null && (i.selected = !0);
    }
  }
  function iv(o, i, u) {
    if (i != null && (i = "" + Fn(i), i !== o.value && (o.value = i), u == null)) {
      o.defaultValue !== i && (o.defaultValue = i);
      return;
    }
    o.defaultValue = u != null ? "" + Fn(u) : "";
  }
  function sv(o, i, u, p) {
    if (i == null) {
      if (p != null) {
        if (u != null) throw Error(r(92));
        if (G(p)) {
          if (1 < p.length) throw Error(r(93));
          p = p[0];
        }
        u = p;
      }
      u == null && (u = ""), i = u;
    }
    u = Fn(i), o.defaultValue = u, p = o.textContent, p === u && p !== "" && p !== null && (o.value = p), dl(o);
  }
  function Fa(o, i) {
    if (i) {
      var u = o.firstChild;
      if (u && u === o.lastChild && u.nodeType === 3) {
        u.nodeValue = i;
        return;
      }
    }
    o.textContent = i;
  }
  var rO = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function lv(o, i, u) {
    var p = i.indexOf("--") === 0;
    u == null || typeof u == "boolean" || u === "" ? p ? o.setProperty(i, "") : i === "float" ? o.cssFloat = "" : o[i] = "" : p ? o.setProperty(i, u) : typeof u != "number" || u === 0 || rO.has(i) ? i === "float" ? o.cssFloat = u : o[i] = ("" + u).trim() : o[i] = u + "px";
  }
  function uv(o, i, u) {
    if (i != null && typeof i != "object")
      throw Error(r(62));
    if (o = o.style, u != null) {
      for (var p in u)
        !u.hasOwnProperty(p) || i != null && i.hasOwnProperty(p) || (p.indexOf("--") === 0 ? o.setProperty(p, "") : p === "float" ? o.cssFloat = "" : o[p] = "");
      for (var y in i)
        p = i[y], i.hasOwnProperty(y) && u[y] !== p && lv(o, y, p);
    } else
      for (var S in i)
        i.hasOwnProperty(S) && lv(o, S, i[S]);
  }
  function af(o) {
    if (o.indexOf("-") === -1) return !1;
    switch (o) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var oO = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), aO = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function iu(o) {
    return aO.test("" + o) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : o;
  }
  function Lr() {
  }
  var sf = null;
  function lf(o) {
    return o = o.target || o.srcElement || window, o.correspondingUseElement && (o = o.correspondingUseElement), o.nodeType === 3 ? o.parentNode : o;
  }
  var Ba = null, Ua = null;
  function cv(o) {
    var i = ra(o);
    if (i && (o = i.stateNode)) {
      var u = o[yn] || null;
      e: switch (o = i.stateNode, i.type) {
        case "input":
          if (Zi(
            o,
            u.value,
            u.defaultValue,
            u.defaultValue,
            u.checked,
            u.defaultChecked,
            u.type,
            u.name
          ), i = u.name, u.type === "radio" && i != null) {
            for (u = o; u.parentNode; ) u = u.parentNode;
            for (u = u.querySelectorAll(
              'input[name="' + Jn(
                "" + i
              ) + '"][type="radio"]'
            ), i = 0; i < u.length; i++) {
              var p = u[i];
              if (p !== o && p.form === o.form) {
                var y = p[yn] || null;
                if (!y) throw Error(r(90));
                Zi(
                  p,
                  y.value,
                  y.defaultValue,
                  y.defaultValue,
                  y.checked,
                  y.defaultChecked,
                  y.type,
                  y.name
                );
              }
            }
            for (i = 0; i < u.length; i++)
              p = u[i], p.form === o.form && rf(p);
          }
          break e;
        case "textarea":
          iv(o, u.value, u.defaultValue);
          break e;
        case "select":
          i = u.value, i != null && Wo(o, !!u.multiple, i, !1);
      }
    }
  }
  var uf = !1;
  function dv(o, i, u) {
    if (uf) return o(i, u);
    uf = !0;
    try {
      var p = o(i);
      return p;
    } finally {
      if (uf = !1, (Ba !== null || Ua !== null) && (Gu(), Ba && (i = Ba, o = Ua, Ua = Ba = null, cv(i), o)))
        for (i = 0; i < o.length; i++) cv(o[i]);
    }
  }
  function es(o, i) {
    var u = o.stateNode;
    if (u === null) return null;
    var p = u[yn] || null;
    if (p === null) return null;
    u = p[i];
    e: switch (i) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (p = !p.disabled) || (o = o.type, p = !(o === "button" || o === "input" || o === "select" || o === "textarea")), o = !p;
        break e;
      default:
        o = !1;
    }
    if (o) return null;
    if (u && typeof u != "function")
      throw Error(
        r(231, i, typeof u)
      );
    return u;
  }
  var Fr = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), cf = !1;
  if (Fr)
    try {
      var ts = {};
      Object.defineProperty(ts, "passive", {
        get: function() {
          cf = !0;
        }
      }), window.addEventListener("test", ts, ts), window.removeEventListener("test", ts, ts);
    } catch {
      cf = !1;
    }
  var uo = null, df = null, su = null;
  function fv() {
    if (su) return su;
    var o, i = df, u = i.length, p, y = "value" in uo ? uo.value : uo.textContent, S = y.length;
    for (o = 0; o < u && i[o] === y[o]; o++) ;
    var j = u - o;
    for (p = 1; p <= j && i[u - p] === y[S - p]; p++) ;
    return su = y.slice(o, 1 < p ? 1 - p : void 0);
  }
  function lu(o) {
    var i = o.keyCode;
    return "charCode" in o ? (o = o.charCode, o === 0 && i === 13 && (o = 13)) : o = i, o === 10 && (o = 13), 32 <= o || o === 13 ? o : 0;
  }
  function uu() {
    return !0;
  }
  function pv() {
    return !1;
  }
  function Mn(o) {
    function i(u, p, y, S, j) {
      this._reactName = u, this._targetInst = y, this.type = p, this.nativeEvent = S, this.target = j, this.currentTarget = null;
      for (var T in o)
        o.hasOwnProperty(T) && (u = o[T], this[T] = u ? u(S) : S[T]);
      return this.isDefaultPrevented = (S.defaultPrevented != null ? S.defaultPrevented : S.returnValue === !1) ? uu : pv, this.isPropagationStopped = pv, this;
    }
    return h(i.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var u = this.nativeEvent;
        u && (u.preventDefault ? u.preventDefault() : typeof u.returnValue != "unknown" && (u.returnValue = !1), this.isDefaultPrevented = uu);
      },
      stopPropagation: function() {
        var u = this.nativeEvent;
        u && (u.stopPropagation ? u.stopPropagation() : typeof u.cancelBubble != "unknown" && (u.cancelBubble = !0), this.isPropagationStopped = uu);
      },
      persist: function() {
      },
      isPersistent: uu
    }), i;
  }
  var ia = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(o) {
      return o.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, cu = Mn(ia), ns = h({}, ia, { view: 0, detail: 0 }), iO = Mn(ns), ff, pf, rs, du = h({}, ns, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: hf,
    button: 0,
    buttons: 0,
    relatedTarget: function(o) {
      return o.relatedTarget === void 0 ? o.fromElement === o.srcElement ? o.toElement : o.fromElement : o.relatedTarget;
    },
    movementX: function(o) {
      return "movementX" in o ? o.movementX : (o !== rs && (rs && o.type === "mousemove" ? (ff = o.screenX - rs.screenX, pf = o.screenY - rs.screenY) : pf = ff = 0, rs = o), ff);
    },
    movementY: function(o) {
      return "movementY" in o ? o.movementY : pf;
    }
  }), mv = Mn(du), sO = h({}, du, { dataTransfer: 0 }), lO = Mn(sO), uO = h({}, ns, { relatedTarget: 0 }), mf = Mn(uO), cO = h({}, ia, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), dO = Mn(cO), fO = h({}, ia, {
    clipboardData: function(o) {
      return "clipboardData" in o ? o.clipboardData : window.clipboardData;
    }
  }), pO = Mn(fO), mO = h({}, ia, { data: 0 }), hv = Mn(mO), hO = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, gO = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, vO = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function yO(o) {
    var i = this.nativeEvent;
    return i.getModifierState ? i.getModifierState(o) : (o = vO[o]) ? !!i[o] : !1;
  }
  function hf() {
    return yO;
  }
  var bO = h({}, ns, {
    key: function(o) {
      if (o.key) {
        var i = hO[o.key] || o.key;
        if (i !== "Unidentified") return i;
      }
      return o.type === "keypress" ? (o = lu(o), o === 13 ? "Enter" : String.fromCharCode(o)) : o.type === "keydown" || o.type === "keyup" ? gO[o.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: hf,
    charCode: function(o) {
      return o.type === "keypress" ? lu(o) : 0;
    },
    keyCode: function(o) {
      return o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
    },
    which: function(o) {
      return o.type === "keypress" ? lu(o) : o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
    }
  }), wO = Mn(bO), xO = h({}, du, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), gv = Mn(xO), SO = h({}, ns, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: hf
  }), kO = Mn(SO), _O = h({}, ia, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), EO = Mn(_O), CO = h({}, du, {
    deltaX: function(o) {
      return "deltaX" in o ? o.deltaX : "wheelDeltaX" in o ? -o.wheelDeltaX : 0;
    },
    deltaY: function(o) {
      return "deltaY" in o ? o.deltaY : "wheelDeltaY" in o ? -o.wheelDeltaY : "wheelDelta" in o ? -o.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), OO = Mn(CO), MO = h({}, ia, {
    newState: 0,
    oldState: 0
  }), NO = Mn(MO), AO = [9, 13, 27, 32], gf = Fr && "CompositionEvent" in window, os = null;
  Fr && "documentMode" in document && (os = document.documentMode);
  var RO = Fr && "TextEvent" in window && !os, vv = Fr && (!gf || os && 8 < os && 11 >= os), yv = " ", bv = !1;
  function wv(o, i) {
    switch (o) {
      case "keyup":
        return AO.indexOf(i.keyCode) !== -1;
      case "keydown":
        return i.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function xv(o) {
    return o = o.detail, typeof o == "object" && "data" in o ? o.data : null;
  }
  var Va = !1;
  function jO(o, i) {
    switch (o) {
      case "compositionend":
        return xv(i);
      case "keypress":
        return i.which !== 32 ? null : (bv = !0, yv);
      case "textInput":
        return o = i.data, o === yv && bv ? null : o;
      default:
        return null;
    }
  }
  function PO(o, i) {
    if (Va)
      return o === "compositionend" || !gf && wv(o, i) ? (o = fv(), su = df = uo = null, Va = !1, o) : null;
    switch (o) {
      case "paste":
        return null;
      case "keypress":
        if (!(i.ctrlKey || i.altKey || i.metaKey) || i.ctrlKey && i.altKey) {
          if (i.char && 1 < i.char.length)
            return i.char;
          if (i.which) return String.fromCharCode(i.which);
        }
        return null;
      case "compositionend":
        return vv && i.locale !== "ko" ? null : i.data;
      default:
        return null;
    }
  }
  var DO = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function Sv(o) {
    var i = o && o.nodeName && o.nodeName.toLowerCase();
    return i === "input" ? !!DO[o.type] : i === "textarea";
  }
  function kv(o, i, u, p) {
    Ba ? Ua ? Ua.push(p) : Ua = [p] : Ba = p, i = ec(i, "onChange"), 0 < i.length && (u = new cu(
      "onChange",
      "change",
      null,
      u,
      p
    ), o.push({ event: u, listeners: i }));
  }
  var as = null, is = null;
  function IO(o) {
    aw(o, 0);
  }
  function fu(o) {
    var i = Na(o);
    if (rf(i)) return o;
  }
  function _v(o, i) {
    if (o === "change") return i;
  }
  var Ev = !1;
  if (Fr) {
    var vf;
    if (Fr) {
      var yf = "oninput" in document;
      if (!yf) {
        var Cv = document.createElement("div");
        Cv.setAttribute("oninput", "return;"), yf = typeof Cv.oninput == "function";
      }
      vf = yf;
    } else vf = !1;
    Ev = vf && (!document.documentMode || 9 < document.documentMode);
  }
  function Ov() {
    as && (as.detachEvent("onpropertychange", Mv), is = as = null);
  }
  function Mv(o) {
    if (o.propertyName === "value" && fu(is)) {
      var i = [];
      kv(
        i,
        is,
        o,
        lf(o)
      ), dv(IO, i);
    }
  }
  function $O(o, i, u) {
    o === "focusin" ? (Ov(), as = i, is = u, as.attachEvent("onpropertychange", Mv)) : o === "focusout" && Ov();
  }
  function zO(o) {
    if (o === "selectionchange" || o === "keyup" || o === "keydown")
      return fu(is);
  }
  function TO(o, i) {
    if (o === "click") return fu(i);
  }
  function LO(o, i) {
    if (o === "input" || o === "change")
      return fu(i);
  }
  function FO(o, i) {
    return o === i && (o !== 0 || 1 / o === 1 / i) || o !== o && i !== i;
  }
  var Bn = typeof Object.is == "function" ? Object.is : FO;
  function ss(o, i) {
    if (Bn(o, i)) return !0;
    if (typeof o != "object" || o === null || typeof i != "object" || i === null)
      return !1;
    var u = Object.keys(o), p = Object.keys(i);
    if (u.length !== p.length) return !1;
    for (p = 0; p < u.length; p++) {
      var y = u[p];
      if (!tt.call(i, y) || !Bn(o[y], i[y]))
        return !1;
    }
    return !0;
  }
  function Nv(o) {
    for (; o && o.firstChild; ) o = o.firstChild;
    return o;
  }
  function Av(o, i) {
    var u = Nv(o);
    o = 0;
    for (var p; u; ) {
      if (u.nodeType === 3) {
        if (p = o + u.textContent.length, o <= i && p >= i)
          return { node: u, offset: i - o };
        o = p;
      }
      e: {
        for (; u; ) {
          if (u.nextSibling) {
            u = u.nextSibling;
            break e;
          }
          u = u.parentNode;
        }
        u = void 0;
      }
      u = Nv(u);
    }
  }
  function Rv(o, i) {
    return o && i ? o === i ? !0 : o && o.nodeType === 3 ? !1 : i && i.nodeType === 3 ? Rv(o, i.parentNode) : "contains" in o ? o.contains(i) : o.compareDocumentPosition ? !!(o.compareDocumentPosition(i) & 16) : !1 : !1;
  }
  function jv(o) {
    o = o != null && o.ownerDocument != null && o.ownerDocument.defaultView != null ? o.ownerDocument.defaultView : window;
    for (var i = Di(o.document); i instanceof o.HTMLIFrameElement; ) {
      try {
        var u = typeof i.contentWindow.location.href == "string";
      } catch {
        u = !1;
      }
      if (u) o = i.contentWindow;
      else break;
      i = Di(o.document);
    }
    return i;
  }
  function bf(o) {
    var i = o && o.nodeName && o.nodeName.toLowerCase();
    return i && (i === "input" && (o.type === "text" || o.type === "search" || o.type === "tel" || o.type === "url" || o.type === "password") || i === "textarea" || o.contentEditable === "true");
  }
  var BO = Fr && "documentMode" in document && 11 >= document.documentMode, Ha = null, wf = null, ls = null, xf = !1;
  function Pv(o, i, u) {
    var p = u.window === u ? u.document : u.nodeType === 9 ? u : u.ownerDocument;
    xf || Ha == null || Ha !== Di(p) || (p = Ha, "selectionStart" in p && bf(p) ? p = { start: p.selectionStart, end: p.selectionEnd } : (p = (p.ownerDocument && p.ownerDocument.defaultView || window).getSelection(), p = {
      anchorNode: p.anchorNode,
      anchorOffset: p.anchorOffset,
      focusNode: p.focusNode,
      focusOffset: p.focusOffset
    }), ls && ss(ls, p) || (ls = p, p = ec(wf, "onSelect"), 0 < p.length && (i = new cu(
      "onSelect",
      "select",
      null,
      i,
      u
    ), o.push({ event: i, listeners: p }), i.target = Ha)));
  }
  function sa(o, i) {
    var u = {};
    return u[o.toLowerCase()] = i.toLowerCase(), u["Webkit" + o] = "webkit" + i, u["Moz" + o] = "moz" + i, u;
  }
  var Wa = {
    animationend: sa("Animation", "AnimationEnd"),
    animationiteration: sa("Animation", "AnimationIteration"),
    animationstart: sa("Animation", "AnimationStart"),
    transitionrun: sa("Transition", "TransitionRun"),
    transitionstart: sa("Transition", "TransitionStart"),
    transitioncancel: sa("Transition", "TransitionCancel"),
    transitionend: sa("Transition", "TransitionEnd")
  }, Sf = {}, Dv = {};
  Fr && (Dv = document.createElement("div").style, "AnimationEvent" in window || (delete Wa.animationend.animation, delete Wa.animationiteration.animation, delete Wa.animationstart.animation), "TransitionEvent" in window || delete Wa.transitionend.transition);
  function la(o) {
    if (Sf[o]) return Sf[o];
    if (!Wa[o]) return o;
    var i = Wa[o], u;
    for (u in i)
      if (i.hasOwnProperty(u) && u in Dv)
        return Sf[o] = i[u];
    return o;
  }
  var Iv = la("animationend"), $v = la("animationiteration"), zv = la("animationstart"), UO = la("transitionrun"), VO = la("transitionstart"), HO = la("transitioncancel"), Tv = la("transitionend"), Lv = /* @__PURE__ */ new Map(), kf = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  kf.push("scrollEnd");
  function yr(o, i) {
    Lv.set(o, i), lo(i, [o]);
  }
  var pu = typeof reportError == "function" ? reportError : function(o) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var i = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof o == "object" && o !== null && typeof o.message == "string" ? String(o.message) : String(o),
        error: o
      });
      if (!window.dispatchEvent(i)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", o);
      return;
    }
    console.error(o);
  }, tr = [], qa = 0, _f = 0;
  function mu() {
    for (var o = qa, i = _f = qa = 0; i < o; ) {
      var u = tr[i];
      tr[i++] = null;
      var p = tr[i];
      tr[i++] = null;
      var y = tr[i];
      tr[i++] = null;
      var S = tr[i];
      if (tr[i++] = null, p !== null && y !== null) {
        var j = p.pending;
        j === null ? y.next = y : (y.next = j.next, j.next = y), p.pending = y;
      }
      S !== 0 && Fv(u, y, S);
    }
  }
  function hu(o, i, u, p) {
    tr[qa++] = o, tr[qa++] = i, tr[qa++] = u, tr[qa++] = p, _f |= p, o.lanes |= p, o = o.alternate, o !== null && (o.lanes |= p);
  }
  function Ef(o, i, u, p) {
    return hu(o, i, u, p), gu(o);
  }
  function ua(o, i) {
    return hu(o, null, null, i), gu(o);
  }
  function Fv(o, i, u) {
    o.lanes |= u;
    var p = o.alternate;
    p !== null && (p.lanes |= u);
    for (var y = !1, S = o.return; S !== null; )
      S.childLanes |= u, p = S.alternate, p !== null && (p.childLanes |= u), S.tag === 22 && (o = S.stateNode, o === null || o._visibility & 1 || (y = !0)), o = S, S = S.return;
    return o.tag === 3 ? (S = o.stateNode, y && i !== null && (y = 31 - Ae(u), o = S.hiddenUpdates, p = o[y], p === null ? o[y] = [i] : p.push(i), i.lane = u | 536870912), S) : null;
  }
  function gu(o) {
    if (50 < As)
      throw As = 0, Dp = null, Error(r(185));
    for (var i = o.return; i !== null; )
      o = i, i = o.return;
    return o.tag === 3 ? o.stateNode : null;
  }
  var Ga = {};
  function WO(o, i, u, p) {
    this.tag = o, this.key = u, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = i, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = p, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Un(o, i, u, p) {
    return new WO(o, i, u, p);
  }
  function Cf(o) {
    return o = o.prototype, !(!o || !o.isReactComponent);
  }
  function Br(o, i) {
    var u = o.alternate;
    return u === null ? (u = Un(
      o.tag,
      i,
      o.key,
      o.mode
    ), u.elementType = o.elementType, u.type = o.type, u.stateNode = o.stateNode, u.alternate = o, o.alternate = u) : (u.pendingProps = i, u.type = o.type, u.flags = 0, u.subtreeFlags = 0, u.deletions = null), u.flags = o.flags & 65011712, u.childLanes = o.childLanes, u.lanes = o.lanes, u.child = o.child, u.memoizedProps = o.memoizedProps, u.memoizedState = o.memoizedState, u.updateQueue = o.updateQueue, i = o.dependencies, u.dependencies = i === null ? null : { lanes: i.lanes, firstContext: i.firstContext }, u.sibling = o.sibling, u.index = o.index, u.ref = o.ref, u.refCleanup = o.refCleanup, u;
  }
  function Bv(o, i) {
    o.flags &= 65011714;
    var u = o.alternate;
    return u === null ? (o.childLanes = 0, o.lanes = i, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = u.childLanes, o.lanes = u.lanes, o.child = u.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = u.memoizedProps, o.memoizedState = u.memoizedState, o.updateQueue = u.updateQueue, o.type = u.type, i = u.dependencies, o.dependencies = i === null ? null : {
      lanes: i.lanes,
      firstContext: i.firstContext
    }), o;
  }
  function vu(o, i, u, p, y, S) {
    var j = 0;
    if (p = o, typeof o == "function") Cf(o) && (j = 1);
    else if (typeof o == "string")
      j = XM(
        o,
        u,
        W.current
      ) ? 26 : o === "html" || o === "head" || o === "body" ? 27 : 5;
    else
      e: switch (o) {
        case I:
          return o = Un(31, u, i, y), o.elementType = I, o.lanes = S, o;
        case x:
          return ca(u.children, y, S, i);
        case w:
          j = 8, y |= 24;
          break;
        case k:
          return o = Un(12, u, i, y | 2), o.elementType = k, o.lanes = S, o;
        case N:
          return o = Un(13, u, i, y), o.elementType = N, o.lanes = S, o;
        case A:
          return o = Un(19, u, i, y), o.elementType = A, o.lanes = S, o;
        default:
          if (typeof o == "object" && o !== null)
            switch (o.$$typeof) {
              case _:
                j = 10;
                break e;
              case E:
                j = 9;
                break e;
              case O:
                j = 11;
                break e;
              case R:
                j = 14;
                break e;
              case D:
                j = 16, p = null;
                break e;
            }
          j = 29, u = Error(
            r(130, o === null ? "null" : typeof o, "")
          ), p = null;
      }
    return i = Un(j, u, i, y), i.elementType = o, i.type = p, i.lanes = S, i;
  }
  function ca(o, i, u, p) {
    return o = Un(7, o, p, i), o.lanes = u, o;
  }
  function Of(o, i, u) {
    return o = Un(6, o, null, i), o.lanes = u, o;
  }
  function Uv(o) {
    var i = Un(18, null, null, 0);
    return i.stateNode = o, i;
  }
  function Mf(o, i, u) {
    return i = Un(
      4,
      o.children !== null ? o.children : [],
      o.key,
      i
    ), i.lanes = u, i.stateNode = {
      containerInfo: o.containerInfo,
      pendingChildren: null,
      implementation: o.implementation
    }, i;
  }
  var Vv = /* @__PURE__ */ new WeakMap();
  function nr(o, i) {
    if (typeof o == "object" && o !== null) {
      var u = Vv.get(o);
      return u !== void 0 ? u : (i = {
        value: o,
        source: i,
        stack: Xe(i)
      }, Vv.set(o, i), i);
    }
    return {
      value: o,
      source: i,
      stack: Xe(i)
    };
  }
  var Ka = [], Ya = 0, yu = null, us = 0, rr = [], or = 0, co = null, Cr = 1, Or = "";
  function Ur(o, i) {
    Ka[Ya++] = us, Ka[Ya++] = yu, yu = o, us = i;
  }
  function Hv(o, i, u) {
    rr[or++] = Cr, rr[or++] = Or, rr[or++] = co, co = o;
    var p = Cr;
    o = Or;
    var y = 32 - Ae(p) - 1;
    p &= ~(1 << y), u += 1;
    var S = 32 - Ae(i) + y;
    if (30 < S) {
      var j = y - y % 5;
      S = (p & (1 << j) - 1).toString(32), p >>= j, y -= j, Cr = 1 << 32 - Ae(i) + y | u << y | p, Or = S + o;
    } else
      Cr = 1 << S | u << y | p, Or = o;
  }
  function Nf(o) {
    o.return !== null && (Ur(o, 1), Hv(o, 1, 0));
  }
  function Af(o) {
    for (; o === yu; )
      yu = Ka[--Ya], Ka[Ya] = null, us = Ka[--Ya], Ka[Ya] = null;
    for (; o === co; )
      co = rr[--or], rr[or] = null, Or = rr[--or], rr[or] = null, Cr = rr[--or], rr[or] = null;
  }
  function Wv(o, i) {
    rr[or++] = Cr, rr[or++] = Or, rr[or++] = co, Cr = i.id, Or = i.overflow, co = o;
  }
  var on = null, yt = null, Ke = !1, fo = null, ar = !1, Rf = Error(r(519));
  function po(o) {
    var i = Error(
      r(
        418,
        1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML",
        ""
      )
    );
    throw cs(nr(i, o)), Rf;
  }
  function qv(o) {
    var i = o.stateNode, u = o.type, p = o.memoizedProps;
    switch (i[en] = o, i[yn] = p, u) {
      case "dialog":
        Ue("cancel", i), Ue("close", i);
        break;
      case "iframe":
      case "object":
      case "embed":
        Ue("load", i);
        break;
      case "video":
      case "audio":
        for (u = 0; u < js.length; u++)
          Ue(js[u], i);
        break;
      case "source":
        Ue("error", i);
        break;
      case "img":
      case "image":
      case "link":
        Ue("error", i), Ue("load", i);
        break;
      case "details":
        Ue("toggle", i);
        break;
      case "input":
        Ue("invalid", i), of(
          i,
          p.value,
          p.defaultValue,
          p.checked,
          p.defaultChecked,
          p.type,
          p.name,
          !0
        );
        break;
      case "select":
        Ue("invalid", i);
        break;
      case "textarea":
        Ue("invalid", i), sv(i, p.value, p.defaultValue, p.children);
    }
    u = p.children, typeof u != "string" && typeof u != "number" && typeof u != "bigint" || i.textContent === "" + u || p.suppressHydrationWarning === !0 || uw(i.textContent, u) ? (p.popover != null && (Ue("beforetoggle", i), Ue("toggle", i)), p.onScroll != null && Ue("scroll", i), p.onScrollEnd != null && Ue("scrollend", i), p.onClick != null && (i.onclick = Lr), i = !0) : i = !1, i || po(o, !0);
  }
  function Gv(o) {
    for (on = o.return; on; )
      switch (on.tag) {
        case 5:
        case 31:
        case 13:
          ar = !1;
          return;
        case 27:
        case 3:
          ar = !0;
          return;
        default:
          on = on.return;
      }
  }
  function Xa(o) {
    if (o !== on) return !1;
    if (!Ke) return Gv(o), Ke = !0, !1;
    var i = o.tag, u;
    if ((u = i !== 3 && i !== 27) && ((u = i === 5) && (u = o.type, u = !(u !== "form" && u !== "button") || Yp(o.type, o.memoizedProps)), u = !u), u && yt && po(o), Gv(o), i === 13) {
      if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(r(317));
      yt = yw(o);
    } else if (i === 31) {
      if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(r(317));
      yt = yw(o);
    } else
      i === 27 ? (i = yt, Oo(o.type) ? (o = em, em = null, yt = o) : yt = i) : yt = on ? ir(o.stateNode.nextSibling) : null;
    return !0;
  }
  function da() {
    yt = on = null, Ke = !1;
  }
  function jf() {
    var o = fo;
    return o !== null && (jn === null ? jn = o : jn.push.apply(
      jn,
      o
    ), fo = null), o;
  }
  function cs(o) {
    fo === null ? fo = [o] : fo.push(o);
  }
  var Pf = F(null), fa = null, Vr = null;
  function mo(o, i, u) {
    U(Pf, i._currentValue), i._currentValue = u;
  }
  function Hr(o) {
    o._currentValue = Pf.current, Y(Pf);
  }
  function Df(o, i, u) {
    for (; o !== null; ) {
      var p = o.alternate;
      if ((o.childLanes & i) !== i ? (o.childLanes |= i, p !== null && (p.childLanes |= i)) : p !== null && (p.childLanes & i) !== i && (p.childLanes |= i), o === u) break;
      o = o.return;
    }
  }
  function If(o, i, u, p) {
    var y = o.child;
    for (y !== null && (y.return = o); y !== null; ) {
      var S = y.dependencies;
      if (S !== null) {
        var j = y.child;
        S = S.firstContext;
        e: for (; S !== null; ) {
          var T = S;
          S = y;
          for (var X = 0; X < i.length; X++)
            if (T.context === i[X]) {
              S.lanes |= u, T = S.alternate, T !== null && (T.lanes |= u), Df(
                S.return,
                u,
                o
              ), p || (j = null);
              break e;
            }
          S = T.next;
        }
      } else if (y.tag === 18) {
        if (j = y.return, j === null) throw Error(r(341));
        j.lanes |= u, S = j.alternate, S !== null && (S.lanes |= u), Df(j, u, o), j = null;
      } else j = y.child;
      if (j !== null) j.return = y;
      else
        for (j = y; j !== null; ) {
          if (j === o) {
            j = null;
            break;
          }
          if (y = j.sibling, y !== null) {
            y.return = j.return, j = y;
            break;
          }
          j = j.return;
        }
      y = j;
    }
  }
  function Ja(o, i, u, p) {
    o = null;
    for (var y = i, S = !1; y !== null; ) {
      if (!S) {
        if ((y.flags & 524288) !== 0) S = !0;
        else if ((y.flags & 262144) !== 0) break;
      }
      if (y.tag === 10) {
        var j = y.alternate;
        if (j === null) throw Error(r(387));
        if (j = j.memoizedProps, j !== null) {
          var T = y.type;
          Bn(y.pendingProps.value, j.value) || (o !== null ? o.push(T) : o = [T]);
        }
      } else if (y === fe.current) {
        if (j = y.alternate, j === null) throw Error(r(387));
        j.memoizedState.memoizedState !== y.memoizedState.memoizedState && (o !== null ? o.push(zs) : o = [zs]);
      }
      y = y.return;
    }
    o !== null && If(
      i,
      o,
      u,
      p
    ), i.flags |= 262144;
  }
  function bu(o) {
    for (o = o.firstContext; o !== null; ) {
      if (!Bn(
        o.context._currentValue,
        o.memoizedValue
      ))
        return !0;
      o = o.next;
    }
    return !1;
  }
  function pa(o) {
    fa = o, Vr = null, o = o.dependencies, o !== null && (o.firstContext = null);
  }
  function an(o) {
    return Kv(fa, o);
  }
  function wu(o, i) {
    return fa === null && pa(o), Kv(o, i);
  }
  function Kv(o, i) {
    var u = i._currentValue;
    if (i = { context: i, memoizedValue: u, next: null }, Vr === null) {
      if (o === null) throw Error(r(308));
      Vr = i, o.dependencies = { lanes: 0, firstContext: i }, o.flags |= 524288;
    } else Vr = Vr.next = i;
    return u;
  }
  var qO = typeof AbortController < "u" ? AbortController : function() {
    var o = [], i = this.signal = {
      aborted: !1,
      addEventListener: function(u, p) {
        o.push(p);
      }
    };
    this.abort = function() {
      i.aborted = !0, o.forEach(function(u) {
        return u();
      });
    };
  }, GO = e.unstable_scheduleCallback, KO = e.unstable_NormalPriority, It = {
    $$typeof: _,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function $f() {
    return {
      controller: new qO(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function ds(o) {
    o.refCount--, o.refCount === 0 && GO(KO, function() {
      o.controller.abort();
    });
  }
  var fs = null, zf = 0, Qa = 0, Za = null;
  function YO(o, i) {
    if (fs === null) {
      var u = fs = [];
      zf = 0, Qa = Fp(), Za = {
        status: "pending",
        value: void 0,
        then: function(p) {
          u.push(p);
        }
      };
    }
    return zf++, i.then(Yv, Yv), i;
  }
  function Yv() {
    if (--zf === 0 && fs !== null) {
      Za !== null && (Za.status = "fulfilled");
      var o = fs;
      fs = null, Qa = 0, Za = null;
      for (var i = 0; i < o.length; i++) (0, o[i])();
    }
  }
  function XO(o, i) {
    var u = [], p = {
      status: "pending",
      value: null,
      reason: null,
      then: function(y) {
        u.push(y);
      }
    };
    return o.then(
      function() {
        p.status = "fulfilled", p.value = i;
        for (var y = 0; y < u.length; y++) (0, u[y])(i);
      },
      function(y) {
        for (p.status = "rejected", p.reason = y, y = 0; y < u.length; y++)
          (0, u[y])(void 0);
      }
    ), p;
  }
  var Xv = $.S;
  $.S = function(o, i) {
    Pb = Ce(), typeof i == "object" && i !== null && typeof i.then == "function" && YO(o, i), Xv !== null && Xv(o, i);
  };
  var ma = F(null);
  function Tf() {
    var o = ma.current;
    return o !== null ? o : ut.pooledCache;
  }
  function xu(o, i) {
    i === null ? U(ma, ma.current) : U(ma, i.pool);
  }
  function Jv() {
    var o = Tf();
    return o === null ? null : { parent: It._currentValue, pool: o };
  }
  var ei = Error(r(460)), Lf = Error(r(474)), Su = Error(r(542)), ku = { then: function() {
  } };
  function Qv(o) {
    return o = o.status, o === "fulfilled" || o === "rejected";
  }
  function Zv(o, i, u) {
    switch (u = o[u], u === void 0 ? o.push(i) : u !== i && (i.then(Lr, Lr), i = u), i.status) {
      case "fulfilled":
        return i.value;
      case "rejected":
        throw o = i.reason, ty(o), o;
      default:
        if (typeof i.status == "string") i.then(Lr, Lr);
        else {
          if (o = ut, o !== null && 100 < o.shellSuspendCounter)
            throw Error(r(482));
          o = i, o.status = "pending", o.then(
            function(p) {
              if (i.status === "pending") {
                var y = i;
                y.status = "fulfilled", y.value = p;
              }
            },
            function(p) {
              if (i.status === "pending") {
                var y = i;
                y.status = "rejected", y.reason = p;
              }
            }
          );
        }
        switch (i.status) {
          case "fulfilled":
            return i.value;
          case "rejected":
            throw o = i.reason, ty(o), o;
        }
        throw ga = i, ei;
    }
  }
  function ha(o) {
    try {
      var i = o._init;
      return i(o._payload);
    } catch (u) {
      throw u !== null && typeof u == "object" && typeof u.then == "function" ? (ga = u, ei) : u;
    }
  }
  var ga = null;
  function ey() {
    if (ga === null) throw Error(r(459));
    var o = ga;
    return ga = null, o;
  }
  function ty(o) {
    if (o === ei || o === Su)
      throw Error(r(483));
  }
  var ti = null, ps = 0;
  function _u(o) {
    var i = ps;
    return ps += 1, ti === null && (ti = []), Zv(ti, o, i);
  }
  function ms(o, i) {
    i = i.props.ref, o.ref = i !== void 0 ? i : null;
  }
  function Eu(o, i) {
    throw i.$$typeof === v ? Error(r(525)) : (o = Object.prototype.toString.call(i), Error(
      r(
        31,
        o === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : o
      )
    ));
  }
  function ny(o) {
    function i(ee, Q) {
      if (o) {
        var te = ee.deletions;
        te === null ? (ee.deletions = [Q], ee.flags |= 16) : te.push(Q);
      }
    }
    function u(ee, Q) {
      if (!o) return null;
      for (; Q !== null; )
        i(ee, Q), Q = Q.sibling;
      return null;
    }
    function p(ee) {
      for (var Q = /* @__PURE__ */ new Map(); ee !== null; )
        ee.key !== null ? Q.set(ee.key, ee) : Q.set(ee.index, ee), ee = ee.sibling;
      return Q;
    }
    function y(ee, Q) {
      return ee = Br(ee, Q), ee.index = 0, ee.sibling = null, ee;
    }
    function S(ee, Q, te) {
      return ee.index = te, o ? (te = ee.alternate, te !== null ? (te = te.index, te < Q ? (ee.flags |= 67108866, Q) : te) : (ee.flags |= 67108866, Q)) : (ee.flags |= 1048576, Q);
    }
    function j(ee) {
      return o && ee.alternate === null && (ee.flags |= 67108866), ee;
    }
    function T(ee, Q, te, de) {
      return Q === null || Q.tag !== 6 ? (Q = Of(te, ee.mode, de), Q.return = ee, Q) : (Q = y(Q, te), Q.return = ee, Q);
    }
    function X(ee, Q, te, de) {
      var Oe = te.type;
      return Oe === x ? ue(
        ee,
        Q,
        te.props.children,
        de,
        te.key
      ) : Q !== null && (Q.elementType === Oe || typeof Oe == "object" && Oe !== null && Oe.$$typeof === D && ha(Oe) === Q.type) ? (Q = y(Q, te.props), ms(Q, te), Q.return = ee, Q) : (Q = vu(
        te.type,
        te.key,
        te.props,
        null,
        ee.mode,
        de
      ), ms(Q, te), Q.return = ee, Q);
    }
    function ne(ee, Q, te, de) {
      return Q === null || Q.tag !== 4 || Q.stateNode.containerInfo !== te.containerInfo || Q.stateNode.implementation !== te.implementation ? (Q = Mf(te, ee.mode, de), Q.return = ee, Q) : (Q = y(Q, te.children || []), Q.return = ee, Q);
    }
    function ue(ee, Q, te, de, Oe) {
      return Q === null || Q.tag !== 7 ? (Q = ca(
        te,
        ee.mode,
        de,
        Oe
      ), Q.return = ee, Q) : (Q = y(Q, te), Q.return = ee, Q);
    }
    function pe(ee, Q, te) {
      if (typeof Q == "string" && Q !== "" || typeof Q == "number" || typeof Q == "bigint")
        return Q = Of(
          "" + Q,
          ee.mode,
          te
        ), Q.return = ee, Q;
      if (typeof Q == "object" && Q !== null) {
        switch (Q.$$typeof) {
          case g:
            return te = vu(
              Q.type,
              Q.key,
              Q.props,
              null,
              ee.mode,
              te
            ), ms(te, Q), te.return = ee, te;
          case b:
            return Q = Mf(
              Q,
              ee.mode,
              te
            ), Q.return = ee, Q;
          case D:
            return Q = ha(Q), pe(ee, Q, te);
        }
        if (G(Q) || P(Q))
          return Q = ca(
            Q,
            ee.mode,
            te,
            null
          ), Q.return = ee, Q;
        if (typeof Q.then == "function")
          return pe(ee, _u(Q), te);
        if (Q.$$typeof === _)
          return pe(
            ee,
            wu(ee, Q),
            te
          );
        Eu(ee, Q);
      }
      return null;
    }
    function ae(ee, Q, te, de) {
      var Oe = Q !== null ? Q.key : null;
      if (typeof te == "string" && te !== "" || typeof te == "number" || typeof te == "bigint")
        return Oe !== null ? null : T(ee, Q, "" + te, de);
      if (typeof te == "object" && te !== null) {
        switch (te.$$typeof) {
          case g:
            return te.key === Oe ? X(ee, Q, te, de) : null;
          case b:
            return te.key === Oe ? ne(ee, Q, te, de) : null;
          case D:
            return te = ha(te), ae(ee, Q, te, de);
        }
        if (G(te) || P(te))
          return Oe !== null ? null : ue(ee, Q, te, de, null);
        if (typeof te.then == "function")
          return ae(
            ee,
            Q,
            _u(te),
            de
          );
        if (te.$$typeof === _)
          return ae(
            ee,
            Q,
            wu(ee, te),
            de
          );
        Eu(ee, te);
      }
      return null;
    }
    function se(ee, Q, te, de, Oe) {
      if (typeof de == "string" && de !== "" || typeof de == "number" || typeof de == "bigint")
        return ee = ee.get(te) || null, T(Q, ee, "" + de, Oe);
      if (typeof de == "object" && de !== null) {
        switch (de.$$typeof) {
          case g:
            return ee = ee.get(
              de.key === null ? te : de.key
            ) || null, X(Q, ee, de, Oe);
          case b:
            return ee = ee.get(
              de.key === null ? te : de.key
            ) || null, ne(Q, ee, de, Oe);
          case D:
            return de = ha(de), se(
              ee,
              Q,
              te,
              de,
              Oe
            );
        }
        if (G(de) || P(de))
          return ee = ee.get(te) || null, ue(Q, ee, de, Oe, null);
        if (typeof de.then == "function")
          return se(
            ee,
            Q,
            te,
            _u(de),
            Oe
          );
        if (de.$$typeof === _)
          return se(
            ee,
            Q,
            te,
            wu(Q, de),
            Oe
          );
        Eu(Q, de);
      }
      return null;
    }
    function we(ee, Q, te, de) {
      for (var Oe = null, Je = null, ke = Q, Le = Q = 0, We = null; ke !== null && Le < te.length; Le++) {
        ke.index > Le ? (We = ke, ke = null) : We = ke.sibling;
        var Qe = ae(
          ee,
          ke,
          te[Le],
          de
        );
        if (Qe === null) {
          ke === null && (ke = We);
          break;
        }
        o && ke && Qe.alternate === null && i(ee, ke), Q = S(Qe, Q, Le), Je === null ? Oe = Qe : Je.sibling = Qe, Je = Qe, ke = We;
      }
      if (Le === te.length)
        return u(ee, ke), Ke && Ur(ee, Le), Oe;
      if (ke === null) {
        for (; Le < te.length; Le++)
          ke = pe(ee, te[Le], de), ke !== null && (Q = S(
            ke,
            Q,
            Le
          ), Je === null ? Oe = ke : Je.sibling = ke, Je = ke);
        return Ke && Ur(ee, Le), Oe;
      }
      for (ke = p(ke); Le < te.length; Le++)
        We = se(
          ke,
          ee,
          Le,
          te[Le],
          de
        ), We !== null && (o && We.alternate !== null && ke.delete(
          We.key === null ? Le : We.key
        ), Q = S(
          We,
          Q,
          Le
        ), Je === null ? Oe = We : Je.sibling = We, Je = We);
      return o && ke.forEach(function(jo) {
        return i(ee, jo);
      }), Ke && Ur(ee, Le), Oe;
    }
    function Ne(ee, Q, te, de) {
      if (te == null) throw Error(r(151));
      for (var Oe = null, Je = null, ke = Q, Le = Q = 0, We = null, Qe = te.next(); ke !== null && !Qe.done; Le++, Qe = te.next()) {
        ke.index > Le ? (We = ke, ke = null) : We = ke.sibling;
        var jo = ae(ee, ke, Qe.value, de);
        if (jo === null) {
          ke === null && (ke = We);
          break;
        }
        o && ke && jo.alternate === null && i(ee, ke), Q = S(jo, Q, Le), Je === null ? Oe = jo : Je.sibling = jo, Je = jo, ke = We;
      }
      if (Qe.done)
        return u(ee, ke), Ke && Ur(ee, Le), Oe;
      if (ke === null) {
        for (; !Qe.done; Le++, Qe = te.next())
          Qe = pe(ee, Qe.value, de), Qe !== null && (Q = S(Qe, Q, Le), Je === null ? Oe = Qe : Je.sibling = Qe, Je = Qe);
        return Ke && Ur(ee, Le), Oe;
      }
      for (ke = p(ke); !Qe.done; Le++, Qe = te.next())
        Qe = se(ke, ee, Le, Qe.value, de), Qe !== null && (o && Qe.alternate !== null && ke.delete(Qe.key === null ? Le : Qe.key), Q = S(Qe, Q, Le), Je === null ? Oe = Qe : Je.sibling = Qe, Je = Qe);
      return o && ke.forEach(function(sN) {
        return i(ee, sN);
      }), Ke && Ur(ee, Le), Oe;
    }
    function st(ee, Q, te, de) {
      if (typeof te == "object" && te !== null && te.type === x && te.key === null && (te = te.props.children), typeof te == "object" && te !== null) {
        switch (te.$$typeof) {
          case g:
            e: {
              for (var Oe = te.key; Q !== null; ) {
                if (Q.key === Oe) {
                  if (Oe = te.type, Oe === x) {
                    if (Q.tag === 7) {
                      u(
                        ee,
                        Q.sibling
                      ), de = y(
                        Q,
                        te.props.children
                      ), de.return = ee, ee = de;
                      break e;
                    }
                  } else if (Q.elementType === Oe || typeof Oe == "object" && Oe !== null && Oe.$$typeof === D && ha(Oe) === Q.type) {
                    u(
                      ee,
                      Q.sibling
                    ), de = y(Q, te.props), ms(de, te), de.return = ee, ee = de;
                    break e;
                  }
                  u(ee, Q);
                  break;
                } else i(ee, Q);
                Q = Q.sibling;
              }
              te.type === x ? (de = ca(
                te.props.children,
                ee.mode,
                de,
                te.key
              ), de.return = ee, ee = de) : (de = vu(
                te.type,
                te.key,
                te.props,
                null,
                ee.mode,
                de
              ), ms(de, te), de.return = ee, ee = de);
            }
            return j(ee);
          case b:
            e: {
              for (Oe = te.key; Q !== null; ) {
                if (Q.key === Oe)
                  if (Q.tag === 4 && Q.stateNode.containerInfo === te.containerInfo && Q.stateNode.implementation === te.implementation) {
                    u(
                      ee,
                      Q.sibling
                    ), de = y(Q, te.children || []), de.return = ee, ee = de;
                    break e;
                  } else {
                    u(ee, Q);
                    break;
                  }
                else i(ee, Q);
                Q = Q.sibling;
              }
              de = Mf(te, ee.mode, de), de.return = ee, ee = de;
            }
            return j(ee);
          case D:
            return te = ha(te), st(
              ee,
              Q,
              te,
              de
            );
        }
        if (G(te))
          return we(
            ee,
            Q,
            te,
            de
          );
        if (P(te)) {
          if (Oe = P(te), typeof Oe != "function") throw Error(r(150));
          return te = Oe.call(te), Ne(
            ee,
            Q,
            te,
            de
          );
        }
        if (typeof te.then == "function")
          return st(
            ee,
            Q,
            _u(te),
            de
          );
        if (te.$$typeof === _)
          return st(
            ee,
            Q,
            wu(ee, te),
            de
          );
        Eu(ee, te);
      }
      return typeof te == "string" && te !== "" || typeof te == "number" || typeof te == "bigint" ? (te = "" + te, Q !== null && Q.tag === 6 ? (u(ee, Q.sibling), de = y(Q, te), de.return = ee, ee = de) : (u(ee, Q), de = Of(te, ee.mode, de), de.return = ee, ee = de), j(ee)) : u(ee, Q);
    }
    return function(ee, Q, te, de) {
      try {
        ps = 0;
        var Oe = st(
          ee,
          Q,
          te,
          de
        );
        return ti = null, Oe;
      } catch (ke) {
        if (ke === ei || ke === Su) throw ke;
        var Je = Un(29, ke, null, ee.mode);
        return Je.lanes = de, Je.return = ee, Je;
      }
    };
  }
  var va = ny(!0), ry = ny(!1), ho = !1;
  function Ff(o) {
    o.updateQueue = {
      baseState: o.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function Bf(o, i) {
    o = o.updateQueue, i.updateQueue === o && (i.updateQueue = {
      baseState: o.baseState,
      firstBaseUpdate: o.firstBaseUpdate,
      lastBaseUpdate: o.lastBaseUpdate,
      shared: o.shared,
      callbacks: null
    });
  }
  function go(o) {
    return { lane: o, tag: 0, payload: null, callback: null, next: null };
  }
  function vo(o, i, u) {
    var p = o.updateQueue;
    if (p === null) return null;
    if (p = p.shared, (Ze & 2) !== 0) {
      var y = p.pending;
      return y === null ? i.next = i : (i.next = y.next, y.next = i), p.pending = i, i = gu(o), Fv(o, null, u), i;
    }
    return hu(o, p, i, u), gu(o);
  }
  function hs(o, i, u) {
    if (i = i.updateQueue, i !== null && (i = i.shared, (u & 4194048) !== 0)) {
      var p = i.lanes;
      p &= o.pendingLanes, u |= p, i.lanes = u, Kd(o, u);
    }
  }
  function Uf(o, i) {
    var u = o.updateQueue, p = o.alternate;
    if (p !== null && (p = p.updateQueue, u === p)) {
      var y = null, S = null;
      if (u = u.firstBaseUpdate, u !== null) {
        do {
          var j = {
            lane: u.lane,
            tag: u.tag,
            payload: u.payload,
            callback: null,
            next: null
          };
          S === null ? y = S = j : S = S.next = j, u = u.next;
        } while (u !== null);
        S === null ? y = S = i : S = S.next = i;
      } else y = S = i;
      u = {
        baseState: p.baseState,
        firstBaseUpdate: y,
        lastBaseUpdate: S,
        shared: p.shared,
        callbacks: p.callbacks
      }, o.updateQueue = u;
      return;
    }
    o = u.lastBaseUpdate, o === null ? u.firstBaseUpdate = i : o.next = i, u.lastBaseUpdate = i;
  }
  var Vf = !1;
  function gs() {
    if (Vf) {
      var o = Za;
      if (o !== null) throw o;
    }
  }
  function vs(o, i, u, p) {
    Vf = !1;
    var y = o.updateQueue;
    ho = !1;
    var S = y.firstBaseUpdate, j = y.lastBaseUpdate, T = y.shared.pending;
    if (T !== null) {
      y.shared.pending = null;
      var X = T, ne = X.next;
      X.next = null, j === null ? S = ne : j.next = ne, j = X;
      var ue = o.alternate;
      ue !== null && (ue = ue.updateQueue, T = ue.lastBaseUpdate, T !== j && (T === null ? ue.firstBaseUpdate = ne : T.next = ne, ue.lastBaseUpdate = X));
    }
    if (S !== null) {
      var pe = y.baseState;
      j = 0, ue = ne = X = null, T = S;
      do {
        var ae = T.lane & -536870913, se = ae !== T.lane;
        if (se ? (He & ae) === ae : (p & ae) === ae) {
          ae !== 0 && ae === Qa && (Vf = !0), ue !== null && (ue = ue.next = {
            lane: 0,
            tag: T.tag,
            payload: T.payload,
            callback: null,
            next: null
          });
          e: {
            var we = o, Ne = T;
            ae = i;
            var st = u;
            switch (Ne.tag) {
              case 1:
                if (we = Ne.payload, typeof we == "function") {
                  pe = we.call(st, pe, ae);
                  break e;
                }
                pe = we;
                break e;
              case 3:
                we.flags = we.flags & -65537 | 128;
              case 0:
                if (we = Ne.payload, ae = typeof we == "function" ? we.call(st, pe, ae) : we, ae == null) break e;
                pe = h({}, pe, ae);
                break e;
              case 2:
                ho = !0;
            }
          }
          ae = T.callback, ae !== null && (o.flags |= 64, se && (o.flags |= 8192), se = y.callbacks, se === null ? y.callbacks = [ae] : se.push(ae));
        } else
          se = {
            lane: ae,
            tag: T.tag,
            payload: T.payload,
            callback: T.callback,
            next: null
          }, ue === null ? (ne = ue = se, X = pe) : ue = ue.next = se, j |= ae;
        if (T = T.next, T === null) {
          if (T = y.shared.pending, T === null)
            break;
          se = T, T = se.next, se.next = null, y.lastBaseUpdate = se, y.shared.pending = null;
        }
      } while (!0);
      ue === null && (X = pe), y.baseState = X, y.firstBaseUpdate = ne, y.lastBaseUpdate = ue, S === null && (y.shared.lanes = 0), So |= j, o.lanes = j, o.memoizedState = pe;
    }
  }
  function oy(o, i) {
    if (typeof o != "function")
      throw Error(r(191, o));
    o.call(i);
  }
  function ay(o, i) {
    var u = o.callbacks;
    if (u !== null)
      for (o.callbacks = null, o = 0; o < u.length; o++)
        oy(u[o], i);
  }
  var ni = F(null), Cu = F(0);
  function iy(o, i) {
    o = Zr, U(Cu, o), U(ni, i), Zr = o | i.baseLanes;
  }
  function Hf() {
    U(Cu, Zr), U(ni, ni.current);
  }
  function Wf() {
    Zr = Cu.current, Y(ni), Y(Cu);
  }
  var Vn = F(null), fr = null;
  function yo(o) {
    var i = o.alternate;
    U(At, At.current & 1), U(Vn, o), fr === null && (i === null || ni.current !== null || i.memoizedState !== null) && (fr = o);
  }
  function qf(o) {
    U(At, At.current), U(Vn, o), fr === null && (fr = o);
  }
  function sy(o) {
    o.tag === 22 ? (U(At, At.current), U(Vn, o), fr === null && (fr = o)) : bo();
  }
  function bo() {
    U(At, At.current), U(Vn, Vn.current);
  }
  function Hn(o) {
    Y(Vn), fr === o && (fr = null), Y(At);
  }
  var At = F(0);
  function Ou(o) {
    for (var i = o; i !== null; ) {
      if (i.tag === 13) {
        var u = i.memoizedState;
        if (u !== null && (u = u.dehydrated, u === null || Qp(u) || Zp(u)))
          return i;
      } else if (i.tag === 19 && (i.memoizedProps.revealOrder === "forwards" || i.memoizedProps.revealOrder === "backwards" || i.memoizedProps.revealOrder === "unstable_legacy-backwards" || i.memoizedProps.revealOrder === "together")) {
        if ((i.flags & 128) !== 0) return i;
      } else if (i.child !== null) {
        i.child.return = i, i = i.child;
        continue;
      }
      if (i === o) break;
      for (; i.sibling === null; ) {
        if (i.return === null || i.return === o) return null;
        i = i.return;
      }
      i.sibling.return = i.return, i = i.sibling;
    }
    return null;
  }
  var Wr = 0, ze = null, at = null, $t = null, Mu = !1, ri = !1, ya = !1, Nu = 0, ys = 0, oi = null, JO = 0;
  function kt() {
    throw Error(r(321));
  }
  function Gf(o, i) {
    if (i === null) return !1;
    for (var u = 0; u < i.length && u < o.length; u++)
      if (!Bn(o[u], i[u])) return !1;
    return !0;
  }
  function Kf(o, i, u, p, y, S) {
    return Wr = S, ze = i, i.memoizedState = null, i.updateQueue = null, i.lanes = 0, $.H = o === null || o.memoizedState === null ? Hy : up, ya = !1, S = u(p, y), ya = !1, ri && (S = uy(
      i,
      u,
      p,
      y
    )), ly(o), S;
  }
  function ly(o) {
    $.H = xs;
    var i = at !== null && at.next !== null;
    if (Wr = 0, $t = at = ze = null, Mu = !1, ys = 0, oi = null, i) throw Error(r(300));
    o === null || zt || (o = o.dependencies, o !== null && bu(o) && (zt = !0));
  }
  function uy(o, i, u, p) {
    ze = o;
    var y = 0;
    do {
      if (ri && (oi = null), ys = 0, ri = !1, 25 <= y) throw Error(r(301));
      if (y += 1, $t = at = null, o.updateQueue != null) {
        var S = o.updateQueue;
        S.lastEffect = null, S.events = null, S.stores = null, S.memoCache != null && (S.memoCache.index = 0);
      }
      $.H = Wy, S = i(u, p);
    } while (ri);
    return S;
  }
  function QO() {
    var o = $.H, i = o.useState()[0];
    return i = typeof i.then == "function" ? bs(i) : i, o = o.useState()[0], (at !== null ? at.memoizedState : null) !== o && (ze.flags |= 1024), i;
  }
  function Yf() {
    var o = Nu !== 0;
    return Nu = 0, o;
  }
  function Xf(o, i, u) {
    i.updateQueue = o.updateQueue, i.flags &= -2053, o.lanes &= ~u;
  }
  function Jf(o) {
    if (Mu) {
      for (o = o.memoizedState; o !== null; ) {
        var i = o.queue;
        i !== null && (i.pending = null), o = o.next;
      }
      Mu = !1;
    }
    Wr = 0, $t = at = ze = null, ri = !1, ys = Nu = 0, oi = null;
  }
  function bn() {
    var o = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return $t === null ? ze.memoizedState = $t = o : $t = $t.next = o, $t;
  }
  function Rt() {
    if (at === null) {
      var o = ze.alternate;
      o = o !== null ? o.memoizedState : null;
    } else o = at.next;
    var i = $t === null ? ze.memoizedState : $t.next;
    if (i !== null)
      $t = i, at = o;
    else {
      if (o === null)
        throw ze.alternate === null ? Error(r(467)) : Error(r(310));
      at = o, o = {
        memoizedState: at.memoizedState,
        baseState: at.baseState,
        baseQueue: at.baseQueue,
        queue: at.queue,
        next: null
      }, $t === null ? ze.memoizedState = $t = o : $t = $t.next = o;
    }
    return $t;
  }
  function Au() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function bs(o) {
    var i = ys;
    return ys += 1, oi === null && (oi = []), o = Zv(oi, o, i), i = ze, ($t === null ? i.memoizedState : $t.next) === null && (i = i.alternate, $.H = i === null || i.memoizedState === null ? Hy : up), o;
  }
  function Ru(o) {
    if (o !== null && typeof o == "object") {
      if (typeof o.then == "function") return bs(o);
      if (o.$$typeof === _) return an(o);
    }
    throw Error(r(438, String(o)));
  }
  function Qf(o) {
    var i = null, u = ze.updateQueue;
    if (u !== null && (i = u.memoCache), i == null) {
      var p = ze.alternate;
      p !== null && (p = p.updateQueue, p !== null && (p = p.memoCache, p != null && (i = {
        data: p.data.map(function(y) {
          return y.slice();
        }),
        index: 0
      })));
    }
    if (i == null && (i = { data: [], index: 0 }), u === null && (u = Au(), ze.updateQueue = u), u.memoCache = i, u = i.data[i.index], u === void 0)
      for (u = i.data[i.index] = Array(o), p = 0; p < o; p++)
        u[p] = z;
    return i.index++, u;
  }
  function qr(o, i) {
    return typeof i == "function" ? i(o) : i;
  }
  function ju(o) {
    var i = Rt();
    return Zf(i, at, o);
  }
  function Zf(o, i, u) {
    var p = o.queue;
    if (p === null) throw Error(r(311));
    p.lastRenderedReducer = u;
    var y = o.baseQueue, S = p.pending;
    if (S !== null) {
      if (y !== null) {
        var j = y.next;
        y.next = S.next, S.next = j;
      }
      i.baseQueue = y = S, p.pending = null;
    }
    if (S = o.baseState, y === null) o.memoizedState = S;
    else {
      i = y.next;
      var T = j = null, X = null, ne = i, ue = !1;
      do {
        var pe = ne.lane & -536870913;
        if (pe !== ne.lane ? (He & pe) === pe : (Wr & pe) === pe) {
          var ae = ne.revertLane;
          if (ae === 0)
            X !== null && (X = X.next = {
              lane: 0,
              revertLane: 0,
              gesture: null,
              action: ne.action,
              hasEagerState: ne.hasEagerState,
              eagerState: ne.eagerState,
              next: null
            }), pe === Qa && (ue = !0);
          else if ((Wr & ae) === ae) {
            ne = ne.next, ae === Qa && (ue = !0);
            continue;
          } else
            pe = {
              lane: 0,
              revertLane: ne.revertLane,
              gesture: null,
              action: ne.action,
              hasEagerState: ne.hasEagerState,
              eagerState: ne.eagerState,
              next: null
            }, X === null ? (T = X = pe, j = S) : X = X.next = pe, ze.lanes |= ae, So |= ae;
          pe = ne.action, ya && u(S, pe), S = ne.hasEagerState ? ne.eagerState : u(S, pe);
        } else
          ae = {
            lane: pe,
            revertLane: ne.revertLane,
            gesture: ne.gesture,
            action: ne.action,
            hasEagerState: ne.hasEagerState,
            eagerState: ne.eagerState,
            next: null
          }, X === null ? (T = X = ae, j = S) : X = X.next = ae, ze.lanes |= pe, So |= pe;
        ne = ne.next;
      } while (ne !== null && ne !== i);
      if (X === null ? j = S : X.next = T, !Bn(S, o.memoizedState) && (zt = !0, ue && (u = Za, u !== null)))
        throw u;
      o.memoizedState = S, o.baseState = j, o.baseQueue = X, p.lastRenderedState = S;
    }
    return y === null && (p.lanes = 0), [o.memoizedState, p.dispatch];
  }
  function ep(o) {
    var i = Rt(), u = i.queue;
    if (u === null) throw Error(r(311));
    u.lastRenderedReducer = o;
    var p = u.dispatch, y = u.pending, S = i.memoizedState;
    if (y !== null) {
      u.pending = null;
      var j = y = y.next;
      do
        S = o(S, j.action), j = j.next;
      while (j !== y);
      Bn(S, i.memoizedState) || (zt = !0), i.memoizedState = S, i.baseQueue === null && (i.baseState = S), u.lastRenderedState = S;
    }
    return [S, p];
  }
  function cy(o, i, u) {
    var p = ze, y = Rt(), S = Ke;
    if (S) {
      if (u === void 0) throw Error(r(407));
      u = u();
    } else u = i();
    var j = !Bn(
      (at || y).memoizedState,
      u
    );
    if (j && (y.memoizedState = u, zt = !0), y = y.queue, rp(py.bind(null, p, y, o), [
      o
    ]), y.getSnapshot !== i || j || $t !== null && $t.memoizedState.tag & 1) {
      if (p.flags |= 2048, ai(
        9,
        { destroy: void 0 },
        fy.bind(
          null,
          p,
          y,
          u,
          i
        ),
        null
      ), ut === null) throw Error(r(349));
      S || (Wr & 127) !== 0 || dy(p, i, u);
    }
    return u;
  }
  function dy(o, i, u) {
    o.flags |= 16384, o = { getSnapshot: i, value: u }, i = ze.updateQueue, i === null ? (i = Au(), ze.updateQueue = i, i.stores = [o]) : (u = i.stores, u === null ? i.stores = [o] : u.push(o));
  }
  function fy(o, i, u, p) {
    i.value = u, i.getSnapshot = p, my(i) && hy(o);
  }
  function py(o, i, u) {
    return u(function() {
      my(i) && hy(o);
    });
  }
  function my(o) {
    var i = o.getSnapshot;
    o = o.value;
    try {
      var u = i();
      return !Bn(o, u);
    } catch {
      return !0;
    }
  }
  function hy(o) {
    var i = ua(o, 2);
    i !== null && Pn(i, o, 2);
  }
  function tp(o) {
    var i = bn();
    if (typeof o == "function") {
      var u = o;
      if (o = u(), ya) {
        kn(!0);
        try {
          u();
        } finally {
          kn(!1);
        }
      }
    }
    return i.memoizedState = i.baseState = o, i.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: qr,
      lastRenderedState: o
    }, i;
  }
  function gy(o, i, u, p) {
    return o.baseState = u, Zf(
      o,
      at,
      typeof p == "function" ? p : qr
    );
  }
  function ZO(o, i, u, p, y) {
    if (Iu(o)) throw Error(r(485));
    if (o = i.action, o !== null) {
      var S = {
        payload: y,
        action: o,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(j) {
          S.listeners.push(j);
        }
      };
      $.T !== null ? u(!0) : S.isTransition = !1, p(S), u = i.pending, u === null ? (S.next = i.pending = S, vy(i, S)) : (S.next = u.next, i.pending = u.next = S);
    }
  }
  function vy(o, i) {
    var u = i.action, p = i.payload, y = o.state;
    if (i.isTransition) {
      var S = $.T, j = {};
      $.T = j;
      try {
        var T = u(y, p), X = $.S;
        X !== null && X(j, T), yy(o, i, T);
      } catch (ne) {
        np(o, i, ne);
      } finally {
        S !== null && j.types !== null && (S.types = j.types), $.T = S;
      }
    } else
      try {
        S = u(y, p), yy(o, i, S);
      } catch (ne) {
        np(o, i, ne);
      }
  }
  function yy(o, i, u) {
    u !== null && typeof u == "object" && typeof u.then == "function" ? u.then(
      function(p) {
        by(o, i, p);
      },
      function(p) {
        return np(o, i, p);
      }
    ) : by(o, i, u);
  }
  function by(o, i, u) {
    i.status = "fulfilled", i.value = u, wy(i), o.state = u, i = o.pending, i !== null && (u = i.next, u === i ? o.pending = null : (u = u.next, i.next = u, vy(o, u)));
  }
  function np(o, i, u) {
    var p = o.pending;
    if (o.pending = null, p !== null) {
      p = p.next;
      do
        i.status = "rejected", i.reason = u, wy(i), i = i.next;
      while (i !== p);
    }
    o.action = null;
  }
  function wy(o) {
    o = o.listeners;
    for (var i = 0; i < o.length; i++) (0, o[i])();
  }
  function xy(o, i) {
    return i;
  }
  function Sy(o, i) {
    if (Ke) {
      var u = ut.formState;
      if (u !== null) {
        e: {
          var p = ze;
          if (Ke) {
            if (yt) {
              t: {
                for (var y = yt, S = ar; y.nodeType !== 8; ) {
                  if (!S) {
                    y = null;
                    break t;
                  }
                  if (y = ir(
                    y.nextSibling
                  ), y === null) {
                    y = null;
                    break t;
                  }
                }
                S = y.data, y = S === "F!" || S === "F" ? y : null;
              }
              if (y) {
                yt = ir(
                  y.nextSibling
                ), p = y.data === "F!";
                break e;
              }
            }
            po(p);
          }
          p = !1;
        }
        p && (i = u[0]);
      }
    }
    return u = bn(), u.memoizedState = u.baseState = i, p = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: xy,
      lastRenderedState: i
    }, u.queue = p, u = By.bind(
      null,
      ze,
      p
    ), p.dispatch = u, p = tp(!1), S = lp.bind(
      null,
      ze,
      !1,
      p.queue
    ), p = bn(), y = {
      state: i,
      dispatch: null,
      action: o,
      pending: null
    }, p.queue = y, u = ZO.bind(
      null,
      ze,
      y,
      S,
      u
    ), y.dispatch = u, p.memoizedState = o, [i, u, !1];
  }
  function ky(o) {
    var i = Rt();
    return _y(i, at, o);
  }
  function _y(o, i, u) {
    if (i = Zf(
      o,
      i,
      xy
    )[0], o = ju(qr)[0], typeof i == "object" && i !== null && typeof i.then == "function")
      try {
        var p = bs(i);
      } catch (j) {
        throw j === ei ? Su : j;
      }
    else p = i;
    i = Rt();
    var y = i.queue, S = y.dispatch;
    return u !== i.memoizedState && (ze.flags |= 2048, ai(
      9,
      { destroy: void 0 },
      eM.bind(null, y, u),
      null
    )), [p, S, o];
  }
  function eM(o, i) {
    o.action = i;
  }
  function Ey(o) {
    var i = Rt(), u = at;
    if (u !== null)
      return _y(i, u, o);
    Rt(), i = i.memoizedState, u = Rt();
    var p = u.queue.dispatch;
    return u.memoizedState = o, [i, p, !1];
  }
  function ai(o, i, u, p) {
    return o = { tag: o, create: u, deps: p, inst: i, next: null }, i = ze.updateQueue, i === null && (i = Au(), ze.updateQueue = i), u = i.lastEffect, u === null ? i.lastEffect = o.next = o : (p = u.next, u.next = o, o.next = p, i.lastEffect = o), o;
  }
  function Cy() {
    return Rt().memoizedState;
  }
  function Pu(o, i, u, p) {
    var y = bn();
    ze.flags |= o, y.memoizedState = ai(
      1 | i,
      { destroy: void 0 },
      u,
      p === void 0 ? null : p
    );
  }
  function Du(o, i, u, p) {
    var y = Rt();
    p = p === void 0 ? null : p;
    var S = y.memoizedState.inst;
    at !== null && p !== null && Gf(p, at.memoizedState.deps) ? y.memoizedState = ai(i, S, u, p) : (ze.flags |= o, y.memoizedState = ai(
      1 | i,
      S,
      u,
      p
    ));
  }
  function Oy(o, i) {
    Pu(8390656, 8, o, i);
  }
  function rp(o, i) {
    Du(2048, 8, o, i);
  }
  function tM(o) {
    ze.flags |= 4;
    var i = ze.updateQueue;
    if (i === null)
      i = Au(), ze.updateQueue = i, i.events = [o];
    else {
      var u = i.events;
      u === null ? i.events = [o] : u.push(o);
    }
  }
  function My(o) {
    var i = Rt().memoizedState;
    return tM({ ref: i, nextImpl: o }), function() {
      if ((Ze & 2) !== 0) throw Error(r(440));
      return i.impl.apply(void 0, arguments);
    };
  }
  function Ny(o, i) {
    return Du(4, 2, o, i);
  }
  function Ay(o, i) {
    return Du(4, 4, o, i);
  }
  function Ry(o, i) {
    if (typeof i == "function") {
      o = o();
      var u = i(o);
      return function() {
        typeof u == "function" ? u() : i(null);
      };
    }
    if (i != null)
      return o = o(), i.current = o, function() {
        i.current = null;
      };
  }
  function jy(o, i, u) {
    u = u != null ? u.concat([o]) : null, Du(4, 4, Ry.bind(null, i, o), u);
  }
  function op() {
  }
  function Py(o, i) {
    var u = Rt();
    i = i === void 0 ? null : i;
    var p = u.memoizedState;
    return i !== null && Gf(i, p[1]) ? p[0] : (u.memoizedState = [o, i], o);
  }
  function Dy(o, i) {
    var u = Rt();
    i = i === void 0 ? null : i;
    var p = u.memoizedState;
    if (i !== null && Gf(i, p[1]))
      return p[0];
    if (p = o(), ya) {
      kn(!0);
      try {
        o();
      } finally {
        kn(!1);
      }
    }
    return u.memoizedState = [p, i], p;
  }
  function ap(o, i, u) {
    return u === void 0 || (Wr & 1073741824) !== 0 && (He & 261930) === 0 ? o.memoizedState = i : (o.memoizedState = u, o = Ib(), ze.lanes |= o, So |= o, u);
  }
  function Iy(o, i, u, p) {
    return Bn(u, i) ? u : ni.current !== null ? (o = ap(o, u, p), Bn(o, i) || (zt = !0), o) : (Wr & 42) === 0 || (Wr & 1073741824) !== 0 && (He & 261930) === 0 ? (zt = !0, o.memoizedState = u) : (o = Ib(), ze.lanes |= o, So |= o, i);
  }
  function $y(o, i, u, p, y) {
    var S = K.p;
    K.p = S !== 0 && 8 > S ? S : 8;
    var j = $.T, T = {};
    $.T = T, lp(o, !1, i, u);
    try {
      var X = y(), ne = $.S;
      if (ne !== null && ne(T, X), X !== null && typeof X == "object" && typeof X.then == "function") {
        var ue = XO(
          X,
          p
        );
        ws(
          o,
          i,
          ue,
          Gn(o)
        );
      } else
        ws(
          o,
          i,
          p,
          Gn(o)
        );
    } catch (pe) {
      ws(
        o,
        i,
        { then: function() {
        }, status: "rejected", reason: pe },
        Gn()
      );
    } finally {
      K.p = S, j !== null && T.types !== null && (j.types = T.types), $.T = j;
    }
  }
  function nM() {
  }
  function ip(o, i, u, p) {
    if (o.tag !== 5) throw Error(r(476));
    var y = zy(o).queue;
    $y(
      o,
      y,
      i,
      q,
      u === null ? nM : function() {
        return Ty(o), u(p);
      }
    );
  }
  function zy(o) {
    var i = o.memoizedState;
    if (i !== null) return i;
    i = {
      memoizedState: q,
      baseState: q,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: qr,
        lastRenderedState: q
      },
      next: null
    };
    var u = {};
    return i.next = {
      memoizedState: u,
      baseState: u,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: qr,
        lastRenderedState: u
      },
      next: null
    }, o.memoizedState = i, o = o.alternate, o !== null && (o.memoizedState = i), i;
  }
  function Ty(o) {
    var i = zy(o);
    i.next === null && (i = o.alternate.memoizedState), ws(
      o,
      i.next.queue,
      {},
      Gn()
    );
  }
  function sp() {
    return an(zs);
  }
  function Ly() {
    return Rt().memoizedState;
  }
  function Fy() {
    return Rt().memoizedState;
  }
  function rM(o) {
    for (var i = o.return; i !== null; ) {
      switch (i.tag) {
        case 24:
        case 3:
          var u = Gn();
          o = go(u);
          var p = vo(i, o, u);
          p !== null && (Pn(p, i, u), hs(p, i, u)), i = { cache: $f() }, o.payload = i;
          return;
      }
      i = i.return;
    }
  }
  function oM(o, i, u) {
    var p = Gn();
    u = {
      lane: p,
      revertLane: 0,
      gesture: null,
      action: u,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Iu(o) ? Uy(i, u) : (u = Ef(o, i, u, p), u !== null && (Pn(u, o, p), Vy(u, i, p)));
  }
  function By(o, i, u) {
    var p = Gn();
    ws(o, i, u, p);
  }
  function ws(o, i, u, p) {
    var y = {
      lane: p,
      revertLane: 0,
      gesture: null,
      action: u,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (Iu(o)) Uy(i, y);
    else {
      var S = o.alternate;
      if (o.lanes === 0 && (S === null || S.lanes === 0) && (S = i.lastRenderedReducer, S !== null))
        try {
          var j = i.lastRenderedState, T = S(j, u);
          if (y.hasEagerState = !0, y.eagerState = T, Bn(T, j))
            return hu(o, i, y, 0), ut === null && mu(), !1;
        } catch {
        }
      if (u = Ef(o, i, y, p), u !== null)
        return Pn(u, o, p), Vy(u, i, p), !0;
    }
    return !1;
  }
  function lp(o, i, u, p) {
    if (p = {
      lane: 2,
      revertLane: Fp(),
      gesture: null,
      action: p,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Iu(o)) {
      if (i) throw Error(r(479));
    } else
      i = Ef(
        o,
        u,
        p,
        2
      ), i !== null && Pn(i, o, 2);
  }
  function Iu(o) {
    var i = o.alternate;
    return o === ze || i !== null && i === ze;
  }
  function Uy(o, i) {
    ri = Mu = !0;
    var u = o.pending;
    u === null ? i.next = i : (i.next = u.next, u.next = i), o.pending = i;
  }
  function Vy(o, i, u) {
    if ((u & 4194048) !== 0) {
      var p = i.lanes;
      p &= o.pendingLanes, u |= p, i.lanes = u, Kd(o, u);
    }
  }
  var xs = {
    readContext: an,
    use: Ru,
    useCallback: kt,
    useContext: kt,
    useEffect: kt,
    useImperativeHandle: kt,
    useLayoutEffect: kt,
    useInsertionEffect: kt,
    useMemo: kt,
    useReducer: kt,
    useRef: kt,
    useState: kt,
    useDebugValue: kt,
    useDeferredValue: kt,
    useTransition: kt,
    useSyncExternalStore: kt,
    useId: kt,
    useHostTransitionStatus: kt,
    useFormState: kt,
    useActionState: kt,
    useOptimistic: kt,
    useMemoCache: kt,
    useCacheRefresh: kt
  };
  xs.useEffectEvent = kt;
  var Hy = {
    readContext: an,
    use: Ru,
    useCallback: function(o, i) {
      return bn().memoizedState = [
        o,
        i === void 0 ? null : i
      ], o;
    },
    useContext: an,
    useEffect: Oy,
    useImperativeHandle: function(o, i, u) {
      u = u != null ? u.concat([o]) : null, Pu(
        4194308,
        4,
        Ry.bind(null, i, o),
        u
      );
    },
    useLayoutEffect: function(o, i) {
      return Pu(4194308, 4, o, i);
    },
    useInsertionEffect: function(o, i) {
      Pu(4, 2, o, i);
    },
    useMemo: function(o, i) {
      var u = bn();
      i = i === void 0 ? null : i;
      var p = o();
      if (ya) {
        kn(!0);
        try {
          o();
        } finally {
          kn(!1);
        }
      }
      return u.memoizedState = [p, i], p;
    },
    useReducer: function(o, i, u) {
      var p = bn();
      if (u !== void 0) {
        var y = u(i);
        if (ya) {
          kn(!0);
          try {
            u(i);
          } finally {
            kn(!1);
          }
        }
      } else y = i;
      return p.memoizedState = p.baseState = y, o = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: o,
        lastRenderedState: y
      }, p.queue = o, o = o.dispatch = oM.bind(
        null,
        ze,
        o
      ), [p.memoizedState, o];
    },
    useRef: function(o) {
      var i = bn();
      return o = { current: o }, i.memoizedState = o;
    },
    useState: function(o) {
      o = tp(o);
      var i = o.queue, u = By.bind(null, ze, i);
      return i.dispatch = u, [o.memoizedState, u];
    },
    useDebugValue: op,
    useDeferredValue: function(o, i) {
      var u = bn();
      return ap(u, o, i);
    },
    useTransition: function() {
      var o = tp(!1);
      return o = $y.bind(
        null,
        ze,
        o.queue,
        !0,
        !1
      ), bn().memoizedState = o, [!1, o];
    },
    useSyncExternalStore: function(o, i, u) {
      var p = ze, y = bn();
      if (Ke) {
        if (u === void 0)
          throw Error(r(407));
        u = u();
      } else {
        if (u = i(), ut === null)
          throw Error(r(349));
        (He & 127) !== 0 || dy(p, i, u);
      }
      y.memoizedState = u;
      var S = { value: u, getSnapshot: i };
      return y.queue = S, Oy(py.bind(null, p, S, o), [
        o
      ]), p.flags |= 2048, ai(
        9,
        { destroy: void 0 },
        fy.bind(
          null,
          p,
          S,
          u,
          i
        ),
        null
      ), u;
    },
    useId: function() {
      var o = bn(), i = ut.identifierPrefix;
      if (Ke) {
        var u = Or, p = Cr;
        u = (p & ~(1 << 32 - Ae(p) - 1)).toString(32) + u, i = "_" + i + "R_" + u, u = Nu++, 0 < u && (i += "H" + u.toString(32)), i += "_";
      } else
        u = JO++, i = "_" + i + "r_" + u.toString(32) + "_";
      return o.memoizedState = i;
    },
    useHostTransitionStatus: sp,
    useFormState: Sy,
    useActionState: Sy,
    useOptimistic: function(o) {
      var i = bn();
      i.memoizedState = i.baseState = o;
      var u = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return i.queue = u, i = lp.bind(
        null,
        ze,
        !0,
        u
      ), u.dispatch = i, [o, i];
    },
    useMemoCache: Qf,
    useCacheRefresh: function() {
      return bn().memoizedState = rM.bind(
        null,
        ze
      );
    },
    useEffectEvent: function(o) {
      var i = bn(), u = { impl: o };
      return i.memoizedState = u, function() {
        if ((Ze & 2) !== 0)
          throw Error(r(440));
        return u.impl.apply(void 0, arguments);
      };
    }
  }, up = {
    readContext: an,
    use: Ru,
    useCallback: Py,
    useContext: an,
    useEffect: rp,
    useImperativeHandle: jy,
    useInsertionEffect: Ny,
    useLayoutEffect: Ay,
    useMemo: Dy,
    useReducer: ju,
    useRef: Cy,
    useState: function() {
      return ju(qr);
    },
    useDebugValue: op,
    useDeferredValue: function(o, i) {
      var u = Rt();
      return Iy(
        u,
        at.memoizedState,
        o,
        i
      );
    },
    useTransition: function() {
      var o = ju(qr)[0], i = Rt().memoizedState;
      return [
        typeof o == "boolean" ? o : bs(o),
        i
      ];
    },
    useSyncExternalStore: cy,
    useId: Ly,
    useHostTransitionStatus: sp,
    useFormState: ky,
    useActionState: ky,
    useOptimistic: function(o, i) {
      var u = Rt();
      return gy(u, at, o, i);
    },
    useMemoCache: Qf,
    useCacheRefresh: Fy
  };
  up.useEffectEvent = My;
  var Wy = {
    readContext: an,
    use: Ru,
    useCallback: Py,
    useContext: an,
    useEffect: rp,
    useImperativeHandle: jy,
    useInsertionEffect: Ny,
    useLayoutEffect: Ay,
    useMemo: Dy,
    useReducer: ep,
    useRef: Cy,
    useState: function() {
      return ep(qr);
    },
    useDebugValue: op,
    useDeferredValue: function(o, i) {
      var u = Rt();
      return at === null ? ap(u, o, i) : Iy(
        u,
        at.memoizedState,
        o,
        i
      );
    },
    useTransition: function() {
      var o = ep(qr)[0], i = Rt().memoizedState;
      return [
        typeof o == "boolean" ? o : bs(o),
        i
      ];
    },
    useSyncExternalStore: cy,
    useId: Ly,
    useHostTransitionStatus: sp,
    useFormState: Ey,
    useActionState: Ey,
    useOptimistic: function(o, i) {
      var u = Rt();
      return at !== null ? gy(u, at, o, i) : (u.baseState = o, [o, u.queue.dispatch]);
    },
    useMemoCache: Qf,
    useCacheRefresh: Fy
  };
  Wy.useEffectEvent = My;
  function cp(o, i, u, p) {
    i = o.memoizedState, u = u(p, i), u = u == null ? i : h({}, i, u), o.memoizedState = u, o.lanes === 0 && (o.updateQueue.baseState = u);
  }
  var dp = {
    enqueueSetState: function(o, i, u) {
      o = o._reactInternals;
      var p = Gn(), y = go(p);
      y.payload = i, u != null && (y.callback = u), i = vo(o, y, p), i !== null && (Pn(i, o, p), hs(i, o, p));
    },
    enqueueReplaceState: function(o, i, u) {
      o = o._reactInternals;
      var p = Gn(), y = go(p);
      y.tag = 1, y.payload = i, u != null && (y.callback = u), i = vo(o, y, p), i !== null && (Pn(i, o, p), hs(i, o, p));
    },
    enqueueForceUpdate: function(o, i) {
      o = o._reactInternals;
      var u = Gn(), p = go(u);
      p.tag = 2, i != null && (p.callback = i), i = vo(o, p, u), i !== null && (Pn(i, o, u), hs(i, o, u));
    }
  };
  function qy(o, i, u, p, y, S, j) {
    return o = o.stateNode, typeof o.shouldComponentUpdate == "function" ? o.shouldComponentUpdate(p, S, j) : i.prototype && i.prototype.isPureReactComponent ? !ss(u, p) || !ss(y, S) : !0;
  }
  function Gy(o, i, u, p) {
    o = i.state, typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(u, p), typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(u, p), i.state !== o && dp.enqueueReplaceState(i, i.state, null);
  }
  function ba(o, i) {
    var u = i;
    if ("ref" in i) {
      u = {};
      for (var p in i)
        p !== "ref" && (u[p] = i[p]);
    }
    if (o = o.defaultProps) {
      u === i && (u = h({}, u));
      for (var y in o)
        u[y] === void 0 && (u[y] = o[y]);
    }
    return u;
  }
  function Ky(o) {
    pu(o);
  }
  function Yy(o) {
    console.error(o);
  }
  function Xy(o) {
    pu(o);
  }
  function $u(o, i) {
    try {
      var u = o.onUncaughtError;
      u(i.value, { componentStack: i.stack });
    } catch (p) {
      setTimeout(function() {
        throw p;
      });
    }
  }
  function Jy(o, i, u) {
    try {
      var p = o.onCaughtError;
      p(u.value, {
        componentStack: u.stack,
        errorBoundary: i.tag === 1 ? i.stateNode : null
      });
    } catch (y) {
      setTimeout(function() {
        throw y;
      });
    }
  }
  function fp(o, i, u) {
    return u = go(u), u.tag = 3, u.payload = { element: null }, u.callback = function() {
      $u(o, i);
    }, u;
  }
  function Qy(o) {
    return o = go(o), o.tag = 3, o;
  }
  function Zy(o, i, u, p) {
    var y = u.type.getDerivedStateFromError;
    if (typeof y == "function") {
      var S = p.value;
      o.payload = function() {
        return y(S);
      }, o.callback = function() {
        Jy(i, u, p);
      };
    }
    var j = u.stateNode;
    j !== null && typeof j.componentDidCatch == "function" && (o.callback = function() {
      Jy(i, u, p), typeof y != "function" && (ko === null ? ko = /* @__PURE__ */ new Set([this]) : ko.add(this));
      var T = p.stack;
      this.componentDidCatch(p.value, {
        componentStack: T !== null ? T : ""
      });
    });
  }
  function aM(o, i, u, p, y) {
    if (u.flags |= 32768, p !== null && typeof p == "object" && typeof p.then == "function") {
      if (i = u.alternate, i !== null && Ja(
        i,
        u,
        y,
        !0
      ), u = Vn.current, u !== null) {
        switch (u.tag) {
          case 31:
          case 13:
            return fr === null ? Ku() : u.alternate === null && _t === 0 && (_t = 3), u.flags &= -257, u.flags |= 65536, u.lanes = y, p === ku ? u.flags |= 16384 : (i = u.updateQueue, i === null ? u.updateQueue = /* @__PURE__ */ new Set([p]) : i.add(p), zp(o, p, y)), !1;
          case 22:
            return u.flags |= 65536, p === ku ? u.flags |= 16384 : (i = u.updateQueue, i === null ? (i = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([p])
            }, u.updateQueue = i) : (u = i.retryQueue, u === null ? i.retryQueue = /* @__PURE__ */ new Set([p]) : u.add(p)), zp(o, p, y)), !1;
        }
        throw Error(r(435, u.tag));
      }
      return zp(o, p, y), Ku(), !1;
    }
    if (Ke)
      return i = Vn.current, i !== null ? ((i.flags & 65536) === 0 && (i.flags |= 256), i.flags |= 65536, i.lanes = y, p !== Rf && (o = Error(r(422), { cause: p }), cs(nr(o, u)))) : (p !== Rf && (i = Error(r(423), {
        cause: p
      }), cs(
        nr(i, u)
      )), o = o.current.alternate, o.flags |= 65536, y &= -y, o.lanes |= y, p = nr(p, u), y = fp(
        o.stateNode,
        p,
        y
      ), Uf(o, y), _t !== 4 && (_t = 2)), !1;
    var S = Error(r(520), { cause: p });
    if (S = nr(S, u), Ns === null ? Ns = [S] : Ns.push(S), _t !== 4 && (_t = 2), i === null) return !0;
    p = nr(p, u), u = i;
    do {
      switch (u.tag) {
        case 3:
          return u.flags |= 65536, o = y & -y, u.lanes |= o, o = fp(u.stateNode, p, o), Uf(u, o), !1;
        case 1:
          if (i = u.type, S = u.stateNode, (u.flags & 128) === 0 && (typeof i.getDerivedStateFromError == "function" || S !== null && typeof S.componentDidCatch == "function" && (ko === null || !ko.has(S))))
            return u.flags |= 65536, y &= -y, u.lanes |= y, y = Qy(y), Zy(
              y,
              o,
              u,
              p
            ), Uf(u, y), !1;
      }
      u = u.return;
    } while (u !== null);
    return !1;
  }
  var pp = Error(r(461)), zt = !1;
  function sn(o, i, u, p) {
    i.child = o === null ? ry(i, null, u, p) : va(
      i,
      o.child,
      u,
      p
    );
  }
  function eb(o, i, u, p, y) {
    u = u.render;
    var S = i.ref;
    if ("ref" in p) {
      var j = {};
      for (var T in p)
        T !== "ref" && (j[T] = p[T]);
    } else j = p;
    return pa(i), p = Kf(
      o,
      i,
      u,
      j,
      S,
      y
    ), T = Yf(), o !== null && !zt ? (Xf(o, i, y), Gr(o, i, y)) : (Ke && T && Nf(i), i.flags |= 1, sn(o, i, p, y), i.child);
  }
  function tb(o, i, u, p, y) {
    if (o === null) {
      var S = u.type;
      return typeof S == "function" && !Cf(S) && S.defaultProps === void 0 && u.compare === null ? (i.tag = 15, i.type = S, nb(
        o,
        i,
        S,
        p,
        y
      )) : (o = vu(
        u.type,
        null,
        p,
        i,
        i.mode,
        y
      ), o.ref = i.ref, o.return = i, i.child = o);
    }
    if (S = o.child, !xp(o, y)) {
      var j = S.memoizedProps;
      if (u = u.compare, u = u !== null ? u : ss, u(j, p) && o.ref === i.ref)
        return Gr(o, i, y);
    }
    return i.flags |= 1, o = Br(S, p), o.ref = i.ref, o.return = i, i.child = o;
  }
  function nb(o, i, u, p, y) {
    if (o !== null) {
      var S = o.memoizedProps;
      if (ss(S, p) && o.ref === i.ref)
        if (zt = !1, i.pendingProps = p = S, xp(o, y))
          (o.flags & 131072) !== 0 && (zt = !0);
        else
          return i.lanes = o.lanes, Gr(o, i, y);
    }
    return mp(
      o,
      i,
      u,
      p,
      y
    );
  }
  function rb(o, i, u, p) {
    var y = p.children, S = o !== null ? o.memoizedState : null;
    if (o === null && i.stateNode === null && (i.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), p.mode === "hidden") {
      if ((i.flags & 128) !== 0) {
        if (S = S !== null ? S.baseLanes | u : u, o !== null) {
          for (p = i.child = o.child, y = 0; p !== null; )
            y = y | p.lanes | p.childLanes, p = p.sibling;
          p = y & ~S;
        } else p = 0, i.child = null;
        return ob(
          o,
          i,
          S,
          u,
          p
        );
      }
      if ((u & 536870912) !== 0)
        i.memoizedState = { baseLanes: 0, cachePool: null }, o !== null && xu(
          i,
          S !== null ? S.cachePool : null
        ), S !== null ? iy(i, S) : Hf(), sy(i);
      else
        return p = i.lanes = 536870912, ob(
          o,
          i,
          S !== null ? S.baseLanes | u : u,
          u,
          p
        );
    } else
      S !== null ? (xu(i, S.cachePool), iy(i, S), bo(), i.memoizedState = null) : (o !== null && xu(i, null), Hf(), bo());
    return sn(o, i, y, u), i.child;
  }
  function Ss(o, i) {
    return o !== null && o.tag === 22 || i.stateNode !== null || (i.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), i.sibling;
  }
  function ob(o, i, u, p, y) {
    var S = Tf();
    return S = S === null ? null : { parent: It._currentValue, pool: S }, i.memoizedState = {
      baseLanes: u,
      cachePool: S
    }, o !== null && xu(i, null), Hf(), sy(i), o !== null && Ja(o, i, p, !0), i.childLanes = y, null;
  }
  function zu(o, i) {
    return i = Lu(
      { mode: i.mode, children: i.children },
      o.mode
    ), i.ref = o.ref, o.child = i, i.return = o, i;
  }
  function ab(o, i, u) {
    return va(i, o.child, null, u), o = zu(i, i.pendingProps), o.flags |= 2, Hn(i), i.memoizedState = null, o;
  }
  function iM(o, i, u) {
    var p = i.pendingProps, y = (i.flags & 128) !== 0;
    if (i.flags &= -129, o === null) {
      if (Ke) {
        if (p.mode === "hidden")
          return o = zu(i, p), i.lanes = 536870912, Ss(null, o);
        if (qf(i), (o = yt) ? (o = vw(
          o,
          ar
        ), o = o !== null && o.data === "&" ? o : null, o !== null && (i.memoizedState = {
          dehydrated: o,
          treeContext: co !== null ? { id: Cr, overflow: Or } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, u = Uv(o), u.return = i, i.child = u, on = i, yt = null)) : o = null, o === null) throw po(i);
        return i.lanes = 536870912, null;
      }
      return zu(i, p);
    }
    var S = o.memoizedState;
    if (S !== null) {
      var j = S.dehydrated;
      if (qf(i), y)
        if (i.flags & 256)
          i.flags &= -257, i = ab(
            o,
            i,
            u
          );
        else if (i.memoizedState !== null)
          i.child = o.child, i.flags |= 128, i = null;
        else throw Error(r(558));
      else if (zt || Ja(o, i, u, !1), y = (u & o.childLanes) !== 0, zt || y) {
        if (p = ut, p !== null && (j = Yd(p, u), j !== 0 && j !== S.retryLane))
          throw S.retryLane = j, ua(o, j), Pn(p, o, j), pp;
        Ku(), i = ab(
          o,
          i,
          u
        );
      } else
        o = S.treeContext, yt = ir(j.nextSibling), on = i, Ke = !0, fo = null, ar = !1, o !== null && Wv(i, o), i = zu(i, p), i.flags |= 4096;
      return i;
    }
    return o = Br(o.child, {
      mode: p.mode,
      children: p.children
    }), o.ref = i.ref, i.child = o, o.return = i, o;
  }
  function Tu(o, i) {
    var u = i.ref;
    if (u === null)
      o !== null && o.ref !== null && (i.flags |= 4194816);
    else {
      if (typeof u != "function" && typeof u != "object")
        throw Error(r(284));
      (o === null || o.ref !== u) && (i.flags |= 4194816);
    }
  }
  function mp(o, i, u, p, y) {
    return pa(i), u = Kf(
      o,
      i,
      u,
      p,
      void 0,
      y
    ), p = Yf(), o !== null && !zt ? (Xf(o, i, y), Gr(o, i, y)) : (Ke && p && Nf(i), i.flags |= 1, sn(o, i, u, y), i.child);
  }
  function ib(o, i, u, p, y, S) {
    return pa(i), i.updateQueue = null, u = uy(
      i,
      p,
      u,
      y
    ), ly(o), p = Yf(), o !== null && !zt ? (Xf(o, i, S), Gr(o, i, S)) : (Ke && p && Nf(i), i.flags |= 1, sn(o, i, u, S), i.child);
  }
  function sb(o, i, u, p, y) {
    if (pa(i), i.stateNode === null) {
      var S = Ga, j = u.contextType;
      typeof j == "object" && j !== null && (S = an(j)), S = new u(p, S), i.memoizedState = S.state !== null && S.state !== void 0 ? S.state : null, S.updater = dp, i.stateNode = S, S._reactInternals = i, S = i.stateNode, S.props = p, S.state = i.memoizedState, S.refs = {}, Ff(i), j = u.contextType, S.context = typeof j == "object" && j !== null ? an(j) : Ga, S.state = i.memoizedState, j = u.getDerivedStateFromProps, typeof j == "function" && (cp(
        i,
        u,
        j,
        p
      ), S.state = i.memoizedState), typeof u.getDerivedStateFromProps == "function" || typeof S.getSnapshotBeforeUpdate == "function" || typeof S.UNSAFE_componentWillMount != "function" && typeof S.componentWillMount != "function" || (j = S.state, typeof S.componentWillMount == "function" && S.componentWillMount(), typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount(), j !== S.state && dp.enqueueReplaceState(S, S.state, null), vs(i, p, S, y), gs(), S.state = i.memoizedState), typeof S.componentDidMount == "function" && (i.flags |= 4194308), p = !0;
    } else if (o === null) {
      S = i.stateNode;
      var T = i.memoizedProps, X = ba(u, T);
      S.props = X;
      var ne = S.context, ue = u.contextType;
      j = Ga, typeof ue == "object" && ue !== null && (j = an(ue));
      var pe = u.getDerivedStateFromProps;
      ue = typeof pe == "function" || typeof S.getSnapshotBeforeUpdate == "function", T = i.pendingProps !== T, ue || typeof S.UNSAFE_componentWillReceiveProps != "function" && typeof S.componentWillReceiveProps != "function" || (T || ne !== j) && Gy(
        i,
        S,
        p,
        j
      ), ho = !1;
      var ae = i.memoizedState;
      S.state = ae, vs(i, p, S, y), gs(), ne = i.memoizedState, T || ae !== ne || ho ? (typeof pe == "function" && (cp(
        i,
        u,
        pe,
        p
      ), ne = i.memoizedState), (X = ho || qy(
        i,
        u,
        X,
        p,
        ae,
        ne,
        j
      )) ? (ue || typeof S.UNSAFE_componentWillMount != "function" && typeof S.componentWillMount != "function" || (typeof S.componentWillMount == "function" && S.componentWillMount(), typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount()), typeof S.componentDidMount == "function" && (i.flags |= 4194308)) : (typeof S.componentDidMount == "function" && (i.flags |= 4194308), i.memoizedProps = p, i.memoizedState = ne), S.props = p, S.state = ne, S.context = j, p = X) : (typeof S.componentDidMount == "function" && (i.flags |= 4194308), p = !1);
    } else {
      S = i.stateNode, Bf(o, i), j = i.memoizedProps, ue = ba(u, j), S.props = ue, pe = i.pendingProps, ae = S.context, ne = u.contextType, X = Ga, typeof ne == "object" && ne !== null && (X = an(ne)), T = u.getDerivedStateFromProps, (ne = typeof T == "function" || typeof S.getSnapshotBeforeUpdate == "function") || typeof S.UNSAFE_componentWillReceiveProps != "function" && typeof S.componentWillReceiveProps != "function" || (j !== pe || ae !== X) && Gy(
        i,
        S,
        p,
        X
      ), ho = !1, ae = i.memoizedState, S.state = ae, vs(i, p, S, y), gs();
      var se = i.memoizedState;
      j !== pe || ae !== se || ho || o !== null && o.dependencies !== null && bu(o.dependencies) ? (typeof T == "function" && (cp(
        i,
        u,
        T,
        p
      ), se = i.memoizedState), (ue = ho || qy(
        i,
        u,
        ue,
        p,
        ae,
        se,
        X
      ) || o !== null && o.dependencies !== null && bu(o.dependencies)) ? (ne || typeof S.UNSAFE_componentWillUpdate != "function" && typeof S.componentWillUpdate != "function" || (typeof S.componentWillUpdate == "function" && S.componentWillUpdate(p, se, X), typeof S.UNSAFE_componentWillUpdate == "function" && S.UNSAFE_componentWillUpdate(
        p,
        se,
        X
      )), typeof S.componentDidUpdate == "function" && (i.flags |= 4), typeof S.getSnapshotBeforeUpdate == "function" && (i.flags |= 1024)) : (typeof S.componentDidUpdate != "function" || j === o.memoizedProps && ae === o.memoizedState || (i.flags |= 4), typeof S.getSnapshotBeforeUpdate != "function" || j === o.memoizedProps && ae === o.memoizedState || (i.flags |= 1024), i.memoizedProps = p, i.memoizedState = se), S.props = p, S.state = se, S.context = X, p = ue) : (typeof S.componentDidUpdate != "function" || j === o.memoizedProps && ae === o.memoizedState || (i.flags |= 4), typeof S.getSnapshotBeforeUpdate != "function" || j === o.memoizedProps && ae === o.memoizedState || (i.flags |= 1024), p = !1);
    }
    return S = p, Tu(o, i), p = (i.flags & 128) !== 0, S || p ? (S = i.stateNode, u = p && typeof u.getDerivedStateFromError != "function" ? null : S.render(), i.flags |= 1, o !== null && p ? (i.child = va(
      i,
      o.child,
      null,
      y
    ), i.child = va(
      i,
      null,
      u,
      y
    )) : sn(o, i, u, y), i.memoizedState = S.state, o = i.child) : o = Gr(
      o,
      i,
      y
    ), o;
  }
  function lb(o, i, u, p) {
    return da(), i.flags |= 256, sn(o, i, u, p), i.child;
  }
  var hp = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function gp(o) {
    return { baseLanes: o, cachePool: Jv() };
  }
  function vp(o, i, u) {
    return o = o !== null ? o.childLanes & ~u : 0, i && (o |= qn), o;
  }
  function ub(o, i, u) {
    var p = i.pendingProps, y = !1, S = (i.flags & 128) !== 0, j;
    if ((j = S) || (j = o !== null && o.memoizedState === null ? !1 : (At.current & 2) !== 0), j && (y = !0, i.flags &= -129), j = (i.flags & 32) !== 0, i.flags &= -33, o === null) {
      if (Ke) {
        if (y ? yo(i) : bo(), (o = yt) ? (o = vw(
          o,
          ar
        ), o = o !== null && o.data !== "&" ? o : null, o !== null && (i.memoizedState = {
          dehydrated: o,
          treeContext: co !== null ? { id: Cr, overflow: Or } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, u = Uv(o), u.return = i, i.child = u, on = i, yt = null)) : o = null, o === null) throw po(i);
        return Zp(o) ? i.lanes = 32 : i.lanes = 536870912, null;
      }
      var T = p.children;
      return p = p.fallback, y ? (bo(), y = i.mode, T = Lu(
        { mode: "hidden", children: T },
        y
      ), p = ca(
        p,
        y,
        u,
        null
      ), T.return = i, p.return = i, T.sibling = p, i.child = T, p = i.child, p.memoizedState = gp(u), p.childLanes = vp(
        o,
        j,
        u
      ), i.memoizedState = hp, Ss(null, p)) : (yo(i), yp(i, T));
    }
    var X = o.memoizedState;
    if (X !== null && (T = X.dehydrated, T !== null)) {
      if (S)
        i.flags & 256 ? (yo(i), i.flags &= -257, i = bp(
          o,
          i,
          u
        )) : i.memoizedState !== null ? (bo(), i.child = o.child, i.flags |= 128, i = null) : (bo(), T = p.fallback, y = i.mode, p = Lu(
          { mode: "visible", children: p.children },
          y
        ), T = ca(
          T,
          y,
          u,
          null
        ), T.flags |= 2, p.return = i, T.return = i, p.sibling = T, i.child = p, va(
          i,
          o.child,
          null,
          u
        ), p = i.child, p.memoizedState = gp(u), p.childLanes = vp(
          o,
          j,
          u
        ), i.memoizedState = hp, i = Ss(null, p));
      else if (yo(i), Zp(T)) {
        if (j = T.nextSibling && T.nextSibling.dataset, j) var ne = j.dgst;
        j = ne, p = Error(r(419)), p.stack = "", p.digest = j, cs({ value: p, source: null, stack: null }), i = bp(
          o,
          i,
          u
        );
      } else if (zt || Ja(o, i, u, !1), j = (u & o.childLanes) !== 0, zt || j) {
        if (j = ut, j !== null && (p = Yd(j, u), p !== 0 && p !== X.retryLane))
          throw X.retryLane = p, ua(o, p), Pn(j, o, p), pp;
        Qp(T) || Ku(), i = bp(
          o,
          i,
          u
        );
      } else
        Qp(T) ? (i.flags |= 192, i.child = o.child, i = null) : (o = X.treeContext, yt = ir(
          T.nextSibling
        ), on = i, Ke = !0, fo = null, ar = !1, o !== null && Wv(i, o), i = yp(
          i,
          p.children
        ), i.flags |= 4096);
      return i;
    }
    return y ? (bo(), T = p.fallback, y = i.mode, X = o.child, ne = X.sibling, p = Br(X, {
      mode: "hidden",
      children: p.children
    }), p.subtreeFlags = X.subtreeFlags & 65011712, ne !== null ? T = Br(
      ne,
      T
    ) : (T = ca(
      T,
      y,
      u,
      null
    ), T.flags |= 2), T.return = i, p.return = i, p.sibling = T, i.child = p, Ss(null, p), p = i.child, T = o.child.memoizedState, T === null ? T = gp(u) : (y = T.cachePool, y !== null ? (X = It._currentValue, y = y.parent !== X ? { parent: X, pool: X } : y) : y = Jv(), T = {
      baseLanes: T.baseLanes | u,
      cachePool: y
    }), p.memoizedState = T, p.childLanes = vp(
      o,
      j,
      u
    ), i.memoizedState = hp, Ss(o.child, p)) : (yo(i), u = o.child, o = u.sibling, u = Br(u, {
      mode: "visible",
      children: p.children
    }), u.return = i, u.sibling = null, o !== null && (j = i.deletions, j === null ? (i.deletions = [o], i.flags |= 16) : j.push(o)), i.child = u, i.memoizedState = null, u);
  }
  function yp(o, i) {
    return i = Lu(
      { mode: "visible", children: i },
      o.mode
    ), i.return = o, o.child = i;
  }
  function Lu(o, i) {
    return o = Un(22, o, null, i), o.lanes = 0, o;
  }
  function bp(o, i, u) {
    return va(i, o.child, null, u), o = yp(
      i,
      i.pendingProps.children
    ), o.flags |= 2, i.memoizedState = null, o;
  }
  function cb(o, i, u) {
    o.lanes |= i;
    var p = o.alternate;
    p !== null && (p.lanes |= i), Df(o.return, i, u);
  }
  function wp(o, i, u, p, y, S) {
    var j = o.memoizedState;
    j === null ? o.memoizedState = {
      isBackwards: i,
      rendering: null,
      renderingStartTime: 0,
      last: p,
      tail: u,
      tailMode: y,
      treeForkCount: S
    } : (j.isBackwards = i, j.rendering = null, j.renderingStartTime = 0, j.last = p, j.tail = u, j.tailMode = y, j.treeForkCount = S);
  }
  function db(o, i, u) {
    var p = i.pendingProps, y = p.revealOrder, S = p.tail;
    p = p.children;
    var j = At.current, T = (j & 2) !== 0;
    if (T ? (j = j & 1 | 2, i.flags |= 128) : j &= 1, U(At, j), sn(o, i, p, u), p = Ke ? us : 0, !T && o !== null && (o.flags & 128) !== 0)
      e: for (o = i.child; o !== null; ) {
        if (o.tag === 13)
          o.memoizedState !== null && cb(o, u, i);
        else if (o.tag === 19)
          cb(o, u, i);
        else if (o.child !== null) {
          o.child.return = o, o = o.child;
          continue;
        }
        if (o === i) break e;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === i)
            break e;
          o = o.return;
        }
        o.sibling.return = o.return, o = o.sibling;
      }
    switch (y) {
      case "forwards":
        for (u = i.child, y = null; u !== null; )
          o = u.alternate, o !== null && Ou(o) === null && (y = u), u = u.sibling;
        u = y, u === null ? (y = i.child, i.child = null) : (y = u.sibling, u.sibling = null), wp(
          i,
          !1,
          y,
          u,
          S,
          p
        );
        break;
      case "backwards":
      case "unstable_legacy-backwards":
        for (u = null, y = i.child, i.child = null; y !== null; ) {
          if (o = y.alternate, o !== null && Ou(o) === null) {
            i.child = y;
            break;
          }
          o = y.sibling, y.sibling = u, u = y, y = o;
        }
        wp(
          i,
          !0,
          u,
          null,
          S,
          p
        );
        break;
      case "together":
        wp(
          i,
          !1,
          null,
          null,
          void 0,
          p
        );
        break;
      default:
        i.memoizedState = null;
    }
    return i.child;
  }
  function Gr(o, i, u) {
    if (o !== null && (i.dependencies = o.dependencies), So |= i.lanes, (u & i.childLanes) === 0)
      if (o !== null) {
        if (Ja(
          o,
          i,
          u,
          !1
        ), (u & i.childLanes) === 0)
          return null;
      } else return null;
    if (o !== null && i.child !== o.child)
      throw Error(r(153));
    if (i.child !== null) {
      for (o = i.child, u = Br(o, o.pendingProps), i.child = u, u.return = i; o.sibling !== null; )
        o = o.sibling, u = u.sibling = Br(o, o.pendingProps), u.return = i;
      u.sibling = null;
    }
    return i.child;
  }
  function xp(o, i) {
    return (o.lanes & i) !== 0 ? !0 : (o = o.dependencies, !!(o !== null && bu(o)));
  }
  function sM(o, i, u) {
    switch (i.tag) {
      case 3:
        ie(i, i.stateNode.containerInfo), mo(i, It, o.memoizedState.cache), da();
        break;
      case 27:
      case 5:
        ge(i);
        break;
      case 4:
        ie(i, i.stateNode.containerInfo);
        break;
      case 10:
        mo(
          i,
          i.type,
          i.memoizedProps.value
        );
        break;
      case 31:
        if (i.memoizedState !== null)
          return i.flags |= 128, qf(i), null;
        break;
      case 13:
        var p = i.memoizedState;
        if (p !== null)
          return p.dehydrated !== null ? (yo(i), i.flags |= 128, null) : (u & i.child.childLanes) !== 0 ? ub(o, i, u) : (yo(i), o = Gr(
            o,
            i,
            u
          ), o !== null ? o.sibling : null);
        yo(i);
        break;
      case 19:
        var y = (o.flags & 128) !== 0;
        if (p = (u & i.childLanes) !== 0, p || (Ja(
          o,
          i,
          u,
          !1
        ), p = (u & i.childLanes) !== 0), y) {
          if (p)
            return db(
              o,
              i,
              u
            );
          i.flags |= 128;
        }
        if (y = i.memoizedState, y !== null && (y.rendering = null, y.tail = null, y.lastEffect = null), U(At, At.current), p) break;
        return null;
      case 22:
        return i.lanes = 0, rb(
          o,
          i,
          u,
          i.pendingProps
        );
      case 24:
        mo(i, It, o.memoizedState.cache);
    }
    return Gr(o, i, u);
  }
  function fb(o, i, u) {
    if (o !== null)
      if (o.memoizedProps !== i.pendingProps)
        zt = !0;
      else {
        if (!xp(o, u) && (i.flags & 128) === 0)
          return zt = !1, sM(
            o,
            i,
            u
          );
        zt = (o.flags & 131072) !== 0;
      }
    else
      zt = !1, Ke && (i.flags & 1048576) !== 0 && Hv(i, us, i.index);
    switch (i.lanes = 0, i.tag) {
      case 16:
        e: {
          var p = i.pendingProps;
          if (o = ha(i.elementType), i.type = o, typeof o == "function")
            Cf(o) ? (p = ba(o, p), i.tag = 1, i = sb(
              null,
              i,
              o,
              p,
              u
            )) : (i.tag = 0, i = mp(
              null,
              i,
              o,
              p,
              u
            ));
          else {
            if (o != null) {
              var y = o.$$typeof;
              if (y === O) {
                i.tag = 11, i = eb(
                  null,
                  i,
                  o,
                  p,
                  u
                );
                break e;
              } else if (y === R) {
                i.tag = 14, i = tb(
                  null,
                  i,
                  o,
                  p,
                  u
                );
                break e;
              }
            }
            throw i = L(o) || o, Error(r(306, i, ""));
          }
        }
        return i;
      case 0:
        return mp(
          o,
          i,
          i.type,
          i.pendingProps,
          u
        );
      case 1:
        return p = i.type, y = ba(
          p,
          i.pendingProps
        ), sb(
          o,
          i,
          p,
          y,
          u
        );
      case 3:
        e: {
          if (ie(
            i,
            i.stateNode.containerInfo
          ), o === null) throw Error(r(387));
          p = i.pendingProps;
          var S = i.memoizedState;
          y = S.element, Bf(o, i), vs(i, p, null, u);
          var j = i.memoizedState;
          if (p = j.cache, mo(i, It, p), p !== S.cache && If(
            i,
            [It],
            u,
            !0
          ), gs(), p = j.element, S.isDehydrated)
            if (S = {
              element: p,
              isDehydrated: !1,
              cache: j.cache
            }, i.updateQueue.baseState = S, i.memoizedState = S, i.flags & 256) {
              i = lb(
                o,
                i,
                p,
                u
              );
              break e;
            } else if (p !== y) {
              y = nr(
                Error(r(424)),
                i
              ), cs(y), i = lb(
                o,
                i,
                p,
                u
              );
              break e;
            } else
              for (o = i.stateNode.containerInfo, o.nodeType === 9 ? o = o.body : o = o.nodeName === "HTML" ? o.ownerDocument.body : o, yt = ir(o.firstChild), on = i, Ke = !0, fo = null, ar = !0, u = ry(
                i,
                null,
                p,
                u
              ), i.child = u; u; )
                u.flags = u.flags & -3 | 4096, u = u.sibling;
          else {
            if (da(), p === y) {
              i = Gr(
                o,
                i,
                u
              );
              break e;
            }
            sn(o, i, p, u);
          }
          i = i.child;
        }
        return i;
      case 26:
        return Tu(o, i), o === null ? (u = kw(
          i.type,
          null,
          i.pendingProps,
          null
        )) ? i.memoizedState = u : Ke || (u = i.type, o = i.pendingProps, p = tc(
          oe.current
        ).createElement(u), p[en] = i, p[yn] = o, ln(p, u, o), Wt(p), i.stateNode = p) : i.memoizedState = kw(
          i.type,
          o.memoizedProps,
          i.pendingProps,
          o.memoizedState
        ), null;
      case 27:
        return ge(i), o === null && Ke && (p = i.stateNode = ww(
          i.type,
          i.pendingProps,
          oe.current
        ), on = i, ar = !0, y = yt, Oo(i.type) ? (em = y, yt = ir(p.firstChild)) : yt = y), sn(
          o,
          i,
          i.pendingProps.children,
          u
        ), Tu(o, i), o === null && (i.flags |= 4194304), i.child;
      case 5:
        return o === null && Ke && ((y = p = yt) && (p = zM(
          p,
          i.type,
          i.pendingProps,
          ar
        ), p !== null ? (i.stateNode = p, on = i, yt = ir(p.firstChild), ar = !1, y = !0) : y = !1), y || po(i)), ge(i), y = i.type, S = i.pendingProps, j = o !== null ? o.memoizedProps : null, p = S.children, Yp(y, S) ? p = null : j !== null && Yp(y, j) && (i.flags |= 32), i.memoizedState !== null && (y = Kf(
          o,
          i,
          QO,
          null,
          null,
          u
        ), zs._currentValue = y), Tu(o, i), sn(o, i, p, u), i.child;
      case 6:
        return o === null && Ke && ((o = u = yt) && (u = TM(
          u,
          i.pendingProps,
          ar
        ), u !== null ? (i.stateNode = u, on = i, yt = null, o = !0) : o = !1), o || po(i)), null;
      case 13:
        return ub(o, i, u);
      case 4:
        return ie(
          i,
          i.stateNode.containerInfo
        ), p = i.pendingProps, o === null ? i.child = va(
          i,
          null,
          p,
          u
        ) : sn(o, i, p, u), i.child;
      case 11:
        return eb(
          o,
          i,
          i.type,
          i.pendingProps,
          u
        );
      case 7:
        return sn(
          o,
          i,
          i.pendingProps,
          u
        ), i.child;
      case 8:
        return sn(
          o,
          i,
          i.pendingProps.children,
          u
        ), i.child;
      case 12:
        return sn(
          o,
          i,
          i.pendingProps.children,
          u
        ), i.child;
      case 10:
        return p = i.pendingProps, mo(i, i.type, p.value), sn(o, i, p.children, u), i.child;
      case 9:
        return y = i.type._context, p = i.pendingProps.children, pa(i), y = an(y), p = p(y), i.flags |= 1, sn(o, i, p, u), i.child;
      case 14:
        return tb(
          o,
          i,
          i.type,
          i.pendingProps,
          u
        );
      case 15:
        return nb(
          o,
          i,
          i.type,
          i.pendingProps,
          u
        );
      case 19:
        return db(o, i, u);
      case 31:
        return iM(o, i, u);
      case 22:
        return rb(
          o,
          i,
          u,
          i.pendingProps
        );
      case 24:
        return pa(i), p = an(It), o === null ? (y = Tf(), y === null && (y = ut, S = $f(), y.pooledCache = S, S.refCount++, S !== null && (y.pooledCacheLanes |= u), y = S), i.memoizedState = { parent: p, cache: y }, Ff(i), mo(i, It, y)) : ((o.lanes & u) !== 0 && (Bf(o, i), vs(i, null, null, u), gs()), y = o.memoizedState, S = i.memoizedState, y.parent !== p ? (y = { parent: p, cache: p }, i.memoizedState = y, i.lanes === 0 && (i.memoizedState = i.updateQueue.baseState = y), mo(i, It, p)) : (p = S.cache, mo(i, It, p), p !== y.cache && If(
          i,
          [It],
          u,
          !0
        ))), sn(
          o,
          i,
          i.pendingProps.children,
          u
        ), i.child;
      case 29:
        throw i.pendingProps;
    }
    throw Error(r(156, i.tag));
  }
  function Kr(o) {
    o.flags |= 4;
  }
  function Sp(o, i, u, p, y) {
    if ((i = (o.mode & 32) !== 0) && (i = !1), i) {
      if (o.flags |= 16777216, (y & 335544128) === y)
        if (o.stateNode.complete) o.flags |= 8192;
        else if (Lb()) o.flags |= 8192;
        else
          throw ga = ku, Lf;
    } else o.flags &= -16777217;
  }
  function pb(o, i) {
    if (i.type !== "stylesheet" || (i.state.loading & 4) !== 0)
      o.flags &= -16777217;
    else if (o.flags |= 16777216, !Mw(i))
      if (Lb()) o.flags |= 8192;
      else
        throw ga = ku, Lf;
  }
  function Fu(o, i) {
    i !== null && (o.flags |= 4), o.flags & 16384 && (i = o.tag !== 22 ? qd() : 536870912, o.lanes |= i, ui |= i);
  }
  function ks(o, i) {
    if (!Ke)
      switch (o.tailMode) {
        case "hidden":
          i = o.tail;
          for (var u = null; i !== null; )
            i.alternate !== null && (u = i), i = i.sibling;
          u === null ? o.tail = null : u.sibling = null;
          break;
        case "collapsed":
          u = o.tail;
          for (var p = null; u !== null; )
            u.alternate !== null && (p = u), u = u.sibling;
          p === null ? i || o.tail === null ? o.tail = null : o.tail.sibling = null : p.sibling = null;
      }
  }
  function bt(o) {
    var i = o.alternate !== null && o.alternate.child === o.child, u = 0, p = 0;
    if (i)
      for (var y = o.child; y !== null; )
        u |= y.lanes | y.childLanes, p |= y.subtreeFlags & 65011712, p |= y.flags & 65011712, y.return = o, y = y.sibling;
    else
      for (y = o.child; y !== null; )
        u |= y.lanes | y.childLanes, p |= y.subtreeFlags, p |= y.flags, y.return = o, y = y.sibling;
    return o.subtreeFlags |= p, o.childLanes = u, i;
  }
  function lM(o, i, u) {
    var p = i.pendingProps;
    switch (Af(i), i.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return bt(i), null;
      case 1:
        return bt(i), null;
      case 3:
        return u = i.stateNode, p = null, o !== null && (p = o.memoizedState.cache), i.memoizedState.cache !== p && (i.flags |= 2048), Hr(It), ce(), u.pendingContext && (u.context = u.pendingContext, u.pendingContext = null), (o === null || o.child === null) && (Xa(i) ? Kr(i) : o === null || o.memoizedState.isDehydrated && (i.flags & 256) === 0 || (i.flags |= 1024, jf())), bt(i), null;
      case 26:
        var y = i.type, S = i.memoizedState;
        return o === null ? (Kr(i), S !== null ? (bt(i), pb(i, S)) : (bt(i), Sp(
          i,
          y,
          null,
          p,
          u
        ))) : S ? S !== o.memoizedState ? (Kr(i), bt(i), pb(i, S)) : (bt(i), i.flags &= -16777217) : (o = o.memoizedProps, o !== p && Kr(i), bt(i), Sp(
          i,
          y,
          o,
          p,
          u
        )), null;
      case 27:
        if (re(i), u = oe.current, y = i.type, o !== null && i.stateNode != null)
          o.memoizedProps !== p && Kr(i);
        else {
          if (!p) {
            if (i.stateNode === null)
              throw Error(r(166));
            return bt(i), null;
          }
          o = W.current, Xa(i) ? qv(i) : (o = ww(y, p, u), i.stateNode = o, Kr(i));
        }
        return bt(i), null;
      case 5:
        if (re(i), y = i.type, o !== null && i.stateNode != null)
          o.memoizedProps !== p && Kr(i);
        else {
          if (!p) {
            if (i.stateNode === null)
              throw Error(r(166));
            return bt(i), null;
          }
          if (S = W.current, Xa(i))
            qv(i);
          else {
            var j = tc(
              oe.current
            );
            switch (S) {
              case 1:
                S = j.createElementNS(
                  "http://www.w3.org/2000/svg",
                  y
                );
                break;
              case 2:
                S = j.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  y
                );
                break;
              default:
                switch (y) {
                  case "svg":
                    S = j.createElementNS(
                      "http://www.w3.org/2000/svg",
                      y
                    );
                    break;
                  case "math":
                    S = j.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      y
                    );
                    break;
                  case "script":
                    S = j.createElement("div"), S.innerHTML = "<script><\/script>", S = S.removeChild(
                      S.firstChild
                    );
                    break;
                  case "select":
                    S = typeof p.is == "string" ? j.createElement("select", {
                      is: p.is
                    }) : j.createElement("select"), p.multiple ? S.multiple = !0 : p.size && (S.size = p.size);
                    break;
                  default:
                    S = typeof p.is == "string" ? j.createElement(y, { is: p.is }) : j.createElement(y);
                }
            }
            S[en] = i, S[yn] = p;
            e: for (j = i.child; j !== null; ) {
              if (j.tag === 5 || j.tag === 6)
                S.appendChild(j.stateNode);
              else if (j.tag !== 4 && j.tag !== 27 && j.child !== null) {
                j.child.return = j, j = j.child;
                continue;
              }
              if (j === i) break e;
              for (; j.sibling === null; ) {
                if (j.return === null || j.return === i)
                  break e;
                j = j.return;
              }
              j.sibling.return = j.return, j = j.sibling;
            }
            i.stateNode = S;
            e: switch (ln(S, y, p), y) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                p = !!p.autoFocus;
                break e;
              case "img":
                p = !0;
                break e;
              default:
                p = !1;
            }
            p && Kr(i);
          }
        }
        return bt(i), Sp(
          i,
          i.type,
          o === null ? null : o.memoizedProps,
          i.pendingProps,
          u
        ), null;
      case 6:
        if (o && i.stateNode != null)
          o.memoizedProps !== p && Kr(i);
        else {
          if (typeof p != "string" && i.stateNode === null)
            throw Error(r(166));
          if (o = oe.current, Xa(i)) {
            if (o = i.stateNode, u = i.memoizedProps, p = null, y = on, y !== null)
              switch (y.tag) {
                case 27:
                case 5:
                  p = y.memoizedProps;
              }
            o[en] = i, o = !!(o.nodeValue === u || p !== null && p.suppressHydrationWarning === !0 || uw(o.nodeValue, u)), o || po(i, !0);
          } else
            o = tc(o).createTextNode(
              p
            ), o[en] = i, i.stateNode = o;
        }
        return bt(i), null;
      case 31:
        if (u = i.memoizedState, o === null || o.memoizedState !== null) {
          if (p = Xa(i), u !== null) {
            if (o === null) {
              if (!p) throw Error(r(318));
              if (o = i.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(r(557));
              o[en] = i;
            } else
              da(), (i.flags & 128) === 0 && (i.memoizedState = null), i.flags |= 4;
            bt(i), o = !1;
          } else
            u = jf(), o !== null && o.memoizedState !== null && (o.memoizedState.hydrationErrors = u), o = !0;
          if (!o)
            return i.flags & 256 ? (Hn(i), i) : (Hn(i), null);
          if ((i.flags & 128) !== 0)
            throw Error(r(558));
        }
        return bt(i), null;
      case 13:
        if (p = i.memoizedState, o === null || o.memoizedState !== null && o.memoizedState.dehydrated !== null) {
          if (y = Xa(i), p !== null && p.dehydrated !== null) {
            if (o === null) {
              if (!y) throw Error(r(318));
              if (y = i.memoizedState, y = y !== null ? y.dehydrated : null, !y) throw Error(r(317));
              y[en] = i;
            } else
              da(), (i.flags & 128) === 0 && (i.memoizedState = null), i.flags |= 4;
            bt(i), y = !1;
          } else
            y = jf(), o !== null && o.memoizedState !== null && (o.memoizedState.hydrationErrors = y), y = !0;
          if (!y)
            return i.flags & 256 ? (Hn(i), i) : (Hn(i), null);
        }
        return Hn(i), (i.flags & 128) !== 0 ? (i.lanes = u, i) : (u = p !== null, o = o !== null && o.memoizedState !== null, u && (p = i.child, y = null, p.alternate !== null && p.alternate.memoizedState !== null && p.alternate.memoizedState.cachePool !== null && (y = p.alternate.memoizedState.cachePool.pool), S = null, p.memoizedState !== null && p.memoizedState.cachePool !== null && (S = p.memoizedState.cachePool.pool), S !== y && (p.flags |= 2048)), u !== o && u && (i.child.flags |= 8192), Fu(i, i.updateQueue), bt(i), null);
      case 4:
        return ce(), o === null && Hp(i.stateNode.containerInfo), bt(i), null;
      case 10:
        return Hr(i.type), bt(i), null;
      case 19:
        if (Y(At), p = i.memoizedState, p === null) return bt(i), null;
        if (y = (i.flags & 128) !== 0, S = p.rendering, S === null)
          if (y) ks(p, !1);
          else {
            if (_t !== 0 || o !== null && (o.flags & 128) !== 0)
              for (o = i.child; o !== null; ) {
                if (S = Ou(o), S !== null) {
                  for (i.flags |= 128, ks(p, !1), o = S.updateQueue, i.updateQueue = o, Fu(i, o), i.subtreeFlags = 0, o = u, u = i.child; u !== null; )
                    Bv(u, o), u = u.sibling;
                  return U(
                    At,
                    At.current & 1 | 2
                  ), Ke && Ur(i, p.treeForkCount), i.child;
                }
                o = o.sibling;
              }
            p.tail !== null && Ce() > Wu && (i.flags |= 128, y = !0, ks(p, !1), i.lanes = 4194304);
          }
        else {
          if (!y)
            if (o = Ou(S), o !== null) {
              if (i.flags |= 128, y = !0, o = o.updateQueue, i.updateQueue = o, Fu(i, o), ks(p, !0), p.tail === null && p.tailMode === "hidden" && !S.alternate && !Ke)
                return bt(i), null;
            } else
              2 * Ce() - p.renderingStartTime > Wu && u !== 536870912 && (i.flags |= 128, y = !0, ks(p, !1), i.lanes = 4194304);
          p.isBackwards ? (S.sibling = i.child, i.child = S) : (o = p.last, o !== null ? o.sibling = S : i.child = S, p.last = S);
        }
        return p.tail !== null ? (o = p.tail, p.rendering = o, p.tail = o.sibling, p.renderingStartTime = Ce(), o.sibling = null, u = At.current, U(
          At,
          y ? u & 1 | 2 : u & 1
        ), Ke && Ur(i, p.treeForkCount), o) : (bt(i), null);
      case 22:
      case 23:
        return Hn(i), Wf(), p = i.memoizedState !== null, o !== null ? o.memoizedState !== null !== p && (i.flags |= 8192) : p && (i.flags |= 8192), p ? (u & 536870912) !== 0 && (i.flags & 128) === 0 && (bt(i), i.subtreeFlags & 6 && (i.flags |= 8192)) : bt(i), u = i.updateQueue, u !== null && Fu(i, u.retryQueue), u = null, o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (u = o.memoizedState.cachePool.pool), p = null, i.memoizedState !== null && i.memoizedState.cachePool !== null && (p = i.memoizedState.cachePool.pool), p !== u && (i.flags |= 2048), o !== null && Y(ma), null;
      case 24:
        return u = null, o !== null && (u = o.memoizedState.cache), i.memoizedState.cache !== u && (i.flags |= 2048), Hr(It), bt(i), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(r(156, i.tag));
  }
  function uM(o, i) {
    switch (Af(i), i.tag) {
      case 1:
        return o = i.flags, o & 65536 ? (i.flags = o & -65537 | 128, i) : null;
      case 3:
        return Hr(It), ce(), o = i.flags, (o & 65536) !== 0 && (o & 128) === 0 ? (i.flags = o & -65537 | 128, i) : null;
      case 26:
      case 27:
      case 5:
        return re(i), null;
      case 31:
        if (i.memoizedState !== null) {
          if (Hn(i), i.alternate === null)
            throw Error(r(340));
          da();
        }
        return o = i.flags, o & 65536 ? (i.flags = o & -65537 | 128, i) : null;
      case 13:
        if (Hn(i), o = i.memoizedState, o !== null && o.dehydrated !== null) {
          if (i.alternate === null)
            throw Error(r(340));
          da();
        }
        return o = i.flags, o & 65536 ? (i.flags = o & -65537 | 128, i) : null;
      case 19:
        return Y(At), null;
      case 4:
        return ce(), null;
      case 10:
        return Hr(i.type), null;
      case 22:
      case 23:
        return Hn(i), Wf(), o !== null && Y(ma), o = i.flags, o & 65536 ? (i.flags = o & -65537 | 128, i) : null;
      case 24:
        return Hr(It), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function mb(o, i) {
    switch (Af(i), i.tag) {
      case 3:
        Hr(It), ce();
        break;
      case 26:
      case 27:
      case 5:
        re(i);
        break;
      case 4:
        ce();
        break;
      case 31:
        i.memoizedState !== null && Hn(i);
        break;
      case 13:
        Hn(i);
        break;
      case 19:
        Y(At);
        break;
      case 10:
        Hr(i.type);
        break;
      case 22:
      case 23:
        Hn(i), Wf(), o !== null && Y(ma);
        break;
      case 24:
        Hr(It);
    }
  }
  function _s(o, i) {
    try {
      var u = i.updateQueue, p = u !== null ? u.lastEffect : null;
      if (p !== null) {
        var y = p.next;
        u = y;
        do {
          if ((u.tag & o) === o) {
            p = void 0;
            var S = u.create, j = u.inst;
            p = S(), j.destroy = p;
          }
          u = u.next;
        } while (u !== y);
      }
    } catch (T) {
      ot(i, i.return, T);
    }
  }
  function wo(o, i, u) {
    try {
      var p = i.updateQueue, y = p !== null ? p.lastEffect : null;
      if (y !== null) {
        var S = y.next;
        p = S;
        do {
          if ((p.tag & o) === o) {
            var j = p.inst, T = j.destroy;
            if (T !== void 0) {
              j.destroy = void 0, y = i;
              var X = u, ne = T;
              try {
                ne();
              } catch (ue) {
                ot(
                  y,
                  X,
                  ue
                );
              }
            }
          }
          p = p.next;
        } while (p !== S);
      }
    } catch (ue) {
      ot(i, i.return, ue);
    }
  }
  function hb(o) {
    var i = o.updateQueue;
    if (i !== null) {
      var u = o.stateNode;
      try {
        ay(i, u);
      } catch (p) {
        ot(o, o.return, p);
      }
    }
  }
  function gb(o, i, u) {
    u.props = ba(
      o.type,
      o.memoizedProps
    ), u.state = o.memoizedState;
    try {
      u.componentWillUnmount();
    } catch (p) {
      ot(o, i, p);
    }
  }
  function Es(o, i) {
    try {
      var u = o.ref;
      if (u !== null) {
        switch (o.tag) {
          case 26:
          case 27:
          case 5:
            var p = o.stateNode;
            break;
          case 30:
            p = o.stateNode;
            break;
          default:
            p = o.stateNode;
        }
        typeof u == "function" ? o.refCleanup = u(p) : u.current = p;
      }
    } catch (y) {
      ot(o, i, y);
    }
  }
  function Mr(o, i) {
    var u = o.ref, p = o.refCleanup;
    if (u !== null)
      if (typeof p == "function")
        try {
          p();
        } catch (y) {
          ot(o, i, y);
        } finally {
          o.refCleanup = null, o = o.alternate, o != null && (o.refCleanup = null);
        }
      else if (typeof u == "function")
        try {
          u(null);
        } catch (y) {
          ot(o, i, y);
        }
      else u.current = null;
  }
  function vb(o) {
    var i = o.type, u = o.memoizedProps, p = o.stateNode;
    try {
      e: switch (i) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          u.autoFocus && p.focus();
          break e;
        case "img":
          u.src ? p.src = u.src : u.srcSet && (p.srcset = u.srcSet);
      }
    } catch (y) {
      ot(o, o.return, y);
    }
  }
  function kp(o, i, u) {
    try {
      var p = o.stateNode;
      RM(p, o.type, u, i), p[yn] = i;
    } catch (y) {
      ot(o, o.return, y);
    }
  }
  function yb(o) {
    return o.tag === 5 || o.tag === 3 || o.tag === 26 || o.tag === 27 && Oo(o.type) || o.tag === 4;
  }
  function _p(o) {
    e: for (; ; ) {
      for (; o.sibling === null; ) {
        if (o.return === null || yb(o.return)) return null;
        o = o.return;
      }
      for (o.sibling.return = o.return, o = o.sibling; o.tag !== 5 && o.tag !== 6 && o.tag !== 18; ) {
        if (o.tag === 27 && Oo(o.type) || o.flags & 2 || o.child === null || o.tag === 4) continue e;
        o.child.return = o, o = o.child;
      }
      if (!(o.flags & 2)) return o.stateNode;
    }
  }
  function Ep(o, i, u) {
    var p = o.tag;
    if (p === 5 || p === 6)
      o = o.stateNode, i ? (u.nodeType === 9 ? u.body : u.nodeName === "HTML" ? u.ownerDocument.body : u).insertBefore(o, i) : (i = u.nodeType === 9 ? u.body : u.nodeName === "HTML" ? u.ownerDocument.body : u, i.appendChild(o), u = u._reactRootContainer, u != null || i.onclick !== null || (i.onclick = Lr));
    else if (p !== 4 && (p === 27 && Oo(o.type) && (u = o.stateNode, i = null), o = o.child, o !== null))
      for (Ep(o, i, u), o = o.sibling; o !== null; )
        Ep(o, i, u), o = o.sibling;
  }
  function Bu(o, i, u) {
    var p = o.tag;
    if (p === 5 || p === 6)
      o = o.stateNode, i ? u.insertBefore(o, i) : u.appendChild(o);
    else if (p !== 4 && (p === 27 && Oo(o.type) && (u = o.stateNode), o = o.child, o !== null))
      for (Bu(o, i, u), o = o.sibling; o !== null; )
        Bu(o, i, u), o = o.sibling;
  }
  function bb(o) {
    var i = o.stateNode, u = o.memoizedProps;
    try {
      for (var p = o.type, y = i.attributes; y.length; )
        i.removeAttributeNode(y[0]);
      ln(i, p, u), i[en] = o, i[yn] = u;
    } catch (S) {
      ot(o, o.return, S);
    }
  }
  var Yr = !1, Tt = !1, Cp = !1, wb = typeof WeakSet == "function" ? WeakSet : Set, tn = null;
  function cM(o, i) {
    if (o = o.containerInfo, Gp = lc, o = jv(o), bf(o)) {
      if ("selectionStart" in o)
        var u = {
          start: o.selectionStart,
          end: o.selectionEnd
        };
      else
        e: {
          u = (u = o.ownerDocument) && u.defaultView || window;
          var p = u.getSelection && u.getSelection();
          if (p && p.rangeCount !== 0) {
            u = p.anchorNode;
            var y = p.anchorOffset, S = p.focusNode;
            p = p.focusOffset;
            try {
              u.nodeType, S.nodeType;
            } catch {
              u = null;
              break e;
            }
            var j = 0, T = -1, X = -1, ne = 0, ue = 0, pe = o, ae = null;
            t: for (; ; ) {
              for (var se; pe !== u || y !== 0 && pe.nodeType !== 3 || (T = j + y), pe !== S || p !== 0 && pe.nodeType !== 3 || (X = j + p), pe.nodeType === 3 && (j += pe.nodeValue.length), (se = pe.firstChild) !== null; )
                ae = pe, pe = se;
              for (; ; ) {
                if (pe === o) break t;
                if (ae === u && ++ne === y && (T = j), ae === S && ++ue === p && (X = j), (se = pe.nextSibling) !== null) break;
                pe = ae, ae = pe.parentNode;
              }
              pe = se;
            }
            u = T === -1 || X === -1 ? null : { start: T, end: X };
          } else u = null;
        }
      u = u || { start: 0, end: 0 };
    } else u = null;
    for (Kp = { focusedElem: o, selectionRange: u }, lc = !1, tn = i; tn !== null; )
      if (i = tn, o = i.child, (i.subtreeFlags & 1028) !== 0 && o !== null)
        o.return = i, tn = o;
      else
        for (; tn !== null; ) {
          switch (i = tn, S = i.alternate, o = i.flags, i.tag) {
            case 0:
              if ((o & 4) !== 0 && (o = i.updateQueue, o = o !== null ? o.events : null, o !== null))
                for (u = 0; u < o.length; u++)
                  y = o[u], y.ref.impl = y.nextImpl;
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((o & 1024) !== 0 && S !== null) {
                o = void 0, u = i, y = S.memoizedProps, S = S.memoizedState, p = u.stateNode;
                try {
                  var we = ba(
                    u.type,
                    y
                  );
                  o = p.getSnapshotBeforeUpdate(
                    we,
                    S
                  ), p.__reactInternalSnapshotBeforeUpdate = o;
                } catch (Ne) {
                  ot(
                    u,
                    u.return,
                    Ne
                  );
                }
              }
              break;
            case 3:
              if ((o & 1024) !== 0) {
                if (o = i.stateNode.containerInfo, u = o.nodeType, u === 9)
                  Jp(o);
                else if (u === 1)
                  switch (o.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      Jp(o);
                      break;
                    default:
                      o.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((o & 1024) !== 0) throw Error(r(163));
          }
          if (o = i.sibling, o !== null) {
            o.return = i.return, tn = o;
            break;
          }
          tn = i.return;
        }
  }
  function xb(o, i, u) {
    var p = u.flags;
    switch (u.tag) {
      case 0:
      case 11:
      case 15:
        Jr(o, u), p & 4 && _s(5, u);
        break;
      case 1:
        if (Jr(o, u), p & 4)
          if (o = u.stateNode, i === null)
            try {
              o.componentDidMount();
            } catch (j) {
              ot(u, u.return, j);
            }
          else {
            var y = ba(
              u.type,
              i.memoizedProps
            );
            i = i.memoizedState;
            try {
              o.componentDidUpdate(
                y,
                i,
                o.__reactInternalSnapshotBeforeUpdate
              );
            } catch (j) {
              ot(
                u,
                u.return,
                j
              );
            }
          }
        p & 64 && hb(u), p & 512 && Es(u, u.return);
        break;
      case 3:
        if (Jr(o, u), p & 64 && (o = u.updateQueue, o !== null)) {
          if (i = null, u.child !== null)
            switch (u.child.tag) {
              case 27:
              case 5:
                i = u.child.stateNode;
                break;
              case 1:
                i = u.child.stateNode;
            }
          try {
            ay(o, i);
          } catch (j) {
            ot(u, u.return, j);
          }
        }
        break;
      case 27:
        i === null && p & 4 && bb(u);
      case 26:
      case 5:
        Jr(o, u), i === null && p & 4 && vb(u), p & 512 && Es(u, u.return);
        break;
      case 12:
        Jr(o, u);
        break;
      case 31:
        Jr(o, u), p & 4 && _b(o, u);
        break;
      case 13:
        Jr(o, u), p & 4 && Eb(o, u), p & 64 && (o = u.memoizedState, o !== null && (o = o.dehydrated, o !== null && (u = bM.bind(
          null,
          u
        ), LM(o, u))));
        break;
      case 22:
        if (p = u.memoizedState !== null || Yr, !p) {
          i = i !== null && i.memoizedState !== null || Tt, y = Yr;
          var S = Tt;
          Yr = p, (Tt = i) && !S ? Qr(
            o,
            u,
            (u.subtreeFlags & 8772) !== 0
          ) : Jr(o, u), Yr = y, Tt = S;
        }
        break;
      case 30:
        break;
      default:
        Jr(o, u);
    }
  }
  function Sb(o) {
    var i = o.alternate;
    i !== null && (o.alternate = null, Sb(i)), o.child = null, o.deletions = null, o.sibling = null, o.tag === 5 && (i = o.stateNode, i !== null && ou(i)), o.stateNode = null, o.return = null, o.dependencies = null, o.memoizedProps = null, o.memoizedState = null, o.pendingProps = null, o.stateNode = null, o.updateQueue = null;
  }
  var wt = null, Nn = !1;
  function Xr(o, i, u) {
    for (u = u.child; u !== null; )
      kb(o, i, u), u = u.sibling;
  }
  function kb(o, i, u) {
    if (Nt && typeof Nt.onCommitFiberUnmount == "function")
      try {
        Nt.onCommitFiberUnmount(Xt, u);
      } catch {
      }
    switch (u.tag) {
      case 26:
        Tt || Mr(u, i), Xr(
          o,
          i,
          u
        ), u.memoizedState ? u.memoizedState.count-- : u.stateNode && (u = u.stateNode, u.parentNode.removeChild(u));
        break;
      case 27:
        Tt || Mr(u, i);
        var p = wt, y = Nn;
        Oo(u.type) && (wt = u.stateNode, Nn = !1), Xr(
          o,
          i,
          u
        ), Ds(u.stateNode), wt = p, Nn = y;
        break;
      case 5:
        Tt || Mr(u, i);
      case 6:
        if (p = wt, y = Nn, wt = null, Xr(
          o,
          i,
          u
        ), wt = p, Nn = y, wt !== null)
          if (Nn)
            try {
              (wt.nodeType === 9 ? wt.body : wt.nodeName === "HTML" ? wt.ownerDocument.body : wt).removeChild(u.stateNode);
            } catch (S) {
              ot(
                u,
                i,
                S
              );
            }
          else
            try {
              wt.removeChild(u.stateNode);
            } catch (S) {
              ot(
                u,
                i,
                S
              );
            }
        break;
      case 18:
        wt !== null && (Nn ? (o = wt, hw(
          o.nodeType === 9 ? o.body : o.nodeName === "HTML" ? o.ownerDocument.body : o,
          u.stateNode
        ), vi(o)) : hw(wt, u.stateNode));
        break;
      case 4:
        p = wt, y = Nn, wt = u.stateNode.containerInfo, Nn = !0, Xr(
          o,
          i,
          u
        ), wt = p, Nn = y;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        wo(2, u, i), Tt || wo(4, u, i), Xr(
          o,
          i,
          u
        );
        break;
      case 1:
        Tt || (Mr(u, i), p = u.stateNode, typeof p.componentWillUnmount == "function" && gb(
          u,
          i,
          p
        )), Xr(
          o,
          i,
          u
        );
        break;
      case 21:
        Xr(
          o,
          i,
          u
        );
        break;
      case 22:
        Tt = (p = Tt) || u.memoizedState !== null, Xr(
          o,
          i,
          u
        ), Tt = p;
        break;
      default:
        Xr(
          o,
          i,
          u
        );
    }
  }
  function _b(o, i) {
    if (i.memoizedState === null && (o = i.alternate, o !== null && (o = o.memoizedState, o !== null))) {
      o = o.dehydrated;
      try {
        vi(o);
      } catch (u) {
        ot(i, i.return, u);
      }
    }
  }
  function Eb(o, i) {
    if (i.memoizedState === null && (o = i.alternate, o !== null && (o = o.memoizedState, o !== null && (o = o.dehydrated, o !== null))))
      try {
        vi(o);
      } catch (u) {
        ot(i, i.return, u);
      }
  }
  function dM(o) {
    switch (o.tag) {
      case 31:
      case 13:
      case 19:
        var i = o.stateNode;
        return i === null && (i = o.stateNode = new wb()), i;
      case 22:
        return o = o.stateNode, i = o._retryCache, i === null && (i = o._retryCache = new wb()), i;
      default:
        throw Error(r(435, o.tag));
    }
  }
  function Uu(o, i) {
    var u = dM(o);
    i.forEach(function(p) {
      if (!u.has(p)) {
        u.add(p);
        var y = wM.bind(null, o, p);
        p.then(y, y);
      }
    });
  }
  function An(o, i) {
    var u = i.deletions;
    if (u !== null)
      for (var p = 0; p < u.length; p++) {
        var y = u[p], S = o, j = i, T = j;
        e: for (; T !== null; ) {
          switch (T.tag) {
            case 27:
              if (Oo(T.type)) {
                wt = T.stateNode, Nn = !1;
                break e;
              }
              break;
            case 5:
              wt = T.stateNode, Nn = !1;
              break e;
            case 3:
            case 4:
              wt = T.stateNode.containerInfo, Nn = !0;
              break e;
          }
          T = T.return;
        }
        if (wt === null) throw Error(r(160));
        kb(S, j, y), wt = null, Nn = !1, S = y.alternate, S !== null && (S.return = null), y.return = null;
      }
    if (i.subtreeFlags & 13886)
      for (i = i.child; i !== null; )
        Cb(i, o), i = i.sibling;
  }
  var br = null;
  function Cb(o, i) {
    var u = o.alternate, p = o.flags;
    switch (o.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        An(i, o), Rn(o), p & 4 && (wo(3, o, o.return), _s(3, o), wo(5, o, o.return));
        break;
      case 1:
        An(i, o), Rn(o), p & 512 && (Tt || u === null || Mr(u, u.return)), p & 64 && Yr && (o = o.updateQueue, o !== null && (p = o.callbacks, p !== null && (u = o.shared.hiddenCallbacks, o.shared.hiddenCallbacks = u === null ? p : u.concat(p))));
        break;
      case 26:
        var y = br;
        if (An(i, o), Rn(o), p & 512 && (Tt || u === null || Mr(u, u.return)), p & 4) {
          var S = u !== null ? u.memoizedState : null;
          if (p = o.memoizedState, u === null)
            if (p === null)
              if (o.stateNode === null) {
                e: {
                  p = o.type, u = o.memoizedProps, y = y.ownerDocument || y;
                  t: switch (p) {
                    case "title":
                      S = y.getElementsByTagName("title")[0], (!S || S[La] || S[en] || S.namespaceURI === "http://www.w3.org/2000/svg" || S.hasAttribute("itemprop")) && (S = y.createElement(p), y.head.insertBefore(
                        S,
                        y.querySelector("head > title")
                      )), ln(S, p, u), S[en] = o, Wt(S), p = S;
                      break e;
                    case "link":
                      var j = Cw(
                        "link",
                        "href",
                        y
                      ).get(p + (u.href || ""));
                      if (j) {
                        for (var T = 0; T < j.length; T++)
                          if (S = j[T], S.getAttribute("href") === (u.href == null || u.href === "" ? null : u.href) && S.getAttribute("rel") === (u.rel == null ? null : u.rel) && S.getAttribute("title") === (u.title == null ? null : u.title) && S.getAttribute("crossorigin") === (u.crossOrigin == null ? null : u.crossOrigin)) {
                            j.splice(T, 1);
                            break t;
                          }
                      }
                      S = y.createElement(p), ln(S, p, u), y.head.appendChild(S);
                      break;
                    case "meta":
                      if (j = Cw(
                        "meta",
                        "content",
                        y
                      ).get(p + (u.content || ""))) {
                        for (T = 0; T < j.length; T++)
                          if (S = j[T], S.getAttribute("content") === (u.content == null ? null : "" + u.content) && S.getAttribute("name") === (u.name == null ? null : u.name) && S.getAttribute("property") === (u.property == null ? null : u.property) && S.getAttribute("http-equiv") === (u.httpEquiv == null ? null : u.httpEquiv) && S.getAttribute("charset") === (u.charSet == null ? null : u.charSet)) {
                            j.splice(T, 1);
                            break t;
                          }
                      }
                      S = y.createElement(p), ln(S, p, u), y.head.appendChild(S);
                      break;
                    default:
                      throw Error(r(468, p));
                  }
                  S[en] = o, Wt(S), p = S;
                }
                o.stateNode = p;
              } else
                Ow(
                  y,
                  o.type,
                  o.stateNode
                );
            else
              o.stateNode = Ew(
                y,
                p,
                o.memoizedProps
              );
          else
            S !== p ? (S === null ? u.stateNode !== null && (u = u.stateNode, u.parentNode.removeChild(u)) : S.count--, p === null ? Ow(
              y,
              o.type,
              o.stateNode
            ) : Ew(
              y,
              p,
              o.memoizedProps
            )) : p === null && o.stateNode !== null && kp(
              o,
              o.memoizedProps,
              u.memoizedProps
            );
        }
        break;
      case 27:
        An(i, o), Rn(o), p & 512 && (Tt || u === null || Mr(u, u.return)), u !== null && p & 4 && kp(
          o,
          o.memoizedProps,
          u.memoizedProps
        );
        break;
      case 5:
        if (An(i, o), Rn(o), p & 512 && (Tt || u === null || Mr(u, u.return)), o.flags & 32) {
          y = o.stateNode;
          try {
            Fa(y, "");
          } catch (we) {
            ot(o, o.return, we);
          }
        }
        p & 4 && o.stateNode != null && (y = o.memoizedProps, kp(
          o,
          y,
          u !== null ? u.memoizedProps : y
        )), p & 1024 && (Cp = !0);
        break;
      case 6:
        if (An(i, o), Rn(o), p & 4) {
          if (o.stateNode === null)
            throw Error(r(162));
          p = o.memoizedProps, u = o.stateNode;
          try {
            u.nodeValue = p;
          } catch (we) {
            ot(o, o.return, we);
          }
        }
        break;
      case 3:
        if (oc = null, y = br, br = nc(i.containerInfo), An(i, o), br = y, Rn(o), p & 4 && u !== null && u.memoizedState.isDehydrated)
          try {
            vi(i.containerInfo);
          } catch (we) {
            ot(o, o.return, we);
          }
        Cp && (Cp = !1, Ob(o));
        break;
      case 4:
        p = br, br = nc(
          o.stateNode.containerInfo
        ), An(i, o), Rn(o), br = p;
        break;
      case 12:
        An(i, o), Rn(o);
        break;
      case 31:
        An(i, o), Rn(o), p & 4 && (p = o.updateQueue, p !== null && (o.updateQueue = null, Uu(o, p)));
        break;
      case 13:
        An(i, o), Rn(o), o.child.flags & 8192 && o.memoizedState !== null != (u !== null && u.memoizedState !== null) && (Hu = Ce()), p & 4 && (p = o.updateQueue, p !== null && (o.updateQueue = null, Uu(o, p)));
        break;
      case 22:
        y = o.memoizedState !== null;
        var X = u !== null && u.memoizedState !== null, ne = Yr, ue = Tt;
        if (Yr = ne || y, Tt = ue || X, An(i, o), Tt = ue, Yr = ne, Rn(o), p & 8192)
          e: for (i = o.stateNode, i._visibility = y ? i._visibility & -2 : i._visibility | 1, y && (u === null || X || Yr || Tt || wa(o)), u = null, i = o; ; ) {
            if (i.tag === 5 || i.tag === 26) {
              if (u === null) {
                X = u = i;
                try {
                  if (S = X.stateNode, y)
                    j = S.style, typeof j.setProperty == "function" ? j.setProperty("display", "none", "important") : j.display = "none";
                  else {
                    T = X.stateNode;
                    var pe = X.memoizedProps.style, ae = pe != null && pe.hasOwnProperty("display") ? pe.display : null;
                    T.style.display = ae == null || typeof ae == "boolean" ? "" : ("" + ae).trim();
                  }
                } catch (we) {
                  ot(X, X.return, we);
                }
              }
            } else if (i.tag === 6) {
              if (u === null) {
                X = i;
                try {
                  X.stateNode.nodeValue = y ? "" : X.memoizedProps;
                } catch (we) {
                  ot(X, X.return, we);
                }
              }
            } else if (i.tag === 18) {
              if (u === null) {
                X = i;
                try {
                  var se = X.stateNode;
                  y ? gw(se, !0) : gw(X.stateNode, !1);
                } catch (we) {
                  ot(X, X.return, we);
                }
              }
            } else if ((i.tag !== 22 && i.tag !== 23 || i.memoizedState === null || i === o) && i.child !== null) {
              i.child.return = i, i = i.child;
              continue;
            }
            if (i === o) break e;
            for (; i.sibling === null; ) {
              if (i.return === null || i.return === o) break e;
              u === i && (u = null), i = i.return;
            }
            u === i && (u = null), i.sibling.return = i.return, i = i.sibling;
          }
        p & 4 && (p = o.updateQueue, p !== null && (u = p.retryQueue, u !== null && (p.retryQueue = null, Uu(o, u))));
        break;
      case 19:
        An(i, o), Rn(o), p & 4 && (p = o.updateQueue, p !== null && (o.updateQueue = null, Uu(o, p)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        An(i, o), Rn(o);
    }
  }
  function Rn(o) {
    var i = o.flags;
    if (i & 2) {
      try {
        for (var u, p = o.return; p !== null; ) {
          if (yb(p)) {
            u = p;
            break;
          }
          p = p.return;
        }
        if (u == null) throw Error(r(160));
        switch (u.tag) {
          case 27:
            var y = u.stateNode, S = _p(o);
            Bu(o, S, y);
            break;
          case 5:
            var j = u.stateNode;
            u.flags & 32 && (Fa(j, ""), u.flags &= -33);
            var T = _p(o);
            Bu(o, T, j);
            break;
          case 3:
          case 4:
            var X = u.stateNode.containerInfo, ne = _p(o);
            Ep(
              o,
              ne,
              X
            );
            break;
          default:
            throw Error(r(161));
        }
      } catch (ue) {
        ot(o, o.return, ue);
      }
      o.flags &= -3;
    }
    i & 4096 && (o.flags &= -4097);
  }
  function Ob(o) {
    if (o.subtreeFlags & 1024)
      for (o = o.child; o !== null; ) {
        var i = o;
        Ob(i), i.tag === 5 && i.flags & 1024 && i.stateNode.reset(), o = o.sibling;
      }
  }
  function Jr(o, i) {
    if (i.subtreeFlags & 8772)
      for (i = i.child; i !== null; )
        xb(o, i.alternate, i), i = i.sibling;
  }
  function wa(o) {
    for (o = o.child; o !== null; ) {
      var i = o;
      switch (i.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          wo(4, i, i.return), wa(i);
          break;
        case 1:
          Mr(i, i.return);
          var u = i.stateNode;
          typeof u.componentWillUnmount == "function" && gb(
            i,
            i.return,
            u
          ), wa(i);
          break;
        case 27:
          Ds(i.stateNode);
        case 26:
        case 5:
          Mr(i, i.return), wa(i);
          break;
        case 22:
          i.memoizedState === null && wa(i);
          break;
        case 30:
          wa(i);
          break;
        default:
          wa(i);
      }
      o = o.sibling;
    }
  }
  function Qr(o, i, u) {
    for (u = u && (i.subtreeFlags & 8772) !== 0, i = i.child; i !== null; ) {
      var p = i.alternate, y = o, S = i, j = S.flags;
      switch (S.tag) {
        case 0:
        case 11:
        case 15:
          Qr(
            y,
            S,
            u
          ), _s(4, S);
          break;
        case 1:
          if (Qr(
            y,
            S,
            u
          ), p = S, y = p.stateNode, typeof y.componentDidMount == "function")
            try {
              y.componentDidMount();
            } catch (ne) {
              ot(p, p.return, ne);
            }
          if (p = S, y = p.updateQueue, y !== null) {
            var T = p.stateNode;
            try {
              var X = y.shared.hiddenCallbacks;
              if (X !== null)
                for (y.shared.hiddenCallbacks = null, y = 0; y < X.length; y++)
                  oy(X[y], T);
            } catch (ne) {
              ot(p, p.return, ne);
            }
          }
          u && j & 64 && hb(S), Es(S, S.return);
          break;
        case 27:
          bb(S);
        case 26:
        case 5:
          Qr(
            y,
            S,
            u
          ), u && p === null && j & 4 && vb(S), Es(S, S.return);
          break;
        case 12:
          Qr(
            y,
            S,
            u
          );
          break;
        case 31:
          Qr(
            y,
            S,
            u
          ), u && j & 4 && _b(y, S);
          break;
        case 13:
          Qr(
            y,
            S,
            u
          ), u && j & 4 && Eb(y, S);
          break;
        case 22:
          S.memoizedState === null && Qr(
            y,
            S,
            u
          ), Es(S, S.return);
          break;
        case 30:
          break;
        default:
          Qr(
            y,
            S,
            u
          );
      }
      i = i.sibling;
    }
  }
  function Op(o, i) {
    var u = null;
    o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (u = o.memoizedState.cachePool.pool), o = null, i.memoizedState !== null && i.memoizedState.cachePool !== null && (o = i.memoizedState.cachePool.pool), o !== u && (o != null && o.refCount++, u != null && ds(u));
  }
  function Mp(o, i) {
    o = null, i.alternate !== null && (o = i.alternate.memoizedState.cache), i = i.memoizedState.cache, i !== o && (i.refCount++, o != null && ds(o));
  }
  function wr(o, i, u, p) {
    if (i.subtreeFlags & 10256)
      for (i = i.child; i !== null; )
        Mb(
          o,
          i,
          u,
          p
        ), i = i.sibling;
  }
  function Mb(o, i, u, p) {
    var y = i.flags;
    switch (i.tag) {
      case 0:
      case 11:
      case 15:
        wr(
          o,
          i,
          u,
          p
        ), y & 2048 && _s(9, i);
        break;
      case 1:
        wr(
          o,
          i,
          u,
          p
        );
        break;
      case 3:
        wr(
          o,
          i,
          u,
          p
        ), y & 2048 && (o = null, i.alternate !== null && (o = i.alternate.memoizedState.cache), i = i.memoizedState.cache, i !== o && (i.refCount++, o != null && ds(o)));
        break;
      case 12:
        if (y & 2048) {
          wr(
            o,
            i,
            u,
            p
          ), o = i.stateNode;
          try {
            var S = i.memoizedProps, j = S.id, T = S.onPostCommit;
            typeof T == "function" && T(
              j,
              i.alternate === null ? "mount" : "update",
              o.passiveEffectDuration,
              -0
            );
          } catch (X) {
            ot(i, i.return, X);
          }
        } else
          wr(
            o,
            i,
            u,
            p
          );
        break;
      case 31:
        wr(
          o,
          i,
          u,
          p
        );
        break;
      case 13:
        wr(
          o,
          i,
          u,
          p
        );
        break;
      case 23:
        break;
      case 22:
        S = i.stateNode, j = i.alternate, i.memoizedState !== null ? S._visibility & 2 ? wr(
          o,
          i,
          u,
          p
        ) : Cs(o, i) : S._visibility & 2 ? wr(
          o,
          i,
          u,
          p
        ) : (S._visibility |= 2, ii(
          o,
          i,
          u,
          p,
          (i.subtreeFlags & 10256) !== 0 || !1
        )), y & 2048 && Op(j, i);
        break;
      case 24:
        wr(
          o,
          i,
          u,
          p
        ), y & 2048 && Mp(i.alternate, i);
        break;
      default:
        wr(
          o,
          i,
          u,
          p
        );
    }
  }
  function ii(o, i, u, p, y) {
    for (y = y && ((i.subtreeFlags & 10256) !== 0 || !1), i = i.child; i !== null; ) {
      var S = o, j = i, T = u, X = p, ne = j.flags;
      switch (j.tag) {
        case 0:
        case 11:
        case 15:
          ii(
            S,
            j,
            T,
            X,
            y
          ), _s(8, j);
          break;
        case 23:
          break;
        case 22:
          var ue = j.stateNode;
          j.memoizedState !== null ? ue._visibility & 2 ? ii(
            S,
            j,
            T,
            X,
            y
          ) : Cs(
            S,
            j
          ) : (ue._visibility |= 2, ii(
            S,
            j,
            T,
            X,
            y
          )), y && ne & 2048 && Op(
            j.alternate,
            j
          );
          break;
        case 24:
          ii(
            S,
            j,
            T,
            X,
            y
          ), y && ne & 2048 && Mp(j.alternate, j);
          break;
        default:
          ii(
            S,
            j,
            T,
            X,
            y
          );
      }
      i = i.sibling;
    }
  }
  function Cs(o, i) {
    if (i.subtreeFlags & 10256)
      for (i = i.child; i !== null; ) {
        var u = o, p = i, y = p.flags;
        switch (p.tag) {
          case 22:
            Cs(u, p), y & 2048 && Op(
              p.alternate,
              p
            );
            break;
          case 24:
            Cs(u, p), y & 2048 && Mp(p.alternate, p);
            break;
          default:
            Cs(u, p);
        }
        i = i.sibling;
      }
  }
  var Os = 8192;
  function si(o, i, u) {
    if (o.subtreeFlags & Os)
      for (o = o.child; o !== null; )
        Nb(
          o,
          i,
          u
        ), o = o.sibling;
  }
  function Nb(o, i, u) {
    switch (o.tag) {
      case 26:
        si(
          o,
          i,
          u
        ), o.flags & Os && o.memoizedState !== null && JM(
          u,
          br,
          o.memoizedState,
          o.memoizedProps
        );
        break;
      case 5:
        si(
          o,
          i,
          u
        );
        break;
      case 3:
      case 4:
        var p = br;
        br = nc(o.stateNode.containerInfo), si(
          o,
          i,
          u
        ), br = p;
        break;
      case 22:
        o.memoizedState === null && (p = o.alternate, p !== null && p.memoizedState !== null ? (p = Os, Os = 16777216, si(
          o,
          i,
          u
        ), Os = p) : si(
          o,
          i,
          u
        ));
        break;
      default:
        si(
          o,
          i,
          u
        );
    }
  }
  function Ab(o) {
    var i = o.alternate;
    if (i !== null && (o = i.child, o !== null)) {
      i.child = null;
      do
        i = o.sibling, o.sibling = null, o = i;
      while (o !== null);
    }
  }
  function Ms(o) {
    var i = o.deletions;
    if ((o.flags & 16) !== 0) {
      if (i !== null)
        for (var u = 0; u < i.length; u++) {
          var p = i[u];
          tn = p, jb(
            p,
            o
          );
        }
      Ab(o);
    }
    if (o.subtreeFlags & 10256)
      for (o = o.child; o !== null; )
        Rb(o), o = o.sibling;
  }
  function Rb(o) {
    switch (o.tag) {
      case 0:
      case 11:
      case 15:
        Ms(o), o.flags & 2048 && wo(9, o, o.return);
        break;
      case 3:
        Ms(o);
        break;
      case 12:
        Ms(o);
        break;
      case 22:
        var i = o.stateNode;
        o.memoizedState !== null && i._visibility & 2 && (o.return === null || o.return.tag !== 13) ? (i._visibility &= -3, Vu(o)) : Ms(o);
        break;
      default:
        Ms(o);
    }
  }
  function Vu(o) {
    var i = o.deletions;
    if ((o.flags & 16) !== 0) {
      if (i !== null)
        for (var u = 0; u < i.length; u++) {
          var p = i[u];
          tn = p, jb(
            p,
            o
          );
        }
      Ab(o);
    }
    for (o = o.child; o !== null; ) {
      switch (i = o, i.tag) {
        case 0:
        case 11:
        case 15:
          wo(8, i, i.return), Vu(i);
          break;
        case 22:
          u = i.stateNode, u._visibility & 2 && (u._visibility &= -3, Vu(i));
          break;
        default:
          Vu(i);
      }
      o = o.sibling;
    }
  }
  function jb(o, i) {
    for (; tn !== null; ) {
      var u = tn;
      switch (u.tag) {
        case 0:
        case 11:
        case 15:
          wo(8, u, i);
          break;
        case 23:
        case 22:
          if (u.memoizedState !== null && u.memoizedState.cachePool !== null) {
            var p = u.memoizedState.cachePool.pool;
            p != null && p.refCount++;
          }
          break;
        case 24:
          ds(u.memoizedState.cache);
      }
      if (p = u.child, p !== null) p.return = u, tn = p;
      else
        e: for (u = o; tn !== null; ) {
          p = tn;
          var y = p.sibling, S = p.return;
          if (Sb(p), p === u) {
            tn = null;
            break e;
          }
          if (y !== null) {
            y.return = S, tn = y;
            break e;
          }
          tn = S;
        }
    }
  }
  var fM = {
    getCacheForType: function(o) {
      var i = an(It), u = i.data.get(o);
      return u === void 0 && (u = o(), i.data.set(o, u)), u;
    },
    cacheSignal: function() {
      return an(It).controller.signal;
    }
  }, pM = typeof WeakMap == "function" ? WeakMap : Map, Ze = 0, ut = null, Be = null, He = 0, rt = 0, Wn = null, xo = !1, li = !1, Np = !1, Zr = 0, _t = 0, So = 0, xa = 0, Ap = 0, qn = 0, ui = 0, Ns = null, jn = null, Rp = !1, Hu = 0, Pb = 0, Wu = 1 / 0, qu = null, ko = null, qt = 0, _o = null, ci = null, eo = 0, jp = 0, Pp = null, Db = null, As = 0, Dp = null;
  function Gn() {
    return (Ze & 2) !== 0 && He !== 0 ? He & -He : $.T !== null ? Fp() : Xd();
  }
  function Ib() {
    if (qn === 0)
      if ((He & 536870912) === 0 || Ke) {
        var o = hn;
        hn <<= 1, (hn & 3932160) === 0 && (hn = 262144), qn = o;
      } else qn = 536870912;
    return o = Vn.current, o !== null && (o.flags |= 32), qn;
  }
  function Pn(o, i, u) {
    (o === ut && (rt === 2 || rt === 9) || o.cancelPendingCommit !== null) && (di(o, 0), Eo(
      o,
      He,
      qn,
      !1
    )), Ta(o, u), ((Ze & 2) === 0 || o !== ut) && (o === ut && ((Ze & 2) === 0 && (xa |= u), _t === 4 && Eo(
      o,
      He,
      qn,
      !1
    )), Nr(o));
  }
  function $b(o, i, u) {
    if ((Ze & 6) !== 0) throw Error(r(327));
    var p = !u && (i & 127) === 0 && (i & o.expiredLanes) === 0 || vr(o, i), y = p ? gM(o, i) : $p(o, i, !0), S = p;
    do {
      if (y === 0) {
        li && !p && Eo(o, i, 0, !1);
        break;
      } else {
        if (u = o.current.alternate, S && !mM(u)) {
          y = $p(o, i, !1), S = !1;
          continue;
        }
        if (y === 2) {
          if (S = i, o.errorRecoveryDisabledLanes & S)
            var j = 0;
          else
            j = o.pendingLanes & -536870913, j = j !== 0 ? j : j & 536870912 ? 536870912 : 0;
          if (j !== 0) {
            i = j;
            e: {
              var T = o;
              y = Ns;
              var X = T.current.memoizedState.isDehydrated;
              if (X && (di(T, j).flags |= 256), j = $p(
                T,
                j,
                !1
              ), j !== 2) {
                if (Np && !X) {
                  T.errorRecoveryDisabledLanes |= S, xa |= S, y = 4;
                  break e;
                }
                S = jn, jn = y, S !== null && (jn === null ? jn = S : jn.push.apply(
                  jn,
                  S
                ));
              }
              y = j;
            }
            if (S = !1, y !== 2) continue;
          }
        }
        if (y === 1) {
          di(o, 0), Eo(o, i, 0, !0);
          break;
        }
        e: {
          switch (p = o, S = y, S) {
            case 0:
            case 1:
              throw Error(r(345));
            case 4:
              if ((i & 4194048) !== i) break;
            case 6:
              Eo(
                p,
                i,
                qn,
                !xo
              );
              break e;
            case 2:
              jn = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(r(329));
          }
          if ((i & 62914560) === i && (y = Hu + 300 - Ce(), 10 < y)) {
            if (Eo(
              p,
              i,
              qn,
              !xo
            ), Vo(p, 0, !0) !== 0) break e;
            eo = i, p.timeoutHandle = pw(
              zb.bind(
                null,
                p,
                u,
                jn,
                qu,
                Rp,
                i,
                qn,
                xa,
                ui,
                xo,
                S,
                "Throttled",
                -0,
                0
              ),
              y
            );
            break e;
          }
          zb(
            p,
            u,
            jn,
            qu,
            Rp,
            i,
            qn,
            xa,
            ui,
            xo,
            S,
            null,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    Nr(o);
  }
  function zb(o, i, u, p, y, S, j, T, X, ne, ue, pe, ae, se) {
    if (o.timeoutHandle = -1, pe = i.subtreeFlags, pe & 8192 || (pe & 16785408) === 16785408) {
      pe = {
        stylesheets: null,
        count: 0,
        imgCount: 0,
        imgBytes: 0,
        suspenseyImages: [],
        waitingForImages: !0,
        waitingForViewTransition: !1,
        unsuspend: Lr
      }, Nb(
        i,
        S,
        pe
      );
      var we = (S & 62914560) === S ? Hu - Ce() : (S & 4194048) === S ? Pb - Ce() : 0;
      if (we = QM(
        pe,
        we
      ), we !== null) {
        eo = S, o.cancelPendingCommit = we(
          Wb.bind(
            null,
            o,
            i,
            S,
            u,
            p,
            y,
            j,
            T,
            X,
            ue,
            pe,
            null,
            ae,
            se
          )
        ), Eo(o, S, j, !ne);
        return;
      }
    }
    Wb(
      o,
      i,
      S,
      u,
      p,
      y,
      j,
      T,
      X
    );
  }
  function mM(o) {
    for (var i = o; ; ) {
      var u = i.tag;
      if ((u === 0 || u === 11 || u === 15) && i.flags & 16384 && (u = i.updateQueue, u !== null && (u = u.stores, u !== null)))
        for (var p = 0; p < u.length; p++) {
          var y = u[p], S = y.getSnapshot;
          y = y.value;
          try {
            if (!Bn(S(), y)) return !1;
          } catch {
            return !1;
          }
        }
      if (u = i.child, i.subtreeFlags & 16384 && u !== null)
        u.return = i, i = u;
      else {
        if (i === o) break;
        for (; i.sibling === null; ) {
          if (i.return === null || i.return === o) return !0;
          i = i.return;
        }
        i.sibling.return = i.return, i = i.sibling;
      }
    }
    return !0;
  }
  function Eo(o, i, u, p) {
    i &= ~Ap, i &= ~xa, o.suspendedLanes |= i, o.pingedLanes &= ~i, p && (o.warmLanes |= i), p = o.expirationTimes;
    for (var y = i; 0 < y; ) {
      var S = 31 - Ae(y), j = 1 << S;
      p[S] = -1, y &= ~j;
    }
    u !== 0 && Gd(o, u, i);
  }
  function Gu() {
    return (Ze & 6) === 0 ? (Rs(0), !1) : !0;
  }
  function Ip() {
    if (Be !== null) {
      if (rt === 0)
        var o = Be.return;
      else
        o = Be, Vr = fa = null, Jf(o), ti = null, ps = 0, o = Be;
      for (; o !== null; )
        mb(o.alternate, o), o = o.return;
      Be = null;
    }
  }
  function di(o, i) {
    var u = o.timeoutHandle;
    u !== -1 && (o.timeoutHandle = -1, DM(u)), u = o.cancelPendingCommit, u !== null && (o.cancelPendingCommit = null, u()), eo = 0, Ip(), ut = o, Be = u = Br(o.current, null), He = i, rt = 0, Wn = null, xo = !1, li = vr(o, i), Np = !1, ui = qn = Ap = xa = So = _t = 0, jn = Ns = null, Rp = !1, (i & 8) !== 0 && (i |= i & 32);
    var p = o.entangledLanes;
    if (p !== 0)
      for (o = o.entanglements, p &= i; 0 < p; ) {
        var y = 31 - Ae(p), S = 1 << y;
        i |= o[y], p &= ~S;
      }
    return Zr = i, mu(), u;
  }
  function Tb(o, i) {
    ze = null, $.H = xs, i === ei || i === Su ? (i = ey(), rt = 3) : i === Lf ? (i = ey(), rt = 4) : rt = i === pp ? 8 : i !== null && typeof i == "object" && typeof i.then == "function" ? 6 : 1, Wn = i, Be === null && (_t = 1, $u(
      o,
      nr(i, o.current)
    ));
  }
  function Lb() {
    var o = Vn.current;
    return o === null ? !0 : (He & 4194048) === He ? fr === null : (He & 62914560) === He || (He & 536870912) !== 0 ? o === fr : !1;
  }
  function Fb() {
    var o = $.H;
    return $.H = xs, o === null ? xs : o;
  }
  function Bb() {
    var o = $.A;
    return $.A = fM, o;
  }
  function Ku() {
    _t = 4, xo || (He & 4194048) !== He && Vn.current !== null || (li = !0), (So & 134217727) === 0 && (xa & 134217727) === 0 || ut === null || Eo(
      ut,
      He,
      qn,
      !1
    );
  }
  function $p(o, i, u) {
    var p = Ze;
    Ze |= 2;
    var y = Fb(), S = Bb();
    (ut !== o || He !== i) && (qu = null, di(o, i)), i = !1;
    var j = _t;
    e: do
      try {
        if (rt !== 0 && Be !== null) {
          var T = Be, X = Wn;
          switch (rt) {
            case 8:
              Ip(), j = 6;
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              Vn.current === null && (i = !0);
              var ne = rt;
              if (rt = 0, Wn = null, fi(o, T, X, ne), u && li) {
                j = 0;
                break e;
              }
              break;
            default:
              ne = rt, rt = 0, Wn = null, fi(o, T, X, ne);
          }
        }
        hM(), j = _t;
        break;
      } catch (ue) {
        Tb(o, ue);
      }
    while (!0);
    return i && o.shellSuspendCounter++, Vr = fa = null, Ze = p, $.H = y, $.A = S, Be === null && (ut = null, He = 0, mu()), j;
  }
  function hM() {
    for (; Be !== null; ) Ub(Be);
  }
  function gM(o, i) {
    var u = Ze;
    Ze |= 2;
    var p = Fb(), y = Bb();
    ut !== o || He !== i ? (qu = null, Wu = Ce() + 500, di(o, i)) : li = vr(
      o,
      i
    );
    e: do
      try {
        if (rt !== 0 && Be !== null) {
          i = Be;
          var S = Wn;
          t: switch (rt) {
            case 1:
              rt = 0, Wn = null, fi(o, i, S, 1);
              break;
            case 2:
            case 9:
              if (Qv(S)) {
                rt = 0, Wn = null, Vb(i);
                break;
              }
              i = function() {
                rt !== 2 && rt !== 9 || ut !== o || (rt = 7), Nr(o);
              }, S.then(i, i);
              break e;
            case 3:
              rt = 7;
              break e;
            case 4:
              rt = 5;
              break e;
            case 7:
              Qv(S) ? (rt = 0, Wn = null, Vb(i)) : (rt = 0, Wn = null, fi(o, i, S, 7));
              break;
            case 5:
              var j = null;
              switch (Be.tag) {
                case 26:
                  j = Be.memoizedState;
                case 5:
                case 27:
                  var T = Be;
                  if (j ? Mw(j) : T.stateNode.complete) {
                    rt = 0, Wn = null;
                    var X = T.sibling;
                    if (X !== null) Be = X;
                    else {
                      var ne = T.return;
                      ne !== null ? (Be = ne, Yu(ne)) : Be = null;
                    }
                    break t;
                  }
              }
              rt = 0, Wn = null, fi(o, i, S, 5);
              break;
            case 6:
              rt = 0, Wn = null, fi(o, i, S, 6);
              break;
            case 8:
              Ip(), _t = 6;
              break e;
            default:
              throw Error(r(462));
          }
        }
        vM();
        break;
      } catch (ue) {
        Tb(o, ue);
      }
    while (!0);
    return Vr = fa = null, $.H = p, $.A = y, Ze = u, Be !== null ? 0 : (ut = null, He = 0, mu(), _t);
  }
  function vM() {
    for (; Be !== null && !cn(); )
      Ub(Be);
  }
  function Ub(o) {
    var i = fb(o.alternate, o, Zr);
    o.memoizedProps = o.pendingProps, i === null ? Yu(o) : Be = i;
  }
  function Vb(o) {
    var i = o, u = i.alternate;
    switch (i.tag) {
      case 15:
      case 0:
        i = ib(
          u,
          i,
          i.pendingProps,
          i.type,
          void 0,
          He
        );
        break;
      case 11:
        i = ib(
          u,
          i,
          i.pendingProps,
          i.type.render,
          i.ref,
          He
        );
        break;
      case 5:
        Jf(i);
      default:
        mb(u, i), i = Be = Bv(i, Zr), i = fb(u, i, Zr);
    }
    o.memoizedProps = o.pendingProps, i === null ? Yu(o) : Be = i;
  }
  function fi(o, i, u, p) {
    Vr = fa = null, Jf(i), ti = null, ps = 0;
    var y = i.return;
    try {
      if (aM(
        o,
        y,
        i,
        u,
        He
      )) {
        _t = 1, $u(
          o,
          nr(u, o.current)
        ), Be = null;
        return;
      }
    } catch (S) {
      if (y !== null) throw Be = y, S;
      _t = 1, $u(
        o,
        nr(u, o.current)
      ), Be = null;
      return;
    }
    i.flags & 32768 ? (Ke || p === 1 ? o = !0 : li || (He & 536870912) !== 0 ? o = !1 : (xo = o = !0, (p === 2 || p === 9 || p === 3 || p === 6) && (p = Vn.current, p !== null && p.tag === 13 && (p.flags |= 16384))), Hb(i, o)) : Yu(i);
  }
  function Yu(o) {
    var i = o;
    do {
      if ((i.flags & 32768) !== 0) {
        Hb(
          i,
          xo
        );
        return;
      }
      o = i.return;
      var u = lM(
        i.alternate,
        i,
        Zr
      );
      if (u !== null) {
        Be = u;
        return;
      }
      if (i = i.sibling, i !== null) {
        Be = i;
        return;
      }
      Be = i = o;
    } while (i !== null);
    _t === 0 && (_t = 5);
  }
  function Hb(o, i) {
    do {
      var u = uM(o.alternate, o);
      if (u !== null) {
        u.flags &= 32767, Be = u;
        return;
      }
      if (u = o.return, u !== null && (u.flags |= 32768, u.subtreeFlags = 0, u.deletions = null), !i && (o = o.sibling, o !== null)) {
        Be = o;
        return;
      }
      Be = o = u;
    } while (o !== null);
    _t = 6, Be = null;
  }
  function Wb(o, i, u, p, y, S, j, T, X) {
    o.cancelPendingCommit = null;
    do
      Xu();
    while (qt !== 0);
    if ((Ze & 6) !== 0) throw Error(r(327));
    if (i !== null) {
      if (i === o.current) throw Error(r(177));
      if (S = i.lanes | i.childLanes, S |= _f, ev(
        o,
        u,
        S,
        j,
        T,
        X
      ), o === ut && (Be = ut = null, He = 0), ci = i, _o = o, eo = u, jp = S, Pp = y, Db = p, (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0 ? (o.callbackNode = null, o.callbackPriority = 0, xM(Ee, function() {
        return Xb(), null;
      })) : (o.callbackNode = null, o.callbackPriority = 0), p = (i.flags & 13878) !== 0, (i.subtreeFlags & 13878) !== 0 || p) {
        p = $.T, $.T = null, y = K.p, K.p = 2, j = Ze, Ze |= 4;
        try {
          cM(o, i, u);
        } finally {
          Ze = j, K.p = y, $.T = p;
        }
      }
      qt = 1, qb(), Gb(), Kb();
    }
  }
  function qb() {
    if (qt === 1) {
      qt = 0;
      var o = _o, i = ci, u = (i.flags & 13878) !== 0;
      if ((i.subtreeFlags & 13878) !== 0 || u) {
        u = $.T, $.T = null;
        var p = K.p;
        K.p = 2;
        var y = Ze;
        Ze |= 4;
        try {
          Cb(i, o);
          var S = Kp, j = jv(o.containerInfo), T = S.focusedElem, X = S.selectionRange;
          if (j !== T && T && T.ownerDocument && Rv(
            T.ownerDocument.documentElement,
            T
          )) {
            if (X !== null && bf(T)) {
              var ne = X.start, ue = X.end;
              if (ue === void 0 && (ue = ne), "selectionStart" in T)
                T.selectionStart = ne, T.selectionEnd = Math.min(
                  ue,
                  T.value.length
                );
              else {
                var pe = T.ownerDocument || document, ae = pe && pe.defaultView || window;
                if (ae.getSelection) {
                  var se = ae.getSelection(), we = T.textContent.length, Ne = Math.min(X.start, we), st = X.end === void 0 ? Ne : Math.min(X.end, we);
                  !se.extend && Ne > st && (j = st, st = Ne, Ne = j);
                  var ee = Av(
                    T,
                    Ne
                  ), Q = Av(
                    T,
                    st
                  );
                  if (ee && Q && (se.rangeCount !== 1 || se.anchorNode !== ee.node || se.anchorOffset !== ee.offset || se.focusNode !== Q.node || se.focusOffset !== Q.offset)) {
                    var te = pe.createRange();
                    te.setStart(ee.node, ee.offset), se.removeAllRanges(), Ne > st ? (se.addRange(te), se.extend(Q.node, Q.offset)) : (te.setEnd(Q.node, Q.offset), se.addRange(te));
                  }
                }
              }
            }
            for (pe = [], se = T; se = se.parentNode; )
              se.nodeType === 1 && pe.push({
                element: se,
                left: se.scrollLeft,
                top: se.scrollTop
              });
            for (typeof T.focus == "function" && T.focus(), T = 0; T < pe.length; T++) {
              var de = pe[T];
              de.element.scrollLeft = de.left, de.element.scrollTop = de.top;
            }
          }
          lc = !!Gp, Kp = Gp = null;
        } finally {
          Ze = y, K.p = p, $.T = u;
        }
      }
      o.current = i, qt = 2;
    }
  }
  function Gb() {
    if (qt === 2) {
      qt = 0;
      var o = _o, i = ci, u = (i.flags & 8772) !== 0;
      if ((i.subtreeFlags & 8772) !== 0 || u) {
        u = $.T, $.T = null;
        var p = K.p;
        K.p = 2;
        var y = Ze;
        Ze |= 4;
        try {
          xb(o, i.alternate, i);
        } finally {
          Ze = y, K.p = p, $.T = u;
        }
      }
      qt = 3;
    }
  }
  function Kb() {
    if (qt === 4 || qt === 3) {
      qt = 0, pt();
      var o = _o, i = ci, u = eo, p = Db;
      (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0 ? qt = 5 : (qt = 0, ci = _o = null, Yb(o, o.pendingLanes));
      var y = o.pendingLanes;
      if (y === 0 && (ko = null), ru(u), i = i.stateNode, Nt && typeof Nt.onCommitFiberRoot == "function")
        try {
          Nt.onCommitFiberRoot(
            Xt,
            i,
            void 0,
            (i.current.flags & 128) === 128
          );
        } catch {
        }
      if (p !== null) {
        i = $.T, y = K.p, K.p = 2, $.T = null;
        try {
          for (var S = o.onRecoverableError, j = 0; j < p.length; j++) {
            var T = p[j];
            S(T.value, {
              componentStack: T.stack
            });
          }
        } finally {
          $.T = i, K.p = y;
        }
      }
      (eo & 3) !== 0 && Xu(), Nr(o), y = o.pendingLanes, (u & 261930) !== 0 && (y & 42) !== 0 ? o === Dp ? As++ : (As = 0, Dp = o) : As = 0, Rs(0);
    }
  }
  function Yb(o, i) {
    (o.pooledCacheLanes &= i) === 0 && (i = o.pooledCache, i != null && (o.pooledCache = null, ds(i)));
  }
  function Xu() {
    return qb(), Gb(), Kb(), Xb();
  }
  function Xb() {
    if (qt !== 5) return !1;
    var o = _o, i = jp;
    jp = 0;
    var u = ru(eo), p = $.T, y = K.p;
    try {
      K.p = 32 > u ? 32 : u, $.T = null, u = Pp, Pp = null;
      var S = _o, j = eo;
      if (qt = 0, ci = _o = null, eo = 0, (Ze & 6) !== 0) throw Error(r(331));
      var T = Ze;
      if (Ze |= 4, Rb(S.current), Mb(
        S,
        S.current,
        j,
        u
      ), Ze = T, Rs(0, !1), Nt && typeof Nt.onPostCommitFiberRoot == "function")
        try {
          Nt.onPostCommitFiberRoot(Xt, S);
        } catch {
        }
      return !0;
    } finally {
      K.p = y, $.T = p, Yb(o, i);
    }
  }
  function Jb(o, i, u) {
    i = nr(u, i), i = fp(o.stateNode, i, 2), o = vo(o, i, 2), o !== null && (Ta(o, 2), Nr(o));
  }
  function ot(o, i, u) {
    if (o.tag === 3)
      Jb(o, o, u);
    else
      for (; i !== null; ) {
        if (i.tag === 3) {
          Jb(
            i,
            o,
            u
          );
          break;
        } else if (i.tag === 1) {
          var p = i.stateNode;
          if (typeof i.type.getDerivedStateFromError == "function" || typeof p.componentDidCatch == "function" && (ko === null || !ko.has(p))) {
            o = nr(u, o), u = Qy(2), p = vo(i, u, 2), p !== null && (Zy(
              u,
              p,
              i,
              o
            ), Ta(p, 2), Nr(p));
            break;
          }
        }
        i = i.return;
      }
  }
  function zp(o, i, u) {
    var p = o.pingCache;
    if (p === null) {
      p = o.pingCache = new pM();
      var y = /* @__PURE__ */ new Set();
      p.set(i, y);
    } else
      y = p.get(i), y === void 0 && (y = /* @__PURE__ */ new Set(), p.set(i, y));
    y.has(u) || (Np = !0, y.add(u), o = yM.bind(null, o, i, u), i.then(o, o));
  }
  function yM(o, i, u) {
    var p = o.pingCache;
    p !== null && p.delete(i), o.pingedLanes |= o.suspendedLanes & u, o.warmLanes &= ~u, ut === o && (He & u) === u && (_t === 4 || _t === 3 && (He & 62914560) === He && 300 > Ce() - Hu ? (Ze & 2) === 0 && di(o, 0) : Ap |= u, ui === He && (ui = 0)), Nr(o);
  }
  function Qb(o, i) {
    i === 0 && (i = qd()), o = ua(o, i), o !== null && (Ta(o, i), Nr(o));
  }
  function bM(o) {
    var i = o.memoizedState, u = 0;
    i !== null && (u = i.retryLane), Qb(o, u);
  }
  function wM(o, i) {
    var u = 0;
    switch (o.tag) {
      case 31:
      case 13:
        var p = o.stateNode, y = o.memoizedState;
        y !== null && (u = y.retryLane);
        break;
      case 19:
        p = o.stateNode;
        break;
      case 22:
        p = o.stateNode._retryCache;
        break;
      default:
        throw Error(r(314));
    }
    p !== null && p.delete(i), Qb(o, u);
  }
  function xM(o, i) {
    return nt(o, i);
  }
  var Ju = null, pi = null, Tp = !1, Qu = !1, Lp = !1, Co = 0;
  function Nr(o) {
    o !== pi && o.next === null && (pi === null ? Ju = pi = o : pi = pi.next = o), Qu = !0, Tp || (Tp = !0, kM());
  }
  function Rs(o, i) {
    if (!Lp && Qu) {
      Lp = !0;
      do
        for (var u = !1, p = Ju; p !== null; ) {
          if (o !== 0) {
            var y = p.pendingLanes;
            if (y === 0) var S = 0;
            else {
              var j = p.suspendedLanes, T = p.pingedLanes;
              S = (1 << 31 - Ae(42 | o) + 1) - 1, S &= y & ~(j & ~T), S = S & 201326741 ? S & 201326741 | 1 : S ? S | 2 : 0;
            }
            S !== 0 && (u = !0, nw(p, S));
          } else
            S = He, S = Vo(
              p,
              p === ut ? S : 0,
              p.cancelPendingCommit !== null || p.timeoutHandle !== -1
            ), (S & 3) === 0 || vr(p, S) || (u = !0, nw(p, S));
          p = p.next;
        }
      while (u);
      Lp = !1;
    }
  }
  function SM() {
    Zb();
  }
  function Zb() {
    Qu = Tp = !1;
    var o = 0;
    Co !== 0 && PM() && (o = Co);
    for (var i = Ce(), u = null, p = Ju; p !== null; ) {
      var y = p.next, S = ew(p, i);
      S === 0 ? (p.next = null, u === null ? Ju = y : u.next = y, y === null && (pi = u)) : (u = p, (o !== 0 || (S & 3) !== 0) && (Qu = !0)), p = y;
    }
    qt !== 0 && qt !== 5 || Rs(o), Co !== 0 && (Co = 0);
  }
  function ew(o, i) {
    for (var u = o.suspendedLanes, p = o.pingedLanes, y = o.expirationTimes, S = o.pendingLanes & -62914561; 0 < S; ) {
      var j = 31 - Ae(S), T = 1 << j, X = y[j];
      X === -1 ? ((T & u) === 0 || (T & p) !== 0) && (y[j] = Zg(T, i)) : X <= i && (o.expiredLanes |= T), S &= ~T;
    }
    if (i = ut, u = He, u = Vo(
      o,
      o === i ? u : 0,
      o.cancelPendingCommit !== null || o.timeoutHandle !== -1
    ), p = o.callbackNode, u === 0 || o === i && (rt === 2 || rt === 9) || o.cancelPendingCommit !== null)
      return p !== null && p !== null && je(p), o.callbackNode = null, o.callbackPriority = 0;
    if ((u & 3) === 0 || vr(o, u)) {
      if (i = u & -u, i === o.callbackPriority) return i;
      switch (p !== null && je(p), ru(u)) {
        case 2:
        case 8:
          u = ye;
          break;
        case 32:
          u = Ee;
          break;
        case 268435456:
          u = Fe;
          break;
        default:
          u = Ee;
      }
      return p = tw.bind(null, o), u = nt(u, p), o.callbackPriority = i, o.callbackNode = u, i;
    }
    return p !== null && p !== null && je(p), o.callbackPriority = 2, o.callbackNode = null, 2;
  }
  function tw(o, i) {
    if (qt !== 0 && qt !== 5)
      return o.callbackNode = null, o.callbackPriority = 0, null;
    var u = o.callbackNode;
    if (Xu() && o.callbackNode !== u)
      return null;
    var p = He;
    return p = Vo(
      o,
      o === ut ? p : 0,
      o.cancelPendingCommit !== null || o.timeoutHandle !== -1
    ), p === 0 ? null : ($b(o, p, i), ew(o, Ce()), o.callbackNode != null && o.callbackNode === u ? tw.bind(null, o) : null);
  }
  function nw(o, i) {
    if (Xu()) return null;
    $b(o, i, !0);
  }
  function kM() {
    IM(function() {
      (Ze & 6) !== 0 ? nt(
        he,
        SM
      ) : Zb();
    });
  }
  function Fp() {
    if (Co === 0) {
      var o = Qa;
      o === 0 && (o = Uo, Uo <<= 1, (Uo & 261888) === 0 && (Uo = 256)), Co = o;
    }
    return Co;
  }
  function rw(o) {
    return o == null || typeof o == "symbol" || typeof o == "boolean" ? null : typeof o == "function" ? o : iu("" + o);
  }
  function ow(o, i) {
    var u = i.ownerDocument.createElement("input");
    return u.name = i.name, u.value = i.value, o.id && u.setAttribute("form", o.id), i.parentNode.insertBefore(u, i), o = new FormData(o), u.parentNode.removeChild(u), o;
  }
  function _M(o, i, u, p, y) {
    if (i === "submit" && u && u.stateNode === y) {
      var S = rw(
        (y[yn] || null).action
      ), j = p.submitter;
      j && (i = (i = j[yn] || null) ? rw(i.formAction) : j.getAttribute("formAction"), i !== null && (S = i, j = null));
      var T = new cu(
        "action",
        "action",
        null,
        p,
        y
      );
      o.push({
        event: T,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (p.defaultPrevented) {
                if (Co !== 0) {
                  var X = j ? ow(y, j) : new FormData(y);
                  ip(
                    u,
                    {
                      pending: !0,
                      data: X,
                      method: y.method,
                      action: S
                    },
                    null,
                    X
                  );
                }
              } else
                typeof S == "function" && (T.preventDefault(), X = j ? ow(y, j) : new FormData(y), ip(
                  u,
                  {
                    pending: !0,
                    data: X,
                    method: y.method,
                    action: S
                  },
                  S,
                  X
                ));
            },
            currentTarget: y
          }
        ]
      });
    }
  }
  for (var Bp = 0; Bp < kf.length; Bp++) {
    var Up = kf[Bp], EM = Up.toLowerCase(), CM = Up[0].toUpperCase() + Up.slice(1);
    yr(
      EM,
      "on" + CM
    );
  }
  yr(Iv, "onAnimationEnd"), yr($v, "onAnimationIteration"), yr(zv, "onAnimationStart"), yr("dblclick", "onDoubleClick"), yr("focusin", "onFocus"), yr("focusout", "onBlur"), yr(UO, "onTransitionRun"), yr(VO, "onTransitionStart"), yr(HO, "onTransitionCancel"), yr(Tv, "onTransitionEnd"), aa("onMouseEnter", ["mouseout", "mouseover"]), aa("onMouseLeave", ["mouseout", "mouseover"]), aa("onPointerEnter", ["pointerout", "pointerover"]), aa("onPointerLeave", ["pointerout", "pointerover"]), lo(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), lo(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), lo("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), lo(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), lo(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), lo(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var js = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), OM = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(js)
  );
  function aw(o, i) {
    i = (i & 4) !== 0;
    for (var u = 0; u < o.length; u++) {
      var p = o[u], y = p.event;
      p = p.listeners;
      e: {
        var S = void 0;
        if (i)
          for (var j = p.length - 1; 0 <= j; j--) {
            var T = p[j], X = T.instance, ne = T.currentTarget;
            if (T = T.listener, X !== S && y.isPropagationStopped())
              break e;
            S = T, y.currentTarget = ne;
            try {
              S(y);
            } catch (ue) {
              pu(ue);
            }
            y.currentTarget = null, S = X;
          }
        else
          for (j = 0; j < p.length; j++) {
            if (T = p[j], X = T.instance, ne = T.currentTarget, T = T.listener, X !== S && y.isPropagationStopped())
              break e;
            S = T, y.currentTarget = ne;
            try {
              S(y);
            } catch (ue) {
              pu(ue);
            }
            y.currentTarget = null, S = X;
          }
      }
    }
  }
  function Ue(o, i) {
    var u = i[cl];
    u === void 0 && (u = i[cl] = /* @__PURE__ */ new Set());
    var p = o + "__bubble";
    u.has(p) || (iw(i, o, 2, !1), u.add(p));
  }
  function Vp(o, i, u) {
    var p = 0;
    i && (p |= 4), iw(
      u,
      o,
      p,
      i
    );
  }
  var Zu = "_reactListening" + Math.random().toString(36).slice(2);
  function Hp(o) {
    if (!o[Zu]) {
      o[Zu] = !0, Zd.forEach(function(u) {
        u !== "selectionchange" && (OM.has(u) || Vp(u, !1, o), Vp(u, !0, o));
      });
      var i = o.nodeType === 9 ? o : o.ownerDocument;
      i === null || i[Zu] || (i[Zu] = !0, Vp("selectionchange", !1, i));
    }
  }
  function iw(o, i, u, p) {
    switch (Iw(i)) {
      case 2:
        var y = tN;
        break;
      case 8:
        y = nN;
        break;
      default:
        y = am;
    }
    u = y.bind(
      null,
      i,
      u,
      o
    ), y = void 0, !cf || i !== "touchstart" && i !== "touchmove" && i !== "wheel" || (y = !0), p ? y !== void 0 ? o.addEventListener(i, u, {
      capture: !0,
      passive: y
    }) : o.addEventListener(i, u, !0) : y !== void 0 ? o.addEventListener(i, u, {
      passive: y
    }) : o.addEventListener(i, u, !1);
  }
  function Wp(o, i, u, p, y) {
    var S = p;
    if ((i & 1) === 0 && (i & 2) === 0 && p !== null)
      e: for (; ; ) {
        if (p === null) return;
        var j = p.tag;
        if (j === 3 || j === 4) {
          var T = p.stateNode.containerInfo;
          if (T === y) break;
          if (j === 4)
            for (j = p.return; j !== null; ) {
              var X = j.tag;
              if ((X === 3 || X === 4) && j.stateNode.containerInfo === y)
                return;
              j = j.return;
            }
          for (; T !== null; ) {
            if (j = na(T), j === null) return;
            if (X = j.tag, X === 5 || X === 6 || X === 26 || X === 27) {
              p = S = j;
              continue e;
            }
            T = T.parentNode;
          }
        }
        p = p.return;
      }
    dv(function() {
      var ne = S, ue = lf(u), pe = [];
      e: {
        var ae = Lv.get(o);
        if (ae !== void 0) {
          var se = cu, we = o;
          switch (o) {
            case "keypress":
              if (lu(u) === 0) break e;
            case "keydown":
            case "keyup":
              se = wO;
              break;
            case "focusin":
              we = "focus", se = mf;
              break;
            case "focusout":
              we = "blur", se = mf;
              break;
            case "beforeblur":
            case "afterblur":
              se = mf;
              break;
            case "click":
              if (u.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              se = mv;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              se = lO;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              se = kO;
              break;
            case Iv:
            case $v:
            case zv:
              se = dO;
              break;
            case Tv:
              se = EO;
              break;
            case "scroll":
            case "scrollend":
              se = iO;
              break;
            case "wheel":
              se = OO;
              break;
            case "copy":
            case "cut":
            case "paste":
              se = pO;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              se = gv;
              break;
            case "toggle":
            case "beforetoggle":
              se = NO;
          }
          var Ne = (i & 4) !== 0, st = !Ne && (o === "scroll" || o === "scrollend"), ee = Ne ? ae !== null ? ae + "Capture" : null : ae;
          Ne = [];
          for (var Q = ne, te; Q !== null; ) {
            var de = Q;
            if (te = de.stateNode, de = de.tag, de !== 5 && de !== 26 && de !== 27 || te === null || ee === null || (de = es(Q, ee), de != null && Ne.push(
              Ps(Q, de, te)
            )), st) break;
            Q = Q.return;
          }
          0 < Ne.length && (ae = new se(
            ae,
            we,
            null,
            u,
            ue
          ), pe.push({ event: ae, listeners: Ne }));
        }
      }
      if ((i & 7) === 0) {
        e: {
          if (ae = o === "mouseover" || o === "pointerover", se = o === "mouseout" || o === "pointerout", ae && u !== sf && (we = u.relatedTarget || u.fromElement) && (na(we) || we[Ho]))
            break e;
          if ((se || ae) && (ae = ue.window === ue ? ue : (ae = ue.ownerDocument) ? ae.defaultView || ae.parentWindow : window, se ? (we = u.relatedTarget || u.toElement, se = ne, we = we ? na(we) : null, we !== null && (st = s(we), Ne = we.tag, we !== st || Ne !== 5 && Ne !== 27 && Ne !== 6) && (we = null)) : (se = null, we = ne), se !== we)) {
            if (Ne = mv, de = "onMouseLeave", ee = "onMouseEnter", Q = "mouse", (o === "pointerout" || o === "pointerover") && (Ne = gv, de = "onPointerLeave", ee = "onPointerEnter", Q = "pointer"), st = se == null ? ae : Na(se), te = we == null ? ae : Na(we), ae = new Ne(
              de,
              Q + "leave",
              se,
              u,
              ue
            ), ae.target = st, ae.relatedTarget = te, de = null, na(ue) === ne && (Ne = new Ne(
              ee,
              Q + "enter",
              we,
              u,
              ue
            ), Ne.target = te, Ne.relatedTarget = st, de = Ne), st = de, se && we)
              t: {
                for (Ne = MM, ee = se, Q = we, te = 0, de = ee; de; de = Ne(de))
                  te++;
                de = 0;
                for (var Oe = Q; Oe; Oe = Ne(Oe))
                  de++;
                for (; 0 < te - de; )
                  ee = Ne(ee), te--;
                for (; 0 < de - te; )
                  Q = Ne(Q), de--;
                for (; te--; ) {
                  if (ee === Q || Q !== null && ee === Q.alternate) {
                    Ne = ee;
                    break t;
                  }
                  ee = Ne(ee), Q = Ne(Q);
                }
                Ne = null;
              }
            else Ne = null;
            se !== null && sw(
              pe,
              ae,
              se,
              Ne,
              !1
            ), we !== null && st !== null && sw(
              pe,
              st,
              we,
              Ne,
              !0
            );
          }
        }
        e: {
          if (ae = ne ? Na(ne) : window, se = ae.nodeName && ae.nodeName.toLowerCase(), se === "select" || se === "input" && ae.type === "file")
            var Je = _v;
          else if (Sv(ae))
            if (Ev)
              Je = LO;
            else {
              Je = zO;
              var ke = $O;
            }
          else
            se = ae.nodeName, !se || se.toLowerCase() !== "input" || ae.type !== "checkbox" && ae.type !== "radio" ? ne && af(ne.elementType) && (Je = _v) : Je = TO;
          if (Je && (Je = Je(o, ne))) {
            kv(
              pe,
              Je,
              u,
              ue
            );
            break e;
          }
          ke && ke(o, ae, ne), o === "focusout" && ne && ae.type === "number" && ne.memoizedProps.value != null && au(ae, "number", ae.value);
        }
        switch (ke = ne ? Na(ne) : window, o) {
          case "focusin":
            (Sv(ke) || ke.contentEditable === "true") && (Ha = ke, wf = ne, ls = null);
            break;
          case "focusout":
            ls = wf = Ha = null;
            break;
          case "mousedown":
            xf = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            xf = !1, Pv(pe, u, ue);
            break;
          case "selectionchange":
            if (BO) break;
          case "keydown":
          case "keyup":
            Pv(pe, u, ue);
        }
        var Le;
        if (gf)
          e: {
            switch (o) {
              case "compositionstart":
                var We = "onCompositionStart";
                break e;
              case "compositionend":
                We = "onCompositionEnd";
                break e;
              case "compositionupdate":
                We = "onCompositionUpdate";
                break e;
            }
            We = void 0;
          }
        else
          Va ? wv(o, u) && (We = "onCompositionEnd") : o === "keydown" && u.keyCode === 229 && (We = "onCompositionStart");
        We && (vv && u.locale !== "ko" && (Va || We !== "onCompositionStart" ? We === "onCompositionEnd" && Va && (Le = fv()) : (uo = ue, df = "value" in uo ? uo.value : uo.textContent, Va = !0)), ke = ec(ne, We), 0 < ke.length && (We = new hv(
          We,
          o,
          null,
          u,
          ue
        ), pe.push({ event: We, listeners: ke }), Le ? We.data = Le : (Le = xv(u), Le !== null && (We.data = Le)))), (Le = RO ? jO(o, u) : PO(o, u)) && (We = ec(ne, "onBeforeInput"), 0 < We.length && (ke = new hv(
          "onBeforeInput",
          "beforeinput",
          null,
          u,
          ue
        ), pe.push({
          event: ke,
          listeners: We
        }), ke.data = Le)), _M(
          pe,
          o,
          ne,
          u,
          ue
        );
      }
      aw(pe, i);
    });
  }
  function Ps(o, i, u) {
    return {
      instance: o,
      listener: i,
      currentTarget: u
    };
  }
  function ec(o, i) {
    for (var u = i + "Capture", p = []; o !== null; ) {
      var y = o, S = y.stateNode;
      if (y = y.tag, y !== 5 && y !== 26 && y !== 27 || S === null || (y = es(o, u), y != null && p.unshift(
        Ps(o, y, S)
      ), y = es(o, i), y != null && p.push(
        Ps(o, y, S)
      )), o.tag === 3) return p;
      o = o.return;
    }
    return [];
  }
  function MM(o) {
    if (o === null) return null;
    do
      o = o.return;
    while (o && o.tag !== 5 && o.tag !== 27);
    return o || null;
  }
  function sw(o, i, u, p, y) {
    for (var S = i._reactName, j = []; u !== null && u !== p; ) {
      var T = u, X = T.alternate, ne = T.stateNode;
      if (T = T.tag, X !== null && X === p) break;
      T !== 5 && T !== 26 && T !== 27 || ne === null || (X = ne, y ? (ne = es(u, S), ne != null && j.unshift(
        Ps(u, ne, X)
      )) : y || (ne = es(u, S), ne != null && j.push(
        Ps(u, ne, X)
      ))), u = u.return;
    }
    j.length !== 0 && o.push({ event: i, listeners: j });
  }
  var NM = /\r\n?/g, AM = /\u0000|\uFFFD/g;
  function lw(o) {
    return (typeof o == "string" ? o : "" + o).replace(NM, `
`).replace(AM, "");
  }
  function uw(o, i) {
    return i = lw(i), lw(o) === i;
  }
  function it(o, i, u, p, y, S) {
    switch (u) {
      case "children":
        typeof p == "string" ? i === "body" || i === "textarea" && p === "" || Fa(o, p) : (typeof p == "number" || typeof p == "bigint") && i !== "body" && Fa(o, "" + p);
        break;
      case "className":
        Qi(o, "class", p);
        break;
      case "tabIndex":
        Qi(o, "tabindex", p);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Qi(o, u, p);
        break;
      case "style":
        uv(o, p, S);
        break;
      case "data":
        if (i !== "object") {
          Qi(o, "data", p);
          break;
        }
      case "src":
      case "href":
        if (p === "" && (i !== "a" || u !== "href")) {
          o.removeAttribute(u);
          break;
        }
        if (p == null || typeof p == "function" || typeof p == "symbol" || typeof p == "boolean") {
          o.removeAttribute(u);
          break;
        }
        p = iu("" + p), o.setAttribute(u, p);
        break;
      case "action":
      case "formAction":
        if (typeof p == "function") {
          o.setAttribute(
            u,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof S == "function" && (u === "formAction" ? (i !== "input" && it(o, i, "name", y.name, y, null), it(
            o,
            i,
            "formEncType",
            y.formEncType,
            y,
            null
          ), it(
            o,
            i,
            "formMethod",
            y.formMethod,
            y,
            null
          ), it(
            o,
            i,
            "formTarget",
            y.formTarget,
            y,
            null
          )) : (it(o, i, "encType", y.encType, y, null), it(o, i, "method", y.method, y, null), it(o, i, "target", y.target, y, null)));
        if (p == null || typeof p == "symbol" || typeof p == "boolean") {
          o.removeAttribute(u);
          break;
        }
        p = iu("" + p), o.setAttribute(u, p);
        break;
      case "onClick":
        p != null && (o.onclick = Lr);
        break;
      case "onScroll":
        p != null && Ue("scroll", o);
        break;
      case "onScrollEnd":
        p != null && Ue("scrollend", o);
        break;
      case "dangerouslySetInnerHTML":
        if (p != null) {
          if (typeof p != "object" || !("__html" in p))
            throw Error(r(61));
          if (u = p.__html, u != null) {
            if (y.children != null) throw Error(r(60));
            o.innerHTML = u;
          }
        }
        break;
      case "multiple":
        o.multiple = p && typeof p != "function" && typeof p != "symbol";
        break;
      case "muted":
        o.muted = p && typeof p != "function" && typeof p != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (p == null || typeof p == "function" || typeof p == "boolean" || typeof p == "symbol") {
          o.removeAttribute("xlink:href");
          break;
        }
        u = iu("" + p), o.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          u
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        p != null && typeof p != "function" && typeof p != "symbol" ? o.setAttribute(u, "" + p) : o.removeAttribute(u);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        p && typeof p != "function" && typeof p != "symbol" ? o.setAttribute(u, "") : o.removeAttribute(u);
        break;
      case "capture":
      case "download":
        p === !0 ? o.setAttribute(u, "") : p !== !1 && p != null && typeof p != "function" && typeof p != "symbol" ? o.setAttribute(u, p) : o.removeAttribute(u);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        p != null && typeof p != "function" && typeof p != "symbol" && !isNaN(p) && 1 <= p ? o.setAttribute(u, p) : o.removeAttribute(u);
        break;
      case "rowSpan":
      case "start":
        p == null || typeof p == "function" || typeof p == "symbol" || isNaN(p) ? o.removeAttribute(u) : o.setAttribute(u, p);
        break;
      case "popover":
        Ue("beforetoggle", o), Ue("toggle", o), Ji(o, "popover", p);
        break;
      case "xlinkActuate":
        Er(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          p
        );
        break;
      case "xlinkArcrole":
        Er(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          p
        );
        break;
      case "xlinkRole":
        Er(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          p
        );
        break;
      case "xlinkShow":
        Er(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          p
        );
        break;
      case "xlinkTitle":
        Er(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          p
        );
        break;
      case "xlinkType":
        Er(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          p
        );
        break;
      case "xmlBase":
        Er(
          o,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          p
        );
        break;
      case "xmlLang":
        Er(
          o,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          p
        );
        break;
      case "xmlSpace":
        Er(
          o,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          p
        );
        break;
      case "is":
        Ji(o, "is", p);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < u.length) || u[0] !== "o" && u[0] !== "O" || u[1] !== "n" && u[1] !== "N") && (u = oO.get(u) || u, Ji(o, u, p));
    }
  }
  function qp(o, i, u, p, y, S) {
    switch (u) {
      case "style":
        uv(o, p, S);
        break;
      case "dangerouslySetInnerHTML":
        if (p != null) {
          if (typeof p != "object" || !("__html" in p))
            throw Error(r(61));
          if (u = p.__html, u != null) {
            if (y.children != null) throw Error(r(60));
            o.innerHTML = u;
          }
        }
        break;
      case "children":
        typeof p == "string" ? Fa(o, p) : (typeof p == "number" || typeof p == "bigint") && Fa(o, "" + p);
        break;
      case "onScroll":
        p != null && Ue("scroll", o);
        break;
      case "onScrollEnd":
        p != null && Ue("scrollend", o);
        break;
      case "onClick":
        p != null && (o.onclick = Lr);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!ef.hasOwnProperty(u))
          e: {
            if (u[0] === "o" && u[1] === "n" && (y = u.endsWith("Capture"), i = u.slice(2, y ? u.length - 7 : void 0), S = o[yn] || null, S = S != null ? S[u] : null, typeof S == "function" && o.removeEventListener(i, S, y), typeof p == "function")) {
              typeof S != "function" && S !== null && (u in o ? o[u] = null : o.hasAttribute(u) && o.removeAttribute(u)), o.addEventListener(i, p, y);
              break e;
            }
            u in o ? o[u] = p : p === !0 ? o.setAttribute(u, "") : Ji(o, u, p);
          }
    }
  }
  function ln(o, i, u) {
    switch (i) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        Ue("error", o), Ue("load", o);
        var p = !1, y = !1, S;
        for (S in u)
          if (u.hasOwnProperty(S)) {
            var j = u[S];
            if (j != null)
              switch (S) {
                case "src":
                  p = !0;
                  break;
                case "srcSet":
                  y = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(r(137, i));
                default:
                  it(o, i, S, j, u, null);
              }
          }
        y && it(o, i, "srcSet", u.srcSet, u, null), p && it(o, i, "src", u.src, u, null);
        return;
      case "input":
        Ue("invalid", o);
        var T = S = j = y = null, X = null, ne = null;
        for (p in u)
          if (u.hasOwnProperty(p)) {
            var ue = u[p];
            if (ue != null)
              switch (p) {
                case "name":
                  y = ue;
                  break;
                case "type":
                  j = ue;
                  break;
                case "checked":
                  X = ue;
                  break;
                case "defaultChecked":
                  ne = ue;
                  break;
                case "value":
                  S = ue;
                  break;
                case "defaultValue":
                  T = ue;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (ue != null)
                    throw Error(r(137, i));
                  break;
                default:
                  it(o, i, p, ue, u, null);
              }
          }
        of(
          o,
          S,
          T,
          X,
          ne,
          j,
          y,
          !1
        );
        return;
      case "select":
        Ue("invalid", o), p = j = S = null;
        for (y in u)
          if (u.hasOwnProperty(y) && (T = u[y], T != null))
            switch (y) {
              case "value":
                S = T;
                break;
              case "defaultValue":
                j = T;
                break;
              case "multiple":
                p = T;
              default:
                it(o, i, y, T, u, null);
            }
        i = S, u = j, o.multiple = !!p, i != null ? Wo(o, !!p, i, !1) : u != null && Wo(o, !!p, u, !0);
        return;
      case "textarea":
        Ue("invalid", o), S = y = p = null;
        for (j in u)
          if (u.hasOwnProperty(j) && (T = u[j], T != null))
            switch (j) {
              case "value":
                p = T;
                break;
              case "defaultValue":
                y = T;
                break;
              case "children":
                S = T;
                break;
              case "dangerouslySetInnerHTML":
                if (T != null) throw Error(r(91));
                break;
              default:
                it(o, i, j, T, u, null);
            }
        sv(o, p, y, S);
        return;
      case "option":
        for (X in u)
          u.hasOwnProperty(X) && (p = u[X], p != null) && (X === "selected" ? o.selected = p && typeof p != "function" && typeof p != "symbol" : it(o, i, X, p, u, null));
        return;
      case "dialog":
        Ue("beforetoggle", o), Ue("toggle", o), Ue("cancel", o), Ue("close", o);
        break;
      case "iframe":
      case "object":
        Ue("load", o);
        break;
      case "video":
      case "audio":
        for (p = 0; p < js.length; p++)
          Ue(js[p], o);
        break;
      case "image":
        Ue("error", o), Ue("load", o);
        break;
      case "details":
        Ue("toggle", o);
        break;
      case "embed":
      case "source":
      case "link":
        Ue("error", o), Ue("load", o);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (ne in u)
          if (u.hasOwnProperty(ne) && (p = u[ne], p != null))
            switch (ne) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(r(137, i));
              default:
                it(o, i, ne, p, u, null);
            }
        return;
      default:
        if (af(i)) {
          for (ue in u)
            u.hasOwnProperty(ue) && (p = u[ue], p !== void 0 && qp(
              o,
              i,
              ue,
              p,
              u,
              void 0
            ));
          return;
        }
    }
    for (T in u)
      u.hasOwnProperty(T) && (p = u[T], p != null && it(o, i, T, p, u, null));
  }
  function RM(o, i, u, p) {
    switch (i) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var y = null, S = null, j = null, T = null, X = null, ne = null, ue = null;
        for (se in u) {
          var pe = u[se];
          if (u.hasOwnProperty(se) && pe != null)
            switch (se) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                X = pe;
              default:
                p.hasOwnProperty(se) || it(o, i, se, null, p, pe);
            }
        }
        for (var ae in p) {
          var se = p[ae];
          if (pe = u[ae], p.hasOwnProperty(ae) && (se != null || pe != null))
            switch (ae) {
              case "type":
                S = se;
                break;
              case "name":
                y = se;
                break;
              case "checked":
                ne = se;
                break;
              case "defaultChecked":
                ue = se;
                break;
              case "value":
                j = se;
                break;
              case "defaultValue":
                T = se;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (se != null)
                  throw Error(r(137, i));
                break;
              default:
                se !== pe && it(
                  o,
                  i,
                  ae,
                  se,
                  p,
                  pe
                );
            }
        }
        Zi(
          o,
          j,
          T,
          X,
          ne,
          ue,
          S,
          y
        );
        return;
      case "select":
        se = j = T = ae = null;
        for (S in u)
          if (X = u[S], u.hasOwnProperty(S) && X != null)
            switch (S) {
              case "value":
                break;
              case "multiple":
                se = X;
              default:
                p.hasOwnProperty(S) || it(
                  o,
                  i,
                  S,
                  null,
                  p,
                  X
                );
            }
        for (y in p)
          if (S = p[y], X = u[y], p.hasOwnProperty(y) && (S != null || X != null))
            switch (y) {
              case "value":
                ae = S;
                break;
              case "defaultValue":
                T = S;
                break;
              case "multiple":
                j = S;
              default:
                S !== X && it(
                  o,
                  i,
                  y,
                  S,
                  p,
                  X
                );
            }
        i = T, u = j, p = se, ae != null ? Wo(o, !!u, ae, !1) : !!p != !!u && (i != null ? Wo(o, !!u, i, !0) : Wo(o, !!u, u ? [] : "", !1));
        return;
      case "textarea":
        se = ae = null;
        for (T in u)
          if (y = u[T], u.hasOwnProperty(T) && y != null && !p.hasOwnProperty(T))
            switch (T) {
              case "value":
                break;
              case "children":
                break;
              default:
                it(o, i, T, null, p, y);
            }
        for (j in p)
          if (y = p[j], S = u[j], p.hasOwnProperty(j) && (y != null || S != null))
            switch (j) {
              case "value":
                ae = y;
                break;
              case "defaultValue":
                se = y;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (y != null) throw Error(r(91));
                break;
              default:
                y !== S && it(o, i, j, y, p, S);
            }
        iv(o, ae, se);
        return;
      case "option":
        for (var we in u)
          ae = u[we], u.hasOwnProperty(we) && ae != null && !p.hasOwnProperty(we) && (we === "selected" ? o.selected = !1 : it(
            o,
            i,
            we,
            null,
            p,
            ae
          ));
        for (X in p)
          ae = p[X], se = u[X], p.hasOwnProperty(X) && ae !== se && (ae != null || se != null) && (X === "selected" ? o.selected = ae && typeof ae != "function" && typeof ae != "symbol" : it(
            o,
            i,
            X,
            ae,
            p,
            se
          ));
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var Ne in u)
          ae = u[Ne], u.hasOwnProperty(Ne) && ae != null && !p.hasOwnProperty(Ne) && it(o, i, Ne, null, p, ae);
        for (ne in p)
          if (ae = p[ne], se = u[ne], p.hasOwnProperty(ne) && ae !== se && (ae != null || se != null))
            switch (ne) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (ae != null)
                  throw Error(r(137, i));
                break;
              default:
                it(
                  o,
                  i,
                  ne,
                  ae,
                  p,
                  se
                );
            }
        return;
      default:
        if (af(i)) {
          for (var st in u)
            ae = u[st], u.hasOwnProperty(st) && ae !== void 0 && !p.hasOwnProperty(st) && qp(
              o,
              i,
              st,
              void 0,
              p,
              ae
            );
          for (ue in p)
            ae = p[ue], se = u[ue], !p.hasOwnProperty(ue) || ae === se || ae === void 0 && se === void 0 || qp(
              o,
              i,
              ue,
              ae,
              p,
              se
            );
          return;
        }
    }
    for (var ee in u)
      ae = u[ee], u.hasOwnProperty(ee) && ae != null && !p.hasOwnProperty(ee) && it(o, i, ee, null, p, ae);
    for (pe in p)
      ae = p[pe], se = u[pe], !p.hasOwnProperty(pe) || ae === se || ae == null && se == null || it(o, i, pe, ae, p, se);
  }
  function cw(o) {
    switch (o) {
      case "css":
      case "script":
      case "font":
      case "img":
      case "image":
      case "input":
      case "link":
        return !0;
      default:
        return !1;
    }
  }
  function jM() {
    if (typeof performance.getEntriesByType == "function") {
      for (var o = 0, i = 0, u = performance.getEntriesByType("resource"), p = 0; p < u.length; p++) {
        var y = u[p], S = y.transferSize, j = y.initiatorType, T = y.duration;
        if (S && T && cw(j)) {
          for (j = 0, T = y.responseEnd, p += 1; p < u.length; p++) {
            var X = u[p], ne = X.startTime;
            if (ne > T) break;
            var ue = X.transferSize, pe = X.initiatorType;
            ue && cw(pe) && (X = X.responseEnd, j += ue * (X < T ? 1 : (T - ne) / (X - ne)));
          }
          if (--p, i += 8 * (S + j) / (y.duration / 1e3), o++, 10 < o) break;
        }
      }
      if (0 < o) return i / o / 1e6;
    }
    return navigator.connection && (o = navigator.connection.downlink, typeof o == "number") ? o : 5;
  }
  var Gp = null, Kp = null;
  function tc(o) {
    return o.nodeType === 9 ? o : o.ownerDocument;
  }
  function dw(o) {
    switch (o) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function fw(o, i) {
    if (o === 0)
      switch (i) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return o === 1 && i === "foreignObject" ? 0 : o;
  }
  function Yp(o, i) {
    return o === "textarea" || o === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.children == "bigint" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null;
  }
  var Xp = null;
  function PM() {
    var o = window.event;
    return o && o.type === "popstate" ? o === Xp ? !1 : (Xp = o, !0) : (Xp = null, !1);
  }
  var pw = typeof setTimeout == "function" ? setTimeout : void 0, DM = typeof clearTimeout == "function" ? clearTimeout : void 0, mw = typeof Promise == "function" ? Promise : void 0, IM = typeof queueMicrotask == "function" ? queueMicrotask : typeof mw < "u" ? function(o) {
    return mw.resolve(null).then(o).catch($M);
  } : pw;
  function $M(o) {
    setTimeout(function() {
      throw o;
    });
  }
  function Oo(o) {
    return o === "head";
  }
  function hw(o, i) {
    var u = i, p = 0;
    do {
      var y = u.nextSibling;
      if (o.removeChild(u), y && y.nodeType === 8)
        if (u = y.data, u === "/$" || u === "/&") {
          if (p === 0) {
            o.removeChild(y), vi(i);
            return;
          }
          p--;
        } else if (u === "$" || u === "$?" || u === "$~" || u === "$!" || u === "&")
          p++;
        else if (u === "html")
          Ds(o.ownerDocument.documentElement);
        else if (u === "head") {
          u = o.ownerDocument.head, Ds(u);
          for (var S = u.firstChild; S; ) {
            var j = S.nextSibling, T = S.nodeName;
            S[La] || T === "SCRIPT" || T === "STYLE" || T === "LINK" && S.rel.toLowerCase() === "stylesheet" || u.removeChild(S), S = j;
          }
        } else
          u === "body" && Ds(o.ownerDocument.body);
      u = y;
    } while (u);
    vi(i);
  }
  function gw(o, i) {
    var u = o;
    o = 0;
    do {
      var p = u.nextSibling;
      if (u.nodeType === 1 ? i ? (u._stashedDisplay = u.style.display, u.style.display = "none") : (u.style.display = u._stashedDisplay || "", u.getAttribute("style") === "" && u.removeAttribute("style")) : u.nodeType === 3 && (i ? (u._stashedText = u.nodeValue, u.nodeValue = "") : u.nodeValue = u._stashedText || ""), p && p.nodeType === 8)
        if (u = p.data, u === "/$") {
          if (o === 0) break;
          o--;
        } else
          u !== "$" && u !== "$?" && u !== "$~" && u !== "$!" || o++;
      u = p;
    } while (u);
  }
  function Jp(o) {
    var i = o.firstChild;
    for (i && i.nodeType === 10 && (i = i.nextSibling); i; ) {
      var u = i;
      switch (i = i.nextSibling, u.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          Jp(u), ou(u);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (u.rel.toLowerCase() === "stylesheet") continue;
      }
      o.removeChild(u);
    }
  }
  function zM(o, i, u, p) {
    for (; o.nodeType === 1; ) {
      var y = u;
      if (o.nodeName.toLowerCase() !== i.toLowerCase()) {
        if (!p && (o.nodeName !== "INPUT" || o.type !== "hidden"))
          break;
      } else if (p) {
        if (!o[La])
          switch (i) {
            case "meta":
              if (!o.hasAttribute("itemprop")) break;
              return o;
            case "link":
              if (S = o.getAttribute("rel"), S === "stylesheet" && o.hasAttribute("data-precedence") || S !== y.rel || o.getAttribute("href") !== (y.href == null || y.href === "" ? null : y.href) || o.getAttribute("crossorigin") !== (y.crossOrigin == null ? null : y.crossOrigin) || o.getAttribute("title") !== (y.title == null ? null : y.title))
                break;
              return o;
            case "style":
              if (o.hasAttribute("data-precedence")) break;
              return o;
            case "script":
              if (S = o.getAttribute("src"), (S !== (y.src == null ? null : y.src) || o.getAttribute("type") !== (y.type == null ? null : y.type) || o.getAttribute("crossorigin") !== (y.crossOrigin == null ? null : y.crossOrigin)) && S && o.hasAttribute("async") && !o.hasAttribute("itemprop"))
                break;
              return o;
            default:
              return o;
          }
      } else if (i === "input" && o.type === "hidden") {
        var S = y.name == null ? null : "" + y.name;
        if (y.type === "hidden" && o.getAttribute("name") === S)
          return o;
      } else return o;
      if (o = ir(o.nextSibling), o === null) break;
    }
    return null;
  }
  function TM(o, i, u) {
    if (i === "") return null;
    for (; o.nodeType !== 3; )
      if ((o.nodeType !== 1 || o.nodeName !== "INPUT" || o.type !== "hidden") && !u || (o = ir(o.nextSibling), o === null)) return null;
    return o;
  }
  function vw(o, i) {
    for (; o.nodeType !== 8; )
      if ((o.nodeType !== 1 || o.nodeName !== "INPUT" || o.type !== "hidden") && !i || (o = ir(o.nextSibling), o === null)) return null;
    return o;
  }
  function Qp(o) {
    return o.data === "$?" || o.data === "$~";
  }
  function Zp(o) {
    return o.data === "$!" || o.data === "$?" && o.ownerDocument.readyState !== "loading";
  }
  function LM(o, i) {
    var u = o.ownerDocument;
    if (o.data === "$~") o._reactRetry = i;
    else if (o.data !== "$?" || u.readyState !== "loading")
      i();
    else {
      var p = function() {
        i(), u.removeEventListener("DOMContentLoaded", p);
      };
      u.addEventListener("DOMContentLoaded", p), o._reactRetry = p;
    }
  }
  function ir(o) {
    for (; o != null; o = o.nextSibling) {
      var i = o.nodeType;
      if (i === 1 || i === 3) break;
      if (i === 8) {
        if (i = o.data, i === "$" || i === "$!" || i === "$?" || i === "$~" || i === "&" || i === "F!" || i === "F")
          break;
        if (i === "/$" || i === "/&") return null;
      }
    }
    return o;
  }
  var em = null;
  function yw(o) {
    o = o.nextSibling;
    for (var i = 0; o; ) {
      if (o.nodeType === 8) {
        var u = o.data;
        if (u === "/$" || u === "/&") {
          if (i === 0)
            return ir(o.nextSibling);
          i--;
        } else
          u !== "$" && u !== "$!" && u !== "$?" && u !== "$~" && u !== "&" || i++;
      }
      o = o.nextSibling;
    }
    return null;
  }
  function bw(o) {
    o = o.previousSibling;
    for (var i = 0; o; ) {
      if (o.nodeType === 8) {
        var u = o.data;
        if (u === "$" || u === "$!" || u === "$?" || u === "$~" || u === "&") {
          if (i === 0) return o;
          i--;
        } else u !== "/$" && u !== "/&" || i++;
      }
      o = o.previousSibling;
    }
    return null;
  }
  function ww(o, i, u) {
    switch (i = tc(u), o) {
      case "html":
        if (o = i.documentElement, !o) throw Error(r(452));
        return o;
      case "head":
        if (o = i.head, !o) throw Error(r(453));
        return o;
      case "body":
        if (o = i.body, !o) throw Error(r(454));
        return o;
      default:
        throw Error(r(451));
    }
  }
  function Ds(o) {
    for (var i = o.attributes; i.length; )
      o.removeAttributeNode(i[0]);
    ou(o);
  }
  var sr = /* @__PURE__ */ new Map(), xw = /* @__PURE__ */ new Set();
  function nc(o) {
    return typeof o.getRootNode == "function" ? o.getRootNode() : o.nodeType === 9 ? o : o.ownerDocument;
  }
  var to = K.d;
  K.d = {
    f: FM,
    r: BM,
    D: UM,
    C: VM,
    L: HM,
    m: WM,
    X: GM,
    S: qM,
    M: KM
  };
  function FM() {
    var o = to.f(), i = Gu();
    return o || i;
  }
  function BM(o) {
    var i = ra(o);
    i !== null && i.tag === 5 && i.type === "form" ? Ty(i) : to.r(o);
  }
  var mi = typeof document > "u" ? null : document;
  function Sw(o, i, u) {
    var p = mi;
    if (p && typeof i == "string" && i) {
      var y = Jn(i);
      y = 'link[rel="' + o + '"][href="' + y + '"]', typeof u == "string" && (y += '[crossorigin="' + u + '"]'), xw.has(y) || (xw.add(y), o = { rel: o, crossOrigin: u, href: i }, p.querySelector(y) === null && (i = p.createElement("link"), ln(i, "link", o), Wt(i), p.head.appendChild(i)));
    }
  }
  function UM(o) {
    to.D(o), Sw("dns-prefetch", o, null);
  }
  function VM(o, i) {
    to.C(o, i), Sw("preconnect", o, i);
  }
  function HM(o, i, u) {
    to.L(o, i, u);
    var p = mi;
    if (p && o && i) {
      var y = 'link[rel="preload"][as="' + Jn(i) + '"]';
      i === "image" && u && u.imageSrcSet ? (y += '[imagesrcset="' + Jn(
        u.imageSrcSet
      ) + '"]', typeof u.imageSizes == "string" && (y += '[imagesizes="' + Jn(
        u.imageSizes
      ) + '"]')) : y += '[href="' + Jn(o) + '"]';
      var S = y;
      switch (i) {
        case "style":
          S = hi(o);
          break;
        case "script":
          S = gi(o);
      }
      sr.has(S) || (o = h(
        {
          rel: "preload",
          href: i === "image" && u && u.imageSrcSet ? void 0 : o,
          as: i
        },
        u
      ), sr.set(S, o), p.querySelector(y) !== null || i === "style" && p.querySelector(Is(S)) || i === "script" && p.querySelector($s(S)) || (i = p.createElement("link"), ln(i, "link", o), Wt(i), p.head.appendChild(i)));
    }
  }
  function WM(o, i) {
    to.m(o, i);
    var u = mi;
    if (u && o) {
      var p = i && typeof i.as == "string" ? i.as : "script", y = 'link[rel="modulepreload"][as="' + Jn(p) + '"][href="' + Jn(o) + '"]', S = y;
      switch (p) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          S = gi(o);
      }
      if (!sr.has(S) && (o = h({ rel: "modulepreload", href: o }, i), sr.set(S, o), u.querySelector(y) === null)) {
        switch (p) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (u.querySelector($s(S)))
              return;
        }
        p = u.createElement("link"), ln(p, "link", o), Wt(p), u.head.appendChild(p);
      }
    }
  }
  function qM(o, i, u) {
    to.S(o, i, u);
    var p = mi;
    if (p && o) {
      var y = oa(p).hoistableStyles, S = hi(o);
      i = i || "default";
      var j = y.get(S);
      if (!j) {
        var T = { loading: 0, preload: null };
        if (j = p.querySelector(
          Is(S)
        ))
          T.loading = 5;
        else {
          o = h(
            { rel: "stylesheet", href: o, "data-precedence": i },
            u
          ), (u = sr.get(S)) && tm(o, u);
          var X = j = p.createElement("link");
          Wt(X), ln(X, "link", o), X._p = new Promise(function(ne, ue) {
            X.onload = ne, X.onerror = ue;
          }), X.addEventListener("load", function() {
            T.loading |= 1;
          }), X.addEventListener("error", function() {
            T.loading |= 2;
          }), T.loading |= 4, rc(j, i, p);
        }
        j = {
          type: "stylesheet",
          instance: j,
          count: 1,
          state: T
        }, y.set(S, j);
      }
    }
  }
  function GM(o, i) {
    to.X(o, i);
    var u = mi;
    if (u && o) {
      var p = oa(u).hoistableScripts, y = gi(o), S = p.get(y);
      S || (S = u.querySelector($s(y)), S || (o = h({ src: o, async: !0 }, i), (i = sr.get(y)) && nm(o, i), S = u.createElement("script"), Wt(S), ln(S, "link", o), u.head.appendChild(S)), S = {
        type: "script",
        instance: S,
        count: 1,
        state: null
      }, p.set(y, S));
    }
  }
  function KM(o, i) {
    to.M(o, i);
    var u = mi;
    if (u && o) {
      var p = oa(u).hoistableScripts, y = gi(o), S = p.get(y);
      S || (S = u.querySelector($s(y)), S || (o = h({ src: o, async: !0, type: "module" }, i), (i = sr.get(y)) && nm(o, i), S = u.createElement("script"), Wt(S), ln(S, "link", o), u.head.appendChild(S)), S = {
        type: "script",
        instance: S,
        count: 1,
        state: null
      }, p.set(y, S));
    }
  }
  function kw(o, i, u, p) {
    var y = (y = oe.current) ? nc(y) : null;
    if (!y) throw Error(r(446));
    switch (o) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof u.precedence == "string" && typeof u.href == "string" ? (i = hi(u.href), u = oa(
          y
        ).hoistableStyles, p = u.get(i), p || (p = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, u.set(i, p)), p) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (u.rel === "stylesheet" && typeof u.href == "string" && typeof u.precedence == "string") {
          o = hi(u.href);
          var S = oa(
            y
          ).hoistableStyles, j = S.get(o);
          if (j || (y = y.ownerDocument || y, j = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, S.set(o, j), (S = y.querySelector(
            Is(o)
          )) && !S._p && (j.instance = S, j.state.loading = 5), sr.has(o) || (u = {
            rel: "preload",
            as: "style",
            href: u.href,
            crossOrigin: u.crossOrigin,
            integrity: u.integrity,
            media: u.media,
            hrefLang: u.hrefLang,
            referrerPolicy: u.referrerPolicy
          }, sr.set(o, u), S || YM(
            y,
            o,
            u,
            j.state
          ))), i && p === null)
            throw Error(r(528, ""));
          return j;
        }
        if (i && p !== null)
          throw Error(r(529, ""));
        return null;
      case "script":
        return i = u.async, u = u.src, typeof u == "string" && i && typeof i != "function" && typeof i != "symbol" ? (i = gi(u), u = oa(
          y
        ).hoistableScripts, p = u.get(i), p || (p = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, u.set(i, p)), p) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(r(444, o));
    }
  }
  function hi(o) {
    return 'href="' + Jn(o) + '"';
  }
  function Is(o) {
    return 'link[rel="stylesheet"][' + o + "]";
  }
  function _w(o) {
    return h({}, o, {
      "data-precedence": o.precedence,
      precedence: null
    });
  }
  function YM(o, i, u, p) {
    o.querySelector('link[rel="preload"][as="style"][' + i + "]") ? p.loading = 1 : (i = o.createElement("link"), p.preload = i, i.addEventListener("load", function() {
      return p.loading |= 1;
    }), i.addEventListener("error", function() {
      return p.loading |= 2;
    }), ln(i, "link", u), Wt(i), o.head.appendChild(i));
  }
  function gi(o) {
    return '[src="' + Jn(o) + '"]';
  }
  function $s(o) {
    return "script[async]" + o;
  }
  function Ew(o, i, u) {
    if (i.count++, i.instance === null)
      switch (i.type) {
        case "style":
          var p = o.querySelector(
            'style[data-href~="' + Jn(u.href) + '"]'
          );
          if (p)
            return i.instance = p, Wt(p), p;
          var y = h({}, u, {
            "data-href": u.href,
            "data-precedence": u.precedence,
            href: null,
            precedence: null
          });
          return p = (o.ownerDocument || o).createElement(
            "style"
          ), Wt(p), ln(p, "style", y), rc(p, u.precedence, o), i.instance = p;
        case "stylesheet":
          y = hi(u.href);
          var S = o.querySelector(
            Is(y)
          );
          if (S)
            return i.state.loading |= 4, i.instance = S, Wt(S), S;
          p = _w(u), (y = sr.get(y)) && tm(p, y), S = (o.ownerDocument || o).createElement("link"), Wt(S);
          var j = S;
          return j._p = new Promise(function(T, X) {
            j.onload = T, j.onerror = X;
          }), ln(S, "link", p), i.state.loading |= 4, rc(S, u.precedence, o), i.instance = S;
        case "script":
          return S = gi(u.src), (y = o.querySelector(
            $s(S)
          )) ? (i.instance = y, Wt(y), y) : (p = u, (y = sr.get(S)) && (p = h({}, u), nm(p, y)), o = o.ownerDocument || o, y = o.createElement("script"), Wt(y), ln(y, "link", p), o.head.appendChild(y), i.instance = y);
        case "void":
          return null;
        default:
          throw Error(r(443, i.type));
      }
    else
      i.type === "stylesheet" && (i.state.loading & 4) === 0 && (p = i.instance, i.state.loading |= 4, rc(p, u.precedence, o));
    return i.instance;
  }
  function rc(o, i, u) {
    for (var p = u.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), y = p.length ? p[p.length - 1] : null, S = y, j = 0; j < p.length; j++) {
      var T = p[j];
      if (T.dataset.precedence === i) S = T;
      else if (S !== y) break;
    }
    S ? S.parentNode.insertBefore(o, S.nextSibling) : (i = u.nodeType === 9 ? u.head : u, i.insertBefore(o, i.firstChild));
  }
  function tm(o, i) {
    o.crossOrigin == null && (o.crossOrigin = i.crossOrigin), o.referrerPolicy == null && (o.referrerPolicy = i.referrerPolicy), o.title == null && (o.title = i.title);
  }
  function nm(o, i) {
    o.crossOrigin == null && (o.crossOrigin = i.crossOrigin), o.referrerPolicy == null && (o.referrerPolicy = i.referrerPolicy), o.integrity == null && (o.integrity = i.integrity);
  }
  var oc = null;
  function Cw(o, i, u) {
    if (oc === null) {
      var p = /* @__PURE__ */ new Map(), y = oc = /* @__PURE__ */ new Map();
      y.set(u, p);
    } else
      y = oc, p = y.get(u), p || (p = /* @__PURE__ */ new Map(), y.set(u, p));
    if (p.has(o)) return p;
    for (p.set(o, null), u = u.getElementsByTagName(o), y = 0; y < u.length; y++) {
      var S = u[y];
      if (!(S[La] || S[en] || o === "link" && S.getAttribute("rel") === "stylesheet") && S.namespaceURI !== "http://www.w3.org/2000/svg") {
        var j = S.getAttribute(i) || "";
        j = o + j;
        var T = p.get(j);
        T ? T.push(S) : p.set(j, [S]);
      }
    }
    return p;
  }
  function Ow(o, i, u) {
    o = o.ownerDocument || o, o.head.insertBefore(
      u,
      i === "title" ? o.querySelector("head > title") : null
    );
  }
  function XM(o, i, u) {
    if (u === 1 || i.itemProp != null) return !1;
    switch (o) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof i.precedence != "string" || typeof i.href != "string" || i.href === "")
          break;
        return !0;
      case "link":
        if (typeof i.rel != "string" || typeof i.href != "string" || i.href === "" || i.onLoad || i.onError)
          break;
        return i.rel === "stylesheet" ? (o = i.disabled, typeof i.precedence == "string" && o == null) : !0;
      case "script":
        if (i.async && typeof i.async != "function" && typeof i.async != "symbol" && !i.onLoad && !i.onError && i.src && typeof i.src == "string")
          return !0;
    }
    return !1;
  }
  function Mw(o) {
    return !(o.type === "stylesheet" && (o.state.loading & 3) === 0);
  }
  function JM(o, i, u, p) {
    if (u.type === "stylesheet" && (typeof p.media != "string" || matchMedia(p.media).matches !== !1) && (u.state.loading & 4) === 0) {
      if (u.instance === null) {
        var y = hi(p.href), S = i.querySelector(
          Is(y)
        );
        if (S) {
          i = S._p, i !== null && typeof i == "object" && typeof i.then == "function" && (o.count++, o = ac.bind(o), i.then(o, o)), u.state.loading |= 4, u.instance = S, Wt(S);
          return;
        }
        S = i.ownerDocument || i, p = _w(p), (y = sr.get(y)) && tm(p, y), S = S.createElement("link"), Wt(S);
        var j = S;
        j._p = new Promise(function(T, X) {
          j.onload = T, j.onerror = X;
        }), ln(S, "link", p), u.instance = S;
      }
      o.stylesheets === null && (o.stylesheets = /* @__PURE__ */ new Map()), o.stylesheets.set(u, i), (i = u.state.preload) && (u.state.loading & 3) === 0 && (o.count++, u = ac.bind(o), i.addEventListener("load", u), i.addEventListener("error", u));
    }
  }
  var rm = 0;
  function QM(o, i) {
    return o.stylesheets && o.count === 0 && sc(o, o.stylesheets), 0 < o.count || 0 < o.imgCount ? function(u) {
      var p = setTimeout(function() {
        if (o.stylesheets && sc(o, o.stylesheets), o.unsuspend) {
          var S = o.unsuspend;
          o.unsuspend = null, S();
        }
      }, 6e4 + i);
      0 < o.imgBytes && rm === 0 && (rm = 62500 * jM());
      var y = setTimeout(
        function() {
          if (o.waitingForImages = !1, o.count === 0 && (o.stylesheets && sc(o, o.stylesheets), o.unsuspend)) {
            var S = o.unsuspend;
            o.unsuspend = null, S();
          }
        },
        (o.imgBytes > rm ? 50 : 800) + i
      );
      return o.unsuspend = u, function() {
        o.unsuspend = null, clearTimeout(p), clearTimeout(y);
      };
    } : null;
  }
  function ac() {
    if (this.count--, this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
      if (this.stylesheets) sc(this, this.stylesheets);
      else if (this.unsuspend) {
        var o = this.unsuspend;
        this.unsuspend = null, o();
      }
    }
  }
  var ic = null;
  function sc(o, i) {
    o.stylesheets = null, o.unsuspend !== null && (o.count++, ic = /* @__PURE__ */ new Map(), i.forEach(ZM, o), ic = null, ac.call(o));
  }
  function ZM(o, i) {
    if (!(i.state.loading & 4)) {
      var u = ic.get(o);
      if (u) var p = u.get(null);
      else {
        u = /* @__PURE__ */ new Map(), ic.set(o, u);
        for (var y = o.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), S = 0; S < y.length; S++) {
          var j = y[S];
          (j.nodeName === "LINK" || j.getAttribute("media") !== "not all") && (u.set(j.dataset.precedence, j), p = j);
        }
        p && u.set(null, p);
      }
      y = i.instance, j = y.getAttribute("data-precedence"), S = u.get(j) || p, S === p && u.set(null, y), u.set(j, y), this.count++, p = ac.bind(this), y.addEventListener("load", p), y.addEventListener("error", p), S ? S.parentNode.insertBefore(y, S.nextSibling) : (o = o.nodeType === 9 ? o.head : o, o.insertBefore(y, o.firstChild)), i.state.loading |= 4;
    }
  }
  var zs = {
    $$typeof: _,
    Provider: null,
    Consumer: null,
    _currentValue: q,
    _currentValue2: q,
    _threadCount: 0
  };
  function eN(o, i, u, p, y, S, j, T, X) {
    this.tag = 1, this.containerInfo = o, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = tu(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = tu(0), this.hiddenUpdates = tu(null), this.identifierPrefix = p, this.onUncaughtError = y, this.onCaughtError = S, this.onRecoverableError = j, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = X, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function Nw(o, i, u, p, y, S, j, T, X, ne, ue, pe) {
    return o = new eN(
      o,
      i,
      u,
      j,
      X,
      ne,
      ue,
      pe,
      T
    ), i = 1, S === !0 && (i |= 24), S = Un(3, null, null, i), o.current = S, S.stateNode = o, i = $f(), i.refCount++, o.pooledCache = i, i.refCount++, S.memoizedState = {
      element: p,
      isDehydrated: u,
      cache: i
    }, Ff(S), o;
  }
  function Aw(o) {
    return o ? (o = Ga, o) : Ga;
  }
  function Rw(o, i, u, p, y, S) {
    y = Aw(y), p.context === null ? p.context = y : p.pendingContext = y, p = go(i), p.payload = { element: u }, S = S === void 0 ? null : S, S !== null && (p.callback = S), u = vo(o, p, i), u !== null && (Pn(u, o, i), hs(u, o, i));
  }
  function jw(o, i) {
    if (o = o.memoizedState, o !== null && o.dehydrated !== null) {
      var u = o.retryLane;
      o.retryLane = u !== 0 && u < i ? u : i;
    }
  }
  function om(o, i) {
    jw(o, i), (o = o.alternate) && jw(o, i);
  }
  function Pw(o) {
    if (o.tag === 13 || o.tag === 31) {
      var i = ua(o, 67108864);
      i !== null && Pn(i, o, 67108864), om(o, 67108864);
    }
  }
  function Dw(o) {
    if (o.tag === 13 || o.tag === 31) {
      var i = Gn();
      i = nu(i);
      var u = ua(o, i);
      u !== null && Pn(u, o, i), om(o, i);
    }
  }
  var lc = !0;
  function tN(o, i, u, p) {
    var y = $.T;
    $.T = null;
    var S = K.p;
    try {
      K.p = 2, am(o, i, u, p);
    } finally {
      K.p = S, $.T = y;
    }
  }
  function nN(o, i, u, p) {
    var y = $.T;
    $.T = null;
    var S = K.p;
    try {
      K.p = 8, am(o, i, u, p);
    } finally {
      K.p = S, $.T = y;
    }
  }
  function am(o, i, u, p) {
    if (lc) {
      var y = im(p);
      if (y === null)
        Wp(
          o,
          i,
          p,
          uc,
          u
        ), $w(o, p);
      else if (oN(
        y,
        o,
        i,
        u,
        p
      ))
        p.stopPropagation();
      else if ($w(o, p), i & 4 && -1 < rN.indexOf(o)) {
        for (; y !== null; ) {
          var S = ra(y);
          if (S !== null)
            switch (S.tag) {
              case 3:
                if (S = S.stateNode, S.current.memoizedState.isDehydrated) {
                  var j = _r(S.pendingLanes);
                  if (j !== 0) {
                    var T = S;
                    for (T.pendingLanes |= 2, T.entangledLanes |= 2; j; ) {
                      var X = 1 << 31 - Ae(j);
                      T.entanglements[1] |= X, j &= ~X;
                    }
                    Nr(S), (Ze & 6) === 0 && (Wu = Ce() + 500, Rs(0));
                  }
                }
                break;
              case 31:
              case 13:
                T = ua(S, 2), T !== null && Pn(T, S, 2), Gu(), om(S, 2);
            }
          if (S = im(p), S === null && Wp(
            o,
            i,
            p,
            uc,
            u
          ), S === y) break;
          y = S;
        }
        y !== null && p.stopPropagation();
      } else
        Wp(
          o,
          i,
          p,
          null,
          u
        );
    }
  }
  function im(o) {
    return o = lf(o), sm(o);
  }
  var uc = null;
  function sm(o) {
    if (uc = null, o = na(o), o !== null) {
      var i = s(o);
      if (i === null) o = null;
      else {
        var u = i.tag;
        if (u === 13) {
          if (o = l(i), o !== null) return o;
          o = null;
        } else if (u === 31) {
          if (o = c(i), o !== null) return o;
          o = null;
        } else if (u === 3) {
          if (i.stateNode.current.memoizedState.isDehydrated)
            return i.tag === 3 ? i.stateNode.containerInfo : null;
          o = null;
        } else i !== o && (o = null);
      }
    }
    return uc = o, null;
  }
  function Iw(o) {
    switch (o) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (Me()) {
          case he:
            return 2;
          case ye:
            return 8;
          case Ee:
          case Te:
            return 32;
          case Fe:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var lm = !1, Mo = null, No = null, Ao = null, Ts = /* @__PURE__ */ new Map(), Ls = /* @__PURE__ */ new Map(), Ro = [], rN = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function $w(o, i) {
    switch (o) {
      case "focusin":
      case "focusout":
        Mo = null;
        break;
      case "dragenter":
      case "dragleave":
        No = null;
        break;
      case "mouseover":
      case "mouseout":
        Ao = null;
        break;
      case "pointerover":
      case "pointerout":
        Ts.delete(i.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Ls.delete(i.pointerId);
    }
  }
  function Fs(o, i, u, p, y, S) {
    return o === null || o.nativeEvent !== S ? (o = {
      blockedOn: i,
      domEventName: u,
      eventSystemFlags: p,
      nativeEvent: S,
      targetContainers: [y]
    }, i !== null && (i = ra(i), i !== null && Pw(i)), o) : (o.eventSystemFlags |= p, i = o.targetContainers, y !== null && i.indexOf(y) === -1 && i.push(y), o);
  }
  function oN(o, i, u, p, y) {
    switch (i) {
      case "focusin":
        return Mo = Fs(
          Mo,
          o,
          i,
          u,
          p,
          y
        ), !0;
      case "dragenter":
        return No = Fs(
          No,
          o,
          i,
          u,
          p,
          y
        ), !0;
      case "mouseover":
        return Ao = Fs(
          Ao,
          o,
          i,
          u,
          p,
          y
        ), !0;
      case "pointerover":
        var S = y.pointerId;
        return Ts.set(
          S,
          Fs(
            Ts.get(S) || null,
            o,
            i,
            u,
            p,
            y
          )
        ), !0;
      case "gotpointercapture":
        return S = y.pointerId, Ls.set(
          S,
          Fs(
            Ls.get(S) || null,
            o,
            i,
            u,
            p,
            y
          )
        ), !0;
    }
    return !1;
  }
  function zw(o) {
    var i = na(o.target);
    if (i !== null) {
      var u = s(i);
      if (u !== null) {
        if (i = u.tag, i === 13) {
          if (i = l(u), i !== null) {
            o.blockedOn = i, Jd(o.priority, function() {
              Dw(u);
            });
            return;
          }
        } else if (i === 31) {
          if (i = c(u), i !== null) {
            o.blockedOn = i, Jd(o.priority, function() {
              Dw(u);
            });
            return;
          }
        } else if (i === 3 && u.stateNode.current.memoizedState.isDehydrated) {
          o.blockedOn = u.tag === 3 ? u.stateNode.containerInfo : null;
          return;
        }
      }
    }
    o.blockedOn = null;
  }
  function cc(o) {
    if (o.blockedOn !== null) return !1;
    for (var i = o.targetContainers; 0 < i.length; ) {
      var u = im(o.nativeEvent);
      if (u === null) {
        u = o.nativeEvent;
        var p = new u.constructor(
          u.type,
          u
        );
        sf = p, u.target.dispatchEvent(p), sf = null;
      } else
        return i = ra(u), i !== null && Pw(i), o.blockedOn = u, !1;
      i.shift();
    }
    return !0;
  }
  function Tw(o, i, u) {
    cc(o) && u.delete(i);
  }
  function aN() {
    lm = !1, Mo !== null && cc(Mo) && (Mo = null), No !== null && cc(No) && (No = null), Ao !== null && cc(Ao) && (Ao = null), Ts.forEach(Tw), Ls.forEach(Tw);
  }
  function dc(o, i) {
    o.blockedOn === i && (o.blockedOn = null, lm || (lm = !0, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      aN
    )));
  }
  var fc = null;
  function Lw(o) {
    fc !== o && (fc = o, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      function() {
        fc === o && (fc = null);
        for (var i = 0; i < o.length; i += 3) {
          var u = o[i], p = o[i + 1], y = o[i + 2];
          if (typeof p != "function") {
            if (sm(p || u) === null)
              continue;
            break;
          }
          var S = ra(u);
          S !== null && (o.splice(i, 3), i -= 3, ip(
            S,
            {
              pending: !0,
              data: y,
              method: u.method,
              action: p
            },
            p,
            y
          ));
        }
      }
    ));
  }
  function vi(o) {
    function i(X) {
      return dc(X, o);
    }
    Mo !== null && dc(Mo, o), No !== null && dc(No, o), Ao !== null && dc(Ao, o), Ts.forEach(i), Ls.forEach(i);
    for (var u = 0; u < Ro.length; u++) {
      var p = Ro[u];
      p.blockedOn === o && (p.blockedOn = null);
    }
    for (; 0 < Ro.length && (u = Ro[0], u.blockedOn === null); )
      zw(u), u.blockedOn === null && Ro.shift();
    if (u = (o.ownerDocument || o).$$reactFormReplay, u != null)
      for (p = 0; p < u.length; p += 3) {
        var y = u[p], S = u[p + 1], j = y[yn] || null;
        if (typeof S == "function")
          j || Lw(u);
        else if (j) {
          var T = null;
          if (S && S.hasAttribute("formAction")) {
            if (y = S, j = S[yn] || null)
              T = j.formAction;
            else if (sm(y) !== null) continue;
          } else T = j.action;
          typeof T == "function" ? u[p + 1] = T : (u.splice(p, 3), p -= 3), Lw(u);
        }
      }
  }
  function Fw() {
    function o(S) {
      S.canIntercept && S.info === "react-transition" && S.intercept({
        handler: function() {
          return new Promise(function(j) {
            return y = j;
          });
        },
        focusReset: "manual",
        scroll: "manual"
      });
    }
    function i() {
      y !== null && (y(), y = null), p || setTimeout(u, 20);
    }
    function u() {
      if (!p && !navigation.transition) {
        var S = navigation.currentEntry;
        S && S.url != null && navigation.navigate(S.url, {
          state: S.getState(),
          info: "react-transition",
          history: "replace"
        });
      }
    }
    if (typeof navigation == "object") {
      var p = !1, y = null;
      return navigation.addEventListener("navigate", o), navigation.addEventListener("navigatesuccess", i), navigation.addEventListener("navigateerror", i), setTimeout(u, 100), function() {
        p = !0, navigation.removeEventListener("navigate", o), navigation.removeEventListener("navigatesuccess", i), navigation.removeEventListener("navigateerror", i), y !== null && (y(), y = null);
      };
    }
  }
  function um(o) {
    this._internalRoot = o;
  }
  pc.prototype.render = um.prototype.render = function(o) {
    var i = this._internalRoot;
    if (i === null) throw Error(r(409));
    var u = i.current, p = Gn();
    Rw(u, p, o, i, null, null);
  }, pc.prototype.unmount = um.prototype.unmount = function() {
    var o = this._internalRoot;
    if (o !== null) {
      this._internalRoot = null;
      var i = o.containerInfo;
      Rw(o.current, 2, null, o, null, null), Gu(), i[Ho] = null;
    }
  };
  function pc(o) {
    this._internalRoot = o;
  }
  pc.prototype.unstable_scheduleHydration = function(o) {
    if (o) {
      var i = Xd();
      o = { blockedOn: null, target: o, priority: i };
      for (var u = 0; u < Ro.length && i !== 0 && i < Ro[u].priority; u++) ;
      Ro.splice(u, 0, o), u === 0 && zw(o);
    }
  };
  var Bw = t.version;
  if (Bw !== "19.2.3")
    throw Error(
      r(
        527,
        Bw,
        "19.2.3"
      )
    );
  K.findDOMNode = function(o) {
    var i = o._reactInternals;
    if (i === void 0)
      throw typeof o.render == "function" ? Error(r(188)) : (o = Object.keys(o).join(","), Error(r(268, o)));
    return o = f(i), o = o !== null ? m(o) : null, o = o === null ? null : o.stateNode, o;
  };
  var iN = {
    bundleType: 0,
    version: "19.2.3",
    rendererPackageName: "react-dom",
    currentDispatcherRef: $,
    reconcilerVersion: "19.2.3"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var mc = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!mc.isDisabled && mc.supportsFiber)
      try {
        Xt = mc.inject(
          iN
        ), Nt = mc;
      } catch {
      }
  }
  return Ww.createRoot = function(o, i) {
    if (!a(o)) throw Error(r(299));
    var u = !1, p = "", y = Ky, S = Yy, j = Xy;
    return i != null && (i.unstable_strictMode === !0 && (u = !0), i.identifierPrefix !== void 0 && (p = i.identifierPrefix), i.onUncaughtError !== void 0 && (y = i.onUncaughtError), i.onCaughtError !== void 0 && (S = i.onCaughtError), i.onRecoverableError !== void 0 && (j = i.onRecoverableError)), i = Nw(
      o,
      1,
      !1,
      null,
      null,
      u,
      p,
      null,
      y,
      S,
      j,
      Fw
    ), o[Ho] = i.current, Hp(o), new um(i);
  }, Ww.hydrateRoot = function(o, i, u) {
    if (!a(o)) throw Error(r(299));
    var p = !1, y = "", S = Ky, j = Yy, T = Xy, X = null;
    return u != null && (u.unstable_strictMode === !0 && (p = !0), u.identifierPrefix !== void 0 && (y = u.identifierPrefix), u.onUncaughtError !== void 0 && (S = u.onUncaughtError), u.onCaughtError !== void 0 && (j = u.onCaughtError), u.onRecoverableError !== void 0 && (T = u.onRecoverableError), u.formState !== void 0 && (X = u.formState)), i = Nw(
      o,
      1,
      !0,
      i,
      u ?? null,
      p,
      y,
      X,
      S,
      j,
      T,
      Fw
    ), i.context = Aw(null), u = i.current, p = Gn(), p = nu(p), y = go(p), y.callback = null, vo(u, y, p), u = p, i.current.lanes = u, Ta(i, u), Nr(i), o[Ho] = i.current, Hp(o), new pc(i);
  }, Ww.version = "19.2.3", Ww;
}
var K1;
function NZ() {
  if (K1) return mN.exports;
  K1 = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), mN.exports = MZ(), mN.exports;
}
var AZ = NZ();
const ro = {
  /** Debug level - most verbose, for development debugging */
  DEBUG: 0,
  /** Info level - general information about application flow */
  INFO: 10,
  /** Warning level - concerning but non-critical issues */
  WARN: 20,
  /** Error level - critical problems requiring attention */
  ERROR: 30
}, Y8 = ro.DEBUG, X8 = ro.INFO, RZ = ro.WARN, jZ = ro.ERROR, Y1 = (e) => typeof e == "string" ? e : e === ro.DEBUG ? "DEBUG" : e === ro.INFO ? "INFO" : e === ro.WARN ? "WARN" : e === ro.ERROR ? "ERROR" : "UNKNOWN";
function PZ() {
  const e = [];
  return function(t, n) {
    if (typeof n != "object" || n === null)
      return n;
    for (; e.length > 0 && e.at(-1) !== this; )
      e.pop();
    return e.includes(n) ? "[Circular]" : (e.push(n), n);
  };
}
const X1 = (e) => {
  if (typeof e == "number") return e;
  const t = e.toLowerCase();
  if (t === "debug") return ro.DEBUG;
  if (t === "info") return ro.INFO;
  if (t === "warn" || t === "warning") return ro.WARN;
  if (t === "error") return ro.ERROR;
  throw new Error(`Unknown log level: ${e}`);
};
class $R {
  /**
   * Create a new BaseLogger instance.
   *
   * @param {string} name - The name/identifier for this logger
   * @param {number | string} [level=LEVELS.INFO] - Initial log level
   * @param {boolean} [with_timestamp=true] - Whether to include timestamps
   * @example
   * ```typescript
   * const logger = new MyLogger("DatabaseService", "DEBUG", true);
   * ```
   */
  constructor(t, n = ro.INFO, r = !0) {
    this.name = t, this.level = X1(n), this._level_name = Y1(this.level), this.with_timestamp = r;
  }
  /**
   * Set the logging level for this logger instance.
   *
   * @param {number | string} level - The new log level (numeric or string)
   * @example
   * ```typescript
   * logger.set_level(DEBUG); // Enable debug logging
   * logger.set_level("debug"); // Same as above using string
   * ```
   */
  set_level(t) {
    typeof t == "string" && (t = X1(t)), this.level = t, this._level_name = Y1(this.level);
  }
  /**
   * Get the string representation of the current log level.
   *
   * @returns {string} The current log level as a string
   * @example
   * ```typescript
   * logger.level_name // "INFO"
   * ```
   */
  get level_name() {
    return this._level_name;
  }
  /**
   * Format a log message with level, timestamp, and arguments.
   *
   * @param {string} levelstring - The log level string (DEBUG, INFO, etc.)
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional arguments to include
   * @returns {string} The formatted log message
   * @example
   * ```typescript
   * // Returns: "12/25/2023, 10:30:15 AM [MyApp] INFO: User logged in {userId: 123}"
   * logger.format_message("INFO", "User logged in", {userId: 123});
   * ```
   */
  format_message(t, n, ...r) {
    return `${this.with_timestamp ? (/* @__PURE__ */ new Date()).toLocaleString() : ""} [${this.name}] ${t}: ${n} ${r.map((a) => JSON.stringify(a, PZ())).join(" ")}`.trim();
  }
  /**
   * Log a debug message if the current level allows it.
   *
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional context arguments
   */
  debug(t, ...n) {
    this.level <= ro.DEBUG && this.out_debug(this.format_message("DEBUG", t, ...n));
  }
  /**
   * Log an info message if the current level allows it.
   *
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional context arguments
   */
  info(t, ...n) {
    this.level <= ro.INFO && this.out_info(this.format_message("INFO", t, ...n));
  }
  /**
   * Log a warning message if the current level allows it.
   *
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional context arguments
   */
  warn(t, ...n) {
    this.level <= ro.WARN && this.out_warn(this.format_message("WARN", t, ...n));
  }
  /**
   * Log an error message if the current level allows it.
   *
   * @param {string} message - The primary log message
   * @param {Error} [error] - Optional Error object for stack trace handling
   */
  error(t, n) {
    this.level <= ro.ERROR && this.out_error(this.format_message("ERROR", t), n);
  }
}
class zR extends $R {
  /**
   * Create a new ConsoleLogger instance.
   *
   * @param {string} name - The name/identifier for this logger
   * @param {number | string} [level=LEVELS.INFO] - Initial log level
   * @example
   * ```typescript
   * const logger = new ConsoleLogger("API", "WARN");
   * ```
   */
  constructor(t, n = ro.INFO) {
    super(t, n);
  }
  /**
   * Output debug message to console.debug.
   *
   * @protected
   * @param {string} formatted_message - The formatted message to output
   */
  out_debug(t) {
    console.debug(t);
  }
  /**
   * Output info message to console.info.
   *
   * @protected
   * @param {string} formatted_message - The formatted message to output
   */
  out_info(t) {
    console.info(t);
  }
  /**
   * Output warning message to console.warn.
   *
   * @protected
   * @param {string} formatted_message - The formatted message to output
   */
  out_warn(t) {
    console.warn(t);
  }
  /**
   * Output error message to console.error.
   *
   * @protected
   * @param {string} formatted_message - The formatted message to output
   * @param {Error | undefined} error - Optional Error object for stack trace handling
   */
  out_error(t, n) {
    console.error(t), n && console.error(n);
  }
}
function hN(e) {
  return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
class DZ extends $R {
  /**
   * Create a new DivLogger instance.
   *
   * @param {HTMLDivElement} div - The HTML div element to append log messages to
   * @param {string} name - The name/identifier for this logger
   * @param {number | string} [level=LEVELS.INFO] - Initial log level
   * @example
   * ```typescript
   * const logContainer = document.createElement('div');
   * const logger = new DivLogger(logContainer, "WebWorker", "DEBUG");
   * ```
   */
  constructor(t, n, r = ro.INFO) {
    super(n, r), this._div = t;
  }
  /**
   * Format a log message with HTML escaping for safe DOM insertion.
   *
   * Overrides the base implementation to automatically escape HTML content,
   * preventing XSS vulnerabilities when displaying logs in web interfaces.
   *
   * @param {string} levelstring - The log level string (DEBUG, INFO, etc.)
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional arguments to include
   * @returns {string} The formatted and HTML-escaped log message
   * @example
   * ```typescript
   * // Input: "User input: <script>alert('xss')<\/script>"
   * // Output: "12/25/2023, 10:30:15 AM [UI] INFO: User input: &lt;script&gt;alert('xss')&lt;/script&gt;"
   * ```
   */
  format_message(t, n, ...r) {
    return hN(super.format_message(t, n, ...r));
  }
  /**
   * Output debug message as HTML div with 'debug' class.
   *
   * @protected
   * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
   */
  out_debug(t) {
    this._div.innerHTML += `<div class="debug">${t}</div>`;
  }
  /**
   * Output info message as HTML div with 'info' class.
   *
   * @protected
   * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
   */
  out_info(t) {
    this._div.innerHTML += `<div class="info">${t}</div>`;
  }
  /**
   * Output warning message as HTML div with 'warn' class.
   *
   * @protected
   * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
   */
  out_warn(t) {
    this._div.innerHTML += `<div class="warn">${t}</div>`;
  }
  /**
   * Output error message as HTML div with 'error' class.
   *
   * @protected
   * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
   * @param {Error | undefined} error - Optional Error object for stack trace handling
   */
  out_error(t, n) {
    let r = t;
    if (n) {
      const a = n.stack ? hN(n.stack) : hN(n.message);
      r += `<br><pre>${a}</pre>`;
    }
    this._div.innerHTML += `<div class="error">${r}</div>`;
  }
}
function IZ(e) {
  const t = window.atob(e), n = t.length, r = new Uint8Array(n);
  for (let a = 0; a < n; a++)
    r[a] = t.charCodeAt(a);
  return r;
}
function $Z(e, t) {
  return new Blob([e], { type: t });
}
function zZ(e, t) {
  return $Z(IZ(e), t);
}
function TZ(e, t, n) {
  const r = zZ(e, n), a = URL.createObjectURL(r), s = document.createElement("a");
  s.href = a, s.download = t, s.click(), URL.revokeObjectURL(a), s.remove();
}
function LZ(e, t = !0) {
  return new Promise((n, r) => {
    const a = new FileReader();
    a.onload = () => {
      const s = a.result;
      n(t ? s.split(",")[1] : s);
    }, a.onerror = () => r(a.error), a.readAsDataURL(e);
  });
}
function FZ(e) {
  return new Promise((t, n) => {
    const r = document.createElement("input");
    r.type = "file", r.accept = e, r.onchange = () => {
      const a = r.files?.[0];
      a ? t(a) : n(new Error("No file selected"));
    }, r.oncancel = () => {
      n(new Error("File selection cancelled"));
    }, r.click();
  });
}
function BZ(e) {
  return FZ(e).then(LZ);
}
async function UZ(e, t = !0) {
  try {
    const n = await fetch(e);
    if (!n.ok)
      throw new Error(
        `Failed to fetch from URL: ${n.status} ${n.statusText}`
      );
    const r = await n.blob();
    return await new Promise((a, s) => {
      const l = new FileReader();
      l.onload = () => {
        const c = l.result;
        typeof c != "string" && (s("Failed to convert URL to Base64: No result from FileReader"), s(l.error)), a(t ? c.split(",")[1] : c);
      }, l.onerror = () => s(l.error), l.readAsDataURL(r);
    });
  } catch (n) {
    throw console.error("Error converting URL to Base64:", n), n;
  }
}
function hd(e) {
  if (Object.prototype.toString.call(e) !== "[object Object]")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype;
}
function TR(e, t, n = /* @__PURE__ */ new WeakMap()) {
  if (e === t) return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (n.has(e))
    return n.get(e) === t;
  if (n.set(e, t), e.constructor !== t.constructor) return !1;
  if (e.constructor === Object || e.constructor === Array) {
    const r = Object.keys(e), a = Object.keys(t);
    if (r.length !== a.length) return !1;
    for (const s of r)
      if (!a.includes(s) || !TR(e[s], t[s], n)) return !1;
  }
  return e instanceof Date && t instanceof Date ? e.getTime() === t.getTime() : !0;
}
const Ed = (e, t) => {
  let n = !1;
  if (!hd(e))
    throw new Error("Target must be a plain object not" + typeof e);
  if (!hd(t))
    throw new Error("Source must be a plain object not" + typeof t);
  const r = { ...e };
  return Object.keys(t).forEach((a) => {
    const s = t[a], l = e[a];
    if (hd(s) && hd(l)) {
      const { new_obj: c, change: d } = Ed(
        l,
        s
      );
      d && (n = !0, r[a] = c);
    } else TR(l, s) || (n = !0, r[a] = s);
  }), { new_obj: r, change: n };
}, LR = (e, t) => {
  let n = !1;
  if (!hd(e))
    throw new Error("Target must be a plain object");
  if (!hd(t))
    throw new Error("Source must be a plain object");
  const r = { ...e };
  return Object.keys(t).forEach((a) => {
    const s = t[a], l = e[a];
    if (!(l === void 0 && s === void 0)) {
      if (l === void 0) {
        n = !0, r[a] = s;
        return;
      }
      if (hd(s) && hd(l)) {
        const { new_obj: c, change: d } = LR(
          l,
          s
        );
        d && (n = !0, r[a] = c);
      }
    }
  }), { new_obj: r, change: n };
}, US = (e, t = void 0) => {
  const n = JSON.stringify(e);
  return (r) => {
    let a = JSON.parse(n);
    return t !== void 0 && (a = t(a)), r === void 0 ? a : LR(r, a).new_obj;
  };
}, Ti = (e, t) => t === void 0 ? [e, !1] : [t, e !== t];
function J8(e, t) {
  throw new Error("Unhandled case: " + e + " with: " + JSON.stringify(t));
}
const Uh = (e, t) => {
  if (t === void 0) return [e, !1];
  if (e === void 0) return [t, t !== void 0];
  const { new_obj: n, change: r } = Ed(e, t);
  return [n, r];
}, VZ = ({ error: e }) => /* @__PURE__ */ C.jsxs("div", { className: "error-div", children: [
  /* @__PURE__ */ C.jsx("h1", { children: "Error" }),
  /* @__PURE__ */ C.jsx("p", { children: e.message })
] }), iE = M.createContext(
  void 0
), gd = M.forwardRef((e, t) => {
  const {
    asChild: n = !1,
    children: r,
    className: a,
    style: s,
    htime: l = 300,
    vtime: c = 300,
    hdelay: d = 0,
    vdelay: f = 200,
    zIndex: m = 9999,
    ...h
  } = e, [v, g] = M.useState(!1), [b, x] = M.useState({}), w = M.useRef(null), k = M.useRef(null);
  M.useImperativeHandle(t, () => w.current, []);
  const E = M.useMemo(
    () => ({
      horizontal: l,
      vertical: c,
      horizontalDelay: d,
      verticalDelay: f
    }),
    [l, c, d, f]
  ), _ = M.useCallback(
    () => Math.max(
      E.horizontal + E.horizontalDelay,
      E.vertical + E.verticalDelay
    ),
    [E]
  ), O = M.useCallback(async () => {
    if (w.current)
      try {
        const B = w.current.getBoundingClientRect();
        k.current = B, x({
          position: "fixed",
          top: `${B.top}px`,
          left: `${B.left}px`,
          width: `${B.width}px`,
          height: `${B.height}px`,
          zIndex: m,
          transition: "none"
        }), g(!0), w.current.offsetHeight, x((P) => ({
          ...P,
          transition: [
            `width ${E.horizontal}ms ease-in-out ${E.horizontalDelay}ms`,
            `left ${E.horizontal}ms ease-in-out ${E.horizontalDelay}ms`,
            `height ${E.vertical}ms ease-in-out ${E.verticalDelay}ms`,
            `top ${E.vertical}ms ease-in-out ${E.verticalDelay}ms`
          ].join(", ")
        })), requestAnimationFrame(() => {
          x((P) => ({
            ...P,
            top: "0",
            left: "0",
            width: "100vw",
            height: "100vh"
          }));
        }), await new Promise((P) => setTimeout(P, _()));
      } catch (B) {
        console.warn("Error during expand animation:", B), g(!0);
      }
  }, [E, m, _]), N = M.useCallback(async () => {
    if (!w.current || !k.current) return;
    const B = k.current;
    x((P) => ({
      ...P,
      transition: [
        `width ${E.horizontal}ms ease-in-out ${E.verticalDelay}ms`,
        `left ${E.horizontal}ms ease-in-out ${E.verticalDelay}ms`,
        `height ${E.vertical}ms ease-in-out ${E.horizontalDelay}ms`,
        `top ${E.vertical}ms ease-in-out ${E.horizontalDelay}ms`
      ].join(", ")
    })), requestAnimationFrame(() => {
      x((P) => ({
        ...P,
        top: `${B.top}px`,
        left: `${B.left}px`,
        width: `${B.width}px`,
        height: `${B.height}px`
      }));
    }), await new Promise((P) => setTimeout(P, _())), x({}), g(!1), k.current = null;
  }, [E, _]), A = M.useCallback(async () => {
    v ? await N() : await O();
  }, [v, O, N]), R = M.useMemo(
    () => ({ isExpanded: v, toggleExpand: A }),
    [v, A]
  ), D = M.useMemo(
    () => ({ ...s, ...b }),
    [s, b]
  );
  let I;
  if (n && M.isValidElement(r)) {
    const B = r;
    I = M.cloneElement(B, {
      ref: w,
      className: [B.props.className, a].filter(Boolean).join(" "),
      style: { ...B.props.style, ...D },
      ...h
    });
  } else
    I = /* @__PURE__ */ C.jsx("div", { ref: w, className: a, style: D, ...h, children: r });
  const z = /* @__PURE__ */ C.jsx(iE.Provider, { value: R, children: I });
  return v ? Xm.createPortal(z, document.body) : z;
});
gd.displayName = "SmoothExpand";
gd.Trigger = function({
  children: e,
  className: t
}) {
  const n = M.useContext(iE);
  if (!n)
    throw new Error(
      "SmoothExpand.Trigger must be used within a SmoothExpand component"
    );
  return /* @__PURE__ */ C.jsx(
    "div",
    {
      className: t,
      style: { cursor: "pointer" },
      onClick: n.toggleExpand,
      role: "button",
      tabIndex: 0,
      onKeyDown: (r) => {
        (r.key === "Enter" || r.key === " ") && (r.preventDefault(), n.toggleExpand());
      },
      children: e
    }
  );
};
gd.Expanded = function({
  children: e
}) {
  const t = M.useContext(iE);
  if (!t)
    throw new Error(
      "SmoothExpand.Expanded must be used within a SmoothExpand component"
    );
  return t.isExpanded ? /* @__PURE__ */ C.jsx(C.Fragment, { children: e }) : null;
};
gd.Collapsed = function({
  children: e
}) {
  const t = M.useContext(iE);
  if (!t)
    throw new Error(
      "SmoothExpand.Collapsed must be used within a SmoothExpand component"
    );
  return t.isExpanded ? null : /* @__PURE__ */ C.jsx(C.Fragment, { children: e });
};
const sE = M.createContext(
  void 0
), Oc = M.forwardRef((e, t) => {
  const { asChild: n = !1, children: r, className: a, style: s, ...l } = e, [c, d] = M.useState(!1), f = M.useRef(null);
  M.useImperativeHandle(t, () => f.current, []);
  const m = M.useCallback(async (w) => {
    const k = w;
    if (w.requestFullscreen)
      await w.requestFullscreen();
    else if (k.mozRequestFullScreen)
      await k.mozRequestFullScreen();
    else if (k.webkitRequestFullscreen)
      await k.webkitRequestFullscreen();
    else if (k.msRequestFullscreen)
      await k.msRequestFullscreen();
    else
      throw new Error("Fullscreen API is not supported in this browser");
  }, []), h = M.useCallback(async () => {
    const w = document;
    if (document.exitFullscreen)
      await document.exitFullscreen();
    else if (w.mozCancelFullScreen)
      await w.mozCancelFullScreen();
    else if (w.webkitExitFullscreen)
      await w.webkitExitFullscreen();
    else if (w.msExitFullscreen)
      await w.msExitFullscreen();
    else
      throw new Error("Exit fullscreen API is not supported in this browser");
  }, []), v = M.useCallback(async () => {
    try {
      const w = f.current;
      if (!w) {
        console.warn("FullScreen: No element reference available");
        return;
      }
      c ? await h() : await m(w);
    } catch (w) {
      console.error("FullScreen: Error toggling fullscreen mode", w);
    }
  }, [c, m, h]), g = M.useCallback(() => {
    const w = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
    d(w);
  }, []);
  M.useEffect(() => {
    const w = [
      "fullscreenchange",
      "webkitfullscreenchange",
      "mozfullscreenchange",
      "MSFullscreenChange"
    ];
    return w.forEach((k) => {
      document.addEventListener(k, g);
    }), () => {
      w.forEach((k) => {
        document.removeEventListener(k, g);
      });
    };
  }, [g]);
  const b = M.useMemo(
    () => ({ isFullScreen: c, toggleFullscreen: v }),
    [c, v]
  );
  let x;
  if (n && M.isValidElement(r)) {
    const w = r;
    x = M.cloneElement(w, {
      ref: f,
      className: [w.props.className, a].filter(Boolean).join(" "),
      style: { ...w.props.style, ...s },
      ...l
    });
  } else
    x = /* @__PURE__ */ C.jsx("div", { ref: f, className: a, style: s, ...l, children: r });
  return /* @__PURE__ */ C.jsx(sE.Provider, { value: b, children: x });
});
Oc.displayName = "FullScreen";
Oc.Trigger = function({
  children: e,
  className: t
}) {
  const n = M.useContext(sE);
  if (!n)
    throw new Error(
      "FullScreen.Trigger must be used within a FullScreen component"
    );
  return /* @__PURE__ */ C.jsx(
    "div",
    {
      className: t,
      style: { cursor: "pointer" },
      onClick: n.toggleFullscreen,
      role: "button",
      tabIndex: 0,
      onKeyDown: (r) => {
        (r.key === "Enter" || r.key === " ") && (r.preventDefault(), n.toggleFullscreen());
      },
      children: e
    }
  );
};
Oc.InFullScreen = function({
  children: e
}) {
  const t = M.useContext(sE);
  if (!t)
    throw new Error(
      "FullScreen.InFullScreen must be used within a FullScreen component"
    );
  return t.isFullScreen ? /* @__PURE__ */ C.jsx(C.Fragment, { children: e }) : null;
};
Oc.OutFullScreen = function({
  children: e
}) {
  const t = M.useContext(sE);
  if (!t)
    throw new Error(
      "FullScreen.OutFullScreen must be used within a FullScreen component"
    );
  return t.isFullScreen ? null : /* @__PURE__ */ C.jsx(C.Fragment, { children: e });
};
var gN = { exports: {} }, J1 = { exports: {} }, _n = {}, Q1;
function HZ() {
  if (Q1) return _n;
  Q1 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? /* @__PURE__ */ Symbol.for("react.element") : 60103, n = e ? /* @__PURE__ */ Symbol.for("react.portal") : 60106, r = e ? /* @__PURE__ */ Symbol.for("react.fragment") : 60107, a = e ? /* @__PURE__ */ Symbol.for("react.strict_mode") : 60108, s = e ? /* @__PURE__ */ Symbol.for("react.profiler") : 60114, l = e ? /* @__PURE__ */ Symbol.for("react.provider") : 60109, c = e ? /* @__PURE__ */ Symbol.for("react.context") : 60110, d = e ? /* @__PURE__ */ Symbol.for("react.async_mode") : 60111, f = e ? /* @__PURE__ */ Symbol.for("react.concurrent_mode") : 60111, m = e ? /* @__PURE__ */ Symbol.for("react.forward_ref") : 60112, h = e ? /* @__PURE__ */ Symbol.for("react.suspense") : 60113, v = e ? /* @__PURE__ */ Symbol.for("react.suspense_list") : 60120, g = e ? /* @__PURE__ */ Symbol.for("react.memo") : 60115, b = e ? /* @__PURE__ */ Symbol.for("react.lazy") : 60116, x = e ? /* @__PURE__ */ Symbol.for("react.block") : 60121, w = e ? /* @__PURE__ */ Symbol.for("react.fundamental") : 60117, k = e ? /* @__PURE__ */ Symbol.for("react.responder") : 60118, E = e ? /* @__PURE__ */ Symbol.for("react.scope") : 60119;
  function _(N) {
    if (typeof N == "object" && N !== null) {
      var A = N.$$typeof;
      switch (A) {
        case t:
          switch (N = N.type, N) {
            case d:
            case f:
            case r:
            case s:
            case a:
            case h:
              return N;
            default:
              switch (N = N && N.$$typeof, N) {
                case c:
                case m:
                case b:
                case g:
                case l:
                  return N;
                default:
                  return A;
              }
          }
        case n:
          return A;
      }
    }
  }
  function O(N) {
    return _(N) === f;
  }
  return _n.AsyncMode = d, _n.ConcurrentMode = f, _n.ContextConsumer = c, _n.ContextProvider = l, _n.Element = t, _n.ForwardRef = m, _n.Fragment = r, _n.Lazy = b, _n.Memo = g, _n.Portal = n, _n.Profiler = s, _n.StrictMode = a, _n.Suspense = h, _n.isAsyncMode = function(N) {
    return O(N) || _(N) === d;
  }, _n.isConcurrentMode = O, _n.isContextConsumer = function(N) {
    return _(N) === c;
  }, _n.isContextProvider = function(N) {
    return _(N) === l;
  }, _n.isElement = function(N) {
    return typeof N == "object" && N !== null && N.$$typeof === t;
  }, _n.isForwardRef = function(N) {
    return _(N) === m;
  }, _n.isFragment = function(N) {
    return _(N) === r;
  }, _n.isLazy = function(N) {
    return _(N) === b;
  }, _n.isMemo = function(N) {
    return _(N) === g;
  }, _n.isPortal = function(N) {
    return _(N) === n;
  }, _n.isProfiler = function(N) {
    return _(N) === s;
  }, _n.isStrictMode = function(N) {
    return _(N) === a;
  }, _n.isSuspense = function(N) {
    return _(N) === h;
  }, _n.isValidElementType = function(N) {
    return typeof N == "string" || typeof N == "function" || N === r || N === f || N === s || N === a || N === h || N === v || typeof N == "object" && N !== null && (N.$$typeof === b || N.$$typeof === g || N.$$typeof === l || N.$$typeof === c || N.$$typeof === m || N.$$typeof === w || N.$$typeof === k || N.$$typeof === E || N.$$typeof === x);
  }, _n.typeOf = _, _n;
}
var Z1;
function WZ() {
  return Z1 || (Z1 = 1, J1.exports = HZ()), J1.exports;
}
var vN, eD;
function qZ() {
  if (eD) return vN;
  eD = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return vN = e, vN;
}
var yN, tD;
function GZ() {
  if (tD) return yN;
  tD = 1;
  var e = /* @__PURE__ */ qZ();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, yN = function() {
    function r(l, c, d, f, m, h) {
      if (h !== e) {
        var v = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw v.name = "Invariant Violation", v;
      }
    }
    r.isRequired = r;
    function a() {
      return r;
    }
    var s = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: a,
      element: r,
      elementType: r,
      instanceOf: a,
      node: r,
      objectOf: a,
      oneOf: a,
      oneOfType: a,
      shape: a,
      exact: a,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return s.PropTypes = s, s;
  }, yN;
}
var nD;
function KZ() {
  return nD || (nD = 1, gN.exports = /* @__PURE__ */ GZ()()), gN.exports;
}
var Pr = /* @__PURE__ */ KZ();
const Xh = /* @__PURE__ */ Gc(Pr);
function Q8(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var a = e.length;
    for (t = 0; t < a; t++) e[t] && (n = Q8(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function Ye() {
  for (var e, t, n = 0, r = "", a = arguments.length; n < a; n++) (e = arguments[n]) && (t = Q8(e)) && (r && (r += " "), r += t);
  return r;
}
function Et(e, t, n = void 0) {
  const r = {};
  for (const a in e) {
    const s = e[a];
    let l = "", c = !0;
    for (let d = 0; d < s.length; d += 1) {
      const f = s[d];
      f && (l += (c === !0 ? "" : " ") + t(f), c = !1, n && n[f] && (l += " " + n[f]));
    }
    r[a] = l;
  }
  return r;
}
const Z8 = /* @__PURE__ */ M.createContext();
function Ic(e, ...t) {
  const n = new URL(`https://mui.com/production-error/?code=${e}`);
  return t.forEach((r) => n.searchParams.append("args[]", r)), `Minified MUI error #${e}; visit ${n} for the full message.`;
}
function qe(e) {
  if (typeof e != "string")
    throw new Error(Ic(7));
  return e.charAt(0).toUpperCase() + e.slice(1);
}
var rD = { exports: {} }, Tn = {}, oD;
function YZ() {
  if (oD) return Tn;
  oD = 1;
  var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.portal"), n = /* @__PURE__ */ Symbol.for("react.fragment"), r = /* @__PURE__ */ Symbol.for("react.strict_mode"), a = /* @__PURE__ */ Symbol.for("react.profiler"), s = /* @__PURE__ */ Symbol.for("react.consumer"), l = /* @__PURE__ */ Symbol.for("react.context"), c = /* @__PURE__ */ Symbol.for("react.forward_ref"), d = /* @__PURE__ */ Symbol.for("react.suspense"), f = /* @__PURE__ */ Symbol.for("react.suspense_list"), m = /* @__PURE__ */ Symbol.for("react.memo"), h = /* @__PURE__ */ Symbol.for("react.lazy"), v = /* @__PURE__ */ Symbol.for("react.view_transition"), g = /* @__PURE__ */ Symbol.for("react.client.reference");
  function b(x) {
    if (typeof x == "object" && x !== null) {
      var w = x.$$typeof;
      switch (w) {
        case e:
          switch (x = x.type, x) {
            case n:
            case a:
            case r:
            case d:
            case f:
            case v:
              return x;
            default:
              switch (x = x && x.$$typeof, x) {
                case l:
                case c:
                case h:
                case m:
                  return x;
                case s:
                  return x;
                default:
                  return w;
              }
          }
        case t:
          return w;
      }
    }
  }
  return Tn.ContextConsumer = s, Tn.ContextProvider = l, Tn.Element = e, Tn.ForwardRef = c, Tn.Fragment = n, Tn.Lazy = h, Tn.Memo = m, Tn.Portal = t, Tn.Profiler = a, Tn.StrictMode = r, Tn.Suspense = d, Tn.SuspenseList = f, Tn.isContextConsumer = function(x) {
    return b(x) === s;
  }, Tn.isContextProvider = function(x) {
    return b(x) === l;
  }, Tn.isElement = function(x) {
    return typeof x == "object" && x !== null && x.$$typeof === e;
  }, Tn.isForwardRef = function(x) {
    return b(x) === c;
  }, Tn.isFragment = function(x) {
    return b(x) === n;
  }, Tn.isLazy = function(x) {
    return b(x) === h;
  }, Tn.isMemo = function(x) {
    return b(x) === m;
  }, Tn.isPortal = function(x) {
    return b(x) === t;
  }, Tn.isProfiler = function(x) {
    return b(x) === a;
  }, Tn.isStrictMode = function(x) {
    return b(x) === r;
  }, Tn.isSuspense = function(x) {
    return b(x) === d;
  }, Tn.isSuspenseList = function(x) {
    return b(x) === f;
  }, Tn.isValidElementType = function(x) {
    return typeof x == "string" || typeof x == "function" || x === n || x === a || x === r || x === d || x === f || typeof x == "object" && x !== null && (x.$$typeof === h || x.$$typeof === m || x.$$typeof === l || x.$$typeof === s || x.$$typeof === c || x.$$typeof === g || x.getModuleId !== void 0);
  }, Tn.typeOf = b, Tn;
}
var aD;
function XZ() {
  return aD || (aD = 1, rD.exports = /* @__PURE__ */ YZ()), rD.exports;
}
var e7 = /* @__PURE__ */ XZ();
function El(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function t7(e) {
  if (/* @__PURE__ */ M.isValidElement(e) || e7.isValidElementType(e) || !El(e))
    return e;
  const t = {};
  return Object.keys(e).forEach((n) => {
    t[n] = t7(e[n]);
  }), t;
}
function Qo(e, t, n = {
  clone: !0
}) {
  const r = n.clone ? {
    ...e
  } : e;
  return El(e) && El(t) && Object.keys(t).forEach((a) => {
    /* @__PURE__ */ M.isValidElement(t[a]) || e7.isValidElementType(t[a]) ? r[a] = t[a] : El(t[a]) && // Avoid prototype pollution
    Object.prototype.hasOwnProperty.call(e, a) && El(e[a]) ? r[a] = Qo(e[a], t[a], n) : n.clone ? r[a] = El(t[a]) ? t7(t[a]) : t[a] : r[a] = t[a];
  }), r;
}
function Nx(e, t) {
  return t ? Qo(e, t, {
    clone: !1
    // No need to clone deep, it's way faster.
  }) : e;
}
function iD(e, t) {
  if (!e.containerQueries)
    return t;
  const n = Object.keys(t).filter((r) => r.startsWith("@container")).sort((r, a) => {
    const s = /min-width:\s*([0-9.]+)/;
    return +(r.match(s)?.[1] || 0) - +(a.match(s)?.[1] || 0);
  });
  return n.length ? n.reduce((r, a) => {
    const s = t[a];
    return delete r[a], r[a] = s, r;
  }, {
    ...t
  }) : t;
}
function JZ(e, t) {
  return t === "@" || t.startsWith("@") && (e.some((n) => t.startsWith(`@${n}`)) || !!t.match(/^@\d/));
}
function QZ(e, t) {
  const n = t.match(/^@([^/]+)?\/?(.+)?$/);
  if (!n)
    return null;
  const [, r, a] = n, s = Number.isNaN(+r) ? r || 0 : +r;
  return e.containerQueries(a).up(s);
}
function ZZ(e) {
  const t = (s, l) => s.replace("@media", l ? `@container ${l}` : "@container");
  function n(s, l) {
    s.up = (...c) => t(e.breakpoints.up(...c), l), s.down = (...c) => t(e.breakpoints.down(...c), l), s.between = (...c) => t(e.breakpoints.between(...c), l), s.only = (...c) => t(e.breakpoints.only(...c), l), s.not = (...c) => {
      const d = t(e.breakpoints.not(...c), l);
      return d.includes("not all and") ? d.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or") : d;
    };
  }
  const r = {}, a = (s) => (n(r, s), r);
  return n(a), {
    ...e,
    containerQueries: a
  };
}
const lE = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
}, sD = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (e) => `@media (min-width:${lE[e]}px)`
}, eee = {
  containerQueries: (e) => ({
    up: (t) => {
      let n = typeof t == "number" ? t : lE[t] || t;
      return typeof n == "number" && (n = `${n}px`), e ? `@container ${e} (min-width:${n})` : `@container (min-width:${n})`;
    }
  })
};
function $c(e, t, n) {
  const r = e.theme || {};
  if (Array.isArray(t)) {
    const a = r.breakpoints || sD;
    return t.reduce((s, l, c) => (s[a.up(a.keys[c])] = n(t[c]), s), {});
  }
  if (typeof t == "object") {
    const a = r.breakpoints || sD;
    return Object.keys(t).reduce((s, l) => {
      if (JZ(a.keys, l)) {
        const c = QZ(r.containerQueries ? r : eee, l);
        c && (s[c] = n(t[l], l));
      } else if (Object.keys(a.values || lE).includes(l)) {
        const c = a.up(l);
        s[c] = n(t[l], l);
      } else {
        const c = l;
        s[c] = t[c];
      }
      return s;
    }, {});
  }
  return n(t);
}
function tee(e = {}) {
  return e.keys?.reduce((t, n) => {
    const r = e.up(n);
    return t[r] = {}, t;
  }, {}) || {};
}
function lD(e, t) {
  return e.reduce((n, r) => {
    const a = n[r];
    return (!a || Object.keys(a).length === 0) && delete n[r], n;
  }, t);
}
function uE(e, t, n = !0) {
  if (!t || typeof t != "string")
    return null;
  if (e && e.vars && n) {
    const r = `vars.${t}`.split(".").reduce((a, s) => a && a[s] ? a[s] : null, e);
    if (r != null)
      return r;
  }
  return t.split(".").reduce((r, a) => r && r[a] != null ? r[a] : null, e);
}
function t2(e, t, n, r = n) {
  let a;
  return typeof e == "function" ? a = e(n) : Array.isArray(e) ? a = e[n] || r : a = uE(e, n) || r, t && (a = t(a, r, e)), a;
}
function Rr(e) {
  const {
    prop: t,
    cssProperty: n = e.prop,
    themeKey: r,
    transform: a
  } = e, s = (l) => {
    if (l[t] == null)
      return null;
    const c = l[t], d = l.theme, f = uE(d, r) || {};
    return $c(l, c, (m) => {
      let h = t2(f, a, m);
      return m === h && typeof m == "string" && (h = t2(f, a, `${t}${m === "default" ? "" : qe(m)}`, m)), n === !1 ? h : {
        [n]: h
      };
    });
  };
  return s.propTypes = {}, s.filterProps = [t], s;
}
function nee(e) {
  const t = {};
  return (n) => (t[n] === void 0 && (t[n] = e(n)), t[n]);
}
const ree = {
  m: "margin",
  p: "padding"
}, oee = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
}, uD = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
}, aee = nee((e) => {
  if (e.length > 2)
    if (uD[e])
      e = uD[e];
    else
      return [e];
  const [t, n] = e.split(""), r = ree[t], a = oee[n] || "";
  return Array.isArray(a) ? a.map((s) => r + s) : [r + a];
}), FR = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], BR = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...FR, ...BR];
function VS(e, t, n, r) {
  const a = uE(e, t, !0) ?? n;
  return typeof a == "number" || typeof a == "string" ? (s) => typeof s == "string" ? s : typeof a == "string" ? a.startsWith("var(") && s === 0 ? 0 : a.startsWith("var(") && s === 1 ? a : `calc(${s} * ${a})` : a * s : Array.isArray(a) ? (s) => {
    if (typeof s == "string")
      return s;
    const l = Math.abs(s), c = a[l];
    return s >= 0 ? c : typeof c == "number" ? -c : typeof c == "string" && c.startsWith("var(") ? `calc(-1 * ${c})` : `-${c}`;
  } : typeof a == "function" ? a : (() => {
  });
}
function UR(e) {
  return VS(e, "spacing", 8);
}
function HS(e, t) {
  return typeof t == "string" || t == null ? t : e(t);
}
function iee(e, t) {
  return (n) => e.reduce((r, a) => (r[a] = HS(t, n), r), {});
}
function see(e, t, n, r) {
  if (!t.includes(n))
    return null;
  const a = aee(n), s = iee(a, r), l = e[n];
  return $c(e, l, s);
}
function n7(e, t) {
  const n = UR(e.theme);
  return Object.keys(e).map((r) => see(e, t, r, n)).reduce(Nx, {});
}
function xr(e) {
  return n7(e, FR);
}
xr.propTypes = {};
xr.filterProps = FR;
function Sr(e) {
  return n7(e, BR);
}
Sr.propTypes = {};
Sr.filterProps = BR;
function cE(...e) {
  const t = e.reduce((r, a) => (a.filterProps.forEach((s) => {
    r[s] = a;
  }), r), {}), n = (r) => Object.keys(r).reduce((a, s) => t[s] ? Nx(a, t[s](r)) : a, {});
  return n.propTypes = {}, n.filterProps = e.reduce((r, a) => r.concat(a.filterProps), []), n;
}
function Li(e) {
  return typeof e != "number" ? e : `${e}px solid`;
}
function Xi(e, t) {
  return Rr({
    prop: e,
    themeKey: "borders",
    transform: t
  });
}
const lee = Xi("border", Li), uee = Xi("borderTop", Li), cee = Xi("borderRight", Li), dee = Xi("borderBottom", Li), fee = Xi("borderLeft", Li), pee = Xi("borderColor"), mee = Xi("borderTopColor"), hee = Xi("borderRightColor"), gee = Xi("borderBottomColor"), vee = Xi("borderLeftColor"), yee = Xi("outline", Li), bee = Xi("outlineColor"), dE = (e) => {
  if (e.borderRadius !== void 0 && e.borderRadius !== null) {
    const t = VS(e.theme, "shape.borderRadius", 4), n = (r) => ({
      borderRadius: HS(t, r)
    });
    return $c(e, e.borderRadius, n);
  }
  return null;
};
dE.propTypes = {};
dE.filterProps = ["borderRadius"];
cE(lee, uee, cee, dee, fee, pee, mee, hee, gee, vee, dE, yee, bee);
const fE = (e) => {
  if (e.gap !== void 0 && e.gap !== null) {
    const t = VS(e.theme, "spacing", 8), n = (r) => ({
      gap: HS(t, r)
    });
    return $c(e, e.gap, n);
  }
  return null;
};
fE.propTypes = {};
fE.filterProps = ["gap"];
const pE = (e) => {
  if (e.columnGap !== void 0 && e.columnGap !== null) {
    const t = VS(e.theme, "spacing", 8), n = (r) => ({
      columnGap: HS(t, r)
    });
    return $c(e, e.columnGap, n);
  }
  return null;
};
pE.propTypes = {};
pE.filterProps = ["columnGap"];
const mE = (e) => {
  if (e.rowGap !== void 0 && e.rowGap !== null) {
    const t = VS(e.theme, "spacing", 8), n = (r) => ({
      rowGap: HS(t, r)
    });
    return $c(e, e.rowGap, n);
  }
  return null;
};
mE.propTypes = {};
mE.filterProps = ["rowGap"];
const wee = Rr({
  prop: "gridColumn"
}), xee = Rr({
  prop: "gridRow"
}), See = Rr({
  prop: "gridAutoFlow"
}), kee = Rr({
  prop: "gridAutoColumns"
}), _ee = Rr({
  prop: "gridAutoRows"
}), Eee = Rr({
  prop: "gridTemplateColumns"
}), Cee = Rr({
  prop: "gridTemplateRows"
}), Oee = Rr({
  prop: "gridTemplateAreas"
}), Mee = Rr({
  prop: "gridArea"
});
cE(fE, pE, mE, wee, xee, See, kee, _ee, Eee, Cee, Oee, Mee);
function Jh(e, t) {
  return t === "grey" ? t : e;
}
const Nee = Rr({
  prop: "color",
  themeKey: "palette",
  transform: Jh
}), Aee = Rr({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: Jh
}), Ree = Rr({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: Jh
});
cE(Nee, Aee, Ree);
function ki(e) {
  return e <= 1 && e !== 0 ? `${e * 100}%` : e;
}
const jee = Rr({
  prop: "width",
  transform: ki
}), VR = (e) => {
  if (e.maxWidth !== void 0 && e.maxWidth !== null) {
    const t = (n) => {
      const r = e.theme?.breakpoints?.values?.[n] || lE[n];
      return r ? e.theme?.breakpoints?.unit !== "px" ? {
        maxWidth: `${r}${e.theme.breakpoints.unit}`
      } : {
        maxWidth: r
      } : {
        maxWidth: ki(n)
      };
    };
    return $c(e, e.maxWidth, t);
  }
  return null;
};
VR.filterProps = ["maxWidth"];
const Pee = Rr({
  prop: "minWidth",
  transform: ki
}), Dee = Rr({
  prop: "height",
  transform: ki
}), Iee = Rr({
  prop: "maxHeight",
  transform: ki
}), $ee = Rr({
  prop: "minHeight",
  transform: ki
});
Rr({
  prop: "size",
  cssProperty: "width",
  transform: ki
});
Rr({
  prop: "size",
  cssProperty: "height",
  transform: ki
});
const zee = Rr({
  prop: "boxSizing"
});
cE(jee, VR, Pee, Dee, Iee, $ee, zee);
const WS = {
  // borders
  border: {
    themeKey: "borders",
    transform: Li
  },
  borderTop: {
    themeKey: "borders",
    transform: Li
  },
  borderRight: {
    themeKey: "borders",
    transform: Li
  },
  borderBottom: {
    themeKey: "borders",
    transform: Li
  },
  borderLeft: {
    themeKey: "borders",
    transform: Li
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: Li
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: dE
  },
  // palette
  color: {
    themeKey: "palette",
    transform: Jh
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: Jh
  },
  backgroundColor: {
    themeKey: "palette",
    transform: Jh
  },
  // spacing
  p: {
    style: Sr
  },
  pt: {
    style: Sr
  },
  pr: {
    style: Sr
  },
  pb: {
    style: Sr
  },
  pl: {
    style: Sr
  },
  px: {
    style: Sr
  },
  py: {
    style: Sr
  },
  padding: {
    style: Sr
  },
  paddingTop: {
    style: Sr
  },
  paddingRight: {
    style: Sr
  },
  paddingBottom: {
    style: Sr
  },
  paddingLeft: {
    style: Sr
  },
  paddingX: {
    style: Sr
  },
  paddingY: {
    style: Sr
  },
  paddingInline: {
    style: Sr
  },
  paddingInlineStart: {
    style: Sr
  },
  paddingInlineEnd: {
    style: Sr
  },
  paddingBlock: {
    style: Sr
  },
  paddingBlockStart: {
    style: Sr
  },
  paddingBlockEnd: {
    style: Sr
  },
  m: {
    style: xr
  },
  mt: {
    style: xr
  },
  mr: {
    style: xr
  },
  mb: {
    style: xr
  },
  ml: {
    style: xr
  },
  mx: {
    style: xr
  },
  my: {
    style: xr
  },
  margin: {
    style: xr
  },
  marginTop: {
    style: xr
  },
  marginRight: {
    style: xr
  },
  marginBottom: {
    style: xr
  },
  marginLeft: {
    style: xr
  },
  marginX: {
    style: xr
  },
  marginY: {
    style: xr
  },
  marginInline: {
    style: xr
  },
  marginInlineStart: {
    style: xr
  },
  marginInlineEnd: {
    style: xr
  },
  marginBlock: {
    style: xr
  },
  marginBlockStart: {
    style: xr
  },
  marginBlockEnd: {
    style: xr
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: (e) => ({
      "@media print": {
        display: e
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: fE
  },
  rowGap: {
    style: mE
  },
  columnGap: {
    style: pE
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: ki
  },
  maxWidth: {
    style: VR
  },
  minWidth: {
    transform: ki
  },
  height: {
    transform: ki
  },
  maxHeight: {
    transform: ki
  },
  minHeight: {
    transform: ki
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: "typography"
  }
};
function Tee(...e) {
  const t = e.reduce((r, a) => r.concat(Object.keys(a)), []), n = new Set(t);
  return e.every((r) => n.size === Object.keys(r).length);
}
function Lee(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Fee() {
  function e(n, r, a, s) {
    const l = {
      [n]: r,
      theme: a
    }, c = s[n];
    if (!c)
      return {
        [n]: r
      };
    const {
      cssProperty: d = n,
      themeKey: f,
      transform: m,
      style: h
    } = c;
    if (r == null)
      return null;
    if (f === "typography" && r === "inherit")
      return {
        [n]: r
      };
    const v = uE(a, f) || {};
    return h ? h(l) : $c(l, r, (g) => {
      let b = t2(v, m, g);
      return g === b && typeof g == "string" && (b = t2(v, m, `${n}${g === "default" ? "" : qe(g)}`, g)), d === !1 ? b : {
        [d]: b
      };
    });
  }
  function t(n) {
    const {
      sx: r,
      theme: a = {},
      nested: s
    } = n || {};
    if (!r)
      return null;
    const l = a.unstable_sxConfig ?? WS;
    function c(d) {
      let f = d;
      if (typeof d == "function")
        f = d(a);
      else if (typeof d != "object")
        return d;
      if (!f)
        return null;
      const m = tee(a.breakpoints), h = Object.keys(m);
      let v = m;
      return Object.keys(f).forEach((g) => {
        const b = Lee(f[g], a);
        if (b != null)
          if (typeof b == "object")
            if (l[g])
              v = Nx(v, e(g, b, a, l));
            else {
              const x = $c({
                theme: a
              }, b, (w) => ({
                [g]: w
              }));
              Tee(x, b) ? v[g] = t({
                sx: b,
                theme: a,
                nested: !0
              }) : v = Nx(v, x);
            }
          else
            v = Nx(v, e(g, b, a, l));
      }), !s && a.modularCssLayers ? {
        "@layer sx": iD(a, lD(h, v))
      } : iD(a, lD(h, v));
    }
    return Array.isArray(r) ? r.map(c) : c(r);
  }
  return t;
}
const Cd = Fee();
Cd.filterProps = ["sx"];
const Bee = (e) => {
  const t = {
    systemProps: {},
    otherProps: {}
  }, n = e?.theme?.unstable_sxConfig ?? WS;
  return Object.keys(e).forEach((r) => {
    n[r] ? t.systemProps[r] = e[r] : t.otherProps[r] = e[r];
  }), t;
};
function HR(e) {
  const {
    sx: t,
    ...n
  } = e, {
    systemProps: r,
    otherProps: a
  } = Bee(n);
  let s;
  return Array.isArray(t) ? s = [r, ...t] : typeof t == "function" ? s = (...l) => {
    const c = t(...l);
    return El(c) ? {
      ...r,
      ...c
    } : r;
  } : s = {
    ...r,
    ...t
  }, {
    ...a,
    sx: s
  };
}
function mt() {
  return mt = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, mt.apply(null, arguments);
}
function Uee(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function Vee(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var Hee = /* @__PURE__ */ (function() {
  function e(n) {
    var r = this;
    this._insertTag = function(a) {
      var s;
      r.tags.length === 0 ? r.insertionPoint ? s = r.insertionPoint.nextSibling : r.prepend ? s = r.container.firstChild : s = r.before : s = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(a, s), r.tags.push(a);
    }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(n) {
    n.forEach(this._insertTag);
  }, t.insert = function(n) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(Vee(this));
    var r = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var a = Uee(r);
      try {
        a.insertRule(n, a.cssRules.length);
      } catch {
      }
    } else
      r.appendChild(document.createTextNode(n));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(n) {
      var r;
      return (r = n.parentNode) == null ? void 0 : r.removeChild(n);
    }), this.tags = [], this.ctr = 0;
  }, e;
})(), Go = "-ms-", n2 = "-moz-", wn = "-webkit-", r7 = "comm", WR = "rule", qR = "decl", Wee = "@import", o7 = "@keyframes", qee = "@layer", Gee = Math.abs, hE = String.fromCharCode, Kee = Object.assign;
function Yee(e, t) {
  return $o(e, 0) ^ 45 ? (((t << 2 ^ $o(e, 0)) << 2 ^ $o(e, 1)) << 2 ^ $o(e, 2)) << 2 ^ $o(e, 3) : 0;
}
function a7(e) {
  return e.trim();
}
function Xee(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function xn(e, t, n) {
  return e.replace(t, n);
}
function AA(e, t) {
  return e.indexOf(t);
}
function $o(e, t) {
  return e.charCodeAt(t) | 0;
}
function Zx(e, t, n) {
  return e.slice(t, n);
}
function xl(e) {
  return e.length;
}
function GR(e) {
  return e.length;
}
function Bk(e, t) {
  return t.push(e), e;
}
function Jee(e, t) {
  return e.map(t).join("");
}
var gE = 1, fg = 1, i7 = 0, Ia = 0, Ir = 0, Ig = "";
function vE(e, t, n, r, a, s, l) {
  return { value: e, root: t, parent: n, type: r, props: a, children: s, line: gE, column: fg, length: l, return: "" };
}
function qw(e, t) {
  return Kee(vE("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function Qee() {
  return Ir;
}
function Zee() {
  return Ir = Ia > 0 ? $o(Ig, --Ia) : 0, fg--, Ir === 10 && (fg = 1, gE--), Ir;
}
function Ei() {
  return Ir = Ia < i7 ? $o(Ig, Ia++) : 0, fg++, Ir === 10 && (fg = 1, gE++), Ir;
}
function $l() {
  return $o(Ig, Ia);
}
function k_() {
  return Ia;
}
function qS(e, t) {
  return Zx(Ig, e, t);
}
function eS(e) {
  switch (e) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function s7(e) {
  return gE = fg = 1, i7 = xl(Ig = e), Ia = 0, [];
}
function l7(e) {
  return Ig = "", e;
}
function __(e) {
  return a7(qS(Ia - 1, RA(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function ete(e) {
  for (; (Ir = $l()) && Ir < 33; )
    Ei();
  return eS(e) > 2 || eS(Ir) > 3 ? "" : " ";
}
function tte(e, t) {
  for (; --t && Ei() && !(Ir < 48 || Ir > 102 || Ir > 57 && Ir < 65 || Ir > 70 && Ir < 97); )
    ;
  return qS(e, k_() + (t < 6 && $l() == 32 && Ei() == 32));
}
function RA(e) {
  for (; Ei(); )
    switch (Ir) {
      // ] ) " '
      case e:
        return Ia;
      // " '
      case 34:
      case 39:
        e !== 34 && e !== 39 && RA(Ir);
        break;
      // (
      case 40:
        e === 41 && RA(e);
        break;
      // \
      case 92:
        Ei();
        break;
    }
  return Ia;
}
function nte(e, t) {
  for (; Ei() && e + Ir !== 57 && !(e + Ir === 84 && $l() === 47); )
    ;
  return "/*" + qS(t, Ia - 1) + "*" + hE(e === 47 ? e : Ei());
}
function rte(e) {
  for (; !eS($l()); )
    Ei();
  return qS(e, Ia);
}
function ote(e) {
  return l7(E_("", null, null, null, [""], e = s7(e), 0, [0], e));
}
function E_(e, t, n, r, a, s, l, c, d) {
  for (var f = 0, m = 0, h = l, v = 0, g = 0, b = 0, x = 1, w = 1, k = 1, E = 0, _ = "", O = a, N = s, A = r, R = _; w; )
    switch (b = E, E = Ei()) {
      // (
      case 40:
        if (b != 108 && $o(R, h - 1) == 58) {
          AA(R += xn(__(E), "&", "&\f"), "&\f") != -1 && (k = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        R += __(E);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        R += ete(b);
        break;
      // \
      case 92:
        R += tte(k_() - 1, 7);
        continue;
      // /
      case 47:
        switch ($l()) {
          case 42:
          case 47:
            Bk(ate(nte(Ei(), k_()), t, n), d);
            break;
          default:
            R += "/";
        }
        break;
      // {
      case 123 * x:
        c[f++] = xl(R) * k;
      // } ; \0
      case 125 * x:
      case 59:
      case 0:
        switch (E) {
          // \0 }
          case 0:
          case 125:
            w = 0;
          // ;
          case 59 + m:
            k == -1 && (R = xn(R, /\f/g, "")), g > 0 && xl(R) - h && Bk(g > 32 ? dD(R + ";", r, n, h - 1) : dD(xn(R, " ", "") + ";", r, n, h - 2), d);
            break;
          // @ ;
          case 59:
            R += ";";
          // { rule/at-rule
          default:
            if (Bk(A = cD(R, t, n, f, m, a, c, _, O = [], N = [], h), s), E === 123)
              if (m === 0)
                E_(R, t, A, A, O, s, h, c, N);
              else
                switch (v === 99 && $o(R, 3) === 110 ? 100 : v) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    E_(e, A, A, r && Bk(cD(e, A, A, 0, 0, a, c, _, a, O = [], h), N), a, N, h, c, r ? O : N);
                    break;
                  default:
                    E_(R, A, A, A, [""], N, 0, c, N);
                }
        }
        f = m = g = 0, x = k = 1, _ = R = "", h = l;
        break;
      // :
      case 58:
        h = 1 + xl(R), g = b;
      default:
        if (x < 1) {
          if (E == 123)
            --x;
          else if (E == 125 && x++ == 0 && Zee() == 125)
            continue;
        }
        switch (R += hE(E), E * x) {
          // &
          case 38:
            k = m > 0 ? 1 : (R += "\f", -1);
            break;
          // ,
          case 44:
            c[f++] = (xl(R) - 1) * k, k = 1;
            break;
          // @
          case 64:
            $l() === 45 && (R += __(Ei())), v = $l(), m = h = xl(_ = R += rte(k_())), E++;
            break;
          // -
          case 45:
            b === 45 && xl(R) == 2 && (x = 0);
        }
    }
  return s;
}
function cD(e, t, n, r, a, s, l, c, d, f, m) {
  for (var h = a - 1, v = a === 0 ? s : [""], g = GR(v), b = 0, x = 0, w = 0; b < r; ++b)
    for (var k = 0, E = Zx(e, h + 1, h = Gee(x = l[b])), _ = e; k < g; ++k)
      (_ = a7(x > 0 ? v[k] + " " + E : xn(E, /&\f/g, v[k]))) && (d[w++] = _);
  return vE(e, t, n, a === 0 ? WR : c, d, f, m);
}
function ate(e, t, n) {
  return vE(e, t, n, r7, hE(Qee()), Zx(e, 2, -2), 0);
}
function dD(e, t, n, r) {
  return vE(e, t, n, qR, Zx(e, 0, r), Zx(e, r + 1, -1), r);
}
function Qh(e, t) {
  for (var n = "", r = GR(e), a = 0; a < r; a++)
    n += t(e[a], a, e, t) || "";
  return n;
}
function ite(e, t, n, r) {
  switch (e.type) {
    case qee:
      if (e.children.length) break;
    case Wee:
    case qR:
      return e.return = e.return || e.value;
    case r7:
      return "";
    case o7:
      return e.return = e.value + "{" + Qh(e.children, r) + "}";
    case WR:
      e.value = e.props.join(",");
  }
  return xl(n = Qh(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function ste(e) {
  var t = GR(e);
  return function(n, r, a, s) {
    for (var l = "", c = 0; c < t; c++)
      l += e[c](n, r, a, s) || "";
    return l;
  };
}
function lte(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function u7(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var ute = function(e, t, n) {
  for (var r = 0, a = 0; r = a, a = $l(), r === 38 && a === 12 && (t[n] = 1), !eS(a); )
    Ei();
  return qS(e, Ia);
}, cte = function(e, t) {
  var n = -1, r = 44;
  do
    switch (eS(r)) {
      case 0:
        r === 38 && $l() === 12 && (t[n] = 1), e[n] += ute(Ia - 1, t, n);
        break;
      case 2:
        e[n] += __(r);
        break;
      case 4:
        if (r === 44) {
          e[++n] = $l() === 58 ? "&\f" : "", t[n] = e[n].length;
          break;
        }
      // fallthrough
      default:
        e[n] += hE(r);
    }
  while (r = Ei());
  return e;
}, dte = function(e, t) {
  return l7(cte(s7(e), t));
}, fD = /* @__PURE__ */ new WeakMap(), fte = function(e) {
  if (!(e.type !== "rule" || !e.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  e.length < 1)) {
    for (var t = e.value, n = e.parent, r = e.column === n.column && e.line === n.line; n.type !== "rule"; )
      if (n = n.parent, !n) return;
    if (!(e.props.length === 1 && t.charCodeAt(0) !== 58 && !fD.get(n)) && !r) {
      fD.set(e, !0);
      for (var a = [], s = dte(t, a), l = n.props, c = 0, d = 0; c < s.length; c++)
        for (var f = 0; f < l.length; f++, d++)
          e.props[d] = a[c] ? s[c].replace(/&\f/g, l[f]) : l[f] + " " + s[c];
    }
  }
}, pte = function(e) {
  if (e.type === "decl") {
    var t = e.value;
    t.charCodeAt(0) === 108 && // charcode for b
    t.charCodeAt(2) === 98 && (e.return = "", e.value = "");
  }
};
function c7(e, t) {
  switch (Yee(e, t)) {
    // color-adjust
    case 5103:
      return wn + "print-" + e + e;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return wn + e + e;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return wn + e + n2 + e + Go + e + e;
    // flex, flex-direction
    case 6828:
    case 4268:
      return wn + e + Go + e + e;
    // order
    case 6165:
      return wn + e + Go + "flex-" + e + e;
    // align-items
    case 5187:
      return wn + e + xn(e, /(\w+).+(:[^]+)/, wn + "box-$1$2" + Go + "flex-$1$2") + e;
    // align-self
    case 5443:
      return wn + e + Go + "flex-item-" + xn(e, /flex-|-self/, "") + e;
    // align-content
    case 4675:
      return wn + e + Go + "flex-line-pack" + xn(e, /align-content|flex-|-self/, "") + e;
    // flex-shrink
    case 5548:
      return wn + e + Go + xn(e, "shrink", "negative") + e;
    // flex-basis
    case 5292:
      return wn + e + Go + xn(e, "basis", "preferred-size") + e;
    // flex-grow
    case 6060:
      return wn + "box-" + xn(e, "-grow", "") + wn + e + Go + xn(e, "grow", "positive") + e;
    // transition
    case 4554:
      return wn + xn(e, /([^-])(transform)/g, "$1" + wn + "$2") + e;
    // cursor
    case 6187:
      return xn(xn(xn(e, /(zoom-|grab)/, wn + "$1"), /(image-set)/, wn + "$1"), e, "") + e;
    // background, background-image
    case 5495:
    case 3959:
      return xn(e, /(image-set\([^]*)/, wn + "$1$`$1");
    // justify-content
    case 4968:
      return xn(xn(e, /(.+:)(flex-)?(.*)/, wn + "box-pack:$3" + Go + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + wn + e + e;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return xn(e, /(.+)-inline(.+)/, wn + "$1$2") + e;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (xl(e) - 1 - t > 6) switch ($o(e, t + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if ($o(e, t + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return xn(e, /(.+:)(.+)-([^]+)/, "$1" + wn + "$2-$3$1" + n2 + ($o(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        // (s)tretch
        case 115:
          return ~AA(e, "stretch") ? c7(xn(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    // position: sticky
    case 4949:
      if ($o(e, t + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch ($o(e, xl(e) - 3 - (~AA(e, "!important") && 10))) {
        // stic(k)y
        case 107:
          return xn(e, ":", ":" + wn) + e;
        // (inline-)?fl(e)x
        case 101:
          return xn(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + wn + ($o(e, 14) === 45 ? "inline-" : "") + "box$3$1" + wn + "$2$3$1" + Go + "$2box$3") + e;
      }
      break;
    // writing-mode
    case 5936:
      switch ($o(e, t + 11)) {
        // vertical-l(r)
        case 114:
          return wn + e + Go + xn(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        // vertical-r(l)
        case 108:
          return wn + e + Go + xn(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        // horizontal(-)tb
        case 45:
          return wn + e + Go + xn(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return wn + e + Go + e + e;
  }
  return e;
}
var mte = function(e, t, n, r) {
  if (e.length > -1 && !e.return) switch (e.type) {
    case qR:
      e.return = c7(e.value, e.length);
      break;
    case o7:
      return Qh([qw(e, {
        value: xn(e.value, "@", "@" + wn)
      })], r);
    case WR:
      if (e.length) return Jee(e.props, function(a) {
        switch (Xee(a, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ":read-only":
          case ":read-write":
            return Qh([qw(e, {
              props: [xn(a, /:(read-\w+)/, ":" + n2 + "$1")]
            })], r);
          // :placeholder
          case "::placeholder":
            return Qh([qw(e, {
              props: [xn(a, /:(plac\w+)/, ":" + wn + "input-$1")]
            }), qw(e, {
              props: [xn(a, /:(plac\w+)/, ":" + n2 + "$1")]
            }), qw(e, {
              props: [xn(a, /:(plac\w+)/, Go + "input-$1")]
            })], r);
        }
        return "";
      });
  }
}, hte = [mte], gte = function(e) {
  var t = e.key;
  if (t === "css") {
    var n = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(n, function(b) {
      var x = b.getAttribute("data-emotion");
      x.indexOf(" ") !== -1 && (document.head.appendChild(b), b.setAttribute("data-s", ""));
    });
  }
  var r = e.stylisPlugins || hte, a = {}, s, l = [];
  s = e.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + t + ' "]'),
    function(b) {
      for (var x = b.getAttribute("data-emotion").split(" "), w = 1; w < x.length; w++)
        a[x[w]] = !0;
      l.push(b);
    }
  );
  var c, d = [fte, pte];
  {
    var f, m = [ite, lte(function(b) {
      f.insert(b);
    })], h = ste(d.concat(r, m)), v = function(b) {
      return Qh(ote(b), h);
    };
    c = function(b, x, w, k) {
      f = w, v(b ? b + "{" + x.styles + "}" : x.styles), k && (g.inserted[x.name] = !0);
    };
  }
  var g = {
    key: t,
    sheet: new Hee({
      key: t,
      container: s,
      nonce: e.nonce,
      speedy: e.speedy,
      prepend: e.prepend,
      insertionPoint: e.insertionPoint
    }),
    nonce: e.nonce,
    inserted: a,
    registered: {},
    insert: c
  };
  return g.sheet.hydrate(l), g;
}, bN, pD;
function vte() {
  if (pD) return bN;
  pD = 1;
  var e = WZ(), t = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, n = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, r = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, a = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, s = {};
  s[e.ForwardRef] = r, s[e.Memo] = a;
  function l(b) {
    return e.isMemo(b) ? a : s[b.$$typeof] || t;
  }
  var c = Object.defineProperty, d = Object.getOwnPropertyNames, f = Object.getOwnPropertySymbols, m = Object.getOwnPropertyDescriptor, h = Object.getPrototypeOf, v = Object.prototype;
  function g(b, x, w) {
    if (typeof x != "string") {
      if (v) {
        var k = h(x);
        k && k !== v && g(b, k, w);
      }
      var E = d(x);
      f && (E = E.concat(f(x)));
      for (var _ = l(b), O = l(x), N = 0; N < E.length; ++N) {
        var A = E[N];
        if (!n[A] && !(w && w[A]) && !(O && O[A]) && !(_ && _[A])) {
          var R = m(x, A);
          try {
            c(b, A, R);
          } catch {
          }
        }
      }
    }
    return b;
  }
  return bN = g, bN;
}
vte();
var yte = !0;
function d7(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function(a) {
    e[a] !== void 0 ? t.push(e[a] + ";") : a && (r += a + " ");
  }), r;
}
var KR = function(e, t, n) {
  var r = e.key + "-" + t.name;
  (n === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  yte === !1) && e.registered[r] === void 0 && (e.registered[r] = t.styles);
}, YR = function(e, t, n) {
  KR(e, t, n);
  var r = e.key + "-" + t.name;
  if (e.inserted[t.name] === void 0) {
    var a = t;
    do
      e.insert(t === a ? "." + r : "", a, e.sheet, !0), a = a.next;
    while (a !== void 0);
  }
};
function bte(e) {
  for (var t = 0, n, r = 0, a = e.length; a >= 4; ++r, a -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (a) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var wte = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, xte = /[A-Z]|^ms/g, Ste = /_EMO_([^_]+?)_([^]*?)_EMO_/g, f7 = function(e) {
  return e.charCodeAt(1) === 45;
}, mD = function(e) {
  return e != null && typeof e != "boolean";
}, wN = /* @__PURE__ */ u7(function(e) {
  return f7(e) ? e : e.replace(xte, "-$&").toLowerCase();
}), hD = function(e, t) {
  switch (e) {
    case "animation":
    case "animationName":
      if (typeof t == "string")
        return t.replace(Ste, function(n, r, a) {
          return Sl = {
            name: r,
            styles: a,
            next: Sl
          }, r;
        });
  }
  return wte[e] !== 1 && !f7(e) && typeof t == "number" && t !== 0 ? t + "px" : t;
};
function tS(e, t, n) {
  if (n == null)
    return "";
  var r = n;
  if (r.__emotion_styles !== void 0)
    return r;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var a = n;
      if (a.anim === 1)
        return Sl = {
          name: a.name,
          styles: a.styles,
          next: Sl
        }, a.name;
      var s = n;
      if (s.styles !== void 0) {
        var l = s.next;
        if (l !== void 0)
          for (; l !== void 0; )
            Sl = {
              name: l.name,
              styles: l.styles,
              next: Sl
            }, l = l.next;
        var c = s.styles + ";";
        return c;
      }
      return kte(e, t, n);
    }
    case "function": {
      if (e !== void 0) {
        var d = Sl, f = n(e);
        return Sl = d, tS(e, t, f);
      }
      break;
    }
  }
  var m = n;
  if (t == null)
    return m;
  var h = t[m];
  return h !== void 0 ? h : m;
}
function kte(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var a = 0; a < n.length; a++)
      r += tS(e, t, n[a]) + ";";
  else
    for (var s in n) {
      var l = n[s];
      if (typeof l != "object") {
        var c = l;
        t != null && t[c] !== void 0 ? r += s + "{" + t[c] + "}" : mD(c) && (r += wN(s) + ":" + hD(s, c) + ";");
      } else if (Array.isArray(l) && typeof l[0] == "string" && (t == null || t[l[0]] === void 0))
        for (var d = 0; d < l.length; d++)
          mD(l[d]) && (r += wN(s) + ":" + hD(s, l[d]) + ";");
      else {
        var f = tS(e, t, l);
        switch (s) {
          case "animation":
          case "animationName": {
            r += wN(s) + ":" + f + ";";
            break;
          }
          default:
            r += s + "{" + f + "}";
        }
      }
    }
  return r;
}
var gD = /label:\s*([^\s;{]+)\s*(;|$)/g, Sl;
function GS(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var r = !0, a = "";
  Sl = void 0;
  var s = e[0];
  if (s == null || s.raw === void 0)
    r = !1, a += tS(n, t, s);
  else {
    var l = s;
    a += l[0];
  }
  for (var c = 1; c < e.length; c++)
    if (a += tS(n, t, e[c]), r) {
      var d = s;
      a += d[c];
    }
  gD.lastIndex = 0;
  for (var f = "", m; (m = gD.exec(a)) !== null; )
    f += "-" + m[1];
  var h = bte(a) + f;
  return {
    name: h,
    styles: a,
    next: Sl
  };
}
var _te = function(e) {
  return e();
}, p7 = M.useInsertionEffect ? M.useInsertionEffect : !1, m7 = p7 || _te, vD = p7 || M.useLayoutEffect, h7 = /* @__PURE__ */ M.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ gte({
    key: "css"
  }) : null
);
h7.Provider;
var XR = function(e) {
  return /* @__PURE__ */ M.forwardRef(function(t, n) {
    var r = M.useContext(h7);
    return e(t, r, n);
  });
}, KS = /* @__PURE__ */ M.createContext({}), JR = {}.hasOwnProperty, jA = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", Ete = function(e, t) {
  var n = {};
  for (var r in t)
    JR.call(t, r) && (n[r] = t[r]);
  return n[jA] = e, n;
}, Cte = function(e) {
  var t = e.cache, n = e.serialized, r = e.isStringTag;
  return KR(t, n, r), m7(function() {
    return YR(t, n, r);
  }), null;
}, Ote = /* @__PURE__ */ XR(function(e, t, n) {
  var r = e.css;
  typeof r == "string" && t.registered[r] !== void 0 && (r = t.registered[r]);
  var a = e[jA], s = [r], l = "";
  typeof e.className == "string" ? l = d7(t.registered, s, e.className) : e.className != null && (l = e.className + " ");
  var c = GS(s, void 0, M.useContext(KS));
  l += t.key + "-" + c.name;
  var d = {};
  for (var f in e)
    JR.call(e, f) && f !== "css" && f !== jA && (d[f] = e[f]);
  return d.className = l, n && (d.ref = n), /* @__PURE__ */ M.createElement(M.Fragment, null, /* @__PURE__ */ M.createElement(Cte, {
    cache: t,
    serialized: c,
    isStringTag: typeof a == "string"
  }), /* @__PURE__ */ M.createElement(a, d));
}), Mte = Ote, ct = function(e, t) {
  var n = arguments;
  if (t == null || !JR.call(t, "css"))
    return M.createElement.apply(void 0, n);
  var r = n.length, a = new Array(r);
  a[0] = Mte, a[1] = Ete(e, t);
  for (var s = 2; s < r; s++)
    a[s] = n[s];
  return M.createElement.apply(null, a);
};
(function(e) {
  var t;
  t || (t = e.JSX || (e.JSX = {}));
})(ct || (ct = {}));
var Nte = /* @__PURE__ */ XR(function(e, t) {
  var n = e.styles, r = GS([n], void 0, M.useContext(KS)), a = M.useRef();
  return vD(function() {
    var s = t.key + "-global", l = new t.sheet.constructor({
      key: s,
      nonce: t.sheet.nonce,
      container: t.sheet.container,
      speedy: t.sheet.isSpeedy
    }), c = !1, d = document.querySelector('style[data-emotion="' + s + " " + r.name + '"]');
    return t.sheet.tags.length && (l.before = t.sheet.tags[0]), d !== null && (c = !0, d.setAttribute("data-emotion", s), l.hydrate([d])), a.current = [l, c], function() {
      l.flush();
    };
  }, [t]), vD(function() {
    var s = a.current, l = s[0], c = s[1];
    if (c) {
      s[1] = !1;
      return;
    }
    if (r.next !== void 0 && YR(t, r.next, !0), l.tags.length) {
      var d = l.tags[l.tags.length - 1].nextElementSibling;
      l.before = d, l.flush();
    }
    t.insert("", r, l, !1);
  }, [t, r.name]), null;
});
function YS() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return GS(t);
}
function $g() {
  var e = YS.apply(void 0, arguments), t = "animation-" + e.name;
  return {
    name: t,
    styles: "@keyframes " + t + "{" + e.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var Ate = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, Rte = /* @__PURE__ */ u7(
  function(e) {
    return Ate.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
), jte = Rte, Pte = function(e) {
  return e !== "theme";
}, yD = function(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96 ? jte : Pte;
}, bD = function(e, t, n) {
  var r;
  if (t) {
    var a = t.shouldForwardProp;
    r = e.__emotion_forwardProp && a ? function(s) {
      return e.__emotion_forwardProp(s) && a(s);
    } : a;
  }
  return typeof r != "function" && n && (r = e.__emotion_forwardProp), r;
}, Dte = function(e) {
  var t = e.cache, n = e.serialized, r = e.isStringTag;
  return KR(t, n, r), m7(function() {
    return YR(t, n, r);
  }), null;
}, Ite = function e(t, n) {
  var r = t.__emotion_real === t, a = r && t.__emotion_base || t, s, l;
  n !== void 0 && (s = n.label, l = n.target);
  var c = bD(t, n, r), d = c || yD(a), f = !d("as");
  return function() {
    var m = arguments, h = r && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
    if (s !== void 0 && h.push("label:" + s + ";"), m[0] == null || m[0].raw === void 0)
      h.push.apply(h, m);
    else {
      var v = m[0];
      h.push(v[0]);
      for (var g = m.length, b = 1; b < g; b++)
        h.push(m[b], v[b]);
    }
    var x = XR(function(w, k, E) {
      var _ = f && w.as || a, O = "", N = [], A = w;
      if (w.theme == null) {
        A = {};
        for (var R in w)
          A[R] = w[R];
        A.theme = M.useContext(KS);
      }
      typeof w.className == "string" ? O = d7(k.registered, N, w.className) : w.className != null && (O = w.className + " ");
      var D = GS(h.concat(N), k.registered, A);
      O += k.key + "-" + D.name, l !== void 0 && (O += " " + l);
      var I = f && c === void 0 ? yD(_) : d, z = {};
      for (var B in w)
        f && B === "as" || I(B) && (z[B] = w[B]);
      return z.className = O, E && (z.ref = E), /* @__PURE__ */ M.createElement(M.Fragment, null, /* @__PURE__ */ M.createElement(Dte, {
        cache: k,
        serialized: D,
        isStringTag: typeof _ == "string"
      }), /* @__PURE__ */ M.createElement(_, z));
    });
    return x.displayName = s !== void 0 ? s : "Styled(" + (typeof a == "string" ? a : a.displayName || a.name || "Component") + ")", x.defaultProps = t.defaultProps, x.__emotion_real = x, x.__emotion_base = a, x.__emotion_styles = h, x.__emotion_forwardProp = c, Object.defineProperty(x, "toString", {
      value: function() {
        return "." + l;
      }
    }), x.withComponent = function(w, k) {
      var E = e(w, mt({}, n, k, {
        shouldForwardProp: bD(x, k, !0)
      }));
      return E.apply(void 0, h);
    }, x;
  };
}, $te = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], PA = Ite.bind(null);
$te.forEach(function(e) {
  PA[e] = PA(e);
});
function zte(e) {
  return e == null || Object.keys(e).length === 0;
}
function g7(e) {
  const {
    styles: t,
    defaultTheme: n = {}
  } = e, r = typeof t == "function" ? (a) => t(zte(a) ? n : a) : t;
  return /* @__PURE__ */ C.jsx(Nte, {
    styles: r
  });
}
function v7(e, t) {
  return PA(e, t);
}
function Tte(e, t) {
  Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));
}
const wD = [];
function bd(e) {
  return wD[0] = e, GS(wD);
}
const Lte = (e) => {
  const t = Object.keys(e).map((n) => ({
    key: n,
    val: e[n]
  })) || [];
  return t.sort((n, r) => n.val - r.val), t.reduce((n, r) => ({
    ...n,
    [r.key]: r.val
  }), {});
};
function Fte(e) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: t = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: n = "px",
    step: r = 5,
    ...a
  } = e, s = Lte(t), l = Object.keys(s);
  function c(v) {
    return `@media (min-width:${typeof t[v] == "number" ? t[v] : v}${n})`;
  }
  function d(v) {
    return `@media (max-width:${(typeof t[v] == "number" ? t[v] : v) - r / 100}${n})`;
  }
  function f(v, g) {
    const b = l.indexOf(g);
    return `@media (min-width:${typeof t[v] == "number" ? t[v] : v}${n}) and (max-width:${(b !== -1 && typeof t[l[b]] == "number" ? t[l[b]] : g) - r / 100}${n})`;
  }
  function m(v) {
    return l.indexOf(v) + 1 < l.length ? f(v, l[l.indexOf(v) + 1]) : c(v);
  }
  function h(v) {
    const g = l.indexOf(v);
    return g === 0 ? c(l[1]) : g === l.length - 1 ? d(l[g]) : f(v, l[l.indexOf(v) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys: l,
    values: s,
    up: c,
    down: d,
    between: f,
    only: m,
    not: h,
    unit: n,
    ...a
  };
}
const Bte = {
  borderRadius: 4
};
function y7(e = 8, t = UR({
  spacing: e
})) {
  if (e.mui)
    return e;
  const n = (...r) => (r.length === 0 ? [1] : r).map((a) => {
    const s = t(a);
    return typeof s == "number" ? `${s}px` : s;
  }).join(" ");
  return n.mui = !0, n;
}
function Ute(e, t) {
  const n = this;
  if (n.vars) {
    if (!n.colorSchemes?.[e] || typeof n.getColorSchemeSelector != "function")
      return {};
    let r = n.getColorSchemeSelector(e);
    return r === "&" ? t : ((r.includes("data-") || r.includes(".")) && (r = `*:where(${r.replace(/\s*&$/, "")}) &`), {
      [r]: t
    });
  }
  return n.palette.mode === e ? t : {};
}
function yE(e = {}, ...t) {
  const {
    breakpoints: n = {},
    palette: r = {},
    spacing: a,
    shape: s = {},
    ...l
  } = e, c = Fte(n), d = y7(a);
  let f = Qo({
    breakpoints: c,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...r
    },
    spacing: d,
    shape: {
      ...Bte,
      ...s
    }
  }, l);
  return f = ZZ(f), f.applyStyles = Ute, f = t.reduce((m, h) => Qo(m, h), f), f.unstable_sxConfig = {
    ...WS,
    ...l?.unstable_sxConfig
  }, f.unstable_sx = function(m) {
    return Cd({
      sx: m,
      theme: this
    });
  }, f;
}
function Vte(e) {
  return Object.keys(e).length === 0;
}
function QR(e = null) {
  const t = M.useContext(KS);
  return !t || Vte(t) ? e : t;
}
const Hte = yE();
function XS(e = Hte) {
  return QR(e);
}
function xD(e) {
  const t = bd(e);
  return e !== t && t.styles ? (t.styles.match(/^@layer\s+[^{]*$/) || (t.styles = `@layer global{${t.styles}}`), t) : e;
}
function b7({
  styles: e,
  themeId: t,
  defaultTheme: n = {}
}) {
  const r = XS(n), a = t && r[t] || r;
  let s = typeof e == "function" ? e(a) : e;
  return a.modularCssLayers && (Array.isArray(s) ? s = s.map((l) => xD(typeof l == "function" ? l(a) : l)) : s = xD(s)), /* @__PURE__ */ C.jsx(g7, {
    styles: s
  });
}
const SD = (e) => e, Wte = () => {
  let e = SD;
  return {
    configure(t) {
      e = t;
    },
    generate(t) {
      return e(t);
    },
    reset() {
      e = SD;
    }
  };
}, w7 = Wte();
function qte(e = {}) {
  const {
    themeId: t,
    defaultTheme: n,
    defaultClassName: r = "MuiBox-root",
    generateClassName: a
  } = e, s = v7("div", {
    shouldForwardProp: (l) => l !== "theme" && l !== "sx" && l !== "as"
  })(Cd);
  return /* @__PURE__ */ M.forwardRef(function(l, c) {
    const d = XS(n), {
      className: f,
      component: m = "div",
      ...h
    } = HR(l);
    return /* @__PURE__ */ C.jsx(s, {
      as: m,
      ref: c,
      className: Ye(f, a ? a(r) : r),
      theme: t && d[t] || d,
      ...h
    });
  });
}
const Gte = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function Ct(e, t, n = "Mui") {
  const r = Gte[t];
  return r ? `${n}-${r}` : `${w7.generate(e)}-${t}`;
}
function St(e, t, n = "Mui") {
  const r = {};
  return t.forEach((a) => {
    r[a] = Ct(e, a, n);
  }), r;
}
function x7(e) {
  const {
    variants: t,
    ...n
  } = e, r = {
    variants: t,
    style: bd(n),
    isProcessed: !0
  };
  return r.style === n || t && t.forEach((a) => {
    typeof a.style != "function" && (a.style = bd(a.style));
  }), r;
}
const Kte = yE();
function xN(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
function _m(e, t) {
  return t && e && typeof e == "object" && e.styles && !e.styles.startsWith("@layer") && (e.styles = `@layer ${t}{${String(e.styles)}}`), e;
}
function Yte(e) {
  return e ? (t, n) => n[e] : null;
}
function Xte(e, t, n) {
  e.theme = Qte(e.theme) ? n : e.theme[t] || e.theme;
}
function C_(e, t, n) {
  const r = typeof t == "function" ? t(e) : t;
  if (Array.isArray(r))
    return r.flatMap((a) => C_(e, a, n));
  if (Array.isArray(r?.variants)) {
    let a;
    if (r.isProcessed)
      a = n ? _m(r.style, n) : r.style;
    else {
      const {
        variants: s,
        ...l
      } = r;
      a = n ? _m(bd(l), n) : l;
    }
    return S7(e, r.variants, [a], n);
  }
  return r?.isProcessed ? n ? _m(bd(r.style), n) : r.style : n ? _m(bd(r), n) : r;
}
function S7(e, t, n = [], r = void 0) {
  let a;
  e: for (let s = 0; s < t.length; s += 1) {
    const l = t[s];
    if (typeof l.props == "function") {
      if (a ?? (a = {
        ...e,
        ...e.ownerState,
        ownerState: e.ownerState
      }), !l.props(a))
        continue;
    } else
      for (const c in l.props)
        if (e[c] !== l.props[c] && e.ownerState?.[c] !== l.props[c])
          continue e;
    typeof l.style == "function" ? (a ?? (a = {
      ...e,
      ...e.ownerState,
      ownerState: e.ownerState
    }), n.push(r ? _m(bd(l.style(a)), r) : l.style(a))) : n.push(r ? _m(bd(l.style), r) : l.style);
  }
  return n;
}
function k7(e = {}) {
  const {
    themeId: t,
    defaultTheme: n = Kte,
    rootShouldForwardProp: r = xN,
    slotShouldForwardProp: a = xN
  } = e;
  function s(l) {
    Xte(l, t, n);
  }
  return (l, c = {}) => {
    Tte(l, (N) => N.filter((A) => A !== Cd));
    const {
      name: d,
      slot: f,
      skipVariantsResolver: m,
      skipSx: h,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: v = Yte(ene(f)),
      ...g
    } = c, b = d && d.startsWith("Mui") || f ? "components" : "custom", x = m !== void 0 ? m : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      f && f !== "Root" && f !== "root" || !1
    ), w = h || !1;
    let k = xN;
    f === "Root" || f === "root" ? k = r : f ? k = a : Zte(l) && (k = void 0);
    const E = v7(l, {
      shouldForwardProp: k,
      label: Jte(),
      ...g
    }), _ = (N) => {
      if (N.__emotion_real === N)
        return N;
      if (typeof N == "function")
        return function(A) {
          return C_(A, N, A.theme.modularCssLayers ? b : void 0);
        };
      if (El(N)) {
        const A = x7(N);
        return function(R) {
          return A.variants ? C_(R, A, R.theme.modularCssLayers ? b : void 0) : R.theme.modularCssLayers ? _m(A.style, b) : A.style;
        };
      }
      return N;
    }, O = (...N) => {
      const A = [], R = N.map(_), D = [];
      if (A.push(s), d && v && D.push(function(B) {
        const P = B.theme.components?.[d]?.styleOverrides;
        if (!P)
          return null;
        const H = {};
        for (const L in P)
          H[L] = C_(B, P[L], B.theme.modularCssLayers ? "theme" : void 0);
        return v(B, H);
      }), d && !x && D.push(function(B) {
        const P = B.theme?.components?.[d]?.variants;
        return P ? S7(B, P, [], B.theme.modularCssLayers ? "theme" : void 0) : null;
      }), w || D.push(Cd), Array.isArray(R[0])) {
        const B = R.shift(), P = new Array(A.length).fill(""), H = new Array(D.length).fill("");
        let L;
        L = [...P, ...B, ...H], L.raw = [...P, ...B.raw, ...H], A.unshift(L);
      }
      const I = [...A, ...R, ...D], z = E(...I);
      return l.muiName && (z.muiName = l.muiName), z;
    };
    return E.withConfig && (O.withConfig = E.withConfig), O;
  };
}
function Jte(e, t) {
  return void 0;
}
function Qte(e) {
  for (const t in e)
    return !1;
  return !0;
}
function Zte(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96;
}
function ene(e) {
  return e && e.charAt(0).toLowerCase() + e.slice(1);
}
const tne = k7();
function nS(e, t, n = !1) {
  const r = {
    ...t
  };
  for (const a in e)
    if (Object.prototype.hasOwnProperty.call(e, a)) {
      const s = a;
      if (s === "components" || s === "slots")
        r[s] = {
          ...e[s],
          ...r[s]
        };
      else if (s === "componentsProps" || s === "slotProps") {
        const l = e[s], c = t[s];
        if (!c)
          r[s] = l || {};
        else if (!l)
          r[s] = c;
        else {
          r[s] = {
            ...c
          };
          for (const d in l)
            if (Object.prototype.hasOwnProperty.call(l, d)) {
              const f = d;
              r[s][f] = nS(l[f], c[f], n);
            }
        }
      } else s === "className" && n && t.className ? r.className = Ye(e?.className, t?.className) : s === "style" && n && t.style ? r.style = {
        ...e?.style,
        ...t?.style
      } : r[s] === void 0 && (r[s] = e[s]);
    }
  return r;
}
function nne(e) {
  const {
    theme: t,
    name: n,
    props: r
  } = e;
  return !t || !t.components || !t.components[n] || !t.components[n].defaultProps ? r : nS(t.components[n].defaultProps, r);
}
function rne({
  props: e,
  name: t,
  defaultTheme: n,
  themeId: r
}) {
  let a = XS(n);
  return r && (a = a[r] || a), nne({
    theme: a,
    name: t,
    props: e
  });
}
const Zs = typeof window < "u" ? M.useLayoutEffect : M.useEffect;
function $h(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
  return Math.max(t, Math.min(e, n));
}
function ZR(e, t = 0, n = 1) {
  return $h(e, t, n);
}
function one(e) {
  e = e.slice(1);
  const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g");
  let n = e.match(t);
  return n && n[0].length === 1 && (n = n.map((r) => r + r)), n ? `rgb${n.length === 4 ? "a" : ""}(${n.map((r, a) => a < 3 ? parseInt(r, 16) : Math.round(parseInt(r, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function Od(e) {
  if (e.type)
    return e;
  if (e.charAt(0) === "#")
    return Od(one(e));
  const t = e.indexOf("("), n = e.substring(0, t);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(n))
    throw new Error(Ic(9, e));
  let r = e.substring(t + 1, e.length - 1), a;
  if (n === "color") {
    if (r = r.split(" "), a = r.shift(), r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)), !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(a))
      throw new Error(Ic(10, a));
  } else
    r = r.split(",");
  return r = r.map((s) => parseFloat(s)), {
    type: n,
    values: r,
    colorSpace: a
  };
}
const ane = (e) => {
  const t = Od(e);
  return t.values.slice(0, 3).map((n, r) => t.type.includes("hsl") && r !== 0 ? `${n}%` : n).join(" ");
}, mx = (e, t) => {
  try {
    return ane(e);
  } catch {
    return e;
  }
};
function bE(e) {
  const {
    type: t,
    colorSpace: n
  } = e;
  let {
    values: r
  } = e;
  return t.includes("rgb") ? r = r.map((a, s) => s < 3 ? parseInt(a, 10) : a) : t.includes("hsl") && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), t.includes("color") ? r = `${n} ${r.join(" ")}` : r = `${r.join(", ")}`, `${t}(${r})`;
}
function _7(e) {
  e = Od(e);
  const {
    values: t
  } = e, n = t[0], r = t[1] / 100, a = t[2] / 100, s = r * Math.min(a, 1 - a), l = (f, m = (f + n / 30) % 12) => a - s * Math.max(Math.min(m - 3, 9 - m, 1), -1);
  let c = "rgb";
  const d = [Math.round(l(0) * 255), Math.round(l(8) * 255), Math.round(l(4) * 255)];
  return e.type === "hsla" && (c += "a", d.push(t[3])), bE({
    type: c,
    values: d
  });
}
function DA(e) {
  e = Od(e);
  let t = e.type === "hsl" || e.type === "hsla" ? Od(_7(e)).values : e.values;
  return t = t.map((n) => (e.type !== "color" && (n /= 255), n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));
}
function ine(e, t) {
  const n = DA(e), r = DA(t);
  return (Math.max(n, r) + 0.05) / (Math.min(n, r) + 0.05);
}
function r2(e, t) {
  return e = Od(e), t = ZR(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, bE(e);
}
function cm(e, t, n) {
  try {
    return r2(e, t);
  } catch {
    return e;
  }
}
function wE(e, t) {
  if (e = Od(e), t = ZR(t), e.type.includes("hsl"))
    e.values[2] *= 1 - t;
  else if (e.type.includes("rgb") || e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] *= 1 - t;
  return bE(e);
}
function Dn(e, t, n) {
  try {
    return wE(e, t);
  } catch {
    return e;
  }
}
function xE(e, t) {
  if (e = Od(e), t = ZR(t), e.type.includes("hsl"))
    e.values[2] += (100 - e.values[2]) * t;
  else if (e.type.includes("rgb"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (255 - e.values[n]) * t;
  else if (e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (1 - e.values[n]) * t;
  return bE(e);
}
function In(e, t, n) {
  try {
    return xE(e, t);
  } catch {
    return e;
  }
}
function sne(e, t = 0.15) {
  return DA(e) > 0.5 ? wE(e, t) : xE(e, t);
}
function Uk(e, t, n) {
  try {
    return sne(e, t);
  } catch {
    return e;
  }
}
const E7 = /* @__PURE__ */ M.createContext(null);
function e4() {
  return M.useContext(E7);
}
const lne = typeof Symbol == "function" && Symbol.for, une = lne ? /* @__PURE__ */ Symbol.for("mui.nested") : "__THEME_NESTED__";
function cne(e, t) {
  return typeof t == "function" ? t(e) : {
    ...e,
    ...t
  };
}
function dne(e) {
  const {
    children: t,
    theme: n
  } = e, r = e4(), a = M.useMemo(() => {
    const s = r === null ? {
      ...n
    } : cne(r, n);
    return s != null && (s[une] = r !== null), s;
  }, [n, r]);
  return /* @__PURE__ */ C.jsx(E7.Provider, {
    value: a,
    children: t
  });
}
const C7 = /* @__PURE__ */ M.createContext();
function fne({
  value: e,
  ...t
}) {
  return /* @__PURE__ */ C.jsx(C7.Provider, {
    value: e ?? !0,
    ...t
  });
}
const O7 = () => M.useContext(C7) ?? !1, M7 = /* @__PURE__ */ M.createContext(void 0);
function pne({
  value: e,
  children: t
}) {
  return /* @__PURE__ */ C.jsx(M7.Provider, {
    value: e,
    children: t
  });
}
function mne(e) {
  const {
    theme: t,
    name: n,
    props: r
  } = e;
  if (!t || !t.components || !t.components[n])
    return r;
  const a = t.components[n];
  return a.defaultProps ? nS(a.defaultProps, r, t.components.mergeClassNameAndStyle) : !a.styleOverrides && !a.variants ? nS(a, r, t.components.mergeClassNameAndStyle) : r;
}
function hne({
  props: e,
  name: t
}) {
  const n = M.useContext(M7);
  return mne({
    props: e,
    name: t,
    theme: {
      components: n
    }
  });
}
let kD = 0;
function gne(e) {
  const [t, n] = M.useState(e), r = e || t;
  return M.useEffect(() => {
    t == null && (kD += 1, n(`mui-${kD}`));
  }, [t]), r;
}
const vne = {
  ...BS
}, _D = vne.useId;
function zg(e) {
  if (_D !== void 0) {
    const t = _D();
    return e ?? t;
  }
  return gne(e);
}
function yne(e) {
  const t = QR(), n = zg() || "", {
    modularCssLayers: r
  } = e;
  let a = "mui.global, mui.components, mui.theme, mui.custom, mui.sx";
  return !r || t !== null ? a = "" : typeof r == "string" ? a = r.replace(/mui(?!\.)/g, a) : a = `@layer ${a};`, Zs(() => {
    const s = document.querySelector("head");
    if (!s)
      return;
    const l = s.firstChild;
    if (a) {
      if (l && l.hasAttribute?.("data-mui-layer-order") && l.getAttribute("data-mui-layer-order") === n)
        return;
      const c = document.createElement("style");
      c.setAttribute("data-mui-layer-order", n), c.textContent = a, s.prepend(c);
    } else
      s.querySelector(`style[data-mui-layer-order="${n}"]`)?.remove();
  }, [a, n]), a ? /* @__PURE__ */ C.jsx(b7, {
    styles: a
  }) : null;
}
const ED = {};
function CD(e, t, n, r = !1) {
  return M.useMemo(() => {
    const a = e && t[e] || t;
    if (typeof n == "function") {
      const s = n(a), l = e ? {
        ...t,
        [e]: s
      } : s;
      return r ? () => l : l;
    }
    return e ? {
      ...t,
      [e]: n
    } : {
      ...t,
      ...n
    };
  }, [e, t, n, r]);
}
function N7(e) {
  const {
    children: t,
    theme: n,
    themeId: r
  } = e, a = QR(ED), s = e4() || ED, l = CD(r, a, n), c = CD(r, s, n, !0), d = (r ? l[r] : l).direction === "rtl", f = yne(l);
  return /* @__PURE__ */ C.jsx(dne, {
    theme: c,
    children: /* @__PURE__ */ C.jsx(KS.Provider, {
      value: l,
      children: /* @__PURE__ */ C.jsx(fne, {
        value: d,
        children: /* @__PURE__ */ C.jsxs(pne, {
          value: r ? l[r].components : l.components,
          children: [f, t]
        })
      })
    })
  });
}
const OD = {
  theme: void 0
};
function bne(e) {
  let t, n;
  return function(r) {
    let a = t;
    return (a === void 0 || r.theme !== n) && (OD.theme = r.theme, a = x7(e(OD)), t = a, n = r.theme), a;
  };
}
const t4 = "mode", n4 = "color-scheme", wne = "data-color-scheme";
function xne(e) {
  const {
    defaultMode: t = "system",
    defaultLightColorScheme: n = "light",
    defaultDarkColorScheme: r = "dark",
    modeStorageKey: a = t4,
    colorSchemeStorageKey: s = n4,
    attribute: l = wne,
    colorSchemeNode: c = "document.documentElement",
    nonce: d
  } = e || {};
  let f = "", m = l;
  if (l === "class" && (m = ".%s"), l === "data" && (m = "[data-%s]"), m.startsWith(".")) {
    const v = m.substring(1);
    f += `${c}.classList.remove('${v}'.replace('%s', light), '${v}'.replace('%s', dark));
      ${c}.classList.add('${v}'.replace('%s', colorScheme));`;
  }
  const h = m.match(/\[([^[\]]+)\]/);
  if (h) {
    const [v, g] = h[1].split("=");
    g || (f += `${c}.removeAttribute('${v}'.replace('%s', light));
      ${c}.removeAttribute('${v}'.replace('%s', dark));`), f += `
      ${c}.setAttribute('${v}'.replace('%s', colorScheme), ${g ? `${g}.replace('%s', colorScheme)` : '""'});`;
  } else m !== ".%s" && (f += `${c}.setAttribute('${m}', colorScheme);`);
  return /* @__PURE__ */ C.jsx("script", {
    suppressHydrationWarning: !0,
    nonce: typeof window > "u" ? d : "",
    dangerouslySetInnerHTML: {
      __html: `(function() {
try {
  let colorScheme = '';
  const mode = localStorage.getItem('${a}') || '${t}';
  const dark = localStorage.getItem('${s}-dark') || '${r}';
  const light = localStorage.getItem('${s}-light') || '${n}';
  if (mode === 'system') {
    // handle system mode
    const mql = window.matchMedia('(prefers-color-scheme: dark)');
    if (mql.matches) {
      colorScheme = dark
    } else {
      colorScheme = light
    }
  }
  if (mode === 'light') {
    colorScheme = light;
  }
  if (mode === 'dark') {
    colorScheme = dark;
  }
  if (colorScheme) {
    ${f}
  }
} catch(e){}})();`
    }
  }, "mui-color-scheme-init");
}
function Sne() {
}
const kne = ({
  key: e,
  storageWindow: t
}) => (!t && typeof window < "u" && (t = window), {
  get(n) {
    if (typeof window > "u")
      return;
    if (!t)
      return n;
    let r;
    try {
      r = t.localStorage.getItem(e);
    } catch {
    }
    return r || n;
  },
  set: (n) => {
    if (t)
      try {
        t.localStorage.setItem(e, n);
      } catch {
      }
  },
  subscribe: (n) => {
    if (!t)
      return Sne;
    const r = (a) => {
      const s = a.newValue;
      a.key === e && n(s);
    };
    return t.addEventListener("storage", r), () => {
      t.removeEventListener("storage", r);
    };
  }
});
function SN() {
}
function MD(e) {
  if (typeof window < "u" && typeof window.matchMedia == "function" && e === "system")
    return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
}
function A7(e, t) {
  if (e.mode === "light" || e.mode === "system" && e.systemMode === "light")
    return t("light");
  if (e.mode === "dark" || e.mode === "system" && e.systemMode === "dark")
    return t("dark");
}
function _ne(e) {
  return A7(e, (t) => {
    if (t === "light")
      return e.lightColorScheme;
    if (t === "dark")
      return e.darkColorScheme;
  });
}
function Ene(e) {
  const {
    defaultMode: t = "light",
    defaultLightColorScheme: n,
    defaultDarkColorScheme: r,
    supportedColorSchemes: a = [],
    modeStorageKey: s = t4,
    colorSchemeStorageKey: l = n4,
    storageWindow: c = typeof window > "u" ? void 0 : window,
    storageManager: d = kne,
    noSsr: f = !1
  } = e, m = a.join(","), h = a.length > 1, v = M.useMemo(() => d?.({
    key: s,
    storageWindow: c
  }), [d, s, c]), g = M.useMemo(() => d?.({
    key: `${l}-light`,
    storageWindow: c
  }), [d, l, c]), b = M.useMemo(() => d?.({
    key: `${l}-dark`,
    storageWindow: c
  }), [d, l, c]), [x, w] = M.useState(() => {
    const D = v?.get(t) || t, I = g?.get(n) || n, z = b?.get(r) || r;
    return {
      mode: D,
      systemMode: MD(D),
      lightColorScheme: I,
      darkColorScheme: z
    };
  }), [k, E] = M.useState(f || !h);
  M.useEffect(() => {
    E(!0);
  }, []);
  const _ = _ne(x), O = M.useCallback((D) => {
    w((I) => {
      if (D === I.mode)
        return I;
      const z = D ?? t;
      return v?.set(z), {
        ...I,
        mode: z,
        systemMode: MD(z)
      };
    });
  }, [v, t]), N = M.useCallback((D) => {
    D ? typeof D == "string" ? D && !m.includes(D) ? console.error(`\`${D}\` does not exist in \`theme.colorSchemes\`.`) : w((I) => {
      const z = {
        ...I
      };
      return A7(I, (B) => {
        B === "light" && (g?.set(D), z.lightColorScheme = D), B === "dark" && (b?.set(D), z.darkColorScheme = D);
      }), z;
    }) : w((I) => {
      const z = {
        ...I
      }, B = D.light === null ? n : D.light, P = D.dark === null ? r : D.dark;
      return B && (m.includes(B) ? (z.lightColorScheme = B, g?.set(B)) : console.error(`\`${B}\` does not exist in \`theme.colorSchemes\`.`)), P && (m.includes(P) ? (z.darkColorScheme = P, b?.set(P)) : console.error(`\`${P}\` does not exist in \`theme.colorSchemes\`.`)), z;
    }) : w((I) => (g?.set(n), b?.set(r), {
      ...I,
      lightColorScheme: n,
      darkColorScheme: r
    }));
  }, [m, g, b, n, r]), A = M.useCallback((D) => {
    x.mode === "system" && w((I) => {
      const z = D?.matches ? "dark" : "light";
      return I.systemMode === z ? I : {
        ...I,
        systemMode: z
      };
    });
  }, [x.mode]), R = M.useRef(A);
  return R.current = A, M.useEffect(() => {
    if (typeof window.matchMedia != "function" || !h)
      return;
    const D = (...z) => R.current(...z), I = window.matchMedia("(prefers-color-scheme: dark)");
    return I.addListener(D), D(I), () => {
      I.removeListener(D);
    };
  }, [h]), M.useEffect(() => {
    if (h) {
      const D = v?.subscribe((B) => {
        (!B || ["light", "dark", "system"].includes(B)) && O(B || t);
      }) || SN, I = g?.subscribe((B) => {
        (!B || m.match(B)) && N({
          light: B
        });
      }) || SN, z = b?.subscribe((B) => {
        (!B || m.match(B)) && N({
          dark: B
        });
      }) || SN;
      return () => {
        D(), I(), z();
      };
    }
  }, [N, O, m, t, c, h, v, g, b]), {
    ...x,
    mode: k ? x.mode : void 0,
    systemMode: k ? x.systemMode : void 0,
    colorScheme: k ? _ : void 0,
    setMode: O,
    setColorScheme: N
  };
}
const Cne = "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
function One(e) {
  const {
    themeId: t,
    /**
     * This `theme` object needs to follow a certain structure to
     * be used correctly by the finel `CssVarsProvider`. It should have a
     * `colorSchemes` key with the light and dark (and any other) palette.
     * It should also ideally have a vars object created using `prepareCssVars`.
     */
    theme: n = {},
    modeStorageKey: r = t4,
    colorSchemeStorageKey: a = n4,
    disableTransitionOnChange: s = !1,
    defaultColorScheme: l,
    resolveTheme: c
  } = e, d = {
    allColorSchemes: [],
    colorScheme: void 0,
    darkColorScheme: void 0,
    lightColorScheme: void 0,
    mode: void 0,
    setColorScheme: () => {
    },
    setMode: () => {
    },
    systemMode: void 0
  }, f = /* @__PURE__ */ M.createContext(void 0), m = () => M.useContext(f) || d, h = {}, v = {};
  function g(w) {
    const {
      children: k,
      theme: E,
      modeStorageKey: _ = r,
      colorSchemeStorageKey: O = a,
      disableTransitionOnChange: N = s,
      storageManager: A,
      storageWindow: R = typeof window > "u" ? void 0 : window,
      documentNode: D = typeof document > "u" ? void 0 : document,
      colorSchemeNode: I = typeof document > "u" ? void 0 : document.documentElement,
      disableNestedContext: z = !1,
      disableStyleSheetGeneration: B = !1,
      defaultMode: P = "system",
      forceThemeRerender: H = !1,
      noSsr: L
    } = w, G = M.useRef(!1), $ = e4(), K = M.useContext(f), q = !!K && !z, Z = M.useMemo(() => E || (typeof n == "function" ? n() : n), [E]), V = Z[t], F = V || Z, {
      colorSchemes: Y = h,
      components: U = v,
      cssVarPrefix: W
    } = F, J = Object.keys(Y).filter((Me) => !!Y[Me]).join(","), oe = M.useMemo(() => J.split(","), [J]), fe = typeof l == "string" ? l : l.light, ie = typeof l == "string" ? l : l.dark, ce = Y[fe] && Y[ie] ? P : Y[F.defaultColorScheme]?.palette?.mode || F.palette?.mode, {
      mode: ge,
      setMode: re,
      systemMode: le,
      lightColorScheme: me,
      darkColorScheme: ve,
      colorScheme: xe,
      setColorScheme: _e
    } = Ene({
      supportedColorSchemes: oe,
      defaultLightColorScheme: fe,
      defaultDarkColorScheme: ie,
      modeStorageKey: _,
      colorSchemeStorageKey: O,
      defaultMode: ce,
      storageManager: A,
      storageWindow: R,
      noSsr: L
    });
    let Ge = ge, Xe = xe;
    q && (Ge = K.mode, Xe = K.colorScheme);
    let tt = Xe || F.defaultColorScheme;
    F.vars && !H && (tt = F.defaultColorScheme);
    const nt = M.useMemo(() => {
      const Me = F.generateThemeVars?.() || F.vars, he = {
        ...F,
        components: U,
        colorSchemes: Y,
        cssVarPrefix: W,
        vars: Me
      };
      if (typeof he.generateSpacing == "function" && (he.spacing = he.generateSpacing()), tt) {
        const ye = Y[tt];
        ye && typeof ye == "object" && Object.keys(ye).forEach((Ee) => {
          ye[Ee] && typeof ye[Ee] == "object" ? he[Ee] = {
            ...he[Ee],
            ...ye[Ee]
          } : he[Ee] = ye[Ee];
        });
      }
      return c ? c(he) : he;
    }, [F, tt, U, Y, W]), je = F.colorSchemeSelector;
    Zs(() => {
      if (Xe && I && je && je !== "media") {
        const Me = je;
        let he = je;
        if (Me === "class" && (he = ".%s"), Me === "data" && (he = "[data-%s]"), Me?.startsWith("data-") && !Me.includes("%s") && (he = `[${Me}="%s"]`), he.startsWith("."))
          I.classList.remove(...oe.map((ye) => he.substring(1).replace("%s", ye))), I.classList.add(he.substring(1).replace("%s", Xe));
        else {
          const ye = he.replace("%s", Xe).match(/\[([^\]]+)\]/);
          if (ye) {
            const [Ee, Te] = ye[1].split("=");
            Te || oe.forEach((Fe) => {
              I.removeAttribute(Ee.replace(Xe, Fe));
            }), I.setAttribute(Ee, Te ? Te.replace(/"|'/g, "") : "");
          } else
            I.setAttribute(he, Xe);
        }
      }
    }, [Xe, je, I, oe]), M.useEffect(() => {
      let Me;
      if (N && G.current && D) {
        const he = D.createElement("style");
        he.appendChild(D.createTextNode(Cne)), D.head.appendChild(he), window.getComputedStyle(D.body), Me = setTimeout(() => {
          D.head.removeChild(he);
        }, 1);
      }
      return () => {
        clearTimeout(Me);
      };
    }, [Xe, N, D]), M.useEffect(() => (G.current = !0, () => {
      G.current = !1;
    }), []);
    const cn = M.useMemo(() => ({
      allColorSchemes: oe,
      colorScheme: Xe,
      darkColorScheme: ve,
      lightColorScheme: me,
      mode: Ge,
      setColorScheme: _e,
      setMode: re,
      systemMode: le
    }), [oe, Xe, ve, me, Ge, _e, re, le, nt.colorSchemeSelector]);
    let pt = !0;
    (B || F.cssVariables === !1 || q && $?.cssVarPrefix === W) && (pt = !1);
    const Ce = /* @__PURE__ */ C.jsxs(M.Fragment, {
      children: [/* @__PURE__ */ C.jsx(N7, {
        themeId: V ? t : void 0,
        theme: nt,
        children: k
      }), pt && /* @__PURE__ */ C.jsx(g7, {
        styles: nt.generateStyleSheets?.() || []
      })]
    });
    return q ? Ce : /* @__PURE__ */ C.jsx(f.Provider, {
      value: cn,
      children: Ce
    });
  }
  const b = typeof l == "string" ? l : l.light, x = typeof l == "string" ? l : l.dark;
  return {
    CssVarsProvider: g,
    useColorScheme: m,
    getInitColorSchemeScript: (w) => xne({
      colorSchemeStorageKey: a,
      defaultLightColorScheme: b,
      defaultDarkColorScheme: x,
      modeStorageKey: r,
      ...w
    })
  };
}
function Mne(e = "") {
  function t(...n) {
    if (!n.length)
      return "";
    const r = n[0];
    return typeof r == "string" && !r.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/) ? `, var(--${e ? `${e}-` : ""}${r}${t(...n.slice(1))})` : `, ${r}`;
  }
  return (n, ...r) => `var(--${e ? `${e}-` : ""}${n}${t(...r)})`;
}
const ND = (e, t, n, r = []) => {
  let a = e;
  t.forEach((s, l) => {
    l === t.length - 1 ? Array.isArray(a) ? a[Number(s)] = n : a && typeof a == "object" && (a[s] = n) : a && typeof a == "object" && (a[s] || (a[s] = r.includes(s) ? [] : {}), a = a[s]);
  });
}, Nne = (e, t, n) => {
  function r(a, s = [], l = []) {
    Object.entries(a).forEach(([c, d]) => {
      (!n || n && !n([...s, c])) && d != null && (typeof d == "object" && Object.keys(d).length > 0 ? r(d, [...s, c], Array.isArray(d) ? [...l, c] : l) : t([...s, c], d, l));
    });
  }
  r(e);
}, Ane = (e, t) => typeof t == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((n) => e.includes(n)) || e[e.length - 1].toLowerCase().includes("opacity") ? t : `${t}px` : t;
function kN(e, t) {
  const {
    prefix: n,
    shouldSkipGeneratingVar: r
  } = t || {}, a = {}, s = {}, l = {};
  return Nne(
    e,
    (c, d, f) => {
      if ((typeof d == "string" || typeof d == "number") && (!r || !r(c, d))) {
        const m = `--${n ? `${n}-` : ""}${c.join("-")}`, h = Ane(c, d);
        Object.assign(a, {
          [m]: h
        }), ND(s, c, `var(${m})`, f), ND(l, c, `var(${m}, ${h})`, f);
      }
    },
    (c) => c[0] === "vars"
    // skip 'vars/*' paths
  ), {
    css: a,
    vars: s,
    varsWithDefaults: l
  };
}
function Rne(e, t = {}) {
  const {
    getSelector: n = k,
    disableCssColorScheme: r,
    colorSchemeSelector: a,
    enableContrastVars: s
  } = t, {
    colorSchemes: l = {},
    components: c,
    defaultColorScheme: d = "light",
    ...f
  } = e, {
    vars: m,
    css: h,
    varsWithDefaults: v
  } = kN(f, t);
  let g = v;
  const b = {}, {
    [d]: x,
    ...w
  } = l;
  if (Object.entries(w || {}).forEach(([E, _]) => {
    const {
      vars: O,
      css: N,
      varsWithDefaults: A
    } = kN(_, t);
    g = Qo(g, A), b[E] = {
      css: N,
      vars: O
    };
  }), x) {
    const {
      css: E,
      vars: _,
      varsWithDefaults: O
    } = kN(x, t);
    g = Qo(g, O), b[d] = {
      css: E,
      vars: _
    };
  }
  function k(E, _) {
    let O = a;
    if (a === "class" && (O = ".%s"), a === "data" && (O = "[data-%s]"), a?.startsWith("data-") && !a.includes("%s") && (O = `[${a}="%s"]`), E) {
      if (O === "media")
        return e.defaultColorScheme === E ? ":root" : {
          [`@media (prefers-color-scheme: ${l[E]?.palette?.mode || E})`]: {
            ":root": _
          }
        };
      if (O)
        return e.defaultColorScheme === E ? `:root, ${O.replace("%s", String(E))}` : O.replace("%s", String(E));
    }
    return ":root";
  }
  return {
    vars: g,
    generateThemeVars: () => {
      let E = {
        ...m
      };
      return Object.entries(b).forEach(([, {
        vars: _
      }]) => {
        E = Qo(E, _);
      }), E;
    },
    generateStyleSheets: () => {
      const E = [], _ = e.defaultColorScheme || "light";
      function O(R, D) {
        Object.keys(D).length && E.push(typeof R == "string" ? {
          [R]: {
            ...D
          }
        } : R);
      }
      O(n(void 0, {
        ...h
      }), h);
      const {
        [_]: N,
        ...A
      } = b;
      if (N) {
        const {
          css: R
        } = N, D = l[_]?.palette?.mode, I = !r && D ? {
          colorScheme: D,
          ...R
        } : {
          ...R
        };
        O(n(_, {
          ...I
        }), I);
      }
      return Object.entries(A).forEach(([R, {
        css: D
      }]) => {
        const I = l[R]?.palette?.mode, z = !r && I ? {
          colorScheme: I,
          ...D
        } : {
          ...D
        };
        O(n(R, {
          ...z
        }), z);
      }), s && E.push({
        ":root": {
          // use double underscore to indicate that these are private variables
          "--__l-threshold": "0.7",
          "--__l": "clamp(0, (l / var(--__l-threshold) - 1) * -infinity, 1)",
          "--__a": "clamp(0.87, (l / var(--__l-threshold) - 1) * -infinity, 1)"
          // 0.87 is the default alpha value for black text.
        }
      }), E;
    }
  };
}
function jne(e) {
  return function(t) {
    return e === "media" ? `@media (prefers-color-scheme: ${t})` : e ? e.startsWith("data-") && !e.includes("%s") ? `[${e}="${t}"] &` : e === "class" ? `.${t} &` : e === "data" ? `[data-${t}] &` : `${e.replace("%s", t)} &` : "&";
  };
}
function Ax(e, t) {
  return /* @__PURE__ */ M.isValidElement(e) && t.indexOf(
    // For server components `muiName` is available in element.type._payload.value.muiName
    // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
    // eslint-disable-next-line no-underscore-dangle
    e.type.muiName ?? e.type?._payload?.value?.muiName
  ) !== -1;
}
const Pne = (e, t) => e.filter((n) => t.includes(n)), Tg = (e, t, n) => {
  const r = e.keys[0];
  Array.isArray(t) ? t.forEach((a, s) => {
    n((l, c) => {
      s <= e.keys.length - 1 && (s === 0 ? Object.assign(l, c) : l[e.up(e.keys[s])] = c);
    }, a);
  }) : t && typeof t == "object" ? (Object.keys(t).length > e.keys.length ? e.keys : Pne(e.keys, Object.keys(t))).forEach((a) => {
    if (e.keys.includes(a)) {
      const s = t[a];
      s !== void 0 && n((l, c) => {
        r === a ? Object.assign(l, c) : l[e.up(a)] = c;
      }, s);
    }
  }) : (typeof t == "number" || typeof t == "string") && n((a, s) => {
    Object.assign(a, s);
  }, t);
};
function o2(e) {
  return `--Grid-${e}Spacing`;
}
function SE(e) {
  return `--Grid-parent-${e}Spacing`;
}
const AD = "--Grid-columns", Zh = "--Grid-parent-columns", Dne = ({
  theme: e,
  ownerState: t
}) => {
  const n = {};
  return Tg(e.breakpoints, t.size, (r, a) => {
    let s = {};
    a === "grow" && (s = {
      flexBasis: 0,
      flexGrow: 1,
      maxWidth: "100%"
    }), a === "auto" && (s = {
      flexBasis: "auto",
      flexGrow: 0,
      flexShrink: 0,
      maxWidth: "none",
      width: "auto"
    }), typeof a == "number" && (s = {
      flexGrow: 0,
      flexBasis: "auto",
      width: `calc(100% * ${a} / var(${Zh}) - (var(${Zh}) - ${a}) * (var(${SE("column")}) / var(${Zh})))`
    }), r(n, s);
  }), n;
}, Ine = ({
  theme: e,
  ownerState: t
}) => {
  const n = {};
  return Tg(e.breakpoints, t.offset, (r, a) => {
    let s = {};
    a === "auto" && (s = {
      marginLeft: "auto"
    }), typeof a == "number" && (s = {
      marginLeft: a === 0 ? "0px" : `calc(100% * ${a} / var(${Zh}) + var(${SE("column")}) * ${a} / var(${Zh}))`
    }), r(n, s);
  }), n;
}, $ne = ({
  theme: e,
  ownerState: t
}) => {
  if (!t.container)
    return {};
  const n = {
    [AD]: 12
  };
  return Tg(e.breakpoints, t.columns, (r, a) => {
    const s = a ?? 12;
    r(n, {
      [AD]: s,
      "> *": {
        [Zh]: s
      }
    });
  }), n;
}, zne = ({
  theme: e,
  ownerState: t
}) => {
  if (!t.container)
    return {};
  const n = {};
  return Tg(e.breakpoints, t.rowSpacing, (r, a) => {
    const s = typeof a == "string" ? a : e.spacing?.(a);
    r(n, {
      [o2("row")]: s,
      "> *": {
        [SE("row")]: s
      }
    });
  }), n;
}, Tne = ({
  theme: e,
  ownerState: t
}) => {
  if (!t.container)
    return {};
  const n = {};
  return Tg(e.breakpoints, t.columnSpacing, (r, a) => {
    const s = typeof a == "string" ? a : e.spacing?.(a);
    r(n, {
      [o2("column")]: s,
      "> *": {
        [SE("column")]: s
      }
    });
  }), n;
}, Lne = ({
  theme: e,
  ownerState: t
}) => {
  if (!t.container)
    return {};
  const n = {};
  return Tg(e.breakpoints, t.direction, (r, a) => {
    r(n, {
      flexDirection: a
    });
  }), n;
}, Fne = ({
  ownerState: e
}) => ({
  minWidth: 0,
  boxSizing: "border-box",
  ...e.container && {
    display: "flex",
    flexWrap: "wrap",
    ...e.wrap && e.wrap !== "wrap" && {
      flexWrap: e.wrap
    },
    gap: `var(${o2("row")}) var(${o2("column")})`
  }
}), Bne = (e) => {
  const t = [];
  return Object.entries(e).forEach(([n, r]) => {
    r !== !1 && r !== void 0 && t.push(`grid-${n}-${String(r)}`);
  }), t;
}, Une = (e, t = "xs") => {
  function n(r) {
    return r === void 0 ? !1 : typeof r == "string" && !Number.isNaN(Number(r)) || typeof r == "number" && r > 0;
  }
  if (n(e))
    return [`spacing-${t}-${String(e)}`];
  if (typeof e == "object" && !Array.isArray(e)) {
    const r = [];
    return Object.entries(e).forEach(([a, s]) => {
      n(s) && r.push(`spacing-${a}-${String(s)}`);
    }), r;
  }
  return [];
}, Vne = (e) => e === void 0 ? [] : typeof e == "object" ? Object.entries(e).map(([t, n]) => `direction-${t}-${n}`) : [`direction-xs-${String(e)}`];
function Hne(e, t) {
  const n = [];
  e.item !== void 0 && (delete e.item, n.push("item")), e.zeroMinWidth !== void 0 && (delete e.zeroMinWidth, n.push("zeroMinWidth")), t.keys.forEach((r) => {
    e[r] !== void 0 && (n.push(r), delete e[r]);
  });
}
const Wne = yE(), qne = tne("div", {
  name: "MuiGrid",
  slot: "Root"
});
function Gne(e) {
  return rne({
    props: e,
    name: "MuiGrid",
    defaultTheme: Wne
  });
}
function Kne(e = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent: t = qne,
    useThemeProps: n = Gne,
    useTheme: r = XS,
    componentName: a = "MuiGrid"
  } = e, s = (f, m) => {
    const {
      container: h,
      direction: v,
      spacing: g,
      wrap: b,
      size: x
    } = f, w = {
      root: ["root", h && "container", b !== "wrap" && `wrap-xs-${String(b)}`, ...Vne(v), ...Bne(x), ...h ? Une(g, m.breakpoints.keys[0]) : []]
    };
    return Et(w, (k) => Ct(a, k), {});
  };
  function l(f, m, h = () => !0) {
    const v = {};
    return f === null || (Array.isArray(f) ? f.forEach((g, b) => {
      g !== null && h(g) && m.keys[b] && (v[m.keys[b]] = g);
    }) : typeof f == "object" ? Object.keys(f).forEach((g) => {
      const b = f[g];
      b != null && h(b) && (v[g] = b);
    }) : v[m.keys[0]] = f), v;
  }
  const c = t($ne, Tne, zne, Dne, Lne, Fne, Ine), d = /* @__PURE__ */ M.forwardRef(function(f, m) {
    const h = r(), v = n(f), g = HR(v);
    Hne(g, h.breakpoints);
    const {
      className: b,
      children: x,
      columns: w = 12,
      container: k = !1,
      component: E = "div",
      direction: _ = "row",
      wrap: O = "wrap",
      size: N = {},
      offset: A = {},
      spacing: R = 0,
      rowSpacing: D = R,
      columnSpacing: I = R,
      unstable_level: z = 0,
      ...B
    } = g, P = l(N, h.breakpoints, (V) => V !== !1), H = l(A, h.breakpoints), L = f.columns ?? (z ? void 0 : w), G = f.spacing ?? (z ? void 0 : R), $ = f.rowSpacing ?? f.spacing ?? (z ? void 0 : D), K = f.columnSpacing ?? f.spacing ?? (z ? void 0 : I), q = {
      ...g,
      level: z,
      columns: L,
      container: k,
      direction: _,
      wrap: O,
      spacing: G,
      rowSpacing: $,
      columnSpacing: K,
      size: P,
      offset: H
    }, Z = s(q, h);
    return /* @__PURE__ */ C.jsx(c, {
      ref: m,
      as: E,
      ownerState: q,
      className: Ye(Z.root, b),
      ...B,
      children: M.Children.map(x, (V) => /* @__PURE__ */ M.isValidElement(V) && Ax(V, ["Grid"]) && k && V.props.container ? /* @__PURE__ */ M.cloneElement(V, {
        unstable_level: V.props?.unstable_level ?? z + 1
      }) : V)
    });
  });
  return d.muiName = "Grid", d;
}
const rS = {
  black: "#000",
  white: "#fff"
}, Yne = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
}, fh = {
  50: "#f3e5f5",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  700: "#7b1fa2"
}, ph = {
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  700: "#d32f2f",
  800: "#c62828"
}, Gw = {
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  700: "#f57c00",
  900: "#e65100"
}, mh = {
  50: "#e3f2fd",
  200: "#90caf9",
  400: "#42a5f5",
  700: "#1976d2",
  800: "#1565c0"
}, hh = {
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  700: "#0288d1",
  900: "#01579b"
}, gh = {
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20"
};
function R7() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: rS.white,
      default: rS.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const j7 = R7();
function P7() {
  return {
    text: {
      primary: rS.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: rS.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const IA = P7();
function RD(e, t, n, r) {
  const a = r.light || r, s = r.dark || r * 1.5;
  e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : t === "light" ? e.light = xE(e.main, a) : t === "dark" && (e.dark = wE(e.main, s)));
}
function jD(e, t, n, r, a) {
  const s = a.light || a, l = a.dark || a * 1.5;
  t[n] || (t.hasOwnProperty(r) ? t[n] = t[r] : n === "light" ? t.light = `color-mix(in ${e}, ${t.main}, #fff ${(s * 100).toFixed(0)}%)` : n === "dark" && (t.dark = `color-mix(in ${e}, ${t.main}, #000 ${(l * 100).toFixed(0)}%)`));
}
function Xne(e = "light") {
  return e === "dark" ? {
    main: mh[200],
    light: mh[50],
    dark: mh[400]
  } : {
    main: mh[700],
    light: mh[400],
    dark: mh[800]
  };
}
function Jne(e = "light") {
  return e === "dark" ? {
    main: fh[200],
    light: fh[50],
    dark: fh[400]
  } : {
    main: fh[500],
    light: fh[300],
    dark: fh[700]
  };
}
function Qne(e = "light") {
  return e === "dark" ? {
    main: ph[500],
    light: ph[300],
    dark: ph[700]
  } : {
    main: ph[700],
    light: ph[400],
    dark: ph[800]
  };
}
function Zne(e = "light") {
  return e === "dark" ? {
    main: hh[400],
    light: hh[300],
    dark: hh[700]
  } : {
    main: hh[700],
    light: hh[500],
    dark: hh[900]
  };
}
function ere(e = "light") {
  return e === "dark" ? {
    main: gh[400],
    light: gh[300],
    dark: gh[700]
  } : {
    main: gh[800],
    light: gh[500],
    dark: gh[900]
  };
}
function tre(e = "light") {
  return e === "dark" ? {
    main: Gw[400],
    light: Gw[300],
    dark: Gw[700]
  } : {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: Gw[500],
    dark: Gw[900]
  };
}
function nre(e) {
  return `oklch(from ${e} var(--__l) 0 h / var(--__a))`;
}
function r4(e) {
  const {
    mode: t = "light",
    contrastThreshold: n = 3,
    tonalOffset: r = 0.2,
    colorSpace: a,
    ...s
  } = e, l = e.primary || Xne(t), c = e.secondary || Jne(t), d = e.error || Qne(t), f = e.info || Zne(t), m = e.success || ere(t), h = e.warning || tre(t);
  function v(x) {
    return a ? nre(x) : ine(x, IA.text.primary) >= n ? IA.text.primary : j7.text.primary;
  }
  const g = ({
    color: x,
    name: w,
    mainShade: k = 500,
    lightShade: E = 300,
    darkShade: _ = 700
  }) => {
    if (x = {
      ...x
    }, !x.main && x[k] && (x.main = x[k]), !x.hasOwnProperty("main"))
      throw new Error(Ic(11, w ? ` (${w})` : "", k));
    if (typeof x.main != "string")
      throw new Error(Ic(12, w ? ` (${w})` : "", JSON.stringify(x.main)));
    return a ? (jD(a, x, "light", E, r), jD(a, x, "dark", _, r)) : (RD(x, "light", E, r), RD(x, "dark", _, r)), x.contrastText || (x.contrastText = v(x.main)), x;
  };
  let b;
  return t === "light" ? b = R7() : t === "dark" && (b = P7()), Qo({
    // A collection of common colors.
    common: {
      ...rS
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: t,
    // The colors used to represent primary interface elements for a user.
    primary: g({
      color: l,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: g({
      color: c,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: g({
      color: d,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: g({
      color: h,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: g({
      color: f,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: g({
      color: m,
      name: "success"
    }),
    // The grey colors.
    grey: Yne,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: n,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: v,
    // Generate a rich color object.
    augmentColor: g,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: r,
    // The light and dark mode object.
    ...b
  }, s);
}
function rre(e) {
  const t = {};
  return Object.entries(e).forEach((n) => {
    const [r, a] = n;
    typeof a == "object" && (t[r] = `${a.fontStyle ? `${a.fontStyle} ` : ""}${a.fontVariant ? `${a.fontVariant} ` : ""}${a.fontWeight ? `${a.fontWeight} ` : ""}${a.fontStretch ? `${a.fontStretch} ` : ""}${a.fontSize || ""}${a.lineHeight ? `/${a.lineHeight} ` : ""}${a.fontFamily || ""}`);
  }), t;
}
function ore(e, t) {
  return {
    toolbar: {
      minHeight: 56,
      [e.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [e.up("sm")]: {
        minHeight: 64
      }
    },
    ...t
  };
}
function are(e) {
  return Math.round(e * 1e5) / 1e5;
}
const PD = {
  textTransform: "uppercase"
}, DD = '"Roboto", "Helvetica", "Arial", sans-serif';
function D7(e, t) {
  const {
    fontFamily: n = DD,
    // The default font size of the Material Specification.
    fontSize: r = 14,
    // px
    fontWeightLight: a = 300,
    fontWeightRegular: s = 400,
    fontWeightMedium: l = 500,
    fontWeightBold: c = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize: d = 16,
    // Apply the CSS properties to all the variants.
    allVariants: f,
    pxToRem: m,
    ...h
  } = typeof t == "function" ? t(e) : t, v = r / 14, g = m || ((w) => `${w / d * v}rem`), b = (w, k, E, _, O) => ({
    fontFamily: n,
    fontWeight: w,
    fontSize: g(k),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: E,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...n === DD ? {
      letterSpacing: `${are(_ / k)}em`
    } : {},
    ...O,
    ...f
  }), x = {
    h1: b(a, 96, 1.167, -1.5),
    h2: b(a, 60, 1.2, -0.5),
    h3: b(s, 48, 1.167, 0),
    h4: b(s, 34, 1.235, 0.25),
    h5: b(s, 24, 1.334, 0),
    h6: b(l, 20, 1.6, 0.15),
    subtitle1: b(s, 16, 1.75, 0.15),
    subtitle2: b(l, 14, 1.57, 0.1),
    body1: b(s, 16, 1.5, 0.15),
    body2: b(s, 14, 1.43, 0.15),
    button: b(l, 14, 1.75, 0.4, PD),
    caption: b(s, 12, 1.66, 0.4),
    overline: b(s, 12, 2.66, 1, PD),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return Qo({
    htmlFontSize: d,
    pxToRem: g,
    fontFamily: n,
    fontSize: r,
    fontWeightLight: a,
    fontWeightRegular: s,
    fontWeightMedium: l,
    fontWeightBold: c,
    ...x
  }, h, {
    clone: !1
    // No need to clone deep
  });
}
const ire = 0.2, sre = 0.14, lre = 0.12;
function pr(...e) {
  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${ire})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${sre})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${lre})`].join(",");
}
const ure = ["none", pr(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), pr(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), pr(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), pr(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), pr(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), pr(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), pr(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), pr(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), pr(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), pr(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), pr(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), pr(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), pr(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), pr(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), pr(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), pr(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), pr(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), pr(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), pr(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), pr(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), pr(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), pr(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), pr(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), pr(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], cre = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}, dre = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function ID(e) {
  return `${Math.round(e)}ms`;
}
function fre(e) {
  if (!e)
    return 0;
  const t = e / 36;
  return Math.min(Math.round((4 + 15 * t ** 0.25 + t / 5) * 10), 3e3);
}
function pre(e) {
  const t = {
    ...cre,
    ...e.easing
  }, n = {
    ...dre,
    ...e.duration
  };
  return {
    getAutoHeightDuration: fre,
    create: (r = ["all"], a = {}) => {
      const {
        duration: s = n.standard,
        easing: l = t.easeInOut,
        delay: c = 0,
        ...d
      } = a;
      return (Array.isArray(r) ? r : [r]).map((f) => `${f} ${typeof s == "string" ? s : ID(s)} ${l} ${typeof c == "string" ? c : ID(c)}`).join(",");
    },
    ...e,
    easing: t,
    duration: n
  };
}
const mre = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function hre(e) {
  return El(e) || typeof e > "u" || typeof e == "string" || typeof e == "boolean" || typeof e == "number" || Array.isArray(e);
}
function I7(e = {}) {
  const t = {
    ...e
  };
  function n(r) {
    const a = Object.entries(r);
    for (let s = 0; s < a.length; s++) {
      const [l, c] = a[s];
      !hre(c) || l.startsWith("unstable_") ? delete r[l] : El(c) && (r[l] = {
        ...c
      }, n(r[l]));
    }
  }
  return n(t), `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(t, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function $D(e) {
  return typeof e == "number" ? `${(e * 100).toFixed(0)}%` : `calc((${e}) * 100%)`;
}
const gre = (e) => {
  if (!Number.isNaN(+e))
    return +e;
  const t = e.match(/\d*\.?\d+/g);
  if (!t)
    return 0;
  let n = 0;
  for (let r = 0; r < t.length; r += 1)
    n += +t[r];
  return n;
};
function vre(e) {
  Object.assign(e, {
    alpha(t, n) {
      const r = this || e;
      return r.colorSpace ? `oklch(from ${t} l c h / ${typeof n == "string" ? `calc(${n})` : n})` : r.vars ? `rgba(${t.replace(/var\(--([^,\s)]+)(?:,[^)]+)?\)+/g, "var(--$1Channel)")} / ${typeof n == "string" ? `calc(${n})` : n})` : r2(t, gre(n));
    },
    lighten(t, n) {
      const r = this || e;
      return r.colorSpace ? `color-mix(in ${r.colorSpace}, ${t}, #fff ${$D(n)})` : xE(t, n);
    },
    darken(t, n) {
      const r = this || e;
      return r.colorSpace ? `color-mix(in ${r.colorSpace}, ${t}, #000 ${$D(n)})` : wE(t, n);
    }
  });
}
function $A(e = {}, ...t) {
  const {
    breakpoints: n,
    mixins: r = {},
    spacing: a,
    palette: s = {},
    transitions: l = {},
    typography: c = {},
    shape: d,
    colorSpace: f,
    ...m
  } = e;
  if (e.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  e.generateThemeVars === void 0)
    throw new Error(Ic(20));
  const h = r4({
    ...s,
    colorSpace: f
  }), v = yE(e);
  let g = Qo(v, {
    mixins: ore(v.breakpoints, r),
    palette: h,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: ure.slice(),
    typography: D7(h, c),
    transitions: pre(l),
    zIndex: {
      ...mre
    }
  });
  return g = Qo(g, m), g = t.reduce((b, x) => Qo(b, x), g), g.unstable_sxConfig = {
    ...WS,
    ...m?.unstable_sxConfig
  }, g.unstable_sx = function(b) {
    return Cd({
      sx: b,
      theme: this
    });
  }, g.toRuntimeSource = I7, vre(g), g;
}
function zA(e) {
  let t;
  return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, Math.round(t * 10) / 1e3;
}
const yre = [...Array(25)].map((e, t) => {
  if (t === 0)
    return "none";
  const n = zA(t);
  return `linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`;
});
function $7(e) {
  return {
    inputPlaceholder: e === "dark" ? 0.5 : 0.42,
    inputUnderline: e === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: e === "dark" ? 0.2 : 0.12,
    switchTrack: e === "dark" ? 0.3 : 0.38
  };
}
function z7(e) {
  return e === "dark" ? yre : [];
}
function bre(e) {
  const {
    palette: t = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity: n,
    overlays: r,
    colorSpace: a,
    ...s
  } = e, l = r4({
    ...t,
    colorSpace: a
  });
  return {
    palette: l,
    opacity: {
      ...$7(l.mode),
      ...n
    },
    overlays: r || z7(l.mode),
    ...s
  };
}
function wre(e) {
  return !!e[0].match(/(cssVarPrefix|colorSchemeSelector|modularCssLayers|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!e[0].match(/sxConfig$/) || // ends with sxConfig
  e[0] === "palette" && !!e[1]?.match(/(mode|contrastThreshold|tonalOffset)/);
}
const xre = (e) => [...[...Array(25)].map((t, n) => `--${e ? `${e}-` : ""}overlays-${n}`), `--${e ? `${e}-` : ""}palette-AppBar-darkBg`, `--${e ? `${e}-` : ""}palette-AppBar-darkColor`], Sre = (e) => (t, n) => {
  const r = e.rootSelector || ":root", a = e.colorSchemeSelector;
  let s = a;
  if (a === "class" && (s = ".%s"), a === "data" && (s = "[data-%s]"), a?.startsWith("data-") && !a.includes("%s") && (s = `[${a}="%s"]`), e.defaultColorScheme === t) {
    if (t === "dark") {
      const l = {};
      return xre(e.cssVarPrefix).forEach((c) => {
        l[c] = n[c], delete n[c];
      }), s === "media" ? {
        [r]: n,
        "@media (prefers-color-scheme: dark)": {
          [r]: l
        }
      } : s ? {
        [s.replace("%s", t)]: l,
        [`${r}, ${s.replace("%s", t)}`]: n
      } : {
        [r]: {
          ...n,
          ...l
        }
      };
    }
    if (s && s !== "media")
      return `${r}, ${s.replace("%s", String(t))}`;
  } else if (t) {
    if (s === "media")
      return {
        [`@media (prefers-color-scheme: ${String(t)})`]: {
          [r]: n
        }
      };
    if (s)
      return s.replace("%s", String(t));
  }
  return r;
};
function kre(e, t) {
  t.forEach((n) => {
    e[n] || (e[n] = {});
  });
}
function Se(e, t, n) {
  !e[t] && n && (e[t] = n);
}
function hx(e) {
  return typeof e != "string" || !e.startsWith("hsl") ? e : _7(e);
}
function hc(e, t) {
  `${t}Channel` in e || (e[`${t}Channel`] = mx(hx(e[t])));
}
function _re(e) {
  return typeof e == "number" ? `${e}px` : typeof e == "string" || typeof e == "function" || Array.isArray(e) ? e : "8px";
}
const fl = (e) => {
  try {
    return e();
  } catch {
  }
}, Ere = (e = "mui") => Mne(e);
function _N(e, t, n, r, a) {
  if (!n)
    return;
  n = n === !0 ? {} : n;
  const s = a === "dark" ? "dark" : "light";
  if (!r) {
    t[a] = bre({
      ...n,
      palette: {
        mode: s,
        ...n?.palette
      },
      colorSpace: e
    });
    return;
  }
  const {
    palette: l,
    ...c
  } = $A({
    ...r,
    palette: {
      mode: s,
      ...n?.palette
    },
    colorSpace: e
  });
  return t[a] = {
    ...n,
    palette: l,
    opacity: {
      ...$7(s),
      ...n?.opacity
    },
    overlays: n?.overlays || z7(s)
  }, c;
}
function Cre(e = {}, ...t) {
  const {
    colorSchemes: n = {
      light: !0
    },
    defaultColorScheme: r,
    disableCssColorScheme: a = !1,
    cssVarPrefix: s = "mui",
    nativeColor: l = !1,
    shouldSkipGeneratingVar: c = wre,
    colorSchemeSelector: d = n.light && n.dark ? "media" : void 0,
    rootSelector: f = ":root",
    ...m
  } = e, h = Object.keys(n)[0], v = r || (n.light && h !== "light" ? "light" : h), g = Ere(s), {
    [v]: b,
    light: x,
    dark: w,
    ...k
  } = n, E = {
    ...k
  };
  let _ = b;
  if ((v === "dark" && !("dark" in n) || v === "light" && !("light" in n)) && (_ = !0), !_)
    throw new Error(Ic(21, v));
  let O;
  l && (O = "oklch");
  const N = _N(O, E, _, m, v);
  x && !E.light && _N(O, E, x, void 0, "light"), w && !E.dark && _N(O, E, w, void 0, "dark");
  let A = {
    defaultColorScheme: v,
    ...N,
    cssVarPrefix: s,
    colorSchemeSelector: d,
    rootSelector: f,
    getCssVar: g,
    colorSchemes: E,
    font: {
      ...rre(N.typography),
      ...N.font
    },
    spacing: _re(m.spacing)
  };
  Object.keys(A.colorSchemes).forEach((B) => {
    const P = A.colorSchemes[B].palette, H = (G) => {
      const $ = G.split("-"), K = $[1], q = $[2];
      return g(G, P[K][q]);
    };
    P.mode === "light" && (Se(P.common, "background", "#fff"), Se(P.common, "onBackground", "#000")), P.mode === "dark" && (Se(P.common, "background", "#000"), Se(P.common, "onBackground", "#fff"));
    function L(G, $, K) {
      if (O) {
        let q;
        return G === cm && (q = `transparent ${((1 - K) * 100).toFixed(0)}%`), G === Dn && (q = `#000 ${(K * 100).toFixed(0)}%`), G === In && (q = `#fff ${(K * 100).toFixed(0)}%`), `color-mix(in ${O}, ${$}, ${q})`;
      }
      return G($, K);
    }
    if (kre(P, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]), P.mode === "light") {
      Se(P.Alert, "errorColor", L(Dn, P.error.light, 0.6)), Se(P.Alert, "infoColor", L(Dn, P.info.light, 0.6)), Se(P.Alert, "successColor", L(Dn, P.success.light, 0.6)), Se(P.Alert, "warningColor", L(Dn, P.warning.light, 0.6)), Se(P.Alert, "errorFilledBg", H("palette-error-main")), Se(P.Alert, "infoFilledBg", H("palette-info-main")), Se(P.Alert, "successFilledBg", H("palette-success-main")), Se(P.Alert, "warningFilledBg", H("palette-warning-main")), Se(P.Alert, "errorFilledColor", fl(() => P.getContrastText(P.error.main))), Se(P.Alert, "infoFilledColor", fl(() => P.getContrastText(P.info.main))), Se(P.Alert, "successFilledColor", fl(() => P.getContrastText(P.success.main))), Se(P.Alert, "warningFilledColor", fl(() => P.getContrastText(P.warning.main))), Se(P.Alert, "errorStandardBg", L(In, P.error.light, 0.9)), Se(P.Alert, "infoStandardBg", L(In, P.info.light, 0.9)), Se(P.Alert, "successStandardBg", L(In, P.success.light, 0.9)), Se(P.Alert, "warningStandardBg", L(In, P.warning.light, 0.9)), Se(P.Alert, "errorIconColor", H("palette-error-main")), Se(P.Alert, "infoIconColor", H("palette-info-main")), Se(P.Alert, "successIconColor", H("palette-success-main")), Se(P.Alert, "warningIconColor", H("palette-warning-main")), Se(P.AppBar, "defaultBg", H("palette-grey-100")), Se(P.Avatar, "defaultBg", H("palette-grey-400")), Se(P.Button, "inheritContainedBg", H("palette-grey-300")), Se(P.Button, "inheritContainedHoverBg", H("palette-grey-A100")), Se(P.Chip, "defaultBorder", H("palette-grey-400")), Se(P.Chip, "defaultAvatarColor", H("palette-grey-700")), Se(P.Chip, "defaultIconColor", H("palette-grey-700")), Se(P.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"), Se(P.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"), Se(P.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"), Se(P.LinearProgress, "primaryBg", L(In, P.primary.main, 0.62)), Se(P.LinearProgress, "secondaryBg", L(In, P.secondary.main, 0.62)), Se(P.LinearProgress, "errorBg", L(In, P.error.main, 0.62)), Se(P.LinearProgress, "infoBg", L(In, P.info.main, 0.62)), Se(P.LinearProgress, "successBg", L(In, P.success.main, 0.62)), Se(P.LinearProgress, "warningBg", L(In, P.warning.main, 0.62)), Se(P.Skeleton, "bg", O ? L(cm, P.text.primary, 0.11) : `rgba(${H("palette-text-primaryChannel")} / 0.11)`), Se(P.Slider, "primaryTrack", L(In, P.primary.main, 0.62)), Se(P.Slider, "secondaryTrack", L(In, P.secondary.main, 0.62)), Se(P.Slider, "errorTrack", L(In, P.error.main, 0.62)), Se(P.Slider, "infoTrack", L(In, P.info.main, 0.62)), Se(P.Slider, "successTrack", L(In, P.success.main, 0.62)), Se(P.Slider, "warningTrack", L(In, P.warning.main, 0.62));
      const G = O ? L(Dn, P.background.default, 0.6825) : Uk(P.background.default, 0.8);
      Se(P.SnackbarContent, "bg", G), Se(P.SnackbarContent, "color", fl(() => O ? IA.text.primary : P.getContrastText(G))), Se(P.SpeedDialAction, "fabHoverBg", Uk(P.background.paper, 0.15)), Se(P.StepConnector, "border", H("palette-grey-400")), Se(P.StepContent, "border", H("palette-grey-400")), Se(P.Switch, "defaultColor", H("palette-common-white")), Se(P.Switch, "defaultDisabledColor", H("palette-grey-100")), Se(P.Switch, "primaryDisabledColor", L(In, P.primary.main, 0.62)), Se(P.Switch, "secondaryDisabledColor", L(In, P.secondary.main, 0.62)), Se(P.Switch, "errorDisabledColor", L(In, P.error.main, 0.62)), Se(P.Switch, "infoDisabledColor", L(In, P.info.main, 0.62)), Se(P.Switch, "successDisabledColor", L(In, P.success.main, 0.62)), Se(P.Switch, "warningDisabledColor", L(In, P.warning.main, 0.62)), Se(P.TableCell, "border", L(In, L(cm, P.divider, 1), 0.88)), Se(P.Tooltip, "bg", L(cm, P.grey[700], 0.92));
    }
    if (P.mode === "dark") {
      Se(P.Alert, "errorColor", L(In, P.error.light, 0.6)), Se(P.Alert, "infoColor", L(In, P.info.light, 0.6)), Se(P.Alert, "successColor", L(In, P.success.light, 0.6)), Se(P.Alert, "warningColor", L(In, P.warning.light, 0.6)), Se(P.Alert, "errorFilledBg", H("palette-error-dark")), Se(P.Alert, "infoFilledBg", H("palette-info-dark")), Se(P.Alert, "successFilledBg", H("palette-success-dark")), Se(P.Alert, "warningFilledBg", H("palette-warning-dark")), Se(P.Alert, "errorFilledColor", fl(() => P.getContrastText(P.error.dark))), Se(P.Alert, "infoFilledColor", fl(() => P.getContrastText(P.info.dark))), Se(P.Alert, "successFilledColor", fl(() => P.getContrastText(P.success.dark))), Se(P.Alert, "warningFilledColor", fl(() => P.getContrastText(P.warning.dark))), Se(P.Alert, "errorStandardBg", L(Dn, P.error.light, 0.9)), Se(P.Alert, "infoStandardBg", L(Dn, P.info.light, 0.9)), Se(P.Alert, "successStandardBg", L(Dn, P.success.light, 0.9)), Se(P.Alert, "warningStandardBg", L(Dn, P.warning.light, 0.9)), Se(P.Alert, "errorIconColor", H("palette-error-main")), Se(P.Alert, "infoIconColor", H("palette-info-main")), Se(P.Alert, "successIconColor", H("palette-success-main")), Se(P.Alert, "warningIconColor", H("palette-warning-main")), Se(P.AppBar, "defaultBg", H("palette-grey-900")), Se(P.AppBar, "darkBg", H("palette-background-paper")), Se(P.AppBar, "darkColor", H("palette-text-primary")), Se(P.Avatar, "defaultBg", H("palette-grey-600")), Se(P.Button, "inheritContainedBg", H("palette-grey-800")), Se(P.Button, "inheritContainedHoverBg", H("palette-grey-700")), Se(P.Chip, "defaultBorder", H("palette-grey-700")), Se(P.Chip, "defaultAvatarColor", H("palette-grey-300")), Se(P.Chip, "defaultIconColor", H("palette-grey-300")), Se(P.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"), Se(P.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"), Se(P.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"), Se(P.LinearProgress, "primaryBg", L(Dn, P.primary.main, 0.5)), Se(P.LinearProgress, "secondaryBg", L(Dn, P.secondary.main, 0.5)), Se(P.LinearProgress, "errorBg", L(Dn, P.error.main, 0.5)), Se(P.LinearProgress, "infoBg", L(Dn, P.info.main, 0.5)), Se(P.LinearProgress, "successBg", L(Dn, P.success.main, 0.5)), Se(P.LinearProgress, "warningBg", L(Dn, P.warning.main, 0.5)), Se(P.Skeleton, "bg", O ? L(cm, P.text.primary, 0.13) : `rgba(${H("palette-text-primaryChannel")} / 0.13)`), Se(P.Slider, "primaryTrack", L(Dn, P.primary.main, 0.5)), Se(P.Slider, "secondaryTrack", L(Dn, P.secondary.main, 0.5)), Se(P.Slider, "errorTrack", L(Dn, P.error.main, 0.5)), Se(P.Slider, "infoTrack", L(Dn, P.info.main, 0.5)), Se(P.Slider, "successTrack", L(Dn, P.success.main, 0.5)), Se(P.Slider, "warningTrack", L(Dn, P.warning.main, 0.5));
      const G = O ? L(In, P.background.default, 0.985) : Uk(P.background.default, 0.98);
      Se(P.SnackbarContent, "bg", G), Se(P.SnackbarContent, "color", fl(() => O ? j7.text.primary : P.getContrastText(G))), Se(P.SpeedDialAction, "fabHoverBg", Uk(P.background.paper, 0.15)), Se(P.StepConnector, "border", H("palette-grey-600")), Se(P.StepContent, "border", H("palette-grey-600")), Se(P.Switch, "defaultColor", H("palette-grey-300")), Se(P.Switch, "defaultDisabledColor", H("palette-grey-600")), Se(P.Switch, "primaryDisabledColor", L(Dn, P.primary.main, 0.55)), Se(P.Switch, "secondaryDisabledColor", L(Dn, P.secondary.main, 0.55)), Se(P.Switch, "errorDisabledColor", L(Dn, P.error.main, 0.55)), Se(P.Switch, "infoDisabledColor", L(Dn, P.info.main, 0.55)), Se(P.Switch, "successDisabledColor", L(Dn, P.success.main, 0.55)), Se(P.Switch, "warningDisabledColor", L(Dn, P.warning.main, 0.55)), Se(P.TableCell, "border", L(Dn, L(cm, P.divider, 1), 0.68)), Se(P.Tooltip, "bg", L(cm, P.grey[700], 0.92));
    }
    hc(P.background, "default"), hc(P.background, "paper"), hc(P.common, "background"), hc(P.common, "onBackground"), hc(P, "divider"), Object.keys(P).forEach((G) => {
      const $ = P[G];
      G !== "tonalOffset" && $ && typeof $ == "object" && ($.main && Se(P[G], "mainChannel", mx(hx($.main))), $.light && Se(P[G], "lightChannel", mx(hx($.light))), $.dark && Se(P[G], "darkChannel", mx(hx($.dark))), $.contrastText && Se(P[G], "contrastTextChannel", mx(hx($.contrastText))), G === "text" && (hc(P[G], "primary"), hc(P[G], "secondary")), G === "action" && ($.active && hc(P[G], "active"), $.selected && hc(P[G], "selected")));
    });
  }), A = t.reduce((B, P) => Qo(B, P), A);
  const R = {
    prefix: s,
    disableCssColorScheme: a,
    shouldSkipGeneratingVar: c,
    getSelector: Sre(A),
    enableContrastVars: l
  }, {
    vars: D,
    generateThemeVars: I,
    generateStyleSheets: z
  } = Rne(A, R);
  return A.vars = D, Object.entries(A.colorSchemes[A.defaultColorScheme]).forEach(([B, P]) => {
    A[B] = P;
  }), A.generateThemeVars = I, A.generateStyleSheets = z, A.generateSpacing = function() {
    return y7(m.spacing, UR(this));
  }, A.getColorSchemeSelector = jne(d), A.spacing = A.generateSpacing(), A.shouldSkipGeneratingVar = c, A.unstable_sxConfig = {
    ...WS,
    ...m?.unstable_sxConfig
  }, A.unstable_sx = function(B) {
    return Cd({
      sx: B,
      theme: this
    });
  }, A.toRuntimeSource = I7, A;
}
function zD(e, t, n) {
  e.colorSchemes && n && (e.colorSchemes[t] = {
    ...n !== !0 && n,
    palette: r4({
      ...n === !0 ? {} : n.palette,
      mode: t
    })
    // cast type to skip module augmentation test
  });
}
function kE(e = {}, ...t) {
  const {
    palette: n,
    cssVariables: r = !1,
    colorSchemes: a = n ? void 0 : {
      light: !0
    },
    defaultColorScheme: s = n?.mode,
    ...l
  } = e, c = s || "light", d = a?.[c], f = {
    ...a,
    ...n ? {
      [c]: {
        ...typeof d != "boolean" && d,
        palette: n
      }
    } : void 0
  };
  if (r === !1) {
    if (!("colorSchemes" in e))
      return $A(e, ...t);
    let m = n;
    "palette" in e || f[c] && (f[c] !== !0 ? m = f[c].palette : c === "dark" && (m = {
      mode: "dark"
    }));
    const h = $A({
      ...e,
      palette: m
    }, ...t);
    return h.defaultColorScheme = c, h.colorSchemes = f, h.palette.mode === "light" && (h.colorSchemes.light = {
      ...f.light !== !0 && f.light,
      palette: h.palette
    }, zD(h, "dark", f.dark)), h.palette.mode === "dark" && (h.colorSchemes.dark = {
      ...f.dark !== !0 && f.dark,
      palette: h.palette
    }, zD(h, "light", f.light)), h;
  }
  return !n && !("light" in f) && c === "light" && (f.light = !0), Cre({
    ...l,
    colorSchemes: f,
    defaultColorScheme: c,
    ...typeof r != "boolean" && r
  }, ...t);
}
const o4 = kE(), zl = "$$material";
function _E() {
  const e = XS(o4);
  return e[zl] || e;
}
function Ore(e) {
  return /* @__PURE__ */ C.jsx(b7, {
    ...e,
    defaultTheme: o4,
    themeId: zl
  });
}
function EE(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
const ea = (e) => EE(e) && e !== "classes", $e = k7({
  themeId: zl,
  defaultTheme: o4,
  rootShouldForwardProp: ea
});
function Mre(e) {
  return function(t) {
    return (
      // Pigment CSS `globalCss` support callback with theme inside an object but `GlobalStyles` support theme as a callback value.
      /* @__PURE__ */ C.jsx(Ore, {
        styles: typeof e == "function" ? (n) => e({
          theme: n,
          ...t
        }) : e
      })
    );
  };
}
function Nre() {
  return HR;
}
const Mt = bne;
function Dt(e) {
  return hne(e);
}
function Are(e) {
  return Ct("MuiTable", e);
}
St("MuiTable", ["root", "stickyHeader"]);
const Rre = (e) => {
  const {
    classes: t,
    stickyHeader: n
  } = e;
  return Et({
    root: ["root", n && "stickyHeader"]
  }, Are, t);
}, jre = $e("table", {
  name: "MuiTable",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.stickyHeader && t.stickyHeader];
  }
})(Mt(({
  theme: e
}) => ({
  display: "table",
  width: "100%",
  borderCollapse: "collapse",
  borderSpacing: 0,
  "& caption": {
    ...e.typography.body2,
    padding: e.spacing(2),
    color: (e.vars || e).palette.text.secondary,
    textAlign: "left",
    captionSide: "bottom"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.stickyHeader,
    style: {
      borderCollapse: "separate"
    }
  }]
}))), TD = "table", Pre = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiTable"
  }), {
    className: r,
    component: a = TD,
    padding: s = "normal",
    size: l = "medium",
    stickyHeader: c = !1,
    ...d
  } = n, f = {
    ...n,
    component: a,
    padding: s,
    size: l,
    stickyHeader: c
  }, m = Rre(f), h = M.useMemo(() => ({
    padding: s,
    size: l,
    stickyHeader: c
  }), [s, l, c]);
  return /* @__PURE__ */ C.jsx(Z8.Provider, {
    value: h,
    children: /* @__PURE__ */ C.jsx(jre, {
      as: a,
      role: a === TD ? null : "table",
      ref: t,
      className: Ye(m.root, r),
      ownerState: f,
      ...d
    })
  });
}), CE = /* @__PURE__ */ M.createContext();
function Dre(e) {
  return Ct("MuiTableBody", e);
}
St("MuiTableBody", ["root"]);
const Ire = (e) => {
  const {
    classes: t
  } = e;
  return Et({
    root: ["root"]
  }, Dre, t);
}, $re = $e("tbody", {
  name: "MuiTableBody",
  slot: "Root"
})({
  display: "table-row-group"
}), zre = {
  variant: "body"
}, LD = "tbody", Tre = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiTableBody"
  }), {
    className: r,
    component: a = LD,
    ...s
  } = n, l = {
    ...n,
    component: a
  }, c = Ire(l);
  return /* @__PURE__ */ C.jsx(CE.Provider, {
    value: zre,
    children: /* @__PURE__ */ C.jsx($re, {
      className: Ye(c.root, r),
      as: a,
      ref: t,
      role: a === LD ? null : "rowgroup",
      ownerState: l,
      ...s
    })
  });
});
function Lre(e) {
  return Ct("MuiTableCell", e);
}
const Fre = St("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]), Bre = (e) => {
  const {
    classes: t,
    variant: n,
    align: r,
    padding: a,
    size: s,
    stickyHeader: l
  } = e, c = {
    root: ["root", n, l && "stickyHeader", r !== "inherit" && `align${qe(r)}`, a !== "normal" && `padding${qe(a)}`, `size${qe(s)}`]
  };
  return Et(c, Lre, t);
}, Ure = $e("td", {
  name: "MuiTableCell",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], t[`size${qe(n.size)}`], n.padding !== "normal" && t[`padding${qe(n.padding)}`], n.align !== "inherit" && t[`align${qe(n.align)}`], n.stickyHeader && t.stickyHeader];
  }
})(Mt(({
  theme: e
}) => ({
  ...e.typography.body2,
  display: "table-cell",
  verticalAlign: "inherit",
  // Workaround for a rendering bug with spanned columns in Chrome 62.0.
  // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
  borderBottom: e.vars ? `1px solid ${e.vars.palette.TableCell.border}` : `1px solid
    ${e.palette.mode === "light" ? e.lighten(e.alpha(e.palette.divider, 1), 0.88) : e.darken(e.alpha(e.palette.divider, 1), 0.68)}`,
  textAlign: "left",
  padding: 16,
  variants: [{
    props: {
      variant: "head"
    },
    style: {
      color: (e.vars || e).palette.text.primary,
      lineHeight: e.typography.pxToRem(24),
      fontWeight: e.typography.fontWeightMedium
    }
  }, {
    props: {
      variant: "body"
    },
    style: {
      color: (e.vars || e).palette.text.primary
    }
  }, {
    props: {
      variant: "footer"
    },
    style: {
      color: (e.vars || e).palette.text.secondary,
      lineHeight: e.typography.pxToRem(21),
      fontSize: e.typography.pxToRem(12)
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      padding: "6px 16px",
      [`&.${Fre.paddingCheckbox}`]: {
        width: 24,
        // prevent the checkbox column from growing
        padding: "0 12px 0 16px",
        "& > *": {
          padding: 0
        }
      }
    }
  }, {
    props: {
      padding: "checkbox"
    },
    style: {
      width: 48,
      // prevent the checkbox column from growing
      padding: "0 0 0 4px"
    }
  }, {
    props: {
      padding: "none"
    },
    style: {
      padding: 0
    }
  }, {
    props: {
      align: "left"
    },
    style: {
      textAlign: "left"
    }
  }, {
    props: {
      align: "center"
    },
    style: {
      textAlign: "center"
    }
  }, {
    props: {
      align: "right"
    },
    style: {
      textAlign: "right",
      flexDirection: "row-reverse"
    }
  }, {
    props: {
      align: "justify"
    },
    style: {
      textAlign: "justify"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.stickyHeader,
    style: {
      position: "sticky",
      top: 0,
      zIndex: 2,
      backgroundColor: (e.vars || e).palette.background.default
    }
  }]
}))), Vk = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiTableCell"
  }), {
    align: r = "inherit",
    className: a,
    component: s,
    padding: l,
    scope: c,
    size: d,
    sortDirection: f,
    variant: m,
    ...h
  } = n, v = M.useContext(Z8), g = M.useContext(CE), b = g && g.variant === "head";
  let x;
  s ? x = s : x = b ? "th" : "td";
  let w = c;
  x === "td" ? w = void 0 : !w && b && (w = "col");
  const k = m || g && g.variant, E = {
    ...n,
    align: r,
    component: x,
    padding: l || (v && v.padding ? v.padding : "normal"),
    size: d || (v && v.size ? v.size : "medium"),
    sortDirection: f,
    stickyHeader: k === "head" && v && v.stickyHeader,
    variant: k
  }, _ = Bre(E);
  let O = null;
  return f && (O = f === "asc" ? "ascending" : "descending"), /* @__PURE__ */ C.jsx(Ure, {
    as: x,
    ref: t,
    className: Ye(_.root, a),
    "aria-sort": O,
    scope: w,
    ownerState: E,
    ...h
  });
});
function Vre(e) {
  return Ct("MuiTableContainer", e);
}
St("MuiTableContainer", ["root"]);
const Hre = (e) => {
  const {
    classes: t
  } = e;
  return Et({
    root: ["root"]
  }, Vre, t);
}, Wre = $e("div", {
  name: "MuiTableContainer",
  slot: "Root"
})({
  width: "100%",
  overflowX: "auto"
}), qre = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiTableContainer"
  }), {
    className: r,
    component: a = "div",
    ...s
  } = n, l = {
    ...n,
    component: a
  }, c = Hre(l);
  return /* @__PURE__ */ C.jsx(Wre, {
    ref: t,
    as: a,
    className: Ye(c.root, r),
    ownerState: l,
    ...s
  });
});
function Gre(e) {
  return Ct("MuiTableHead", e);
}
St("MuiTableHead", ["root"]);
const Kre = (e) => {
  const {
    classes: t
  } = e;
  return Et({
    root: ["root"]
  }, Gre, t);
}, Yre = $e("thead", {
  name: "MuiTableHead",
  slot: "Root"
})({
  display: "table-header-group"
}), Xre = {
  variant: "head"
}, FD = "thead", Jre = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiTableHead"
  }), {
    className: r,
    component: a = FD,
    ...s
  } = n, l = {
    ...n,
    component: a
  }, c = Kre(l);
  return /* @__PURE__ */ C.jsx(CE.Provider, {
    value: Xre,
    children: /* @__PURE__ */ C.jsx(Yre, {
      as: a,
      className: Ye(c.root, r),
      ref: t,
      role: a === FD ? null : "rowgroup",
      ownerState: l,
      ...s
    })
  });
});
function Qre(e) {
  return Ct("MuiTableRow", e);
}
const BD = St("MuiTableRow", ["root", "selected", "hover", "head", "footer"]), Zre = (e) => {
  const {
    classes: t,
    selected: n,
    hover: r,
    head: a,
    footer: s
  } = e;
  return Et({
    root: ["root", n && "selected", r && "hover", a && "head", s && "footer"]
  }, Qre, t);
}, eoe = $e("tr", {
  name: "MuiTableRow",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.head && t.head, n.footer && t.footer];
  }
})(Mt(({
  theme: e
}) => ({
  color: "inherit",
  display: "table-row",
  verticalAlign: "middle",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  [`&.${BD.hover}:hover`]: {
    backgroundColor: (e.vars || e).palette.action.hover
  },
  [`&.${BD.selected}`]: {
    backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.hoverOpacity}`)
    }
  }
}))), UD = "tr", Hk = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiTableRow"
  }), {
    className: r,
    component: a = UD,
    hover: s = !1,
    selected: l = !1,
    ...c
  } = n, d = M.useContext(CE), f = {
    ...n,
    component: a,
    hover: s,
    selected: l,
    head: d && d.variant === "head",
    footer: d && d.variant === "footer"
  }, m = Zre(f);
  return /* @__PURE__ */ C.jsx(eoe, {
    as: a,
    ref: t,
    className: Ye(m.root, r),
    role: a === UD ? null : "row",
    ownerState: f,
    ...c
  });
});
Xh.oneOfType([Xh.func, Xh.object]);
function a4(e, t) {
  return () => null;
}
a4(Xh.elementType);
function a2(e) {
  try {
    return e.matches(":focus-visible");
  } catch {
  }
  return !1;
}
function io(...e) {
  const t = M.useRef(void 0), n = M.useCallback((r) => {
    const a = e.map((s) => {
      if (s == null)
        return null;
      if (typeof s == "function") {
        const l = s, c = l(r);
        return typeof c == "function" ? c : () => {
          l(null);
        };
      }
      return s.current = r, () => {
        s.current = null;
      };
    });
    return () => {
      a.forEach((s) => s?.());
    };
  }, e);
  return M.useMemo(() => e.every((r) => r == null) ? null : (r) => {
    t.current && (t.current(), t.current = void 0), r != null && (t.current = n(r));
  }, e);
}
function Tl(e) {
  const t = M.useRef(e);
  return Zs(() => {
    t.current = e;
  }), M.useRef((...n) => (
    // @ts-expect-error hide `this`
    (0, t.current)(...n)
  )).current;
}
const VD = {};
function T7(e, t) {
  const n = M.useRef(VD);
  return n.current === VD && (n.current = e(t)), n;
}
class i2 {
  constructor() {
    no(this, "mountEffect", () => {
      this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0, this.mounted.resolve());
    });
    this.ref = {
      current: null
    }, this.mounted = null, this.didMount = !1, this.shouldMount = !1, this.setShouldMount = null;
  }
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new i2();
  }
  static use() {
    const t = T7(i2.create).current, [n, r] = M.useState(!1);
    return t.shouldMount = n, t.setShouldMount = r, M.useEffect(t.mountEffect, [n]), t;
  }
  mount() {
    return this.mounted || (this.mounted = noe(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted;
  }
  /* Ripple API */
  start(...t) {
    this.mount().then(() => this.ref.current?.start(...t));
  }
  stop(...t) {
    this.mount().then(() => this.ref.current?.stop(...t));
  }
  pulsate(...t) {
    this.mount().then(() => this.ref.current?.pulsate(...t));
  }
}
function toe() {
  return i2.use();
}
function noe() {
  let e, t;
  const n = new Promise((r, a) => {
    e = r, t = a;
  });
  return n.resolve = e, n.reject = t, n;
}
function OE(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function s2(e, t) {
  return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, s2(e, t);
}
function i4(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, s2(e, t);
}
const HD = {
  disabled: !1
}, l2 = jt.createContext(null);
var roe = function(e) {
  return e.scrollTop;
}, gx = "unmounted", ym = "exited", bm = "entering", zh = "entered", TA = "exiting", Gl = /* @__PURE__ */ (function(e) {
  i4(t, e);
  function t(r, a) {
    var s;
    s = e.call(this, r, a) || this;
    var l = a, c = l && !l.isMounting ? r.enter : r.appear, d;
    return s.appearStatus = null, r.in ? c ? (d = ym, s.appearStatus = bm) : d = zh : r.unmountOnExit || r.mountOnEnter ? d = gx : d = ym, s.state = {
      status: d
    }, s.nextCallback = null, s;
  }
  t.getDerivedStateFromProps = function(r, a) {
    var s = r.in;
    return s && a.status === gx ? {
      status: ym
    } : null;
  };
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, n.componentDidUpdate = function(r) {
    var a = null;
    if (r !== this.props) {
      var s = this.state.status;
      this.props.in ? s !== bm && s !== zh && (a = bm) : (s === bm || s === zh) && (a = TA);
    }
    this.updateStatus(!1, a);
  }, n.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, n.getTimeouts = function() {
    var r = this.props.timeout, a, s, l;
    return a = s = l = r, r != null && typeof r != "number" && (a = r.exit, s = r.enter, l = r.appear !== void 0 ? r.appear : s), {
      exit: a,
      enter: s,
      appear: l
    };
  }, n.updateStatus = function(r, a) {
    if (r === void 0 && (r = !1), a !== null)
      if (this.cancelNextCallback(), a === bm) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var s = this.props.nodeRef ? this.props.nodeRef.current : Bh.findDOMNode(this);
          s && roe(s);
        }
        this.performEnter(r);
      } else
        this.performExit();
    else this.props.unmountOnExit && this.state.status === ym && this.setState({
      status: gx
    });
  }, n.performEnter = function(r) {
    var a = this, s = this.props.enter, l = this.context ? this.context.isMounting : r, c = this.props.nodeRef ? [l] : [Bh.findDOMNode(this), l], d = c[0], f = c[1], m = this.getTimeouts(), h = l ? m.appear : m.enter;
    if (!r && !s || HD.disabled) {
      this.safeSetState({
        status: zh
      }, function() {
        a.props.onEntered(d);
      });
      return;
    }
    this.props.onEnter(d, f), this.safeSetState({
      status: bm
    }, function() {
      a.props.onEntering(d, f), a.onTransitionEnd(h, function() {
        a.safeSetState({
          status: zh
        }, function() {
          a.props.onEntered(d, f);
        });
      });
    });
  }, n.performExit = function() {
    var r = this, a = this.props.exit, s = this.getTimeouts(), l = this.props.nodeRef ? void 0 : Bh.findDOMNode(this);
    if (!a || HD.disabled) {
      this.safeSetState({
        status: ym
      }, function() {
        r.props.onExited(l);
      });
      return;
    }
    this.props.onExit(l), this.safeSetState({
      status: TA
    }, function() {
      r.props.onExiting(l), r.onTransitionEnd(s.exit, function() {
        r.safeSetState({
          status: ym
        }, function() {
          r.props.onExited(l);
        });
      });
    });
  }, n.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, n.safeSetState = function(r, a) {
    a = this.setNextCallback(a), this.setState(r, a);
  }, n.setNextCallback = function(r) {
    var a = this, s = !0;
    return this.nextCallback = function(l) {
      s && (s = !1, a.nextCallback = null, r(l));
    }, this.nextCallback.cancel = function() {
      s = !1;
    }, this.nextCallback;
  }, n.onTransitionEnd = function(r, a) {
    this.setNextCallback(a);
    var s = this.props.nodeRef ? this.props.nodeRef.current : Bh.findDOMNode(this), l = r == null && !this.props.addEndListener;
    if (!s || l) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var c = this.props.nodeRef ? [this.nextCallback] : [s, this.nextCallback], d = c[0], f = c[1];
      this.props.addEndListener(d, f);
    }
    r != null && setTimeout(this.nextCallback, r);
  }, n.render = function() {
    var r = this.state.status;
    if (r === gx)
      return null;
    var a = this.props, s = a.children;
    a.in, a.mountOnEnter, a.unmountOnExit, a.appear, a.enter, a.exit, a.timeout, a.addEndListener, a.onEnter, a.onEntering, a.onEntered, a.onExit, a.onExiting, a.onExited, a.nodeRef;
    var l = OE(a, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ jt.createElement(l2.Provider, {
        value: null
      }, typeof s == "function" ? s(r, l) : jt.cloneElement(jt.Children.only(s), l))
    );
  }, t;
})(jt.Component);
Gl.contextType = l2;
Gl.propTypes = {};
function vh() {
}
Gl.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: vh,
  onEntering: vh,
  onEntered: vh,
  onExit: vh,
  onExiting: vh,
  onExited: vh
};
Gl.UNMOUNTED = gx;
Gl.EXITED = ym;
Gl.ENTERING = bm;
Gl.ENTERED = zh;
Gl.EXITING = TA;
function L7(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function s4(e, t) {
  var n = function(a) {
    return t && M.isValidElement(a) ? t(a) : a;
  }, r = /* @__PURE__ */ Object.create(null);
  return e && M.Children.map(e, function(a) {
    return a;
  }).forEach(function(a) {
    r[a.key] = n(a);
  }), r;
}
function ooe(e, t) {
  e = e || {}, t = t || {};
  function n(m) {
    return m in t ? t[m] : e[m];
  }
  var r = /* @__PURE__ */ Object.create(null), a = [];
  for (var s in e)
    s in t ? a.length && (r[s] = a, a = []) : a.push(s);
  var l, c = {};
  for (var d in t) {
    if (r[d])
      for (l = 0; l < r[d].length; l++) {
        var f = r[d][l];
        c[r[d][l]] = n(f);
      }
    c[d] = n(d);
  }
  for (l = 0; l < a.length; l++)
    c[a[l]] = n(a[l]);
  return c;
}
function Em(e, t, n) {
  return n[t] != null ? n[t] : e.props[t];
}
function aoe(e, t) {
  return s4(e.children, function(n) {
    return M.cloneElement(n, {
      onExited: t.bind(null, n),
      in: !0,
      appear: Em(n, "appear", e),
      enter: Em(n, "enter", e),
      exit: Em(n, "exit", e)
    });
  });
}
function ioe(e, t, n) {
  var r = s4(e.children), a = ooe(t, r);
  return Object.keys(a).forEach(function(s) {
    var l = a[s];
    if (M.isValidElement(l)) {
      var c = s in t, d = s in r, f = t[s], m = M.isValidElement(f) && !f.props.in;
      d && (!c || m) ? a[s] = M.cloneElement(l, {
        onExited: n.bind(null, l),
        in: !0,
        exit: Em(l, "exit", e),
        enter: Em(l, "enter", e)
      }) : !d && c && !m ? a[s] = M.cloneElement(l, {
        in: !1
      }) : d && c && M.isValidElement(f) && (a[s] = M.cloneElement(l, {
        onExited: n.bind(null, l),
        in: f.props.in,
        exit: Em(l, "exit", e),
        enter: Em(l, "enter", e)
      }));
    }
  }), a;
}
var soe = Object.values || function(e) {
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}, loe = {
  component: "div",
  childFactory: function(e) {
    return e;
  }
}, l4 = /* @__PURE__ */ (function(e) {
  i4(t, e);
  function t(r, a) {
    var s;
    s = e.call(this, r, a) || this;
    var l = s.handleExited.bind(L7(s));
    return s.state = {
      contextValue: {
        isMounting: !0
      },
      handleExited: l,
      firstRender: !0
    }, s;
  }
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.mounted = !0, this.setState({
      contextValue: {
        isMounting: !1
      }
    });
  }, n.componentWillUnmount = function() {
    this.mounted = !1;
  }, t.getDerivedStateFromProps = function(r, a) {
    var s = a.children, l = a.handleExited, c = a.firstRender;
    return {
      children: c ? aoe(r, l) : ioe(r, s, l),
      firstRender: !1
    };
  }, n.handleExited = function(r, a) {
    var s = s4(this.props.children);
    r.key in s || (r.props.onExited && r.props.onExited(a), this.mounted && this.setState(function(l) {
      var c = mt({}, l.children);
      return delete c[r.key], {
        children: c
      };
    }));
  }, n.render = function() {
    var r = this.props, a = r.component, s = r.childFactory, l = OE(r, ["component", "childFactory"]), c = this.state.contextValue, d = soe(this.state.children).map(s);
    return delete l.appear, delete l.enter, delete l.exit, a === null ? /* @__PURE__ */ jt.createElement(l2.Provider, {
      value: c
    }, d) : /* @__PURE__ */ jt.createElement(l2.Provider, {
      value: c
    }, /* @__PURE__ */ jt.createElement(a, l, d));
  }, t;
})(jt.Component);
l4.propTypes = {};
l4.defaultProps = loe;
const uoe = [];
function coe(e) {
  M.useEffect(e, uoe);
}
class u4 {
  constructor() {
    no(this, "currentId", null);
    no(this, "clear", () => {
      this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);
    });
    no(this, "disposeEffect", () => this.clear);
  }
  static create() {
    return new u4();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(t, n) {
    this.clear(), this.currentId = setTimeout(() => {
      this.currentId = null, n();
    }, t);
  }
}
function F7() {
  const e = T7(u4.create).current;
  return coe(e.disposeEffect), e;
}
function doe(e) {
  const {
    className: t,
    classes: n,
    pulsate: r = !1,
    rippleX: a,
    rippleY: s,
    rippleSize: l,
    in: c,
    onExited: d,
    timeout: f
  } = e, [m, h] = M.useState(!1), v = Ye(t, n.ripple, n.rippleVisible, r && n.ripplePulsate), g = {
    width: l,
    height: l,
    top: -(l / 2) + s,
    left: -(l / 2) + a
  }, b = Ye(n.child, m && n.childLeaving, r && n.childPulsate);
  return !c && !m && h(!0), M.useEffect(() => {
    if (!c && d != null) {
      const x = setTimeout(d, f);
      return () => {
        clearTimeout(x);
      };
    }
  }, [d, c, f]), /* @__PURE__ */ C.jsx("span", {
    className: v,
    style: g,
    children: /* @__PURE__ */ C.jsx("span", {
      className: b
    })
  });
}
const zi = St("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), LA = 550, foe = 80, poe = $g`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`, moe = $g`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`, hoe = $g`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`, goe = $e("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
}), voe = $e(doe, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${zi.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${poe};
    animation-duration: ${LA}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  &.${zi.ripplePulsate} {
    animation-duration: ${({
  theme: e
}) => e.transitions.duration.shorter}ms;
  }

  & .${zi.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${zi.childLeaving} {
    opacity: 0;
    animation-name: ${moe};
    animation-duration: ${LA}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  & .${zi.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${hoe};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`, yoe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiTouchRipple"
  }), {
    center: r = !1,
    classes: a = {},
    className: s,
    ...l
  } = n, [c, d] = M.useState([]), f = M.useRef(0), m = M.useRef(null);
  M.useEffect(() => {
    m.current && (m.current(), m.current = null);
  }, [c]);
  const h = M.useRef(!1), v = F7(), g = M.useRef(null), b = M.useRef(null), x = M.useCallback((_) => {
    const {
      pulsate: O,
      rippleX: N,
      rippleY: A,
      rippleSize: R,
      cb: D
    } = _;
    d((I) => [...I, /* @__PURE__ */ C.jsx(voe, {
      classes: {
        ripple: Ye(a.ripple, zi.ripple),
        rippleVisible: Ye(a.rippleVisible, zi.rippleVisible),
        ripplePulsate: Ye(a.ripplePulsate, zi.ripplePulsate),
        child: Ye(a.child, zi.child),
        childLeaving: Ye(a.childLeaving, zi.childLeaving),
        childPulsate: Ye(a.childPulsate, zi.childPulsate)
      },
      timeout: LA,
      pulsate: O,
      rippleX: N,
      rippleY: A,
      rippleSize: R
    }, f.current)]), f.current += 1, m.current = D;
  }, [a]), w = M.useCallback((_ = {}, O = {}, N = () => {
  }) => {
    const {
      pulsate: A = !1,
      center: R = r || O.pulsate,
      fakeElement: D = !1
      // For test purposes
    } = O;
    if (_?.type === "mousedown" && h.current) {
      h.current = !1;
      return;
    }
    _?.type === "touchstart" && (h.current = !0);
    const I = D ? null : b.current, z = I ? I.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let B, P, H;
    if (R || _ === void 0 || _.clientX === 0 && _.clientY === 0 || !_.clientX && !_.touches)
      B = Math.round(z.width / 2), P = Math.round(z.height / 2);
    else {
      const {
        clientX: L,
        clientY: G
      } = _.touches && _.touches.length > 0 ? _.touches[0] : _;
      B = Math.round(L - z.left), P = Math.round(G - z.top);
    }
    if (R)
      H = Math.sqrt((2 * z.width ** 2 + z.height ** 2) / 3), H % 2 === 0 && (H += 1);
    else {
      const L = Math.max(Math.abs((I ? I.clientWidth : 0) - B), B) * 2 + 2, G = Math.max(Math.abs((I ? I.clientHeight : 0) - P), P) * 2 + 2;
      H = Math.sqrt(L ** 2 + G ** 2);
    }
    _?.touches ? g.current === null && (g.current = () => {
      x({
        pulsate: A,
        rippleX: B,
        rippleY: P,
        rippleSize: H,
        cb: N
      });
    }, v.start(foe, () => {
      g.current && (g.current(), g.current = null);
    })) : x({
      pulsate: A,
      rippleX: B,
      rippleY: P,
      rippleSize: H,
      cb: N
    });
  }, [r, x, v]), k = M.useCallback(() => {
    w({}, {
      pulsate: !0
    });
  }, [w]), E = M.useCallback((_, O) => {
    if (v.clear(), _?.type === "touchend" && g.current) {
      g.current(), g.current = null, v.start(0, () => {
        E(_, O);
      });
      return;
    }
    g.current = null, d((N) => N.length > 0 ? N.slice(1) : N), m.current = O;
  }, [v]);
  return M.useImperativeHandle(t, () => ({
    pulsate: k,
    start: w,
    stop: E
  }), [k, w, E]), /* @__PURE__ */ C.jsx(goe, {
    className: Ye(zi.root, a.root, s),
    ref: b,
    ...l,
    children: /* @__PURE__ */ C.jsx(l4, {
      component: null,
      exit: !0,
      children: c
    })
  });
});
function boe(e) {
  return Ct("MuiButtonBase", e);
}
const woe = St("MuiButtonBase", ["root", "disabled", "focusVisible"]), xoe = (e) => {
  const {
    disabled: t,
    focusVisible: n,
    focusVisibleClassName: r,
    classes: a
  } = e, s = Et({
    root: ["root", t && "disabled", n && "focusVisible"]
  }, boe, a);
  return n && r && (s.root += ` ${r}`), s;
}, Soe = $e("button", {
  name: "MuiButtonBase",
  slot: "Root"
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${woe.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
}), JS = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiButtonBase"
  }), {
    action: r,
    centerRipple: a = !1,
    children: s,
    className: l,
    component: c = "button",
    disabled: d = !1,
    disableRipple: f = !1,
    disableTouchRipple: m = !1,
    focusRipple: h = !1,
    focusVisibleClassName: v,
    LinkComponent: g = "a",
    onBlur: b,
    onClick: x,
    onContextMenu: w,
    onDragLeave: k,
    onFocus: E,
    onFocusVisible: _,
    onKeyDown: O,
    onKeyUp: N,
    onMouseDown: A,
    onMouseLeave: R,
    onMouseUp: D,
    onTouchEnd: I,
    onTouchMove: z,
    onTouchStart: B,
    tabIndex: P = 0,
    TouchRippleProps: H,
    touchRippleRef: L,
    type: G,
    ...$
  } = n, K = M.useRef(null), q = toe(), Z = io(q.ref, L), [V, F] = M.useState(!1);
  d && V && F(!1), M.useImperativeHandle(r, () => ({
    focusVisible: () => {
      F(!0), K.current.focus();
    }
  }), []);
  const Y = q.shouldMount && !f && !d;
  M.useEffect(() => {
    V && h && !f && q.pulsate();
  }, [f, h, V, q]);
  const U = gc(q, "start", A, m), W = gc(q, "stop", w, m), J = gc(q, "stop", k, m), oe = gc(q, "stop", D, m), fe = gc(q, "stop", (je) => {
    V && je.preventDefault(), R && R(je);
  }, m), ie = gc(q, "start", B, m), ce = gc(q, "stop", I, m), ge = gc(q, "stop", z, m), re = gc(q, "stop", (je) => {
    a2(je.target) || F(!1), b && b(je);
  }, !1), le = Tl((je) => {
    K.current || (K.current = je.currentTarget), a2(je.target) && (F(!0), _ && _(je)), E && E(je);
  }), me = () => {
    const je = K.current;
    return c && c !== "button" && !(je.tagName === "A" && je.href);
  }, ve = Tl((je) => {
    h && !je.repeat && V && je.key === " " && q.stop(je, () => {
      q.start(je);
    }), je.target === je.currentTarget && me() && je.key === " " && je.preventDefault(), O && O(je), je.target === je.currentTarget && me() && je.key === "Enter" && !d && (je.preventDefault(), x && x(je));
  }), xe = Tl((je) => {
    h && je.key === " " && V && !je.defaultPrevented && q.stop(je, () => {
      q.pulsate(je);
    }), N && N(je), x && je.target === je.currentTarget && me() && je.key === " " && !je.defaultPrevented && x(je);
  });
  let _e = c;
  _e === "button" && ($.href || $.to) && (_e = g);
  const Ge = {};
  if (_e === "button") {
    const je = !!$.formAction;
    Ge.type = G === void 0 && !je ? "button" : G, Ge.disabled = d;
  } else
    !$.href && !$.to && (Ge.role = "button"), d && (Ge["aria-disabled"] = d);
  const Xe = io(t, K), tt = {
    ...n,
    centerRipple: a,
    component: c,
    disabled: d,
    disableRipple: f,
    disableTouchRipple: m,
    focusRipple: h,
    tabIndex: P,
    focusVisible: V
  }, nt = xoe(tt);
  return /* @__PURE__ */ C.jsxs(Soe, {
    as: _e,
    className: Ye(nt.root, l),
    ownerState: tt,
    onBlur: re,
    onClick: x,
    onContextMenu: W,
    onFocus: le,
    onKeyDown: ve,
    onKeyUp: xe,
    onMouseDown: U,
    onMouseLeave: fe,
    onMouseUp: oe,
    onDragLeave: J,
    onTouchEnd: ce,
    onTouchMove: ge,
    onTouchStart: ie,
    ref: Xe,
    tabIndex: d ? -1 : P,
    type: G,
    ...Ge,
    ...$,
    children: [s, Y ? /* @__PURE__ */ C.jsx(yoe, {
      ref: Z,
      center: a,
      ...H
    }) : null]
  });
});
function gc(e, t, n, r = !1) {
  return Tl((a) => (n && n(a), r || e[t](a), !0));
}
function koe(e) {
  return Ct("MuiSvgIcon", e);
}
St("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const _oe = (e) => {
  const {
    color: t,
    fontSize: n,
    classes: r
  } = e, a = {
    root: ["root", t !== "inherit" && `color${qe(t)}`, `fontSize${qe(n)}`]
  };
  return Et(a, koe, r);
}, Eoe = $e("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color !== "inherit" && t[`color${qe(n.color)}`], t[`fontSize${qe(n.fontSize)}`]];
  }
})(Mt(({
  theme: e
}) => ({
  userSelect: "none",
  width: "1em",
  height: "1em",
  display: "inline-block",
  flexShrink: 0,
  transition: e.transitions?.create?.("fill", {
    duration: (e.vars ?? e).transitions?.duration?.shorter
  }),
  variants: [
    {
      props: (t) => !t.hasSvgAsChild,
      style: {
        // the <svg> will define the property that has `currentColor`
        // for example heroicons uses fill="none" and stroke="currentColor"
        fill: "currentColor"
      }
    },
    {
      props: {
        fontSize: "inherit"
      },
      style: {
        fontSize: "inherit"
      }
    },
    {
      props: {
        fontSize: "small"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(20) || "1.25rem"
      }
    },
    {
      props: {
        fontSize: "medium"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(24) || "1.5rem"
      }
    },
    {
      props: {
        fontSize: "large"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(35) || "2.1875rem"
      }
    },
    // TODO v5 deprecate color prop, v6 remove for sx
    ...Object.entries((e.vars ?? e).palette).filter(([, t]) => t && t.main).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (e.vars ?? e).palette?.[t]?.main
      }
    })),
    {
      props: {
        color: "action"
      },
      style: {
        color: (e.vars ?? e).palette?.action?.active
      }
    },
    {
      props: {
        color: "disabled"
      },
      style: {
        color: (e.vars ?? e).palette?.action?.disabled
      }
    },
    {
      props: {
        color: "inherit"
      },
      style: {
        color: void 0
      }
    }
  ]
}))), FA = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiSvgIcon"
  }), {
    children: r,
    className: a,
    color: s = "inherit",
    component: l = "svg",
    fontSize: c = "medium",
    htmlColor: d,
    inheritViewBox: f = !1,
    titleAccess: m,
    viewBox: h = "0 0 24 24",
    ...v
  } = n, g = /* @__PURE__ */ M.isValidElement(r) && r.type === "svg", b = {
    ...n,
    color: s,
    component: l,
    fontSize: c,
    instanceFontSize: e.fontSize,
    inheritViewBox: f,
    viewBox: h,
    hasSvgAsChild: g
  }, x = {};
  f || (x.viewBox = h);
  const w = _oe(b);
  return /* @__PURE__ */ C.jsxs(Eoe, {
    as: l,
    className: Ye(w.root, a),
    focusable: "false",
    color: d,
    "aria-hidden": m ? void 0 : !0,
    role: m ? "img" : void 0,
    ref: t,
    ...x,
    ...v,
    ...g && r.props,
    ownerState: b,
    children: [g ? r.props.children : r, m ? /* @__PURE__ */ C.jsx("title", {
      children: m
    }) : null]
  });
});
FA.muiName = "SvgIcon";
function Ni(e, t) {
  function n(r, a) {
    return /* @__PURE__ */ C.jsx(FA, {
      "data-testid": void 0,
      ref: a,
      ...r,
      children: e
    });
  }
  return n.muiName = FA.muiName, /* @__PURE__ */ M.memo(/* @__PURE__ */ M.forwardRef(n));
}
const Coe = Ni(/* @__PURE__ */ C.jsx("path", {
  d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
}));
function Ooe(e) {
  return Ct("MuiTableSortLabel", e);
}
const EN = St("MuiTableSortLabel", ["root", "active", "icon", "iconDirectionDesc", "iconDirectionAsc", "directionDesc", "directionAsc"]);
function Ll(e) {
  return typeof e == "string";
}
function B7(e, t, n) {
  return e === void 0 || Ll(e) ? t : {
    ...t,
    ownerState: {
      ...t.ownerState,
      ...n
    }
  };
}
function U7(e, t, n) {
  return typeof e == "function" ? e(t, n) : e;
}
function Rx(e, t = []) {
  if (e === void 0)
    return {};
  const n = {};
  return Object.keys(e).filter((r) => r.match(/^on[A-Z]/) && typeof e[r] == "function" && !t.includes(r)).forEach((r) => {
    n[r] = e[r];
  }), n;
}
function WD(e) {
  if (e === void 0)
    return {};
  const t = {};
  return Object.keys(e).filter((n) => !(n.match(/^on[A-Z]/) && typeof e[n] == "function")).forEach((n) => {
    t[n] = e[n];
  }), t;
}
function V7(e) {
  const {
    getSlotProps: t,
    additionalProps: n,
    externalSlotProps: r,
    externalForwardedProps: a,
    className: s
  } = e;
  if (!t) {
    const g = Ye(n?.className, s, a?.className, r?.className), b = {
      ...n?.style,
      ...a?.style,
      ...r?.style
    }, x = {
      ...n,
      ...a,
      ...r
    };
    return g.length > 0 && (x.className = g), Object.keys(b).length > 0 && (x.style = b), {
      props: x,
      internalRef: void 0
    };
  }
  const l = Rx({
    ...a,
    ...r
  }), c = WD(r), d = WD(a), f = t(l), m = Ye(f?.className, n?.className, s, a?.className, r?.className), h = {
    ...f?.style,
    ...n?.style,
    ...a?.style,
    ...r?.style
  }, v = {
    ...f,
    ...n,
    ...d,
    ...c
  };
  return m.length > 0 && (v.className = m), Object.keys(h).length > 0 && (v.style = h), {
    props: v,
    internalRef: f.ref
  };
}
function Kn(e, t) {
  const {
    className: n,
    elementType: r,
    ownerState: a,
    externalForwardedProps: s,
    internalForwardedProps: l,
    shouldForwardComponentProp: c = !1,
    ...d
  } = t, {
    component: f,
    slots: m = {
      [e]: void 0
    },
    slotProps: h = {
      [e]: void 0
    },
    ...v
  } = s, g = m[e] || r, b = U7(h[e], a), {
    props: {
      component: x,
      ...w
    },
    internalRef: k
  } = V7({
    className: n,
    ...d,
    externalForwardedProps: e === "root" ? v : void 0,
    externalSlotProps: b
  }), E = io(k, b?.ref, t.ref), _ = e === "root" ? x || f : x, O = B7(g, {
    ...e === "root" && !f && !m[e] && l,
    ...e !== "root" && !m[e] && l,
    ...w,
    ..._ && !c && {
      as: _
    },
    ..._ && c && {
      component: _
    },
    ref: E
  }, a);
  return [g, O];
}
const Moe = (e) => {
  const {
    classes: t,
    direction: n,
    active: r
  } = e, a = {
    root: ["root", r && "active", `direction${qe(n)}`],
    icon: ["icon", `iconDirection${qe(n)}`]
  };
  return Et(a, Ooe, t);
}, Noe = $e(JS, {
  name: "MuiTableSortLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.active && t.active];
  }
})(Mt(({
  theme: e
}) => ({
  cursor: "pointer",
  display: "inline-flex",
  justifyContent: "flex-start",
  flexDirection: "inherit",
  alignItems: "center",
  "&:focus": {
    color: (e.vars || e).palette.text.secondary
  },
  "&:hover": {
    color: (e.vars || e).palette.text.secondary,
    [`& .${EN.icon}`]: {
      opacity: 0.5
    }
  },
  [`&.${EN.active}`]: {
    color: (e.vars || e).palette.text.primary,
    [`& .${EN.icon}`]: {
      opacity: 1,
      color: (e.vars || e).palette.text.secondary
    }
  }
}))), Aoe = $e("span", {
  name: "MuiTableSortLabel",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, t[`iconDirection${qe(n.direction)}`]];
  }
})(Mt(({
  theme: e
}) => ({
  fontSize: 18,
  marginRight: 4,
  marginLeft: 4,
  opacity: 0,
  transition: e.transitions.create(["opacity", "transform"], {
    duration: e.transitions.duration.shorter
  }),
  userSelect: "none",
  variants: [{
    props: {
      direction: "desc"
    },
    style: {
      transform: "rotate(0deg)"
    }
  }, {
    props: {
      direction: "asc"
    },
    style: {
      transform: "rotate(180deg)"
    }
  }]
}))), Roe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiTableSortLabel"
  }), {
    active: r = !1,
    children: a,
    className: s,
    direction: l = "asc",
    hideSortIcon: c = !1,
    IconComponent: d = Coe,
    slots: f = {},
    slotProps: m = {},
    ...h
  } = n, v = {
    ...n,
    active: r,
    direction: l,
    hideSortIcon: c,
    IconComponent: d
  }, g = Moe(v), b = {
    slots: f,
    slotProps: m
  }, [x, w] = Kn("root", {
    elementType: Noe,
    externalForwardedProps: b,
    ownerState: v,
    className: Ye(g.root, s),
    ref: t
  }), [k, E] = Kn("icon", {
    elementType: Aoe,
    externalForwardedProps: b,
    ownerState: v,
    className: g.icon
  });
  return /* @__PURE__ */ C.jsxs(x, {
    disableRipple: !0,
    component: "span",
    ...w,
    ...h,
    children: [a, c && !r ? null : /* @__PURE__ */ C.jsx(k, {
      as: d,
      ...E
    })]
  });
}), joe = (e) => {
  const t = [];
  if (e === void 0)
    return {
      header: [],
      rows: []
    };
  e.data === void 0 && (e.data = []), (e.columns === void 0 || e.columns.length === 0) && (e.data.length === 0 ? e.columns = [] : e.columns = e.data[0].map((r, a) => `col${a}`)), (e.index === void 0 || e.index.length === 0) && (e.index = e.data.map((r, a) => `row${a}`));
  const n = Math.max(e.index.length, e.data.length);
  for (let r = 0; r < n; r++) {
    const a = [r < e.index.length ? e.index[r] : `row${r}`];
    for (let s = 0; s < e.columns.length; s++)
      a.push(e.data[r] ? e.data[r][s] : void 0);
    t.push(a);
  }
  return {
    header: ["index", ...e.columns],
    rows: t
  };
}, Poe = (e, t) => e === "desc" ? (n, r) => r[t] < n[t] ? -1 : r[t] > n[t] ? 1 : 0 : (n, r) => n[t] < r[t] ? -1 : n[t] > r[t] ? 1 : 0, BA = (e, t) => {
  const n = e.map((r, a) => [
    r,
    a
  ]);
  return n.sort((r, a) => t(r[0], a[0])), n.map((r) => r[0]);
}, Doe = (e, t, n = 1e3) => {
  if (e.length <= n)
    return BA(e, t);
  const r = [];
  for (let s = 0; s < e.length; s += n)
    r.push(e.slice(s, s + n));
  const a = r.map((s) => BA(s, t));
  return Ioe(a, t);
}, Ioe = (e, t) => {
  if (e.length === 1) return e[0];
  const n = [], r = new Array(e.length).fill(0);
  for (; r.some((a, s) => a < e[s].length); ) {
    let a = -1, s = null;
    for (let l = 0; l < e.length; l++)
      if (r[l] < e[l].length) {
        const c = e[l][r[l]];
        (s === null || t(c, s) < 0) && (s = c, a = l);
      }
    a !== -1 && s !== null && (n.push(s), r[a]++);
  }
  return n;
}, qD = (e, t, n) => {
  const r = Math.ceil(e / n);
  return {
    currentPage: r === 0 ? 1 : Math.min(Math.max(1, t), r),
    pageSize: n,
    totalPages: r,
    totalRows: e
  };
}, $oe = (e, t, n) => {
  const r = (t - 1) * n, a = r + n;
  return e.slice(r, a);
}, zoe = (e, t, n, r, a = 5) => {
  const s = Math.max(0, Math.floor(e / n) - a), l = Math.min(
    r - 1,
    Math.ceil((e + t) / n) + a
  );
  return { startIndex: s, endIndex: l };
}, Toe = (e, t) => {
  let n;
  return (...r) => {
    clearTimeout(n), n = setTimeout(() => e(...r), t);
  };
}, H7 = ({
  tabledata: e,
  className: t = "",
  size: n = "small",
  onSortChange: r,
  enablePagination: a = void 0,
  pageSize: s = 50,
  enableVirtualScrolling: l = void 0,
  virtualScrollingHeight: c = 400,
  enableLazyLoading: d = void 0,
  onLoadMore: f
}) => {
  e || (e = {
    columns: [],
    index: [],
    data: []
  });
  const m = e.index.length;
  m > 1e4 && (d = d === void 0 ? !0 : d), m > 1e3 && (l = l === void 0 ? !0 : l), m > 2 * s && (a = a === void 0 ? !0 : a), d = d === void 0 ? !1 : d, l = l === void 0 ? !1 : l, a = a === void 0 ? !1 : a;
  const h = M.useMemo(
    () => joe(e),
    [e]
  ), [v, g] = M.useState("asc"), [b, x] = M.useState("index"), [w, k] = M.useState(
    () => qD(h.rows.length, 1, s)
  ), [E, _] = M.useState(0), O = M.useRef(null), N = M.useMemo(() => {
    const q = h.header.indexOf(b);
    return q === -1 ? 0 : q;
  }, [h.header, b]), A = M.useMemo(
    () => Toe((q, Z) => {
      g(Z), x(q), r?.(q, Z);
    }, 150),
    [r]
  ), R = M.useCallback(
    (q) => {
      const Z = b === q && v === "asc" ? "desc" : "asc";
      h.rows.length > 1e3 ? A(q, Z) : (g(Z), x(q), r?.(q, Z));
    },
    [
      b,
      v,
      r,
      h.rows.length,
      A
    ]
  ), D = M.useMemo(
    () => Poe(v, N),
    [v, N]
  ), I = M.useMemo(() => h.rows.length > 1e3 ? Doe(h.rows, D) : BA(h.rows, D), [h.rows, D]), z = M.useMemo(() => a ? $oe(I, w.currentPage, w.pageSize) : I, [
    I,
    a,
    w.currentPage,
    w.pageSize
  ]), B = {
    itemHeight: 48,
    // Approximate row height
    overscan: 5,
    containerHeight: c
  }, P = M.useMemo(() => l ? zoe(
    E,
    B.containerHeight,
    B.itemHeight,
    z.length,
    B.overscan
  ) : { startIndex: 0, endIndex: z.length - 1 }, [
    E,
    l,
    z.length,
    B
  ]), H = M.useCallback(
    (q) => {
      l && _(q.currentTarget.scrollTop);
    },
    [l]
  ), L = M.useCallback((q) => {
    k((Z) => ({
      ...Z,
      currentPage: q
    }));
  }, []), G = M.useCallback(
    (q) => {
      if (!(!a || q.target.closest(".sortable-table-wrapper") !== q.currentTarget))
        switch (q.key) {
          case "ArrowLeft":
            w.currentPage > 1 && (q.preventDefault(), q.stopPropagation(), L(w.currentPage - 1));
            break;
          case "ArrowRight":
            w.currentPage < w.totalPages && (q.preventDefault(), q.stopPropagation(), L(w.currentPage + 1));
            break;
          case "Home":
            w.currentPage > 1 && (q.preventDefault(), q.stopPropagation(), L(1));
            break;
          case "End":
            w.currentPage < w.totalPages && (q.preventDefault(), q.stopPropagation(), L(w.totalPages));
            break;
        }
    },
    [
      a,
      w.currentPage,
      w.totalPages,
      L
    ]
  );
  M.useEffect(() => {
    a && k((q) => qD(
      I.length,
      q.currentPage,
      // Use previous current page instead of hardcoding 1
      s
    ));
  }, [I.length, a, s]), M.useEffect(() => {
    d && f && w.currentPage >= w.totalPages - 1 && f(w.currentPage + 1);
  }, [
    d,
    f,
    w.currentPage,
    w.totalPages
  ]);
  const $ = () => a ? /* @__PURE__ */ C.jsxs("div", { className: "sortable-table-pagination", children: [
    /* @__PURE__ */ C.jsx(
      "button",
      {
        onClick: () => L(w.currentPage - 1),
        disabled: w.currentPage <= 1,
        className: "pagination-button",
        children: "Previous"
      }
    ),
    /* @__PURE__ */ C.jsxs("span", { className: "pagination-info", children: [
      "Page ",
      w.currentPage,
      " of ",
      w.totalPages,
      "(",
      w.totalRows,
      " total rows)"
    ] }),
    /* @__PURE__ */ C.jsx(
      "button",
      {
        onClick: () => L(w.currentPage + 1),
        disabled: w.currentPage >= w.totalPages,
        className: "pagination-button",
        children: "Next"
      }
    )
  ] }) : null, K = () => {
    const q = l ? z.slice(
      P.startIndex,
      P.endIndex + 1
    ) : z;
    return /* @__PURE__ */ C.jsxs(Tre, { children: [
      l && /* @__PURE__ */ C.jsx(
        Hk,
        {
          style: {
            height: P.startIndex * B.itemHeight
          },
          children: /* @__PURE__ */ C.jsx(Vk, { colSpan: h.header.length })
        }
      ),
      q.map((Z, V) => {
        const F = l ? P.startIndex + V : V;
        return /* @__PURE__ */ C.jsx(Hk, { children: Z.map((Y, U) => /* @__PURE__ */ C.jsx(
          Vk,
          {
            className: U === 0 ? "sortable-table-index-cell" : "sortable-table-data-cell",
            children: Y
          },
          `${e.index?.[F] || F}-${U}`
        )) }, e.index?.[F] || F);
      }),
      l && /* @__PURE__ */ C.jsx(
        Hk,
        {
          style: {
            height: (z.length - P.endIndex - 1) * B.itemHeight
          },
          children: /* @__PURE__ */ C.jsx(Vk, { colSpan: h.header.length })
        }
      )
    ] });
  };
  return /* @__PURE__ */ C.jsxs(
    "div",
    {
      className: "sortable-table-wrapper",
      onKeyDown: G,
      tabIndex: a ? 0 : -1,
      role: a ? "application" : void 0,
      "aria-label": a ? "Sortable table with pagination" : void 0,
      children: [
        /* @__PURE__ */ C.jsx(
          qre,
          {
            className: `sortable-table-container ${t}`,
            ref: O,
            onScroll: H,
            style: l ? { height: c } : void 0,
            children: /* @__PURE__ */ C.jsxs(Pre, { size: n, children: [
              /* @__PURE__ */ C.jsx(Jre, { className: "sortable-table-head", children: /* @__PURE__ */ C.jsx(Hk, { className: "sortable-table-header-row", children: h.header.map((q) => /* @__PURE__ */ C.jsx(
                Vk,
                {
                  className: "sortable-table-header-cell",
                  "aria-label": `Sort by ${q}`,
                  children: /* @__PURE__ */ C.jsx(
                    Roe,
                    {
                      active: b === q,
                      direction: b === q ? v : "asc",
                      onClick: () => R(q),
                      className: "sortable-table-sort-label",
                      sx: {
                        "& .MuiTableSortLabel-icon": {
                          color: "inherit !important"
                        }
                      },
                      children: q
                    }
                  )
                },
                q
              )) }) }),
              K()
            ] })
          }
        ),
        $()
      ]
    }
  );
};
H7.displayName = "SortableTable";
function et(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(r) {
    if (e?.(r), n === !1 || !r.defaultPrevented)
      return t?.(r);
  };
}
function GD(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function ME(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((a) => {
      const s = GD(a, t);
      return !n && typeof s == "function" && (n = !0), s;
    });
    if (n)
      return () => {
        for (let a = 0; a < r.length; a++) {
          const s = r[a];
          typeof s == "function" ? s() : GD(e[a], null);
        }
      };
  };
}
function Xn(...e) {
  return M.useCallback(ME(...e), e);
}
function Loe(e, t) {
  const n = M.createContext(t), r = (s) => {
    const { children: l, ...c } = s, d = M.useMemo(() => c, Object.values(c));
    return /* @__PURE__ */ C.jsx(n.Provider, { value: d, children: l });
  };
  r.displayName = e + "Provider";
  function a(s) {
    const l = M.useContext(n);
    if (l) return l;
    if (t !== void 0) return t;
    throw new Error(`\`${s}\` must be used within \`${e}\``);
  }
  return [r, a];
}
function Kl(e, t = []) {
  let n = [];
  function r(s, l) {
    const c = M.createContext(l), d = n.length;
    n = [...n, l];
    const f = (h) => {
      const { scope: v, children: g, ...b } = h, x = v?.[e]?.[d] || c, w = M.useMemo(() => b, Object.values(b));
      return /* @__PURE__ */ C.jsx(x.Provider, { value: w, children: g });
    };
    f.displayName = s + "Provider";
    function m(h, v) {
      const g = v?.[e]?.[d] || c, b = M.useContext(g);
      if (b) return b;
      if (l !== void 0) return l;
      throw new Error(`\`${h}\` must be used within \`${s}\``);
    }
    return [f, m];
  }
  const a = () => {
    const s = n.map((l) => M.createContext(l));
    return function(l) {
      const c = l?.[e] || s;
      return M.useMemo(
        () => ({ [`__scope${e}`]: { ...l, [e]: c } }),
        [l, c]
      );
    };
  };
  return a.scopeName = e, [r, Foe(a, ...t)];
}
function Foe(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((a) => ({
      useScope: a(),
      scopeName: a.scopeName
    }));
    return function(a) {
      const s = r.reduce((l, { useScope: c, scopeName: d }) => {
        const f = c(a)[`__scope${d}`];
        return { ...l, ...f };
      }, {});
      return M.useMemo(() => ({ [`__scope${t.scopeName}`]: s }), [s]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
var zc = globalThis?.document ? M.useLayoutEffect : () => {
}, Boe = BS[" useId ".trim().toString()] || (() => {
}), Uoe = 0;
function Fl(e) {
  const [t, n] = M.useState(Boe());
  return zc(() => {
    n((r) => r ?? String(Uoe++));
  }, [e]), t ? `radix-${t}` : "";
}
var Voe = BS[" useInsertionEffect ".trim().toString()] || zc;
function Bd({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  },
  caller: r
}) {
  const [a, s, l] = Hoe({
    defaultProp: t,
    onChange: n
  }), c = e !== void 0, d = c ? e : a;
  {
    const m = M.useRef(e !== void 0);
    M.useEffect(() => {
      const h = m.current;
      h !== c && console.warn(
        `${r} is changing from ${h ? "controlled" : "uncontrolled"} to ${c ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), m.current = c;
    }, [c, r]);
  }
  const f = M.useCallback(
    (m) => {
      if (c) {
        const h = Woe(m) ? m(e) : m;
        h !== e && l.current?.(h);
      } else
        s(m);
    },
    [c, e, s, l]
  );
  return [d, f];
}
function Hoe({
  defaultProp: e,
  onChange: t
}) {
  const [n, r] = M.useState(e), a = M.useRef(n), s = M.useRef(t);
  return Voe(() => {
    s.current = t;
  }, [t]), M.useEffect(() => {
    a.current !== n && (s.current?.(n), a.current = n);
  }, [n, a]), [n, r, s];
}
function Woe(e) {
  return typeof e == "function";
}
// @__NO_SIDE_EFFECTS__
function pg(e) {
  const t = /* @__PURE__ */ qoe(e), n = M.forwardRef((r, a) => {
    const { children: s, ...l } = r, c = M.Children.toArray(s), d = c.find(Koe);
    if (d) {
      const f = d.props.children, m = c.map((h) => h === d ? M.Children.count(f) > 1 ? M.Children.only(null) : M.isValidElement(f) ? f.props.children : null : h);
      return /* @__PURE__ */ C.jsx(t, { ...l, ref: a, children: M.isValidElement(f) ? M.cloneElement(f, void 0, m) : null });
    }
    return /* @__PURE__ */ C.jsx(t, { ...l, ref: a, children: s });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function qoe(e) {
  const t = M.forwardRef((n, r) => {
    const { children: a, ...s } = n;
    if (M.isValidElement(a)) {
      const l = Xoe(a), c = Yoe(s, a.props);
      return a.type !== M.Fragment && (c.ref = r ? ME(r, l) : l), M.cloneElement(a, c);
    }
    return M.Children.count(a) > 1 ? M.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var Goe = /* @__PURE__ */ Symbol("radix.slottable");
function Koe(e) {
  return M.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === Goe;
}
function Yoe(e, t) {
  const n = { ...t };
  for (const r in t) {
    const a = e[r], s = t[r];
    /^on[A-Z]/.test(r) ? a && s ? n[r] = (...l) => {
      const c = s(...l);
      return a(...l), c;
    } : a && (n[r] = a) : r === "style" ? n[r] = { ...a, ...s } : r === "className" && (n[r] = [a, s].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function Xoe(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var Joe = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], Qt = Joe.reduce((e, t) => {
  const n = /* @__PURE__ */ pg(`Primitive.${t}`), r = M.forwardRef((a, s) => {
    const { asChild: l, ...c } = a, d = l ? n : t;
    return typeof window < "u" && (window[/* @__PURE__ */ Symbol.for("radix-ui")] = !0), /* @__PURE__ */ C.jsx(d, { ...c, ref: s });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function c4(e, t) {
  e && Xm.flushSync(() => e.dispatchEvent(t));
}
function $a(e) {
  const t = M.useRef(e);
  return M.useEffect(() => {
    t.current = e;
  }), M.useMemo(() => (...n) => t.current?.(...n), []);
}
function Qoe(e, t = globalThis?.document) {
  const n = $a(e);
  M.useEffect(() => {
    const r = (a) => {
      a.key === "Escape" && n(a);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var Zoe = "DismissableLayer", UA = "dismissableLayer.update", eae = "dismissableLayer.pointerDownOutside", tae = "dismissableLayer.focusOutside", KD, W7 = M.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), QS = M.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: a,
      onFocusOutside: s,
      onInteractOutside: l,
      onDismiss: c,
      ...d
    } = e, f = M.useContext(W7), [m, h] = M.useState(null), v = m?.ownerDocument ?? globalThis?.document, [, g] = M.useState({}), b = Xn(t, (R) => h(R)), x = Array.from(f.layers), [w] = [...f.layersWithOutsidePointerEventsDisabled].slice(-1), k = x.indexOf(w), E = m ? x.indexOf(m) : -1, _ = f.layersWithOutsidePointerEventsDisabled.size > 0, O = E >= k, N = rae((R) => {
      const D = R.target, I = [...f.branches].some((z) => z.contains(D));
      !O || I || (a?.(R), l?.(R), R.defaultPrevented || c?.());
    }, v), A = oae((R) => {
      const D = R.target;
      [...f.branches].some((I) => I.contains(D)) || (s?.(R), l?.(R), R.defaultPrevented || c?.());
    }, v);
    return Qoe((R) => {
      E === f.layers.size - 1 && (r?.(R), !R.defaultPrevented && c && (R.preventDefault(), c()));
    }, v), M.useEffect(() => {
      if (m)
        return n && (f.layersWithOutsidePointerEventsDisabled.size === 0 && (KD = v.body.style.pointerEvents, v.body.style.pointerEvents = "none"), f.layersWithOutsidePointerEventsDisabled.add(m)), f.layers.add(m), YD(), () => {
          n && f.layersWithOutsidePointerEventsDisabled.size === 1 && (v.body.style.pointerEvents = KD);
        };
    }, [m, v, n, f]), M.useEffect(() => () => {
      m && (f.layers.delete(m), f.layersWithOutsidePointerEventsDisabled.delete(m), YD());
    }, [m, f]), M.useEffect(() => {
      const R = () => g({});
      return document.addEventListener(UA, R), () => document.removeEventListener(UA, R);
    }, []), /* @__PURE__ */ C.jsx(
      Qt.div,
      {
        ...d,
        ref: b,
        style: {
          pointerEvents: _ ? O ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: et(e.onFocusCapture, A.onFocusCapture),
        onBlurCapture: et(e.onBlurCapture, A.onBlurCapture),
        onPointerDownCapture: et(
          e.onPointerDownCapture,
          N.onPointerDownCapture
        )
      }
    );
  }
);
QS.displayName = Zoe;
var nae = "DismissableLayerBranch", q7 = M.forwardRef((e, t) => {
  const n = M.useContext(W7), r = M.useRef(null), a = Xn(t, r);
  return M.useEffect(() => {
    const s = r.current;
    if (s)
      return n.branches.add(s), () => {
        n.branches.delete(s);
      };
  }, [n.branches]), /* @__PURE__ */ C.jsx(Qt.div, { ...e, ref: a });
});
q7.displayName = nae;
function rae(e, t = globalThis?.document) {
  const n = $a(e), r = M.useRef(!1), a = M.useRef(() => {
  });
  return M.useEffect(() => {
    const s = (c) => {
      if (c.target && !r.current) {
        let d = function() {
          G7(
            eae,
            n,
            f,
            { discrete: !0 }
          );
        };
        const f = { originalEvent: c };
        c.pointerType === "touch" ? (t.removeEventListener("click", a.current), a.current = d, t.addEventListener("click", a.current, { once: !0 })) : d();
      } else
        t.removeEventListener("click", a.current);
      r.current = !1;
    }, l = window.setTimeout(() => {
      t.addEventListener("pointerdown", s);
    }, 0);
    return () => {
      window.clearTimeout(l), t.removeEventListener("pointerdown", s), t.removeEventListener("click", a.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function oae(e, t = globalThis?.document) {
  const n = $a(e), r = M.useRef(!1);
  return M.useEffect(() => {
    const a = (s) => {
      s.target && !r.current && G7(tae, n, { originalEvent: s }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", a), () => t.removeEventListener("focusin", a);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function YD() {
  const e = new CustomEvent(UA);
  document.dispatchEvent(e);
}
function G7(e, t, n, { discrete: r }) {
  const a = n.originalEvent.target, s = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && a.addEventListener(e, t, { once: !0 }), r ? c4(a, s) : a.dispatchEvent(s);
}
var aae = QS, iae = q7, CN = "focusScope.autoFocusOnMount", ON = "focusScope.autoFocusOnUnmount", XD = { bubbles: !1, cancelable: !0 }, sae = "FocusScope", NE = M.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: a,
    onUnmountAutoFocus: s,
    ...l
  } = e, [c, d] = M.useState(null), f = $a(a), m = $a(s), h = M.useRef(null), v = Xn(t, (x) => d(x)), g = M.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  M.useEffect(() => {
    if (r) {
      let x = function(_) {
        if (g.paused || !c) return;
        const O = _.target;
        c.contains(O) ? h.current = O : cd(h.current, { select: !0 });
      }, w = function(_) {
        if (g.paused || !c) return;
        const O = _.relatedTarget;
        O !== null && (c.contains(O) || cd(h.current, { select: !0 }));
      }, k = function(_) {
        if (document.activeElement === document.body)
          for (const O of _)
            O.removedNodes.length > 0 && cd(c);
      };
      document.addEventListener("focusin", x), document.addEventListener("focusout", w);
      const E = new MutationObserver(k);
      return c && E.observe(c, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", x), document.removeEventListener("focusout", w), E.disconnect();
      };
    }
  }, [r, c, g.paused]), M.useEffect(() => {
    if (c) {
      QD.add(g);
      const x = document.activeElement;
      if (!c.contains(x)) {
        const w = new CustomEvent(CN, XD);
        c.addEventListener(CN, f), c.dispatchEvent(w), w.defaultPrevented || (lae(pae(K7(c)), { select: !0 }), document.activeElement === x && cd(c));
      }
      return () => {
        c.removeEventListener(CN, f), setTimeout(() => {
          const w = new CustomEvent(ON, XD);
          c.addEventListener(ON, m), c.dispatchEvent(w), w.defaultPrevented || cd(x ?? document.body, { select: !0 }), c.removeEventListener(ON, m), QD.remove(g);
        }, 0);
      };
    }
  }, [c, f, m, g]);
  const b = M.useCallback(
    (x) => {
      if (!n && !r || g.paused) return;
      const w = x.key === "Tab" && !x.altKey && !x.ctrlKey && !x.metaKey, k = document.activeElement;
      if (w && k) {
        const E = x.currentTarget, [_, O] = uae(E);
        _ && O ? !x.shiftKey && k === O ? (x.preventDefault(), n && cd(_, { select: !0 })) : x.shiftKey && k === _ && (x.preventDefault(), n && cd(O, { select: !0 })) : k === E && x.preventDefault();
      }
    },
    [n, r, g.paused]
  );
  return /* @__PURE__ */ C.jsx(Qt.div, { tabIndex: -1, ...l, ref: v, onKeyDown: b });
});
NE.displayName = sae;
function lae(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (cd(r, { select: t }), document.activeElement !== n) return;
}
function uae(e) {
  const t = K7(e), n = JD(t, e), r = JD(t.reverse(), e);
  return [n, r];
}
function K7(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const a = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || a ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function JD(e, t) {
  for (const n of e)
    if (!cae(n, { upTo: t })) return n;
}
function cae(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function dae(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function cd(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && dae(e) && t && e.select();
  }
}
var QD = fae();
function fae() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && n?.pause(), e = ZD(e, t), e.unshift(t);
    },
    remove(t) {
      e = ZD(e, t), e[0]?.resume();
    }
  };
}
function ZD(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function pae(e) {
  return e.filter((t) => t.tagName !== "A");
}
var mae = "Portal", AE = M.forwardRef((e, t) => {
  const { container: n, ...r } = e, [a, s] = M.useState(!1);
  zc(() => s(!0), []);
  const l = n || a && globalThis?.document?.body;
  return l ? Bh.createPortal(/* @__PURE__ */ C.jsx(Qt.div, { ...r, ref: t }), l) : null;
});
AE.displayName = mae;
function hae(e, t) {
  return M.useReducer((n, r) => t[n][r] ?? n, e);
}
var al = (e) => {
  const { present: t, children: n } = e, r = gae(t), a = typeof n == "function" ? n({ present: r.isPresent }) : M.Children.only(n), s = Xn(r.ref, vae(a));
  return typeof n == "function" || r.isPresent ? M.cloneElement(a, { ref: s }) : null;
};
al.displayName = "Presence";
function gae(e) {
  const [t, n] = M.useState(), r = M.useRef(null), a = M.useRef(e), s = M.useRef("none"), l = e ? "mounted" : "unmounted", [c, d] = hae(l, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return M.useEffect(() => {
    const f = Wk(r.current);
    s.current = c === "mounted" ? f : "none";
  }, [c]), zc(() => {
    const f = r.current, m = a.current;
    if (m !== e) {
      const h = s.current, v = Wk(f);
      e ? d("MOUNT") : v === "none" || f?.display === "none" ? d("UNMOUNT") : d(m && h !== v ? "ANIMATION_OUT" : "UNMOUNT"), a.current = e;
    }
  }, [e, d]), zc(() => {
    if (t) {
      let f;
      const m = t.ownerDocument.defaultView ?? window, h = (g) => {
        const b = Wk(r.current).includes(CSS.escape(g.animationName));
        if (g.target === t && b && (d("ANIMATION_END"), !a.current)) {
          const x = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", f = m.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = x);
          });
        }
      }, v = (g) => {
        g.target === t && (s.current = Wk(r.current));
      };
      return t.addEventListener("animationstart", v), t.addEventListener("animationcancel", h), t.addEventListener("animationend", h), () => {
        m.clearTimeout(f), t.removeEventListener("animationstart", v), t.removeEventListener("animationcancel", h), t.removeEventListener("animationend", h);
      };
    } else
      d("ANIMATION_END");
  }, [t, d]), {
    isPresent: ["mounted", "unmountSuspended"].includes(c),
    ref: M.useCallback((f) => {
      r.current = f ? getComputedStyle(f) : null, n(f);
    }, [])
  };
}
function Wk(e) {
  return e?.animationName || "none";
}
function vae(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var MN = 0;
function d4() {
  M.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? eI()), document.body.insertAdjacentElement("beforeend", e[1] ?? eI()), MN++, () => {
      MN === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), MN--;
    };
  }, []);
}
function eI() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var Cl = function() {
  return Cl = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var a in t) Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);
    }
    return e;
  }, Cl.apply(this, arguments);
};
function Y7(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, r = Object.getOwnPropertySymbols(e); a < r.length; a++)
      t.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[a]) && (n[r[a]] = e[r[a]]);
  return n;
}
function O_(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, a = t.length, s; r < a; r++)
    (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);
  return e.concat(s || Array.prototype.slice.call(t));
}
var M_ = "right-scroll-bar-position", N_ = "width-before-scroll-bar", yae = "with-scroll-bars-hidden", bae = "--removed-body-scroll-bar-size";
function NN(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function wae(e, t) {
  var n = M.useState(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var a = n.value;
          a !== r && (n.value = r, n.callback(r, a));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var xae = typeof window < "u" ? M.useLayoutEffect : M.useEffect, tI = /* @__PURE__ */ new WeakMap();
function Sae(e, t) {
  var n = wae(null, function(r) {
    return e.forEach(function(a) {
      return NN(a, r);
    });
  });
  return xae(function() {
    var r = tI.get(n);
    if (r) {
      var a = new Set(r), s = new Set(e), l = n.current;
      a.forEach(function(c) {
        s.has(c) || NN(c, null);
      }), s.forEach(function(c) {
        a.has(c) || NN(c, l);
      });
    }
    tI.set(n, e);
  }, [e]), n;
}
function kae(e) {
  return e;
}
function _ae(e, t) {
  t === void 0 && (t = kae);
  var n = [], r = !1, a = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(s) {
      var l = t(s, r);
      return n.push(l), function() {
        n = n.filter(function(c) {
          return c !== l;
        });
      };
    },
    assignSyncMedium: function(s) {
      for (r = !0; n.length; ) {
        var l = n;
        n = [], l.forEach(s);
      }
      n = {
        push: function(c) {
          return s(c);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(s) {
      r = !0;
      var l = [];
      if (n.length) {
        var c = n;
        n = [], c.forEach(s), l = n;
      }
      var d = function() {
        var m = l;
        l = [], m.forEach(s);
      }, f = function() {
        return Promise.resolve().then(d);
      };
      f(), n = {
        push: function(m) {
          l.push(m), f();
        },
        filter: function(m) {
          return l = l.filter(m), n;
        }
      };
    }
  };
  return a;
}
function Eae(e) {
  e === void 0 && (e = {});
  var t = _ae(null);
  return t.options = Cl({ async: !0, ssr: !1 }, e), t;
}
var X7 = function(e) {
  var t = e.sideCar, n = Y7(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return M.createElement(r, Cl({}, n));
};
X7.isSideCarExport = !0;
function Cae(e, t) {
  return e.useMedium(t), X7;
}
var J7 = Eae(), AN = function() {
}, RE = M.forwardRef(function(e, t) {
  var n = M.useRef(null), r = M.useState({
    onScrollCapture: AN,
    onWheelCapture: AN,
    onTouchMoveCapture: AN
  }), a = r[0], s = r[1], l = e.forwardProps, c = e.children, d = e.className, f = e.removeScrollBar, m = e.enabled, h = e.shards, v = e.sideCar, g = e.noRelative, b = e.noIsolation, x = e.inert, w = e.allowPinchZoom, k = e.as, E = k === void 0 ? "div" : k, _ = e.gapMode, O = Y7(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), N = v, A = Sae([n, t]), R = Cl(Cl({}, O), a);
  return M.createElement(
    M.Fragment,
    null,
    m && M.createElement(N, { sideCar: J7, removeScrollBar: f, shards: h, noRelative: g, noIsolation: b, inert: x, setCallbacks: s, allowPinchZoom: !!w, lockRef: n, gapMode: _ }),
    l ? M.cloneElement(M.Children.only(c), Cl(Cl({}, R), { ref: A })) : M.createElement(E, Cl({}, R, { className: d, ref: A }), c)
  );
});
RE.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
RE.classNames = {
  fullWidth: N_,
  zeroRight: M_
};
var Oae = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function Mae() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = Oae();
  return t && e.setAttribute("nonce", t), e;
}
function Nae(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function Aae(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var Rae = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = Mae()) && (Nae(t, n), Aae(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, jae = function() {
  var e = Rae();
  return function(t, n) {
    M.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, Q7 = function() {
  var e = jae(), t = function(n) {
    var r = n.styles, a = n.dynamic;
    return e(r, a), null;
  };
  return t;
}, Pae = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, RN = function(e) {
  return parseInt(e || "", 10) || 0;
}, Dae = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], a = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [RN(n), RN(r), RN(a)];
}, Iae = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return Pae;
  var t = Dae(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, $ae = Q7(), eg = "data-scroll-locked", zae = function(e, t, n, r) {
  var a = e.left, s = e.top, l = e.right, c = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(yae, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(c, "px ").concat(r, `;
  }
  body[`).concat(eg, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(a, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(l, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(c, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(c, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }

  .`).concat(M_, ` {
    right: `).concat(c, "px ").concat(r, `;
  }

  .`).concat(N_, ` {
    margin-right: `).concat(c, "px ").concat(r, `;
  }

  .`).concat(M_, " .").concat(M_, ` {
    right: 0 `).concat(r, `;
  }

  .`).concat(N_, " .").concat(N_, ` {
    margin-right: 0 `).concat(r, `;
  }

  body[`).concat(eg, `] {
    `).concat(bae, ": ").concat(c, `px;
  }
`);
}, nI = function() {
  var e = parseInt(document.body.getAttribute(eg) || "0", 10);
  return isFinite(e) ? e : 0;
}, Tae = function() {
  M.useEffect(function() {
    return document.body.setAttribute(eg, (nI() + 1).toString()), function() {
      var e = nI() - 1;
      e <= 0 ? document.body.removeAttribute(eg) : document.body.setAttribute(eg, e.toString());
    };
  }, []);
}, Lae = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, a = r === void 0 ? "margin" : r;
  Tae();
  var s = M.useMemo(function() {
    return Iae(a);
  }, [a]);
  return M.createElement($ae, { styles: zae(s, !t, a, n ? "" : "!important") });
}, VA = !1;
if (typeof window < "u")
  try {
    var qk = Object.defineProperty({}, "passive", {
      get: function() {
        return VA = !0, !0;
      }
    });
    window.addEventListener("test", qk, qk), window.removeEventListener("test", qk, qk);
  } catch {
    VA = !1;
  }
var yh = VA ? { passive: !1 } : !1, Fae = function(e) {
  return e.tagName === "TEXTAREA";
}, Z7 = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !Fae(e) && n[t] === "visible")
  );
}, Bae = function(e) {
  return Z7(e, "overflowY");
}, Uae = function(e) {
  return Z7(e, "overflowX");
}, rI = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var a = eB(e, r);
    if (a) {
      var s = tB(e, r), l = s[1], c = s[2];
      if (l > c)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, Vae = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, Hae = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, eB = function(e, t) {
  return e === "v" ? Bae(t) : Uae(t);
}, tB = function(e, t) {
  return e === "v" ? Vae(t) : Hae(t);
}, Wae = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, qae = function(e, t, n, r, a) {
  var s = Wae(e, window.getComputedStyle(t).direction), l = s * r, c = n.target, d = t.contains(c), f = !1, m = l > 0, h = 0, v = 0;
  do {
    if (!c)
      break;
    var g = tB(e, c), b = g[0], x = g[1], w = g[2], k = x - w - s * b;
    (b || k) && eB(e, c) && (h += k, v += b);
    var E = c.parentNode;
    c = E && E.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? E.host : E;
  } while (
    // portaled content
    !d && c !== document.body || // self content
    d && (t.contains(c) || t === c)
  );
  return (m && Math.abs(h) < 1 || !m && Math.abs(v) < 1) && (f = !0), f;
}, Gk = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, oI = function(e) {
  return [e.deltaX, e.deltaY];
}, aI = function(e) {
  return e && "current" in e ? e.current : e;
}, Gae = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, Kae = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, Yae = 0, bh = [];
function Xae(e) {
  var t = M.useRef([]), n = M.useRef([0, 0]), r = M.useRef(), a = M.useState(Yae++)[0], s = M.useState(Q7)[0], l = M.useRef(e);
  M.useEffect(function() {
    l.current = e;
  }, [e]), M.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(a));
      var x = O_([e.lockRef.current], (e.shards || []).map(aI), !0).filter(Boolean);
      return x.forEach(function(w) {
        return w.classList.add("allow-interactivity-".concat(a));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(a)), x.forEach(function(w) {
          return w.classList.remove("allow-interactivity-".concat(a));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var c = M.useCallback(function(x, w) {
    if ("touches" in x && x.touches.length === 2 || x.type === "wheel" && x.ctrlKey)
      return !l.current.allowPinchZoom;
    var k = Gk(x), E = n.current, _ = "deltaX" in x ? x.deltaX : E[0] - k[0], O = "deltaY" in x ? x.deltaY : E[1] - k[1], N, A = x.target, R = Math.abs(_) > Math.abs(O) ? "h" : "v";
    if ("touches" in x && R === "h" && A.type === "range")
      return !1;
    var D = rI(R, A);
    if (!D)
      return !0;
    if (D ? N = R : (N = R === "v" ? "h" : "v", D = rI(R, A)), !D)
      return !1;
    if (!r.current && "changedTouches" in x && (_ || O) && (r.current = N), !N)
      return !0;
    var I = r.current || N;
    return qae(I, w, x, I === "h" ? _ : O);
  }, []), d = M.useCallback(function(x) {
    var w = x;
    if (!(!bh.length || bh[bh.length - 1] !== s)) {
      var k = "deltaY" in w ? oI(w) : Gk(w), E = t.current.filter(function(N) {
        return N.name === w.type && (N.target === w.target || w.target === N.shadowParent) && Gae(N.delta, k);
      })[0];
      if (E && E.should) {
        w.cancelable && w.preventDefault();
        return;
      }
      if (!E) {
        var _ = (l.current.shards || []).map(aI).filter(Boolean).filter(function(N) {
          return N.contains(w.target);
        }), O = _.length > 0 ? c(w, _[0]) : !l.current.noIsolation;
        O && w.cancelable && w.preventDefault();
      }
    }
  }, []), f = M.useCallback(function(x, w, k, E) {
    var _ = { name: x, delta: w, target: k, should: E, shadowParent: Jae(k) };
    t.current.push(_), setTimeout(function() {
      t.current = t.current.filter(function(O) {
        return O !== _;
      });
    }, 1);
  }, []), m = M.useCallback(function(x) {
    n.current = Gk(x), r.current = void 0;
  }, []), h = M.useCallback(function(x) {
    f(x.type, oI(x), x.target, c(x, e.lockRef.current));
  }, []), v = M.useCallback(function(x) {
    f(x.type, Gk(x), x.target, c(x, e.lockRef.current));
  }, []);
  M.useEffect(function() {
    return bh.push(s), e.setCallbacks({
      onScrollCapture: h,
      onWheelCapture: h,
      onTouchMoveCapture: v
    }), document.addEventListener("wheel", d, yh), document.addEventListener("touchmove", d, yh), document.addEventListener("touchstart", m, yh), function() {
      bh = bh.filter(function(x) {
        return x !== s;
      }), document.removeEventListener("wheel", d, yh), document.removeEventListener("touchmove", d, yh), document.removeEventListener("touchstart", m, yh);
    };
  }, []);
  var g = e.removeScrollBar, b = e.inert;
  return M.createElement(
    M.Fragment,
    null,
    b ? M.createElement(s, { styles: Kae(a) }) : null,
    g ? M.createElement(Lae, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
  );
}
function Jae(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const Qae = Cae(J7, Xae);
var jE = M.forwardRef(function(e, t) {
  return M.createElement(RE, Cl({}, e, { ref: t, sideCar: Qae }));
});
jE.classNames = RE.classNames;
var Zae = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, wh = /* @__PURE__ */ new WeakMap(), Kk = /* @__PURE__ */ new WeakMap(), Yk = {}, jN = 0, nB = function(e) {
  return e && (e.host || nB(e.parentNode));
}, eie = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = nB(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, tie = function(e, t, n, r) {
  var a = eie(t, Array.isArray(e) ? e : [e]);
  Yk[n] || (Yk[n] = /* @__PURE__ */ new WeakMap());
  var s = Yk[n], l = [], c = /* @__PURE__ */ new Set(), d = new Set(a), f = function(h) {
    !h || c.has(h) || (c.add(h), f(h.parentNode));
  };
  a.forEach(f);
  var m = function(h) {
    !h || d.has(h) || Array.prototype.forEach.call(h.children, function(v) {
      if (c.has(v))
        m(v);
      else
        try {
          var g = v.getAttribute(r), b = g !== null && g !== "false", x = (wh.get(v) || 0) + 1, w = (s.get(v) || 0) + 1;
          wh.set(v, x), s.set(v, w), l.push(v), x === 1 && b && Kk.set(v, !0), w === 1 && v.setAttribute(n, "true"), b || v.setAttribute(r, "true");
        } catch (k) {
          console.error("aria-hidden: cannot operate on ", v, k);
        }
    });
  };
  return m(t), c.clear(), jN++, function() {
    l.forEach(function(h) {
      var v = wh.get(h) - 1, g = s.get(h) - 1;
      wh.set(h, v), s.set(h, g), v || (Kk.has(h) || h.removeAttribute(r), Kk.delete(h)), g || h.removeAttribute(n);
    }), jN--, jN || (wh = /* @__PURE__ */ new WeakMap(), wh = /* @__PURE__ */ new WeakMap(), Kk = /* @__PURE__ */ new WeakMap(), Yk = {});
  };
}, f4 = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), a = Zae(e);
  return a ? (r.push.apply(r, Array.from(a.querySelectorAll("[aria-live], script"))), tie(r, a, n, "aria-hidden")) : function() {
    return null;
  };
}, PE = "Dialog", [rB] = Kl(PE), [nie, il] = rB(PE), oB = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: a,
    onOpenChange: s,
    modal: l = !0
  } = e, c = M.useRef(null), d = M.useRef(null), [f, m] = Bd({
    prop: r,
    defaultProp: a ?? !1,
    onChange: s,
    caller: PE
  });
  return /* @__PURE__ */ C.jsx(
    nie,
    {
      scope: t,
      triggerRef: c,
      contentRef: d,
      contentId: Fl(),
      titleId: Fl(),
      descriptionId: Fl(),
      open: f,
      onOpenChange: m,
      onOpenToggle: M.useCallback(() => m((h) => !h), [m]),
      modal: l,
      children: n
    }
  );
};
oB.displayName = PE;
var aB = "DialogTrigger", iB = M.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, a = il(aB, n), s = Xn(t, a.triggerRef);
    return /* @__PURE__ */ C.jsx(
      Qt.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": a.open,
        "aria-controls": a.contentId,
        "data-state": h4(a.open),
        ...r,
        ref: s,
        onClick: et(e.onClick, a.onOpenToggle)
      }
    );
  }
);
iB.displayName = aB;
var p4 = "DialogPortal", [rie, sB] = rB(p4, {
  forceMount: void 0
}), lB = (e) => {
  const { __scopeDialog: t, forceMount: n, children: r, container: a } = e, s = il(p4, t);
  return /* @__PURE__ */ C.jsx(rie, { scope: t, forceMount: n, children: M.Children.map(r, (l) => /* @__PURE__ */ C.jsx(al, { present: n || s.open, children: /* @__PURE__ */ C.jsx(AE, { asChild: !0, container: a, children: l }) })) });
};
lB.displayName = p4;
var u2 = "DialogOverlay", uB = M.forwardRef(
  (e, t) => {
    const n = sB(u2, e.__scopeDialog), { forceMount: r = n.forceMount, ...a } = e, s = il(u2, e.__scopeDialog);
    return s.modal ? /* @__PURE__ */ C.jsx(al, { present: r || s.open, children: /* @__PURE__ */ C.jsx(aie, { ...a, ref: t }) }) : null;
  }
);
uB.displayName = u2;
var oie = /* @__PURE__ */ pg("DialogOverlay.RemoveScroll"), aie = M.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, a = il(u2, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ C.jsx(jE, { as: oie, allowPinchZoom: !0, shards: [a.contentRef], children: /* @__PURE__ */ C.jsx(
        Qt.div,
        {
          "data-state": h4(a.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), Pm = "DialogContent", cB = M.forwardRef(
  (e, t) => {
    const n = sB(Pm, e.__scopeDialog), { forceMount: r = n.forceMount, ...a } = e, s = il(Pm, e.__scopeDialog);
    return /* @__PURE__ */ C.jsx(al, { present: r || s.open, children: s.modal ? /* @__PURE__ */ C.jsx(iie, { ...a, ref: t }) : /* @__PURE__ */ C.jsx(sie, { ...a, ref: t }) });
  }
);
cB.displayName = Pm;
var iie = M.forwardRef(
  (e, t) => {
    const n = il(Pm, e.__scopeDialog), r = M.useRef(null), a = Xn(t, n.contentRef, r);
    return M.useEffect(() => {
      const s = r.current;
      if (s) return f4(s);
    }, []), /* @__PURE__ */ C.jsx(
      dB,
      {
        ...e,
        ref: a,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: et(e.onCloseAutoFocus, (s) => {
          s.preventDefault(), n.triggerRef.current?.focus();
        }),
        onPointerDownOutside: et(e.onPointerDownOutside, (s) => {
          const l = s.detail.originalEvent, c = l.button === 0 && l.ctrlKey === !0;
          (l.button === 2 || c) && s.preventDefault();
        }),
        onFocusOutside: et(
          e.onFocusOutside,
          (s) => s.preventDefault()
        )
      }
    );
  }
), sie = M.forwardRef(
  (e, t) => {
    const n = il(Pm, e.__scopeDialog), r = M.useRef(!1), a = M.useRef(!1);
    return /* @__PURE__ */ C.jsx(
      dB,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (s) => {
          e.onCloseAutoFocus?.(s), s.defaultPrevented || (r.current || n.triggerRef.current?.focus(), s.preventDefault()), r.current = !1, a.current = !1;
        },
        onInteractOutside: (s) => {
          e.onInteractOutside?.(s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (a.current = !0));
          const l = s.target;
          n.triggerRef.current?.contains(l) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && a.current && s.preventDefault();
        }
      }
    );
  }
), dB = M.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: a, onCloseAutoFocus: s, ...l } = e, c = il(Pm, n), d = M.useRef(null), f = Xn(t, d);
    return d4(), /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
      /* @__PURE__ */ C.jsx(
        NE,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: a,
          onUnmountAutoFocus: s,
          children: /* @__PURE__ */ C.jsx(
            QS,
            {
              role: "dialog",
              id: c.contentId,
              "aria-describedby": c.descriptionId,
              "aria-labelledby": c.titleId,
              "data-state": h4(c.open),
              ...l,
              ref: f,
              onDismiss: () => c.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
        /* @__PURE__ */ C.jsx(lie, { titleId: c.titleId }),
        /* @__PURE__ */ C.jsx(cie, { contentRef: d, descriptionId: c.descriptionId })
      ] })
    ] });
  }
), m4 = "DialogTitle", fB = M.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, a = il(m4, n);
    return /* @__PURE__ */ C.jsx(Qt.h2, { id: a.titleId, ...r, ref: t });
  }
);
fB.displayName = m4;
var pB = "DialogDescription", mB = M.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, a = il(pB, n);
    return /* @__PURE__ */ C.jsx(Qt.p, { id: a.descriptionId, ...r, ref: t });
  }
);
mB.displayName = pB;
var hB = "DialogClose", gB = M.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, a = il(hB, n);
    return /* @__PURE__ */ C.jsx(
      Qt.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: et(e.onClick, () => a.onOpenChange(!1))
      }
    );
  }
);
gB.displayName = hB;
function h4(e) {
  return e ? "open" : "closed";
}
var vB = "DialogTitleWarning", [WGe, yB] = Loe(vB, {
  contentName: Pm,
  titleName: m4,
  docsSlug: "dialog"
}), lie = ({ titleId: e }) => {
  const t = yB(vB), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return M.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, uie = "DialogDescriptionWarning", cie = ({ contentRef: e, descriptionId: t }) => {
  const n = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${yB(uie).contentName}}.`;
  return M.useEffect(() => {
    const r = e.current?.getAttribute("aria-describedby");
    t && r && (document.getElementById(t) || console.warn(n));
  }, [n, e, t]), null;
}, die = oB, fie = iB, pie = lB, mie = uB, hie = cB, gie = fB, vie = mB, bB = gB;
function HA(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function yie(e) {
  if (Array.isArray(e)) return e;
}
function bie(e) {
  if (Array.isArray(e)) return HA(e);
}
function wie(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function xie(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, wB(r.key), r);
  }
}
function Sie(e, t, n) {
  return t && xie(e.prototype, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function A_(e, t) {
  var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (!n) {
    if (Array.isArray(e) || (n = g4(e)) || t) {
      n && (e = n);
      var r = 0, a = function() {
      };
      return {
        s: a,
        n: function() {
          return r >= e.length ? {
            done: !0
          } : {
            done: !1,
            value: e[r++]
          };
        },
        e: function(d) {
          throw d;
        },
        f: a
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var s, l = !0, c = !1;
  return {
    s: function() {
      n = n.call(e);
    },
    n: function() {
      var d = n.next();
      return l = d.done, d;
    },
    e: function(d) {
      c = !0, s = d;
    },
    f: function() {
      try {
        l || n.return == null || n.return();
      } finally {
        if (c) throw s;
      }
    }
  };
}
function Ft(e, t, n) {
  return (t = wB(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function kie(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function _ie(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, a, s, l, c = [], d = !0, f = !1;
    try {
      if (s = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n) return;
        d = !1;
      } else for (; !(d = (r = s.call(n)).done) && (c.push(r.value), c.length !== t); d = !0) ;
    } catch (m) {
      f = !0, a = m;
    } finally {
      try {
        if (!d && n.return != null && (l = n.return(), Object(l) !== l)) return;
      } finally {
        if (f) throw a;
      }
    }
    return c;
  }
}
function Eie() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Cie() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function iI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function De(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iI(Object(n), !0).forEach(function(r) {
      Ft(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function DE(e, t) {
  return yie(e) || _ie(e, t) || g4(e, t) || Eie();
}
function el(e) {
  return bie(e) || kie(e) || g4(e) || Cie();
}
function Oie(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function wB(e) {
  var t = Oie(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function c2(e) {
  "@babel/helpers - typeof";
  return c2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, c2(e);
}
function g4(e, t) {
  if (e) {
    if (typeof e == "string") return HA(e, t);
    var n = {}.toString.call(e).slice(8, -1);
    return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? HA(e, t) : void 0;
  }
}
var sI = function() {
}, v4 = {}, xB = {}, SB = null, kB = {
  mark: sI,
  measure: sI
};
try {
  typeof window < "u" && (v4 = window), typeof document < "u" && (xB = document), typeof MutationObserver < "u" && (SB = MutationObserver), typeof performance < "u" && (kB = performance);
} catch {
}
var Mie = v4.navigator || {}, lI = Mie.userAgent, uI = lI === void 0 ? "" : lI, Md = v4, ur = xB, cI = SB, Xk = kB;
Md.document;
var Kc = !!ur.documentElement && !!ur.head && typeof ur.addEventListener == "function" && typeof ur.createElement == "function", _B = ~uI.indexOf("MSIE") || ~uI.indexOf("Trident/"), PN, Nie = /fa(k|kd|s|r|l|t|d|dr|dl|dt|b|slr|slpr|wsb|tl|ns|nds|es|jr|jfr|jdr|usb|ufsb|udsb|cr|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/, Aie = /Font ?Awesome ?([567 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit|Notdog Duo|Notdog|Chisel|Etch|Thumbprint|Jelly Fill|Jelly Duo|Jelly|Utility|Utility Fill|Utility Duo|Slab Press|Slab|Whiteboard)?.*/i, EB = {
  classic: {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fab: "brands",
    "fa-brands": "brands"
  },
  duotone: {
    fa: "solid",
    fad: "solid",
    "fa-solid": "solid",
    "fa-duotone": "solid",
    fadr: "regular",
    "fa-regular": "regular",
    fadl: "light",
    "fa-light": "light",
    fadt: "thin",
    "fa-thin": "thin"
  },
  sharp: {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular",
    fasl: "light",
    "fa-light": "light",
    fast: "thin",
    "fa-thin": "thin"
  },
  "sharp-duotone": {
    fa: "solid",
    fasds: "solid",
    "fa-solid": "solid",
    fasdr: "regular",
    "fa-regular": "regular",
    fasdl: "light",
    "fa-light": "light",
    fasdt: "thin",
    "fa-thin": "thin"
  },
  slab: {
    "fa-regular": "regular",
    faslr: "regular"
  },
  "slab-press": {
    "fa-regular": "regular",
    faslpr: "regular"
  },
  thumbprint: {
    "fa-light": "light",
    fatl: "light"
  },
  whiteboard: {
    "fa-semibold": "semibold",
    fawsb: "semibold"
  },
  notdog: {
    "fa-solid": "solid",
    fans: "solid"
  },
  "notdog-duo": {
    "fa-solid": "solid",
    fands: "solid"
  },
  etch: {
    "fa-solid": "solid",
    faes: "solid"
  },
  jelly: {
    "fa-regular": "regular",
    fajr: "regular"
  },
  "jelly-fill": {
    "fa-regular": "regular",
    fajfr: "regular"
  },
  "jelly-duo": {
    "fa-regular": "regular",
    fajdr: "regular"
  },
  chisel: {
    "fa-regular": "regular",
    facr: "regular"
  },
  utility: {
    "fa-semibold": "semibold",
    fausb: "semibold"
  },
  "utility-duo": {
    "fa-semibold": "semibold",
    faudsb: "semibold"
  },
  "utility-fill": {
    "fa-semibold": "semibold",
    faufsb: "semibold"
  }
}, Rie = {
  GROUP: "duotone-group",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, CB = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press", "fa-utility", "fa-utility-duo", "fa-utility-fill"], Lo = "classic", ZS = "duotone", OB = "sharp", MB = "sharp-duotone", NB = "chisel", AB = "etch", RB = "jelly", jB = "jelly-duo", PB = "jelly-fill", DB = "notdog", IB = "notdog-duo", $B = "slab", zB = "slab-press", TB = "thumbprint", LB = "utility", FB = "utility-duo", BB = "utility-fill", UB = "whiteboard", jie = "Classic", Pie = "Duotone", Die = "Sharp", Iie = "Sharp Duotone", $ie = "Chisel", zie = "Etch", Tie = "Jelly", Lie = "Jelly Duo", Fie = "Jelly Fill", Bie = "Notdog", Uie = "Notdog Duo", Vie = "Slab", Hie = "Slab Press", Wie = "Thumbprint", qie = "Utility", Gie = "Utility Duo", Kie = "Utility Fill", Yie = "Whiteboard", VB = [Lo, ZS, OB, MB, NB, AB, RB, jB, PB, DB, IB, $B, zB, TB, LB, FB, BB, UB];
PN = {}, Ft(Ft(Ft(Ft(Ft(Ft(Ft(Ft(Ft(Ft(PN, Lo, jie), ZS, Pie), OB, Die), MB, Iie), NB, $ie), AB, zie), RB, Tie), jB, Lie), PB, Fie), DB, Bie), Ft(Ft(Ft(Ft(Ft(Ft(Ft(Ft(PN, IB, Uie), $B, Vie), zB, Hie), TB, Wie), LB, qie), FB, Gie), BB, Kie), UB, Yie);
var Xie = {
  classic: {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  duotone: {
    900: "fad",
    400: "fadr",
    300: "fadl",
    100: "fadt"
  },
  sharp: {
    900: "fass",
    400: "fasr",
    300: "fasl",
    100: "fast"
  },
  "sharp-duotone": {
    900: "fasds",
    400: "fasdr",
    300: "fasdl",
    100: "fasdt"
  },
  slab: {
    400: "faslr"
  },
  "slab-press": {
    400: "faslpr"
  },
  whiteboard: {
    600: "fawsb"
  },
  thumbprint: {
    300: "fatl"
  },
  notdog: {
    900: "fans"
  },
  "notdog-duo": {
    900: "fands"
  },
  etch: {
    900: "faes"
  },
  chisel: {
    400: "facr"
  },
  jelly: {
    400: "fajr"
  },
  "jelly-fill": {
    400: "fajfr"
  },
  "jelly-duo": {
    400: "fajdr"
  },
  utility: {
    600: "fausb"
  },
  "utility-duo": {
    600: "faudsb"
  },
  "utility-fill": {
    600: "faufsb"
  }
}, Jie = {
  "Font Awesome 7 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 7 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  "Font Awesome 7 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 7 Duotone": {
    900: "fad",
    400: "fadr",
    normal: "fadr",
    300: "fadl",
    100: "fadt"
  },
  "Font Awesome 7 Sharp": {
    900: "fass",
    400: "fasr",
    normal: "fasr",
    300: "fasl",
    100: "fast"
  },
  "Font Awesome 7 Sharp Duotone": {
    900: "fasds",
    400: "fasdr",
    normal: "fasdr",
    300: "fasdl",
    100: "fasdt"
  },
  "Font Awesome 7 Jelly": {
    400: "fajr",
    normal: "fajr"
  },
  "Font Awesome 7 Jelly Fill": {
    400: "fajfr",
    normal: "fajfr"
  },
  "Font Awesome 7 Jelly Duo": {
    400: "fajdr",
    normal: "fajdr"
  },
  "Font Awesome 7 Slab": {
    400: "faslr",
    normal: "faslr"
  },
  "Font Awesome 7 Slab Press": {
    400: "faslpr",
    normal: "faslpr"
  },
  "Font Awesome 7 Thumbprint": {
    300: "fatl",
    normal: "fatl"
  },
  "Font Awesome 7 Notdog": {
    900: "fans",
    normal: "fans"
  },
  "Font Awesome 7 Notdog Duo": {
    900: "fands",
    normal: "fands"
  },
  "Font Awesome 7 Etch": {
    900: "faes",
    normal: "faes"
  },
  "Font Awesome 7 Chisel": {
    400: "facr",
    normal: "facr"
  },
  "Font Awesome 7 Whiteboard": {
    600: "fawsb",
    normal: "fawsb"
  },
  "Font Awesome 7 Utility": {
    600: "fausb",
    normal: "fausb"
  },
  "Font Awesome 7 Utility Duo": {
    600: "faudsb",
    normal: "faudsb"
  },
  "Font Awesome 7 Utility Fill": {
    600: "faufsb",
    normal: "faufsb"
  }
}, Qie = /* @__PURE__ */ new Map([["classic", {
  defaultShortPrefixId: "fas",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin", "brands"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["duotone", {
  defaultShortPrefixId: "fad",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp", {
  defaultShortPrefixId: "fass",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp-duotone", {
  defaultShortPrefixId: "fasds",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["chisel", {
  defaultShortPrefixId: "facr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["etch", {
  defaultShortPrefixId: "faes",
  defaultStyleId: "solid",
  styleIds: ["solid"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["jelly", {
  defaultShortPrefixId: "fajr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["jelly-duo", {
  defaultShortPrefixId: "fajdr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["jelly-fill", {
  defaultShortPrefixId: "fajfr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["notdog", {
  defaultShortPrefixId: "fans",
  defaultStyleId: "solid",
  styleIds: ["solid"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["notdog-duo", {
  defaultShortPrefixId: "fands",
  defaultStyleId: "solid",
  styleIds: ["solid"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["slab", {
  defaultShortPrefixId: "faslr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["slab-press", {
  defaultShortPrefixId: "faslpr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["thumbprint", {
  defaultShortPrefixId: "fatl",
  defaultStyleId: "light",
  styleIds: ["light"],
  futureStyleIds: [],
  defaultFontWeight: 300
}], ["utility", {
  defaultShortPrefixId: "fausb",
  defaultStyleId: "semibold",
  styleIds: ["semibold"],
  futureStyleIds: [],
  defaultFontWeight: 600
}], ["utility-duo", {
  defaultShortPrefixId: "faudsb",
  defaultStyleId: "semibold",
  styleIds: ["semibold"],
  futureStyleIds: [],
  defaultFontWeight: 600
}], ["utility-fill", {
  defaultShortPrefixId: "faufsb",
  defaultStyleId: "semibold",
  styleIds: ["semibold"],
  futureStyleIds: [],
  defaultFontWeight: 600
}], ["whiteboard", {
  defaultShortPrefixId: "fawsb",
  defaultStyleId: "semibold",
  styleIds: ["semibold"],
  futureStyleIds: [],
  defaultFontWeight: 600
}]]), Zie = {
  chisel: {
    regular: "facr"
  },
  classic: {
    brands: "fab",
    light: "fal",
    regular: "far",
    solid: "fas",
    thin: "fat"
  },
  duotone: {
    light: "fadl",
    regular: "fadr",
    solid: "fad",
    thin: "fadt"
  },
  etch: {
    solid: "faes"
  },
  jelly: {
    regular: "fajr"
  },
  "jelly-duo": {
    regular: "fajdr"
  },
  "jelly-fill": {
    regular: "fajfr"
  },
  notdog: {
    solid: "fans"
  },
  "notdog-duo": {
    solid: "fands"
  },
  sharp: {
    light: "fasl",
    regular: "fasr",
    solid: "fass",
    thin: "fast"
  },
  "sharp-duotone": {
    light: "fasdl",
    regular: "fasdr",
    solid: "fasds",
    thin: "fasdt"
  },
  slab: {
    regular: "faslr"
  },
  "slab-press": {
    regular: "faslpr"
  },
  thumbprint: {
    light: "fatl"
  },
  utility: {
    semibold: "fausb"
  },
  "utility-duo": {
    semibold: "faudsb"
  },
  "utility-fill": {
    semibold: "faufsb"
  },
  whiteboard: {
    semibold: "fawsb"
  }
}, HB = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], dI = {
  kit: {
    fak: "kit",
    "fa-kit": "kit"
  },
  "kit-duotone": {
    fakd: "kit-duotone",
    "fa-kit-duotone": "kit-duotone"
  }
}, ese = ["kit"], tse = "kit", nse = "kit-duotone", rse = "Kit", ose = "Kit Duotone";
Ft(Ft({}, tse, rse), nse, ose);
var ase = {
  kit: {
    "fa-kit": "fak"
  }
}, ise = {
  "Font Awesome Kit": {
    400: "fak",
    normal: "fak"
  },
  "Font Awesome Kit Duotone": {
    400: "fakd",
    normal: "fakd"
  }
}, sse = {
  kit: {
    fak: "fa-kit"
  }
}, fI = {
  kit: {
    kit: "fak"
  },
  "kit-duotone": {
    "kit-duotone": "fakd"
  }
}, DN, Jk = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, lse = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press", "fa-utility", "fa-utility-duo", "fa-utility-fill"], use = "classic", cse = "duotone", dse = "sharp", fse = "sharp-duotone", pse = "chisel", mse = "etch", hse = "jelly", gse = "jelly-duo", vse = "jelly-fill", yse = "notdog", bse = "notdog-duo", wse = "slab", xse = "slab-press", Sse = "thumbprint", kse = "utility", _se = "utility-duo", Ese = "utility-fill", Cse = "whiteboard", Ose = "Classic", Mse = "Duotone", Nse = "Sharp", Ase = "Sharp Duotone", Rse = "Chisel", jse = "Etch", Pse = "Jelly", Dse = "Jelly Duo", Ise = "Jelly Fill", $se = "Notdog", zse = "Notdog Duo", Tse = "Slab", Lse = "Slab Press", Fse = "Thumbprint", Bse = "Utility", Use = "Utility Duo", Vse = "Utility Fill", Hse = "Whiteboard";
DN = {}, Ft(Ft(Ft(Ft(Ft(Ft(Ft(Ft(Ft(Ft(DN, use, Ose), cse, Mse), dse, Nse), fse, Ase), pse, Rse), mse, jse), hse, Pse), gse, Dse), vse, Ise), yse, $se), Ft(Ft(Ft(Ft(Ft(Ft(Ft(Ft(DN, bse, zse), wse, Tse), xse, Lse), Sse, Fse), kse, Bse), _se, Use), Ese, Vse), Cse, Hse);
var Wse = "kit", qse = "kit-duotone", Gse = "Kit", Kse = "Kit Duotone";
Ft(Ft({}, Wse, Gse), qse, Kse);
var Yse = {
  classic: {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
  },
  duotone: {
    "fa-regular": "fadr",
    "fa-light": "fadl",
    "fa-thin": "fadt"
  },
  sharp: {
    "fa-solid": "fass",
    "fa-regular": "fasr",
    "fa-light": "fasl",
    "fa-thin": "fast"
  },
  "sharp-duotone": {
    "fa-solid": "fasds",
    "fa-regular": "fasdr",
    "fa-light": "fasdl",
    "fa-thin": "fasdt"
  },
  slab: {
    "fa-regular": "faslr"
  },
  "slab-press": {
    "fa-regular": "faslpr"
  },
  whiteboard: {
    "fa-semibold": "fawsb"
  },
  thumbprint: {
    "fa-light": "fatl"
  },
  notdog: {
    "fa-solid": "fans"
  },
  "notdog-duo": {
    "fa-solid": "fands"
  },
  etch: {
    "fa-solid": "faes"
  },
  jelly: {
    "fa-regular": "fajr"
  },
  "jelly-fill": {
    "fa-regular": "fajfr"
  },
  "jelly-duo": {
    "fa-regular": "fajdr"
  },
  chisel: {
    "fa-regular": "facr"
  },
  utility: {
    "fa-semibold": "fausb"
  },
  "utility-duo": {
    "fa-semibold": "faudsb"
  },
  "utility-fill": {
    "fa-semibold": "faufsb"
  }
}, Xse = {
  classic: ["fas", "far", "fal", "fat", "fad"],
  duotone: ["fadr", "fadl", "fadt"],
  sharp: ["fass", "fasr", "fasl", "fast"],
  "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"],
  slab: ["faslr"],
  "slab-press": ["faslpr"],
  whiteboard: ["fawsb"],
  thumbprint: ["fatl"],
  notdog: ["fans"],
  "notdog-duo": ["fands"],
  etch: ["faes"],
  jelly: ["fajr"],
  "jelly-fill": ["fajfr"],
  "jelly-duo": ["fajdr"],
  chisel: ["facr"],
  utility: ["fausb"],
  "utility-duo": ["faudsb"],
  "utility-fill": ["faufsb"]
}, WA = {
  classic: {
    fab: "fa-brands",
    fad: "fa-duotone",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
  },
  duotone: {
    fadr: "fa-regular",
    fadl: "fa-light",
    fadt: "fa-thin"
  },
  sharp: {
    fass: "fa-solid",
    fasr: "fa-regular",
    fasl: "fa-light",
    fast: "fa-thin"
  },
  "sharp-duotone": {
    fasds: "fa-solid",
    fasdr: "fa-regular",
    fasdl: "fa-light",
    fasdt: "fa-thin"
  },
  slab: {
    faslr: "fa-regular"
  },
  "slab-press": {
    faslpr: "fa-regular"
  },
  whiteboard: {
    fawsb: "fa-semibold"
  },
  thumbprint: {
    fatl: "fa-light"
  },
  notdog: {
    fans: "fa-solid"
  },
  "notdog-duo": {
    fands: "fa-solid"
  },
  etch: {
    faes: "fa-solid"
  },
  jelly: {
    fajr: "fa-regular"
  },
  "jelly-fill": {
    fajfr: "fa-regular"
  },
  "jelly-duo": {
    fajdr: "fa-regular"
  },
  chisel: {
    facr: "fa-regular"
  },
  utility: {
    fausb: "fa-semibold"
  },
  "utility-duo": {
    faudsb: "fa-semibold"
  },
  "utility-fill": {
    faufsb: "fa-semibold"
  }
}, Jse = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands", "fa-semibold"], WB = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", "faslr", "faslpr", "fawsb", "fatl", "fans", "fands", "faes", "fajr", "fajfr", "fajdr", "facr", "fausb", "faudsb", "faufsb"].concat(lse, Jse), Qse = ["solid", "regular", "light", "thin", "duotone", "brands", "semibold"], qB = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], Zse = qB.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), ele = ["aw", "fw", "pull-left", "pull-right"], tle = [].concat(el(Object.keys(Xse)), Qse, ele, ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "inverse", "layers", "layers-bottom-left", "layers-bottom-right", "layers-counter", "layers-text", "layers-top-left", "layers-top-right", "li", "pull-end", "pull-start", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", "width-auto", "width-fixed", Jk.GROUP, Jk.SWAP_OPACITY, Jk.PRIMARY, Jk.SECONDARY]).concat(qB.map(function(e) {
  return "".concat(e, "x");
})).concat(Zse.map(function(e) {
  return "w-".concat(e);
})), nle = {
  "Font Awesome 5 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 5 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal"
  },
  "Font Awesome 5 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 5 Duotone": {
    900: "fad"
  }
}, Tc = "___FONT_AWESOME___", qA = 16, GB = "fa", KB = "svg-inline--fa", Dm = "data-fa-i2svg", GA = "data-fa-pseudo-element", rle = "data-fa-pseudo-element-pending", y4 = "data-prefix", b4 = "data-icon", pI = "fontawesome-i2svg", ole = "async", ale = ["HTML", "HEAD", "STYLE", "SCRIPT"], YB = ["::before", "::after", ":before", ":after"], XB = (function() {
  try {
    return !0;
  } catch {
    return !1;
  }
})();
function ek(e) {
  return new Proxy(e, {
    get: function(t, n) {
      return n in t ? t[n] : t[Lo];
    }
  });
}
var JB = De({}, EB);
JB[Lo] = De(De(De(De({}, {
  "fa-duotone": "duotone"
}), EB[Lo]), dI.kit), dI["kit-duotone"]);
var ile = ek(JB), KA = De({}, Zie);
KA[Lo] = De(De(De(De({}, {
  duotone: "fad"
}), KA[Lo]), fI.kit), fI["kit-duotone"]);
var mI = ek(KA), YA = De({}, WA);
YA[Lo] = De(De({}, YA[Lo]), sse.kit);
var w4 = ek(YA), XA = De({}, Yse);
XA[Lo] = De(De({}, XA[Lo]), ase.kit);
ek(XA);
var sle = Nie, QB = "fa-layers-text", lle = Aie, ule = De({}, Xie);
ek(ule);
var cle = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], IN = Rie, dle = [].concat(el(ese), el(tle)), jx = Md.FontAwesomeConfig || {};
function fle(e) {
  var t = ur.querySelector("script[" + e + "]");
  if (t)
    return t.getAttribute(e);
}
function ple(e) {
  return e === "" ? !0 : e === "false" ? !1 : e === "true" ? !0 : e;
}
if (ur && typeof ur.querySelector == "function") {
  var mle = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-search-pseudo-elements-warnings", "searchPseudoElementsWarnings"], ["data-search-pseudo-elements-full-scan", "searchPseudoElementsFullScan"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
  mle.forEach(function(e) {
    var t = DE(e, 2), n = t[0], r = t[1], a = ple(fle(n));
    a != null && (jx[r] = a);
  });
}
var ZB = {
  styleDefault: "solid",
  familyDefault: Lo,
  cssPrefix: GB,
  replacementClass: KB,
  autoReplaceSvg: !0,
  autoAddCss: !0,
  searchPseudoElements: !1,
  searchPseudoElementsWarnings: !0,
  searchPseudoElementsFullScan: !1,
  observeMutations: !0,
  mutateApproach: "async",
  keepOriginalSource: !0,
  measurePerformance: !1,
  showMissingIcons: !0
};
jx.familyPrefix && (jx.cssPrefix = jx.familyPrefix);
var mg = De(De({}, ZB), jx);
mg.autoReplaceSvg || (mg.observeMutations = !1);
var dt = {};
Object.keys(ZB).forEach(function(e) {
  Object.defineProperty(dt, e, {
    enumerable: !0,
    set: function(t) {
      mg[e] = t, Px.forEach(function(n) {
        return n(dt);
      });
    },
    get: function() {
      return mg[e];
    }
  });
});
Object.defineProperty(dt, "familyPrefix", {
  enumerable: !0,
  set: function(e) {
    mg.cssPrefix = e, Px.forEach(function(t) {
      return t(dt);
    });
  },
  get: function() {
    return mg.cssPrefix;
  }
});
Md.FontAwesomeConfig = dt;
var Px = [];
function hle(e) {
  return Px.push(e), function() {
    Px.splice(Px.indexOf(e), 1);
  };
}
var xh = qA, Ol = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: !1,
  flipY: !1
};
function gle(e) {
  if (!(!e || !Kc)) {
    var t = ur.createElement("style");
    t.setAttribute("type", "text/css"), t.innerHTML = e;
    for (var n = ur.head.childNodes, r = null, a = n.length - 1; a > -1; a--) {
      var s = n[a], l = (s.tagName || "").toUpperCase();
      ["STYLE", "LINK"].indexOf(l) > -1 && (r = s);
    }
    return ur.head.insertBefore(t, r), e;
  }
}
var vle = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function hI() {
  for (var e = 12, t = ""; e-- > 0; )
    t += vle[Math.random() * 62 | 0];
  return t;
}
function Lg(e) {
  for (var t = [], n = (e || []).length >>> 0; n--; )
    t[n] = e[n];
  return t;
}
function x4(e) {
  return e.classList ? Lg(e.classList) : (e.getAttribute("class") || "").split(" ").filter(function(t) {
    return t;
  });
}
function eU(e) {
  return "".concat(e).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function yle(e) {
  return Object.keys(e || {}).reduce(function(t, n) {
    return t + "".concat(n, '="').concat(eU(e[n]), '" ');
  }, "").trim();
}
function IE(e) {
  return Object.keys(e || {}).reduce(function(t, n) {
    return t + "".concat(n, ": ").concat(e[n].trim(), ";");
  }, "");
}
function S4(e) {
  return e.size !== Ol.size || e.x !== Ol.x || e.y !== Ol.y || e.rotate !== Ol.rotate || e.flipX || e.flipY;
}
function ble(e) {
  var t = e.transform, n = e.containerWidth, r = e.iconWidth, a = {
    transform: "translate(".concat(n / 2, " 256)")
  }, s = "translate(".concat(t.x * 32, ", ").concat(t.y * 32, ") "), l = "scale(".concat(t.size / 16 * (t.flipX ? -1 : 1), ", ").concat(t.size / 16 * (t.flipY ? -1 : 1), ") "), c = "rotate(".concat(t.rotate, " 0 0)"), d = {
    transform: "".concat(s, " ").concat(l, " ").concat(c)
  }, f = {
    transform: "translate(".concat(r / 2 * -1, " -256)")
  };
  return {
    outer: a,
    inner: d,
    path: f
  };
}
function wle(e) {
  var t = e.transform, n = e.width, r = n === void 0 ? qA : n, a = e.height, s = a === void 0 ? qA : a, l = "";
  return _B ? l += "translate(".concat(t.x / xh - r / 2, "em, ").concat(t.y / xh - s / 2, "em) ") : l += "translate(calc(-50% + ".concat(t.x / xh, "em), calc(-50% + ").concat(t.y / xh, "em)) "), l += "scale(".concat(t.size / xh * (t.flipX ? -1 : 1), ", ").concat(t.size / xh * (t.flipY ? -1 : 1), ") "), l += "rotate(".concat(t.rotate, "deg) "), l;
}
var xle = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 7 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 7 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 7 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 7 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 7 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 7 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-slab-regular: normal 400 1em/1 "Font Awesome 7 Slab";
  --fa-font-slab-press-regular: normal 400 1em/1 "Font Awesome 7 Slab Press";
  --fa-font-whiteboard-semibold: normal 600 1em/1 "Font Awesome 7 Whiteboard";
  --fa-font-thumbprint-light: normal 300 1em/1 "Font Awesome 7 Thumbprint";
  --fa-font-notdog-solid: normal 900 1em/1 "Font Awesome 7 Notdog";
  --fa-font-notdog-duo-solid: normal 900 1em/1 "Font Awesome 7 Notdog Duo";
  --fa-font-etch-solid: normal 900 1em/1 "Font Awesome 7 Etch";
  --fa-font-jelly-regular: normal 400 1em/1 "Font Awesome 7 Jelly";
  --fa-font-jelly-fill-regular: normal 400 1em/1 "Font Awesome 7 Jelly Fill";
  --fa-font-jelly-duo-regular: normal 400 1em/1 "Font Awesome 7 Jelly Duo";
  --fa-font-chisel-regular: normal 400 1em/1 "Font Awesome 7 Chisel";
  --fa-font-utility-semibold: normal 600 1em/1 "Font Awesome 7 Utility";
  --fa-font-utility-duo-semibold: normal 600 1em/1 "Font Awesome 7 Utility Duo";
  --fa-font-utility-fill-semibold: normal 600 1em/1 "Font Awesome 7 Utility Fill";
}

.svg-inline--fa {
  box-sizing: content-box;
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285714em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left,
.svg-inline--fa .fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-pull-right,
.svg-inline--fa .fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  inset-block-start: 0.25em; /* syncing vertical alignment with Web Font rendering */
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.fa-layers .svg-inline--fa {
  inset: 0;
  margin: auto;
  position: absolute;
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: calc(10 / 16 * 1em); /* converts a 10px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 10 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 10 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xs {
  font-size: calc(12 / 16 * 1em); /* converts a 12px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 12 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 12 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-sm {
  font-size: calc(14 / 16 * 1em); /* converts a 14px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 14 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 14 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-lg {
  font-size: calc(20 / 16 * 1em); /* converts a 20px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 20 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 20 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xl {
  font-size: calc(24 / 16 * 1em); /* converts a 24px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 24 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 24 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-2xl {
  font-size: calc(32 / 16 * 1em); /* converts a 32px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 32 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 32 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-width-auto {
  --fa-width: auto;
}

.fa-fw,
.fa-width-fixed {
  --fa-width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-inline-start: var(--fa-li-margin, 2.5em);
  padding-inline-start: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

/* Heads Up: Bordered Icons will not be supported in the future!
  - This feature will be deprecated in the next major release of Font Awesome (v8)!
  - You may continue to use it in this version *v7), but it will not be supported in Font Awesome v8.
*/
/* Notes:
* --@{v.$css-prefix}-border-width = 1/16 by default (to render as ~1px based on a 16px default font-size)
* --@{v.$css-prefix}-border-padding =
  ** 3/16 for vertical padding (to give ~2px of vertical whitespace around an icon considering it's vertical alignment)
  ** 4/16 for horizontal padding (to give ~4px of horizontal whitespace around an icon)
*/
.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.0625em);
  box-sizing: var(--fa-border-box-sizing, content-box);
  padding: var(--fa-border-padding, 0.1875em 0.25em);
}

.fa-pull-left,
.fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right,
.fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
  .fa-bounce,
  .fa-fade,
  .fa-beat-fade,
  .fa-flip,
  .fa-pulse,
  .fa-shake,
  .fa-spin,
  .fa-spin-pulse {
    animation: none !important;
    transition: none !important;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.svg-inline--fa.fa-inverse {
  fill: var(--fa-inverse, #fff);
}

.fa-stack {
  display: inline-block;
  height: 2em;
  line-height: 2em;
  position: relative;
  vertical-align: middle;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.svg-inline--fa.fa-stack-1x {
  --fa-width: 1.25em;
  height: 1em;
  width: var(--fa-width);
}
.svg-inline--fa.fa-stack-2x {
  --fa-width: 2.5em;
  height: 2em;
  width: var(--fa-width);
}

.fa-stack-1x,
.fa-stack-2x {
  inset: 0;
  margin: auto;
  position: absolute;
  z-index: var(--fa-stack-z-index, auto);
}`;
function tU() {
  var e = GB, t = KB, n = dt.cssPrefix, r = dt.replacementClass, a = xle;
  if (n !== e || r !== t) {
    var s = new RegExp("\\.".concat(e, "\\-"), "g"), l = new RegExp("\\--".concat(e, "\\-"), "g"), c = new RegExp("\\.".concat(t), "g");
    a = a.replace(s, ".".concat(n, "-")).replace(l, "--".concat(n, "-")).replace(c, ".".concat(r));
  }
  return a;
}
var gI = !1;
function $N() {
  dt.autoAddCss && !gI && (gle(tU()), gI = !0);
}
var Sle = {
  mixout: function() {
    return {
      dom: {
        css: tU,
        insertCss: $N
      }
    };
  },
  hooks: function() {
    return {
      beforeDOMElementCreation: function() {
        $N();
      },
      beforeI2svg: function() {
        $N();
      }
    };
  }
}, Lc = Md || {};
Lc[Tc] || (Lc[Tc] = {});
Lc[Tc].styles || (Lc[Tc].styles = {});
Lc[Tc].hooks || (Lc[Tc].hooks = {});
Lc[Tc].shims || (Lc[Tc].shims = []);
var Gs = Lc[Tc], nU = [], rU = function() {
  ur.removeEventListener("DOMContentLoaded", rU), d2 = 1, nU.map(function(e) {
    return e();
  });
}, d2 = !1;
Kc && (d2 = (ur.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(ur.readyState), d2 || ur.addEventListener("DOMContentLoaded", rU));
function kle(e) {
  Kc && (d2 ? setTimeout(e, 0) : nU.push(e));
}
function tk(e) {
  var t = e.tag, n = e.attributes, r = n === void 0 ? {} : n, a = e.children, s = a === void 0 ? [] : a;
  return typeof e == "string" ? eU(e) : "<".concat(t, " ").concat(yle(r), ">").concat(s.map(tk).join(""), "</").concat(t, ">");
}
function vI(e, t, n) {
  if (e && e[t] && e[t][n])
    return {
      prefix: t,
      iconName: n,
      icon: e[t][n]
    };
}
var zN = function(e, t, n, r) {
  var a = Object.keys(e), s = a.length, l = t, c, d, f;
  for (n === void 0 ? (c = 1, f = e[a[0]]) : (c = 0, f = n); c < s; c++)
    d = a[c], f = l(f, e[d], d, e);
  return f;
};
function oU(e) {
  return el(e).length !== 1 ? null : e.codePointAt(0).toString(16);
}
function yI(e) {
  return Object.keys(e).reduce(function(t, n) {
    var r = e[n], a = !!r.icon;
    return a ? t[r.iconName] = r.icon : t[n] = r, t;
  }, {});
}
function JA(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = n.skipHooks, a = r === void 0 ? !1 : r, s = yI(t);
  typeof Gs.hooks.addPack == "function" && !a ? Gs.hooks.addPack(e, yI(t)) : Gs.styles[e] = De(De({}, Gs.styles[e] || {}), s), e === "fas" && JA("fa", t);
}
var oS = Gs.styles, _le = Gs.shims, aU = Object.keys(w4), Ele = aU.reduce(function(e, t) {
  return e[t] = Object.keys(w4[t]), e;
}, {}), k4 = null, iU = {}, sU = {}, lU = {}, uU = {}, cU = {};
function Cle(e) {
  return ~dle.indexOf(e);
}
function Ole(e, t) {
  var n = t.split("-"), r = n[0], a = n.slice(1).join("-");
  return r === e && a !== "" && !Cle(a) ? a : null;
}
var dU = function() {
  var e = function(r) {
    return zN(oS, function(a, s, l) {
      return a[l] = zN(s, r, {}), a;
    }, {});
  };
  iU = e(function(r, a, s) {
    if (a[3] && (r[a[3]] = s), a[2]) {
      var l = a[2].filter(function(c) {
        return typeof c == "number";
      });
      l.forEach(function(c) {
        r[c.toString(16)] = s;
      });
    }
    return r;
  }), sU = e(function(r, a, s) {
    if (r[s] = s, a[2]) {
      var l = a[2].filter(function(c) {
        return typeof c == "string";
      });
      l.forEach(function(c) {
        r[c] = s;
      });
    }
    return r;
  }), cU = e(function(r, a, s) {
    var l = a[2];
    return r[s] = s, l.forEach(function(c) {
      r[c] = s;
    }), r;
  });
  var t = "far" in oS || dt.autoFetchSvg, n = zN(_le, function(r, a) {
    var s = a[0], l = a[1], c = a[2];
    return l === "far" && !t && (l = "fas"), typeof s == "string" && (r.names[s] = {
      prefix: l,
      iconName: c
    }), typeof s == "number" && (r.unicodes[s.toString(16)] = {
      prefix: l,
      iconName: c
    }), r;
  }, {
    names: {},
    unicodes: {}
  });
  lU = n.names, uU = n.unicodes, k4 = $E(dt.styleDefault, {
    family: dt.familyDefault
  });
};
hle(function(e) {
  k4 = $E(e.styleDefault, {
    family: dt.familyDefault
  });
});
dU();
function _4(e, t) {
  return (iU[e] || {})[t];
}
function Mle(e, t) {
  return (sU[e] || {})[t];
}
function Cm(e, t) {
  return (cU[e] || {})[t];
}
function fU(e) {
  return lU[e] || {
    prefix: null,
    iconName: null
  };
}
function Nle(e) {
  var t = uU[e], n = _4("fas", e);
  return t || (n ? {
    prefix: "fas",
    iconName: n
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function Nd() {
  return k4;
}
var pU = function() {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
};
function Ale(e) {
  var t = Lo, n = aU.reduce(function(r, a) {
    return r[a] = "".concat(dt.cssPrefix, "-").concat(a), r;
  }, {});
  return VB.forEach(function(r) {
    (e.includes(n[r]) || e.some(function(a) {
      return Ele[r].includes(a);
    })) && (t = r);
  }), t;
}
function $E(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.family, r = n === void 0 ? Lo : n, a = ile[r][e];
  if (r === ZS && !e)
    return "fad";
  var s = mI[r][e] || mI[r][a], l = e in Gs.styles ? e : null, c = s || l || null;
  return c;
}
function Rle(e) {
  var t = [], n = null;
  return e.forEach(function(r) {
    var a = Ole(dt.cssPrefix, r);
    a ? n = a : r && t.push(r);
  }), {
    iconName: n,
    rest: t
  };
}
function bI(e) {
  return e.sort().filter(function(t, n, r) {
    return r.indexOf(t) === n;
  });
}
var wI = WB.concat(HB);
function zE(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.skipLookups, r = n === void 0 ? !1 : n, a = null, s = bI(e.filter(function(g) {
    return wI.includes(g);
  })), l = bI(e.filter(function(g) {
    return !wI.includes(g);
  })), c = s.filter(function(g) {
    return a = g, !CB.includes(g);
  }), d = DE(c, 1), f = d[0], m = f === void 0 ? null : f, h = Ale(s), v = De(De({}, Rle(l)), {}, {
    prefix: $E(m, {
      family: h
    })
  });
  return De(De(De({}, v), Ile({
    values: e,
    family: h,
    styles: oS,
    config: dt,
    canonical: v,
    givenPrefix: a
  })), jle(r, a, v));
}
function jle(e, t, n) {
  var r = n.prefix, a = n.iconName;
  if (e || !r || !a)
    return {
      prefix: r,
      iconName: a
    };
  var s = t === "fa" ? fU(a) : {}, l = Cm(r, a);
  return a = s.iconName || l || a, r = s.prefix || r, r === "far" && !oS.far && oS.fas && !dt.autoFetchSvg && (r = "fas"), {
    prefix: r,
    iconName: a
  };
}
var Ple = VB.filter(function(e) {
  return e !== Lo || e !== ZS;
}), Dle = Object.keys(WA).filter(function(e) {
  return e !== Lo;
}).map(function(e) {
  return Object.keys(WA[e]);
}).flat();
function Ile(e) {
  var t = e.values, n = e.family, r = e.canonical, a = e.givenPrefix, s = a === void 0 ? "" : a, l = e.styles, c = l === void 0 ? {} : l, d = e.config, f = d === void 0 ? {} : d, m = n === ZS, h = t.includes("fa-duotone") || t.includes("fad"), v = f.familyDefault === "duotone", g = r.prefix === "fad" || r.prefix === "fa-duotone";
  if (!m && (h || v || g) && (r.prefix = "fad"), (t.includes("fa-brands") || t.includes("fab")) && (r.prefix = "fab"), !r.prefix && Ple.includes(n)) {
    var b = Object.keys(c).find(function(w) {
      return Dle.includes(w);
    });
    if (b || f.autoFetchSvg) {
      var x = Qie.get(n).defaultShortPrefixId;
      r.prefix = x, r.iconName = Cm(r.prefix, r.iconName) || r.iconName;
    }
  }
  return (r.prefix === "fa" || s === "fa") && (r.prefix = Nd() || "fas"), r;
}
var $le = /* @__PURE__ */ (function() {
  function e() {
    wie(this, e), this.definitions = {};
  }
  return Sie(e, [{
    key: "add",
    value: function() {
      for (var t = this, n = arguments.length, r = new Array(n), a = 0; a < n; a++)
        r[a] = arguments[a];
      var s = r.reduce(this._pullDefinitions, {});
      Object.keys(s).forEach(function(l) {
        t.definitions[l] = De(De({}, t.definitions[l] || {}), s[l]), JA(l, s[l]);
        var c = w4[Lo][l];
        c && JA(c, s[l]), dU();
      });
    }
  }, {
    key: "reset",
    value: function() {
      this.definitions = {};
    }
  }, {
    key: "_pullDefinitions",
    value: function(t, n) {
      var r = n.prefix && n.iconName && n.icon ? {
        0: n
      } : n;
      return Object.keys(r).map(function(a) {
        var s = r[a], l = s.prefix, c = s.iconName, d = s.icon, f = d[2];
        t[l] || (t[l] = {}), f.length > 0 && f.forEach(function(m) {
          typeof m == "string" && (t[l][m] = d);
        }), t[l][c] = d;
      }), t;
    }
  }]);
})(), xI = [], Vh = {}, tg = {}, zle = Object.keys(tg);
function Tle(e, t) {
  var n = t.mixoutsTo;
  return xI = e, Vh = {}, Object.keys(tg).forEach(function(r) {
    zle.indexOf(r) === -1 && delete tg[r];
  }), xI.forEach(function(r) {
    var a = r.mixout ? r.mixout() : {};
    if (Object.keys(a).forEach(function(l) {
      typeof a[l] == "function" && (n[l] = a[l]), c2(a[l]) === "object" && Object.keys(a[l]).forEach(function(c) {
        n[l] || (n[l] = {}), n[l][c] = a[l][c];
      });
    }), r.hooks) {
      var s = r.hooks();
      Object.keys(s).forEach(function(l) {
        Vh[l] || (Vh[l] = []), Vh[l].push(s[l]);
      });
    }
    r.provides && r.provides(tg);
  }), n;
}
function QA(e, t) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), a = 2; a < n; a++)
    r[a - 2] = arguments[a];
  var s = Vh[e] || [];
  return s.forEach(function(l) {
    t = l.apply(null, [t].concat(r));
  }), t;
}
function Im(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  var a = Vh[e] || [];
  a.forEach(function(s) {
    s.apply(null, n);
  });
}
function Ad() {
  var e = arguments[0], t = Array.prototype.slice.call(arguments, 1);
  return tg[e] ? tg[e].apply(null, t) : void 0;
}
function ZA(e) {
  e.prefix === "fa" && (e.prefix = "fas");
  var t = e.iconName, n = e.prefix || Nd();
  if (t)
    return t = Cm(n, t) || t, vI(mU.definitions, n, t) || vI(Gs.styles, n, t);
}
var mU = new $le(), Lle = function() {
  dt.autoReplaceSvg = !1, dt.observeMutations = !1, Im("noAuto");
}, Fle = {
  i2svg: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Kc ? (Im("beforeI2svg", e), Ad("pseudoElements2svg", e), Ad("i2svg", e)) : Promise.reject(new Error("Operation requires a DOM of some kind."));
  },
  watch: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = e.autoReplaceSvgRoot;
    dt.autoReplaceSvg === !1 && (dt.autoReplaceSvg = !0), dt.observeMutations = !0, kle(function() {
      Ule({
        autoReplaceSvgRoot: t
      }), Im("watch", e);
    });
  }
}, Ble = {
  icon: function(e) {
    if (e === null)
      return null;
    if (c2(e) === "object" && e.prefix && e.iconName)
      return {
        prefix: e.prefix,
        iconName: Cm(e.prefix, e.iconName) || e.iconName
      };
    if (Array.isArray(e) && e.length === 2) {
      var t = e[1].indexOf("fa-") === 0 ? e[1].slice(3) : e[1], n = $E(e[0]);
      return {
        prefix: n,
        iconName: Cm(n, t) || t
      };
    }
    if (typeof e == "string" && (e.indexOf("".concat(dt.cssPrefix, "-")) > -1 || e.match(sle))) {
      var r = zE(e.split(" "), {
        skipLookups: !0
      });
      return {
        prefix: r.prefix || Nd(),
        iconName: Cm(r.prefix, r.iconName) || r.iconName
      };
    }
    if (typeof e == "string") {
      var a = Nd();
      return {
        prefix: a,
        iconName: Cm(a, e) || e
      };
    }
  }
}, Ai = {
  noAuto: Lle,
  config: dt,
  dom: Fle,
  parse: Ble,
  library: mU,
  findIconDefinition: ZA,
  toHtml: tk
}, Ule = function() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = e.autoReplaceSvgRoot, n = t === void 0 ? ur : t;
  (Object.keys(Gs.styles).length > 0 || dt.autoFetchSvg) && Kc && dt.autoReplaceSvg && Ai.dom.i2svg({
    node: n
  });
};
function TE(e, t) {
  return Object.defineProperty(e, "abstract", {
    get: t
  }), Object.defineProperty(e, "html", {
    get: function() {
      return e.abstract.map(function(n) {
        return tk(n);
      });
    }
  }), Object.defineProperty(e, "node", {
    get: function() {
      if (Kc) {
        var n = ur.createElement("div");
        return n.innerHTML = e.html, n.children;
      }
    }
  }), e;
}
function Vle(e) {
  var t = e.children, n = e.main, r = e.mask, a = e.attributes, s = e.styles, l = e.transform;
  if (S4(l) && n.found && !r.found) {
    var c = n.width, d = n.height, f = {
      x: c / d / 2,
      y: 0.5
    };
    a.style = IE(De(De({}, s), {}, {
      "transform-origin": "".concat(f.x + l.x / 16, "em ").concat(f.y + l.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes: a,
    children: t
  }];
}
function Hle(e) {
  var t = e.prefix, n = e.iconName, r = e.children, a = e.attributes, s = e.symbol, l = s === !0 ? "".concat(t, "-").concat(dt.cssPrefix, "-").concat(n) : s;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: De(De({}, a), {}, {
        id: l
      }),
      children: r
    }]
  }];
}
function Wle(e) {
  var t = ["aria-label", "aria-labelledby", "title", "role"];
  return t.some(function(n) {
    return n in e;
  });
}
function E4(e) {
  var t = e.icons, n = t.main, r = t.mask, a = e.prefix, s = e.iconName, l = e.transform, c = e.symbol, d = e.maskId, f = e.extra, m = e.watchable, h = m === void 0 ? !1 : m, v = r.found ? r : n, g = v.width, b = v.height, x = [dt.replacementClass, s ? "".concat(dt.cssPrefix, "-").concat(s) : ""].filter(function(N) {
    return f.classes.indexOf(N) === -1;
  }).filter(function(N) {
    return N !== "" || !!N;
  }).concat(f.classes).join(" "), w = {
    children: [],
    attributes: De(De({}, f.attributes), {}, {
      "data-prefix": a,
      "data-icon": s,
      class: x,
      role: f.attributes.role || "img",
      viewBox: "0 0 ".concat(g, " ").concat(b)
    })
  };
  !Wle(f.attributes) && !f.attributes["aria-hidden"] && (w.attributes["aria-hidden"] = "true"), h && (w.attributes[Dm] = "");
  var k = De(De({}, w), {}, {
    prefix: a,
    iconName: s,
    main: n,
    mask: r,
    maskId: d,
    transform: l,
    symbol: c,
    styles: De({}, f.styles)
  }), E = r.found && n.found ? Ad("generateAbstractMask", k) || {
    children: [],
    attributes: {}
  } : Ad("generateAbstractIcon", k) || {
    children: [],
    attributes: {}
  }, _ = E.children, O = E.attributes;
  return k.children = _, k.attributes = O, c ? Hle(k) : Vle(k);
}
function SI(e) {
  var t = e.content, n = e.width, r = e.height, a = e.transform, s = e.extra, l = e.watchable, c = l === void 0 ? !1 : l, d = De(De({}, s.attributes), {}, {
    class: s.classes.join(" ")
  });
  c && (d[Dm] = "");
  var f = De({}, s.styles);
  S4(a) && (f.transform = wle({
    transform: a,
    width: n,
    height: r
  }), f["-webkit-transform"] = f.transform);
  var m = IE(f);
  m.length > 0 && (d.style = m);
  var h = [];
  return h.push({
    tag: "span",
    attributes: d,
    children: [t]
  }), h;
}
function qle(e) {
  var t = e.content, n = e.extra, r = De(De({}, n.attributes), {}, {
    class: n.classes.join(" ")
  }), a = IE(n.styles);
  a.length > 0 && (r.style = a);
  var s = [];
  return s.push({
    tag: "span",
    attributes: r,
    children: [t]
  }), s;
}
var TN = Gs.styles;
function e3(e) {
  var t = e[0], n = e[1], r = e.slice(4), a = DE(r, 1), s = a[0], l = null;
  return Array.isArray(s) ? l = {
    tag: "g",
    attributes: {
      class: "".concat(dt.cssPrefix, "-").concat(IN.GROUP)
    },
    children: [{
      tag: "path",
      attributes: {
        class: "".concat(dt.cssPrefix, "-").concat(IN.SECONDARY),
        fill: "currentColor",
        d: s[0]
      }
    }, {
      tag: "path",
      attributes: {
        class: "".concat(dt.cssPrefix, "-").concat(IN.PRIMARY),
        fill: "currentColor",
        d: s[1]
      }
    }]
  } : l = {
    tag: "path",
    attributes: {
      fill: "currentColor",
      d: s
    }
  }, {
    found: !0,
    width: t,
    height: n,
    icon: l
  };
}
var Gle = {
  found: !1,
  width: 512,
  height: 512
};
function Kle(e, t) {
  !XB && !dt.showMissingIcons && e && console.error('Icon with name "'.concat(e, '" and prefix "').concat(t, '" is missing.'));
}
function t3(e, t) {
  var n = t;
  return t === "fa" && dt.styleDefault !== null && (t = Nd()), new Promise(function(r, a) {
    if (n === "fa") {
      var s = fU(e) || {};
      e = s.iconName || e, t = s.prefix || t;
    }
    if (e && t && TN[t] && TN[t][e]) {
      var l = TN[t][e];
      return r(e3(l));
    }
    Kle(e, t), r(De(De({}, Gle), {}, {
      icon: dt.showMissingIcons && e ? Ad("missingIconAbstract") || {} : {}
    }));
  });
}
var kI = function() {
}, n3 = dt.measurePerformance && Xk && Xk.mark && Xk.measure ? Xk : {
  mark: kI,
  measure: kI
}, vx = 'FA "7.1.0"', Yle = function(e) {
  return n3.mark("".concat(vx, " ").concat(e, " begins")), function() {
    return hU(e);
  };
}, hU = function(e) {
  n3.mark("".concat(vx, " ").concat(e, " ends")), n3.measure("".concat(vx, " ").concat(e), "".concat(vx, " ").concat(e, " begins"), "".concat(vx, " ").concat(e, " ends"));
}, C4 = {
  begin: Yle,
  end: hU
}, R_ = function() {
};
function _I(e) {
  var t = e.getAttribute ? e.getAttribute(Dm) : null;
  return typeof t == "string";
}
function Xle(e) {
  var t = e.getAttribute ? e.getAttribute(y4) : null, n = e.getAttribute ? e.getAttribute(b4) : null;
  return t && n;
}
function Jle(e) {
  return e && e.classList && e.classList.contains && e.classList.contains(dt.replacementClass);
}
function Qle() {
  if (dt.autoReplaceSvg === !0)
    return j_.replace;
  var e = j_[dt.autoReplaceSvg];
  return e || j_.replace;
}
function Zle(e) {
  return ur.createElementNS("http://www.w3.org/2000/svg", e);
}
function eue(e) {
  return ur.createElement(e);
}
function gU(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.ceFn, r = n === void 0 ? e.tag === "svg" ? Zle : eue : n;
  if (typeof e == "string")
    return ur.createTextNode(e);
  var a = r(e.tag);
  Object.keys(e.attributes || []).forEach(function(l) {
    a.setAttribute(l, e.attributes[l]);
  });
  var s = e.children || [];
  return s.forEach(function(l) {
    a.appendChild(gU(l, {
      ceFn: r
    }));
  }), a;
}
function tue(e) {
  var t = " ".concat(e.outerHTML, " ");
  return t = "".concat(t, "Font Awesome fontawesome.com "), t;
}
var j_ = {
  replace: function(e) {
    var t = e[0];
    if (t.parentNode)
      if (e[1].forEach(function(r) {
        t.parentNode.insertBefore(gU(r), t);
      }), t.getAttribute(Dm) === null && dt.keepOriginalSource) {
        var n = ur.createComment(tue(t));
        t.parentNode.replaceChild(n, t);
      } else
        t.remove();
  },
  nest: function(e) {
    var t = e[0], n = e[1];
    if (~x4(t).indexOf(dt.replacementClass))
      return j_.replace(e);
    var r = new RegExp("".concat(dt.cssPrefix, "-.*"));
    if (delete n[0].attributes.id, n[0].attributes.class) {
      var a = n[0].attributes.class.split(" ").reduce(function(l, c) {
        return c === dt.replacementClass || c.match(r) ? l.toSvg.push(c) : l.toNode.push(c), l;
      }, {
        toNode: [],
        toSvg: []
      });
      n[0].attributes.class = a.toSvg.join(" "), a.toNode.length === 0 ? t.removeAttribute("class") : t.setAttribute("class", a.toNode.join(" "));
    }
    var s = n.map(function(l) {
      return tk(l);
    }).join(`
`);
    t.setAttribute(Dm, ""), t.innerHTML = s;
  }
};
function EI(e) {
  e();
}
function vU(e, t) {
  var n = typeof t == "function" ? t : R_;
  if (e.length === 0)
    n();
  else {
    var r = EI;
    dt.mutateApproach === ole && (r = Md.requestAnimationFrame || EI), r(function() {
      var a = Qle(), s = C4.begin("mutate");
      e.map(a), s(), n();
    });
  }
}
var O4 = !1;
function yU() {
  O4 = !0;
}
function r3() {
  O4 = !1;
}
var f2 = null;
function CI(e) {
  if (cI && dt.observeMutations) {
    var t = e.treeCallback, n = t === void 0 ? R_ : t, r = e.nodeCallback, a = r === void 0 ? R_ : r, s = e.pseudoElementsCallback, l = s === void 0 ? R_ : s, c = e.observeMutationsRoot, d = c === void 0 ? ur : c;
    f2 = new cI(function(f) {
      if (!O4) {
        var m = Nd();
        Lg(f).forEach(function(h) {
          if (h.type === "childList" && h.addedNodes.length > 0 && !_I(h.addedNodes[0]) && (dt.searchPseudoElements && l(h.target), n(h.target)), h.type === "attributes" && h.target.parentNode && dt.searchPseudoElements && l([h.target], !0), h.type === "attributes" && _I(h.target) && ~cle.indexOf(h.attributeName))
            if (h.attributeName === "class" && Xle(h.target)) {
              var v = zE(x4(h.target)), g = v.prefix, b = v.iconName;
              h.target.setAttribute(y4, g || m), b && h.target.setAttribute(b4, b);
            } else Jle(h.target) && a(h.target);
        });
      }
    }), Kc && f2.observe(d, {
      childList: !0,
      attributes: !0,
      characterData: !0,
      subtree: !0
    });
  }
}
function nue() {
  f2 && f2.disconnect();
}
function rue(e) {
  var t = e.getAttribute("style"), n = [];
  return t && (n = t.split(";").reduce(function(r, a) {
    var s = a.split(":"), l = s[0], c = s.slice(1);
    return l && c.length > 0 && (r[l] = c.join(":").trim()), r;
  }, {})), n;
}
function oue(e) {
  var t = e.getAttribute("data-prefix"), n = e.getAttribute("data-icon"), r = e.innerText !== void 0 ? e.innerText.trim() : "", a = zE(x4(e));
  return a.prefix || (a.prefix = Nd()), t && n && (a.prefix = t, a.iconName = n), a.iconName && a.prefix || (a.prefix && r.length > 0 && (a.iconName = Mle(a.prefix, e.innerText) || _4(a.prefix, oU(e.innerText))), !a.iconName && dt.autoFetchSvg && e.firstChild && e.firstChild.nodeType === Node.TEXT_NODE && (a.iconName = e.firstChild.data)), a;
}
function aue(e) {
  var t = Lg(e.attributes).reduce(function(n, r) {
    return n.name !== "class" && n.name !== "style" && (n[r.name] = r.value), n;
  }, {});
  return t;
}
function iue() {
  return {
    iconName: null,
    prefix: null,
    transform: Ol,
    symbol: !1,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function OI(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: !0
  }, n = oue(e), r = n.iconName, a = n.prefix, s = n.rest, l = aue(e), c = QA("parseNodeAttributes", {}, e), d = t.styleParser ? rue(e) : [];
  return De({
    iconName: r,
    prefix: a,
    transform: Ol,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: !1,
    extra: {
      classes: s,
      styles: d,
      attributes: l
    }
  }, c);
}
var sue = Gs.styles;
function bU(e) {
  var t = dt.autoReplaceSvg === "nest" ? OI(e, {
    styleParser: !1
  }) : OI(e);
  return ~t.extra.classes.indexOf(QB) ? Ad("generateLayersText", e, t) : Ad("generateSvgReplacementMutation", e, t);
}
function lue() {
  return [].concat(el(HB), el(WB));
}
function MI(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!Kc) return Promise.resolve();
  var n = ur.documentElement.classList, r = function(m) {
    return n.add("".concat(pI, "-").concat(m));
  }, a = function(m) {
    return n.remove("".concat(pI, "-").concat(m));
  }, s = dt.autoFetchSvg ? lue() : CB.concat(Object.keys(sue));
  s.includes("fa") || s.push("fa");
  var l = [".".concat(QB, ":not([").concat(Dm, "])")].concat(s.map(function(m) {
    return ".".concat(m, ":not([").concat(Dm, "])");
  })).join(", ");
  if (l.length === 0)
    return Promise.resolve();
  var c = [];
  try {
    c = Lg(e.querySelectorAll(l));
  } catch {
  }
  if (c.length > 0)
    r("pending"), a("complete");
  else
    return Promise.resolve();
  var d = C4.begin("onTree"), f = c.reduce(function(m, h) {
    try {
      var v = bU(h);
      v && m.push(v);
    } catch (g) {
      XB || g.name === "MissingIcon" && console.error(g);
    }
    return m;
  }, []);
  return new Promise(function(m, h) {
    Promise.all(f).then(function(v) {
      vU(v, function() {
        r("active"), r("complete"), a("pending"), typeof t == "function" && t(), d(), m();
      });
    }).catch(function(v) {
      d(), h(v);
    });
  });
}
function uue(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  bU(e).then(function(n) {
    n && vU([n], t);
  });
}
function cue(e) {
  return function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = (t || {}).icon ? t : ZA(t || {}), a = n.mask;
    return a && (a = (a || {}).icon ? a : ZA(a || {})), e(r, De(De({}, n), {}, {
      mask: a
    }));
  };
}
var due = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.transform, r = n === void 0 ? Ol : n, a = t.symbol, s = a === void 0 ? !1 : a, l = t.mask, c = l === void 0 ? null : l, d = t.maskId, f = d === void 0 ? null : d, m = t.classes, h = m === void 0 ? [] : m, v = t.attributes, g = v === void 0 ? {} : v, b = t.styles, x = b === void 0 ? {} : b;
  if (e) {
    var w = e.prefix, k = e.iconName, E = e.icon;
    return TE(De({
      type: "icon"
    }, e), function() {
      return Im("beforeDOMElementCreation", {
        iconDefinition: e,
        params: t
      }), E4({
        icons: {
          main: e3(E),
          mask: c ? e3(c.icon) : {
            found: !1,
            width: null,
            height: null,
            icon: {}
          }
        },
        prefix: w,
        iconName: k,
        transform: De(De({}, Ol), r),
        symbol: s,
        maskId: f,
        extra: {
          attributes: g,
          styles: x,
          classes: h
        }
      });
    });
  }
}, fue = {
  mixout: function() {
    return {
      icon: cue(due)
    };
  },
  hooks: function() {
    return {
      mutationObserverCallbacks: function(e) {
        return e.treeCallback = MI, e.nodeCallback = uue, e;
      }
    };
  },
  provides: function(e) {
    e.i2svg = function(t) {
      var n = t.node, r = n === void 0 ? ur : n, a = t.callback, s = a === void 0 ? function() {
      } : a;
      return MI(r, s);
    }, e.generateSvgReplacementMutation = function(t, n) {
      var r = n.iconName, a = n.prefix, s = n.transform, l = n.symbol, c = n.mask, d = n.maskId, f = n.extra;
      return new Promise(function(m, h) {
        Promise.all([t3(r, a), c.iconName ? t3(c.iconName, c.prefix) : Promise.resolve({
          found: !1,
          width: 512,
          height: 512,
          icon: {}
        })]).then(function(v) {
          var g = DE(v, 2), b = g[0], x = g[1];
          m([t, E4({
            icons: {
              main: b,
              mask: x
            },
            prefix: a,
            iconName: r,
            transform: s,
            symbol: l,
            maskId: d,
            extra: f,
            watchable: !0
          })]);
        }).catch(h);
      });
    }, e.generateAbstractIcon = function(t) {
      var n = t.children, r = t.attributes, a = t.main, s = t.transform, l = t.styles, c = IE(l);
      c.length > 0 && (r.style = c);
      var d;
      return S4(s) && (d = Ad("generateAbstractTransformGrouping", {
        main: a,
        transform: s,
        containerWidth: a.width,
        iconWidth: a.width
      })), n.push(d || a.icon), {
        children: n,
        attributes: r
      };
    };
  }
}, pue = {
  mixout: function() {
    return {
      layer: function(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.classes, r = n === void 0 ? [] : n;
        return TE({
          type: "layer"
        }, function() {
          Im("beforeDOMElementCreation", {
            assembler: e,
            params: t
          });
          var a = [];
          return e(function(s) {
            Array.isArray(s) ? s.map(function(l) {
              a = a.concat(l.abstract);
            }) : a = a.concat(s.abstract);
          }), [{
            tag: "span",
            attributes: {
              class: ["".concat(dt.cssPrefix, "-layers")].concat(el(r)).join(" ")
            },
            children: a
          }];
        });
      }
    };
  }
}, mue = {
  mixout: function() {
    return {
      counter: function(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        t.title;
        var n = t.classes, r = n === void 0 ? [] : n, a = t.attributes, s = a === void 0 ? {} : a, l = t.styles, c = l === void 0 ? {} : l;
        return TE({
          type: "counter",
          content: e
        }, function() {
          return Im("beforeDOMElementCreation", {
            content: e,
            params: t
          }), qle({
            content: e.toString(),
            extra: {
              attributes: s,
              styles: c,
              classes: ["".concat(dt.cssPrefix, "-layers-counter")].concat(el(r))
            }
          });
        });
      }
    };
  }
}, hue = {
  mixout: function() {
    return {
      text: function(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.transform, r = n === void 0 ? Ol : n, a = t.classes, s = a === void 0 ? [] : a, l = t.attributes, c = l === void 0 ? {} : l, d = t.styles, f = d === void 0 ? {} : d;
        return TE({
          type: "text",
          content: e
        }, function() {
          return Im("beforeDOMElementCreation", {
            content: e,
            params: t
          }), SI({
            content: e,
            transform: De(De({}, Ol), r),
            extra: {
              attributes: c,
              styles: f,
              classes: ["".concat(dt.cssPrefix, "-layers-text")].concat(el(s))
            }
          });
        });
      }
    };
  },
  provides: function(e) {
    e.generateLayersText = function(t, n) {
      var r = n.transform, a = n.extra, s = null, l = null;
      if (_B) {
        var c = parseInt(getComputedStyle(t).fontSize, 10), d = t.getBoundingClientRect();
        s = d.width / c, l = d.height / c;
      }
      return Promise.resolve([t, SI({
        content: t.innerHTML,
        width: s,
        height: l,
        transform: r,
        extra: a,
        watchable: !0
      })]);
    };
  }
}, wU = new RegExp('"', "ug"), NI = [1105920, 1112319], AI = De(De(De(De({}, {
  FontAwesome: {
    normal: "fas",
    400: "fas"
  }
}), Jie), nle), ise), o3 = Object.keys(AI).reduce(function(e, t) {
  return e[t.toLowerCase()] = AI[t], e;
}, {}), gue = Object.keys(o3).reduce(function(e, t) {
  var n = o3[t];
  return e[t] = n[900] || el(Object.entries(n))[0][1], e;
}, {});
function vue(e) {
  var t = e.replace(wU, "");
  return oU(el(t)[0] || "");
}
function yue(e) {
  var t = e.getPropertyValue("font-feature-settings").includes("ss01"), n = e.getPropertyValue("content"), r = n.replace(wU, ""), a = r.codePointAt(0), s = a >= NI[0] && a <= NI[1], l = r.length === 2 ? r[0] === r[1] : !1;
  return s || l || t;
}
function bue(e, t) {
  var n = e.replace(/^['"]|['"]$/g, "").toLowerCase(), r = parseInt(t), a = isNaN(r) ? "normal" : r;
  return (o3[n] || {})[a] || gue[n];
}
function RI(e, t) {
  var n = "".concat(rle).concat(t.replace(":", "-"));
  return new Promise(function(r, a) {
    if (e.getAttribute(n) !== null)
      return r();
    var s = Lg(e.children), l = s.filter(function(A) {
      return A.getAttribute(GA) === t;
    })[0], c = Md.getComputedStyle(e, t), d = c.getPropertyValue("font-family"), f = d.match(lle), m = c.getPropertyValue("font-weight"), h = c.getPropertyValue("content");
    if (l && !f)
      return e.removeChild(l), r();
    if (f && h !== "none" && h !== "") {
      var v = c.getPropertyValue("content"), g = bue(d, m), b = vue(v), x = f[0].startsWith("FontAwesome"), w = yue(c), k = _4(g, b), E = k;
      if (x) {
        var _ = Nle(b);
        _.iconName && _.prefix && (k = _.iconName, g = _.prefix);
      }
      if (k && !w && (!l || l.getAttribute(y4) !== g || l.getAttribute(b4) !== E)) {
        e.setAttribute(n, E), l && e.removeChild(l);
        var O = iue(), N = O.extra;
        N.attributes[GA] = t, t3(k, g).then(function(A) {
          var R = E4(De(De({}, O), {}, {
            icons: {
              main: A,
              mask: pU()
            },
            prefix: g,
            iconName: E,
            extra: N,
            watchable: !0
          })), D = ur.createElementNS("http://www.w3.org/2000/svg", "svg");
          t === "::before" ? e.insertBefore(D, e.firstChild) : e.appendChild(D), D.outerHTML = R.map(function(I) {
            return tk(I);
          }).join(`
`), e.removeAttribute(n), r();
        }).catch(a);
      } else
        r();
    } else
      r();
  });
}
function wue(e) {
  return Promise.all([RI(e, "::before"), RI(e, "::after")]);
}
function xue(e) {
  return e.parentNode !== document.head && !~ale.indexOf(e.tagName.toUpperCase()) && !e.getAttribute(GA) && (!e.parentNode || e.parentNode.tagName !== "svg");
}
var Sue = function(e) {
  return !!e && YB.some(function(t) {
    return e.includes(t);
  });
}, kue = function(e) {
  if (!e) return [];
  var t = /* @__PURE__ */ new Set(), n = e.split(/,(?![^()]*\))/).map(function(c) {
    return c.trim();
  });
  n = n.flatMap(function(c) {
    return c.includes("(") ? c : c.split(",").map(function(d) {
      return d.trim();
    });
  });
  var r = A_(n), a;
  try {
    for (r.s(); !(a = r.n()).done; ) {
      var s = a.value;
      if (Sue(s)) {
        var l = YB.reduce(function(c, d) {
          return c.replace(d, "");
        }, s);
        l !== "" && l !== "*" && t.add(l);
      }
    }
  } catch (c) {
    r.e(c);
  } finally {
    r.f();
  }
  return t;
};
function jI(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  if (Kc) {
    var n;
    if (t)
      n = e;
    else if (dt.searchPseudoElementsFullScan)
      n = e.querySelectorAll("*");
    else {
      var r = /* @__PURE__ */ new Set(), a = A_(document.styleSheets), s;
      try {
        for (a.s(); !(s = a.n()).done; ) {
          var l = s.value;
          try {
            var c = A_(l.cssRules), d;
            try {
              for (c.s(); !(d = c.n()).done; ) {
                var f = d.value, m = kue(f.selectorText), h = A_(m), v;
                try {
                  for (h.s(); !(v = h.n()).done; ) {
                    var g = v.value;
                    r.add(g);
                  }
                } catch (x) {
                  h.e(x);
                } finally {
                  h.f();
                }
              }
            } catch (x) {
              c.e(x);
            } finally {
              c.f();
            }
          } catch (x) {
            dt.searchPseudoElementsWarnings && console.warn("Font Awesome: cannot parse stylesheet: ".concat(l.href, " (").concat(x.message, `)
If it declares any Font Awesome CSS pseudo-elements, they will not be rendered as SVG icons. Add crossorigin="anonymous" to the <link>, enable searchPseudoElementsFullScan for slower but more thorough DOM parsing, or suppress this warning by setting searchPseudoElementsWarnings to false.`));
          }
        }
      } catch (x) {
        a.e(x);
      } finally {
        a.f();
      }
      if (!r.size) return;
      var b = Array.from(r).join(", ");
      try {
        n = e.querySelectorAll(b);
      } catch {
      }
    }
    return new Promise(function(x, w) {
      var k = Lg(n).filter(xue).map(wue), E = C4.begin("searchPseudoElements");
      yU(), Promise.all(k).then(function() {
        E(), r3(), x();
      }).catch(function() {
        E(), r3(), w();
      });
    });
  }
}
var _ue = {
  hooks: function() {
    return {
      mutationObserverCallbacks: function(e) {
        return e.pseudoElementsCallback = jI, e;
      }
    };
  },
  provides: function(e) {
    e.pseudoElements2svg = function(t) {
      var n = t.node, r = n === void 0 ? ur : n;
      dt.searchPseudoElements && jI(r);
    };
  }
}, PI = !1, Eue = {
  mixout: function() {
    return {
      dom: {
        unwatch: function() {
          yU(), PI = !0;
        }
      }
    };
  },
  hooks: function() {
    return {
      bootstrap: function() {
        CI(QA("mutationObserverCallbacks", {}));
      },
      noAuto: function() {
        nue();
      },
      watch: function(e) {
        var t = e.observeMutationsRoot;
        PI ? r3() : CI(QA("mutationObserverCallbacks", {
          observeMutationsRoot: t
        }));
      }
    };
  }
}, DI = function(e) {
  var t = {
    size: 16,
    x: 0,
    y: 0,
    flipX: !1,
    flipY: !1,
    rotate: 0
  };
  return e.toLowerCase().split(" ").reduce(function(n, r) {
    var a = r.toLowerCase().split("-"), s = a[0], l = a.slice(1).join("-");
    if (s && l === "h")
      return n.flipX = !0, n;
    if (s && l === "v")
      return n.flipY = !0, n;
    if (l = parseFloat(l), isNaN(l))
      return n;
    switch (s) {
      case "grow":
        n.size = n.size + l;
        break;
      case "shrink":
        n.size = n.size - l;
        break;
      case "left":
        n.x = n.x - l;
        break;
      case "right":
        n.x = n.x + l;
        break;
      case "up":
        n.y = n.y - l;
        break;
      case "down":
        n.y = n.y + l;
        break;
      case "rotate":
        n.rotate = n.rotate + l;
        break;
    }
    return n;
  }, t);
}, Cue = {
  mixout: function() {
    return {
      parse: {
        transform: function(e) {
          return DI(e);
        }
      }
    };
  },
  hooks: function() {
    return {
      parseNodeAttributes: function(e, t) {
        var n = t.getAttribute("data-fa-transform");
        return n && (e.transform = DI(n)), e;
      }
    };
  },
  provides: function(e) {
    e.generateAbstractTransformGrouping = function(t) {
      var n = t.main, r = t.transform, a = t.containerWidth, s = t.iconWidth, l = {
        transform: "translate(".concat(a / 2, " 256)")
      }, c = "translate(".concat(r.x * 32, ", ").concat(r.y * 32, ") "), d = "scale(".concat(r.size / 16 * (r.flipX ? -1 : 1), ", ").concat(r.size / 16 * (r.flipY ? -1 : 1), ") "), f = "rotate(".concat(r.rotate, " 0 0)"), m = {
        transform: "".concat(c, " ").concat(d, " ").concat(f)
      }, h = {
        transform: "translate(".concat(s / 2 * -1, " -256)")
      }, v = {
        outer: l,
        inner: m,
        path: h
      };
      return {
        tag: "g",
        attributes: De({}, v.outer),
        children: [{
          tag: "g",
          attributes: De({}, v.inner),
          children: [{
            tag: n.icon.tag,
            children: n.icon.children,
            attributes: De(De({}, n.icon.attributes), v.path)
          }]
        }]
      };
    };
  }
}, LN = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function II(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return e.attributes && (e.attributes.fill || t) && (e.attributes.fill = "black"), e;
}
function Oue(e) {
  return e.tag === "g" ? e.children : [e];
}
var Mue = {
  hooks: function() {
    return {
      parseNodeAttributes: function(e, t) {
        var n = t.getAttribute("data-fa-mask"), r = n ? zE(n.split(" ").map(function(a) {
          return a.trim();
        })) : pU();
        return r.prefix || (r.prefix = Nd()), e.mask = r, e.maskId = t.getAttribute("data-fa-mask-id"), e;
      }
    };
  },
  provides: function(e) {
    e.generateAbstractMask = function(t) {
      var n = t.children, r = t.attributes, a = t.main, s = t.mask, l = t.maskId, c = t.transform, d = a.width, f = a.icon, m = s.width, h = s.icon, v = ble({
        transform: c,
        containerWidth: m,
        iconWidth: d
      }), g = {
        tag: "rect",
        attributes: De(De({}, LN), {}, {
          fill: "white"
        })
      }, b = f.children ? {
        children: f.children.map(II)
      } : {}, x = {
        tag: "g",
        attributes: De({}, v.inner),
        children: [II(De({
          tag: f.tag,
          attributes: De(De({}, f.attributes), v.path)
        }, b))]
      }, w = {
        tag: "g",
        attributes: De({}, v.outer),
        children: [x]
      }, k = "mask-".concat(l || hI()), E = "clip-".concat(l || hI()), _ = {
        tag: "mask",
        attributes: De(De({}, LN), {}, {
          id: k,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        }),
        children: [g, w]
      }, O = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: E
          },
          children: Oue(h)
        }, _]
      };
      return n.push(O, {
        tag: "rect",
        attributes: De({
          fill: "currentColor",
          "clip-path": "url(#".concat(E, ")"),
          mask: "url(#".concat(k, ")")
        }, LN)
      }), {
        children: n,
        attributes: r
      };
    };
  }
}, Nue = {
  provides: function(e) {
    var t = !1;
    Md.matchMedia && (t = Md.matchMedia("(prefers-reduced-motion: reduce)").matches), e.missingIconAbstract = function() {
      var n = [], r = {
        fill: "currentColor"
      }, a = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      n.push({
        tag: "path",
        attributes: De(De({}, r), {}, {
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        })
      });
      var s = De(De({}, a), {}, {
        attributeName: "opacity"
      }), l = {
        tag: "circle",
        attributes: De(De({}, r), {}, {
          cx: "256",
          cy: "364",
          r: "28"
        }),
        children: []
      };
      return t || l.children.push({
        tag: "animate",
        attributes: De(De({}, a), {}, {
          attributeName: "r",
          values: "28;14;28;28;14;28;"
        })
      }, {
        tag: "animate",
        attributes: De(De({}, s), {}, {
          values: "1;0;1;1;0;1;"
        })
      }), n.push(l), n.push({
        tag: "path",
        attributes: De(De({}, r), {}, {
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        }),
        children: t ? [] : [{
          tag: "animate",
          attributes: De(De({}, s), {}, {
            values: "1;0;0;0;0;1;"
          })
        }]
      }), t || n.push({
        tag: "path",
        attributes: De(De({}, r), {}, {
          opacity: "0",
          d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
        }),
        children: [{
          tag: "animate",
          attributes: De(De({}, s), {}, {
            values: "0;0;1;1;0;0;"
          })
        }]
      }), {
        tag: "g",
        attributes: {
          class: "missing"
        },
        children: n
      };
    };
  }
}, Aue = {
  hooks: function() {
    return {
      parseNodeAttributes: function(e, t) {
        var n = t.getAttribute("data-fa-symbol"), r = n === null ? !1 : n === "" ? !0 : n;
        return e.symbol = r, e;
      }
    };
  }
}, Rue = [Sle, fue, pue, mue, hue, _ue, Eue, Cue, Mue, Nue, Aue];
Tle(Rue, {
  mixoutsTo: Ai
});
Ai.noAuto;
var hg = Ai.config;
Ai.library;
Ai.dom;
var xU = Ai.parse;
Ai.findIconDefinition;
Ai.toHtml;
var jue = Ai.icon;
Ai.layer;
Ai.text;
Ai.counter;
function Pue(e) {
  return e = e - 0, e === e;
}
function SU(e) {
  return Pue(e) ? e : (e = e.replace(/[_-]+(.)?/g, (t, n) => n ? n.toUpperCase() : ""), e.charAt(0).toLowerCase() + e.slice(1));
}
function Due(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
var Sh = /* @__PURE__ */ new Map(), Iue = 1e3;
function $ue(e) {
  if (Sh.has(e))
    return Sh.get(e);
  const t = {};
  let n = 0;
  const r = e.length;
  for (; n < r; ) {
    const a = e.indexOf(";", n), s = a === -1 ? r : a, l = e.slice(n, s).trim();
    if (l) {
      const c = l.indexOf(":");
      if (c > 0) {
        const d = l.slice(0, c).trim(), f = l.slice(c + 1).trim();
        if (d && f) {
          const m = SU(d);
          t[m.startsWith("webkit") ? Due(m) : m] = f;
        }
      }
    }
    n = s + 1;
  }
  if (Sh.size === Iue) {
    const a = Sh.keys().next().value;
    a && Sh.delete(a);
  }
  return Sh.set(e, t), t;
}
function kU(e, t, n = {}) {
  if (typeof t == "string")
    return t;
  const r = (t.children || []).map((m) => kU(e, m)), a = t.attributes || {}, s = {};
  for (const [m, h] of Object.entries(a))
    switch (!0) {
      case m === "class": {
        s.className = h;
        break;
      }
      case m === "style": {
        s.style = $ue(String(h));
        break;
      }
      case m.startsWith("aria-"):
      case m.startsWith("data-"): {
        s[m.toLowerCase()] = h;
        break;
      }
      default:
        s[SU(m)] = h;
    }
  const {
    style: l,
    role: c,
    "aria-label": d,
    ...f
  } = n;
  return l && (s.style = s.style ? { ...s.style, ...l } : l), c && (s.role = c), d && (s["aria-label"] = d, s["aria-hidden"] = "false"), e(t.tag, { ...f, ...s }, ...r);
}
var zue = kU.bind(null, jt.createElement), $I = (e, t) => {
  const n = M.useId();
  return e || (t ? n : void 0);
}, Tue = class {
  constructor(e = "react-fontawesome") {
    this.enabled = !1;
    let t = !1;
    try {
      t = typeof process < "u" && !1;
    } catch {
    }
    this.scope = e, this.enabled = t;
  }
  /**
   * Logs messages to the console if not in production.
   * @param args - The message and/or data to log.
   */
  log(...e) {
    this.enabled && console.log(`[${this.scope}]`, ...e);
  }
  /**
   * Logs warnings to the console if not in production.
   * @param args - The warning message and/or data to log.
   */
  warn(...e) {
    this.enabled && console.warn(`[${this.scope}]`, ...e);
  }
  /**
   * Logs errors to the console if not in production.
   * @param args - The error message and/or data to log.
   */
  error(...e) {
    this.enabled && console.error(`[${this.scope}]`, ...e);
  }
};
typeof process < "u" && process.env.FA_VERSION;
var Lue = (
  // @ts-expect-error TS2872 - Expression is always truthy - This is true when v7 of SVGCore is used, but not when v6 is used.
  // This is the point of this check - if the property exists on config, we have v7, otherwise we have v6.
  // TS is checking this against the dev dependencies which uses v7, so it reports a false error here.
  "searchPseudoElementsFullScan" in hg ? "7.0.0" : "6.0.0"
), Fue = Number.parseInt(Lue) >= 7, Dx = "fa", vc = {
  beat: "fa-beat",
  fade: "fa-fade",
  beatFade: "fa-beat-fade",
  bounce: "fa-bounce",
  shake: "fa-shake",
  spin: "fa-spin",
  spinPulse: "fa-spin-pulse",
  spinReverse: "fa-spin-reverse",
  pulse: "fa-pulse"
}, Bue = {
  left: "fa-pull-left",
  right: "fa-pull-right"
}, Uue = {
  90: "fa-rotate-90",
  180: "fa-rotate-180",
  270: "fa-rotate-270"
}, Vue = {
  "2xs": "fa-2xs",
  xs: "fa-xs",
  sm: "fa-sm",
  lg: "fa-lg",
  xl: "fa-xl",
  "2xl": "fa-2xl",
  "1x": "fa-1x",
  "2x": "fa-2x",
  "3x": "fa-3x",
  "4x": "fa-4x",
  "5x": "fa-5x",
  "6x": "fa-6x",
  "7x": "fa-7x",
  "8x": "fa-8x",
  "9x": "fa-9x",
  "10x": "fa-10x"
}, yc = {
  border: "fa-border",
  /** @deprecated */
  fixedWidth: "fa-fw",
  flip: "fa-flip",
  flipHorizontal: "fa-flip-horizontal",
  flipVertical: "fa-flip-vertical",
  inverse: "fa-inverse",
  rotateBy: "fa-rotate-by",
  swapOpacity: "fa-swap-opacity",
  widthAuto: "fa-width-auto"
};
function Hue(e) {
  const t = hg.cssPrefix || hg.familyPrefix || Dx;
  return t === Dx ? e : e.replace(
    new RegExp(String.raw`(?<=^|\s)${Dx}-`, "g"),
    `${t}-`
  );
}
function Wue(e) {
  const {
    beat: t,
    fade: n,
    beatFade: r,
    bounce: a,
    shake: s,
    spin: l,
    spinPulse: c,
    spinReverse: d,
    pulse: f,
    fixedWidth: m,
    inverse: h,
    border: v,
    flip: g,
    size: b,
    rotation: x,
    pull: w,
    swapOpacity: k,
    rotateBy: E,
    widthAuto: _,
    className: O
  } = e, N = [];
  return O && N.push(...O.split(" ")), t && N.push(vc.beat), n && N.push(vc.fade), r && N.push(vc.beatFade), a && N.push(vc.bounce), s && N.push(vc.shake), l && N.push(vc.spin), d && N.push(vc.spinReverse), c && N.push(vc.spinPulse), f && N.push(vc.pulse), m && N.push(yc.fixedWidth), h && N.push(yc.inverse), v && N.push(yc.border), g === !0 && N.push(yc.flip), (g === "horizontal" || g === "both") && N.push(yc.flipHorizontal), (g === "vertical" || g === "both") && N.push(yc.flipVertical), b != null && N.push(Vue[b]), x != null && x !== 0 && N.push(Uue[x]), w != null && N.push(Bue[w]), k && N.push(yc.swapOpacity), Fue ? (E && N.push(yc.rotateBy), _ && N.push(yc.widthAuto), (hg.cssPrefix || hg.familyPrefix || Dx) === Dx ? N : (
    // TODO: see if we can achieve custom prefix support without iterating
    // eslint-disable-next-line unicorn/no-array-callback-reference
    N.map(Hue)
  )) : N;
}
var que = (e) => typeof e == "object" && "icon" in e && !!e.icon;
function zI(e) {
  if (e)
    return que(e) ? e : xU.icon(e);
}
function Gue(e) {
  return Object.keys(e);
}
var TI = new Tue("FontAwesomeIcon"), _U = {
  border: !1,
  className: "",
  mask: void 0,
  maskId: void 0,
  fixedWidth: !1,
  inverse: !1,
  flip: !1,
  icon: void 0,
  listItem: !1,
  pull: void 0,
  pulse: !1,
  rotation: void 0,
  rotateBy: !1,
  size: void 0,
  spin: !1,
  spinPulse: !1,
  spinReverse: !1,
  beat: !1,
  fade: !1,
  beatFade: !1,
  bounce: !1,
  shake: !1,
  symbol: !1,
  title: "",
  titleId: void 0,
  transform: void 0,
  swapOpacity: !1,
  widthAuto: !1
}, Kue = new Set(Object.keys(_U)), EU = jt.forwardRef((e, t) => {
  const n = { ..._U, ...e }, {
    icon: r,
    mask: a,
    symbol: s,
    title: l,
    titleId: c,
    maskId: d,
    transform: f
  } = n, m = $I(d, !!a), h = $I(c, !!l), v = zI(r);
  if (!v)
    return TI.error("Icon lookup is undefined", r), null;
  const g = Wue(n), b = typeof f == "string" ? xU.transform(f) : f, x = zI(a), w = jue(v, {
    ...g.length > 0 && { classes: g },
    ...b && { transform: b },
    ...x && { mask: x },
    symbol: s,
    title: l,
    titleId: h,
    maskId: m
  });
  if (!w)
    return TI.error("Could not find icon", v), null;
  const { abstract: k } = w, E = { ref: t };
  for (const _ of Gue(n))
    Kue.has(_) || (E[_] = n[_]);
  return zue(k[0], E);
});
EU.displayName = "FontAwesomeIcon";
var Yue = {
  prefix: "fas",
  iconName: "magnifying-glass",
  icon: [512, 512, [128269, "search"], "f002", "M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376C296.3 401.1 253.9 416 208 416 93.1 416 0 322.9 0 208S93.1 0 208 0 416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"]
}, Xue = {
  prefix: "fas",
  iconName: "chevron-up",
  icon: [448, 512, [], "f077", "M201.4 105.4c12.5-12.5 32.8-12.5 45.3 0l192 192c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L224 173.3 54.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l192-192z"]
}, Jue = {
  prefix: "fas",
  iconName: "expand",
  icon: [448, 512, [], "f065", "M32 32C14.3 32 0 46.3 0 64l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 32zM64 352c0-17.7-14.3-32-32-32S0 334.3 0 352l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 32c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM448 352c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96z"]
}, Que = {
  prefix: "fas",
  iconName: "chevron-right",
  icon: [320, 512, [9002], "f054", "M311.1 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L243.2 256 73.9 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z"]
}, Zue = {
  prefix: "fas",
  iconName: "circle-xmark",
  icon: [512, 512, [61532, "times-circle", "xmark-circle"], "f057", "M256 512a256 256 0 1 0 0-512 256 256 0 1 0 0 512zM167 167c9.4-9.4 24.6-9.4 33.9 0l55 55 55-55c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-55 55 55 55c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-55-55-55 55c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l55-55-55-55c-9.4-9.4-9.4-24.6 0-33.9z"]
}, ece = {
  prefix: "fas",
  iconName: "network-wired",
  icon: [576, 512, [], "f6ff", "M248 88l80 0 0 48-80 0 0-48zm-8-56c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l16 0 0 32-224 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0 0 32-16 0c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l96 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-16 0 0-32 192 0 0 32-16 0c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l96 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-16 0 0-32 96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-224 0 0-32 16 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-96 0zM448 376l8 0 0 48-80 0 0-48 72 0zm-256 0l8 0 0 48-80 0 0-48 72 0z"]
}, tce = {
  prefix: "fas",
  iconName: "gear",
  icon: [512, 512, [9881, "cog"], "f013", "M195.1 9.5C198.1-5.3 211.2-16 226.4-16l59.8 0c15.2 0 28.3 10.7 31.3 25.5L332 79.5c14.1 6 27.3 13.7 39.3 22.8l67.8-22.5c14.4-4.8 30.2 1.2 37.8 14.4l29.9 51.8c7.6 13.2 4.9 29.8-6.5 39.9L447 233.3c.9 7.4 1.3 15 1.3 22.7s-.5 15.3-1.3 22.7l53.4 47.5c11.4 10.1 14 26.8 6.5 39.9l-29.9 51.8c-7.6 13.1-23.4 19.2-37.8 14.4l-67.8-22.5c-12.1 9.1-25.3 16.7-39.3 22.8l-14.4 69.9c-3.1 14.9-16.2 25.5-31.3 25.5l-59.8 0c-15.2 0-28.3-10.7-31.3-25.5l-14.4-69.9c-14.1-6-27.2-13.7-39.3-22.8L73.5 432.3c-14.4 4.8-30.2-1.2-37.8-14.4L5.8 366.1c-7.6-13.2-4.9-29.8 6.5-39.9l53.4-47.5c-.9-7.4-1.3-15-1.3-22.7s.5-15.3 1.3-22.7L12.3 185.8c-11.4-10.1-14-26.8-6.5-39.9L35.7 94.1c7.6-13.2 23.4-19.2 37.8-14.4l67.8 22.5c12.1-9.1 25.3-16.7 39.3-22.8L195.1 9.5zM256.3 336a80 80 0 1 0 -.6-160 80 80 0 1 0 .6 160z"]
}, nce = {
  prefix: "fas",
  iconName: "up-right-and-down-left-from-center",
  icon: [512, 512, ["expand-alt"], "f424", "M344 0L488 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39-87 87c-9.4 9.4-24.6 9.4-33.9 0l-32-32c-9.4-9.4-9.4-24.6 0-33.9l87-87-39-39c-6.9-6.9-8.9-17.2-5.2-26.2S334.3 0 344 0zM168 512L24 512c-13.3 0-24-10.7-24-24L0 344c0-9.7 5.8-18.5 14.8-22.2S34.1 320.2 41 327l39 39 87-87c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2S177.7 512 168 512z"]
}, rce = {
  prefix: "fas",
  iconName: "xmark",
  icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M55.1 73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L147.2 256 9.9 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192.5 301.3 329.9 438.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.8 256 375.1 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192.5 210.7 55.1 73.4z"]
}, oce = {
  prefix: "fas",
  iconName: "lock-open",
  icon: [576, 512, [], "f3c1", "M384 96c0-35.3 28.7-64 64-64s64 28.7 64 64l0 32c0 17.7 14.3 32 32 32s32-14.3 32-32l0-32c0-70.7-57.3-128-128-128S320 25.3 320 96l0 64-160 0c-35.3 0-64 28.7-64 64l0 224c0 35.3 28.7 64 64 64l256 0c35.3 0 64-28.7 64-64l0-224c0-35.3-28.7-64-64-64l-32 0 0-64z"]
}, ace = {
  prefix: "fas",
  iconName: "circle-check",
  icon: [512, 512, [61533, "check-circle"], "f058", "M256 512a256 256 0 1 1 0-512 256 256 0 1 1 0 512zM374 145.7c-10.7-7.8-25.7-5.4-33.5 5.3L221.1 315.2 169 263.1c-9.4-9.4-24.6-9.4-33.9 0s-9.4 24.6 0 33.9l72 72c5 5 11.8 7.5 18.8 7s13.4-4.1 17.5-9.8L379.3 179.2c7.8-10.7 5.4-25.7-5.3-33.5z"]
}, ice = {
  prefix: "fas",
  iconName: "circle-play",
  icon: [512, 512, [61469, "play-circle"], "f144", "M0 256a256 256 0 1 1 512 0 256 256 0 1 1 -512 0zM188.3 147.1c-7.6 4.2-12.3 12.3-12.3 20.9l0 176c0 8.7 4.7 16.7 12.3 20.9s16.8 4.1 24.3-.5l144-88c7.1-4.4 11.5-12.1 11.5-20.5s-4.4-16.1-11.5-20.5l-144-88c-7.4-4.5-16.7-4.7-24.3-.5z"]
}, sce = {
  prefix: "fas",
  iconName: "chevron-down",
  icon: [448, 512, [], "f078", "M201.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 338.7 54.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"]
}, lce = {
  prefix: "fas",
  iconName: "chevron-left",
  icon: [320, 512, [9001], "f053", "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z"]
}, uce = {
  prefix: "fas",
  iconName: "lock",
  icon: [384, 512, [128274], "f023", "M128 96l0 64 128 0 0-64c0-35.3-28.7-64-64-64s-64 28.7-64 64zM64 160l0-64C64 25.3 121.3-32 192-32S320 25.3 320 96l0 64c35.3 0 64 28.7 64 64l0 224c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 224c0-35.3 28.7-64 64-64z"]
}, cce = {
  prefix: "fas",
  iconName: "down-left-and-up-right-to-center",
  icon: [512, 512, ["compress-alt"], "f422", "M439.5 7c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2S450.2 240 440.5 240l-144 0c-13.3 0-24-10.7-24-24l0-144c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2l39 39 87-87zM72.5 272l144 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39-87 87c-9.4 9.4-24.6 9.4-33.9 0l-32-32c-9.4-9.4-9.4-24.6 0-33.9l87-87-39-39c-6.9-6.9-8.9-17.2-5.2-26.2S62.8 272 72.5 272z"]
}, dce = {
  prefix: "fas",
  iconName: "compress",
  icon: [448, 512, [], "f066", "M160 64c0-17.7-14.3-32-32-32S96 46.3 96 64l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96zM32 320c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM352 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 320c-17.7 0-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0z"]
}, fce = {
  prefix: "fas",
  iconName: "bars",
  icon: [448, 512, ["navicon"], "f0c9", "M0 96C0 78.3 14.3 64 32 64l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 128C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 288c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32L32 448c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"]
};
hg.autoAddCss = !1;
const so = (e) => {
  const { style: t, ...n } = e;
  return /* @__PURE__ */ C.jsx("span", { style: t, children: /* @__PURE__ */ C.jsx(EU, { ...n }) });
}, M4 = (e) => /* @__PURE__ */ C.jsx(so, { ...e, icon: fce }), aS = (e) => /* @__PURE__ */ C.jsx(so, { ...e, icon: Que }), p2 = (e) => /* @__PURE__ */ C.jsx(so, { ...e, icon: lce }), CU = (e) => /* @__PURE__ */ C.jsx(so, { ...e, icon: Jue }), pce = (e) => /* @__PURE__ */ C.jsx(so, { ...e, icon: dce }), mce = (e) => /* @__PURE__ */ C.jsx(so, { ...e, icon: cce }), hce = (e) => /* @__PURE__ */ C.jsx(so, { ...e, icon: nce }), m2 = (e) => /* @__PURE__ */ C.jsx(so, { ...e, icon: sce }), iS = (e) => /* @__PURE__ */ C.jsx(so, { ...e, icon: Xue }), nk = iS, LE = (e) => /* @__PURE__ */ C.jsx(so, { ...e, icon: rce }), gce = (e) => /* @__PURE__ */ C.jsx(so, { ...e, icon: oce }), vce = (e) => /* @__PURE__ */ C.jsx(so, { ...e, icon: uce }), yce = (e) => /* @__PURE__ */ C.jsx(so, { ...e, icon: ece }), bce = (e) => /* @__PURE__ */ C.jsx(so, { ...e, icon: ice }), wce = (e) => /* @__PURE__ */ C.jsx(so, { ...e, icon: Yue }), xce = (e) => /* @__PURE__ */ C.jsx(so, { ...e, icon: tce }), Sce = (e) => /* @__PURE__ */ C.jsx(so, { ...e, icon: ace }), kce = (e) => /* @__PURE__ */ C.jsx(so, { ...e, icon: Zue }), OU = M.createContext(null), Sn = () => {
  const e = M.useContext(OU);
  if (!e)
    throw new Error(
      "useFuncNodesContext must be used within a FuncNodesContext.Provider"
    );
  return e;
}, MU = M.createContext(
  void 0
), N4 = () => {
  const e = M.useContext(MU);
  if (!e)
    throw new Error("useKeyPress must be used within a KeyPressProvider");
  return e;
}, _ce = ({
  children: e,
  preventDefault: t = !1,
  ignoredKeys: n = [],
  debug: r = !1,
  target: a
}) => {
  const [s, l] = M.useState(/* @__PURE__ */ new Set()), c = M.useMemo(
    () => new Set(n),
    [n]
  ), d = M.useRef(s);
  d.current = s;
  const f = M.useMemo(
    () => ({
      keys: s,
      isKeyPressed: (m) => s.has(m),
      areKeysPressed: (...m) => m.every((h) => s.has(h)),
      isAnyKeyPressed: (...m) => m.some((h) => s.has(h))
    }),
    [s]
  );
  return M.useEffect(() => {
    const m = a ?? window;
    if (!m) return;
    const h = (x) => {
      const w = x.key;
      c.has(w) || (t && x.preventDefault(), d.current.has(w) || (r && console.log(`[KeyPress] Key down: ${w}`), l((k) => {
        const E = new Set(k);
        return E.add(w), E;
      })));
    }, v = (x) => {
      const w = x.key;
      d.current.has(w) && (r && console.log(`[KeyPress] Key up: ${w}`), l((k) => {
        const E = new Set(k);
        return E.delete(w), E;
      }));
    }, g = () => {
      d.current.size > 0 && (r && console.log("[KeyPress] Window blur - clearing all keys"), l(/* @__PURE__ */ new Set()));
    }, b = () => {
      document.hidden && d.current.size > 0 && (r && console.log("[KeyPress] Tab hidden - clearing all keys"), l(/* @__PURE__ */ new Set()));
    };
    return m.addEventListener("keydown", h), m.addEventListener("keyup", v), m.addEventListener("blur", g), document.addEventListener("visibilitychange", b), () => {
      m.removeEventListener("keydown", h), m.removeEventListener("keyup", v), m.removeEventListener("blur", g), document.removeEventListener("visibilitychange", b);
    };
  }, [t, c, r, a]), /* @__PURE__ */ C.jsx(MU.Provider, { value: f, children: e });
}, NU = M.createContext({
  colorTheme: "classic",
  setColorTheme: () => {
  },
  previewColorTheme: () => {
  }
}), Ece = ({
  available_themes: e,
  children: t,
  default_theme: n
}) => {
  const r = M.useMemo(
    () => new Set(e),
    [e]
  ), [a, s] = M.useState(
    n ?? e[0]
  ), l = M.useCallback(
    (f) => {
      if (!r.has(f))
        throw new Error(
          `Theme "${f}" is not in available_themes: [${Array.from(
            r
          ).join(", ")}]`
        );
      s(f);
      const m = {
        colorTheme: f
      };
      try {
        localStorage.setItem("theme", JSON.stringify(m));
      } catch (h) {
        console.warn("Failed to save theme to localStorage:", h);
      }
    },
    [r]
  ), c = M.useCallback(
    (f) => {
      if (!r.has(f))
        throw new Error(
          `Theme "${f}" is not in available_themes: [${Array.from(
            r
          ).join(", ")}]`
        );
      s(f);
    },
    [r]
  );
  M.useEffect(() => {
    document.documentElement.setAttribute("fn-data-color-theme", a);
  }, [a]), M.useEffect(() => {
    try {
      const f = localStorage.getItem("theme");
      if (!f) return;
      const m = JSON.parse(f);
      m.colorTheme && r.has(m.colorTheme) && s(m.colorTheme);
    } catch (f) {
      console.warn("Failed to load theme from localStorage:", f);
    }
  }, [r]), M.useEffect(() => {
    if (n && !r.has(n)) {
      const f = Array.from(r)[0];
      f && l(f);
    }
  }, [r, n, l]), M.useEffect(() => {
    if (!r.has(a)) {
      const f = Array.from(r)[0];
      f && l(f);
    }
  }, [a, r, l]);
  const d = M.useMemo(
    () => ({
      colorTheme: a,
      setColorTheme: l,
      previewColorTheme: c
    }),
    [a, l, c]
  );
  return /* @__PURE__ */ C.jsx(NU.Provider, { value: d, children: t });
}, AU = () => {
  const e = M.useContext(NU);
  if (!e)
    throw new Error("useTheme must be used within a ThemeProvider");
  return e;
}, RU = M.memo(({ button: e, index: t }) => {
  const n = M.useCallback(
    (a) => {
      a.preventDefault(), e.onClick(a);
    },
    [e]
  ), r = /* @__PURE__ */ C.jsx(
    "button",
    {
      className: `dialog-send-button ${e.className || ""}`,
      onClick: n,
      disabled: e.disabled,
      "aria-label": e.ariaLabel,
      type: "button",
      children: e.text
    }
  );
  return e.close !== !1 ? /* @__PURE__ */ C.jsx(bB, { asChild: !0, children: r }, t) : /* @__PURE__ */ C.jsx(M.Fragment, { children: r }, t);
});
RU.displayName = "DialogButton";
const Yl = M.memo(
  ({
    trigger: e,
    title: t,
    description: n,
    children: r,
    closebutton: a = !0,
    onOpenChange: s,
    buttons: l = [],
    open: c,
    setOpen: d,
    modal: f = !0,
    dialogClassName: m = "default-dialog-content",
    ariaLabel: h,
    ariaDescription: v
  }) => {
    const g = Sn().local_state((k) => k.funcnodescontainerRef), b = M.useMemo(
      () => `dialog-content funcnodescontainer ${m}`,
      [m]
    ), x = M.useCallback(
      (k) => {
        try {
          d?.(k), s?.(k);
        } catch (E) {
          console.error("Error in dialog open change handler:", E);
        }
      },
      [d, s]
    ), w = M.useMemo(
      () => l.map((k, E) => /* @__PURE__ */ C.jsx(
        RU,
        {
          button: k,
          index: E
        },
        `${k.text}-${E}`
      )),
      [l]
    );
    return /* @__PURE__ */ C.jsxs(die, { open: c, onOpenChange: x, modal: f, children: [
      e && /* @__PURE__ */ C.jsx(fie, { asChild: !0, children: e }),
      /* @__PURE__ */ C.jsxs(pie, { container: g, children: [
        /* @__PURE__ */ C.jsx(mie, { className: "dialog-overlay funcnodescontainer" }),
        /* @__PURE__ */ C.jsx(hie, { asChild: !0, ...n ? {} : { "aria-describedby": void 0 }, children: /* @__PURE__ */ C.jsxs(
          "div",
          {
            className: b,
            role: "dialog",
            "aria-label": h || t,
            "aria-description": v || (typeof n == "string" ? n : void 0),
            children: [
              /* @__PURE__ */ C.jsx(
                gie,
                {
                  className: `dialog-title${t ? "" : " dialog-title--visually-hidden"}`,
                  children: t || h || "Dialog"
                }
              ),
              n && /* @__PURE__ */ C.jsx(
                vie,
                {
                  className: "dialog-description",
                  children: n
                }
              ),
              /* @__PURE__ */ C.jsx("div", { className: "dialog-children", role: "main", children: r }),
              l.length > 0 && /* @__PURE__ */ C.jsx(
                "div",
                {
                  className: "dialog-buttons",
                  role: "group",
                  "aria-label": "Dialog actions",
                  children: w
                }
              ),
              a && /* @__PURE__ */ C.jsx(bB, { asChild: !0, children: /* @__PURE__ */ C.jsx(
                "button",
                {
                  className: "dialog-close-button",
                  "aria-label": "Close dialog",
                  type: "button",
                  children: /* @__PURE__ */ C.jsx(LE, {})
                }
              ) })
            ]
          }
        ) })
      ] })
    ] });
  }
);
Yl.displayName = "CustomDialog";
const Cce = ["top", "right", "bottom", "left"], Rd = Math.min, Si = Math.max, h2 = Math.round, Qk = Math.floor, Bl = (e) => ({
  x: e,
  y: e
}), Oce = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Mce = {
  start: "end",
  end: "start"
};
function a3(e, t, n) {
  return Si(e, Rd(t, n));
}
function Fc(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Bc(e) {
  return e.split("-")[0];
}
function Fg(e) {
  return e.split("-")[1];
}
function A4(e) {
  return e === "x" ? "y" : "x";
}
function R4(e) {
  return e === "y" ? "height" : "width";
}
const Nce = /* @__PURE__ */ new Set(["top", "bottom"]);
function Ml(e) {
  return Nce.has(Bc(e)) ? "y" : "x";
}
function j4(e) {
  return A4(Ml(e));
}
function Ace(e, t, n) {
  n === void 0 && (n = !1);
  const r = Fg(e), a = j4(e), s = R4(a);
  let l = a === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[s] > t.floating[s] && (l = g2(l)), [l, g2(l)];
}
function Rce(e) {
  const t = g2(e);
  return [i3(e), t, i3(t)];
}
function i3(e) {
  return e.replace(/start|end/g, (t) => Mce[t]);
}
const LI = ["left", "right"], FI = ["right", "left"], jce = ["top", "bottom"], Pce = ["bottom", "top"];
function Dce(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? FI : LI : t ? LI : FI;
    case "left":
    case "right":
      return t ? jce : Pce;
    default:
      return [];
  }
}
function Ice(e, t, n, r) {
  const a = Fg(e);
  let s = Dce(Bc(e), n === "start", r);
  return a && (s = s.map((l) => l + "-" + a), t && (s = s.concat(s.map(i3)))), s;
}
function g2(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Oce[t]);
}
function $ce(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function jU(e) {
  return typeof e != "number" ? $ce(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function v2(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: a
  } = e;
  return {
    width: r,
    height: a,
    top: n,
    left: t,
    right: t + r,
    bottom: n + a,
    x: t,
    y: n
  };
}
function BI(e, t, n) {
  let {
    reference: r,
    floating: a
  } = e;
  const s = Ml(t), l = j4(t), c = R4(l), d = Bc(t), f = s === "y", m = r.x + r.width / 2 - a.width / 2, h = r.y + r.height / 2 - a.height / 2, v = r[c] / 2 - a[c] / 2;
  let g;
  switch (d) {
    case "top":
      g = {
        x: m,
        y: r.y - a.height
      };
      break;
    case "bottom":
      g = {
        x: m,
        y: r.y + r.height
      };
      break;
    case "right":
      g = {
        x: r.x + r.width,
        y: h
      };
      break;
    case "left":
      g = {
        x: r.x - a.width,
        y: h
      };
      break;
    default:
      g = {
        x: r.x,
        y: r.y
      };
  }
  switch (Fg(t)) {
    case "start":
      g[l] -= v * (n && f ? -1 : 1);
      break;
    case "end":
      g[l] += v * (n && f ? -1 : 1);
      break;
  }
  return g;
}
const zce = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: a = "absolute",
    middleware: s = [],
    platform: l
  } = n, c = s.filter(Boolean), d = await (l.isRTL == null ? void 0 : l.isRTL(t));
  let f = await l.getElementRects({
    reference: e,
    floating: t,
    strategy: a
  }), {
    x: m,
    y: h
  } = BI(f, r, d), v = r, g = {}, b = 0;
  for (let x = 0; x < c.length; x++) {
    const {
      name: w,
      fn: k
    } = c[x], {
      x: E,
      y: _,
      data: O,
      reset: N
    } = await k({
      x: m,
      y: h,
      initialPlacement: r,
      placement: v,
      strategy: a,
      middlewareData: g,
      rects: f,
      platform: l,
      elements: {
        reference: e,
        floating: t
      }
    });
    m = E ?? m, h = _ ?? h, g = {
      ...g,
      [w]: {
        ...g[w],
        ...O
      }
    }, N && b <= 50 && (b++, typeof N == "object" && (N.placement && (v = N.placement), N.rects && (f = N.rects === !0 ? await l.getElementRects({
      reference: e,
      floating: t,
      strategy: a
    }) : N.rects), {
      x: m,
      y: h
    } = BI(f, v, d)), x = -1);
  }
  return {
    x: m,
    y: h,
    placement: v,
    strategy: a,
    middlewareData: g
  };
};
async function sS(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: a,
    platform: s,
    rects: l,
    elements: c,
    strategy: d
  } = e, {
    boundary: f = "clippingAncestors",
    rootBoundary: m = "viewport",
    elementContext: h = "floating",
    altBoundary: v = !1,
    padding: g = 0
  } = Fc(t, e), b = jU(g), x = c[v ? h === "floating" ? "reference" : "floating" : h], w = v2(await s.getClippingRect({
    element: (n = await (s.isElement == null ? void 0 : s.isElement(x))) == null || n ? x : x.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(c.floating)),
    boundary: f,
    rootBoundary: m,
    strategy: d
  })), k = h === "floating" ? {
    x: r,
    y: a,
    width: l.floating.width,
    height: l.floating.height
  } : l.reference, E = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(c.floating)), _ = await (s.isElement == null ? void 0 : s.isElement(E)) ? await (s.getScale == null ? void 0 : s.getScale(E)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, O = v2(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: c,
    rect: k,
    offsetParent: E,
    strategy: d
  }) : k);
  return {
    top: (w.top - O.top + b.top) / _.y,
    bottom: (O.bottom - w.bottom + b.bottom) / _.y,
    left: (w.left - O.left + b.left) / _.x,
    right: (O.right - w.right + b.right) / _.x
  };
}
const Tce = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: a,
      rects: s,
      platform: l,
      elements: c,
      middlewareData: d
    } = t, {
      element: f,
      padding: m = 0
    } = Fc(e, t) || {};
    if (f == null)
      return {};
    const h = jU(m), v = {
      x: n,
      y: r
    }, g = j4(a), b = R4(g), x = await l.getDimensions(f), w = g === "y", k = w ? "top" : "left", E = w ? "bottom" : "right", _ = w ? "clientHeight" : "clientWidth", O = s.reference[b] + s.reference[g] - v[g] - s.floating[b], N = v[g] - s.reference[g], A = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(f));
    let R = A ? A[_] : 0;
    (!R || !await (l.isElement == null ? void 0 : l.isElement(A))) && (R = c.floating[_] || s.floating[b]);
    const D = O / 2 - N / 2, I = R / 2 - x[b] / 2 - 1, z = Rd(h[k], I), B = Rd(h[E], I), P = z, H = R - x[b] - B, L = R / 2 - x[b] / 2 + D, G = a3(P, L, H), $ = !d.arrow && Fg(a) != null && L !== G && s.reference[b] / 2 - (L < P ? z : B) - x[b] / 2 < 0, K = $ ? L < P ? L - P : L - H : 0;
    return {
      [g]: v[g] + K,
      data: {
        [g]: G,
        centerOffset: L - G - K,
        ...$ && {
          alignmentOffset: K
        }
      },
      reset: $
    };
  }
}), Lce = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: a,
        middlewareData: s,
        rects: l,
        initialPlacement: c,
        platform: d,
        elements: f
      } = t, {
        mainAxis: m = !0,
        crossAxis: h = !0,
        fallbackPlacements: v,
        fallbackStrategy: g = "bestFit",
        fallbackAxisSideDirection: b = "none",
        flipAlignment: x = !0,
        ...w
      } = Fc(e, t);
      if ((n = s.arrow) != null && n.alignmentOffset)
        return {};
      const k = Bc(a), E = Ml(c), _ = Bc(c) === c, O = await (d.isRTL == null ? void 0 : d.isRTL(f.floating)), N = v || (_ || !x ? [g2(c)] : Rce(c)), A = b !== "none";
      !v && A && N.push(...Ice(c, x, b, O));
      const R = [c, ...N], D = await sS(t, w), I = [];
      let z = ((r = s.flip) == null ? void 0 : r.overflows) || [];
      if (m && I.push(D[k]), h) {
        const L = Ace(a, l, O);
        I.push(D[L[0]], D[L[1]]);
      }
      if (z = [...z, {
        placement: a,
        overflows: I
      }], !I.every((L) => L <= 0)) {
        var B, P;
        const L = (((B = s.flip) == null ? void 0 : B.index) || 0) + 1, G = R[L];
        if (G && (!(h === "alignment" && E !== Ml(G)) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        z.every((K) => K.overflows[0] > 0 && Ml(K.placement) === E)))
          return {
            data: {
              index: L,
              overflows: z
            },
            reset: {
              placement: G
            }
          };
        let $ = (P = z.filter((K) => K.overflows[0] <= 0).sort((K, q) => K.overflows[1] - q.overflows[1])[0]) == null ? void 0 : P.placement;
        if (!$)
          switch (g) {
            case "bestFit": {
              var H;
              const K = (H = z.filter((q) => {
                if (A) {
                  const Z = Ml(q.placement);
                  return Z === E || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Z === "y";
                }
                return !0;
              }).map((q) => [q.placement, q.overflows.filter((Z) => Z > 0).reduce((Z, V) => Z + V, 0)]).sort((q, Z) => q[1] - Z[1])[0]) == null ? void 0 : H[0];
              K && ($ = K);
              break;
            }
            case "initialPlacement":
              $ = c;
              break;
          }
        if (a !== $)
          return {
            reset: {
              placement: $
            }
          };
      }
      return {};
    }
  };
};
function UI(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function VI(e) {
  return Cce.some((t) => e[t] >= 0);
}
const Fce = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...a
      } = Fc(e, t);
      switch (r) {
        case "referenceHidden": {
          const s = await sS(t, {
            ...a,
            elementContext: "reference"
          }), l = UI(s, n.reference);
          return {
            data: {
              referenceHiddenOffsets: l,
              referenceHidden: VI(l)
            }
          };
        }
        case "escaped": {
          const s = await sS(t, {
            ...a,
            altBoundary: !0
          }), l = UI(s, n.floating);
          return {
            data: {
              escapedOffsets: l,
              escaped: VI(l)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, PU = /* @__PURE__ */ new Set(["left", "top"]);
async function Bce(e, t) {
  const {
    placement: n,
    platform: r,
    elements: a
  } = e, s = await (r.isRTL == null ? void 0 : r.isRTL(a.floating)), l = Bc(n), c = Fg(n), d = Ml(n) === "y", f = PU.has(l) ? -1 : 1, m = s && d ? -1 : 1, h = Fc(t, e);
  let {
    mainAxis: v,
    crossAxis: g,
    alignmentAxis: b
  } = typeof h == "number" ? {
    mainAxis: h,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: h.mainAxis || 0,
    crossAxis: h.crossAxis || 0,
    alignmentAxis: h.alignmentAxis
  };
  return c && typeof b == "number" && (g = c === "end" ? b * -1 : b), d ? {
    x: g * m,
    y: v * f
  } : {
    x: v * f,
    y: g * m
  };
}
const Uce = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: a,
        y: s,
        placement: l,
        middlewareData: c
      } = t, d = await Bce(t, e);
      return l === ((n = c.offset) == null ? void 0 : n.placement) && (r = c.arrow) != null && r.alignmentOffset ? {} : {
        x: a + d.x,
        y: s + d.y,
        data: {
          ...d,
          placement: l
        }
      };
    }
  };
}, Vce = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: a
      } = t, {
        mainAxis: s = !0,
        crossAxis: l = !1,
        limiter: c = {
          fn: (w) => {
            let {
              x: k,
              y: E
            } = w;
            return {
              x: k,
              y: E
            };
          }
        },
        ...d
      } = Fc(e, t), f = {
        x: n,
        y: r
      }, m = await sS(t, d), h = Ml(Bc(a)), v = A4(h);
      let g = f[v], b = f[h];
      if (s) {
        const w = v === "y" ? "top" : "left", k = v === "y" ? "bottom" : "right", E = g + m[w], _ = g - m[k];
        g = a3(E, g, _);
      }
      if (l) {
        const w = h === "y" ? "top" : "left", k = h === "y" ? "bottom" : "right", E = b + m[w], _ = b - m[k];
        b = a3(E, b, _);
      }
      const x = c.fn({
        ...t,
        [v]: g,
        [h]: b
      });
      return {
        ...x,
        data: {
          x: x.x - n,
          y: x.y - r,
          enabled: {
            [v]: s,
            [h]: l
          }
        }
      };
    }
  };
}, Hce = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: a,
        rects: s,
        middlewareData: l
      } = t, {
        offset: c = 0,
        mainAxis: d = !0,
        crossAxis: f = !0
      } = Fc(e, t), m = {
        x: n,
        y: r
      }, h = Ml(a), v = A4(h);
      let g = m[v], b = m[h];
      const x = Fc(c, t), w = typeof x == "number" ? {
        mainAxis: x,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...x
      };
      if (d) {
        const _ = v === "y" ? "height" : "width", O = s.reference[v] - s.floating[_] + w.mainAxis, N = s.reference[v] + s.reference[_] - w.mainAxis;
        g < O ? g = O : g > N && (g = N);
      }
      if (f) {
        var k, E;
        const _ = v === "y" ? "width" : "height", O = PU.has(Bc(a)), N = s.reference[h] - s.floating[_] + (O && ((k = l.offset) == null ? void 0 : k[h]) || 0) + (O ? 0 : w.crossAxis), A = s.reference[h] + s.reference[_] + (O ? 0 : ((E = l.offset) == null ? void 0 : E[h]) || 0) - (O ? w.crossAxis : 0);
        b < N ? b = N : b > A && (b = A);
      }
      return {
        [v]: g,
        [h]: b
      };
    }
  };
}, Wce = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: a,
        rects: s,
        platform: l,
        elements: c
      } = t, {
        apply: d = () => {
        },
        ...f
      } = Fc(e, t), m = await sS(t, f), h = Bc(a), v = Fg(a), g = Ml(a) === "y", {
        width: b,
        height: x
      } = s.floating;
      let w, k;
      h === "top" || h === "bottom" ? (w = h, k = v === (await (l.isRTL == null ? void 0 : l.isRTL(c.floating)) ? "start" : "end") ? "left" : "right") : (k = h, w = v === "end" ? "top" : "bottom");
      const E = x - m.top - m.bottom, _ = b - m.left - m.right, O = Rd(x - m[w], E), N = Rd(b - m[k], _), A = !t.middlewareData.shift;
      let R = O, D = N;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (D = _), (r = t.middlewareData.shift) != null && r.enabled.y && (R = E), A && !v) {
        const z = Si(m.left, 0), B = Si(m.right, 0), P = Si(m.top, 0), H = Si(m.bottom, 0);
        g ? D = b - 2 * (z !== 0 || B !== 0 ? z + B : Si(m.left, m.right)) : R = x - 2 * (P !== 0 || H !== 0 ? P + H : Si(m.top, m.bottom));
      }
      await d({
        ...t,
        availableWidth: D,
        availableHeight: R
      });
      const I = await l.getDimensions(c.floating);
      return b !== I.width || x !== I.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function FE() {
  return typeof window < "u";
}
function Bg(e) {
  return DU(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Ci(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Xl(e) {
  var t;
  return (t = (DU(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function DU(e) {
  return FE() ? e instanceof Node || e instanceof Ci(e).Node : !1;
}
function tl(e) {
  return FE() ? e instanceof Element || e instanceof Ci(e).Element : !1;
}
function Vl(e) {
  return FE() ? e instanceof HTMLElement || e instanceof Ci(e).HTMLElement : !1;
}
function HI(e) {
  return !FE() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Ci(e).ShadowRoot;
}
const qce = /* @__PURE__ */ new Set(["inline", "contents"]);
function rk(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: a
  } = nl(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !qce.has(a);
}
const Gce = /* @__PURE__ */ new Set(["table", "td", "th"]);
function Kce(e) {
  return Gce.has(Bg(e));
}
const Yce = [":popover-open", ":modal"];
function BE(e) {
  return Yce.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const Xce = ["transform", "translate", "scale", "rotate", "perspective"], Jce = ["transform", "translate", "scale", "rotate", "perspective", "filter"], Qce = ["paint", "layout", "strict", "content"];
function P4(e) {
  const t = D4(), n = tl(e) ? nl(e) : e;
  return Xce.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || Jce.some((r) => (n.willChange || "").includes(r)) || Qce.some((r) => (n.contain || "").includes(r));
}
function Zce(e) {
  let t = jd(e);
  for (; Vl(t) && !gg(t); ) {
    if (P4(t))
      return t;
    if (BE(t))
      return null;
    t = jd(t);
  }
  return null;
}
function D4() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const ede = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function gg(e) {
  return ede.has(Bg(e));
}
function nl(e) {
  return Ci(e).getComputedStyle(e);
}
function UE(e) {
  return tl(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function jd(e) {
  if (Bg(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    HI(e) && e.host || // Fallback.
    Xl(e)
  );
  return HI(t) ? t.host : t;
}
function IU(e) {
  const t = jd(e);
  return gg(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Vl(t) && rk(t) ? t : IU(t);
}
function lS(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const a = IU(e), s = a === ((r = e.ownerDocument) == null ? void 0 : r.body), l = Ci(a);
  if (s) {
    const c = s3(l);
    return t.concat(l, l.visualViewport || [], rk(a) ? a : [], c && n ? lS(c) : []);
  }
  return t.concat(a, lS(a, [], n));
}
function s3(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function $U(e) {
  const t = nl(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const a = Vl(e), s = a ? e.offsetWidth : n, l = a ? e.offsetHeight : r, c = h2(n) !== s || h2(r) !== l;
  return c && (n = s, r = l), {
    width: n,
    height: r,
    $: c
  };
}
function I4(e) {
  return tl(e) ? e : e.contextElement;
}
function ng(e) {
  const t = I4(e);
  if (!Vl(t))
    return Bl(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: a,
    $: s
  } = $U(t);
  let l = (s ? h2(n.width) : n.width) / r, c = (s ? h2(n.height) : n.height) / a;
  return (!l || !Number.isFinite(l)) && (l = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: l,
    y: c
  };
}
const tde = /* @__PURE__ */ Bl(0);
function zU(e) {
  const t = Ci(e);
  return !D4() || !t.visualViewport ? tde : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function nde(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== Ci(e) ? !1 : t;
}
function $m(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const a = e.getBoundingClientRect(), s = I4(e);
  let l = Bl(1);
  t && (r ? tl(r) && (l = ng(r)) : l = ng(e));
  const c = nde(s, n, r) ? zU(s) : Bl(0);
  let d = (a.left + c.x) / l.x, f = (a.top + c.y) / l.y, m = a.width / l.x, h = a.height / l.y;
  if (s) {
    const v = Ci(s), g = r && tl(r) ? Ci(r) : r;
    let b = v, x = s3(b);
    for (; x && r && g !== b; ) {
      const w = ng(x), k = x.getBoundingClientRect(), E = nl(x), _ = k.left + (x.clientLeft + parseFloat(E.paddingLeft)) * w.x, O = k.top + (x.clientTop + parseFloat(E.paddingTop)) * w.y;
      d *= w.x, f *= w.y, m *= w.x, h *= w.y, d += _, f += O, b = Ci(x), x = s3(b);
    }
  }
  return v2({
    width: m,
    height: h,
    x: d,
    y: f
  });
}
function $4(e, t) {
  const n = UE(e).scrollLeft;
  return t ? t.left + n : $m(Xl(e)).left + n;
}
function TU(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), a = r.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    $4(e, r)
  )), s = r.top + t.scrollTop;
  return {
    x: a,
    y: s
  };
}
function rde(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: a
  } = e;
  const s = a === "fixed", l = Xl(r), c = t ? BE(t.floating) : !1;
  if (r === l || c && s)
    return n;
  let d = {
    scrollLeft: 0,
    scrollTop: 0
  }, f = Bl(1);
  const m = Bl(0), h = Vl(r);
  if ((h || !h && !s) && ((Bg(r) !== "body" || rk(l)) && (d = UE(r)), Vl(r))) {
    const g = $m(r);
    f = ng(r), m.x = g.x + r.clientLeft, m.y = g.y + r.clientTop;
  }
  const v = l && !h && !s ? TU(l, d, !0) : Bl(0);
  return {
    width: n.width * f.x,
    height: n.height * f.y,
    x: n.x * f.x - d.scrollLeft * f.x + m.x + v.x,
    y: n.y * f.y - d.scrollTop * f.y + m.y + v.y
  };
}
function ode(e) {
  return Array.from(e.getClientRects());
}
function ade(e) {
  const t = Xl(e), n = UE(e), r = e.ownerDocument.body, a = Si(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), s = Si(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let l = -n.scrollLeft + $4(e);
  const c = -n.scrollTop;
  return nl(r).direction === "rtl" && (l += Si(t.clientWidth, r.clientWidth) - a), {
    width: a,
    height: s,
    x: l,
    y: c
  };
}
function ide(e, t) {
  const n = Ci(e), r = Xl(e), a = n.visualViewport;
  let s = r.clientWidth, l = r.clientHeight, c = 0, d = 0;
  if (a) {
    s = a.width, l = a.height;
    const f = D4();
    (!f || f && t === "fixed") && (c = a.offsetLeft, d = a.offsetTop);
  }
  return {
    width: s,
    height: l,
    x: c,
    y: d
  };
}
const sde = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function lde(e, t) {
  const n = $m(e, !0, t === "fixed"), r = n.top + e.clientTop, a = n.left + e.clientLeft, s = Vl(e) ? ng(e) : Bl(1), l = e.clientWidth * s.x, c = e.clientHeight * s.y, d = a * s.x, f = r * s.y;
  return {
    width: l,
    height: c,
    x: d,
    y: f
  };
}
function WI(e, t, n) {
  let r;
  if (t === "viewport")
    r = ide(e, n);
  else if (t === "document")
    r = ade(Xl(e));
  else if (tl(t))
    r = lde(t, n);
  else {
    const a = zU(e);
    r = {
      x: t.x - a.x,
      y: t.y - a.y,
      width: t.width,
      height: t.height
    };
  }
  return v2(r);
}
function LU(e, t) {
  const n = jd(e);
  return n === t || !tl(n) || gg(n) ? !1 : nl(n).position === "fixed" || LU(n, t);
}
function ude(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = lS(e, [], !1).filter((c) => tl(c) && Bg(c) !== "body"), a = null;
  const s = nl(e).position === "fixed";
  let l = s ? jd(e) : e;
  for (; tl(l) && !gg(l); ) {
    const c = nl(l), d = P4(l);
    !d && c.position === "fixed" && (a = null), (s ? !d && !a : !d && c.position === "static" && a && sde.has(a.position) || rk(l) && !d && LU(e, l)) ? r = r.filter((f) => f !== l) : a = c, l = jd(l);
  }
  return t.set(e, r), r;
}
function cde(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: a
  } = e;
  const s = [...n === "clippingAncestors" ? BE(t) ? [] : ude(t, this._c) : [].concat(n), r], l = s[0], c = s.reduce((d, f) => {
    const m = WI(t, f, a);
    return d.top = Si(m.top, d.top), d.right = Rd(m.right, d.right), d.bottom = Rd(m.bottom, d.bottom), d.left = Si(m.left, d.left), d;
  }, WI(t, l, a));
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top
  };
}
function dde(e) {
  const {
    width: t,
    height: n
  } = $U(e);
  return {
    width: t,
    height: n
  };
}
function fde(e, t, n) {
  const r = Vl(t), a = Xl(t), s = n === "fixed", l = $m(e, !0, s, t);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const d = Bl(0);
  function f() {
    d.x = $4(a);
  }
  if (r || !r && !s)
    if ((Bg(t) !== "body" || rk(a)) && (c = UE(t)), r) {
      const g = $m(t, !0, s, t);
      d.x = g.x + t.clientLeft, d.y = g.y + t.clientTop;
    } else a && f();
  s && !r && a && f();
  const m = a && !r && !s ? TU(a, c) : Bl(0), h = l.left + c.scrollLeft - d.x - m.x, v = l.top + c.scrollTop - d.y - m.y;
  return {
    x: h,
    y: v,
    width: l.width,
    height: l.height
  };
}
function FN(e) {
  return nl(e).position === "static";
}
function qI(e, t) {
  if (!Vl(e) || nl(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return Xl(e) === n && (n = n.ownerDocument.body), n;
}
function FU(e, t) {
  const n = Ci(e);
  if (BE(e))
    return n;
  if (!Vl(e)) {
    let a = jd(e);
    for (; a && !gg(a); ) {
      if (tl(a) && !FN(a))
        return a;
      a = jd(a);
    }
    return n;
  }
  let r = qI(e, t);
  for (; r && Kce(r) && FN(r); )
    r = qI(r, t);
  return r && gg(r) && FN(r) && !P4(r) ? n : r || Zce(e) || n;
}
const pde = async function(e) {
  const t = this.getOffsetParent || FU, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: fde(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function mde(e) {
  return nl(e).direction === "rtl";
}
const hde = {
  convertOffsetParentRelativeRectToViewportRelativeRect: rde,
  getDocumentElement: Xl,
  getClippingRect: cde,
  getOffsetParent: FU,
  getElementRects: pde,
  getClientRects: ode,
  getDimensions: dde,
  getScale: ng,
  isElement: tl,
  isRTL: mde
};
function BU(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function gde(e, t) {
  let n = null, r;
  const a = Xl(e);
  function s() {
    var c;
    clearTimeout(r), (c = n) == null || c.disconnect(), n = null;
  }
  function l(c, d) {
    c === void 0 && (c = !1), d === void 0 && (d = 1), s();
    const f = e.getBoundingClientRect(), {
      left: m,
      top: h,
      width: v,
      height: g
    } = f;
    if (c || t(), !v || !g)
      return;
    const b = Qk(h), x = Qk(a.clientWidth - (m + v)), w = Qk(a.clientHeight - (h + g)), k = Qk(m), E = {
      rootMargin: -b + "px " + -x + "px " + -w + "px " + -k + "px",
      threshold: Si(0, Rd(1, d)) || 1
    };
    let _ = !0;
    function O(N) {
      const A = N[0].intersectionRatio;
      if (A !== d) {
        if (!_)
          return l();
        A ? l(!1, A) : r = setTimeout(() => {
          l(!1, 1e-7);
        }, 1e3);
      }
      A === 1 && !BU(f, e.getBoundingClientRect()) && l(), _ = !1;
    }
    try {
      n = new IntersectionObserver(O, {
        ...E,
        // Handle <iframe>s
        root: a.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(O, E);
    }
    n.observe(e);
  }
  return l(!0), s;
}
function UU(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: a = !0,
    ancestorResize: s = !0,
    elementResize: l = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: d = !1
  } = r, f = I4(e), m = a || s ? [...f ? lS(f) : [], ...lS(t)] : [];
  m.forEach((k) => {
    a && k.addEventListener("scroll", n, {
      passive: !0
    }), s && k.addEventListener("resize", n);
  });
  const h = f && c ? gde(f, n) : null;
  let v = -1, g = null;
  l && (g = new ResizeObserver((k) => {
    let [E] = k;
    E && E.target === f && g && (g.unobserve(t), cancelAnimationFrame(v), v = requestAnimationFrame(() => {
      var _;
      (_ = g) == null || _.observe(t);
    })), n();
  }), f && !d && g.observe(f), g.observe(t));
  let b, x = d ? $m(e) : null;
  d && w();
  function w() {
    const k = $m(e);
    x && !BU(x, k) && n(), x = k, b = requestAnimationFrame(w);
  }
  return n(), () => {
    var k;
    m.forEach((E) => {
      a && E.removeEventListener("scroll", n), s && E.removeEventListener("resize", n);
    }), h?.(), (k = g) == null || k.disconnect(), g = null, d && cancelAnimationFrame(b);
  };
}
const vde = Uce, yde = Vce, bde = Lce, wde = Wce, xde = Fce, GI = Tce, Sde = Hce, kde = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), a = {
    platform: hde,
    ...n
  }, s = {
    ...a.platform,
    _c: r
  };
  return zce(e, t, {
    ...a,
    platform: s
  });
};
var _de = typeof document < "u", Ede = function() {
}, P_ = _de ? M.useLayoutEffect : Ede;
function y2(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, a;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!y2(e[r], t[r]))
          return !1;
      return !0;
    }
    if (a = Object.keys(e), n = a.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, a[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const s = a[r];
      if (!(s === "_owner" && e.$$typeof) && !y2(e[s], t[s]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function VU(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function KI(e, t) {
  const n = VU(e);
  return Math.round(t * n) / n;
}
function BN(e) {
  const t = M.useRef(e);
  return P_(() => {
    t.current = e;
  }), t;
}
function Cde(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: a,
    elements: {
      reference: s,
      floating: l
    } = {},
    transform: c = !0,
    whileElementsMounted: d,
    open: f
  } = e, [m, h] = M.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [v, g] = M.useState(r);
  y2(v, r) || g(r);
  const [b, x] = M.useState(null), [w, k] = M.useState(null), E = M.useCallback((q) => {
    q !== A.current && (A.current = q, x(q));
  }, []), _ = M.useCallback((q) => {
    q !== R.current && (R.current = q, k(q));
  }, []), O = s || b, N = l || w, A = M.useRef(null), R = M.useRef(null), D = M.useRef(m), I = d != null, z = BN(d), B = BN(a), P = BN(f), H = M.useCallback(() => {
    if (!A.current || !R.current)
      return;
    const q = {
      placement: t,
      strategy: n,
      middleware: v
    };
    B.current && (q.platform = B.current), kde(A.current, R.current, q).then((Z) => {
      const V = {
        ...Z,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: P.current !== !1
      };
      L.current && !y2(D.current, V) && (D.current = V, Xm.flushSync(() => {
        h(V);
      }));
    });
  }, [v, t, n, B, P]);
  P_(() => {
    f === !1 && D.current.isPositioned && (D.current.isPositioned = !1, h((q) => ({
      ...q,
      isPositioned: !1
    })));
  }, [f]);
  const L = M.useRef(!1);
  P_(() => (L.current = !0, () => {
    L.current = !1;
  }), []), P_(() => {
    if (O && (A.current = O), N && (R.current = N), O && N) {
      if (z.current)
        return z.current(O, N, H);
      H();
    }
  }, [O, N, H, z, I]);
  const G = M.useMemo(() => ({
    reference: A,
    floating: R,
    setReference: E,
    setFloating: _
  }), [E, _]), $ = M.useMemo(() => ({
    reference: O,
    floating: N
  }), [O, N]), K = M.useMemo(() => {
    const q = {
      position: n,
      left: 0,
      top: 0
    };
    if (!$.floating)
      return q;
    const Z = KI($.floating, m.x), V = KI($.floating, m.y);
    return c ? {
      ...q,
      transform: "translate(" + Z + "px, " + V + "px)",
      ...VU($.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: Z,
      top: V
    };
  }, [n, c, $.floating, m.x, m.y]);
  return M.useMemo(() => ({
    ...m,
    update: H,
    refs: G,
    elements: $,
    floatingStyles: K
  }), [m, H, G, $, K]);
}
const Ode = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: a
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? GI({
        element: r.current,
        padding: a
      }).fn(n) : {} : r ? GI({
        element: r,
        padding: a
      }).fn(n) : {};
    }
  };
}, Mde = (e, t) => ({
  ...vde(e),
  options: [e, t]
}), Nde = (e, t) => ({
  ...yde(e),
  options: [e, t]
}), Ade = (e, t) => ({
  ...Sde(e),
  options: [e, t]
}), Rde = (e, t) => ({
  ...bde(e),
  options: [e, t]
}), jde = (e, t) => ({
  ...wde(e),
  options: [e, t]
}), Pde = (e, t) => ({
  ...xde(e),
  options: [e, t]
}), Dde = (e, t) => ({
  ...Ode(e),
  options: [e, t]
});
var Ide = "Arrow", HU = M.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: a = 5, ...s } = e;
  return /* @__PURE__ */ C.jsx(
    Qt.svg,
    {
      ...s,
      ref: t,
      width: r,
      height: a,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ C.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
HU.displayName = Ide;
var $de = HU;
function WU(e) {
  const [t, n] = M.useState(void 0);
  return zc(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((a) => {
        if (!Array.isArray(a) || !a.length)
          return;
        const s = a[0];
        let l, c;
        if ("borderBoxSize" in s) {
          const d = s.borderBoxSize, f = Array.isArray(d) ? d[0] : d;
          l = f.inlineSize, c = f.blockSize;
        } else
          l = e.offsetWidth, c = e.offsetHeight;
        n({ width: l, height: c });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var z4 = "Popper", [qU, VE] = Kl(z4), [zde, GU] = qU(z4), KU = (e) => {
  const { __scopePopper: t, children: n } = e, [r, a] = M.useState(null);
  return /* @__PURE__ */ C.jsx(zde, { scope: t, anchor: r, onAnchorChange: a, children: n });
};
KU.displayName = z4;
var YU = "PopperAnchor", XU = M.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...a } = e, s = GU(YU, n), l = M.useRef(null), c = Xn(t, l), d = M.useRef(null);
    return M.useEffect(() => {
      const f = d.current;
      d.current = r?.current || l.current, f !== d.current && s.onAnchorChange(d.current);
    }), r ? null : /* @__PURE__ */ C.jsx(Qt.div, { ...a, ref: c });
  }
);
XU.displayName = YU;
var T4 = "PopperContent", [Tde, Lde] = qU(T4), JU = M.forwardRef(
  (e, t) => {
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: a = 0,
      align: s = "center",
      alignOffset: l = 0,
      arrowPadding: c = 0,
      avoidCollisions: d = !0,
      collisionBoundary: f = [],
      collisionPadding: m = 0,
      sticky: h = "partial",
      hideWhenDetached: v = !1,
      updatePositionStrategy: g = "optimized",
      onPlaced: b,
      ...x
    } = e, w = GU(T4, n), [k, E] = M.useState(null), _ = Xn(t, (fe) => E(fe)), [O, N] = M.useState(null), A = WU(O), R = A?.width ?? 0, D = A?.height ?? 0, I = r + (s !== "center" ? "-" + s : ""), z = typeof m == "number" ? m : { top: 0, right: 0, bottom: 0, left: 0, ...m }, B = Array.isArray(f) ? f : [f], P = B.length > 0, H = {
      padding: z,
      boundary: B.filter(Bde),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: P
    }, { refs: L, floatingStyles: G, placement: $, isPositioned: K, middlewareData: q } = Cde({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: I,
      whileElementsMounted: (...fe) => UU(...fe, {
        animationFrame: g === "always"
      }),
      elements: {
        reference: w.anchor
      },
      middleware: [
        Mde({ mainAxis: a + D, alignmentAxis: l }),
        d && Nde({
          mainAxis: !0,
          crossAxis: !1,
          limiter: h === "partial" ? Ade() : void 0,
          ...H
        }),
        d && Rde({ ...H }),
        jde({
          ...H,
          apply: ({ elements: fe, rects: ie, availableWidth: ce, availableHeight: ge }) => {
            const { width: re, height: le } = ie.reference, me = fe.floating.style;
            me.setProperty("--radix-popper-available-width", `${ce}px`), me.setProperty("--radix-popper-available-height", `${ge}px`), me.setProperty("--radix-popper-anchor-width", `${re}px`), me.setProperty("--radix-popper-anchor-height", `${le}px`);
          }
        }),
        O && Dde({ element: O, padding: c }),
        Ude({ arrowWidth: R, arrowHeight: D }),
        v && Pde({ strategy: "referenceHidden", ...H })
      ]
    }), [Z, V] = eV($), F = $a(b);
    zc(() => {
      K && F?.();
    }, [K, F]);
    const Y = q.arrow?.x, U = q.arrow?.y, W = q.arrow?.centerOffset !== 0, [J, oe] = M.useState();
    return zc(() => {
      k && oe(window.getComputedStyle(k).zIndex);
    }, [k]), /* @__PURE__ */ C.jsx(
      "div",
      {
        ref: L.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...G,
          transform: K ? G.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: J,
          "--radix-popper-transform-origin": [
            q.transformOrigin?.x,
            q.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...q.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ C.jsx(
          Tde,
          {
            scope: n,
            placedSide: Z,
            onArrowChange: N,
            arrowX: Y,
            arrowY: U,
            shouldHideArrow: W,
            children: /* @__PURE__ */ C.jsx(
              Qt.div,
              {
                "data-side": Z,
                "data-align": V,
                ...x,
                ref: _,
                style: {
                  ...x.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: K ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
JU.displayName = T4;
var QU = "PopperArrow", Fde = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, ZU = M.forwardRef(function(e, t) {
  const { __scopePopper: n, ...r } = e, a = Lde(QU, n), s = Fde[a.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ C.jsx(
      "span",
      {
        ref: a.onArrowChange,
        style: {
          position: "absolute",
          left: a.arrowX,
          top: a.arrowY,
          [s]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[a.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[a.placedSide],
          visibility: a.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ C.jsx(
          $de,
          {
            ...r,
            ref: t,
            style: {
              ...r.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
ZU.displayName = QU;
function Bde(e) {
  return e !== null;
}
var Ude = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    const { placement: n, rects: r, middlewareData: a } = t, s = a.arrow?.centerOffset !== 0, l = s ? 0 : e.arrowWidth, c = s ? 0 : e.arrowHeight, [d, f] = eV(n), m = { start: "0%", center: "50%", end: "100%" }[f], h = (a.arrow?.x ?? 0) + l / 2, v = (a.arrow?.y ?? 0) + c / 2;
    let g = "", b = "";
    return d === "bottom" ? (g = s ? m : `${h}px`, b = `${-c}px`) : d === "top" ? (g = s ? m : `${h}px`, b = `${r.floating.height + c}px`) : d === "right" ? (g = `${-c}px`, b = s ? m : `${v}px`) : d === "left" && (g = `${r.floating.width + c}px`, b = s ? m : `${v}px`), { data: { x: g, y: b } };
  }
});
function eV(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var L4 = KU, F4 = XU, tV = JU, nV = ZU, HE = "Popover", [rV] = Kl(HE, [
  VE
]), ok = VE(), [Vde, Ud] = rV(HE), oV = (e) => {
  const {
    __scopePopover: t,
    children: n,
    open: r,
    defaultOpen: a,
    onOpenChange: s,
    modal: l = !1
  } = e, c = ok(t), d = M.useRef(null), [f, m] = M.useState(!1), [h, v] = Bd({
    prop: r,
    defaultProp: a ?? !1,
    onChange: s,
    caller: HE
  });
  return /* @__PURE__ */ C.jsx(L4, { ...c, children: /* @__PURE__ */ C.jsx(
    Vde,
    {
      scope: t,
      contentId: Fl(),
      triggerRef: d,
      open: h,
      onOpenChange: v,
      onOpenToggle: M.useCallback(() => v((g) => !g), [v]),
      hasCustomAnchor: f,
      onCustomAnchorAdd: M.useCallback(() => m(!0), []),
      onCustomAnchorRemove: M.useCallback(() => m(!1), []),
      modal: l,
      children: n
    }
  ) });
};
oV.displayName = HE;
var aV = "PopoverAnchor", Hde = M.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, a = Ud(aV, n), s = ok(n), { onCustomAnchorAdd: l, onCustomAnchorRemove: c } = a;
    return M.useEffect(() => (l(), () => c()), [l, c]), /* @__PURE__ */ C.jsx(F4, { ...s, ...r, ref: t });
  }
);
Hde.displayName = aV;
var iV = "PopoverTrigger", sV = M.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, a = Ud(iV, n), s = ok(n), l = Xn(t, a.triggerRef), c = /* @__PURE__ */ C.jsx(
      Qt.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": a.open,
        "aria-controls": a.contentId,
        "data-state": pV(a.open),
        ...r,
        ref: l,
        onClick: et(e.onClick, a.onOpenToggle)
      }
    );
    return a.hasCustomAnchor ? c : /* @__PURE__ */ C.jsx(F4, { asChild: !0, ...s, children: c });
  }
);
sV.displayName = iV;
var B4 = "PopoverPortal", [Wde, qde] = rV(B4, {
  forceMount: void 0
}), lV = (e) => {
  const { __scopePopover: t, forceMount: n, children: r, container: a } = e, s = Ud(B4, t);
  return /* @__PURE__ */ C.jsx(Wde, { scope: t, forceMount: n, children: /* @__PURE__ */ C.jsx(al, { present: n || s.open, children: /* @__PURE__ */ C.jsx(AE, { asChild: !0, container: a, children: r }) }) });
};
lV.displayName = B4;
var vg = "PopoverContent", uV = M.forwardRef(
  (e, t) => {
    const n = qde(vg, e.__scopePopover), { forceMount: r = n.forceMount, ...a } = e, s = Ud(vg, e.__scopePopover);
    return /* @__PURE__ */ C.jsx(al, { present: r || s.open, children: s.modal ? /* @__PURE__ */ C.jsx(Kde, { ...a, ref: t }) : /* @__PURE__ */ C.jsx(Yde, { ...a, ref: t }) });
  }
);
uV.displayName = vg;
var Gde = /* @__PURE__ */ pg("PopoverContent.RemoveScroll"), Kde = M.forwardRef(
  (e, t) => {
    const n = Ud(vg, e.__scopePopover), r = M.useRef(null), a = Xn(t, r), s = M.useRef(!1);
    return M.useEffect(() => {
      const l = r.current;
      if (l) return f4(l);
    }, []), /* @__PURE__ */ C.jsx(jE, { as: Gde, allowPinchZoom: !0, children: /* @__PURE__ */ C.jsx(
      cV,
      {
        ...e,
        ref: a,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: et(e.onCloseAutoFocus, (l) => {
          l.preventDefault(), s.current || n.triggerRef.current?.focus();
        }),
        onPointerDownOutside: et(
          e.onPointerDownOutside,
          (l) => {
            const c = l.detail.originalEvent, d = c.button === 0 && c.ctrlKey === !0, f = c.button === 2 || d;
            s.current = f;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: et(
          e.onFocusOutside,
          (l) => l.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), Yde = M.forwardRef(
  (e, t) => {
    const n = Ud(vg, e.__scopePopover), r = M.useRef(!1), a = M.useRef(!1);
    return /* @__PURE__ */ C.jsx(
      cV,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (s) => {
          e.onCloseAutoFocus?.(s), s.defaultPrevented || (r.current || n.triggerRef.current?.focus(), s.preventDefault()), r.current = !1, a.current = !1;
        },
        onInteractOutside: (s) => {
          e.onInteractOutside?.(s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (a.current = !0));
          const l = s.target;
          n.triggerRef.current?.contains(l) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && a.current && s.preventDefault();
        }
      }
    );
  }
), cV = M.forwardRef(
  (e, t) => {
    const {
      __scopePopover: n,
      trapFocus: r,
      onOpenAutoFocus: a,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: l,
      onEscapeKeyDown: c,
      onPointerDownOutside: d,
      onFocusOutside: f,
      onInteractOutside: m,
      ...h
    } = e, v = Ud(vg, n), g = ok(n);
    return d4(), /* @__PURE__ */ C.jsx(
      NE,
      {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: a,
        onUnmountAutoFocus: s,
        children: /* @__PURE__ */ C.jsx(
          QS,
          {
            asChild: !0,
            disableOutsidePointerEvents: l,
            onInteractOutside: m,
            onEscapeKeyDown: c,
            onPointerDownOutside: d,
            onFocusOutside: f,
            onDismiss: () => v.onOpenChange(!1),
            children: /* @__PURE__ */ C.jsx(
              tV,
              {
                "data-state": pV(v.open),
                role: "dialog",
                id: v.contentId,
                ...g,
                ...h,
                ref: t,
                style: {
                  ...h.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), dV = "PopoverClose", Xde = M.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, a = Ud(dV, n);
    return /* @__PURE__ */ C.jsx(
      Qt.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: et(e.onClick, () => a.onOpenChange(!1))
      }
    );
  }
);
Xde.displayName = dV;
var Jde = "PopoverArrow", fV = M.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, a = ok(n);
    return /* @__PURE__ */ C.jsx(nV, { ...a, ...r, ref: t });
  }
);
fV.displayName = Jde;
function pV(e) {
  return e ? "open" : "closed";
}
var mV = oV, hV = sV, gV = lV, vV = uV, Qde = fV;
const uS = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
}, yV = {};
for (const e of Object.keys(uS))
  yV[uS[e]] = e;
const Ve = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  oklab: { channels: 3, labels: ["okl", "oka", "okb"] },
  lch: { channels: 3, labels: "lch" },
  oklch: { channels: 3, labels: ["okl", "okc", "okh"] },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
}, Rc = (6 / 29) ** 3;
function rg(e) {
  const t = e > 31308e-7 ? 1.055 * e ** 0.4166666666666667 - 0.055 : e * 12.92;
  return Math.min(Math.max(0, t), 1);
}
function og(e) {
  return e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92;
}
for (const e of Object.keys(Ve)) {
  if (!("channels" in Ve[e]))
    throw new Error("missing channels property: " + e);
  if (!("labels" in Ve[e]))
    throw new Error("missing channel labels property: " + e);
  if (Ve[e].labels.length !== Ve[e].channels)
    throw new Error("channel and label counts mismatch: " + e);
  const { channels: t, labels: n } = Ve[e];
  delete Ve[e].channels, delete Ve[e].labels, Object.defineProperty(Ve[e], "channels", { value: t }), Object.defineProperty(Ve[e], "labels", { value: n });
}
Ve.rgb.hsl = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, a = Math.min(t, n, r), s = Math.max(t, n, r), l = s - a;
  let c, d;
  switch (s) {
    case a: {
      c = 0;
      break;
    }
    case t: {
      c = (n - r) / l;
      break;
    }
    case n: {
      c = 2 + (r - t) / l;
      break;
    }
    case r: {
      c = 4 + (t - n) / l;
      break;
    }
  }
  c = Math.min(c * 60, 360), c < 0 && (c += 360);
  const f = (a + s) / 2;
  return s === a ? d = 0 : f <= 0.5 ? d = l / (s + a) : d = l / (2 - s - a), [c, d * 100, f * 100];
};
Ve.rgb.hsv = function(e) {
  let t, n, r, a, s;
  const l = e[0] / 255, c = e[1] / 255, d = e[2] / 255, f = Math.max(l, c, d), m = f - Math.min(l, c, d), h = function(v) {
    return (f - v) / 6 / m + 1 / 2;
  };
  if (m === 0)
    a = 0, s = 0;
  else {
    switch (s = m / f, t = h(l), n = h(c), r = h(d), f) {
      case l: {
        a = r - n;
        break;
      }
      case c: {
        a = 1 / 3 + t - r;
        break;
      }
      case d: {
        a = 2 / 3 + n - t;
        break;
      }
    }
    a < 0 ? a += 1 : a > 1 && (a -= 1);
  }
  return [
    a * 360,
    s * 100,
    f * 100
  ];
};
Ve.rgb.hwb = function(e) {
  const t = e[0], n = e[1];
  let r = e[2];
  const a = Ve.rgb.hsl(e)[0], s = 1 / 255 * Math.min(t, Math.min(n, r));
  return r = 1 - 1 / 255 * Math.max(t, Math.max(n, r)), [a, s * 100, r * 100];
};
Ve.rgb.oklab = function(e) {
  const t = og(e[0] / 255), n = og(e[1] / 255), r = og(e[2] / 255), a = Math.cbrt(0.4122214708 * t + 0.5363325363 * n + 0.0514459929 * r), s = Math.cbrt(0.2119034982 * t + 0.6806995451 * n + 0.1073969566 * r), l = Math.cbrt(0.0883024619 * t + 0.2817188376 * n + 0.6299787005 * r), c = 0.2104542553 * a + 0.793617785 * s - 0.0040720468 * l, d = 1.9779984951 * a - 2.428592205 * s + 0.4505937099 * l, f = 0.0259040371 * a + 0.7827717662 * s - 0.808675766 * l;
  return [c * 100, d * 100, f * 100];
};
Ve.rgb.cmyk = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, a = Math.min(1 - t, 1 - n, 1 - r), s = (1 - t - a) / (1 - a) || 0, l = (1 - n - a) / (1 - a) || 0, c = (1 - r - a) / (1 - a) || 0;
  return [s * 100, l * 100, c * 100, a * 100];
};
function Zde(e, t) {
  return (e[0] - t[0]) ** 2 + (e[1] - t[1]) ** 2 + (e[2] - t[2]) ** 2;
}
Ve.rgb.keyword = function(e) {
  const t = yV[e];
  if (t)
    return t;
  let n = Number.POSITIVE_INFINITY, r;
  for (const a of Object.keys(uS)) {
    const s = uS[a], l = Zde(e, s);
    l < n && (n = l, r = a);
  }
  return r;
};
Ve.keyword.rgb = function(e) {
  return [...uS[e]];
};
Ve.rgb.xyz = function(e) {
  const t = og(e[0] / 255), n = og(e[1] / 255), r = og(e[2] / 255), a = t * 0.4124564 + n * 0.3575761 + r * 0.1804375, s = t * 0.2126729 + n * 0.7151522 + r * 0.072175, l = t * 0.0193339 + n * 0.119192 + r * 0.9503041;
  return [a * 100, s * 100, l * 100];
};
Ve.rgb.lab = function(e) {
  const t = Ve.rgb.xyz(e);
  let n = t[0], r = t[1], a = t[2];
  n /= 95.047, r /= 100, a /= 108.883, n = n > Rc ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > Rc ? r ** (1 / 3) : 7.787 * r + 16 / 116, a = a > Rc ? a ** (1 / 3) : 7.787 * a + 16 / 116;
  const s = 116 * r - 16, l = 500 * (n - r), c = 200 * (r - a);
  return [s, l, c];
};
Ve.hsl.rgb = function(e) {
  const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
  let a, s;
  if (n === 0)
    return s = r * 255, [s, s, s];
  const l = r < 0.5 ? r * (1 + n) : r + n - r * n, c = 2 * r - l, d = [0, 0, 0];
  for (let f = 0; f < 3; f++)
    a = t + 1 / 3 * -(f - 1), a < 0 && a++, a > 1 && a--, 6 * a < 1 ? s = c + (l - c) * 6 * a : 2 * a < 1 ? s = l : 3 * a < 2 ? s = c + (l - c) * (2 / 3 - a) * 6 : s = c, d[f] = s * 255;
  return d;
};
Ve.hsl.hsv = function(e) {
  const t = e[0];
  let n = e[1] / 100, r = e[2] / 100, a = n;
  const s = Math.max(r, 0.01);
  r *= 2, n *= r <= 1 ? r : 2 - r, a *= s <= 1 ? s : 2 - s;
  const l = (r + n) / 2, c = r === 0 ? 2 * a / (s + a) : 2 * n / (r + n);
  return [t, c * 100, l * 100];
};
Ve.hsv.rgb = function(e) {
  const t = e[0] / 60, n = e[1] / 100;
  let r = e[2] / 100;
  const a = Math.floor(t) % 6, s = t - Math.floor(t), l = 255 * r * (1 - n), c = 255 * r * (1 - n * s), d = 255 * r * (1 - n * (1 - s));
  switch (r *= 255, a) {
    case 0:
      return [r, d, l];
    case 1:
      return [c, r, l];
    case 2:
      return [l, r, d];
    case 3:
      return [l, c, r];
    case 4:
      return [d, l, r];
    case 5:
      return [r, l, c];
  }
};
Ve.hsv.hsl = function(e) {
  const t = e[0], n = e[1] / 100, r = e[2] / 100, a = Math.max(r, 0.01);
  let s, l;
  l = (2 - n) * r;
  const c = (2 - n) * a;
  return s = n * a, s /= c <= 1 ? c : 2 - c, s = s || 0, l /= 2, [t, s * 100, l * 100];
};
Ve.hwb.rgb = function(e) {
  const t = e[0] / 360;
  let n = e[1] / 100, r = e[2] / 100;
  const a = n + r;
  let s;
  a > 1 && (n /= a, r /= a);
  const l = Math.floor(6 * t), c = 1 - r;
  s = 6 * t - l, (l & 1) !== 0 && (s = 1 - s);
  const d = n + s * (c - n);
  let f, m, h;
  switch (l) {
    default:
    case 6:
    case 0: {
      f = c, m = d, h = n;
      break;
    }
    case 1: {
      f = d, m = c, h = n;
      break;
    }
    case 2: {
      f = n, m = c, h = d;
      break;
    }
    case 3: {
      f = n, m = d, h = c;
      break;
    }
    case 4: {
      f = d, m = n, h = c;
      break;
    }
    case 5: {
      f = c, m = n, h = d;
      break;
    }
  }
  return [f * 255, m * 255, h * 255];
};
Ve.cmyk.rgb = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, a = e[3] / 100, s = 1 - Math.min(1, t * (1 - a) + a), l = 1 - Math.min(1, n * (1 - a) + a), c = 1 - Math.min(1, r * (1 - a) + a);
  return [s * 255, l * 255, c * 255];
};
Ve.xyz.rgb = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100;
  let a, s, l;
  return a = t * 3.2404542 + n * -1.5371385 + r * -0.4985314, s = t * -0.969266 + n * 1.8760108 + r * 0.041556, l = t * 0.0556434 + n * -0.2040259 + r * 1.0572252, a = rg(a), s = rg(s), l = rg(l), [a * 255, s * 255, l * 255];
};
Ve.xyz.lab = function(e) {
  let t = e[0], n = e[1], r = e[2];
  t /= 95.047, n /= 100, r /= 108.883, t = t > Rc ? t ** (1 / 3) : 7.787 * t + 16 / 116, n = n > Rc ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > Rc ? r ** (1 / 3) : 7.787 * r + 16 / 116;
  const a = 116 * n - 16, s = 500 * (t - n), l = 200 * (n - r);
  return [a, s, l];
};
Ve.xyz.oklab = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, a = Math.cbrt(0.8189330101 * t + 0.3618667424 * n - 0.1288597137 * r), s = Math.cbrt(0.0329845436 * t + 0.9293118715 * n + 0.0361456387 * r), l = Math.cbrt(0.0482003018 * t + 0.2643662691 * n + 0.633851707 * r), c = 0.2104542553 * a + 0.793617785 * s - 0.0040720468 * l, d = 1.9779984951 * a - 2.428592205 * s + 0.4505937099 * l, f = 0.0259040371 * a + 0.7827717662 * s - 0.808675766 * l;
  return [c * 100, d * 100, f * 100];
};
Ve.oklab.oklch = function(e) {
  return Ve.lab.lch(e);
};
Ve.oklab.xyz = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, a = (0.999999998 * t + 0.396337792 * n + 0.215803758 * r) ** 3, s = (1.000000008 * t - 0.105561342 * n - 0.063854175 * r) ** 3, l = (1.000000055 * t - 0.089484182 * n - 1.291485538 * r) ** 3, c = 1.227013851 * a - 0.55779998 * s + 0.281256149 * l, d = -0.040580178 * a + 1.11225687 * s - 0.071676679 * l, f = -0.076381285 * a - 0.421481978 * s + 1.58616322 * l;
  return [c * 100, d * 100, f * 100];
};
Ve.oklab.rgb = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, a = (t + 0.3963377774 * n + 0.2158037573 * r) ** 3, s = (t - 0.1055613458 * n - 0.0638541728 * r) ** 3, l = (t - 0.0894841775 * n - 1.291485548 * r) ** 3, c = rg(4.0767416621 * a - 3.3077115913 * s + 0.2309699292 * l), d = rg(-1.2684380046 * a + 2.6097574011 * s - 0.3413193965 * l), f = rg(-0.0041960863 * a - 0.7034186147 * s + 1.707614701 * l);
  return [c * 255, d * 255, f * 255];
};
Ve.oklch.oklab = function(e) {
  return Ve.lch.lab(e);
};
Ve.lab.xyz = function(e) {
  const t = e[0], n = e[1], r = e[2];
  let a, s, l;
  s = (t + 16) / 116, a = n / 500 + s, l = s - r / 200;
  const c = s ** 3, d = a ** 3, f = l ** 3;
  return s = c > Rc ? c : (s - 16 / 116) / 7.787, a = d > Rc ? d : (a - 16 / 116) / 7.787, l = f > Rc ? f : (l - 16 / 116) / 7.787, a *= 95.047, s *= 100, l *= 108.883, [a, s, l];
};
Ve.lab.lch = function(e) {
  const t = e[0], n = e[1], r = e[2];
  let a;
  a = Math.atan2(r, n) * 360 / 2 / Math.PI, a < 0 && (a += 360);
  const s = Math.sqrt(n * n + r * r);
  return [t, s, a];
};
Ve.lch.lab = function(e) {
  const t = e[0], n = e[1], r = e[2] / 360 * 2 * Math.PI, a = n * Math.cos(r), s = n * Math.sin(r);
  return [t, a, s];
};
Ve.rgb.ansi16 = function(e, t = null) {
  const [n, r, a] = e;
  let s = t === null ? Ve.rgb.hsv(e)[2] : t;
  if (s = Math.round(s / 50), s === 0)
    return 30;
  let l = 30 + (Math.round(a / 255) << 2 | Math.round(r / 255) << 1 | Math.round(n / 255));
  return s === 2 && (l += 60), l;
};
Ve.hsv.ansi16 = function(e) {
  return Ve.rgb.ansi16(Ve.hsv.rgb(e), e[2]);
};
Ve.rgb.ansi256 = function(e) {
  const t = e[0], n = e[1], r = e[2];
  return t >> 4 === n >> 4 && n >> 4 === r >> 4 ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5);
};
Ve.ansi16.rgb = function(e) {
  e = e[0];
  let t = e % 10;
  if (t === 0 || t === 7)
    return e > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t];
  const n = (Math.trunc(e > 50) + 1) * 0.5, r = (t & 1) * n * 255, a = (t >> 1 & 1) * n * 255, s = (t >> 2 & 1) * n * 255;
  return [r, a, s];
};
Ve.ansi256.rgb = function(e) {
  if (e = e[0], e >= 232) {
    const s = (e - 232) * 10 + 8;
    return [s, s, s];
  }
  e -= 16;
  let t;
  const n = Math.floor(e / 36) / 5 * 255, r = Math.floor((t = e % 36) / 6) / 5 * 255, a = t % 6 / 5 * 255;
  return [n, r, a];
};
Ve.rgb.hex = function(e) {
  const t = (((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255)).toString(16).toUpperCase();
  return "000000".slice(t.length) + t;
};
Ve.hex.rgb = function(e) {
  const t = e.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i);
  if (!t)
    return [0, 0, 0];
  let n = t[0];
  t[0].length === 3 && (n = [...n].map((c) => c + c).join(""));
  const r = Number.parseInt(n, 16), a = r >> 16 & 255, s = r >> 8 & 255, l = r & 255;
  return [a, s, l];
};
Ve.rgb.hcg = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, a = Math.max(Math.max(t, n), r), s = Math.min(Math.min(t, n), r), l = a - s;
  let c;
  const d = l < 1 ? s / (1 - l) : 0;
  return l <= 0 ? c = 0 : a === t ? c = (n - r) / l % 6 : a === n ? c = 2 + (r - t) / l : c = 4 + (t - n) / l, c /= 6, c %= 1, [c * 360, l * 100, d * 100];
};
Ve.hsl.hcg = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = n < 0.5 ? 2 * t * n : 2 * t * (1 - n);
  let a = 0;
  return r < 1 && (a = (n - 0.5 * r) / (1 - r)), [e[0], r * 100, a * 100];
};
Ve.hsv.hcg = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t * n;
  let a = 0;
  return r < 1 && (a = (n - r) / (1 - r)), [e[0], r * 100, a * 100];
};
Ve.hcg.rgb = function(e) {
  const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
  if (n === 0)
    return [r * 255, r * 255, r * 255];
  const a = [0, 0, 0], s = t % 1 * 6, l = s % 1, c = 1 - l;
  let d = 0;
  switch (Math.floor(s)) {
    case 0: {
      a[0] = 1, a[1] = l, a[2] = 0;
      break;
    }
    case 1: {
      a[0] = c, a[1] = 1, a[2] = 0;
      break;
    }
    case 2: {
      a[0] = 0, a[1] = 1, a[2] = l;
      break;
    }
    case 3: {
      a[0] = 0, a[1] = c, a[2] = 1;
      break;
    }
    case 4: {
      a[0] = l, a[1] = 0, a[2] = 1;
      break;
    }
    default:
      a[0] = 1, a[1] = 0, a[2] = c;
  }
  return d = (1 - n) * r, [
    (n * a[0] + d) * 255,
    (n * a[1] + d) * 255,
    (n * a[2] + d) * 255
  ];
};
Ve.hcg.hsv = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
  let a = 0;
  return r > 0 && (a = t / r), [e[0], a * 100, r * 100];
};
Ve.hcg.hsl = function(e) {
  const t = e[1] / 100, n = e[2] / 100 * (1 - t) + 0.5 * t;
  let r = 0;
  return n > 0 && n < 0.5 ? r = t / (2 * n) : n >= 0.5 && n < 1 && (r = t / (2 * (1 - n))), [e[0], r * 100, n * 100];
};
Ve.hcg.hwb = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
  return [e[0], (r - t) * 100, (1 - r) * 100];
};
Ve.hwb.hcg = function(e) {
  const t = e[1] / 100, n = 1 - e[2] / 100, r = n - t;
  let a = 0;
  return r < 1 && (a = (n - r) / (1 - r)), [e[0], r * 100, a * 100];
};
Ve.apple.rgb = function(e) {
  return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255];
};
Ve.rgb.apple = function(e) {
  return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535];
};
Ve.gray.rgb = function(e) {
  return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255];
};
Ve.gray.hsl = function(e) {
  return [0, 0, e[0]];
};
Ve.gray.hsv = Ve.gray.hsl;
Ve.gray.hwb = function(e) {
  return [0, 100, e[0]];
};
Ve.gray.cmyk = function(e) {
  return [0, 0, 0, e[0]];
};
Ve.gray.lab = function(e) {
  return [e[0], 0, 0];
};
Ve.gray.hex = function(e) {
  const t = Math.round(e[0] / 100 * 255) & 255, n = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
  return "000000".slice(n.length) + n;
};
Ve.rgb.gray = function(e) {
  return [(e[0] + e[1] + e[2]) / 3 / 255 * 100];
};
function efe() {
  const e = {}, t = Object.keys(Ve);
  for (let { length: n } = t, r = 0; r < n; r++)
    e[t[r]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  return e;
}
function tfe(e) {
  const t = efe(), n = [e];
  for (t[e].distance = 0; n.length > 0; ) {
    const r = n.pop(), a = Object.keys(Ve[r]);
    for (let { length: s } = a, l = 0; l < s; l++) {
      const c = a[l], d = t[c];
      d.distance === -1 && (d.distance = t[r].distance + 1, d.parent = r, n.unshift(c));
    }
  }
  return t;
}
function nfe(e, t) {
  return function(n) {
    return t(e(n));
  };
}
function rfe(e, t) {
  const n = [t[e].parent, e];
  let r = Ve[t[e].parent][e], a = t[e].parent;
  for (; t[a].parent; )
    n.unshift(t[a].parent), r = nfe(Ve[t[a].parent][a], r), a = t[a].parent;
  return r.conversion = n, r;
}
function ofe(e) {
  const t = tfe(e), n = {}, r = Object.keys(t);
  for (let { length: a } = r, s = 0; s < a; s++) {
    const l = r[s];
    t[l].parent !== null && (n[l] = rfe(l, t));
  }
  return n;
}
const Sm = {}, afe = Object.keys(Ve);
function ife(e) {
  const t = function(...n) {
    const r = n[0];
    return r == null ? r : (r.length > 1 && (n = r), e(n));
  };
  return "conversion" in e && (t.conversion = e.conversion), t;
}
function sfe(e) {
  const t = function(...n) {
    const r = n[0];
    if (r == null)
      return r;
    r.length > 1 && (n = r);
    const a = e(n);
    if (typeof a == "object")
      for (let { length: s } = a, l = 0; l < s; l++)
        a[l] = Math.round(a[l]);
    return a;
  };
  return "conversion" in e && (t.conversion = e.conversion), t;
}
for (const e of afe) {
  Sm[e] = {}, Object.defineProperty(Sm[e], "channels", { value: Ve[e].channels }), Object.defineProperty(Sm[e], "labels", { value: Ve[e].labels });
  const t = ofe(e), n = Object.keys(t);
  for (const r of n) {
    const a = t[r];
    Sm[e][r] = sfe(a), Sm[e][r].raw = ife(a);
  }
}
const lfe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Sm
}, Symbol.toStringTag, { value: "Module" })), Ko = (e, t) => {
  const n = Array.isArray(t) ? t : [t];
  if (n[0] === void 0 || n[0] === null)
    return Ko("rgb", [0, 0, 0]);
  const r = Sm[e];
  if (!r)
    throw new Error(
      `Unsupported color type: ${e} allowed are ${Object.keys(lfe).join(
        ", "
      )}`
    );
  r[e] = () => n;
  const a = (l) => {
    const c = l(...n);
    return Array.isArray(c) ? c[0] != null : c;
  };
  if (!a(r.rgb) || !a(r.hsl))
    return Ko("rgb", [0, 0, 0]);
  const s = {};
  return Object.keys(r).forEach((l) => {
    const c = r[l];
    typeof c == "function" && (s[l] = () => l === e ? n : c(...n));
  }), s;
}, ufe = ({
  onChange: e,
  colorconverter: t,
  allow_null: n = !1
}) => {
  if (t === null && !n)
    throw new Error("Color converter is null");
  const [r, a] = M.useState(t), [s, l] = M.useState([0, 0, 0]), [c, d] = M.useState([0, 0, 0]), [f, m] = M.useState([0, 0, 0]), [h, v] = M.useState("000");
  M.useEffect(() => {
    if (!r) {
      if (!n) throw new Error("Color converter is null");
      d([0, 0, 0]), l([0, 0, 0]), m([0, 0, 0]), v("");
      return;
    }
    l(r.hsl()), d(r.rgb()), m(r.hsv()), v(r.hex());
  }, [r]);
  const g = {
    backgroundColor: `hsl(${s[0]}, ${s[1]}%, ${s[2]}%)`,
    padding: "10px",
    margin: "10px 0"
  };
  return /* @__PURE__ */ C.jsxs("div", { style: { backgroundColor: "white" }, children: [
    /* @__PURE__ */ C.jsx("div", { style: g, children: "Color Preview" }),
    /* @__PURE__ */ C.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ C.jsx("div", { className: "colorspace_title", children: "RGB" }),
      /* @__PURE__ */ C.jsx("div", {}),
      /* @__PURE__ */ C.jsx("label", { children: "Red" }),
      /* @__PURE__ */ C.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: c[0],
          onChange: (b) => {
            const x = [parseInt(b.target.value), c[1], c[2]], w = Ko("rgb", x);
            a(w), e(w);
          },
          style: { background: "linear-gradient(to right, #000, #f00)" }
        }
      ),
      /* @__PURE__ */ C.jsx("label", { children: "Green" }),
      /* @__PURE__ */ C.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: c[1],
          onChange: (b) => {
            const x = [c[0], parseInt(b.target.value), c[2]], w = Ko("rgb", x);
            a(w), e(w);
          },
          style: { background: "linear-gradient(to right, #000, #0f0)" }
        }
      ),
      /* @__PURE__ */ C.jsx("label", { children: "Blue" }),
      /* @__PURE__ */ C.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: c[2],
          onChange: (b) => {
            const x = [c[0], c[1], parseInt(b.target.value)], w = Ko("rgb", x);
            a(w), e(w);
          },
          style: { background: "linear-gradient(to right, #000, #00f)" }
        }
      )
    ] }),
    /* @__PURE__ */ C.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ C.jsx("div", { className: "colorspace_title", children: "HSL" }),
      /* @__PURE__ */ C.jsx("div", {}),
      /* @__PURE__ */ C.jsx("label", { children: "Hue" }),
      /* @__PURE__ */ C.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "360",
          value: s[0],
          onChange: (b) => {
            const x = [parseInt(b.target.value), s[1], s[2]], w = Ko("hsl", x);
            a(w), e(w);
          },
          style: {
            background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
          }
        }
      ),
      /* @__PURE__ */ C.jsx("label", { children: "Saturation" }),
      /* @__PURE__ */ C.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: s[1],
          onChange: (b) => {
            const x = [s[0], parseInt(b.target.value), s[2]], w = Ko("hsl", x);
            a(w), e(w);
          },
          style: {
            background: `linear-gradient(to right, #fff, hsl(${s[0]}, 100%, 50%))`
          }
        }
      ),
      /* @__PURE__ */ C.jsx("label", { children: "Lightness" }),
      /* @__PURE__ */ C.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: s[2],
          onChange: (b) => {
            const x = [s[0], s[1], parseInt(b.target.value)], w = Ko("hsl", x);
            a(w), e(w);
          },
          style: {
            background: `linear-gradient(to right, #000, hsl(${s[0]}, 100%, 50%), #fff)`
          }
        }
      )
    ] }),
    /* @__PURE__ */ C.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ C.jsx("div", { className: "colorspace_title", children: "HSV" }),
      /* @__PURE__ */ C.jsx("div", {}),
      /* @__PURE__ */ C.jsx("label", { children: "Hue" }),
      /* @__PURE__ */ C.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "360",
          value: f[0],
          onChange: (b) => {
            const x = [parseInt(b.target.value), f[1], f[2]], w = Ko("hsv", x);
            a(w), e(w);
          },
          style: {
            background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
          }
        }
      ),
      /* @__PURE__ */ C.jsx("label", { children: "Saturation" }),
      /* @__PURE__ */ C.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: f[1],
          onChange: (b) => {
            const x = [f[0], parseInt(b.target.value), f[2]], w = Ko("hsv", x);
            a(w), e(w);
          },
          style: {
            background: `linear-gradient(to right, #fff, hsl(${s[0]}, 100%, 50%))`
          }
        }
      ),
      /* @__PURE__ */ C.jsx("label", { children: "Value" }),
      /* @__PURE__ */ C.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: f[2],
          onChange: (b) => {
            const x = [f[0], f[1], parseInt(b.target.value)], w = Ko("hsv", x);
            a(w), e(w);
          },
          style: {
            background: `linear-gradient(to right, #000, hsl(${s[0]}, 100%, 50%))`
          }
        }
      )
    ] }),
    /* @__PURE__ */ C.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ C.jsx("div", { className: "colorspace_title", children: "HEX" }),
      /* @__PURE__ */ C.jsx("div", {}),
      /* @__PURE__ */ C.jsx(
        "input",
        {
          type: "text",
          value: h,
          onChange: (b) => {
            const x = b.target.value === "" ? null : Ko("hex", [b.target.value]);
            a(x), e(x);
          }
        }
      )
    ] })
  ] });
}, cfe = ({
  inicolordata: e,
  inicolorspace: t,
  allow_null: n = !1,
  delay: r = 1e3,
  onChange: a,
  portalContainer: s
}) => {
  const l = e !== void 0 ? e : [0, 0, 0], c = e === void 0 ? "rgb" : t || "hex", d = Array.isArray(l) ? l : [l], f = M.useMemo(() => {
    let x = Ko(c, d);
    return x.rgb() === void 0 && (x = Ko("rgb", [0, 0, 0])), x;
  }, [c, d]), [m, h] = M.useState(f);
  M.useEffect(() => {
    const x = e !== void 0 ? e : [0, 0, 0], w = e === void 0 ? "rgb" : t || "hex", k = Array.isArray(x) ? x : [x];
    let E = Ko(w, k);
    E.rgb() === void 0 && (E = Ko("rgb", [0, 0, 0])), h(E);
  }, [JSON.stringify(e), t]);
  const v = M.useRef(null), g = M.useCallback(
    (x) => {
      if (x === null && !n)
        throw new Error("Color is null");
      x !== null && h(x), v.current && clearTimeout(v.current), a && (v.current = setTimeout(() => {
        a(x), v.current = null;
      }, r));
    },
    [n, a, r]
  );
  M.useEffect(() => () => {
    v.current && clearTimeout(v.current);
  }, []);
  const b = M.useMemo(
    () => ({
      background: "#" + m.hex(),
      borderRadius: "0.3rem",
      width: "2rem",
      height: "1rem"
    }),
    [m]
  );
  return /* @__PURE__ */ C.jsxs(mV, { children: [
    /* @__PURE__ */ C.jsx(hV, { asChild: !0, children: /* @__PURE__ */ C.jsx("button", { style: b }) }),
    /* @__PURE__ */ C.jsx(gV, { container: s, children: /* @__PURE__ */ C.jsx(vV, { side: "left", className: "iotooltipcontent", children: /* @__PURE__ */ C.jsx(
      ufe,
      {
        onChange: g,
        colorconverter: m,
        allow_null: n
      }
    ) }) })
  ] });
};
function zm(e) {
  "@babel/helpers - typeof";
  return zm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, zm(e);
}
function dfe(e, t) {
  if (zm(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (zm(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function bV(e) {
  var t = dfe(e, "string");
  return zm(t) == "symbol" ? t : t + "";
}
function yx(e, t, n) {
  return (t = bV(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function YI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ht(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YI(Object(n), !0).forEach(function(r) {
      yx(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function ffe(e) {
  if (Array.isArray(e)) return e;
}
function pfe(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, a, s, l, c = [], d = !0, f = !1;
    try {
      if (s = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n) return;
        d = !1;
      } else for (; !(d = (r = s.call(n)).done) && (c.push(r.value), c.length !== t); d = !0) ;
    } catch (m) {
      f = !0, a = m;
    } finally {
      try {
        if (!d && n.return != null && (l = n.return(), Object(l) !== l)) return;
      } finally {
        if (f) throw a;
      }
    }
    return c;
  }
}
function l3(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function wV(e, t) {
  if (e) {
    if (typeof e == "string") return l3(e, t);
    var n = {}.toString.call(e).slice(8, -1);
    return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? l3(e, t) : void 0;
  }
}
function mfe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function jc(e, t) {
  return ffe(e) || pfe(e, t) || wV(e, t) || mfe();
}
function Yc(e, t) {
  if (e == null) return {};
  var n, r, a = OE(e, t);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    for (r = 0; r < s.length; r++) n = s[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (a[n] = e[n]);
  }
  return a;
}
var hfe = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function gfe(e) {
  var t = e.defaultInputValue, n = t === void 0 ? "" : t, r = e.defaultMenuIsOpen, a = r === void 0 ? !1 : r, s = e.defaultValue, l = s === void 0 ? null : s, c = e.inputValue, d = e.menuIsOpen, f = e.onChange, m = e.onInputChange, h = e.onMenuClose, v = e.onMenuOpen, g = e.value, b = Yc(e, hfe), x = M.useState(c !== void 0 ? c : n), w = jc(x, 2), k = w[0], E = w[1], _ = M.useState(d !== void 0 ? d : a), O = jc(_, 2), N = O[0], A = O[1], R = M.useState(g !== void 0 ? g : l), D = jc(R, 2), I = D[0], z = D[1], B = M.useCallback(function(q, Z) {
    typeof f == "function" && f(q, Z), z(q);
  }, [f]), P = M.useCallback(function(q, Z) {
    var V;
    typeof m == "function" && (V = m(q, Z)), E(V !== void 0 ? V : q);
  }, [m]), H = M.useCallback(function() {
    typeof v == "function" && v(), A(!0);
  }, [v]), L = M.useCallback(function() {
    typeof h == "function" && h(), A(!1);
  }, [h]), G = c !== void 0 ? c : k, $ = d !== void 0 ? d : N, K = g !== void 0 ? g : I;
  return ht(ht({}, b), {}, {
    inputValue: G,
    menuIsOpen: $,
    onChange: B,
    onInputChange: P,
    onMenuClose: L,
    onMenuOpen: H,
    value: K
  });
}
function vfe(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function XI(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, bV(r.key), r);
  }
}
function yfe(e, t, n) {
  return t && XI(e.prototype, t), n && XI(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function bfe(e, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && s2(e, t);
}
function b2(e) {
  return b2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, b2(e);
}
function xV() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (xV = function() {
    return !!e;
  })();
}
function wfe(e, t) {
  if (t && (zm(t) == "object" || typeof t == "function")) return t;
  if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return L7(e);
}
function xfe(e) {
  var t = xV();
  return function() {
    var n, r = b2(e);
    if (t) {
      var a = b2(this).constructor;
      n = Reflect.construct(r, arguments, a);
    } else n = r.apply(this, arguments);
    return wfe(this, n);
  };
}
function Sfe(e) {
  if (Array.isArray(e)) return l3(e);
}
function kfe(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function _fe() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function U4(e) {
  return Sfe(e) || kfe(e) || wV(e) || _fe();
}
function Efe(e, t) {
  return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
    raw: {
      value: Object.freeze(t)
    }
  }));
}
var u3 = M.useLayoutEffect, Cfe = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"], w2 = function() {
};
function Ofe(e, t) {
  return t ? t[0] === "-" ? e + t : e + "__" + t : e;
}
function Mfe(e, t) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), a = 2; a < n; a++)
    r[a - 2] = arguments[a];
  var s = [].concat(r);
  if (t && e)
    for (var l in t)
      t.hasOwnProperty(l) && t[l] && s.push("".concat(Ofe(e, l)));
  return s.filter(function(c) {
    return c;
  }).map(function(c) {
    return String(c).trim();
  }).join(" ");
}
var JI = function(e) {
  return zfe(e) ? e.filter(Boolean) : zm(e) === "object" && e !== null ? [e] : [];
}, SV = function(e) {
  e.className, e.clearValue, e.cx, e.getStyles, e.getClassNames, e.getValue, e.hasValue, e.isMulti, e.isRtl, e.options, e.selectOption, e.selectProps, e.setValue, e.theme;
  var t = Yc(e, Cfe);
  return ht({}, t);
}, kr = function(e, t, n) {
  var r = e.cx, a = e.getStyles, s = e.getClassNames, l = e.className;
  return {
    css: a(t, e),
    className: r(n ?? {}, s(t, e), l)
  };
};
function WE(e) {
  return [document.documentElement, document.body, window].indexOf(e) > -1;
}
function Nfe(e) {
  return WE(e) ? window.innerHeight : e.clientHeight;
}
function kV(e) {
  return WE(e) ? window.pageYOffset : e.scrollTop;
}
function x2(e, t) {
  if (WE(e)) {
    window.scrollTo(0, t);
    return;
  }
  e.scrollTop = t;
}
function Afe(e) {
  var t = getComputedStyle(e), n = t.position === "absolute", r = /(auto|scroll)/;
  if (t.position === "fixed") return document.documentElement;
  for (var a = e; a = a.parentElement; )
    if (t = getComputedStyle(a), !(n && t.position === "static") && r.test(t.overflow + t.overflowY + t.overflowX))
      return a;
  return document.documentElement;
}
function Rfe(e, t, n, r) {
  return n * ((e = e / r - 1) * e * e + 1) + t;
}
function Zk(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : w2, a = kV(e), s = t - a, l = 10, c = 0;
  function d() {
    c += l;
    var f = Rfe(c, a, s, n);
    x2(e, f), c < n ? window.requestAnimationFrame(d) : r(e);
  }
  d();
}
function QI(e, t) {
  var n = e.getBoundingClientRect(), r = t.getBoundingClientRect(), a = t.offsetHeight / 3;
  r.bottom + a > n.bottom ? x2(e, Math.min(t.offsetTop + t.clientHeight - e.offsetHeight + a, e.scrollHeight)) : r.top - a < n.top && x2(e, Math.max(t.offsetTop - a, 0));
}
function jfe(e) {
  var t = e.getBoundingClientRect();
  return {
    bottom: t.bottom,
    height: t.height,
    left: t.left,
    right: t.right,
    top: t.top,
    width: t.width
  };
}
function ZI() {
  try {
    return document.createEvent("TouchEvent"), !0;
  } catch {
    return !1;
  }
}
function Pfe() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch {
    return !1;
  }
}
var _V = !1, Dfe = {
  get passive() {
    return _V = !0;
  }
}, e0 = typeof window < "u" ? window : {};
e0.addEventListener && e0.removeEventListener && (e0.addEventListener("p", w2, Dfe), e0.removeEventListener("p", w2, !1));
var Ife = _V;
function $fe(e) {
  return e != null;
}
function zfe(e) {
  return Array.isArray(e);
}
function t0(e, t, n) {
  return e ? t : n;
}
var Tfe = function(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  var a = Object.entries(e).filter(function(s) {
    var l = jc(s, 1), c = l[0];
    return !n.includes(c);
  });
  return a.reduce(function(s, l) {
    var c = jc(l, 2), d = c[0], f = c[1];
    return s[d] = f, s;
  }, {});
}, Lfe = ["children", "innerProps"], Ffe = ["children", "innerProps"];
function Bfe(e) {
  var t = e.maxHeight, n = e.menuEl, r = e.minHeight, a = e.placement, s = e.shouldScroll, l = e.isFixedPosition, c = e.controlHeight, d = Afe(n), f = {
    placement: "bottom",
    maxHeight: t
  };
  if (!n || !n.offsetParent) return f;
  var m = d.getBoundingClientRect(), h = m.height, v = n.getBoundingClientRect(), g = v.bottom, b = v.height, x = v.top, w = n.offsetParent.getBoundingClientRect(), k = w.top, E = l ? window.innerHeight : Nfe(d), _ = kV(d), O = parseInt(getComputedStyle(n).marginBottom, 10), N = parseInt(getComputedStyle(n).marginTop, 10), A = k - N, R = E - x, D = A + _, I = h - _ - x, z = g - E + _ + O, B = _ + x - N, P = 160;
  switch (a) {
    case "auto":
    case "bottom":
      if (R >= b)
        return {
          placement: "bottom",
          maxHeight: t
        };
      if (I >= b && !l)
        return s && Zk(d, z, P), {
          placement: "bottom",
          maxHeight: t
        };
      if (!l && I >= r || l && R >= r) {
        s && Zk(d, z, P);
        var H = l ? R - O : I - O;
        return {
          placement: "bottom",
          maxHeight: H
        };
      }
      if (a === "auto" || l) {
        var L = t, G = l ? A : D;
        return G >= r && (L = Math.min(G - O - c, t)), {
          placement: "top",
          maxHeight: L
        };
      }
      if (a === "bottom")
        return s && x2(d, z), {
          placement: "bottom",
          maxHeight: t
        };
      break;
    case "top":
      if (A >= b)
        return {
          placement: "top",
          maxHeight: t
        };
      if (D >= b && !l)
        return s && Zk(d, B, P), {
          placement: "top",
          maxHeight: t
        };
      if (!l && D >= r || l && A >= r) {
        var $ = t;
        return (!l && D >= r || l && A >= r) && ($ = l ? A - N : D - N), s && Zk(d, B, P), {
          placement: "top",
          maxHeight: $
        };
      }
      return {
        placement: "bottom",
        maxHeight: t
      };
    default:
      throw new Error('Invalid placement provided "'.concat(a, '".'));
  }
  return f;
}
function Ufe(e) {
  var t = {
    bottom: "top",
    top: "bottom"
  };
  return e ? t[e] : "bottom";
}
var EV = function(e) {
  return e === "auto" ? "bottom" : e;
}, Vfe = function(e, t) {
  var n, r = e.placement, a = e.theme, s = a.borderRadius, l = a.spacing, c = a.colors;
  return ht((n = {
    label: "menu"
  }, yx(n, Ufe(r), "100%"), yx(n, "position", "absolute"), yx(n, "width", "100%"), yx(n, "zIndex", 1), n), t ? {} : {
    backgroundColor: c.neutral0,
    borderRadius: s,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: l.menuGutter,
    marginTop: l.menuGutter
  });
}, CV = /* @__PURE__ */ M.createContext(null), Hfe = function(e) {
  var t = e.children, n = e.minMenuHeight, r = e.maxMenuHeight, a = e.menuPlacement, s = e.menuPosition, l = e.menuShouldScrollIntoView, c = e.theme, d = M.useContext(CV) || {}, f = d.setPortalPlacement, m = M.useRef(null), h = M.useState(r), v = jc(h, 2), g = v[0], b = v[1], x = M.useState(null), w = jc(x, 2), k = w[0], E = w[1], _ = c.spacing.controlHeight;
  return u3(function() {
    var O = m.current;
    if (O) {
      var N = s === "fixed", A = l && !N, R = Bfe({
        maxHeight: r,
        menuEl: O,
        minHeight: n,
        placement: a,
        shouldScroll: A,
        isFixedPosition: N,
        controlHeight: _
      });
      b(R.maxHeight), E(R.placement), f?.(R.placement);
    }
  }, [r, a, s, l, n, f, _]), t({
    ref: m,
    placerProps: ht(ht({}, e), {}, {
      placement: k || EV(a),
      maxHeight: g
    })
  });
}, Wfe = function(e) {
  var t = e.children, n = e.innerRef, r = e.innerProps;
  return ct("div", mt({}, kr(e, "menu", {
    menu: !0
  }), {
    ref: n
  }, r), t);
}, qfe = Wfe, Gfe = function(e, t) {
  var n = e.maxHeight, r = e.theme.spacing.baseUnit;
  return ht({
    maxHeight: n,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, t ? {} : {
    paddingBottom: r,
    paddingTop: r
  });
}, Kfe = function(e) {
  var t = e.children, n = e.innerProps, r = e.innerRef, a = e.isMulti;
  return ct("div", mt({}, kr(e, "menuList", {
    "menu-list": !0,
    "menu-list--is-multi": a
  }), {
    ref: r
  }, n), t);
}, OV = function(e, t) {
  var n = e.theme, r = n.spacing.baseUnit, a = n.colors;
  return ht({
    textAlign: "center"
  }, t ? {} : {
    color: a.neutral40,
    padding: "".concat(r * 2, "px ").concat(r * 3, "px")
  });
}, Yfe = OV, Xfe = OV, Jfe = function(e) {
  var t = e.children, n = t === void 0 ? "No options" : t, r = e.innerProps, a = Yc(e, Lfe);
  return ct("div", mt({}, kr(ht(ht({}, a), {}, {
    children: n,
    innerProps: r
  }), "noOptionsMessage", {
    "menu-notice": !0,
    "menu-notice--no-options": !0
  }), r), n);
}, Qfe = function(e) {
  var t = e.children, n = t === void 0 ? "Loading..." : t, r = e.innerProps, a = Yc(e, Ffe);
  return ct("div", mt({}, kr(ht(ht({}, a), {}, {
    children: n,
    innerProps: r
  }), "loadingMessage", {
    "menu-notice": !0,
    "menu-notice--loading": !0
  }), r), n);
}, Zfe = function(e) {
  var t = e.rect, n = e.offset, r = e.position;
  return {
    left: t.left,
    position: r,
    top: n,
    width: t.width,
    zIndex: 1
  };
}, epe = function(e) {
  var t = e.appendTo, n = e.children, r = e.controlElement, a = e.innerProps, s = e.menuPlacement, l = e.menuPosition, c = M.useRef(null), d = M.useRef(null), f = M.useState(EV(s)), m = jc(f, 2), h = m[0], v = m[1], g = M.useMemo(function() {
    return {
      setPortalPlacement: v
    };
  }, []), b = M.useState(null), x = jc(b, 2), w = x[0], k = x[1], E = M.useCallback(function() {
    if (r) {
      var A = jfe(r), R = l === "fixed" ? 0 : window.pageYOffset, D = A[h] + R;
      (D !== w?.offset || A.left !== w?.rect.left || A.width !== w?.rect.width) && k({
        offset: D,
        rect: A
      });
    }
  }, [r, l, h, w?.offset, w?.rect.left, w?.rect.width]);
  u3(function() {
    E();
  }, [E]);
  var _ = M.useCallback(function() {
    typeof d.current == "function" && (d.current(), d.current = null), r && c.current && (d.current = UU(r, c.current, E, {
      elementResize: "ResizeObserver" in window
    }));
  }, [r, E]);
  u3(function() {
    _();
  }, [_]);
  var O = M.useCallback(function(A) {
    c.current = A, _();
  }, [_]);
  if (!t && l !== "fixed" || !w) return null;
  var N = ct("div", mt({
    ref: O
  }, kr(ht(ht({}, e), {}, {
    offset: w.offset,
    position: l,
    rect: w.rect
  }), "menuPortal", {
    "menu-portal": !0
  }), a), n);
  return ct(CV.Provider, {
    value: g
  }, t ? /* @__PURE__ */ Xm.createPortal(N, t) : N);
}, tpe = function(e) {
  var t = e.isDisabled, n = e.isRtl;
  return {
    label: "container",
    direction: n ? "rtl" : void 0,
    pointerEvents: t ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
}, npe = function(e) {
  var t = e.children, n = e.innerProps, r = e.isDisabled, a = e.isRtl;
  return ct("div", mt({}, kr(e, "container", {
    "--is-disabled": r,
    "--is-rtl": a
  }), n), t);
}, rpe = function(e, t) {
  var n = e.theme.spacing, r = e.isMulti, a = e.hasValue, s = e.selectProps.controlShouldRenderValue;
  return ht({
    alignItems: "center",
    display: r && a && s ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, t ? {} : {
    padding: "".concat(n.baseUnit / 2, "px ").concat(n.baseUnit * 2, "px")
  });
}, ope = function(e) {
  var t = e.children, n = e.innerProps, r = e.isMulti, a = e.hasValue;
  return ct("div", mt({}, kr(e, "valueContainer", {
    "value-container": !0,
    "value-container--is-multi": r,
    "value-container--has-value": a
  }), n), t);
}, ape = function() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
}, ipe = function(e) {
  var t = e.children, n = e.innerProps;
  return ct("div", mt({}, kr(e, "indicatorsContainer", {
    indicators: !0
  }), n), t);
}, e$, spe = ["size"], lpe = ["innerProps", "isRtl", "size"], upe = {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
}, MV = function(e) {
  var t = e.size, n = Yc(e, spe);
  return ct("svg", mt({
    height: t,
    width: t,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: upe
  }, n));
}, V4 = function(e) {
  return ct(MV, mt({
    size: 20
  }, e), ct("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
}, NV = function(e) {
  return ct(MV, mt({
    size: 20
  }, e), ct("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
}, AV = function(e, t) {
  var n = e.isFocused, r = e.theme, a = r.spacing.baseUnit, s = r.colors;
  return ht({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, t ? {} : {
    color: n ? s.neutral60 : s.neutral20,
    padding: a * 2,
    ":hover": {
      color: n ? s.neutral80 : s.neutral40
    }
  });
}, cpe = AV, dpe = function(e) {
  var t = e.children, n = e.innerProps;
  return ct("div", mt({}, kr(e, "dropdownIndicator", {
    indicator: !0,
    "dropdown-indicator": !0
  }), n), t || ct(NV, null));
}, fpe = AV, ppe = function(e) {
  var t = e.children, n = e.innerProps;
  return ct("div", mt({}, kr(e, "clearIndicator", {
    indicator: !0,
    "clear-indicator": !0
  }), n), t || ct(V4, null));
}, mpe = function(e, t) {
  var n = e.isDisabled, r = e.theme, a = r.spacing.baseUnit, s = r.colors;
  return ht({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, t ? {} : {
    backgroundColor: n ? s.neutral10 : s.neutral20,
    marginBottom: a * 2,
    marginTop: a * 2
  });
}, hpe = function(e) {
  var t = e.innerProps;
  return ct("span", mt({}, t, kr(e, "indicatorSeparator", {
    "indicator-separator": !0
  })));
}, gpe = $g(e$ || (e$ = Efe([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`]))), vpe = function(e, t) {
  var n = e.isFocused, r = e.size, a = e.theme, s = a.colors, l = a.spacing.baseUnit;
  return ht({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: r,
    lineHeight: 1,
    marginRight: r,
    textAlign: "center",
    verticalAlign: "middle"
  }, t ? {} : {
    color: n ? s.neutral60 : s.neutral20,
    padding: l * 2
  });
}, UN = function(e) {
  var t = e.delay, n = e.offset;
  return ct("span", {
    css: /* @__PURE__ */ YS({
      animation: "".concat(gpe, " 1s ease-in-out ").concat(t, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: n ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, "", "")
  });
}, ype = function(e) {
  var t = e.innerProps, n = e.isRtl, r = e.size, a = r === void 0 ? 4 : r, s = Yc(e, lpe);
  return ct("div", mt({}, kr(ht(ht({}, s), {}, {
    innerProps: t,
    isRtl: n,
    size: a
  }), "loadingIndicator", {
    indicator: !0,
    "loading-indicator": !0
  }), t), ct(UN, {
    delay: 0,
    offset: n
  }), ct(UN, {
    delay: 160,
    offset: !0
  }), ct(UN, {
    delay: 320,
    offset: !n
  }));
}, bpe = function(e, t) {
  var n = e.isDisabled, r = e.isFocused, a = e.theme, s = a.colors, l = a.borderRadius, c = a.spacing;
  return ht({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: c.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, t ? {} : {
    backgroundColor: n ? s.neutral5 : s.neutral0,
    borderColor: n ? s.neutral10 : r ? s.primary : s.neutral20,
    borderRadius: l,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: r ? "0 0 0 1px ".concat(s.primary) : void 0,
    "&:hover": {
      borderColor: r ? s.primary : s.neutral30
    }
  });
}, wpe = function(e) {
  var t = e.children, n = e.isDisabled, r = e.isFocused, a = e.innerRef, s = e.innerProps, l = e.menuIsOpen;
  return ct("div", mt({
    ref: a
  }, kr(e, "control", {
    control: !0,
    "control--is-disabled": n,
    "control--is-focused": r,
    "control--menu-is-open": l
  }), s, {
    "aria-disabled": n || void 0
  }), t);
}, xpe = wpe, Spe = ["data"], kpe = function(e, t) {
  var n = e.theme.spacing;
  return t ? {} : {
    paddingBottom: n.baseUnit * 2,
    paddingTop: n.baseUnit * 2
  };
}, _pe = function(e) {
  var t = e.children, n = e.cx, r = e.getStyles, a = e.getClassNames, s = e.Heading, l = e.headingProps, c = e.innerProps, d = e.label, f = e.theme, m = e.selectProps;
  return ct("div", mt({}, kr(e, "group", {
    group: !0
  }), c), ct(s, mt({}, l, {
    selectProps: m,
    theme: f,
    getStyles: r,
    getClassNames: a,
    cx: n
  }), d), ct("div", null, t));
}, Epe = function(e, t) {
  var n = e.theme, r = n.colors, a = n.spacing;
  return ht({
    label: "group",
    cursor: "default",
    display: "block"
  }, t ? {} : {
    color: r.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: a.baseUnit * 3,
    paddingRight: a.baseUnit * 3,
    textTransform: "uppercase"
  });
}, Cpe = function(e) {
  var t = SV(e);
  t.data;
  var n = Yc(t, Spe);
  return ct("div", mt({}, kr(e, "groupHeading", {
    "group-heading": !0
  }), n));
}, Ope = _pe, Mpe = ["innerRef", "isDisabled", "isHidden", "inputClassName"], Npe = function(e, t) {
  var n = e.isDisabled, r = e.value, a = e.theme, s = a.spacing, l = a.colors;
  return ht(ht({
    visibility: n ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: r ? "translateZ(0)" : ""
  }, Ape), t ? {} : {
    margin: s.baseUnit / 2,
    paddingBottom: s.baseUnit / 2,
    paddingTop: s.baseUnit / 2,
    color: l.neutral80
  });
}, RV = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
}, Ape = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": ht({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, RV)
}, Rpe = function(e) {
  return ht({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: e ? 0 : 1,
    width: "100%"
  }, RV);
}, jpe = function(e) {
  var t = e.cx, n = e.value, r = SV(e), a = r.innerRef, s = r.isDisabled, l = r.isHidden, c = r.inputClassName, d = Yc(r, Mpe);
  return ct("div", mt({}, kr(e, "input", {
    "input-container": !0
  }), {
    "data-value": n || ""
  }), ct("input", mt({
    className: t({
      input: !0
    }, c),
    ref: a,
    style: Rpe(l),
    disabled: s
  }, d)));
}, Ppe = jpe, Dpe = function(e, t) {
  var n = e.theme, r = n.spacing, a = n.borderRadius, s = n.colors;
  return ht({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, t ? {} : {
    backgroundColor: s.neutral10,
    borderRadius: a / 2,
    margin: r.baseUnit / 2
  });
}, Ipe = function(e, t) {
  var n = e.theme, r = n.borderRadius, a = n.colors, s = e.cropWithEllipsis;
  return ht({
    overflow: "hidden",
    textOverflow: s || s === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, t ? {} : {
    borderRadius: r / 2,
    color: a.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
}, $pe = function(e, t) {
  var n = e.theme, r = n.spacing, a = n.borderRadius, s = n.colors, l = e.isFocused;
  return ht({
    alignItems: "center",
    display: "flex"
  }, t ? {} : {
    borderRadius: a / 2,
    backgroundColor: l ? s.dangerLight : void 0,
    paddingLeft: r.baseUnit,
    paddingRight: r.baseUnit,
    ":hover": {
      backgroundColor: s.dangerLight,
      color: s.danger
    }
  });
}, jV = function(e) {
  var t = e.children, n = e.innerProps;
  return ct("div", n, t);
}, zpe = jV, Tpe = jV;
function Lpe(e) {
  var t = e.children, n = e.innerProps;
  return ct("div", mt({
    role: "button"
  }, n), t || ct(V4, {
    size: 14
  }));
}
var Fpe = function(e) {
  var t = e.children, n = e.components, r = e.data, a = e.innerProps, s = e.isDisabled, l = e.removeProps, c = e.selectProps, d = n.Container, f = n.Label, m = n.Remove;
  return ct(d, {
    data: r,
    innerProps: ht(ht({}, kr(e, "multiValue", {
      "multi-value": !0,
      "multi-value--is-disabled": s
    })), a),
    selectProps: c
  }, ct(f, {
    data: r,
    innerProps: ht({}, kr(e, "multiValueLabel", {
      "multi-value__label": !0
    })),
    selectProps: c
  }, t), ct(m, {
    data: r,
    innerProps: ht(ht({}, kr(e, "multiValueRemove", {
      "multi-value__remove": !0
    })), {}, {
      "aria-label": "Remove ".concat(t || "option")
    }, l),
    selectProps: c
  }));
}, Bpe = Fpe, Upe = function(e, t) {
  var n = e.isDisabled, r = e.isFocused, a = e.isSelected, s = e.theme, l = s.spacing, c = s.colors;
  return ht({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, t ? {} : {
    backgroundColor: a ? c.primary : r ? c.primary25 : "transparent",
    color: n ? c.neutral20 : a ? c.neutral0 : "inherit",
    padding: "".concat(l.baseUnit * 2, "px ").concat(l.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: n ? void 0 : a ? c.primary : c.primary50
    }
  });
}, Vpe = function(e) {
  var t = e.children, n = e.isDisabled, r = e.isFocused, a = e.isSelected, s = e.innerRef, l = e.innerProps;
  return ct("div", mt({}, kr(e, "option", {
    option: !0,
    "option--is-disabled": n,
    "option--is-focused": r,
    "option--is-selected": a
  }), {
    ref: s,
    "aria-disabled": n
  }, l), t);
}, Hpe = Vpe, Wpe = function(e, t) {
  var n = e.theme, r = n.spacing, a = n.colors;
  return ht({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, t ? {} : {
    color: a.neutral50,
    marginLeft: r.baseUnit / 2,
    marginRight: r.baseUnit / 2
  });
}, qpe = function(e) {
  var t = e.children, n = e.innerProps;
  return ct("div", mt({}, kr(e, "placeholder", {
    placeholder: !0
  }), n), t);
}, Gpe = qpe, Kpe = function(e, t) {
  var n = e.isDisabled, r = e.theme, a = r.spacing, s = r.colors;
  return ht({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, t ? {} : {
    color: n ? s.neutral40 : s.neutral80,
    marginLeft: a.baseUnit / 2,
    marginRight: a.baseUnit / 2
  });
}, Ype = function(e) {
  var t = e.children, n = e.isDisabled, r = e.innerProps;
  return ct("div", mt({}, kr(e, "singleValue", {
    "single-value": !0,
    "single-value--is-disabled": n
  }), r), t);
}, Xpe = Ype, Jpe = {
  ClearIndicator: ppe,
  Control: xpe,
  DropdownIndicator: dpe,
  DownChevron: NV,
  CrossIcon: V4,
  Group: Ope,
  GroupHeading: Cpe,
  IndicatorsContainer: ipe,
  IndicatorSeparator: hpe,
  Input: Ppe,
  LoadingIndicator: ype,
  Menu: qfe,
  MenuList: Kfe,
  MenuPortal: epe,
  LoadingMessage: Qfe,
  NoOptionsMessage: Jfe,
  MultiValue: Bpe,
  MultiValueContainer: zpe,
  MultiValueLabel: Tpe,
  MultiValueRemove: Lpe,
  Option: Hpe,
  Placeholder: Gpe,
  SelectContainer: npe,
  SingleValue: Xpe,
  ValueContainer: ope
}, Qpe = function(e) {
  return ht(ht({}, Jpe), e.components);
}, t$ = Number.isNaN || function(e) {
  return typeof e == "number" && e !== e;
};
function Zpe(e, t) {
  return !!(e === t || t$(e) && t$(t));
}
function eme(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++)
    if (!Zpe(e[n], t[n]))
      return !1;
  return !0;
}
function tme(e, t) {
  t === void 0 && (t = eme);
  var n = null;
  function r() {
    for (var a = [], s = 0; s < arguments.length; s++)
      a[s] = arguments[s];
    if (n && n.lastThis === this && t(a, n.lastArgs))
      return n.lastResult;
    var l = e.apply(this, a);
    return n = {
      lastResult: l,
      lastArgs: a,
      lastThis: this
    }, l;
  }
  return r.clear = function() {
    n = null;
  }, r;
}
var nme = {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
}, rme = function(e) {
  return ct("span", mt({
    css: nme
  }, e));
}, n$ = rme, ome = {
  guidance: function(e) {
    var t = e.isSearchable, n = e.isMulti, r = e.tabSelectsValue, a = e.context, s = e.isInitialFocus;
    switch (a) {
      case "menu":
        return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(r ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return s ? "".concat(e["aria-label"] || "Select", " is focused ").concat(t ? ",type to refine list" : "", ", press Down to open the menu, ").concat(n ? " press left to focus selected values" : "") : "";
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function(e) {
    var t = e.action, n = e.label, r = n === void 0 ? "" : n, a = e.labels, s = e.isDisabled;
    switch (t) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(r, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(a.length > 1 ? "s" : "", " ").concat(a.join(","), ", selected.");
      case "select-option":
        return s ? "option ".concat(r, " is disabled. Select another option.") : "option ".concat(r, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function(e) {
    var t = e.context, n = e.focused, r = e.options, a = e.label, s = a === void 0 ? "" : a, l = e.selectValue, c = e.isDisabled, d = e.isSelected, f = e.isAppleDevice, m = function(g, b) {
      return g && g.length ? "".concat(g.indexOf(b) + 1, " of ").concat(g.length) : "";
    };
    if (t === "value" && l)
      return "value ".concat(s, " focused, ").concat(m(l, n), ".");
    if (t === "menu" && f) {
      var h = c ? " disabled" : "", v = "".concat(d ? " selected" : "").concat(h);
      return "".concat(s).concat(v, ", ").concat(m(r, n), ".");
    }
    return "";
  },
  onFilter: function(e) {
    var t = e.inputValue, n = e.resultsMessage;
    return "".concat(n).concat(t ? " for search term " + t : "", ".");
  }
}, ame = function(e) {
  var t = e.ariaSelection, n = e.focusedOption, r = e.focusedValue, a = e.focusableOptions, s = e.isFocused, l = e.selectValue, c = e.selectProps, d = e.id, f = e.isAppleDevice, m = c.ariaLiveMessages, h = c.getOptionLabel, v = c.inputValue, g = c.isMulti, b = c.isOptionDisabled, x = c.isSearchable, w = c.menuIsOpen, k = c.options, E = c.screenReaderStatus, _ = c.tabSelectsValue, O = c.isLoading, N = c["aria-label"], A = c["aria-live"], R = M.useMemo(function() {
    return ht(ht({}, ome), m || {});
  }, [m]), D = M.useMemo(function() {
    var L = "";
    if (t && R.onChange) {
      var G = t.option, $ = t.options, K = t.removedValue, q = t.removedValues, Z = t.value, V = function(oe) {
        return Array.isArray(oe) ? null : oe;
      }, F = K || G || V(Z), Y = F ? h(F) : "", U = $ || q || void 0, W = U ? U.map(h) : [], J = ht({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: F && b(F, l),
        label: Y,
        labels: W
      }, t);
      L = R.onChange(J);
    }
    return L;
  }, [t, R, b, l, h]), I = M.useMemo(function() {
    var L = "", G = n || r, $ = !!(n && l && l.includes(n));
    if (G && R.onFocus) {
      var K = {
        focused: G,
        label: h(G),
        isDisabled: b(G, l),
        isSelected: $,
        options: a,
        context: G === n ? "menu" : "value",
        selectValue: l,
        isAppleDevice: f
      };
      L = R.onFocus(K);
    }
    return L;
  }, [n, r, h, b, R, a, l, f]), z = M.useMemo(function() {
    var L = "";
    if (w && k.length && !O && R.onFilter) {
      var G = E({
        count: a.length
      });
      L = R.onFilter({
        inputValue: v,
        resultsMessage: G
      });
    }
    return L;
  }, [a, v, w, R, k, E, O]), B = t?.action === "initial-input-focus", P = M.useMemo(function() {
    var L = "";
    if (R.guidance) {
      var G = r ? "value" : w ? "menu" : "input";
      L = R.guidance({
        "aria-label": N,
        context: G,
        isDisabled: n && b(n, l),
        isMulti: g,
        isSearchable: x,
        tabSelectsValue: _,
        isInitialFocus: B
      });
    }
    return L;
  }, [N, n, r, g, b, x, w, R, l, _, B]), H = ct(M.Fragment, null, ct("span", {
    id: "aria-selection"
  }, D), ct("span", {
    id: "aria-focused"
  }, I), ct("span", {
    id: "aria-results"
  }, z), ct("span", {
    id: "aria-guidance"
  }, P));
  return ct(M.Fragment, null, ct(n$, {
    id: d
  }, B && H), ct(n$, {
    "aria-live": A,
    "aria-atomic": "false",
    "aria-relevant": "additions text",
    role: "log"
  }, s && !B && H));
}, ime = ame, c3 = [{
  base: "A",
  letters: "A"
}, {
  base: "AA",
  letters: ""
}, {
  base: "AE",
  letters: ""
}, {
  base: "AO",
  letters: ""
}, {
  base: "AU",
  letters: ""
}, {
  base: "AV",
  letters: ""
}, {
  base: "AY",
  letters: ""
}, {
  base: "B",
  letters: "B"
}, {
  base: "C",
  letters: "C"
}, {
  base: "D",
  letters: "D"
}, {
  base: "DZ",
  letters: ""
}, {
  base: "Dz",
  letters: ""
}, {
  base: "E",
  letters: "E"
}, {
  base: "F",
  letters: "F"
}, {
  base: "G",
  letters: "G"
}, {
  base: "H",
  letters: "H"
}, {
  base: "I",
  letters: "I"
}, {
  base: "J",
  letters: "J"
}, {
  base: "K",
  letters: "K"
}, {
  base: "L",
  letters: "L"
}, {
  base: "LJ",
  letters: ""
}, {
  base: "Lj",
  letters: ""
}, {
  base: "M",
  letters: "M"
}, {
  base: "N",
  letters: "N"
}, {
  base: "NJ",
  letters: ""
}, {
  base: "Nj",
  letters: ""
}, {
  base: "O",
  letters: "O"
}, {
  base: "OI",
  letters: ""
}, {
  base: "OO",
  letters: ""
}, {
  base: "OU",
  letters: ""
}, {
  base: "P",
  letters: "P"
}, {
  base: "Q",
  letters: "Q"
}, {
  base: "R",
  letters: "R"
}, {
  base: "S",
  letters: "S"
}, {
  base: "T",
  letters: "T"
}, {
  base: "TZ",
  letters: ""
}, {
  base: "U",
  letters: "U"
}, {
  base: "V",
  letters: "V"
}, {
  base: "VY",
  letters: ""
}, {
  base: "W",
  letters: "W"
}, {
  base: "X",
  letters: "X"
}, {
  base: "Y",
  letters: "Y"
}, {
  base: "Z",
  letters: "Z"
}, {
  base: "a",
  letters: "a"
}, {
  base: "aa",
  letters: ""
}, {
  base: "ae",
  letters: ""
}, {
  base: "ao",
  letters: ""
}, {
  base: "au",
  letters: ""
}, {
  base: "av",
  letters: ""
}, {
  base: "ay",
  letters: ""
}, {
  base: "b",
  letters: "b"
}, {
  base: "c",
  letters: "c"
}, {
  base: "d",
  letters: "d"
}, {
  base: "dz",
  letters: ""
}, {
  base: "e",
  letters: "e"
}, {
  base: "f",
  letters: "f"
}, {
  base: "g",
  letters: "g"
}, {
  base: "h",
  letters: "h"
}, {
  base: "hv",
  letters: ""
}, {
  base: "i",
  letters: "i"
}, {
  base: "j",
  letters: "j"
}, {
  base: "k",
  letters: "k"
}, {
  base: "l",
  letters: "l"
}, {
  base: "lj",
  letters: ""
}, {
  base: "m",
  letters: "m"
}, {
  base: "n",
  letters: "n"
}, {
  base: "nj",
  letters: ""
}, {
  base: "o",
  letters: "o"
}, {
  base: "oi",
  letters: ""
}, {
  base: "ou",
  letters: ""
}, {
  base: "oo",
  letters: ""
}, {
  base: "p",
  letters: "p"
}, {
  base: "q",
  letters: "q"
}, {
  base: "r",
  letters: "r"
}, {
  base: "s",
  letters: "s"
}, {
  base: "t",
  letters: "t"
}, {
  base: "tz",
  letters: ""
}, {
  base: "u",
  letters: "u"
}, {
  base: "v",
  letters: "v"
}, {
  base: "vy",
  letters: ""
}, {
  base: "w",
  letters: "w"
}, {
  base: "x",
  letters: "x"
}, {
  base: "y",
  letters: "y"
}, {
  base: "z",
  letters: "z"
}], sme = new RegExp("[" + c3.map(function(e) {
  return e.letters;
}).join("") + "]", "g"), PV = {};
for (var VN = 0; VN < c3.length; VN++)
  for (var HN = c3[VN], WN = 0; WN < HN.letters.length; WN++)
    PV[HN.letters[WN]] = HN.base;
var DV = function(e) {
  return e.replace(sme, function(t) {
    return PV[t];
  });
}, lme = tme(DV), r$ = function(e) {
  return e.replace(/^\s+|\s+$/g, "");
}, ume = function(e) {
  return "".concat(e.label, " ").concat(e.value);
}, cme = function(e) {
  return function(t, n) {
    if (t.data.__isNew__) return !0;
    var r = ht({
      ignoreCase: !0,
      ignoreAccents: !0,
      stringify: ume,
      trim: !0,
      matchFrom: "any"
    }, e), a = r.ignoreCase, s = r.ignoreAccents, l = r.stringify, c = r.trim, d = r.matchFrom, f = c ? r$(n) : n, m = c ? r$(l(t)) : l(t);
    return a && (f = f.toLowerCase(), m = m.toLowerCase()), s && (f = lme(f), m = DV(m)), d === "start" ? m.substr(0, f.length) === f : m.indexOf(f) > -1;
  };
}, dme = ["innerRef"];
function fme(e) {
  var t = e.innerRef, n = Yc(e, dme), r = Tfe(n, "onExited", "in", "enter", "exit", "appear");
  return ct("input", mt({
    ref: t
  }, r, {
    css: /* @__PURE__ */ YS({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, "", "")
  }));
}
var pme = function(e) {
  e.cancelable && e.preventDefault(), e.stopPropagation();
};
function mme(e) {
  var t = e.isEnabled, n = e.onBottomArrive, r = e.onBottomLeave, a = e.onTopArrive, s = e.onTopLeave, l = M.useRef(!1), c = M.useRef(!1), d = M.useRef(0), f = M.useRef(null), m = M.useCallback(function(w, k) {
    if (f.current !== null) {
      var E = f.current, _ = E.scrollTop, O = E.scrollHeight, N = E.clientHeight, A = f.current, R = k > 0, D = O - N - _, I = !1;
      D > k && l.current && (r && r(w), l.current = !1), R && c.current && (s && s(w), c.current = !1), R && k > D ? (n && !l.current && n(w), A.scrollTop = O, I = !0, l.current = !0) : !R && -k > _ && (a && !c.current && a(w), A.scrollTop = 0, I = !0, c.current = !0), I && pme(w);
    }
  }, [n, r, a, s]), h = M.useCallback(function(w) {
    m(w, w.deltaY);
  }, [m]), v = M.useCallback(function(w) {
    d.current = w.changedTouches[0].clientY;
  }, []), g = M.useCallback(function(w) {
    var k = d.current - w.changedTouches[0].clientY;
    m(w, k);
  }, [m]), b = M.useCallback(function(w) {
    if (w) {
      var k = Ife ? {
        passive: !1
      } : !1;
      w.addEventListener("wheel", h, k), w.addEventListener("touchstart", v, k), w.addEventListener("touchmove", g, k);
    }
  }, [g, v, h]), x = M.useCallback(function(w) {
    w && (w.removeEventListener("wheel", h, !1), w.removeEventListener("touchstart", v, !1), w.removeEventListener("touchmove", g, !1));
  }, [g, v, h]);
  return M.useEffect(function() {
    if (t) {
      var w = f.current;
      return b(w), function() {
        x(w);
      };
    }
  }, [t, b, x]), function(w) {
    f.current = w;
  };
}
var o$ = ["boxSizing", "height", "overflow", "paddingRight", "position"], a$ = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function i$(e) {
  e.cancelable && e.preventDefault();
}
function s$(e) {
  e.stopPropagation();
}
function l$() {
  var e = this.scrollTop, t = this.scrollHeight, n = e + this.offsetHeight;
  e === 0 ? this.scrollTop = 1 : n === t && (this.scrollTop = e - 1);
}
function u$() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var c$ = !!(typeof window < "u" && window.document && window.document.createElement), Kw = 0, kh = {
  capture: !1,
  passive: !1
};
function hme(e) {
  var t = e.isEnabled, n = e.accountForScrollbars, r = n === void 0 ? !0 : n, a = M.useRef({}), s = M.useRef(null), l = M.useCallback(function(d) {
    if (c$) {
      var f = document.body, m = f && f.style;
      if (r && o$.forEach(function(b) {
        var x = m && m[b];
        a.current[b] = x;
      }), r && Kw < 1) {
        var h = parseInt(a.current.paddingRight, 10) || 0, v = document.body ? document.body.clientWidth : 0, g = window.innerWidth - v + h || 0;
        Object.keys(a$).forEach(function(b) {
          var x = a$[b];
          m && (m[b] = x);
        }), m && (m.paddingRight = "".concat(g, "px"));
      }
      f && u$() && (f.addEventListener("touchmove", i$, kh), d && (d.addEventListener("touchstart", l$, kh), d.addEventListener("touchmove", s$, kh))), Kw += 1;
    }
  }, [r]), c = M.useCallback(function(d) {
    if (c$) {
      var f = document.body, m = f && f.style;
      Kw = Math.max(Kw - 1, 0), r && Kw < 1 && o$.forEach(function(h) {
        var v = a.current[h];
        m && (m[h] = v);
      }), f && u$() && (f.removeEventListener("touchmove", i$, kh), d && (d.removeEventListener("touchstart", l$, kh), d.removeEventListener("touchmove", s$, kh)));
    }
  }, [r]);
  return M.useEffect(function() {
    if (t) {
      var d = s.current;
      return l(d), function() {
        c(d);
      };
    }
  }, [t, l, c]), function(d) {
    s.current = d;
  };
}
var gme = function(e) {
  var t = e.target;
  return t.ownerDocument.activeElement && t.ownerDocument.activeElement.blur();
}, vme = {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
};
function yme(e) {
  var t = e.children, n = e.lockEnabled, r = e.captureEnabled, a = r === void 0 ? !0 : r, s = e.onBottomArrive, l = e.onBottomLeave, c = e.onTopArrive, d = e.onTopLeave, f = mme({
    isEnabled: a,
    onBottomArrive: s,
    onBottomLeave: l,
    onTopArrive: c,
    onTopLeave: d
  }), m = hme({
    isEnabled: n
  }), h = function(v) {
    f(v), m(v);
  };
  return ct(M.Fragment, null, n && ct("div", {
    onClick: gme,
    css: vme
  }), t(h));
}
var bme = {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
}, wme = function(e) {
  var t = e.name, n = e.onFocus;
  return ct("input", {
    required: !0,
    name: t,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: n,
    css: bme,
    value: "",
    onChange: function() {
    }
  });
}, xme = wme;
function H4(e) {
  var t;
  return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1;
}
function Sme() {
  return H4(/^iPhone/i);
}
function IV() {
  return H4(/^Mac/i);
}
function kme() {
  return H4(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  IV() && navigator.maxTouchPoints > 1;
}
function _me() {
  return Sme() || kme();
}
function Eme() {
  return IV() || _me();
}
var Cme = function(e) {
  return e.label;
}, Ome = function(e) {
  return e.label;
}, Mme = function(e) {
  return e.value;
}, Nme = function(e) {
  return !!e.isDisabled;
}, Ame = {
  clearIndicator: fpe,
  container: tpe,
  control: bpe,
  dropdownIndicator: cpe,
  group: kpe,
  groupHeading: Epe,
  indicatorsContainer: ape,
  indicatorSeparator: mpe,
  input: Npe,
  loadingIndicator: vpe,
  loadingMessage: Xfe,
  menu: Vfe,
  menuList: Gfe,
  menuPortal: Zfe,
  multiValue: Dpe,
  multiValueLabel: Ipe,
  multiValueRemove: $pe,
  noOptionsMessage: Yfe,
  option: Upe,
  placeholder: Wpe,
  singleValue: Kpe,
  valueContainer: rpe
}, Rme = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
}, jme = 4, $V = 4, Pme = 38, Dme = $V * 2, Ime = {
  baseUnit: $V,
  controlHeight: Pme,
  menuGutter: Dme
}, qN = {
  borderRadius: jme,
  colors: Rme,
  spacing: Ime
}, $me = {
  "aria-live": "polite",
  backspaceRemovesValue: !0,
  blurInputOnSelect: ZI(),
  captureMenuScroll: !ZI(),
  classNames: {},
  closeMenuOnSelect: !0,
  closeMenuOnScroll: !1,
  components: {},
  controlShouldRenderValue: !0,
  escapeClearsValue: !1,
  filterOption: cme(),
  formatGroupLabel: Cme,
  getOptionLabel: Ome,
  getOptionValue: Mme,
  isDisabled: !1,
  isLoading: !1,
  isMulti: !1,
  isRtl: !1,
  isSearchable: !0,
  isOptionDisabled: Nme,
  loadingMessage: function() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: !1,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: !1,
  menuShouldScrollIntoView: !Pfe(),
  noOptionsMessage: function() {
    return "No options";
  },
  openMenuOnFocus: !1,
  openMenuOnClick: !0,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function(e) {
    var t = e.count;
    return "".concat(t, " result").concat(t !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: !0,
  unstyled: !1
};
function d$(e, t, n, r) {
  var a = LV(e, t, n), s = FV(e, t, n), l = TV(e, t), c = S2(e, t);
  return {
    type: "option",
    data: t,
    isDisabled: a,
    isSelected: s,
    label: l,
    value: c,
    index: r
  };
}
function D_(e, t) {
  return e.options.map(function(n, r) {
    if ("options" in n) {
      var a = n.options.map(function(l, c) {
        return d$(e, l, t, c);
      }).filter(function(l) {
        return p$(e, l);
      });
      return a.length > 0 ? {
        type: "group",
        data: n,
        options: a,
        index: r
      } : void 0;
    }
    var s = d$(e, n, t, r);
    return p$(e, s) ? s : void 0;
  }).filter($fe);
}
function zV(e) {
  return e.reduce(function(t, n) {
    return n.type === "group" ? t.push.apply(t, U4(n.options.map(function(r) {
      return r.data;
    }))) : t.push(n.data), t;
  }, []);
}
function f$(e, t) {
  return e.reduce(function(n, r) {
    return r.type === "group" ? n.push.apply(n, U4(r.options.map(function(a) {
      return {
        data: a.data,
        id: "".concat(t, "-").concat(r.index, "-").concat(a.index)
      };
    }))) : n.push({
      data: r.data,
      id: "".concat(t, "-").concat(r.index)
    }), n;
  }, []);
}
function zme(e, t) {
  return zV(D_(e, t));
}
function p$(e, t) {
  var n = e.inputValue, r = n === void 0 ? "" : n, a = t.data, s = t.isSelected, l = t.label, c = t.value;
  return (!UV(e) || !s) && BV(e, {
    label: l,
    value: c,
    data: a
  }, r);
}
function Tme(e, t) {
  var n = e.focusedValue, r = e.selectValue, a = r.indexOf(n);
  if (a > -1) {
    var s = t.indexOf(n);
    if (s > -1)
      return n;
    if (a < t.length)
      return t[a];
  }
  return null;
}
function Lme(e, t) {
  var n = e.focusedOption;
  return n && t.indexOf(n) > -1 ? n : t[0];
}
var GN = function(e, t) {
  var n, r = (n = e.find(function(a) {
    return a.data === t;
  })) === null || n === void 0 ? void 0 : n.id;
  return r || null;
}, TV = function(e, t) {
  return e.getOptionLabel(t);
}, S2 = function(e, t) {
  return e.getOptionValue(t);
};
function LV(e, t, n) {
  return typeof e.isOptionDisabled == "function" ? e.isOptionDisabled(t, n) : !1;
}
function FV(e, t, n) {
  if (n.indexOf(t) > -1) return !0;
  if (typeof e.isOptionSelected == "function")
    return e.isOptionSelected(t, n);
  var r = S2(e, t);
  return n.some(function(a) {
    return S2(e, a) === r;
  });
}
function BV(e, t, n) {
  return e.filterOption ? e.filterOption(t, n) : !0;
}
var UV = function(e) {
  var t = e.hideSelectedOptions, n = e.isMulti;
  return t === void 0 ? n : t;
}, Fme = 1, VV = /* @__PURE__ */ (function(e) {
  bfe(n, e);
  var t = xfe(n);
  function n(r) {
    var a;
    if (vfe(this, n), a = t.call(this, r), a.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedOptionId: null,
      focusableOptionsWithIds: [],
      focusedValue: null,
      inputIsHidden: !1,
      isFocused: !1,
      selectValue: [],
      clearFocusValueOnUpdate: !1,
      prevWasFocused: !1,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0,
      instancePrefix: "",
      isAppleDevice: !1
    }, a.blockOptionHover = !1, a.isComposing = !1, a.commonProps = void 0, a.initialTouchX = 0, a.initialTouchY = 0, a.openAfterFocus = !1, a.scrollToFocusedOptionOnUpdate = !1, a.userIsDragging = void 0, a.controlRef = null, a.getControlRef = function(d) {
      a.controlRef = d;
    }, a.focusedOptionRef = null, a.getFocusedOptionRef = function(d) {
      a.focusedOptionRef = d;
    }, a.menuListRef = null, a.getMenuListRef = function(d) {
      a.menuListRef = d;
    }, a.inputRef = null, a.getInputRef = function(d) {
      a.inputRef = d;
    }, a.focus = a.focusInput, a.blur = a.blurInput, a.onChange = function(d, f) {
      var m = a.props, h = m.onChange, v = m.name;
      f.name = v, a.ariaOnChange(d, f), h(d, f);
    }, a.setValue = function(d, f, m) {
      var h = a.props, v = h.closeMenuOnSelect, g = h.isMulti, b = h.inputValue;
      a.onInputChange("", {
        action: "set-value",
        prevInputValue: b
      }), v && (a.setState({
        inputIsHiddenAfterUpdate: !g
      }), a.onMenuClose()), a.setState({
        clearFocusValueOnUpdate: !0
      }), a.onChange(d, {
        action: f,
        option: m
      });
    }, a.selectOption = function(d) {
      var f = a.props, m = f.blurInputOnSelect, h = f.isMulti, v = f.name, g = a.state.selectValue, b = h && a.isOptionSelected(d, g), x = a.isOptionDisabled(d, g);
      if (b) {
        var w = a.getOptionValue(d);
        a.setValue(g.filter(function(k) {
          return a.getOptionValue(k) !== w;
        }), "deselect-option", d);
      } else if (!x)
        h ? a.setValue([].concat(U4(g), [d]), "select-option", d) : a.setValue(d, "select-option");
      else {
        a.ariaOnChange(d, {
          action: "select-option",
          option: d,
          name: v
        });
        return;
      }
      m && a.blurInput();
    }, a.removeValue = function(d) {
      var f = a.props.isMulti, m = a.state.selectValue, h = a.getOptionValue(d), v = m.filter(function(b) {
        return a.getOptionValue(b) !== h;
      }), g = t0(f, v, v[0] || null);
      a.onChange(g, {
        action: "remove-value",
        removedValue: d
      }), a.focusInput();
    }, a.clearValue = function() {
      var d = a.state.selectValue;
      a.onChange(t0(a.props.isMulti, [], null), {
        action: "clear",
        removedValues: d
      });
    }, a.popValue = function() {
      var d = a.props.isMulti, f = a.state.selectValue, m = f[f.length - 1], h = f.slice(0, f.length - 1), v = t0(d, h, h[0] || null);
      m && a.onChange(v, {
        action: "pop-value",
        removedValue: m
      });
    }, a.getFocusedOptionId = function(d) {
      return GN(a.state.focusableOptionsWithIds, d);
    }, a.getFocusableOptionsWithIds = function() {
      return f$(D_(a.props, a.state.selectValue), a.getElementId("option"));
    }, a.getValue = function() {
      return a.state.selectValue;
    }, a.cx = function() {
      for (var d = arguments.length, f = new Array(d), m = 0; m < d; m++)
        f[m] = arguments[m];
      return Mfe.apply(void 0, [a.props.classNamePrefix].concat(f));
    }, a.getOptionLabel = function(d) {
      return TV(a.props, d);
    }, a.getOptionValue = function(d) {
      return S2(a.props, d);
    }, a.getStyles = function(d, f) {
      var m = a.props.unstyled, h = Ame[d](f, m);
      h.boxSizing = "border-box";
      var v = a.props.styles[d];
      return v ? v(h, f) : h;
    }, a.getClassNames = function(d, f) {
      var m, h;
      return (m = (h = a.props.classNames)[d]) === null || m === void 0 ? void 0 : m.call(h, f);
    }, a.getElementId = function(d) {
      return "".concat(a.state.instancePrefix, "-").concat(d);
    }, a.getComponents = function() {
      return Qpe(a.props);
    }, a.buildCategorizedOptions = function() {
      return D_(a.props, a.state.selectValue);
    }, a.getCategorizedOptions = function() {
      return a.props.menuIsOpen ? a.buildCategorizedOptions() : [];
    }, a.buildFocusableOptions = function() {
      return zV(a.buildCategorizedOptions());
    }, a.getFocusableOptions = function() {
      return a.props.menuIsOpen ? a.buildFocusableOptions() : [];
    }, a.ariaOnChange = function(d, f) {
      a.setState({
        ariaSelection: ht({
          value: d
        }, f)
      });
    }, a.onMenuMouseDown = function(d) {
      d.button === 0 && (d.stopPropagation(), d.preventDefault(), a.focusInput());
    }, a.onMenuMouseMove = function(d) {
      a.blockOptionHover = !1;
    }, a.onControlMouseDown = function(d) {
      if (!d.defaultPrevented) {
        var f = a.props.openMenuOnClick;
        a.state.isFocused ? a.props.menuIsOpen ? d.target.tagName !== "INPUT" && d.target.tagName !== "TEXTAREA" && a.onMenuClose() : f && a.openMenu("first") : (f && (a.openAfterFocus = !0), a.focusInput()), d.target.tagName !== "INPUT" && d.target.tagName !== "TEXTAREA" && d.preventDefault();
      }
    }, a.onDropdownIndicatorMouseDown = function(d) {
      if (!(d && d.type === "mousedown" && d.button !== 0) && !a.props.isDisabled) {
        var f = a.props, m = f.isMulti, h = f.menuIsOpen;
        a.focusInput(), h ? (a.setState({
          inputIsHiddenAfterUpdate: !m
        }), a.onMenuClose()) : a.openMenu("first"), d.preventDefault();
      }
    }, a.onClearIndicatorMouseDown = function(d) {
      d && d.type === "mousedown" && d.button !== 0 || (a.clearValue(), d.preventDefault(), a.openAfterFocus = !1, d.type === "touchend" ? a.focusInput() : setTimeout(function() {
        return a.focusInput();
      }));
    }, a.onScroll = function(d) {
      typeof a.props.closeMenuOnScroll == "boolean" ? d.target instanceof HTMLElement && WE(d.target) && a.props.onMenuClose() : typeof a.props.closeMenuOnScroll == "function" && a.props.closeMenuOnScroll(d) && a.props.onMenuClose();
    }, a.onCompositionStart = function() {
      a.isComposing = !0;
    }, a.onCompositionEnd = function() {
      a.isComposing = !1;
    }, a.onTouchStart = function(d) {
      var f = d.touches, m = f && f.item(0);
      m && (a.initialTouchX = m.clientX, a.initialTouchY = m.clientY, a.userIsDragging = !1);
    }, a.onTouchMove = function(d) {
      var f = d.touches, m = f && f.item(0);
      if (m) {
        var h = Math.abs(m.clientX - a.initialTouchX), v = Math.abs(m.clientY - a.initialTouchY), g = 5;
        a.userIsDragging = h > g || v > g;
      }
    }, a.onTouchEnd = function(d) {
      a.userIsDragging || (a.controlRef && !a.controlRef.contains(d.target) && a.menuListRef && !a.menuListRef.contains(d.target) && a.blurInput(), a.initialTouchX = 0, a.initialTouchY = 0);
    }, a.onControlTouchEnd = function(d) {
      a.userIsDragging || a.onControlMouseDown(d);
    }, a.onClearIndicatorTouchEnd = function(d) {
      a.userIsDragging || a.onClearIndicatorMouseDown(d);
    }, a.onDropdownIndicatorTouchEnd = function(d) {
      a.userIsDragging || a.onDropdownIndicatorMouseDown(d);
    }, a.handleInputChange = function(d) {
      var f = a.props.inputValue, m = d.currentTarget.value;
      a.setState({
        inputIsHiddenAfterUpdate: !1
      }), a.onInputChange(m, {
        action: "input-change",
        prevInputValue: f
      }), a.props.menuIsOpen || a.onMenuOpen();
    }, a.onInputFocus = function(d) {
      a.props.onFocus && a.props.onFocus(d), a.setState({
        inputIsHiddenAfterUpdate: !1,
        isFocused: !0
      }), (a.openAfterFocus || a.props.openMenuOnFocus) && a.openMenu("first"), a.openAfterFocus = !1;
    }, a.onInputBlur = function(d) {
      var f = a.props.inputValue;
      if (a.menuListRef && a.menuListRef.contains(document.activeElement)) {
        a.inputRef.focus();
        return;
      }
      a.props.onBlur && a.props.onBlur(d), a.onInputChange("", {
        action: "input-blur",
        prevInputValue: f
      }), a.onMenuClose(), a.setState({
        focusedValue: null,
        isFocused: !1
      });
    }, a.onOptionHover = function(d) {
      if (!(a.blockOptionHover || a.state.focusedOption === d)) {
        var f = a.getFocusableOptions(), m = f.indexOf(d);
        a.setState({
          focusedOption: d,
          focusedOptionId: m > -1 ? a.getFocusedOptionId(d) : null
        });
      }
    }, a.shouldHideSelectedOptions = function() {
      return UV(a.props);
    }, a.onValueInputFocus = function(d) {
      d.preventDefault(), d.stopPropagation(), a.focus();
    }, a.onKeyDown = function(d) {
      var f = a.props, m = f.isMulti, h = f.backspaceRemovesValue, v = f.escapeClearsValue, g = f.inputValue, b = f.isClearable, x = f.isDisabled, w = f.menuIsOpen, k = f.onKeyDown, E = f.tabSelectsValue, _ = f.openMenuOnFocus, O = a.state, N = O.focusedOption, A = O.focusedValue, R = O.selectValue;
      if (!x && !(typeof k == "function" && (k(d), d.defaultPrevented))) {
        switch (a.blockOptionHover = !0, d.key) {
          case "ArrowLeft":
            if (!m || g) return;
            a.focusValue("previous");
            break;
          case "ArrowRight":
            if (!m || g) return;
            a.focusValue("next");
            break;
          case "Delete":
          case "Backspace":
            if (g) return;
            if (A)
              a.removeValue(A);
            else {
              if (!h) return;
              m ? a.popValue() : b && a.clearValue();
            }
            break;
          case "Tab":
            if (a.isComposing || d.shiftKey || !w || !E || !N || // don't capture the event if the menu opens on focus and the focused
            // option is already selected; it breaks the flow of navigation
            _ && a.isOptionSelected(N, R))
              return;
            a.selectOption(N);
            break;
          case "Enter":
            if (d.keyCode === 229)
              break;
            if (w) {
              if (!N || a.isComposing) return;
              a.selectOption(N);
              break;
            }
            return;
          case "Escape":
            w ? (a.setState({
              inputIsHiddenAfterUpdate: !1
            }), a.onInputChange("", {
              action: "menu-close",
              prevInputValue: g
            }), a.onMenuClose()) : b && v && a.clearValue();
            break;
          case " ":
            if (g)
              return;
            if (!w) {
              a.openMenu("first");
              break;
            }
            if (!N) return;
            a.selectOption(N);
            break;
          case "ArrowUp":
            w ? a.focusOption("up") : a.openMenu("last");
            break;
          case "ArrowDown":
            w ? a.focusOption("down") : a.openMenu("first");
            break;
          case "PageUp":
            if (!w) return;
            a.focusOption("pageup");
            break;
          case "PageDown":
            if (!w) return;
            a.focusOption("pagedown");
            break;
          case "Home":
            if (!w) return;
            a.focusOption("first");
            break;
          case "End":
            if (!w) return;
            a.focusOption("last");
            break;
          default:
            return;
        }
        d.preventDefault();
      }
    }, a.state.instancePrefix = "react-select-" + (a.props.instanceId || ++Fme), a.state.selectValue = JI(r.value), r.menuIsOpen && a.state.selectValue.length) {
      var s = a.getFocusableOptionsWithIds(), l = a.buildFocusableOptions(), c = l.indexOf(a.state.selectValue[0]);
      a.state.focusableOptionsWithIds = s, a.state.focusedOption = l[c], a.state.focusedOptionId = GN(s, l[c]);
    }
    return a;
  }
  return yfe(n, [{
    key: "componentDidMount",
    value: function() {
      this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, !0), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && QI(this.menuListRef, this.focusedOptionRef), Eme() && this.setState({
        isAppleDevice: !0
      });
    }
  }, {
    key: "componentDidUpdate",
    value: function(r) {
      var a = this.props, s = a.isDisabled, l = a.menuIsOpen, c = this.state.isFocused;
      (c && !s && r.isDisabled || // ensure focus is on the Input when the menu opens
      c && l && !r.menuIsOpen) && this.focusInput(), c && s && !r.isDisabled ? this.setState({
        isFocused: !1
      }, this.onMenuClose) : !c && !s && r.isDisabled && this.inputRef === document.activeElement && this.setState({
        isFocused: !0
      }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (QI(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = !1);
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, !0);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      }), this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function(r, a) {
      this.props.onInputChange(r, a);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function() {
      this.inputRef && this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function() {
      this.inputRef && this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function(r) {
      var a = this, s = this.state, l = s.selectValue, c = s.isFocused, d = this.buildFocusableOptions(), f = r === "first" ? 0 : d.length - 1;
      if (!this.props.isMulti) {
        var m = d.indexOf(l[0]);
        m > -1 && (f = m);
      }
      this.scrollToFocusedOptionOnUpdate = !(c && this.menuListRef), this.setState({
        inputIsHiddenAfterUpdate: !1,
        focusedValue: null,
        focusedOption: d[f],
        focusedOptionId: this.getFocusedOptionId(d[f])
      }, function() {
        return a.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function(r) {
      var a = this.state, s = a.selectValue, l = a.focusedValue;
      if (this.props.isMulti) {
        this.setState({
          focusedOption: null
        });
        var c = s.indexOf(l);
        l || (c = -1);
        var d = s.length - 1, f = -1;
        if (s.length) {
          switch (r) {
            case "previous":
              c === 0 ? f = 0 : c === -1 ? f = d : f = c - 1;
              break;
            case "next":
              c > -1 && c < d && (f = c + 1);
              break;
          }
          this.setState({
            inputIsHidden: f !== -1,
            focusedValue: s[f]
          });
        }
      }
    }
  }, {
    key: "focusOption",
    value: function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first", a = this.props.pageSize, s = this.state.focusedOption, l = this.getFocusableOptions();
      if (l.length) {
        var c = 0, d = l.indexOf(s);
        s || (d = -1), r === "up" ? c = d > 0 ? d - 1 : l.length - 1 : r === "down" ? c = (d + 1) % l.length : r === "pageup" ? (c = d - a, c < 0 && (c = 0)) : r === "pagedown" ? (c = d + a, c > l.length - 1 && (c = l.length - 1)) : r === "last" && (c = l.length - 1), this.scrollToFocusedOptionOnUpdate = !0, this.setState({
          focusedOption: l[c],
          focusedValue: null,
          focusedOptionId: this.getFocusedOptionId(l[c])
        });
      }
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      (function() {
        return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(qN) : ht(ht({}, qN), this.props.theme) : qN;
      })
    )
  }, {
    key: "getCommonProps",
    value: function() {
      var r = this.clearValue, a = this.cx, s = this.getStyles, l = this.getClassNames, c = this.getValue, d = this.selectOption, f = this.setValue, m = this.props, h = m.isMulti, v = m.isRtl, g = m.options, b = this.hasValue();
      return {
        clearValue: r,
        cx: a,
        getStyles: s,
        getClassNames: l,
        getValue: c,
        hasValue: b,
        isMulti: h,
        isRtl: v,
        options: g,
        selectOption: d,
        selectProps: m,
        setValue: f,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function() {
      var r = this.state.selectValue;
      return r.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function() {
      var r = this.props, a = r.isClearable, s = r.isMulti;
      return a === void 0 ? s : a;
    }
  }, {
    key: "isOptionDisabled",
    value: function(r, a) {
      return LV(this.props, r, a);
    }
  }, {
    key: "isOptionSelected",
    value: function(r, a) {
      return FV(this.props, r, a);
    }
  }, {
    key: "filterOption",
    value: function(r, a) {
      return BV(this.props, r, a);
    }
  }, {
    key: "formatOptionLabel",
    value: function(r, a) {
      if (typeof this.props.formatOptionLabel == "function") {
        var s = this.props.inputValue, l = this.state.selectValue;
        return this.props.formatOptionLabel(r, {
          context: a,
          inputValue: s,
          selectValue: l
        });
      } else
        return this.getOptionLabel(r);
    }
  }, {
    key: "formatGroupLabel",
    value: function(r) {
      return this.props.formatGroupLabel(r);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      (function() {
        document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, !1), document.addEventListener("compositionend", this.onCompositionEnd, !1));
      })
    )
  }, {
    key: "stopListeningComposition",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd));
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      (function() {
        document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, !1), document.addEventListener("touchmove", this.onTouchMove, !1), document.addEventListener("touchend", this.onTouchEnd, !1));
      })
    )
  }, {
    key: "stopListeningToTouch",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd));
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      (function() {
        var r = this.props, a = r.isDisabled, s = r.isSearchable, l = r.inputId, c = r.inputValue, d = r.tabIndex, f = r.form, m = r.menuIsOpen, h = r.required, v = this.getComponents(), g = v.Input, b = this.state, x = b.inputIsHidden, w = b.ariaSelection, k = this.commonProps, E = l || this.getElementId("input"), _ = ht(ht(ht({
          "aria-autocomplete": "list",
          "aria-expanded": m,
          "aria-haspopup": !0,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": h,
          role: "combobox",
          "aria-activedescendant": this.state.isAppleDevice ? void 0 : this.state.focusedOptionId || ""
        }, m && {
          "aria-controls": this.getElementId("listbox")
        }), !s && {
          "aria-readonly": !0
        }), this.hasValue() ? w?.action === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        return s ? /* @__PURE__ */ M.createElement(g, mt({}, k, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id: E,
          innerRef: this.getInputRef,
          isDisabled: a,
          isHidden: x,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex: d,
          form: f,
          type: "text",
          value: c
        }, _)) : /* @__PURE__ */ M.createElement(fme, mt({
          id: E,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: w2,
          onFocus: this.onInputFocus,
          disabled: a,
          tabIndex: d,
          inputMode: "none",
          form: f,
          value: ""
        }, _));
      })
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function() {
      var r = this, a = this.getComponents(), s = a.MultiValue, l = a.MultiValueContainer, c = a.MultiValueLabel, d = a.MultiValueRemove, f = a.SingleValue, m = a.Placeholder, h = this.commonProps, v = this.props, g = v.controlShouldRenderValue, b = v.isDisabled, x = v.isMulti, w = v.inputValue, k = v.placeholder, E = this.state, _ = E.selectValue, O = E.focusedValue, N = E.isFocused;
      if (!this.hasValue() || !g)
        return w ? null : /* @__PURE__ */ M.createElement(m, mt({}, h, {
          key: "placeholder",
          isDisabled: b,
          isFocused: N,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), k);
      if (x)
        return _.map(function(R, D) {
          var I = R === O, z = "".concat(r.getOptionLabel(R), "-").concat(r.getOptionValue(R));
          return /* @__PURE__ */ M.createElement(s, mt({}, h, {
            components: {
              Container: l,
              Label: c,
              Remove: d
            },
            isFocused: I,
            isDisabled: b,
            key: z,
            index: D,
            removeProps: {
              onClick: function() {
                return r.removeValue(R);
              },
              onTouchEnd: function() {
                return r.removeValue(R);
              },
              onMouseDown: function(B) {
                B.preventDefault();
              }
            },
            data: R
          }), r.formatOptionLabel(R, "value"));
        });
      if (w)
        return null;
      var A = _[0];
      return /* @__PURE__ */ M.createElement(f, mt({}, h, {
        data: A,
        isDisabled: b
      }), this.formatOptionLabel(A, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function() {
      var r = this.getComponents(), a = r.ClearIndicator, s = this.commonProps, l = this.props, c = l.isDisabled, d = l.isLoading, f = this.state.isFocused;
      if (!this.isClearable() || !a || c || !this.hasValue() || d)
        return null;
      var m = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ M.createElement(a, mt({}, s, {
        innerProps: m,
        isFocused: f
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function() {
      var r = this.getComponents(), a = r.LoadingIndicator, s = this.commonProps, l = this.props, c = l.isDisabled, d = l.isLoading, f = this.state.isFocused;
      if (!a || !d) return null;
      var m = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ M.createElement(a, mt({}, s, {
        innerProps: m,
        isDisabled: c,
        isFocused: f
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function() {
      var r = this.getComponents(), a = r.DropdownIndicator, s = r.IndicatorSeparator;
      if (!a || !s) return null;
      var l = this.commonProps, c = this.props.isDisabled, d = this.state.isFocused;
      return /* @__PURE__ */ M.createElement(s, mt({}, l, {
        isDisabled: c,
        isFocused: d
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function() {
      var r = this.getComponents(), a = r.DropdownIndicator;
      if (!a) return null;
      var s = this.commonProps, l = this.props.isDisabled, c = this.state.isFocused, d = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ M.createElement(a, mt({}, s, {
        innerProps: d,
        isDisabled: l,
        isFocused: c
      }));
    }
  }, {
    key: "renderMenu",
    value: function() {
      var r = this, a = this.getComponents(), s = a.Group, l = a.GroupHeading, c = a.Menu, d = a.MenuList, f = a.MenuPortal, m = a.LoadingMessage, h = a.NoOptionsMessage, v = a.Option, g = this.commonProps, b = this.state.focusedOption, x = this.props, w = x.captureMenuScroll, k = x.inputValue, E = x.isLoading, _ = x.loadingMessage, O = x.minMenuHeight, N = x.maxMenuHeight, A = x.menuIsOpen, R = x.menuPlacement, D = x.menuPosition, I = x.menuPortalTarget, z = x.menuShouldBlockScroll, B = x.menuShouldScrollIntoView, P = x.noOptionsMessage, H = x.onMenuScrollToTop, L = x.onMenuScrollToBottom;
      if (!A) return null;
      var G = function(F, Y) {
        var U = F.type, W = F.data, J = F.isDisabled, oe = F.isSelected, fe = F.label, ie = F.value, ce = b === W, ge = J ? void 0 : function() {
          return r.onOptionHover(W);
        }, re = J ? void 0 : function() {
          return r.selectOption(W);
        }, le = "".concat(r.getElementId("option"), "-").concat(Y), me = {
          id: le,
          onClick: re,
          onMouseMove: ge,
          onMouseOver: ge,
          tabIndex: -1,
          role: "option",
          "aria-selected": r.state.isAppleDevice ? void 0 : oe
          // is not supported on Apple devices
        };
        return /* @__PURE__ */ M.createElement(v, mt({}, g, {
          innerProps: me,
          data: W,
          isDisabled: J,
          isSelected: oe,
          key: le,
          label: fe,
          type: U,
          value: ie,
          isFocused: ce,
          innerRef: ce ? r.getFocusedOptionRef : void 0
        }), r.formatOptionLabel(F.data, "menu"));
      }, $;
      if (this.hasOptions())
        $ = this.getCategorizedOptions().map(function(F) {
          if (F.type === "group") {
            var Y = F.data, U = F.options, W = F.index, J = "".concat(r.getElementId("group"), "-").concat(W), oe = "".concat(J, "-heading");
            return /* @__PURE__ */ M.createElement(s, mt({}, g, {
              key: J,
              data: Y,
              options: U,
              Heading: l,
              headingProps: {
                id: oe,
                data: F.data
              },
              label: r.formatGroupLabel(F.data)
            }), F.options.map(function(fe) {
              return G(fe, "".concat(W, "-").concat(fe.index));
            }));
          } else if (F.type === "option")
            return G(F, "".concat(F.index));
        });
      else if (E) {
        var K = _({
          inputValue: k
        });
        if (K === null) return null;
        $ = /* @__PURE__ */ M.createElement(m, g, K);
      } else {
        var q = P({
          inputValue: k
        });
        if (q === null) return null;
        $ = /* @__PURE__ */ M.createElement(h, g, q);
      }
      var Z = {
        minMenuHeight: O,
        maxMenuHeight: N,
        menuPlacement: R,
        menuPosition: D,
        menuShouldScrollIntoView: B
      }, V = /* @__PURE__ */ M.createElement(Hfe, mt({}, g, Z), function(F) {
        var Y = F.ref, U = F.placerProps, W = U.placement, J = U.maxHeight;
        return /* @__PURE__ */ M.createElement(c, mt({}, g, Z, {
          innerRef: Y,
          innerProps: {
            onMouseDown: r.onMenuMouseDown,
            onMouseMove: r.onMenuMouseMove
          },
          isLoading: E,
          placement: W
        }), /* @__PURE__ */ M.createElement(yme, {
          captureEnabled: w,
          onTopArrive: H,
          onBottomArrive: L,
          lockEnabled: z
        }, function(oe) {
          return /* @__PURE__ */ M.createElement(d, mt({}, g, {
            innerRef: function(fe) {
              r.getMenuListRef(fe), oe(fe);
            },
            innerProps: {
              role: "listbox",
              "aria-multiselectable": g.isMulti,
              id: r.getElementId("listbox")
            },
            isLoading: E,
            maxHeight: J,
            focusedOption: b
          }), $);
        }));
      });
      return I || D === "fixed" ? /* @__PURE__ */ M.createElement(f, mt({}, g, {
        appendTo: I,
        controlElement: this.controlRef,
        menuPlacement: R,
        menuPosition: D
      }), V) : V;
    }
  }, {
    key: "renderFormField",
    value: function() {
      var r = this, a = this.props, s = a.delimiter, l = a.isDisabled, c = a.isMulti, d = a.name, f = a.required, m = this.state.selectValue;
      if (f && !this.hasValue() && !l)
        return /* @__PURE__ */ M.createElement(xme, {
          name: d,
          onFocus: this.onValueInputFocus
        });
      if (!(!d || l))
        if (c)
          if (s) {
            var h = m.map(function(b) {
              return r.getOptionValue(b);
            }).join(s);
            return /* @__PURE__ */ M.createElement("input", {
              name: d,
              type: "hidden",
              value: h
            });
          } else {
            var v = m.length > 0 ? m.map(function(b, x) {
              return /* @__PURE__ */ M.createElement("input", {
                key: "i-".concat(x),
                name: d,
                type: "hidden",
                value: r.getOptionValue(b)
              });
            }) : /* @__PURE__ */ M.createElement("input", {
              name: d,
              type: "hidden",
              value: ""
            });
            return /* @__PURE__ */ M.createElement("div", null, v);
          }
        else {
          var g = m[0] ? this.getOptionValue(m[0]) : "";
          return /* @__PURE__ */ M.createElement("input", {
            name: d,
            type: "hidden",
            value: g
          });
        }
    }
  }, {
    key: "renderLiveRegion",
    value: function() {
      var r = this.commonProps, a = this.state, s = a.ariaSelection, l = a.focusedOption, c = a.focusedValue, d = a.isFocused, f = a.selectValue, m = this.getFocusableOptions();
      return /* @__PURE__ */ M.createElement(ime, mt({}, r, {
        id: this.getElementId("live-region"),
        ariaSelection: s,
        focusedOption: l,
        focusedValue: c,
        isFocused: d,
        selectValue: f,
        focusableOptions: m,
        isAppleDevice: this.state.isAppleDevice
      }));
    }
  }, {
    key: "render",
    value: function() {
      var r = this.getComponents(), a = r.Control, s = r.IndicatorsContainer, l = r.SelectContainer, c = r.ValueContainer, d = this.props, f = d.className, m = d.id, h = d.isDisabled, v = d.menuIsOpen, g = this.state.isFocused, b = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ M.createElement(l, mt({}, b, {
        className: f,
        innerProps: {
          id: m,
          onKeyDown: this.onKeyDown
        },
        isDisabled: h,
        isFocused: g
      }), this.renderLiveRegion(), /* @__PURE__ */ M.createElement(a, mt({}, b, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled: h,
        isFocused: g,
        menuIsOpen: v
      }), /* @__PURE__ */ M.createElement(c, mt({}, b, {
        isDisabled: h
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ M.createElement(s, mt({}, b, {
        isDisabled: h
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(r, a) {
      var s = a.prevProps, l = a.clearFocusValueOnUpdate, c = a.inputIsHiddenAfterUpdate, d = a.ariaSelection, f = a.isFocused, m = a.prevWasFocused, h = a.instancePrefix, v = r.options, g = r.value, b = r.menuIsOpen, x = r.inputValue, w = r.isMulti, k = JI(g), E = {};
      if (s && (g !== s.value || v !== s.options || b !== s.menuIsOpen || x !== s.inputValue)) {
        var _ = b ? zme(r, k) : [], O = b ? f$(D_(r, k), "".concat(h, "-option")) : [], N = l ? Tme(a, k) : null, A = Lme(a, _), R = GN(O, A);
        E = {
          selectValue: k,
          focusedOption: A,
          focusedOptionId: R,
          focusableOptionsWithIds: O,
          focusedValue: N,
          clearFocusValueOnUpdate: !1
        };
      }
      var D = c != null && r !== s ? {
        inputIsHidden: c,
        inputIsHiddenAfterUpdate: void 0
      } : {}, I = d, z = f && m;
      return f && !z && (I = {
        value: t0(w, k, k[0] || null),
        options: k,
        action: "initial-input-focus"
      }, z = !m), d?.action === "initial-input-focus" && (I = null), ht(ht(ht({}, E), D), {}, {
        prevProps: r,
        ariaSelection: I,
        prevWasFocused: z
      });
    }
  }]), n;
})(M.Component);
VV.defaultProps = $me;
var Bme = /* @__PURE__ */ M.forwardRef(function(e, t) {
  var n = gfe(e);
  return /* @__PURE__ */ M.createElement(VV, mt({
    ref: t
  }, n));
}), Ume = Bme;
const Vme = ({
  options: e,
  items_per_page: t,
  className: n,
  defaultValue: r,
  onChange: a
}) => {
  const [s, l] = M.useState(""), [c, d] = M.useState(0), f = (g) => {
    l(g.toLowerCase()), d(0);
  }, m = e.filter((g) => g.label.toLowerCase().includes(s) || g.value.toLowerCase().includes(s));
  var h;
  t !== void 0 ? h = m.slice(
    c * t,
    (c + 1) * t
  ) : h = m;
  const v = {
    control: (g) => ({
      ...g,
      minHeight: void 0
    })
  };
  return /* @__PURE__ */ C.jsx(
    Ume,
    {
      options: h,
      onInputChange: f,
      onChange: a,
      inputValue: s,
      isSearchable: !0,
      placeholder: "Select an option...",
      className: n,
      unstyled: !0,
      styles: v,
      classNamePrefix: "styled-select",
      defaultValue: r,
      value: r
    }
  );
}, Hme = (e) => typeof e == "boolean" || e instanceof Boolean, Wme = (e) => typeof e == "number" || e instanceof Number, qme = (e) => typeof e == "bigint" || e instanceof BigInt, HV = (e) => !!e && e instanceof Date, Gme = (e) => typeof e == "string" || e instanceof String, Kme = (e) => Array.isArray(e), WV = (e) => typeof e == "object" && e !== null, qV = (e) => !!e && e instanceof Object && typeof e == "function";
function k2(e, t) {
  return t === void 0 && (t = !1), !e || t ? `"${e}"` : e;
}
function Yme(e, t, n) {
  return n ? JSON.stringify(e) : t ? `"${e}"` : e;
}
function GV(e) {
  let {
    field: t,
    value: n,
    data: r,
    lastElement: a,
    openBracket: s,
    closeBracket: l,
    level: c,
    style: d,
    shouldExpandNode: f,
    clickToExpandNode: m,
    outerRef: h,
    beforeExpandChange: v
  } = e;
  const g = M.useRef(!1), [b, x] = M.useState(() => f(c, n, t)), w = M.useRef(null);
  M.useEffect(() => {
    g.current ? x(f(c, n, t)) : g.current = !0;
  }, [f]);
  const k = M.useId();
  if (r.length === 0)
    return Xme({
      field: t,
      openBracket: s,
      closeBracket: l,
      lastElement: a,
      style: d
    });
  const E = b ? d.collapseIcon : d.expandIcon, _ = b ? d.ariaLables.collapseJson : d.ariaLables.expandJson, O = c + 1, N = r.length - 1, A = (I) => {
    b !== I && (!v || v({
      level: c,
      value: n,
      field: t,
      newExpandValue: I
    })) && x(I);
  }, R = (I) => {
    if (I.key === "ArrowRight" || I.key === "ArrowLeft")
      I.preventDefault(), A(I.key === "ArrowRight");
    else if (I.key === "ArrowUp" || I.key === "ArrowDown") {
      I.preventDefault();
      const z = I.key === "ArrowUp" ? -1 : 1;
      if (!h.current) return;
      const B = h.current.querySelectorAll("[role=button]");
      let P = -1;
      for (let L = 0; L < B.length; L++)
        if (B[L].tabIndex === 0) {
          P = L;
          break;
        }
      if (P < 0)
        return;
      const H = (P + z + B.length) % B.length;
      B[P].tabIndex = -1, B[H].tabIndex = 0, B[H].focus();
    }
  }, D = () => {
    var I;
    A(!b);
    const z = w.current;
    if (!z) return;
    const B = (I = h.current) === null || I === void 0 ? void 0 : I.querySelector('[role=button][tabindex="0"]');
    B && (B.tabIndex = -1), z.tabIndex = 0, z.focus();
  };
  return /* @__PURE__ */ M.createElement("div", {
    className: d.basicChildStyle,
    role: "treeitem",
    "aria-expanded": b,
    "aria-selected": void 0
  }, /* @__PURE__ */ M.createElement("span", {
    className: E,
    onClick: D,
    onKeyDown: R,
    role: "button",
    "aria-label": _,
    "aria-expanded": b,
    "aria-controls": b ? k : void 0,
    ref: w,
    tabIndex: c === 0 ? 0 : -1
  }), (t || t === "") && (m ? /* @__PURE__ */ M.createElement("span", {
    className: d.clickableLabel,
    onClick: D,
    onKeyDown: R
  }, k2(t, d.quotesForFieldNames), ":") : /* @__PURE__ */ M.createElement("span", {
    className: d.label
  }, k2(t, d.quotesForFieldNames), ":")), /* @__PURE__ */ M.createElement("span", {
    className: d.punctuation
  }, s), b ? /* @__PURE__ */ M.createElement("ul", {
    id: k,
    role: "group",
    className: d.childFieldsContainer
  }, r.map((I, z) => /* @__PURE__ */ M.createElement(d3, {
    key: I[0] || z,
    field: I[0],
    value: I[1],
    style: d,
    lastElement: z === N,
    level: O,
    shouldExpandNode: f,
    clickToExpandNode: m,
    beforeExpandChange: v,
    outerRef: h
  }))) : /* @__PURE__ */ M.createElement("span", {
    className: d.collapsedContent,
    onClick: D,
    onKeyDown: R
  }), /* @__PURE__ */ M.createElement("span", {
    className: d.punctuation
  }, l), !a && /* @__PURE__ */ M.createElement("span", {
    className: d.punctuation
  }, ","));
}
function Xme(e) {
  let {
    field: t,
    openBracket: n,
    closeBracket: r,
    lastElement: a,
    style: s
  } = e;
  return /* @__PURE__ */ M.createElement("div", {
    className: s.basicChildStyle,
    role: "treeitem",
    "aria-selected": void 0
  }, (t || t === "") && /* @__PURE__ */ M.createElement("span", {
    className: s.label
  }, k2(t, s.quotesForFieldNames), ":"), /* @__PURE__ */ M.createElement("span", {
    className: s.punctuation
  }, n), /* @__PURE__ */ M.createElement("span", {
    className: s.punctuation
  }, r), !a && /* @__PURE__ */ M.createElement("span", {
    className: s.punctuation
  }, ","));
}
function Jme(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: a,
    shouldExpandNode: s,
    clickToExpandNode: l,
    level: c,
    outerRef: d,
    beforeExpandChange: f
  } = e;
  return GV({
    field: t,
    value: n,
    lastElement: a || !1,
    level: c,
    openBracket: "{",
    closeBracket: "}",
    style: r,
    shouldExpandNode: s,
    clickToExpandNode: l,
    data: Object.keys(n).map((m) => [m, n[m]]),
    outerRef: d,
    beforeExpandChange: f
  });
}
function Qme(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: a,
    level: s,
    shouldExpandNode: l,
    clickToExpandNode: c,
    outerRef: d,
    beforeExpandChange: f
  } = e;
  return GV({
    field: t,
    value: n,
    lastElement: a || !1,
    level: s,
    openBracket: "[",
    closeBracket: "]",
    style: r,
    shouldExpandNode: l,
    clickToExpandNode: c,
    data: n.map((m) => [void 0, m]),
    outerRef: d,
    beforeExpandChange: f
  });
}
function Zme(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: a
  } = e, s, l = r.otherValue;
  return n === null ? (s = "null", l = r.nullValue) : n === void 0 ? (s = "undefined", l = r.undefinedValue) : Gme(n) ? (s = Yme(n, !r.noQuotesForStringValues, r.stringifyStringValues), l = r.stringValue) : Hme(n) ? (s = n ? "true" : "false", l = r.booleanValue) : Wme(n) ? (s = n.toString(), l = r.numberValue) : qme(n) ? (s = `${n.toString()}n`, l = r.numberValue) : HV(n) ? s = n.toISOString() : qV(n) ? s = "function() { }" : s = n.toString(), /* @__PURE__ */ M.createElement("div", {
    className: r.basicChildStyle,
    role: "treeitem",
    "aria-selected": void 0
  }, (t || t === "") && /* @__PURE__ */ M.createElement("span", {
    className: r.label
  }, k2(t, r.quotesForFieldNames), ":"), /* @__PURE__ */ M.createElement("span", {
    className: l
  }, s), !a && /* @__PURE__ */ M.createElement("span", {
    className: r.punctuation
  }, ","));
}
function d3(e) {
  const t = e.value;
  return Kme(t) ? /* @__PURE__ */ M.createElement(Qme, Object.assign({}, e)) : WV(t) && !HV(t) && !qV(t) ? /* @__PURE__ */ M.createElement(Jme, Object.assign({}, e)) : /* @__PURE__ */ M.createElement(Zme, Object.assign({}, e));
}
var Cn = { "container-light": "_2IvMF _GzYRV", "basic-element-style": "_2bkNM", "child-fields-container": "_1BXBN", "label-light": "_1MGIk", "clickable-label-light": "_2YKJg _1MGIk _1MFti", "punctuation-light": "_3uHL6 _3eOF8", "value-null-light": "_2T6PJ", "value-undefined-light": "_1Gho6", "value-string-light": "_vGjyY", "value-number-light": "_1bQdo", "value-boolean-light": "_3zQKs", "value-other-light": "_1xvuR", "collapse-icon-light": "_oLqym _f10Tu _1MFti _1LId0", "expand-icon-light": "_2AXVT _f10Tu _1MFti _1UmXx", "collapsed-content-light": "_2KJWg _1pNG9 _1MFti", "container-dark": "_11RoI _GzYRV", "expand-icon-dark": "_17H2C _f10Tu _1MFti _1UmXx", "collapse-icon-dark": "_3QHg2 _f10Tu _1MFti _1LId0", "collapsed-content-dark": "_3fDAz _1pNG9 _1MFti", "label-dark": "_2bSDX", "clickable-label-dark": "_1RQEj _2bSDX _1MFti", "punctuation-dark": "_gsbQL _3eOF8", "value-null-dark": "_LaAZe", "value-undefined-dark": "_GTKgm", "value-string-dark": "_Chy1W", "value-number-dark": "_2bveF", "value-boolean-dark": "_2vRm-", "value-other-dark": "_1prJR" };
const KV = {
  collapseJson: "collapse JSON",
  expandJson: "expand JSON"
}, KN = {
  container: Cn["container-light"],
  basicChildStyle: Cn["basic-element-style"],
  childFieldsContainer: Cn["child-fields-container"],
  label: Cn["label-light"],
  clickableLabel: Cn["clickable-label-light"],
  nullValue: Cn["value-null-light"],
  undefinedValue: Cn["value-undefined-light"],
  stringValue: Cn["value-string-light"],
  booleanValue: Cn["value-boolean-light"],
  numberValue: Cn["value-number-light"],
  otherValue: Cn["value-other-light"],
  punctuation: Cn["punctuation-light"],
  collapseIcon: Cn["collapse-icon-light"],
  expandIcon: Cn["expand-icon-light"],
  collapsedContent: Cn["collapsed-content-light"],
  noQuotesForStringValues: !1,
  quotesForFieldNames: !1,
  ariaLables: KV,
  stringifyStringValues: !1
}, ehe = {
  container: Cn["container-dark"],
  basicChildStyle: Cn["basic-element-style"],
  childFieldsContainer: Cn["child-fields-container"],
  label: Cn["label-dark"],
  clickableLabel: Cn["clickable-label-dark"],
  nullValue: Cn["value-null-dark"],
  undefinedValue: Cn["value-undefined-dark"],
  stringValue: Cn["value-string-dark"],
  booleanValue: Cn["value-boolean-dark"],
  numberValue: Cn["value-number-dark"],
  otherValue: Cn["value-other-dark"],
  punctuation: Cn["punctuation-dark"],
  collapseIcon: Cn["collapse-icon-dark"],
  expandIcon: Cn["expand-icon-dark"],
  collapsedContent: Cn["collapsed-content-dark"],
  noQuotesForStringValues: !1,
  quotesForFieldNames: !1,
  ariaLables: KV,
  stringifyStringValues: !1
}, the = () => !0, nhe = (e) => e < 1, rhe = (e) => {
  let {
    data: t,
    style: n = KN,
    shouldExpandNode: r = the,
    clickToExpandNode: a = !1,
    beforeExpandChange: s,
    compactTopLevel: l,
    ...c
  } = e;
  const d = M.useRef(null);
  return /* @__PURE__ */ M.createElement("div", Object.assign({
    "aria-label": "JSON view"
  }, c, {
    className: n.container,
    ref: d,
    role: "tree"
  }), l && WV(t) ? Object.entries(t).map((f) => {
    let [m, h] = f;
    return /* @__PURE__ */ M.createElement(d3, {
      key: m,
      field: m,
      value: h,
      style: {
        ...KN,
        ...n
      },
      lastElement: !0,
      level: 1,
      shouldExpandNode: r,
      clickToExpandNode: a,
      beforeExpandChange: s,
      outerRef: d
    });
  }) : /* @__PURE__ */ M.createElement(d3, {
    value: t,
    style: {
      ...KN,
      ...n
    },
    lastElement: !0,
    level: 0,
    shouldExpandNode: r,
    clickToExpandNode: a,
    outerRef: d,
    beforeExpandChange: s
  }));
};
function ohe(e) {
  for (const t in e)
    if (Object.hasOwn(e, t))
      return !1;
  return !0;
}
function ahe(e) {
  if (e == null || typeof e != "object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t !== null && t !== Object.prototype ? !1 : ohe(e);
}
const ihe = ({
  data: e,
  className: t = "json-display"
}) => /* @__PURE__ */ C.jsx("div", { className: t, children: /* @__PURE__ */ C.jsx(
  rhe,
  {
    data: ahe(e) ? "" : e,
    style: ehe,
    shouldExpandNode: nhe
  }
) });
function she(e, t, n = {}) {
  const {
    maxFontSize: r = 100,
    // default maximum font size
    minFontSize: a = 6,
    // default minimum font size
    decrementFactor: s = 0.9
    // font size decrement step
  } = n;
  if (!e || !t)
    return;
  if (s >= 1 || s <= 0)
    throw new Error("decrementFactor must be between 0 and 1");
  const l = e.getBoundingClientRect(), c = l.width, d = l.height;
  let f = r;
  t.style.whiteSpace = "nowrap", t.style.display = "inline-block", t.style.fontSize = f + "px";
  let m = t.getBoundingClientRect();
  for (; (m.width > c || m.height > d) && f > a; )
    f *= s, t.style.fontSize = f + "px", m = t.getBoundingClientRect();
}
function lhe(e = {
  n: 0,
  elapsed: 0,
  ascii: !1,
  unit: "it",
  unit_scale: !1,
  unit_divisor: 1e3
}) {
  let t = e.total ?? null;
  const {
    n = 0,
    unit_scale: r = !1,
    elapsed: a = 0,
    // ascii,
    unit: s = "it",
    unit_divisor: l = 1e3,
    // ncols = undefined,
    prefix: c = "",
    rate: d = void 0,
    // bar_format = undefined,
    postfix: f = null,
    initial: m = 0
    // colour = undefined,
  } = e;
  t !== null && n >= t + 0.5 && (t = null);
  let h = n, v = t, g = d;
  r && r !== !0 && r !== 1 && (t !== null && (v = t * r), h = n * r, d !== void 0 && (g = d * r));
  const b = m$(a);
  g === void 0 && a > 0 && (g = (h - m) / a);
  const x = g ? 1 / g : void 0, [w, k] = g ? n0(g, l) : [void 0, ""], [E, _] = x ? n0(x, 1e3) : [void 0, ""], O = (w || "?") + `${k}${s}/s`, N = E ? `${E}${_}s/` + s : "?", A = x && x > 1 ? N : O, R = r ? n0(h, l).join("") : h.toString(), D = r && v !== null ? n0(v, l).join("") : v?.toString() ?? "?", I = g && v !== null ? (v - h) / g : 0, z = g ? m$(I) : "?", B = c ? `${c}: ` : "";
  if (t !== null) {
    const P = h / t * 100, H = ` ${R}/${D} [${b} < ${z}, ${A}${f ?? ""}]`;
    return `${B}${P.toFixed(0)}%${H}`;
  }
  return `${B}${R}${s} [${b}, ${A}${f ?? ""}]`;
}
function m$(e) {
  const t = Math.floor(e / 60), n = Math.floor(e % 60);
  return `${t}:${n.toString().padStart(2, "0")}`;
}
function n0(e, t) {
  const n = ["", "K", "M", "G", "T"];
  let r = 0;
  for (; e >= t && r < n.length - 1; )
    e /= t, r++;
  return [e.toFixed(2), n[r]];
}
const uhe = ({ state: e, className: t = "reacttqdm", ...n }) => {
  const r = M.useRef(null), a = M.useRef(null);
  M.useEffect(() => {
    const l = () => {
      !r.current || !a.current || she(r.current, a.current, {
        maxFontSize: 12,
        decrementFactor: 0.9
      });
    };
    return l(), window.addEventListener("resize", l), () => {
      window.removeEventListener("resize", l);
    };
  }, [e]);
  const s = e.total ? (e.n ?? 0) / e.total * 100 : 0;
  return /* @__PURE__ */ C.jsx("div", { ref: r, className: t, ...n, children: /* @__PURE__ */ C.jsxs(
    "div",
    {
      style: {
        position: "relative",
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center"
      },
      children: [
        /* @__PURE__ */ C.jsx(
          "div",
          {
            className: t + "-bar",
            style: {
              position: "absolute",
              width: "100%",
              height: "100%",
              // Adjust height if needed
              overflow: "hidden"
            },
            children: /* @__PURE__ */ C.jsx(
              "div",
              {
                className: t + "-progress",
                style: {
                  width: `${s}%`,
                  height: "100%"
                }
              }
            )
          }
        ),
        /* @__PURE__ */ C.jsx("div", { className: t + "-text", ref: a, children: lhe(e) })
      ]
    }
  ) });
};
var r0 = {}, h$;
function che() {
  if (h$) return r0;
  h$ = 1;
  var e = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, t = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, n = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, r = /\\([\u000b\u0020-\u00ff])/g, a = /([\\"])/g, s = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  r0.format = l, r0.parse = c;
  function l(h) {
    if (!h || typeof h != "object")
      throw new TypeError("argument obj is required");
    var v = h.parameters, g = h.type;
    if (!g || !s.test(g))
      throw new TypeError("invalid type");
    var b = g;
    if (v && typeof v == "object")
      for (var x, w = Object.keys(v).sort(), k = 0; k < w.length; k++) {
        if (x = w[k], !n.test(x))
          throw new TypeError("invalid parameter name");
        b += "; " + x + "=" + f(v[x]);
      }
    return b;
  }
  function c(h) {
    if (!h)
      throw new TypeError("argument string is required");
    var v = typeof h == "object" ? d(h) : h;
    if (typeof v != "string")
      throw new TypeError("argument string is required to be a string");
    var g = v.indexOf(";"), b = g !== -1 ? v.slice(0, g).trim() : v.trim();
    if (!s.test(b))
      throw new TypeError("invalid media type");
    var x = new m(b.toLowerCase());
    if (g !== -1) {
      var w, k, E;
      for (e.lastIndex = g; k = e.exec(v); ) {
        if (k.index !== g)
          throw new TypeError("invalid parameter format");
        g += k[0].length, w = k[1].toLowerCase(), E = k[2], E.charCodeAt(0) === 34 && (E = E.slice(1, -1), E.indexOf("\\") !== -1 && (E = E.replace(r, "$1"))), x.parameters[w] = E;
      }
      if (g !== v.length)
        throw new TypeError("invalid parameter format");
    }
    return x;
  }
  function d(h) {
    var v;
    if (typeof h.getHeader == "function" ? v = h.getHeader("content-type") : typeof h.headers == "object" && (v = h.headers && h.headers["content-type"]), typeof v != "string")
      throw new TypeError("content-type header is missing from object");
    return v;
  }
  function f(h) {
    var v = String(h);
    if (n.test(v))
      return v;
    if (v.length > 0 && !t.test(v))
      throw new TypeError("invalid parameter value");
    return '"' + v.replace(a, "\\$1") + '"';
  }
  function m(h) {
    this.parameters = /* @__PURE__ */ Object.create(null), this.type = h;
  }
  return r0;
}
var dhe = che(), Th = /* @__PURE__ */ new Map(), YV = function(e) {
  return e.cloneNode(!0);
}, g$ = function() {
  return window.location.protocol === "file:";
}, XV = function(e, t, n) {
  var r = new XMLHttpRequest();
  r.onreadystatechange = function() {
    try {
      if (!/\.svg/i.test(e) && r.readyState === 2) {
        var a = r.getResponseHeader("Content-Type");
        if (!a)
          throw new Error("Content type not found");
        var s = dhe.parse(a).type;
        if (!(s === "image/svg+xml" || s === "text/plain"))
          throw new Error("Invalid content type: ".concat(s));
      }
      if (r.readyState === 4) {
        if (r.status === 404 || r.responseXML === null)
          throw new Error(g$() ? "Note: SVG injection ajax calls do not work locally without adjusting security settings in your browser. Or consider using a local webserver." : "Unable to load SVG file: " + e);
        if (r.status === 200 || g$() && r.status === 0)
          n(null, r);
        else
          throw new Error("There was a problem injecting the SVG: " + r.status + " " + r.statusText);
      }
    } catch (l) {
      if (r.abort(), l instanceof Error)
        n(l, r);
      else
        throw l;
    }
  }, r.open("GET", e), r.withCredentials = t, r.overrideMimeType && r.overrideMimeType("text/xml"), r.send();
}, pd = {}, v$ = function(e, t) {
  pd[e] = pd[e] || [], pd[e].push(t);
}, fhe = function(e) {
  for (var t = function(a, s) {
    setTimeout(function() {
      if (Array.isArray(pd[e])) {
        var l = Th.get(e), c = pd[e][a];
        l instanceof SVGSVGElement && c(null, YV(l)), l instanceof Error && c(l), a === pd[e].length - 1 && delete pd[e];
      }
    }, 0);
  }, n = 0, r = pd[e].length; n < r; n++)
    t(n);
}, phe = function(e, t, n) {
  if (Th.has(e)) {
    var r = Th.get(e);
    if (r === void 0) {
      v$(e, n);
      return;
    }
    if (r instanceof SVGSVGElement) {
      n(null, YV(r));
      return;
    }
  }
  Th.set(e, void 0), v$(e, n), XV(e, t, function(a, s) {
    var l;
    a ? Th.set(e, a) : ((l = s.responseXML) === null || l === void 0 ? void 0 : l.documentElement) instanceof SVGSVGElement && Th.set(e, s.responseXML.documentElement), fhe(e);
  });
}, mhe = function(e, t, n) {
  XV(e, t, function(r, a) {
    var s;
    r ? n(r) : ((s = a.responseXML) === null || s === void 0 ? void 0 : s.documentElement) instanceof SVGSVGElement && n(null, a.responseXML.documentElement);
  });
}, hhe = 0, ghe = function() {
  return ++hhe;
}, pl = [], y$ = {}, vhe = "http://www.w3.org/2000/svg", YN = "http://www.w3.org/1999/xlink", b$ = function(e, t, n, r, a, s, l) {
  var c = e.getAttribute("data-src") || e.getAttribute("src");
  if (!c) {
    l(new Error("Invalid data-src or src attribute"));
    return;
  }
  if (pl.indexOf(e) !== -1) {
    pl.splice(pl.indexOf(e), 1), e = null;
    return;
  }
  pl.push(e), e.setAttribute("src", "");
  var d = r ? phe : mhe;
  d(c, a, function(f, m) {
    if (!m) {
      pl.splice(pl.indexOf(e), 1), e = null, l(f);
      return;
    }
    var h = e.getAttribute("id");
    h && m.setAttribute("id", h);
    var v = e.getAttribute("title");
    v && m.setAttribute("title", v);
    var g = e.getAttribute("width");
    g && m.setAttribute("width", g);
    var b = e.getAttribute("height");
    b && m.setAttribute("height", b);
    var x = Array.from(new Set(O_(O_(O_([], (m.getAttribute("class") || "").split(" "), !0), ["injected-svg"], !1), (e.getAttribute("class") || "").split(" "), !0))).join(" ").trim();
    m.setAttribute("class", x);
    var w = e.getAttribute("style");
    w && m.setAttribute("style", w), m.setAttribute("data-src", c);
    var k = [].filter.call(e.attributes, function(K) {
      return /^data-\w[\w-]*$/.test(K.name);
    });
    if (Array.prototype.forEach.call(k, function(K) {
      K.name && K.value && m.setAttribute(K.name, K.value);
    }), n) {
      var E = {
        clipPath: ["clip-path"],
        "color-profile": ["color-profile"],
        cursor: ["cursor"],
        filter: ["filter"],
        linearGradient: ["fill", "stroke"],
        marker: ["marker", "marker-start", "marker-mid", "marker-end"],
        mask: ["mask"],
        path: [],
        pattern: ["fill", "stroke"],
        radialGradient: ["fill", "stroke"]
      }, _, O, N, A, R;
      Object.keys(E).forEach(function(K) {
        _ = K, N = E[K], O = m.querySelectorAll(_ + "[id]");
        for (var q = function(F, Y) {
          A = O[F].id, R = A + "-" + ghe();
          var U;
          Array.prototype.forEach.call(N, function(re) {
            U = m.querySelectorAll("[" + re + '*="' + A + '"]');
            for (var le = 0, me = U.length; le < me; le++) {
              var ve = U[le].getAttribute(re);
              ve && !ve.match(new RegExp('url\\("?#' + A + '"?\\)')) || U[le].setAttribute(re, "url(#" + R + ")");
            }
          });
          for (var W = m.querySelectorAll("[*|href]"), J = [], oe = 0, fe = W.length; oe < fe; oe++) {
            var ie = W[oe].getAttributeNS(YN, "href");
            ie && ie.toString() === "#" + O[F].id && J.push(W[oe]);
          }
          for (var ce = 0, ge = J.length; ce < ge; ce++)
            J[ce].setAttributeNS(YN, "href", "#" + R);
          O[F].id = R;
        }, Z = 0, V = O.length; Z < V; Z++)
          q(Z);
      });
    }
    m.removeAttribute("xmlns:a");
    for (var D = m.querySelectorAll("script"), I = [], z, B, P = 0, H = D.length; P < H; P++)
      B = D[P].getAttribute("type"), (!B || B === "application/ecmascript" || B === "application/javascript" || B === "text/javascript") && (z = D[P].innerText || D[P].textContent, z && I.push(z), m.removeChild(D[P]));
    if (I.length > 0 && (t === "always" || t === "once" && !y$[c])) {
      for (var L = 0, G = I.length; L < G; L++)
        new Function(I[L])(window);
      y$[c] = !0;
    }
    var $ = m.querySelectorAll("style");
    if (Array.prototype.forEach.call($, function(K) {
      K.textContent += "";
    }), m.setAttribute("xmlns", vhe), m.setAttribute("xmlns:xlink", YN), s(m), !e.parentNode) {
      pl.splice(pl.indexOf(e), 1), e = null, l(new Error("Parent node is null"));
      return;
    }
    e.parentNode.replaceChild(m, e), pl.splice(pl.indexOf(e), 1), e = null, l(null, m);
  });
}, yhe = function(e, t) {
  var n = t === void 0 ? {} : t, r = n.afterAll, a = r === void 0 ? function() {
  } : r, s = n.afterEach, l = s === void 0 ? function() {
  } : s, c = n.beforeEach, d = c === void 0 ? function() {
  } : c, f = n.cacheRequests, m = f === void 0 ? !0 : f, h = n.evalScripts, v = h === void 0 ? "never" : h, g = n.httpRequestWithCredentials, b = g === void 0 ? !1 : g, x = n.renumerateIRIElements, w = x === void 0 ? !0 : x;
  if (e && "length" in e)
    for (var k = 0, E = 0, _ = e.length; E < _; E++)
      b$(e[E], v, w, m, b, d, function(O, N) {
        l(O, N), e && "length" in e && e.length === ++k && a(k);
      });
  else e ? b$(e, v, w, m, b, d, function(O, N) {
    l(O, N), a(1), e = null;
  }) : a(0);
}, bhe = function(e) {
  var t = e?.ownerDocument || document;
  return t.defaultView || window;
}, whe = function(e, t) {
  for (var n in e)
    if (!(n in t))
      return !0;
  for (var r in t)
    if (e[r] !== t[r])
      return !0;
  return !1;
}, xhe = ["afterInjection", "beforeInjection", "desc", "evalScripts", "fallback", "httpRequestWithCredentials", "loading", "renumerateIRIElements", "src", "title", "useRequestCache", "wrapper"], o0 = "http://www.w3.org/2000/svg", w$ = "http://www.w3.org/1999/xlink", W4 = /* @__PURE__ */ (function(e) {
  function t() {
    for (var r, a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = e.call.apply(e, [this].concat(s)) || this, r.initialState = {
      hasError: !1,
      isLoading: !0
    }, r.state = r.initialState, r._isMounted = !1, r.reactWrapper = void 0, r.nonReactWrapper = void 0, r.refCallback = function(c) {
      r.reactWrapper = c;
    }, r;
  }
  i4(t, e);
  var n = t.prototype;
  return n.renderSVG = function() {
    var r = this;
    if (this.reactWrapper instanceof bhe(this.reactWrapper).Node) {
      var a = this.props, s = a.desc, l = a.evalScripts, c = a.httpRequestWithCredentials, d = a.renumerateIRIElements, f = a.src, m = a.title, h = a.useRequestCache, v = this.props.onError, g = this.props.beforeInjection, b = this.props.afterInjection, x = this.props.wrapper, w, k;
      x === "svg" ? (w = document.createElementNS(o0, x), w.setAttribute("xmlns", o0), w.setAttribute("xmlns:xlink", w$), k = document.createElementNS(o0, x)) : (w = document.createElement(x), k = document.createElement(x)), w.appendChild(k), k.dataset.src = f, this.nonReactWrapper = this.reactWrapper.appendChild(w);
      var E = function(N) {
        if (r.removeSVG(), !r._isMounted) {
          v(N);
          return;
        }
        r.setState(function() {
          return {
            hasError: !0,
            isLoading: !1
          };
        }, function() {
          v(N);
        });
      }, _ = function(N, A) {
        if (N) {
          E(N);
          return;
        }
        r._isMounted && r.setState(function() {
          return {
            isLoading: !1
          };
        }, function() {
          try {
            b(A);
          } catch (R) {
            E(R);
          }
        });
      }, O = function(N) {
        if (N.setAttribute("role", "img"), s) {
          var A = N.querySelector(":scope > desc");
          A && N.removeChild(A);
          var R = document.createElement("desc");
          R.innerHTML = s, N.prepend(R);
        }
        if (m) {
          var D = N.querySelector(":scope > title");
          D && N.removeChild(D);
          var I = document.createElement("title");
          I.innerHTML = m, N.prepend(I);
        }
        try {
          g(N);
        } catch (z) {
          E(z);
        }
      };
      yhe(k, {
        afterEach: _,
        beforeEach: O,
        cacheRequests: h,
        evalScripts: l,
        httpRequestWithCredentials: c,
        renumerateIRIElements: d
      });
    }
  }, n.removeSVG = function() {
    var r;
    (r = this.nonReactWrapper) != null && r.parentNode && (this.nonReactWrapper.parentNode.removeChild(this.nonReactWrapper), this.nonReactWrapper = null);
  }, n.componentDidMount = function() {
    this._isMounted = !0, this.renderSVG();
  }, n.componentDidUpdate = function(r) {
    var a = this;
    whe(mt({}, r), this.props) && this.setState(function() {
      return a.initialState;
    }, function() {
      a.removeSVG(), a.renderSVG();
    });
  }, n.componentWillUnmount = function() {
    this._isMounted = !1, this.removeSVG();
  }, n.render = function() {
    var r = this.props;
    r.afterInjection, r.beforeInjection, r.desc, r.evalScripts;
    var a = r.fallback;
    r.httpRequestWithCredentials;
    var s = r.loading;
    r.renumerateIRIElements, r.src, r.title, r.useRequestCache;
    var l = r.wrapper, c = OE(r, xhe), d = l;
    return /* @__PURE__ */ M.createElement(d, mt({}, c, {
      ref: this.refCallback
    }, l === "svg" ? {
      xmlns: o0,
      xmlnsXlink: w$
    } : {}), this.state.isLoading && s && /* @__PURE__ */ M.createElement(s, null), this.state.hasError && a && /* @__PURE__ */ M.createElement(a, null));
  }, t;
})(M.Component);
W4.defaultProps = {
  afterInjection: function() {
  },
  beforeInjection: function() {
  },
  desc: "",
  evalScripts: "never",
  fallback: null,
  httpRequestWithCredentials: !1,
  loading: null,
  onError: function() {
  },
  renumerateIRIElements: !0,
  title: "",
  useRequestCache: !0,
  wrapper: "div"
};
W4.propTypes = {
  afterInjection: Pr.func,
  beforeInjection: Pr.func,
  desc: Pr.string,
  evalScripts: Pr.oneOf(["always", "once", "never"]),
  fallback: Pr.oneOfType([Pr.func, Pr.object, Pr.string]),
  httpRequestWithCredentials: Pr.bool,
  loading: Pr.oneOfType([Pr.func, Pr.object, Pr.string]),
  onError: Pr.func,
  renumerateIRIElements: Pr.bool,
  src: Pr.string.isRequired,
  title: Pr.string,
  useRequestCache: Pr.bool,
  wrapper: Pr.oneOf(["div", "span", "svg"])
};
const q4 = ({
  text: e = "No image data provided"
}) => /* @__PURE__ */ C.jsx(
  "div",
  {
    style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      minHeight: "100px",
      border: "1px dashed #ccc",
      color: "#666"
    },
    children: e
  }
), She = M.memo(
  ({
    value: e,
    format: t = "jpeg",
    alt: n = "Base64 image",
    onError: r,
    onLoad: a,
    ...s
  }) => {
    const [l, c] = M.useState(!1), [d, f] = M.useState(!0), m = M.useRef(null), h = M.useMemo(() => {
      if (typeof e == "string")
        return e;
      if (e && typeof e == "object" && "data" in e) {
        const x = e.data;
        if (x instanceof ArrayBuffer) {
          const w = new Uint8Array(x);
          let k = "";
          for (let E = 0; E < w.byteLength; E++)
            k += String.fromCharCode(w[E]);
          return btoa(k);
        }
      }
      return "";
    }, [e]), v = M.useMemo(() => h ? `data:image/${t};base64,${h}` : "", [h, t]), g = M.useCallback(
      (x) => {
        c(!0), f(!1), r?.(x);
      },
      [r]
    ), b = M.useCallback(() => {
      f(!1), c(!1), a?.();
    }, [a]);
    return M.useEffect(() => {
      const x = m.current;
      if (x)
        return x.addEventListener("error", g), x.addEventListener("load", b), () => {
          x.removeEventListener("error", g), x.removeEventListener("load", b);
        };
    }, [g, b, e]), M.useEffect(() => {
      c(!1), f(!0);
    }, [e]), h ? l ? /* @__PURE__ */ C.jsx(
      "div",
      {
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          minHeight: "100px",
          border: "1px dashed #ccc",
          color: "#666"
        },
        children: "Failed to load base64 image"
      }
    ) : /* @__PURE__ */ C.jsx(
      "img",
      {
        ref: m,
        src: v,
        alt: n,
        className: `base64-image-renderer image-renderer ${s.className || ""} ${d ? " loading" : ""}`,
        ...s
      }
    ) : /* @__PURE__ */ C.jsx(q4, {});
  }
), khe = M.memo(
  ({
    value: e,
    alt: t = "SVG image",
    onError: n,
    onLoad: r,
    ...a
  }) => {
    const [s, l] = M.useState(!1), c = M.useMemo(() => {
      if (!e) return "";
      try {
        return `data:image/svg+xml;base64,${btoa(e)}`;
      } catch (f) {
        return console.error("Failed to encode SVG to base64:", f), "";
      }
    }, [e]);
    M.useEffect(() => {
      l(!1);
    }, [e]);
    const d = M.useCallback(
      (f) => {
        l(!0), n?.(f);
      },
      [n]
    );
    return e ? s || !c ? /* @__PURE__ */ C.jsx(
      "div",
      {
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          minHeight: "100px",
          border: "1px dashed #ccc",
          color: "#666"
        },
        children: "Failed to load SVG"
      }
    ) : /* @__PURE__ */ C.jsx(
      W4,
      {
        src: c,
        className: `svg-renderer ${a.className || ""}`,
        style: {
          maxWidth: "100%",
          maxHeight: "100%",
          ...a.style
        },
        beforeInjection: (f) => {
          f.classList.add("svg-renderer"), f.setAttribute("style", "max-width: 100%; max-height: 100%;"), f.setAttribute("width", "100%"), f.setAttribute("height", "100%"), f.setAttribute("aria-label", t);
          const m = () => {
            l(!1), r?.();
          }, h = (v) => {
            l(!0), n?.(v);
          };
          try {
            f.addEventListener("load", m), f.addEventListener("error", h);
          } catch {
            m();
          }
        },
        onError: d
      }
    ) : /* @__PURE__ */ C.jsx(q4, {});
  }
), _he = M.memo(
  ({
    src: e,
    alt: t = "Streaming image",
    onError: n,
    onLoad: r,
    ...a
  }) => {
    const s = M.useRef(null), [l, c] = M.useState(!1), [d, f] = M.useState(!0);
    M.useEffect(() => {
      s.current && e && (f(!0), c(!1), s.current.src = e);
    }, [e]);
    const m = M.useCallback(
      (v) => {
        c(!0), f(!1), n?.(v);
      },
      [n]
    ), h = M.useCallback(() => {
      f(!1), c(!1), r?.();
    }, [r]);
    return M.useEffect(() => {
      const v = s.current;
      if (v)
        return v.addEventListener("error", m), v.addEventListener("load", h), () => {
          v.removeEventListener("error", m), v.removeEventListener("load", h);
        };
    }, [m, h]), l ? /* @__PURE__ */ C.jsx(q4, { text: "Failed to load image" }) : /* @__PURE__ */ C.jsx(
      "img",
      {
        ref: s,
        className: `streaming-image image-renderer ${a.className || ""} ${d ? " loading" : ""}`,
        alt: t,
        ...a
      }
    );
  }
);
function qE(e) {
  const t = e + "CollectionProvider", [n, r] = Kl(t), [a, s] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), l = (x) => {
    const { scope: w, children: k } = x, E = jt.useRef(null), _ = jt.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ C.jsx(a, { scope: w, itemMap: _, collectionRef: E, children: k });
  };
  l.displayName = t;
  const c = e + "CollectionSlot", d = /* @__PURE__ */ pg(c), f = jt.forwardRef(
    (x, w) => {
      const { scope: k, children: E } = x, _ = s(c, k), O = Xn(w, _.collectionRef);
      return /* @__PURE__ */ C.jsx(d, { ref: O, children: E });
    }
  );
  f.displayName = c;
  const m = e + "CollectionItemSlot", h = "data-radix-collection-item", v = /* @__PURE__ */ pg(m), g = jt.forwardRef(
    (x, w) => {
      const { scope: k, children: E, ..._ } = x, O = jt.useRef(null), N = Xn(w, O), A = s(m, k);
      return jt.useEffect(() => (A.itemMap.set(O, { ref: O, ..._ }), () => {
        A.itemMap.delete(O);
      })), /* @__PURE__ */ C.jsx(v, { [h]: "", ref: N, children: E });
    }
  );
  g.displayName = m;
  function b(x) {
    const w = s(e + "CollectionConsumer", x);
    return jt.useCallback(() => {
      const k = w.collectionRef.current;
      if (!k) return [];
      const E = Array.from(k.querySelectorAll(`[${h}]`));
      return Array.from(w.itemMap.values()).sort(
        (_, O) => E.indexOf(_.ref.current) - E.indexOf(O.ref.current)
      );
    }, [w.collectionRef, w.itemMap]);
  }
  return [
    { Provider: l, Slot: f, ItemSlot: g },
    b,
    r
  ];
}
var Ehe = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), Che = "VisuallyHidden", G4 = M.forwardRef(
  (e, t) => /* @__PURE__ */ C.jsx(
    Qt.span,
    {
      ...e,
      ref: t,
      style: { ...Ehe, ...e.style }
    }
  )
);
G4.displayName = Che;
var K4 = "ToastProvider", [Y4, Ohe, Mhe] = qE("Toast"), [JV] = Kl("Toast", [Mhe]), [Nhe, GE] = JV(K4), QV = (e) => {
  const {
    __scopeToast: t,
    label: n = "Notification",
    duration: r = 5e3,
    swipeDirection: a = "right",
    swipeThreshold: s = 50,
    children: l
  } = e, [c, d] = M.useState(null), [f, m] = M.useState(0), h = M.useRef(!1), v = M.useRef(!1);
  return n.trim() || console.error(
    `Invalid prop \`label\` supplied to \`${K4}\`. Expected non-empty \`string\`.`
  ), /* @__PURE__ */ C.jsx(Y4.Provider, { scope: t, children: /* @__PURE__ */ C.jsx(
    Nhe,
    {
      scope: t,
      label: n,
      duration: r,
      swipeDirection: a,
      swipeThreshold: s,
      toastCount: f,
      viewport: c,
      onViewportChange: d,
      onToastAdd: M.useCallback(() => m((g) => g + 1), []),
      onToastRemove: M.useCallback(() => m((g) => g - 1), []),
      isFocusedToastEscapeKeyDownRef: h,
      isClosePausedRef: v,
      children: l
    }
  ) });
};
QV.displayName = K4;
var ZV = "ToastViewport", Ahe = ["F8"], f3 = "toast.viewportPause", p3 = "toast.viewportResume", eH = M.forwardRef(
  (e, t) => {
    const {
      __scopeToast: n,
      hotkey: r = Ahe,
      label: a = "Notifications ({hotkey})",
      ...s
    } = e, l = GE(ZV, n), c = Ohe(n), d = M.useRef(null), f = M.useRef(null), m = M.useRef(null), h = M.useRef(null), v = Xn(t, h, l.onViewportChange), g = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), b = l.toastCount > 0;
    M.useEffect(() => {
      const w = (k) => {
        r.length !== 0 && r.every((E) => k[E] || k.code === E) && h.current?.focus();
      };
      return document.addEventListener("keydown", w), () => document.removeEventListener("keydown", w);
    }, [r]), M.useEffect(() => {
      const w = d.current, k = h.current;
      if (b && w && k) {
        const E = () => {
          if (!l.isClosePausedRef.current) {
            const A = new CustomEvent(f3);
            k.dispatchEvent(A), l.isClosePausedRef.current = !0;
          }
        }, _ = () => {
          if (l.isClosePausedRef.current) {
            const A = new CustomEvent(p3);
            k.dispatchEvent(A), l.isClosePausedRef.current = !1;
          }
        }, O = (A) => {
          !w.contains(A.relatedTarget) && _();
        }, N = () => {
          w.contains(document.activeElement) || _();
        };
        return w.addEventListener("focusin", E), w.addEventListener("focusout", O), w.addEventListener("pointermove", E), w.addEventListener("pointerleave", N), window.addEventListener("blur", E), window.addEventListener("focus", _), () => {
          w.removeEventListener("focusin", E), w.removeEventListener("focusout", O), w.removeEventListener("pointermove", E), w.removeEventListener("pointerleave", N), window.removeEventListener("blur", E), window.removeEventListener("focus", _);
        };
      }
    }, [b, l.isClosePausedRef]);
    const x = M.useCallback(
      ({ tabbingDirection: w }) => {
        const k = c().map((E) => {
          const _ = E.ref.current, O = [_, ...Vhe(_)];
          return w === "forwards" ? O : O.reverse();
        });
        return (w === "forwards" ? k.reverse() : k).flat();
      },
      [c]
    );
    return M.useEffect(() => {
      const w = h.current;
      if (w) {
        const k = (E) => {
          const _ = E.altKey || E.ctrlKey || E.metaKey;
          if (E.key === "Tab" && !_) {
            const O = document.activeElement, N = E.shiftKey;
            if (E.target === w && N) {
              f.current?.focus();
              return;
            }
            const A = x({ tabbingDirection: N ? "backwards" : "forwards" }), R = A.findIndex((D) => D === O);
            XN(A.slice(R + 1)) ? E.preventDefault() : N ? f.current?.focus() : m.current?.focus();
          }
        };
        return w.addEventListener("keydown", k), () => w.removeEventListener("keydown", k);
      }
    }, [c, x]), /* @__PURE__ */ C.jsxs(
      iae,
      {
        ref: d,
        role: "region",
        "aria-label": a.replace("{hotkey}", g),
        tabIndex: -1,
        style: { pointerEvents: b ? void 0 : "none" },
        children: [
          b && /* @__PURE__ */ C.jsx(
            m3,
            {
              ref: f,
              onFocusFromOutsideViewport: () => {
                const w = x({
                  tabbingDirection: "forwards"
                });
                XN(w);
              }
            }
          ),
          /* @__PURE__ */ C.jsx(Y4.Slot, { scope: n, children: /* @__PURE__ */ C.jsx(Qt.ol, { tabIndex: -1, ...s, ref: v }) }),
          b && /* @__PURE__ */ C.jsx(
            m3,
            {
              ref: m,
              onFocusFromOutsideViewport: () => {
                const w = x({
                  tabbingDirection: "backwards"
                });
                XN(w);
              }
            }
          )
        ]
      }
    );
  }
);
eH.displayName = ZV;
var tH = "ToastFocusProxy", m3 = M.forwardRef(
  (e, t) => {
    const { __scopeToast: n, onFocusFromOutsideViewport: r, ...a } = e, s = GE(tH, n);
    return /* @__PURE__ */ C.jsx(
      G4,
      {
        tabIndex: 0,
        ...a,
        ref: t,
        style: { position: "fixed" },
        onFocus: (l) => {
          const c = l.relatedTarget;
          !s.viewport?.contains(c) && r();
        }
      }
    );
  }
);
m3.displayName = tH;
var ak = "Toast", Rhe = "toast.swipeStart", jhe = "toast.swipeMove", Phe = "toast.swipeCancel", Dhe = "toast.swipeEnd", nH = M.forwardRef(
  (e, t) => {
    const { forceMount: n, open: r, defaultOpen: a, onOpenChange: s, ...l } = e, [c, d] = Bd({
      prop: r,
      defaultProp: a ?? !0,
      onChange: s,
      caller: ak
    });
    return /* @__PURE__ */ C.jsx(al, { present: n || c, children: /* @__PURE__ */ C.jsx(
      zhe,
      {
        open: c,
        ...l,
        ref: t,
        onClose: () => d(!1),
        onPause: $a(e.onPause),
        onResume: $a(e.onResume),
        onSwipeStart: et(e.onSwipeStart, (f) => {
          f.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: et(e.onSwipeMove, (f) => {
          const { x: m, y: h } = f.detail.delta;
          f.currentTarget.setAttribute("data-swipe", "move"), f.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${m}px`), f.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${h}px`);
        }),
        onSwipeCancel: et(e.onSwipeCancel, (f) => {
          f.currentTarget.setAttribute("data-swipe", "cancel"), f.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), f.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), f.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), f.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: et(e.onSwipeEnd, (f) => {
          const { x: m, y: h } = f.detail.delta;
          f.currentTarget.setAttribute("data-swipe", "end"), f.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), f.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), f.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${m}px`), f.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${h}px`), d(!1);
        })
      }
    ) });
  }
);
nH.displayName = ak;
var [Ihe, $he] = JV(ak, {
  onClose() {
  }
}), zhe = M.forwardRef(
  (e, t) => {
    const {
      __scopeToast: n,
      type: r = "foreground",
      duration: a,
      open: s,
      onClose: l,
      onEscapeKeyDown: c,
      onPause: d,
      onResume: f,
      onSwipeStart: m,
      onSwipeMove: h,
      onSwipeCancel: v,
      onSwipeEnd: g,
      ...b
    } = e, x = GE(ak, n), [w, k] = M.useState(null), E = Xn(t, (L) => k(L)), _ = M.useRef(null), O = M.useRef(null), N = a || x.duration, A = M.useRef(0), R = M.useRef(N), D = M.useRef(0), { onToastAdd: I, onToastRemove: z } = x, B = $a(() => {
      w?.contains(document.activeElement) && x.viewport?.focus(), l();
    }), P = M.useCallback(
      (L) => {
        !L || L === 1 / 0 || (window.clearTimeout(D.current), A.current = (/* @__PURE__ */ new Date()).getTime(), D.current = window.setTimeout(B, L));
      },
      [B]
    );
    M.useEffect(() => {
      const L = x.viewport;
      if (L) {
        const G = () => {
          P(R.current), f?.();
        }, $ = () => {
          const K = (/* @__PURE__ */ new Date()).getTime() - A.current;
          R.current = R.current - K, window.clearTimeout(D.current), d?.();
        };
        return L.addEventListener(f3, $), L.addEventListener(p3, G), () => {
          L.removeEventListener(f3, $), L.removeEventListener(p3, G);
        };
      }
    }, [x.viewport, N, d, f, P]), M.useEffect(() => {
      s && !x.isClosePausedRef.current && P(N);
    }, [s, N, x.isClosePausedRef, P]), M.useEffect(() => (I(), () => z()), [I, z]);
    const H = M.useMemo(() => w ? uH(w) : null, [w]);
    return x.viewport ? /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
      H && /* @__PURE__ */ C.jsx(
        The,
        {
          __scopeToast: n,
          role: "status",
          "aria-live": r === "foreground" ? "assertive" : "polite",
          children: H
        }
      ),
      /* @__PURE__ */ C.jsx(Ihe, { scope: n, onClose: B, children: Xm.createPortal(
        /* @__PURE__ */ C.jsx(Y4.ItemSlot, { scope: n, children: /* @__PURE__ */ C.jsx(
          aae,
          {
            asChild: !0,
            onEscapeKeyDown: et(c, () => {
              x.isFocusedToastEscapeKeyDownRef.current || B(), x.isFocusedToastEscapeKeyDownRef.current = !1;
            }),
            children: /* @__PURE__ */ C.jsx(
              Qt.li,
              {
                tabIndex: 0,
                "data-state": s ? "open" : "closed",
                "data-swipe-direction": x.swipeDirection,
                ...b,
                ref: E,
                style: { userSelect: "none", touchAction: "none", ...e.style },
                onKeyDown: et(e.onKeyDown, (L) => {
                  L.key === "Escape" && (c?.(L.nativeEvent), L.nativeEvent.defaultPrevented || (x.isFocusedToastEscapeKeyDownRef.current = !0, B()));
                }),
                onPointerDown: et(e.onPointerDown, (L) => {
                  L.button === 0 && (_.current = { x: L.clientX, y: L.clientY });
                }),
                onPointerMove: et(e.onPointerMove, (L) => {
                  if (!_.current) return;
                  const G = L.clientX - _.current.x, $ = L.clientY - _.current.y, K = !!O.current, q = ["left", "right"].includes(x.swipeDirection), Z = ["left", "up"].includes(x.swipeDirection) ? Math.min : Math.max, V = q ? Z(0, G) : 0, F = q ? 0 : Z(0, $), Y = L.pointerType === "touch" ? 10 : 2, U = { x: V, y: F }, W = { originalEvent: L, delta: U };
                  K ? (O.current = U, a0(jhe, h, W, {
                    discrete: !1
                  })) : x$(U, x.swipeDirection, Y) ? (O.current = U, a0(Rhe, m, W, {
                    discrete: !1
                  }), L.target.setPointerCapture(L.pointerId)) : (Math.abs(G) > Y || Math.abs($) > Y) && (_.current = null);
                }),
                onPointerUp: et(e.onPointerUp, (L) => {
                  const G = O.current, $ = L.target;
                  if ($.hasPointerCapture(L.pointerId) && $.releasePointerCapture(L.pointerId), O.current = null, _.current = null, G) {
                    const K = L.currentTarget, q = { originalEvent: L, delta: G };
                    x$(G, x.swipeDirection, x.swipeThreshold) ? a0(Dhe, g, q, {
                      discrete: !0
                    }) : a0(
                      Phe,
                      v,
                      q,
                      {
                        discrete: !0
                      }
                    ), K.addEventListener("click", (Z) => Z.preventDefault(), {
                      once: !0
                    });
                  }
                })
              }
            )
          }
        ) }),
        x.viewport
      ) })
    ] }) : null;
  }
), The = (e) => {
  const { __scopeToast: t, children: n, ...r } = e, a = GE(ak, t), [s, l] = M.useState(!1), [c, d] = M.useState(!1);
  return Bhe(() => l(!0)), M.useEffect(() => {
    const f = window.setTimeout(() => d(!0), 1e3);
    return () => window.clearTimeout(f);
  }, []), c ? null : /* @__PURE__ */ C.jsx(AE, { asChild: !0, children: /* @__PURE__ */ C.jsx(G4, { ...r, children: s && /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
    a.label,
    " ",
    n
  ] }) }) });
}, Lhe = "ToastTitle", rH = M.forwardRef(
  (e, t) => {
    const { __scopeToast: n, ...r } = e;
    return /* @__PURE__ */ C.jsx(Qt.div, { ...r, ref: t });
  }
);
rH.displayName = Lhe;
var Fhe = "ToastDescription", oH = M.forwardRef(
  (e, t) => {
    const { __scopeToast: n, ...r } = e;
    return /* @__PURE__ */ C.jsx(Qt.div, { ...r, ref: t });
  }
);
oH.displayName = Fhe;
var aH = "ToastAction", iH = M.forwardRef(
  (e, t) => {
    const { altText: n, ...r } = e;
    return n.trim() ? /* @__PURE__ */ C.jsx(lH, { altText: n, asChild: !0, children: /* @__PURE__ */ C.jsx(X4, { ...r, ref: t }) }) : (console.error(
      `Invalid prop \`altText\` supplied to \`${aH}\`. Expected non-empty \`string\`.`
    ), null);
  }
);
iH.displayName = aH;
var sH = "ToastClose", X4 = M.forwardRef(
  (e, t) => {
    const { __scopeToast: n, ...r } = e, a = $he(sH, n);
    return /* @__PURE__ */ C.jsx(lH, { asChild: !0, children: /* @__PURE__ */ C.jsx(
      Qt.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: et(e.onClick, a.onClose)
      }
    ) });
  }
);
X4.displayName = sH;
var lH = M.forwardRef((e, t) => {
  const { __scopeToast: n, altText: r, ...a } = e;
  return /* @__PURE__ */ C.jsx(
    Qt.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": r || void 0,
      ...a,
      ref: t
    }
  );
});
function uH(e) {
  const t = [];
  return Array.from(e.childNodes).forEach((n) => {
    if (n.nodeType === n.TEXT_NODE && n.textContent && t.push(n.textContent), Uhe(n)) {
      const r = n.ariaHidden || n.hidden || n.style.display === "none", a = n.dataset.radixToastAnnounceExclude === "";
      if (!r)
        if (a) {
          const s = n.dataset.radixToastAnnounceAlt;
          s && t.push(s);
        } else
          t.push(...uH(n));
    }
  }), t;
}
function a0(e, t, n, { discrete: r }) {
  const a = n.originalEvent.currentTarget, s = new CustomEvent(e, { bubbles: !0, cancelable: !0, detail: n });
  t && a.addEventListener(e, t, { once: !0 }), r ? c4(a, s) : a.dispatchEvent(s);
}
var x$ = (e, t, n = 0) => {
  const r = Math.abs(e.x), a = Math.abs(e.y), s = r > a;
  return t === "left" || t === "right" ? s && r > n : !s && a > n;
};
function Bhe(e = () => {
}) {
  const t = $a(e);
  zc(() => {
    let n = 0, r = 0;
    return n = window.requestAnimationFrame(() => r = window.requestAnimationFrame(t)), () => {
      window.cancelAnimationFrame(n), window.cancelAnimationFrame(r);
    };
  }, [t]);
}
function Uhe(e) {
  return e.nodeType === e.ELEMENT_NODE;
}
function Vhe(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const a = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || a ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function XN(e) {
  const t = document.activeElement;
  return e.some((n) => n === t ? !0 : (n.focus(), document.activeElement !== t));
}
var Hhe = QV, Whe = eH, qhe = nH, Ghe = rH, Khe = oH, Yhe = iH, Xhe = X4;
const Do = [];
for (let e = 0; e < 256; ++e)
  Do.push((e + 256).toString(16).slice(1));
function Jhe(e, t = 0) {
  return (Do[e[t + 0]] + Do[e[t + 1]] + Do[e[t + 2]] + Do[e[t + 3]] + "-" + Do[e[t + 4]] + Do[e[t + 5]] + "-" + Do[e[t + 6]] + Do[e[t + 7]] + "-" + Do[e[t + 8]] + Do[e[t + 9]] + "-" + Do[e[t + 10]] + Do[e[t + 11]] + Do[e[t + 12]] + Do[e[t + 13]] + Do[e[t + 14]] + Do[e[t + 15]]).toLowerCase();
}
let JN;
const Qhe = new Uint8Array(16);
function Zhe() {
  if (!JN) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    JN = crypto.getRandomValues.bind(crypto);
  }
  return JN(Qhe);
}
const ege = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), S$ = { randomUUID: ege };
function tge(e, t, n) {
  e = e || {};
  const r = e.random ?? e.rng?.() ?? Zhe();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, Jhe(r);
}
function J4(e, t, n) {
  return S$.randomUUID && !e ? S$.randomUUID() : tge(e);
}
const cH = M.createContext(
  void 0
), dH = M.createContext(
  void 0
), nge = 350, rge = ({ children: e, fixedHeight: t, duration: n = 5e3, maxVisible: r = 3, ...a }) => {
  const [s, l] = M.useState(/* @__PURE__ */ new Map()), c = M.useRef(/* @__PURE__ */ new Map()), d = M.useRef(null), f = M.useRef(!0), m = M.useCallback(() => {
    const k = Array.from(c.current).reverse();
    if (t) {
      const E = t;
      k.forEach(([, _], O) => {
        if (!_) return;
        _.setAttribute("data-front", String(O === 0)), _.setAttribute("data-hidden", String(O >= r)), _.style.setProperty("--index", String(O)), _.style.setProperty("--height", `${t}px`), _.style.setProperty("--front-height", `${E}px`);
        const N = t * O;
        _.style.setProperty("--hover-offset-y", `-${N}px`);
      });
    } else {
      const E = k.map(([, O]) => {
        if (!O) return 0;
        const N = O.querySelector(
          ".ToastInner"
        );
        if (!N) return O.clientHeight;
        const A = N.style.height;
        N.style.height = "auto";
        const R = O.clientHeight;
        return N.style.height = A, R;
      }), _ = E[0] || 0;
      k.forEach(([, O], N) => {
        if (!O) return;
        const A = E[N];
        O.setAttribute("data-front", String(N === 0)), O.setAttribute("data-hidden", String(N >= r)), O.style.setProperty("--index", String(N)), O.style.setProperty("--height", `${A}px`), O.style.setProperty("--front-height", `${_}px`);
        const R = E.slice(0, N).reduce((D, I) => D + I, 0);
        O.style.setProperty("--hover-offset-y", `-${R}px`);
      });
    }
  }, [t, r]), h = M.useCallback(
    (k) => {
      l((E) => {
        const _ = new Map(E);
        return _.set(J4(), {
          ...k,
          duration: k.duration || n,
          open: !0
        }), _;
      });
    },
    [n]
  ), v = M.useCallback((k) => {
    f.current && l((E) => {
      const _ = new Map(E);
      return _.delete(k), _;
    });
  }, []), g = M.useCallback(
    (k) => h({ ...k, status: k.status || "default" }),
    [h]
  ), b = M.useCallback(
    (k) => h({ ...k, status: "success" }),
    [h]
  ), x = M.useCallback(
    (k) => h({ ...k, status: "error" }),
    [h]
  );
  M.useEffect(() => (f.current = !0, () => {
    f.current = !1;
  }), []), M.useEffect(() => {
    const k = d.current;
    if (k) {
      const E = () => {
        c.current.forEach((N) => {
          N.setAttribute("data-hovering", "true");
        });
      }, _ = (N) => {
        (!k.contains(N.target) || k === N.target) && c.current.forEach((A) => {
          A.setAttribute("data-hovering", "false");
        });
      }, O = () => {
        c.current.forEach((N) => {
          N.setAttribute("data-hovering", "false");
        });
      };
      return k.addEventListener("pointermove", E), k.addEventListener("pointerleave", O), k.addEventListener("focusin", E), k.addEventListener("focusout", _), () => {
        k.removeEventListener("pointermove", E), k.removeEventListener("pointerleave", O), k.removeEventListener("focusin", E), k.removeEventListener("focusout", _);
      };
    }
  }, []);
  const w = M.useMemo(
    () => Object.assign(g, {
      success: b,
      error: x
    }),
    [g, b, x]
  );
  return /* @__PURE__ */ C.jsx(cH.Provider, { value: w, children: /* @__PURE__ */ C.jsx(
    dH.Provider,
    {
      value: M.useMemo(
        () => ({
          toastElementsMapRef: c,
          sortToasts: m
        }),
        [m]
      ),
      children: /* @__PURE__ */ C.jsxs(Hhe, { ...a, children: [
        e,
        Array.from(s).map(([k, E]) => /* @__PURE__ */ C.jsx(
          ige,
          {
            id: k,
            toast: E,
            onOpenChange: (_) => {
              _ || (c.current.delete(k), m(), l((O) => {
                const N = new Map(O), A = N.get(k);
                return A && N.set(k, { ...A, open: !1 }), N;
              }), setTimeout(() => {
                v(k);
              }, nge));
            }
          },
          k
        )),
        /* @__PURE__ */ C.jsx(
          Whe,
          {
            ref: d,
            className: "ToastViewport",
            style: t ? {
              "--fixed-toast-height": `${t}px`
            } : void 0
          }
        )
      ] })
    }
  ) });
}, oge = () => {
  const e = M.useContext(cH);
  if (e) return e;
  throw new Error("useToast must be used within Toasts");
}, age = () => {
  const e = M.useContext(dH);
  if (e) return e;
  throw new Error("useToastContext must be used within Toasts");
}, ige = ({
  onOpenChange: e,
  toast: t,
  id: n,
  ...r
}) => {
  const a = M.useRef(null), s = age(), { sortToasts: l, toastElementsMapRef: c } = s, d = c.current;
  return M.useLayoutEffect(() => (a.current && (d.set(n, a.current), l()), () => {
    d.delete(n), l();
  }), [n, l, d]), /* @__PURE__ */ C.jsx(
    qhe,
    {
      ...r,
      ref: a,
      type: t.type,
      duration: t.duration,
      className: "ToastRoot",
      onOpenChange: e,
      open: t.open,
      children: /* @__PURE__ */ C.jsxs("div", { className: "ToastInner", "data-status": t.status, children: [
        /* @__PURE__ */ C.jsx(sge, { status: t.status }),
        t.title && /* @__PURE__ */ C.jsx(Ghe, { className: "ToastTitle", children: t.title }),
        /* @__PURE__ */ C.jsx(Khe, { className: "ToastDescription", children: t.description }),
        t.action && /* @__PURE__ */ C.jsx(
          Yhe,
          {
            className: "ToastAction Button small green",
            altText: t.action.altText,
            onClick: t.action.onClick,
            asChild: !0,
            children: /* @__PURE__ */ C.jsx("button", { children: t.action.label })
          }
        ),
        /* @__PURE__ */ C.jsx(Xhe, { "aria-label": "Close", className: "ToastClose", children: /* @__PURE__ */ C.jsx(LE, { style: { fontSize: "12px" } }) })
      ] })
    }
  );
}, sge = ({ status: e }) => e !== "default" && e ? /* @__PURE__ */ C.jsxs("div", { style: { gridArea: "icon", alignSelf: "start" }, children: [
  e === "success" && /* @__PURE__ */ C.jsx(Sce, { style: { color: "#61d345", fontSize: "20px" } }),
  e === "error" && /* @__PURE__ */ C.jsx(kce, { style: { color: "#ff4b4b", fontSize: "20px" } })
] }) : null, lge = {}, k$ = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (c, d) => {
    const f = typeof c == "function" ? c(t) : c;
    if (!Object.is(f, t)) {
      const m = t;
      t = d ?? (typeof f != "object" || f === null) ? f : Object.assign({}, t, f), n.forEach((h) => h(t, m));
    }
  }, a = () => t, s = { setState: r, getState: a, getInitialState: () => l, subscribe: (c) => (n.add(c), () => n.delete(c)), destroy: () => {
    (lge ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), n.clear();
  } }, l = t = e(r, a, s);
  return s;
}, fH = (e) => e ? k$(e) : k$;
var _$ = { exports: {} }, QN = {}, E$ = { exports: {} }, ZN = {}, C$;
function uge() {
  if (C$) return ZN;
  C$ = 1;
  var e = jt;
  function t(h, v) {
    return h === v && (h !== 0 || 1 / h === 1 / v) || h !== h && v !== v;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, a = e.useEffect, s = e.useLayoutEffect, l = e.useDebugValue;
  function c(h, v) {
    var g = v(), b = r({ inst: { value: g, getSnapshot: v } }), x = b[0].inst, w = b[1];
    return s(
      function() {
        x.value = g, x.getSnapshot = v, d(x) && w({ inst: x });
      },
      [h, g, v]
    ), a(
      function() {
        return d(x) && w({ inst: x }), h(function() {
          d(x) && w({ inst: x });
        });
      },
      [h]
    ), l(g), g;
  }
  function d(h) {
    var v = h.getSnapshot;
    h = h.value;
    try {
      var g = v();
      return !n(h, g);
    } catch {
      return !0;
    }
  }
  function f(h, v) {
    return v();
  }
  var m = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? f : c;
  return ZN.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : m, ZN;
}
var O$;
function cge() {
  return O$ || (O$ = 1, E$.exports = uge()), E$.exports;
}
var M$;
function dge() {
  if (M$) return QN;
  M$ = 1;
  var e = jt, t = cge();
  function n(f, m) {
    return f === m && (f !== 0 || 1 / f === 1 / m) || f !== f && m !== m;
  }
  var r = typeof Object.is == "function" ? Object.is : n, a = t.useSyncExternalStore, s = e.useRef, l = e.useEffect, c = e.useMemo, d = e.useDebugValue;
  return QN.useSyncExternalStoreWithSelector = function(f, m, h, v, g) {
    var b = s(null);
    if (b.current === null) {
      var x = { hasValue: !1, value: null };
      b.current = x;
    } else x = b.current;
    b = c(
      function() {
        function k(A) {
          if (!E) {
            if (E = !0, _ = A, A = v(A), g !== void 0 && x.hasValue) {
              var R = x.value;
              if (g(R, A))
                return O = R;
            }
            return O = A;
          }
          if (R = O, r(_, A)) return R;
          var D = v(A);
          return g !== void 0 && g(R, D) ? (_ = A, R) : (_ = A, O = D);
        }
        var E = !1, _, O, N = h === void 0 ? null : h;
        return [
          function() {
            return k(m());
          },
          N === null ? void 0 : function() {
            return k(N());
          }
        ];
      },
      [m, h, v, g]
    );
    var w = a(f, b[0], b[1]);
    return l(
      function() {
        x.hasValue = !0, x.value = w;
      },
      [w]
    ), d(w), w;
  }, QN;
}
var N$;
function fge() {
  return N$ || (N$ = 1, _$.exports = dge()), _$.exports;
}
var pge = fge();
const pH = /* @__PURE__ */ Gc(pge), mH = {}, { useDebugValue: mge } = jt, { useSyncExternalStoreWithSelector: hge } = pH;
let A$ = !1;
const gge = (e) => e;
function vge(e, t = gge, n) {
  (mH ? "production" : void 0) !== "production" && n && !A$ && (console.warn(
    "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
  ), A$ = !0);
  const r = hge(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return mge(r), r;
}
const R$ = (e) => {
  (mH ? "production" : void 0) !== "production" && typeof e != "function" && console.warn(
    "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
  );
  const t = typeof e == "function" ? fH(e) : e, n = (r, a) => vge(t, r, a);
  return Object.assign(n, t), n;
}, Hi = (e) => e ? R$(e) : R$;
class Xc {
  constructor(t) {
    this.context = t;
  }
  get communicationManager() {
    return this.context.worker.getCommunicationManager();
  }
  get eventManager() {
    return this.context.worker.getEventManager();
  }
  get hookManager() {
    return this.context.worker.getHookManager();
  }
  get nodeManager() {
    return this.context.worker.getNodeManager();
  }
  get syncManager() {
    return this.context.worker.getSyncManager();
  }
  get connectionHealthManager() {
    return this.context.worker.getConnectionHealthManager();
  }
  get edgeManager() {
    return this.context.worker.getEdgeManager();
  }
  get groupManager() {
    return this.context.worker.getGroupManager();
  }
  get libraryManager() {
    return this.context.worker.getLibraryManager();
  }
}
const i0 = 2e3;
class yge extends Xc {
  constructor(t) {
    super(t), this._responsive = !1, this._last_pong = 0, this._last_pong = Date.now() - i0 * 100;
  }
  start() {
    this.stop(), this.pingInterval = setInterval(() => {
      this.context.worker.is_open && this.context.worker.send({ type: "ping" });
    }, i0), this.responsivenessCheckInterval = setInterval(() => {
      this._responsive = Date.now() - this._last_pong <= i0 * 3;
    }, i0 * 2);
  }
  stop() {
    this.pingInterval && clearInterval(this.pingInterval), this.responsivenessCheckInterval && clearInterval(this.responsivenessCheckInterval);
  }
  receivePong() {
    this._last_pong = Date.now(), this._responsive = !0;
  }
  isResponsive() {
    return this._responsive;
  }
}
const j$ = (e, t) => {
  e.properties = e.properties || {}, t.pos && (e.properties["frontend:pos"] = t.pos), t.size && (e.properties["frontend:size"] = t.size), t.collapsed !== void 0 && (e.properties["frontend:collapsed"] = !!t.collapsed);
}, P$ = 2e3, D$ = 2e3;
class bge extends Xc {
  constructor(t) {
    super(t), this._local_nodeupdates = /* @__PURE__ */ new Map(), this._local_groupupdates = /* @__PURE__ */ new Map(), this._after_next_sync = [], this.on_sync_complete = t.on_sync_complete || (async () => {
    });
  }
  start() {
    this._nodeupdatetimer = setTimeout(() => {
      this.sync_local_node_updates();
    }, P$), this._groupupdatetimer = setTimeout(() => {
      this.sync_local_group_updates();
    }, D$);
  }
  stop() {
    this._nodeupdatetimer && clearTimeout(this._nodeupdatetimer), this._groupupdatetimer && clearTimeout(this._groupupdatetimer);
  }
  async stepwise_fullsync() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    await this.sync_lib(), await this.sync_external_worker(), await this.sync_funcnodes_plugins(), await this.sync_nodespace(), await this.sync_view_state(), await this.on_sync_complete(this.context.worker);
    const t = this._after_next_sync.splice(0);
    for (const n of t)
      await n(this.context.worker), this._after_next_sync.includes(n) && this._after_next_sync.splice(this._after_next_sync.indexOf(n), 1);
  }
  add_after_next_sync(t) {
    this._after_next_sync.push(t);
  }
  remove_after_next_sync(t) {
    this._after_next_sync = this._after_next_sync.filter(
      (n) => n !== t
    );
  }
  async sync_lib() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.communicationManager._send_cmd({
      cmd: "get_library",
      wait_for_response: !0,
      retries: 2,
      unique: !0
    });
    this.context.worker._zustand.lib.libstate.getState().set({
      lib: t
    });
  }
  async sync_external_worker() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.communicationManager._send_cmd({
      cmd: "get_worker_dependencies",
      wait_for_response: !0,
      unique: !0
    });
    this.context.worker._zustand.lib.libstate.getState().set({
      external_worker: t
    });
  }
  async sync_funcnodes_plugins() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "get_plugin_keys",
      wait_for_response: !0,
      unique: !0,
      kwargs: { type: "react" }
    });
    for (const n of t) {
      const r = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "get_plugin",
        wait_for_response: !0,
        kwargs: { key: n, type: "react" },
        unique: !0
      });
      this.context.worker._zustand.add_packed_plugin(n, r);
    }
  }
  async sync_view_state() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "view_state",
      wait_for_response: !0,
      unique: !0
    });
    t.renderoptions && this.context.worker._zustand.update_render_options(t.renderoptions);
    const n = t.nodes;
    if (n)
      for (const r in n) {
        const a = {};
        j$(a, n[r]), this.context.worker._zustand.on_node_action({
          type: "update",
          node: a,
          id: r,
          from_remote: !0
        });
      }
  }
  async sync_nodespace() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "get_nodes",
      kwargs: { with_frontend: !0 },
      wait_for_response: !0,
      unique: !0
    });
    for (const a of t)
      this.eventManager._receive_node_added(a);
    const n = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "get_edges",
      wait_for_response: !0,
      unique: !0
    });
    for (const a of n)
      this.eventManager._receive_edge_added(...a);
    const r = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "get_groups",
      kwargs: {},
      wait_for_response: !0,
      unique: !0
    });
    this.eventManager._receive_groups(r);
  }
  async fullsync() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    let t;
    for (; ; )
      try {
        t = await this.communicationManager._send_cmd({
          cmd: "full_state",
          unique: !0
        });
        break;
      } catch (a) {
        a instanceof Error ? this.context.worker._zustand.logger.error("Error in fullsync", a) : this.context.worker._zustand.logger.error(
          "Error in fullsync",
          new Error(JSON.stringify(a))
        );
      }
    this.context.worker._zustand.logger.debug("Full state", t), this.context.worker._zustand.lib.libstate.getState().set({
      lib: t.backend.lib,
      external_worker: t.worker_dependencies
    }), t.view.renderoptions && this.context.worker._zustand.update_render_options(
      t.view.renderoptions
    );
    const n = t.view.nodes;
    for (const a of t.backend.nodes) {
      const s = n[a.id];
      s !== void 0 && j$(a, s), this.eventManager._receive_node_added(a);
    }
    for (const a of t.backend.edges)
      this.eventManager._receive_edge_added(...a);
    const r = t.backend.groups;
    r && this.eventManager._receive_groups(r);
  }
  sync_local_node_updates() {
    clearTimeout(this._nodeupdatetimer), this._local_nodeupdates.forEach(async (t, n) => {
      const r = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "update_node",
        kwargs: { nid: n, data: t },
        wait_for_response: !0
      });
      this.context.worker._zustand && Object.keys(r).length > 0 && this.context.worker._zustand.on_node_action({
        type: "update",
        node: r,
        id: n,
        from_remote: !0
      });
    }), this._local_nodeupdates.clear(), this._nodeupdatetimer = setTimeout(() => {
      this.sync_local_node_updates();
    }, P$);
  }
  sync_local_group_updates() {
    clearTimeout(this._groupupdatetimer), this._local_groupupdates.forEach(async (t, n) => {
      const r = await this.communicationManager._send_cmd({
        cmd: "update_group",
        kwargs: { gid: n, data: t },
        wait_for_response: !0
      });
      this.context.worker._zustand && this.context.worker._zustand.on_group_action({
        type: "update",
        group: r,
        id: n,
        from_remote: !0
      });
    }), this._local_groupupdates.clear(), this._groupupdatetimer = setTimeout(() => {
      this.sync_local_group_updates();
    }, D$);
  }
  locally_update_node(t) {
    const n = this._local_nodeupdates.get(t.id);
    if (n) {
      const { new_obj: r, change: a } = Ed(n, t.node);
      a && this._local_nodeupdates.set(t.id, r);
    } else
      this._local_nodeupdates.set(t.id, t.node);
    t.immediate && this.sync_local_node_updates();
  }
  locally_update_group(t) {
    const n = this._local_groupupdates.get(t.id);
    if (n) {
      const { new_obj: r, change: a } = Ed(n, t.group);
      a && this._local_groupupdates.set(t.id, r);
    } else
      this._local_groupupdates.set(t.id, t.group);
    t.immediate && this.sync_local_group_updates();
  }
}
class Nl {
  /**
   * Creates a new DataStructure instance.
   *
   * @param props - Configuration object containing data and MIME type
   */
  constructor({ data: t, mime: n }) {
    this._data = t, this._mime = n;
  }
  /**
   * Gets the raw wrapped data.
   *
   * @returns The original data in its native type
   */
  get data() {
    return this._data;
  }
  /**
   * Gets the data cast to the expected return type.
   * This is a type assertion and should be overridden in subclasses for proper type conversion.
   *
   * @returns The data cast to type R
   */
  get value() {
    return this._data;
  }
  /**
   * Gets the MIME type of the wrapped data.
   *
   * @returns The MIME type string
   */
  get mime() {
    return this._mime;
  }
  /**
   * Returns a string representation of the DataStructure.
   * The format varies based on the data type:
   * - ArrayBuffer: shows byte length
   * - Blob: shows size
   * - String/Array: shows length
   * - Object: shows number of keys
   * - Other types: shows only MIME type
   *
   * @returns String representation in format "DataStructure(size,mime)" or "DataStructure(mime)"
   */
  toString() {
    return this._data instanceof ArrayBuffer ? `DataStructure(${this._data.byteLength},${this._mime})` : this._data instanceof Blob ? `DataStructure(${this._data.size},${this._mime})` : this._data instanceof String ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Array ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Object ? `DataStructure(${Object.keys(this._data).length},${this._mime})` : `DataStructure(${this._mime})`;
  }
  /**
   * Returns the JSON representation of this DataStructure.
   * Currently delegates to toString() method.
   *
   * @returns JSON string representation
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Cleans up resources associated with this DataStructure.
   * Base implementation does nothing, but subclasses may override to release resources.
   */
  dispose() {
  }
}
class hH extends Nl {
  constructor({ data: t, mime: n }) {
    super({ data: KE(t), mime: n });
  }
  get objectUrl() {
    if (this._objectUrl)
      return this._objectUrl;
    const t = this.data instanceof Blob ? this.data : new Blob([this.data], { type: this.mime });
    return this._objectUrl = URL.createObjectURL(t), this._objectUrl;
  }
  dispose() {
    this._objectUrl && URL.revokeObjectURL(this._objectUrl), super.dispose();
  }
  get value() {
    return this.objectUrl;
  }
}
const KE = (e) => {
  if (e instanceof ArrayBuffer)
    return e;
  const t = ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e), n = new ArrayBuffer(t.byteLength);
  return new Uint8Array(n).set(t), n;
}, wge = {
  x: (e, t) => null,
  //  pad byte 	no value 	(7 )
  c: (e, t) => new DataView(e).getInt8(0),
  //  char 	bytes of length 1 	1 	b 	signed char 	integer 	1 	(1 ), (2 )
  B: (e, t) => new DataView(e).getUint8(0),
  //  unsigned char 	integer 	1 	(2 )
  "?": (e, t) => new DataView(e).getInt8(0) === 1,
  //  _Bool 	bool 	1 	(1 )
  h: (e, t) => new DataView(e).getInt16(0, t),
  //  short 	integer 	2 	(2 )
  H: (e, t) => new DataView(e).getUint16(0, t),
  //  unsigned short 	integer 	2 	(2 )
  i: (e, t) => new DataView(e).getInt32(0, t),
  //  int 	integer 	4 	(2 )
  I: (e, t) => new DataView(e).getUint32(0, t),
  //  unsigned int 	integer 	4 	(2 )
  l: (e, t) => new DataView(e).getInt32(0, t),
  //  long 	integer 	4 	(2 )
  L: (e, t) => new DataView(e).getUint32(0, t),
  //  unsigned long 	integer 	4 	(2 )
  q: (e, t) => Number(
    new DataView(e).getBigInt64(0, t)
  ),
  //  long long 	integer 	8 	(2 )
  Q: (e, t) => Number(
    new DataView(e).getBigUint64(0, t)
  ),
  //  unsigned long long 	integer 	8 	(2 )
  n: (e, t) => Number(
    new DataView(e).getBigInt64(0, t)
  ),
  //  ssize_t 	integer 	(3 )
  N: (e, t) => Number(
    new DataView(e).getBigUint64(0, t)
  ),
  //  size_t 	integer 	(3 )
  // "e":(data:ArrayBufferLike)=>{return new DataView(to_arraybuffer(data)).getFloat16(0)}, //  (6 ) float 	2 	(4 )
  f: (e, t) => new DataView(e).getFloat32(0, t),
  //  float 	float 	4 	(4 )
  d: (e, t) => new DataView(e).getFloat64(0, t),
  //  double 	float 	8 	(4 )
  s: (e, t) => new TextDecoder().decode(e),
  //  char[] 	bytes 	(9 )
  p: (e, t) => new TextDecoder().decode(e),
  //  char[] 	bytes 	(8 )
  P: (e, t) => Number(
    new DataView(e).getBigUint64(0, t)
  )
  //  void* 	int
};
class gH extends Nl {
  constructor({ data: t, mime: n }) {
    super({ data: KE(t), mime: n }), this._cType = n.split("application/fn.struct.")[1], this._value = null, this.parse_value();
  }
  parse_value() {
    let t = !0, n = this._cType;
    return n.startsWith("<") && (t = !0, n = n.slice(1)), n.startsWith(">") && (t = !1, n = n.slice(1)), n.startsWith("!") && (t = !1, n = n.slice(1)), n.startsWith("@") && (t = !1, n = n.slice(1)), n.startsWith("=") && (t = !1, n = n.slice(1)), this._value = wge[n](this.data, t), this._value;
  }
  get value() {
    return this._value;
  }
  toString() {
    return this._value === null ? "null" : this._value.toString();
  }
}
class vd extends Nl {
  constructor({ data: t, mime: n }) {
    const r = KE(t);
    super({ data: r, mime: n }), r.byteLength === 0 ? this._json = void 0 : (this._json = JSON.parse(new TextDecoder().decode(r)), this._json === "<NoValue>" && (this._json = void 0));
  }
  get value() {
    return this._json;
  }
  static fromObject(t) {
    const n = t === "<NoValue>" ? new Uint8Array(0) : new TextEncoder().encode(JSON.stringify(t));
    return new vd({ data: n, mime: "application/json" });
  }
  toString() {
    return typeof this._json == "string" ? this._json : JSON.stringify(this._json);
  }
}
class vH extends Nl {
  constructor({ data: t, mime: n }) {
    const r = KE(t);
    super({ data: r, mime: n }), this._value = new TextDecoder().decode(r);
  }
  get value() {
    return this._value;
  }
  toString() {
    return this._value;
  }
}
const yH = ({
  data: e,
  mime: t
}) => {
  const n = typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer;
  return e instanceof ArrayBuffer || ArrayBuffer.isView(e) || n ? t.startsWith("application/fn.struct.") ? new gH({ data: e, mime: t }) : t.startsWith("application/json") ? new vd({ data: e, mime: t }) : t === "text" || t.startsWith("text/") ? new vH({ data: e, mime: t }) : new hH({ data: e, mime: t }) : new Nl({ data: e, mime: t });
};
class xge extends Xc {
  constructor(t) {
    super(t), this.CHUNK_TIMEOUT = 1e4, this._unique_cmd_outs = {}, this.blobChunks = {}, this.cleanupChunks = () => {
      const n = Date.now();
      for (const r in this.blobChunks)
        n - this.blobChunks[r].timestamp > this.CHUNK_TIMEOUT && delete this.blobChunks[r];
    }, this.messagePromises = /* @__PURE__ */ new Map();
  }
  start() {
    this._chunk_cleanup_timer = setInterval(
      this.cleanupChunks.bind(this),
      this.CHUNK_TIMEOUT / 2
    );
  }
  stop() {
    this._chunk_cleanup_timer && clearInterval(this._chunk_cleanup_timer);
  }
  send(t) {
    this.context.worker.send(t);
  }
  async _send_cmd({
    cmd: t,
    kwargs: n,
    as_bytes: r = !1,
    wait_for_response: a = !0,
    response_timeout: s = 5e3,
    retries: l = 2,
    unique: c = !1
  }) {
    const d = {
      type: "cmd",
      as_bytes: r,
      cmd: t,
      kwargs: n || {}
    };
    if (await new Promise(async (f) => {
      if (this.context.worker.is_responsive) return f();
      const m = setInterval(() => {
        this.context.worker.is_responsive && (clearInterval(m), f());
      }, 100);
    }), a) {
      if (c && this._unique_cmd_outs[d.cmd] !== void 0)
        return this._unique_cmd_outs[d.cmd];
      l < 0 && (l = 0);
      const f = (async () => {
        let m;
        for (; l >= 0; ) {
          const h = d.id || J4();
          d.id = h;
          const v = new Promise((g, b) => {
            const x = setTimeout(() => {
              b("Timeout@wait_for_response for " + t);
            }, s);
            this.messagePromises.set(h, {
              resolve: (w) => {
                clearTimeout(x), g(w), this.messagePromises.delete(h);
              },
              reject: (w) => {
                clearTimeout(x), b(w), this.messagePromises.delete(h);
              }
            });
          });
          await this.send(d);
          try {
            m = await v;
            break;
          } catch (g) {
            if (l === 0)
              throw delete this._unique_cmd_outs[d.cmd], g;
            l -= 1;
            continue;
          }
        }
        return delete this._unique_cmd_outs[d.cmd], m;
      })();
      return c && (this._unique_cmd_outs[d.cmd] = f), f;
    }
    return this.send(d);
  }
  async receive(t) {
    let n;
    switch (this.connectionHealthManager.receivePong(), t.type) {
      case "pong":
        return this.connectionHealthManager.receivePong();
      case "nsevent":
        return await this.context.worker.getEventManager().receive_nodespace_event(t);
      case "result":
        if (n = t.id && this.messagePromises.get(t.id), n)
          return n.resolve(t.result);
        break;
      case "error":
        if (this.context.worker.on_error(t.tb + `
` + t.error), n = t.id && this.messagePromises.get(t.id), n)
          return n.reject(t.error);
        break;
      case "progress":
        if (!this.context.worker._zustand) return;
        this.context.worker._zustand.set_progress(t);
        break;
      case "workerevent":
        return await this.context.worker.getEventManager().receive_workerevent(t);
      case "large_message":
        return await this.context.worker.handle_large_message_hint(t);
      default:
        console.warn("Unhandled message", t);
        break;
    }
  }
  async receive_bytes(t, n) {
    const { type: r } = t;
    if (r === "io_value") {
      if (!this.context.worker._zustand) return;
      const { node: a, io: s, preview: l, mime: c } = t, d = l ? "value" : "fullvalue";
      (!a || !s) && console.error("Invalid io_value message", t);
      const f = yH({
        data: n,
        mime: c || "application/octet-stream"
      });
      this.context.worker._zustand.on_node_action({
        type: "update",
        node: {
          id: a,
          io: {
            [s]: {
              [d]: f
            }
          }
        },
        id: a,
        from_remote: !0
      });
    } else if (r == "result") {
      const a = t.id && this.messagePromises.get(t.id);
      a && a.resolve({ bytes: n, header: t });
    } else
      console.warn("Unhandled bytes message", t);
  }
  async onbytes(t) {
    try {
      const n = new TextDecoder("utf-8").decode(t), r = n.indexOf(`\r
\r
`);
      if (r === -1) {
        console.error(`Header terminator not found for:
`, n);
        return;
      }
      const a = n.substring(0, r + 4), s = t.slice(r + 4), l = a.split(";"), c = {};
      if (l.forEach((h) => {
        const [v, g] = h.split("=");
        c[v.trim()] = g.trim();
      }), !c.chunk || !c.msgid) {
        console.error(
          "Header missing required fields chunk or msgid",
          c
        );
        return;
      }
      const [d, f] = c.chunk.split("/"), m = c.msgid;
      if (d === "1" && f === "1")
        return this.receive_bytes(c, s);
      if (this.blobChunks[m] || (this.blobChunks[m] = {
        chunks: Array.from({ length: parseInt(f) }, () => null),
        timestamp: Date.now()
      }), this.blobChunks[m].chunks.length !== parseInt(f)) {
        console.error("Total chunks mismatch");
        return;
      }
      if (this.blobChunks[m].chunks[parseInt(d) - 1] = t, this.blobChunks[m].chunks.every((h) => h !== null)) {
        const h = new Uint8Array(
          this.blobChunks[m].chunks.reduce((v, g) => v.concat(Array.from(g)), [])
        );
        this.receive_bytes(c, h), delete this.blobChunks[m];
      }
    } catch (n) {
      console.error("Websocketworker: onbytes error", n, t);
      return;
    }
  }
}
class Sge extends Xc {
  constructor() {
    super(...arguments), this._ns_event_intercepts = /* @__PURE__ */ new Map();
  }
  start() {
  }
  stop() {
  }
  async _receive_edge_added(t, n, r, a) {
    this.context.worker._zustand && this.context.worker._zustand.on_edge_action({
      type: "add",
      from_remote: !0,
      src_nid: t,
      src_ioid: n,
      trg_nid: r,
      trg_ioid: a
    });
  }
  async _receive_groups(t) {
    this.context.worker._zustand && this.context.worker._zustand.on_group_action({
      type: "set",
      groups: t
    });
  }
  async _receive_node_added(t) {
    if (this.context.worker._zustand)
      return this.context.worker._zustand.on_node_action({
        type: "add",
        node: t,
        id: t.id,
        from_remote: !0
      });
  }
  async receive_workerevent({ event: t, data: n }) {
    switch (t) {
      case "worker_error":
        return this.context.worker._zustand ? this.context.worker._zustand.logger.error(n.error) : void 0;
      case "update_worker_dependencies":
        return this.context.worker._zustand ? this.context.worker._zustand.lib.libstate.getState().set({
          external_worker: n.worker_dependencies
        }) : void 0;
      case "lib_update":
        await this.context.worker.getSyncManager().sync_lib();
        return;
      case "fullsync":
        await this.context.worker.getSyncManager().stepwise_fullsync();
        return;
      case "external_worker_update":
        await this.context.worker.getSyncManager().sync_lib(), await this.context.worker.getSyncManager().sync_external_worker();
        return;
      case "repos_update":
        await this.hookManager.call_hooks(
          "repos_update",
          n.repos ?? n
        );
        return;
      case "starting":
        this.hookManager.call_hooks("starting");
        return;
      case "stopping":
        this.hookManager.call_hooks("stopping");
        return;
      default:
        console.warn("Unhandled worker event", t, n);
        break;
    }
  }
  async intercept_ns_event(t) {
    let n = t;
    for (const r of this._ns_event_intercepts.get(t.event) || [])
      n = await r(n);
    return n;
  }
  async receive_nodespace_event(t) {
    const { event: n, data: r } = await this.intercept_ns_event(t);
    switch (n) {
      case "after_set_value":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            io: {
              [r.io]: {
                value: r.result
              }
            }
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "after_update_value_options":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            io: {
              [r.io]: {
                value_options: r.result
              }
            }
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerstart":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !0
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerdone":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !1
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerfast":
        if (!this.context.worker._zustand) return;
        this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !0
          },
          id: r.node,
          from_remote: !0
        }), setTimeout(() => {
          this.context.worker._zustand && this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              in_trigger: !1
            },
            id: r.node,
            from_remote: !0
          });
        }, 50);
        return;
      case "node_trigger_error":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "error",
          errortype: "trigger",
          error: r.error,
          id: r.node,
          tb: r.tb,
          from_remote: !0
        }) : void 0;
      case "node_removed":
        if (!this.context.worker._zustand) return;
        this.context.worker._zustand.on_node_action({
          type: "delete",
          id: r.node,
          from_remote: !0
        }), this.hookManager.call_hooks("node_removed", {
          node: r.node
        });
        return;
      case "node_added":
        this._receive_node_added(r.node);
        return;
      case "after_disconnect":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.on_edge_action({
          type: "delete",
          from_remote: !0,
          src_nid: r.result[0],
          src_ioid: r.result[1],
          trg_nid: r.result[2],
          trg_ioid: r.result[3]
        });
      case "after_unforward":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.on_edge_action({
          type: "delete",
          from_remote: !0,
          src_nid: r.result[0],
          src_ioid: r.result[1],
          trg_nid: r.result[2],
          trg_ioid: r.result[3]
        });
      case "after_connect":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
          ...r.result
        );
      case "after_forward":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
          ...r.result
        );
      case "after_add_shelf":
        return !r.result || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.lib.libstate.getState().set({
          lib: r.result
        });
      case "after_remove_shelf":
        return !r.result || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.lib.libstate.getState().set({
          lib: r.result
        });
      case "progress":
        if (!this.context.worker._zustand) return;
        if (r.node)
          return this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              progress: r.info
            },
            id: r.node,
            from_remote: !0
          });
        console.warn("Unhandled nodepsace event", n, r);
        break;
      default:
        if (["after_set_nodespace"].includes(n)) return;
        console.warn("Unhandled nodepsace event", n, r);
        break;
    }
  }
  add_ns_event_intercept(t, n) {
    const r = this._ns_event_intercepts.get(t) || [];
    return r.push(n), this._ns_event_intercepts.set(t, r), () => {
      const a = this._ns_event_intercepts.get(t) || [], s = a.indexOf(n);
      s >= 0 && a.splice(s, 1);
    };
  }
}
class kge extends Xc {
  constructor() {
    super(...arguments), this._hooks = /* @__PURE__ */ new Map();
  }
  start() {
  }
  stop() {
  }
  add_hook(t, n) {
    const r = this._hooks.get(t) || [];
    return r.push(n), this._hooks.set(t, r), () => {
      const a = this._hooks.get(t) || [], s = a.indexOf(n);
      s >= 0 && a.splice(s, 1);
    };
  }
  async call_hooks(t, n) {
    const r = [];
    for (const a of this._hooks.get(t) || []) {
      const s = a({ worker: this.context.worker, data: n });
      s instanceof Promise && r.push(s);
    }
    await Promise.all(r);
  }
}
class _ge extends Xc {
  start() {
  }
  stop() {
  }
  async trigger_node(t) {
    await this.communicationManager._send_cmd({
      cmd: "trigger_node",
      kwargs: { nid: t },
      wait_for_response: !1
    });
  }
  async add_node(t) {
    const n = await this.communicationManager._send_cmd({
      cmd: "add_node",
      kwargs: { id: t }
    });
    return this.eventManager._receive_node_added(n);
  }
  async remove_node(t) {
    await this.communicationManager._send_cmd({
      cmd: "remove_node",
      kwargs: { id: t }
    });
  }
  locally_update_node(t) {
    this.syncManager.locally_update_node(t);
  }
  set_io_value({
    nid: t,
    ioid: n,
    value: r,
    set_default: a = !1
  }) {
    return this.communicationManager._send_cmd({
      cmd: "set_io_value",
      kwargs: { nid: t, ioid: n, value: r, set_default: a },
      wait_for_response: !0
    });
  }
  set_io_value_options({
    nid: t,
    ioid: n,
    values: r,
    keys: a,
    nullable: s
  }) {
    return this.communicationManager._send_cmd({
      cmd: "update_io_value_options",
      kwargs: {
        nid: t,
        ioid: n,
        options: {
          options: {
            type: "enum",
            values: r,
            keys: a,
            nullable: s
          }
        }
      }
    });
  }
  async get_io_value({ nid: t, ioid: n }) {
    const r = await this.communicationManager._send_cmd({
      cmd: "get_io_value",
      kwargs: { nid: t, ioid: n },
      wait_for_response: !0
    });
    return this.context.worker._zustand && this.context.worker._zustand.on_node_action({
      type: "update",
      node: {
        io: {
          [n]: {
            value: r
          }
        }
      },
      id: t,
      from_remote: !0
    }), r;
  }
  async get_ios_values({ nid: t }) {
    const n = await this.communicationManager._send_cmd({
      cmd: "get_ios_values",
      kwargs: { nid: t },
      wait_for_response: !0
    });
    if (!this.context.worker._zustand) return n;
    const r = {};
    for (const a in n)
      r[a] = { value: n[a] };
    return this.context.worker._zustand.on_node_action({
      type: "update",
      node: {
        io: r
      },
      id: t,
      from_remote: !0
    }), n;
  }
  async get_io_full_value({ nid: t, ioid: n }) {
    const r = await this.communicationManager._send_cmd({
      cmd: "get_io_full_value",
      kwargs: { nid: t, ioid: n },
      wait_for_response: !0,
      as_bytes: !0
    }), { header: a, bytes: s } = r, { mime: l } = a, c = yH({
      data: s,
      mime: l || "application/octet-stream"
    });
    return this.context.worker._zustand?.on_node_action?.({
      type: "update",
      node: {
        id: t,
        io: {
          [n]: {
            fullvalue: c
          }
        }
      },
      id: t,
      from_remote: !0
    }), c;
  }
  async update_io_options({
    nid: t,
    ioid: n,
    options: r
  }) {
    const a = await this.communicationManager._send_cmd({
      cmd: "update_io_options",
      kwargs: { nid: t, ioid: n, ...r },
      wait_for_response: !0
    });
    if (!this.context.worker._zustand) return a;
    this.context.worker._zustand.on_node_action({
      type: "update",
      node: {
        io: {
          [n]: {
            ...r
          }
        }
      },
      id: t,
      from_remote: !0
    });
  }
  async get_node_status(t) {
    return await this.communicationManager._send_cmd({
      cmd: "get_node_state",
      kwargs: { nid: t },
      wait_for_response: !0
    });
  }
  async get_remote_node_state(t) {
    const n = await this.communicationManager._send_cmd({
      cmd: "get_node_state",
      kwargs: { nid: t },
      wait_for_response: !0
    });
    this.context.worker._zustand && this.context.worker._zustand.on_node_action({
      type: "update",
      node: n,
      id: n.id,
      from_remote: !0
    });
  }
}
class Ege extends Xc {
  start() {
  }
  stop() {
  }
  add_edge({
    src_nid: t,
    src_ioid: n,
    trg_nid: r,
    trg_ioid: a,
    replace: s = !1
  }) {
    return this.communicationManager._send_cmd({
      cmd: "add_edge",
      kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: a, replace: s }
    });
  }
  remove_edge({
    src_nid: t,
    src_ioid: n,
    trg_nid: r,
    trg_ioid: a
  }) {
    return this.communicationManager._send_cmd({
      cmd: "remove_edge",
      kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: a }
    });
  }
}
class Cge extends Xc {
  start() {
  }
  stop() {
  }
  async group_nodes(t, n) {
    const r = await this.communicationManager._send_cmd({
      cmd: "group_nodes",
      kwargs: { node_ids: t, group_ids: n },
      wait_for_response: !0
    });
    return this.eventManager._receive_groups(r), r;
  }
  async remove_group(t) {
    await this.communicationManager._send_cmd({
      cmd: "remove_group",
      kwargs: { gid: t },
      wait_for_response: !0
    }), await this.syncManager.sync_nodespace();
  }
  locally_update_group(t) {
    this.syncManager.locally_update_group(t);
  }
}
class Oge extends Xc {
  constructor() {
    super(...arguments), this._available_modules_cache = {
      installed: [],
      available: [],
      active: []
    };
  }
  start() {
  }
  stop() {
  }
  async add_external_worker({
    module: t,
    cls_module: n,
    cls_name: r
  }) {
    return await this.communicationManager._send_cmd({
      cmd: "add_external_worker",
      kwargs: { module: t, cls_module: n, cls_name: r }
    });
  }
  async add_lib(t, n) {
    return await this.communicationManager._send_cmd({
      cmd: "add_package_dependency",
      kwargs: { name: t, version: n },
      wait_for_response: !1
    });
  }
  async remove_lib(t) {
    return await this.communicationManager._send_cmd({
      cmd: "remove_package_dependency",
      kwargs: { name: t },
      wait_for_response: !1
    });
  }
  async get_available_modules({
    wait_for_response: t = !1,
    on_load: n
  }) {
    const r = this.communicationManager._send_cmd({
      cmd: "get_available_modules",
      wait_for_response: !0,
      unique: !0
    }).then((a) => {
      this._available_modules_cache = a, n && n(this._available_modules_cache);
    });
    return t && await r, this._available_modules_cache;
  }
  async remove_external_worker(t, n) {
    return await this.communicationManager._send_cmd({
      cmd: "remove_external_worker",
      kwargs: { worker_id: t, class_id: n },
      wait_for_response: !0
    });
  }
  async get_external_worker_config(t, n) {
    return await this.communicationManager._send_cmd({
      cmd: "get_external_worker_config",
      kwargs: { worker_id: t, class_id: n },
      wait_for_response: !0
    });
  }
}
class Q4 {
  // Public getter for handlers to access eventManager
  getEventManager() {
    return this._eventManager;
  }
  getSyncManager() {
    return this._syncManager;
  }
  getCommunicationManager() {
    return this._communicationManager;
  }
  getConnectionHealthManager() {
    return this._connectionhealthManager;
  }
  getHookManager() {
    return this._hookManager;
  }
  getNodeManager() {
    return this._nodeManager;
  }
  getEdgeManager() {
    return this._edgeManager;
  }
  getGroupManager() {
    return this._groupManager;
  }
  getLibraryManager() {
    return this._libraryManager;
  }
  constructor(t) {
    this.uuid = t.uuid, this.on_error = t.on_error || ((r) => {
      this._zustand?.logger.error(r);
    }), this.state = Hi((r, a) => ({
      is_open: !1
    }));
    const n = { worker: this };
    this._connectionhealthManager = new yge(
      n
    ), this._communicationManager = new xge(n), this._eventManager = new Sge({
      ...n
    }), this._syncManager = new bge({
      ...n,
      on_sync_complete: t.on_sync_complete
    }), this._hookManager = new kge(n), this._nodeManager = new _ge(n), this._edgeManager = new Ege(n), this._groupManager = new Cge(n), this._libraryManager = new Oge(n), this._communicationManager.start(), this._connectionhealthManager.start(), this._syncManager.start(), this._eventManager.start(), this._hookManager.start(), this._nodeManager.start(), this._edgeManager.start(), this._groupManager.start(), this._libraryManager.start(), t.zustand && this.set_zustand(t.zustand), this.api = {
      node: this._nodeManager,
      group: this._groupManager,
      edge: this._edgeManager,
      hooks: this._hookManager,
      lib: this._libraryManager
    };
  }
  set_zustand(t) {
    t !== this._zustand && (t.logger.debug("Setting zustand for worker"), this._zustand = t, t.set_worker(this), this._zustand.auto_progress(), this._syncManager.stepwise_fullsync());
  }
  get is_open() {
    return this.state.getState().is_open;
  }
  set is_open(t) {
    this.state.setState({ is_open: t });
  }
  get is_responsive() {
    return this._connectionhealthManager.isResponsive();
  }
  clear() {
    return this._communicationManager._send_cmd({ cmd: "clear", unique: !0 });
  }
  save() {
    return this._communicationManager._send_cmd({
      cmd: "save",
      wait_for_response: !0,
      unique: !0
    });
  }
  load(t) {
    return this._communicationManager._send_cmd({
      cmd: "load_data",
      kwargs: { data: t },
      wait_for_response: !0
    }).then(() => {
      this._syncManager.stepwise_fullsync();
    });
  }
  async get_runstate() {
    return await this._communicationManager._send_cmd({
      cmd: "get_runstate",
      wait_for_response: !0,
      unique: !0
    });
  }
  async send(t) {
    throw new Error("async send(data: any)  not implemented");
  }
  async upload_file(t) {
    throw new Error("upload_file not implemented ");
  }
  async handle_large_message_hint({}) {
    throw new Error(
      "async handle_large_message_hint({}: LargeMessageHint) not implemented "
    );
  }
  disconnect() {
  }
  onclose() {
    this.is_open = !1, this._zustand && this._zustand.auto_progress();
  }
  async reconnect() {
  }
  async stop() {
    window.localStorage.getItem("funcnodes__active_worker") == this.uuid && window.localStorage.removeItem("funcnodes__active_worker"), await this._communicationManager._send_cmd({
      cmd: "stop_worker",
      wait_for_response: !1
    });
    const t = this.onclose.bind(this);
    this.onclose = () => {
      t(), this._zustand && (this._zustand.worker === this && this._zustand.clear_all(), this.onclose = t);
    };
  }
  async update_external_worker(t, n, r) {
    return await this._communicationManager._send_cmd({
      cmd: "update_external_worker",
      kwargs: { worker_id: t, class_id: n, ...r },
      wait_for_response: !0
    });
  }
  async export({ withFiles: t = !1 }) {
    return await this._communicationManager._send_cmd({
      cmd: "export_worker",
      wait_for_response: !0,
      kwargs: { with_files: t }
    });
  }
  async update_from_export(t) {
    const n = this._hookManager.add_hook("node_added", async ({}) => {
      this._zustand?.center_all();
    });
    try {
      const r = await this._communicationManager._send_cmd({
        cmd: "update_from_export",
        kwargs: { data: t },
        wait_for_response: !0,
        response_timeout: 6e5,
        // 10 minutes
        unique: !0
      });
      return await new Promise((a) => {
        setTimeout(() => {
          a();
        }, 1e3);
      }), await this._syncManager.stepwise_fullsync(), r;
    } finally {
      n();
    }
  }
  /**
   * @deprecated This method is deprecated. Use the API or getCommunicationManager()._send_cmd directly instead.
   */
  _send_cmd(t) {
    return this._communicationManager._send_cmd(t);
  }
  /**
   * @deprecated This method is deprecated. Use the API or getNodeManager().set_io_value directly instead.
   */
  set_io_value(t) {
    return this._nodeManager.set_io_value(t);
  }
  /**
   * @deprecated This method is deprecated. Use the API or getNodeManager().get_io_value directly instead.
   */
  get_io_value(t) {
    return this._nodeManager.get_io_value(t);
  }
}
function bH(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: Mge } = Object.prototype, { getPrototypeOf: Z4 } = Object, { iterator: YE, toStringTag: wH } = Symbol, XE = /* @__PURE__ */ ((e) => (t) => {
  const n = Mge.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), sl = (e) => (e = e.toLowerCase(), (t) => XE(t) === e), JE = (e) => (t) => typeof t === e, { isArray: Ug } = Array, yg = JE("undefined");
function ik(e) {
  return e !== null && !yg(e) && e.constructor !== null && !yg(e.constructor) && Pa(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const xH = sl("ArrayBuffer");
function Nge(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && xH(e.buffer), t;
}
const Age = JE("string"), Pa = JE("function"), SH = JE("number"), sk = (e) => e !== null && typeof e == "object", Rge = (e) => e === !0 || e === !1, I_ = (e) => {
  if (XE(e) !== "object")
    return !1;
  const t = Z4(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(wH in e) && !(YE in e);
}, jge = (e) => {
  if (!sk(e) || ik(e))
    return !1;
  try {
    return Object.keys(e).length === 0 && Object.getPrototypeOf(e) === Object.prototype;
  } catch {
    return !1;
  }
}, Pge = sl("Date"), Dge = sl("File"), Ige = sl("Blob"), $ge = sl("FileList"), zge = (e) => sk(e) && Pa(e.pipe), Tge = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || Pa(e.append) && ((t = XE(e)) === "formdata" || // detect form-data instance
  t === "object" && Pa(e.toString) && e.toString() === "[object FormData]"));
}, Lge = sl("URLSearchParams"), [Fge, Bge, Uge, Vge] = ["ReadableStream", "Request", "Response", "Headers"].map(sl), Hge = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function lk(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, a;
  if (typeof e != "object" && (e = [e]), Ug(e))
    for (r = 0, a = e.length; r < a; r++)
      t.call(null, e[r], r, e);
  else {
    if (ik(e))
      return;
    const s = n ? Object.getOwnPropertyNames(e) : Object.keys(e), l = s.length;
    let c;
    for (r = 0; r < l; r++)
      c = s[r], t.call(null, e[c], c, e);
  }
}
function kH(e, t) {
  if (ik(e))
    return null;
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, a;
  for (; r-- > 0; )
    if (a = n[r], t === a.toLowerCase())
      return a;
  return null;
}
const Om = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : km, _H = (e) => !yg(e) && e !== Om;
function h3() {
  const { caseless: e, skipUndefined: t } = _H(this) && this || {}, n = {}, r = (a, s) => {
    const l = e && kH(n, s) || s;
    I_(n[l]) && I_(a) ? n[l] = h3(n[l], a) : I_(a) ? n[l] = h3({}, a) : Ug(a) ? n[l] = a.slice() : (!t || !yg(a)) && (n[l] = a);
  };
  for (let a = 0, s = arguments.length; a < s; a++)
    arguments[a] && lk(arguments[a], r);
  return n;
}
const Wge = (e, t, n, { allOwnKeys: r } = {}) => (lk(t, (a, s) => {
  n && Pa(a) ? e[s] = bH(a, n) : e[s] = a;
}, { allOwnKeys: r }), e), qge = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), Gge = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, Kge = (e, t, n, r) => {
  let a, s, l;
  const c = {};
  if (t = t || {}, e == null) return t;
  do {
    for (a = Object.getOwnPropertyNames(e), s = a.length; s-- > 0; )
      l = a[s], (!r || r(l, e, t)) && !c[l] && (t[l] = e[l], c[l] = !0);
    e = n !== !1 && Z4(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, Yge = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, Xge = (e) => {
  if (!e) return null;
  if (Ug(e)) return e;
  let t = e.length;
  if (!SH(t)) return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, Jge = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && Z4(Uint8Array)), Qge = (e, t) => {
  const n = (e && e[YE]).call(e);
  let r;
  for (; (r = n.next()) && !r.done; ) {
    const a = r.value;
    t.call(e, a[0], a[1]);
  }
}, Zge = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, eve = sl("HTMLFormElement"), tve = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(t, n, r) {
    return n.toUpperCase() + r;
  }
), I$ = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), nve = sl("RegExp"), EH = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  lk(n, (a, s) => {
    let l;
    (l = t(a, s, e)) !== !1 && (r[s] = l || a);
  }), Object.defineProperties(e, r);
}, rve = (e) => {
  EH(e, (t, n) => {
    if (Pa(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (Pa(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, ove = (e, t) => {
  const n = {}, r = (a) => {
    a.forEach((s) => {
      n[s] = !0;
    });
  };
  return Ug(e) ? r(e) : r(String(e).split(t)), n;
}, ave = () => {
}, ive = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
function sve(e) {
  return !!(e && Pa(e.append) && e[wH] === "FormData" && e[YE]);
}
const lve = (e) => {
  const t = new Array(10), n = (r, a) => {
    if (sk(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (ik(r))
        return r;
      if (!("toJSON" in r)) {
        t[a] = r;
        const s = Ug(r) ? [] : {};
        return lk(r, (l, c) => {
          const d = n(l, a + 1);
          !yg(d) && (s[c] = d);
        }), t[a] = void 0, s;
      }
    }
    return r;
  };
  return n(e, 0);
}, uve = sl("AsyncFunction"), cve = (e) => e && (sk(e) || Pa(e)) && Pa(e.then) && Pa(e.catch), CH = ((e, t) => e ? setImmediate : t ? ((n, r) => (Om.addEventListener("message", ({ source: a, data: s }) => {
  a === Om && s === n && r.length && r.shift()();
}, !1), (a) => {
  r.push(a), Om.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  Pa(Om.postMessage)
), dve = typeof queueMicrotask < "u" ? queueMicrotask.bind(Om) : typeof process < "u" && process.nextTick || CH, fve = (e) => e != null && Pa(e[YE]), be = {
  isArray: Ug,
  isArrayBuffer: xH,
  isBuffer: ik,
  isFormData: Tge,
  isArrayBufferView: Nge,
  isString: Age,
  isNumber: SH,
  isBoolean: Rge,
  isObject: sk,
  isPlainObject: I_,
  isEmptyObject: jge,
  isReadableStream: Fge,
  isRequest: Bge,
  isResponse: Uge,
  isHeaders: Vge,
  isUndefined: yg,
  isDate: Pge,
  isFile: Dge,
  isBlob: Ige,
  isRegExp: nve,
  isFunction: Pa,
  isStream: zge,
  isURLSearchParams: Lge,
  isTypedArray: Jge,
  isFileList: $ge,
  forEach: lk,
  merge: h3,
  extend: Wge,
  trim: Hge,
  stripBOM: qge,
  inherits: Gge,
  toFlatObject: Kge,
  kindOf: XE,
  kindOfTest: sl,
  endsWith: Yge,
  toArray: Xge,
  forEachEntry: Qge,
  matchAll: Zge,
  isHTMLForm: eve,
  hasOwnProperty: I$,
  hasOwnProp: I$,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: EH,
  freezeMethods: rve,
  toObjectSet: ove,
  toCamelCase: tve,
  noop: ave,
  toFiniteNumber: ive,
  findKey: kH,
  global: Om,
  isContextDefined: _H,
  isSpecCompliantForm: sve,
  toJSONObject: lve,
  isAsyncFn: uve,
  isThenable: cve,
  setImmediate: CH,
  asap: dve,
  isIterable: fve
};
function Pt(e, t, n, r, a) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), a && (this.response = a, this.status = a.status ? a.status : null);
}
be.inherits(Pt, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: be.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const OH = Pt.prototype, MH = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  MH[e] = { value: e };
});
Object.defineProperties(Pt, MH);
Object.defineProperty(OH, "isAxiosError", { value: !0 });
Pt.from = (e, t, n, r, a, s) => {
  const l = Object.create(OH);
  be.toFlatObject(e, l, function(f) {
    return f !== Error.prototype;
  }, (f) => f !== "isAxiosError");
  const c = e && e.message ? e.message : "Error", d = t == null && e ? e.code : t;
  return Pt.call(l, c, d, n, r, a), e && l.cause == null && Object.defineProperty(l, "cause", { value: e, configurable: !0 }), l.name = e && e.name || "Error", s && Object.assign(l, s), l;
};
const pve = null;
function g3(e) {
  return be.isPlainObject(e) || be.isArray(e);
}
function NH(e) {
  return be.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function $$(e, t, n) {
  return e ? e.concat(t).map(function(r, a) {
    return r = NH(r), !n && a ? "[" + r + "]" : r;
  }).join(n ? "." : "") : t;
}
function mve(e) {
  return be.isArray(e) && !e.some(g3);
}
const hve = be.toFlatObject(be, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function QE(e, t, n) {
  if (!be.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = be.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(g, b) {
    return !be.isUndefined(b[g]);
  });
  const r = n.metaTokens, a = n.visitor || f, s = n.dots, l = n.indexes, c = (n.Blob || typeof Blob < "u" && Blob) && be.isSpecCompliantForm(t);
  if (!be.isFunction(a))
    throw new TypeError("visitor must be a function");
  function d(g) {
    if (g === null) return "";
    if (be.isDate(g))
      return g.toISOString();
    if (be.isBoolean(g))
      return g.toString();
    if (!c && be.isBlob(g))
      throw new Pt("Blob is not supported. Use a Buffer instead.");
    return be.isArrayBuffer(g) || be.isTypedArray(g) ? c && typeof Blob == "function" ? new Blob([g]) : Buffer.from(g) : g;
  }
  function f(g, b, x) {
    let w = g;
    if (g && !x && typeof g == "object") {
      if (be.endsWith(b, "{}"))
        b = r ? b : b.slice(0, -2), g = JSON.stringify(g);
      else if (be.isArray(g) && mve(g) || (be.isFileList(g) || be.endsWith(b, "[]")) && (w = be.toArray(g)))
        return b = NH(b), w.forEach(function(k, E) {
          !(be.isUndefined(k) || k === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            l === !0 ? $$([b], E, s) : l === null ? b : b + "[]",
            d(k)
          );
        }), !1;
    }
    return g3(g) ? !0 : (t.append($$(x, b, s), d(g)), !1);
  }
  const m = [], h = Object.assign(hve, {
    defaultVisitor: f,
    convertValue: d,
    isVisitable: g3
  });
  function v(g, b) {
    if (!be.isUndefined(g)) {
      if (m.indexOf(g) !== -1)
        throw Error("Circular reference detected in " + b.join("."));
      m.push(g), be.forEach(g, function(x, w) {
        (!(be.isUndefined(x) || x === null) && a.call(
          t,
          x,
          be.isString(w) ? w.trim() : w,
          b,
          h
        )) === !0 && v(x, b ? b.concat(w) : [w]);
      }), m.pop();
    }
  }
  if (!be.isObject(e))
    throw new TypeError("data must be an object");
  return v(e), t;
}
function z$(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(n) {
    return t[n];
  });
}
function ej(e, t) {
  this._pairs = [], e && QE(e, this, t);
}
const AH = ej.prototype;
AH.append = function(e, t) {
  this._pairs.push([e, t]);
};
AH.toString = function(e) {
  const t = e ? function(n) {
    return e.call(this, n, z$);
  } : z$;
  return this._pairs.map(function(n) {
    return t(n[0]) + "=" + t(n[1]);
  }, "").join("&");
};
function gve(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function RH(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || gve;
  be.isFunction(n) && (n = {
    serialize: n
  });
  const a = n && n.serialize;
  let s;
  if (a ? s = a(t, n) : s = be.isURLSearchParams(t) ? t.toString() : new ej(t, n).toString(r), s) {
    const l = e.indexOf("#");
    l !== -1 && (e = e.slice(0, l)), e += (e.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return e;
}
class T$ {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {void}
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    be.forEach(this.handlers, function(n) {
      n !== null && t(n);
    });
  }
}
const jH = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, vve = typeof URLSearchParams < "u" ? URLSearchParams : ej, yve = typeof FormData < "u" ? FormData : null, bve = typeof Blob < "u" ? Blob : null, wve = {
  isBrowser: !0,
  classes: {
    URLSearchParams: vve,
    FormData: yve,
    Blob: bve
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, tj = typeof window < "u" && typeof document < "u", v3 = typeof navigator == "object" && navigator || void 0, xve = tj && (!v3 || ["ReactNative", "NativeScript", "NS"].indexOf(v3.product) < 0), Sve = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", kve = tj && window.location.href || "http://localhost", _ve = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: tj,
  hasStandardBrowserEnv: xve,
  hasStandardBrowserWebWorkerEnv: Sve,
  navigator: v3,
  origin: kve
}, Symbol.toStringTag, { value: "Module" })), Yo = {
  ..._ve,
  ...wve
};
function Eve(e, t) {
  return QE(e, new Yo.classes.URLSearchParams(), {
    visitor: function(n, r, a, s) {
      return Yo.isNode && be.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    },
    ...t
  });
}
function Cve(e) {
  return be.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function Ove(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const a = n.length;
  let s;
  for (r = 0; r < a; r++)
    s = n[r], t[s] = e[s];
  return t;
}
function PH(e) {
  function t(n, r, a, s) {
    let l = n[s++];
    if (l === "__proto__") return !0;
    const c = Number.isFinite(+l), d = s >= n.length;
    return l = !l && be.isArray(a) ? a.length : l, d ? (be.hasOwnProp(a, l) ? a[l] = [a[l], r] : a[l] = r, !c) : ((!a[l] || !be.isObject(a[l])) && (a[l] = []), t(n, r, a[l], s) && be.isArray(a[l]) && (a[l] = Ove(a[l])), !c);
  }
  if (be.isFormData(e) && be.isFunction(e.entries)) {
    const n = {};
    return be.forEachEntry(e, (r, a) => {
      t(Cve(r), a, n, 0);
    }), n;
  }
  return null;
}
function Mve(e, t, n) {
  if (be.isString(e))
    try {
      return (t || JSON.parse)(e), be.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const uk = {
  transitional: jH,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, t) {
    const n = t.getContentType() || "", r = n.indexOf("application/json") > -1, a = be.isObject(e);
    if (a && be.isHTMLForm(e) && (e = new FormData(e)), be.isFormData(e))
      return r ? JSON.stringify(PH(e)) : e;
    if (be.isArrayBuffer(e) || be.isBuffer(e) || be.isStream(e) || be.isFile(e) || be.isBlob(e) || be.isReadableStream(e))
      return e;
    if (be.isArrayBufferView(e))
      return e.buffer;
    if (be.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let s;
    if (a) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return Eve(e, this.formSerializer).toString();
      if ((s = be.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return QE(
          s ? { "files[]": e } : e,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return a || r ? (t.setContentType("application/json", !1), Mve(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || uk.transitional, n = t && t.forcedJSONParsing, r = this.responseType === "json";
    if (be.isResponse(e) || be.isReadableStream(e))
      return e;
    if (e && be.isString(e) && (n && !this.responseType || r)) {
      const a = !(t && t.silentJSONParsing) && r;
      try {
        return JSON.parse(e, this.parseReviver);
      } catch (s) {
        if (a)
          throw s.name === "SyntaxError" ? Pt.from(s, Pt.ERR_BAD_RESPONSE, this, null, this.response) : s;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Yo.classes.FormData,
    Blob: Yo.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
be.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  uk.headers[e] = {};
});
const Nve = be.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), Ave = (e) => {
  const t = {};
  let n, r, a;
  return e && e.split(`
`).forEach(function(s) {
    a = s.indexOf(":"), n = s.substring(0, a).trim().toLowerCase(), r = s.substring(a + 1).trim(), !(!n || t[n] && Nve[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, L$ = /* @__PURE__ */ Symbol("internals");
function Yw(e) {
  return e && String(e).trim().toLowerCase();
}
function $_(e) {
  return e === !1 || e == null ? e : be.isArray(e) ? e.map($_) : String(e);
}
function Rve(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
const jve = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function e5(e, t, n, r, a) {
  if (be.isFunction(r))
    return r.call(this, t, n);
  if (a && (t = n), !!be.isString(t)) {
    if (be.isString(r))
      return t.indexOf(r) !== -1;
    if (be.isRegExp(r))
      return r.test(t);
  }
}
function Pve(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function Dve(e, t) {
  const n = be.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(a, s, l) {
        return this[r].call(this, t, a, s, l);
      },
      configurable: !0
    });
  });
}
let Da = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, n) {
    const r = this;
    function a(l, c, d) {
      const f = Yw(c);
      if (!f)
        throw new Error("header name must be a non-empty string");
      const m = be.findKey(r, f);
      (!m || r[m] === void 0 || d === !0 || d === void 0 && r[m] !== !1) && (r[m || c] = $_(l));
    }
    const s = (l, c) => be.forEach(l, (d, f) => a(d, f, c));
    if (be.isPlainObject(e) || e instanceof this.constructor)
      s(e, t);
    else if (be.isString(e) && (e = e.trim()) && !jve(e))
      s(Ave(e), t);
    else if (be.isObject(e) && be.isIterable(e)) {
      let l = {}, c, d;
      for (const f of e) {
        if (!be.isArray(f))
          throw TypeError("Object iterator must return a key-value pair");
        l[d = f[0]] = (c = l[d]) ? be.isArray(c) ? [...c, f[1]] : [c, f[1]] : f[1];
      }
      s(l, t);
    } else
      e != null && a(t, e, n);
    return this;
  }
  get(e, t) {
    if (e = Yw(e), e) {
      const n = be.findKey(this, e);
      if (n) {
        const r = this[n];
        if (!t)
          return r;
        if (t === !0)
          return Rve(r);
        if (be.isFunction(t))
          return t.call(this, r, n);
        if (be.isRegExp(t))
          return t.exec(r);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (e = Yw(e), e) {
      const n = be.findKey(this, e);
      return !!(n && this[n] !== void 0 && (!t || e5(this, this[n], n, t)));
    }
    return !1;
  }
  delete(e, t) {
    const n = this;
    let r = !1;
    function a(s) {
      if (s = Yw(s), s) {
        const l = be.findKey(n, s);
        l && (!t || e5(n, n[l], l, t)) && (delete n[l], r = !0);
      }
    }
    return be.isArray(e) ? e.forEach(a) : a(e), r;
  }
  clear(e) {
    const t = Object.keys(this);
    let n = t.length, r = !1;
    for (; n--; ) {
      const a = t[n];
      (!e || e5(this, this[a], a, e, !0)) && (delete this[a], r = !0);
    }
    return r;
  }
  normalize(e) {
    const t = this, n = {};
    return be.forEach(this, (r, a) => {
      const s = be.findKey(n, a);
      if (s) {
        t[s] = $_(r), delete t[a];
        return;
      }
      const l = e ? Pve(a) : String(a).trim();
      l !== a && delete t[a], t[l] = $_(r), n[l] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return be.forEach(this, (n, r) => {
      n != null && n !== !1 && (t[r] = e && be.isArray(n) ? n.join(", ") : n);
    }), t;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...t) {
    const n = new this(e);
    return t.forEach((r) => n.set(r)), n;
  }
  static accessor(e) {
    const t = (this[L$] = this[L$] = {
      accessors: {}
    }).accessors, n = this.prototype;
    function r(a) {
      const s = Yw(a);
      t[s] || (Dve(n, a), t[s] = !0);
    }
    return be.isArray(e) ? e.forEach(r) : r(e), this;
  }
};
Da.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
be.reduceDescriptors(Da.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(r) {
      this[n] = r;
    }
  };
});
be.freezeMethods(Da);
function t5(e, t) {
  const n = this || uk, r = t || n, a = Da.from(r.headers);
  let s = r.data;
  return be.forEach(e, function(l) {
    s = l.call(n, s, a.normalize(), t ? t.status : void 0);
  }), a.normalize(), s;
}
function DH(e) {
  return !!(e && e.__CANCEL__);
}
function Vg(e, t, n) {
  Pt.call(this, e ?? "canceled", Pt.ERR_CANCELED, t, n), this.name = "CanceledError";
}
be.inherits(Vg, Pt, {
  __CANCEL__: !0
});
function IH(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new Pt(
    "Request failed with status code " + n.status,
    [Pt.ERR_BAD_REQUEST, Pt.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function Ive(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function $ve(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let a = 0, s = 0, l;
  return t = t !== void 0 ? t : 1e3, function(c) {
    const d = Date.now(), f = r[s];
    l || (l = d), n[a] = c, r[a] = d;
    let m = s, h = 0;
    for (; m !== a; )
      h += n[m++], m = m % e;
    if (a = (a + 1) % e, a === s && (s = (s + 1) % e), d - l < t)
      return;
    const v = f && d - f;
    return v ? Math.round(h * 1e3 / v) : void 0;
  };
}
function zve(e, t) {
  let n = 0, r = 1e3 / t, a, s;
  const l = (c, d = Date.now()) => {
    n = d, a = null, s && (clearTimeout(s), s = null), e(...c);
  };
  return [(...c) => {
    const d = Date.now(), f = d - n;
    f >= r ? l(c, d) : (a = c, s || (s = setTimeout(() => {
      s = null, l(a);
    }, r - f)));
  }, () => a && l(a)];
}
const _2 = (e, t, n = 3) => {
  let r = 0;
  const a = $ve(50, 250);
  return zve((s) => {
    const l = s.loaded, c = s.lengthComputable ? s.total : void 0, d = l - r, f = a(d), m = l <= c;
    r = l;
    const h = {
      loaded: l,
      total: c,
      progress: c ? l / c : void 0,
      bytes: d,
      rate: f || void 0,
      estimated: f && c && m ? (c - l) / f : void 0,
      event: s,
      lengthComputable: c != null,
      [t ? "download" : "upload"]: !0
    };
    e(h);
  }, n);
}, F$ = (e, t) => {
  const n = e != null;
  return [(r) => t[0]({
    lengthComputable: n,
    total: e,
    loaded: r
  }), t[1]];
}, B$ = (e) => (...t) => be.asap(() => e(...t)), Tve = Yo.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (n) => (n = new URL(n, Yo.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(
  new URL(Yo.origin),
  Yo.navigator && /(msie|trident)/i.test(Yo.navigator.userAgent)
) : () => !0, Lve = Yo.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, r, a, s, l) {
      if (typeof document > "u") return;
      const c = [`${e}=${encodeURIComponent(t)}`];
      be.isNumber(n) && c.push(`expires=${new Date(n).toUTCString()}`), be.isString(r) && c.push(`path=${r}`), be.isString(a) && c.push(`domain=${a}`), s === !0 && c.push("secure"), be.isString(l) && c.push(`SameSite=${l}`), document.cookie = c.join("; ");
    },
    read(e) {
      if (typeof document > "u") return null;
      const t = document.cookie.match(new RegExp("(?:^|; )" + e + "=([^;]*)"));
      return t ? decodeURIComponent(t[1]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5, "/");
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function Fve(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function Bve(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function $H(e, t, n) {
  let r = !Fve(t);
  return e && (r || n == !1) ? Bve(e, t) : t;
}
const U$ = (e) => e instanceof Da ? { ...e } : e;
function Tm(e, t) {
  t = t || {};
  const n = {};
  function r(f, m, h, v) {
    return be.isPlainObject(f) && be.isPlainObject(m) ? be.merge.call({ caseless: v }, f, m) : be.isPlainObject(m) ? be.merge({}, m) : be.isArray(m) ? m.slice() : m;
  }
  function a(f, m, h, v) {
    if (be.isUndefined(m)) {
      if (!be.isUndefined(f))
        return r(void 0, f, h, v);
    } else return r(f, m, h, v);
  }
  function s(f, m) {
    if (!be.isUndefined(m))
      return r(void 0, m);
  }
  function l(f, m) {
    if (be.isUndefined(m)) {
      if (!be.isUndefined(f))
        return r(void 0, f);
    } else return r(void 0, m);
  }
  function c(f, m, h) {
    if (h in t)
      return r(f, m);
    if (h in e)
      return r(void 0, f);
  }
  const d = {
    url: s,
    method: s,
    data: s,
    baseURL: l,
    transformRequest: l,
    transformResponse: l,
    paramsSerializer: l,
    timeout: l,
    timeoutMessage: l,
    withCredentials: l,
    withXSRFToken: l,
    adapter: l,
    responseType: l,
    xsrfCookieName: l,
    xsrfHeaderName: l,
    onUploadProgress: l,
    onDownloadProgress: l,
    decompress: l,
    maxContentLength: l,
    maxBodyLength: l,
    beforeRedirect: l,
    transport: l,
    httpAgent: l,
    httpsAgent: l,
    cancelToken: l,
    socketPath: l,
    responseEncoding: l,
    validateStatus: c,
    headers: (f, m, h) => a(U$(f), U$(m), h, !0)
  };
  return be.forEach(Object.keys({ ...e, ...t }), function(f) {
    const m = d[f] || a, h = m(e[f], t[f], f);
    be.isUndefined(h) && m !== c || (n[f] = h);
  }), n;
}
const zH = (e) => {
  const t = Tm({}, e);
  let { data: n, withXSRFToken: r, xsrfHeaderName: a, xsrfCookieName: s, headers: l, auth: c } = t;
  if (t.headers = l = Da.from(l), t.url = RH($H(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), c && l.set(
    "Authorization",
    "Basic " + btoa((c.username || "") + ":" + (c.password ? unescape(encodeURIComponent(c.password)) : ""))
  ), be.isFormData(n)) {
    if (Yo.hasStandardBrowserEnv || Yo.hasStandardBrowserWebWorkerEnv)
      l.setContentType(void 0);
    else if (be.isFunction(n.getHeaders)) {
      const d = n.getHeaders(), f = ["content-type", "content-length"];
      Object.entries(d).forEach(([m, h]) => {
        f.includes(m.toLowerCase()) && l.set(m, h);
      });
    }
  }
  if (Yo.hasStandardBrowserEnv && (r && be.isFunction(r) && (r = r(t)), r || r !== !1 && Tve(t.url))) {
    const d = a && s && Lve.read(s);
    d && l.set(a, d);
  }
  return t;
}, Uve = typeof XMLHttpRequest < "u", Vve = Uve && function(e) {
  return new Promise(function(t, n) {
    const r = zH(e);
    let a = r.data;
    const s = Da.from(r.headers).normalize();
    let { responseType: l, onUploadProgress: c, onDownloadProgress: d } = r, f, m, h, v, g;
    function b() {
      v && v(), g && g(), r.cancelToken && r.cancelToken.unsubscribe(f), r.signal && r.signal.removeEventListener("abort", f);
    }
    let x = new XMLHttpRequest();
    x.open(r.method.toUpperCase(), r.url, !0), x.timeout = r.timeout;
    function w() {
      if (!x)
        return;
      const E = Da.from(
        "getAllResponseHeaders" in x && x.getAllResponseHeaders()
      ), _ = {
        data: !l || l === "text" || l === "json" ? x.responseText : x.response,
        status: x.status,
        statusText: x.statusText,
        headers: E,
        config: e,
        request: x
      };
      IH(function(O) {
        t(O), b();
      }, function(O) {
        n(O), b();
      }, _), x = null;
    }
    "onloadend" in x ? x.onloadend = w : x.onreadystatechange = function() {
      !x || x.readyState !== 4 || x.status === 0 && !(x.responseURL && x.responseURL.indexOf("file:") === 0) || setTimeout(w);
    }, x.onabort = function() {
      x && (n(new Pt("Request aborted", Pt.ECONNABORTED, e, x)), x = null);
    }, x.onerror = function(E) {
      const _ = E && E.message ? E.message : "Network Error", O = new Pt(_, Pt.ERR_NETWORK, e, x);
      O.event = E || null, n(O), x = null;
    }, x.ontimeout = function() {
      let E = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded";
      const _ = r.transitional || jH;
      r.timeoutErrorMessage && (E = r.timeoutErrorMessage), n(new Pt(
        E,
        _.clarifyTimeoutError ? Pt.ETIMEDOUT : Pt.ECONNABORTED,
        e,
        x
      )), x = null;
    }, a === void 0 && s.setContentType(null), "setRequestHeader" in x && be.forEach(s.toJSON(), function(E, _) {
      x.setRequestHeader(_, E);
    }), be.isUndefined(r.withCredentials) || (x.withCredentials = !!r.withCredentials), l && l !== "json" && (x.responseType = r.responseType), d && ([h, g] = _2(d, !0), x.addEventListener("progress", h)), c && x.upload && ([m, v] = _2(c), x.upload.addEventListener("progress", m), x.upload.addEventListener("loadend", v)), (r.cancelToken || r.signal) && (f = (E) => {
      x && (n(!E || E.type ? new Vg(null, e, x) : E), x.abort(), x = null);
    }, r.cancelToken && r.cancelToken.subscribe(f), r.signal && (r.signal.aborted ? f() : r.signal.addEventListener("abort", f)));
    const k = Ive(r.url);
    if (k && Yo.protocols.indexOf(k) === -1) {
      n(new Pt("Unsupported protocol " + k + ":", Pt.ERR_BAD_REQUEST, e));
      return;
    }
    x.send(a || null);
  });
}, Hve = (e, t) => {
  const { length: n } = e = e ? e.filter(Boolean) : [];
  if (t || n) {
    let r = new AbortController(), a;
    const s = function(f) {
      if (!a) {
        a = !0, c();
        const m = f instanceof Error ? f : this.reason;
        r.abort(m instanceof Pt ? m : new Vg(m instanceof Error ? m.message : m));
      }
    };
    let l = t && setTimeout(() => {
      l = null, s(new Pt(`timeout ${t} of ms exceeded`, Pt.ETIMEDOUT));
    }, t);
    const c = () => {
      e && (l && clearTimeout(l), l = null, e.forEach((f) => {
        f.unsubscribe ? f.unsubscribe(s) : f.removeEventListener("abort", s);
      }), e = null);
    };
    e.forEach((f) => f.addEventListener("abort", s));
    const { signal: d } = r;
    return d.unsubscribe = () => be.asap(c), d;
  }
}, Wve = function* (e, t) {
  let n = e.byteLength;
  if (n < t) {
    yield e;
    return;
  }
  let r = 0, a;
  for (; r < n; )
    a = r + t, yield e.slice(r, a), r = a;
}, qve = async function* (e, t) {
  for await (const n of Gve(e))
    yield* Wve(n, t);
}, Gve = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: n, value: r } = await t.read();
      if (n)
        break;
      yield r;
    }
  } finally {
    await t.cancel();
  }
}, V$ = (e, t, n, r) => {
  const a = qve(e, t);
  let s = 0, l, c = (d) => {
    l || (l = !0, r && r(d));
  };
  return new ReadableStream({
    async pull(d) {
      try {
        const { done: f, value: m } = await a.next();
        if (f) {
          c(), d.close();
          return;
        }
        let h = m.byteLength;
        if (n) {
          let v = s += h;
          n(v);
        }
        d.enqueue(new Uint8Array(m));
      } catch (f) {
        throw c(f), f;
      }
    },
    cancel(d) {
      return c(d), a.return();
    }
  }, {
    highWaterMark: 2
  });
}, H$ = 64 * 1024, { isFunction: s0 } = be, Kve = (({ Request: e, Response: t }) => ({
  Request: e,
  Response: t
}))(be.global), {
  ReadableStream: W$,
  TextEncoder: q$
} = be.global, G$ = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, Yve = (e) => {
  e = be.merge.call({
    skipUndefined: !0
  }, Kve, e);
  const { fetch: t, Request: n, Response: r } = e, a = t ? s0(t) : typeof fetch == "function", s = s0(n), l = s0(r);
  if (!a)
    return !1;
  const c = a && s0(W$), d = a && (typeof q$ == "function" ? /* @__PURE__ */ ((b) => (x) => b.encode(x))(new q$()) : async (b) => new Uint8Array(await new n(b).arrayBuffer())), f = s && c && G$(() => {
    let b = !1;
    const x = new n(Yo.origin, {
      body: new W$(),
      method: "POST",
      get duplex() {
        return b = !0, "half";
      }
    }).headers.has("Content-Type");
    return b && !x;
  }), m = l && c && G$(() => be.isReadableStream(new r("").body)), h = {
    stream: m && ((b) => b.body)
  };
  a && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((b) => {
    !h[b] && (h[b] = (x, w) => {
      let k = x && x[b];
      if (k)
        return k.call(x);
      throw new Pt(`Response type '${b}' is not supported`, Pt.ERR_NOT_SUPPORT, w);
    });
  });
  const v = async (b) => {
    if (b == null)
      return 0;
    if (be.isBlob(b))
      return b.size;
    if (be.isSpecCompliantForm(b))
      return (await new n(Yo.origin, {
        method: "POST",
        body: b
      }).arrayBuffer()).byteLength;
    if (be.isArrayBufferView(b) || be.isArrayBuffer(b))
      return b.byteLength;
    if (be.isURLSearchParams(b) && (b = b + ""), be.isString(b))
      return (await d(b)).byteLength;
  }, g = async (b, x) => be.toFiniteNumber(b.getContentLength()) ?? v(x);
  return async (b) => {
    let {
      url: x,
      method: w,
      data: k,
      signal: E,
      cancelToken: _,
      timeout: O,
      onDownloadProgress: N,
      onUploadProgress: A,
      responseType: R,
      headers: D,
      withCredentials: I = "same-origin",
      fetchOptions: z
    } = zH(b), B = t || fetch;
    R = R ? (R + "").toLowerCase() : "text";
    let P = Hve([E, _ && _.toAbortSignal()], O), H = null;
    const L = P && P.unsubscribe && (() => {
      P.unsubscribe();
    });
    let G;
    try {
      if (A && f && w !== "get" && w !== "head" && (G = await g(D, k)) !== 0) {
        let F = new n(x, {
          method: "POST",
          body: k,
          duplex: "half"
        }), Y;
        if (be.isFormData(k) && (Y = F.headers.get("content-type")) && D.setContentType(Y), F.body) {
          const [U, W] = F$(
            G,
            _2(B$(A))
          );
          k = V$(F.body, H$, U, W);
        }
      }
      be.isString(I) || (I = I ? "include" : "omit");
      const $ = s && "credentials" in n.prototype, K = {
        ...z,
        signal: P,
        method: w.toUpperCase(),
        headers: D.normalize().toJSON(),
        body: k,
        duplex: "half",
        credentials: $ ? I : void 0
      };
      H = s && new n(x, K);
      let q = await (s ? B(H, z) : B(x, K));
      const Z = m && (R === "stream" || R === "response");
      if (m && (N || Z && L)) {
        const F = {};
        ["status", "statusText", "headers"].forEach((J) => {
          F[J] = q[J];
        });
        const Y = be.toFiniteNumber(q.headers.get("content-length")), [U, W] = N && F$(
          Y,
          _2(B$(N), !0)
        ) || [];
        q = new r(
          V$(q.body, H$, U, () => {
            W && W(), L && L();
          }),
          F
        );
      }
      R = R || "text";
      let V = await h[be.findKey(h, R) || "text"](q, b);
      return !Z && L && L(), await new Promise((F, Y) => {
        IH(F, Y, {
          data: V,
          headers: Da.from(q.headers),
          status: q.status,
          statusText: q.statusText,
          config: b,
          request: H
        });
      });
    } catch ($) {
      throw L && L(), $ && $.name === "TypeError" && /Load failed|fetch/i.test($.message) ? Object.assign(
        new Pt("Network Error", Pt.ERR_NETWORK, b, H),
        {
          cause: $.cause || $
        }
      ) : Pt.from($, $ && $.code, b, H);
    }
  };
}, Xve = /* @__PURE__ */ new Map(), TH = (e) => {
  let t = e && e.env || {};
  const { fetch: n, Request: r, Response: a } = t, s = [
    r,
    a,
    n
  ];
  let l = s.length, c = l, d, f, m = Xve;
  for (; c--; )
    d = s[c], f = m.get(d), f === void 0 && m.set(d, f = c ? /* @__PURE__ */ new Map() : Yve(t)), m = f;
  return f;
};
TH();
const nj = {
  http: pve,
  xhr: Vve,
  fetch: {
    get: TH
  }
};
be.forEach(nj, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const K$ = (e) => `- ${e}`, Jve = (e) => be.isFunction(e) || e === null || e === !1;
function Qve(e, t) {
  e = be.isArray(e) ? e : [e];
  const { length: n } = e;
  let r, a;
  const s = {};
  for (let l = 0; l < n; l++) {
    r = e[l];
    let c;
    if (a = r, !Jve(r) && (a = nj[(c = String(r)).toLowerCase()], a === void 0))
      throw new Pt(`Unknown adapter '${c}'`);
    if (a && (be.isFunction(a) || (a = a.get(t))))
      break;
    s[c || "#" + l] = a;
  }
  if (!a) {
    const l = Object.entries(s).map(
      ([d, f]) => `adapter ${d} ` + (f === !1 ? "is not supported by the environment" : "is not available in the build")
    );
    let c = n ? l.length > 1 ? `since :
` + l.map(K$).join(`
`) : " " + K$(l[0]) : "as no adapter specified";
    throw new Pt(
      "There is no suitable adapter to dispatch the request " + c,
      "ERR_NOT_SUPPORT"
    );
  }
  return a;
}
const LH = {
  /**
   * Resolve an adapter from a list of adapter names or functions.
   * @type {Function}
   */
  getAdapter: Qve,
  /**
   * Exposes all known adapters
   * @type {Object<string, Function|Object>}
   */
  adapters: nj
};
function n5(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Vg(null, e);
}
function Y$(e) {
  return n5(e), e.headers = Da.from(e.headers), e.data = t5.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), LH.getAdapter(e.adapter || uk.adapter, e)(e).then(function(t) {
    return n5(e), t.data = t5.call(
      e,
      e.transformResponse,
      t
    ), t.headers = Da.from(t.headers), t;
  }, function(t) {
    return DH(t) || (n5(e), t && t.response && (t.response.data = t5.call(
      e,
      e.transformResponse,
      t.response
    ), t.response.headers = Da.from(t.response.headers))), Promise.reject(t);
  });
}
const FH = "1.13.2", ZE = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  ZE[e] = function(n) {
    return typeof n === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const X$ = {};
ZE.transitional = function(e, t, n) {
  function r(a, s) {
    return "[Axios v" + FH + "] Transitional option '" + a + "'" + s + (n ? ". " + n : "");
  }
  return (a, s, l) => {
    if (e === !1)
      throw new Pt(
        r(s, " has been removed" + (t ? " in " + t : "")),
        Pt.ERR_DEPRECATED
      );
    return t && !X$[s] && (X$[s] = !0, console.warn(
      r(
        s,
        " has been deprecated since v" + t + " and will be removed in the near future"
      )
    )), e ? e(a, s, l) : !0;
  };
};
ZE.spelling = function(e) {
  return (t, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0);
};
function Zve(e, t, n) {
  if (typeof e != "object")
    throw new Pt("options must be an object", Pt.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let a = r.length;
  for (; a-- > 0; ) {
    const s = r[a], l = t[s];
    if (l) {
      const c = e[s], d = c === void 0 || l(c, s, e);
      if (d !== !0)
        throw new Pt("option " + s + " must be " + d, Pt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new Pt("Unknown option " + s, Pt.ERR_BAD_OPTION);
  }
}
const z_ = {
  assertOptions: Zve,
  validators: ZE
}, ml = z_.validators;
let Am = class {
  constructor(e) {
    this.defaults = e || {}, this.interceptors = {
      request: new T$(),
      response: new T$()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, t) {
    try {
      return await this._request(e, t);
    } catch (n) {
      if (n instanceof Error) {
        let r = {};
        Error.captureStackTrace ? Error.captureStackTrace(r) : r = new Error();
        const a = r.stack ? r.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? a && !String(n.stack).endsWith(a.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + a) : n.stack = a;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(e, t) {
    typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = Tm(this.defaults, t);
    const { transitional: n, paramsSerializer: r, headers: a } = t;
    n !== void 0 && z_.assertOptions(n, {
      silentJSONParsing: ml.transitional(ml.boolean),
      forcedJSONParsing: ml.transitional(ml.boolean),
      clarifyTimeoutError: ml.transitional(ml.boolean)
    }, !1), r != null && (be.isFunction(r) ? t.paramsSerializer = {
      serialize: r
    } : z_.assertOptions(r, {
      encode: ml.function,
      serialize: ml.function
    }, !0)), t.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), z_.assertOptions(t, {
      baseUrl: ml.spelling("baseURL"),
      withXsrfToken: ml.spelling("withXSRFToken")
    }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase();
    let s = a && be.merge(
      a.common,
      a[t.method]
    );
    a && be.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (g) => {
        delete a[g];
      }
    ), t.headers = Da.concat(s, a);
    const l = [];
    let c = !0;
    this.interceptors.request.forEach(function(g) {
      typeof g.runWhen == "function" && g.runWhen(t) === !1 || (c = c && g.synchronous, l.unshift(g.fulfilled, g.rejected));
    });
    const d = [];
    this.interceptors.response.forEach(function(g) {
      d.push(g.fulfilled, g.rejected);
    });
    let f, m = 0, h;
    if (!c) {
      const g = [Y$.bind(this), void 0];
      for (g.unshift(...l), g.push(...d), h = g.length, f = Promise.resolve(t); m < h; )
        f = f.then(g[m++], g[m++]);
      return f;
    }
    h = l.length;
    let v = t;
    for (; m < h; ) {
      const g = l[m++], b = l[m++];
      try {
        v = g(v);
      } catch (x) {
        b.call(this, x);
        break;
      }
    }
    try {
      f = Y$.call(this, v);
    } catch (g) {
      return Promise.reject(g);
    }
    for (m = 0, h = d.length; m < h; )
      f = f.then(d[m++], d[m++]);
    return f;
  }
  getUri(e) {
    e = Tm(this.defaults, e);
    const t = $H(e.baseURL, e.url, e.allowAbsoluteUrls);
    return RH(t, e.params, e.paramsSerializer);
  }
};
be.forEach(["delete", "get", "head", "options"], function(e) {
  Am.prototype[e] = function(t, n) {
    return this.request(Tm(n || {}, {
      method: e,
      url: t,
      data: (n || {}).data
    }));
  };
});
be.forEach(["post", "put", "patch"], function(e) {
  function t(n) {
    return function(r, a, s) {
      return this.request(Tm(s || {}, {
        method: e,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: r,
        data: a
      }));
    };
  }
  Am.prototype[e] = t(), Am.prototype[e + "Form"] = t(!0);
});
let eye = class BH {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(a) {
      n = a;
    });
    const r = this;
    this.promise.then((a) => {
      if (!r._listeners) return;
      let s = r._listeners.length;
      for (; s-- > 0; )
        r._listeners[s](a);
      r._listeners = null;
    }), this.promise.then = (a) => {
      let s;
      const l = new Promise((c) => {
        r.subscribe(c), s = c;
      }).then(a);
      return l.cancel = function() {
        r.unsubscribe(s);
      }, l;
    }, t(function(a, s, l) {
      r.reason || (r.reason = new Vg(a, s, l), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), n = (r) => {
      t.abort(r);
    };
    return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new BH(function(n) {
        t = n;
      }),
      cancel: t
    };
  }
};
function tye(e) {
  return function(t) {
    return e.apply(null, t);
  };
}
function nye(e) {
  return be.isObject(e) && e.isAxiosError === !0;
}
const y3 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
  WebServerIsDown: 521,
  ConnectionTimedOut: 522,
  OriginIsUnreachable: 523,
  TimeoutOccurred: 524,
  SslHandshakeFailed: 525,
  InvalidSslCertificate: 526
};
Object.entries(y3).forEach(([e, t]) => {
  y3[t] = e;
});
function UH(e) {
  const t = new Am(e), n = bH(Am.prototype.request, t);
  return be.extend(n, Am.prototype, t, { allOwnKeys: !0 }), be.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(r) {
    return UH(Tm(e, r));
  }, n;
}
const Ar = UH(uk);
Ar.Axios = Am;
Ar.CanceledError = Vg;
Ar.CancelToken = eye;
Ar.isCancel = DH;
Ar.VERSION = FH;
Ar.toFormData = QE;
Ar.AxiosError = Pt;
Ar.Cancel = Ar.CanceledError;
Ar.all = function(e) {
  return Promise.all(e);
};
Ar.spread = tye;
Ar.isAxiosError = nye;
Ar.mergeConfig = Tm;
Ar.AxiosHeaders = Da;
Ar.formToJSON = (e) => PH(be.isHTMLForm(e) ? new FormData(e) : e);
Ar.getAdapter = LH.getAdapter;
Ar.HttpStatusCode = y3;
Ar.default = Ar;
const {
  Axios: qGe,
  AxiosError: GGe,
  CanceledError: KGe,
  isCancel: YGe,
  CancelToken: XGe,
  VERSION: JGe,
  all: QGe,
  Cancel: ZGe,
  isAxiosError: eKe,
  spread: tKe,
  toFormData: nKe,
  AxiosHeaders: rKe,
  HttpStatusCode: oKe,
  formToJSON: aKe,
  getAdapter: iKe,
  mergeConfig: sKe
} = Ar;
class VH extends Q4 {
  constructor(t) {
    super(t), this._websocket = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 5e3, this._reconnect = !0, this._reconnect_timeout = void 0, this._url = t.url, this._reconnect_timeout = setTimeout(() => {
      this.connect();
    }, 200), this._zustand && this._zustand.auto_progress();
  }
  connect() {
    this._zustand?.logger.info("Connecting to websocket"), this.is_open = !1, this._websocket = new WebSocket(this._url), this._websocket.onopen = () => {
      this.onopen();
    }, this._websocket.onclose = () => {
      this.onclose();
    }, this._websocket.onerror = () => {
      this.on_ws_error();
    }, this._websocket.onmessage = (t) => {
      typeof t.data == "string" ? this.onmessage(t.data) : t.data instanceof Blob && t.data.arrayBuffer().then((n) => {
        const r = new Uint8Array(n);
        this.getCommunicationManager().onbytes(r);
      });
    };
  }
  calculateReconnectTimeout() {
    return Math.min(
      this.initialTimeout * Math.pow(2, this.reconnectAttempts),
      this.maxTimeout
    );
  }
  auto_reconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      let t = this.calculateReconnectTimeout();
      this._zustand?.logger.info(`Attempting to reconnect in ${t} ms`), this._reconnect_timeout = setTimeout(() => {
        this._websocket && this._websocket.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
      }, t);
    } else
      this._zustand?.logger.warn(
        "Maximum reconnect attempts reached. Giving up."
      );
  }
  async onmessage(t) {
    try {
      const n = JSON.parse(t);
      this._zustand?.logger.debug(
        `Recieved data of length: ${t.length} and data"`,
        n
      ), await this.getCommunicationManager().receive(n);
    } catch (n) {
      console.error("Websocketworker: onmessage JSON.parse error", n, t);
      return;
    }
  }
  get http_protocol() {
    return this.secure_url ? "https" : "http";
  }
  get secure_url() {
    return this._url.startsWith("wss");
  }
  get url_wo_protocol() {
    return this._url.substring(this.secure_url ? 6 : 5);
  }
  get http_url() {
    var t = this.http_protocol + "://" + this.url_wo_protocol;
    return t[t.length - 1] !== "/" && (t += "/"), t;
  }
  get_io_subscription_url({
    node_id: t,
    io_id: n,
    stream: r
  }) {
    let a = this.http_url + `node/${t}/io/${n}/value`;
    return r && (a += "/stream"), a;
  }
  async upload_file({
    files: t,
    onProgressCallback: n,
    root: r
  }) {
    const a = `${this.http_url}upload/`, s = new FormData(), l = Array.isArray(t) ? t : Array.from(t);
    for (const c of l) {
      const d = c.webkitRelativePath || c.name, f = r ? `${r}/${d}` : d;
      s.append("file", c, f);
    }
    try {
      return (await Ar.post(a, s, {
        headers: {
          "Content-Type": "multipart/form-data"
        },
        onUploadProgress: (c) => {
          n && n(c.loaded, c.total);
        }
      })).data.file;
    } catch {
      throw new Error("Failed to upload file");
    }
  }
  async handle_large_message_hint({ msg_id: t }) {
    const n = this.http_url + "message/" + t, r = await (await fetch(n, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*"
      }
    })).json();
    this.getCommunicationManager().receive(r);
  }
  onopen() {
    this._zustand?.logger.info("Websocket opened"), this.is_open = !0, this._zustand && this._zustand.auto_progress(), this.reconnectAttempts = 0, this.getSyncManager().stepwise_fullsync();
  }
  onclose() {
    this._zustand?.logger.info("Websocket closed"), super.onclose(), this._reconnect && (this._zustand?.logger.info("Websocket closed,reconnecting"), this.auto_reconnect());
  }
  on_ws_error() {
    this._zustand?.logger.warn("Websocket error"), this._websocket ? this._websocket.close() : this.auto_reconnect();
  }
  async send_large_message(t) {
    const n = `${this.http_url}message/`;
    await fetch(n, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: t
    });
  }
  async send(t) {
    if (!this._websocket || this._websocket.readyState !== WebSocket.OPEN) {
      this._zustand?.logger.warn("Websocket not connected");
      return;
    }
    const n = JSON.stringify(t);
    if (new Blob([n]).size > 1e6)
      return this._zustand?.logger.info("Data too large, sending via http"), await this.send_large_message(n);
    this._zustand?.logger.debug("Sending data", t), this._websocket.send(n);
  }
  async stop() {
    await super.stop(), this._reconnect = !1;
  }
  close() {
    this._websocket && this._websocket.close();
  }
  disconnect() {
    super.disconnect(), this._reconnect = !1, this._reconnect_timeout && (clearTimeout(this._reconnect_timeout), this._reconnect_timeout = void 0), this.close();
  }
  async reconnect() {
    if (await super.reconnect(), this._reconnect = !0, this._websocket && (this._zustand?.logger.info("Reconnecting"), (this._websocket.readyState === WebSocket.OPEN || this._websocket.readyState === WebSocket.CONNECTING) && (this._websocket.readyState === WebSocket.CONNECTING && await new Promise((t, n) => {
      if (this._websocket === null) return;
      let r = setTimeout(() => {
        n("Timeout@reconnect");
      }, 2e3);
      this._websocket.addEventListener(
        "open",
        () => {
          clearTimeout(r), t(null);
        },
        { once: !0 }
      ), this._websocket.readyState === WebSocket.OPEN && (clearTimeout(r), t(null));
    }), this._websocket.readyState === WebSocket.OPEN))) {
      this.getSyncManager().stepwise_fullsync();
      return;
    }
    this.connect();
  }
}
class rye {
  constructor(t, n) {
    this.ws = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 2e3, n.logger.debug("Initializing worker manager"), this._wsuri = t, this.zustand = n, this.workers = {}, this.on_setWorker = (r) => {
      this.zustand.set_worker(r);
    }, this.connectionTimeout = setTimeout(() => {
      this.connect();
    }, 200);
  }
  get wsuri() {
    return this._wsuri;
  }
  get open() {
    return this.ws?.readyState === WebSocket.OPEN;
  }
  connect() {
    this.zustand.set_progress({
      progress: 0,
      message: "connecting to worker manager",
      status: "info",
      blocking: !0
    }), this.zustand.logger.info("Connecting to websocket:", this._wsuri), this.ws = new WebSocket(this._wsuri), this.ws.onopen = () => {
      this.onopen();
    }, this.ws.onclose = () => {
      this.onclose();
    }, this.ws.onerror = () => {
      this.on_ws_error();
    }, this.ws.onmessage = (t) => {
      typeof t.data == "string" ? this.onmessage(t.data) : console.error(
        "WorkerManager: onmessage event.data is not a string",
        typeof t.data
      );
    }, this.connectionTimeout = setTimeout(() => {
      this.ws?.readyState !== WebSocket.OPEN && this.on_ws_error();
    }, 5e3);
  }
  on_ws_error() {
    console.warn("Websocket error"), this.ws ? this.ws.close() : this.reconnect();
  }
  onopen() {
    this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.zustand.auto_progress(), this.ws && this.ws.send("worker_status");
  }
  onmessage(t) {
    try {
      let n = JSON.parse(t);
      if (n.type === "worker_status") {
        const r = {};
        for (let a of n.active)
          a.active = !0, r[a.uuid] = a;
        for (let a of n.inactive)
          a.active = !1, r[a.uuid] = a;
        if (this.zustand.workers.setState(r), !this.zustand.worker) {
          const a = window.localStorage.getItem(
            "funcnodes__active_worker"
          );
          a && r[a] && r[a].active && this.set_active(a);
        }
        return;
      } else if (n.type === "set_worker") {
        if (n.data.type === "WSWorker") {
          let r = "ws" + (n.data.ssl ? "s" : "") + "://" + n.data.host + ":" + n.data.port;
          this.setWorker(
            this.workers[n.data.uuid] || new VH({
              url: r,
              zustand: this.zustand,
              uuid: n.data.uuid,
              on_sync_complete: this.zustand.options.on_sync_complete
            })
          );
        } else
          this.zustand.logger.error("WorkerManager: unknown worker type", n);
        return;
      } else if (n.type === "progress") {
        this.zustand.set_progress(n);
        return;
      }
      this.zustand.logger.error("WorkerManager: unknown message", n);
    } catch (n) {
      console.error("WorkerManager: onmessage JSON.parse error", n, t);
      return;
    }
  }
  setWorker(t) {
    for (let n in this.workers)
      n !== t?.uuid && this.workers[n].disconnect();
    t !== void 0 && (this.workers[t.uuid] = t, t.reconnect()), t?.uuid && window.localStorage.setItem("funcnodes__active_worker", t?.uuid), this.zustand.worker !== void 0 && this.zustand.clear_all(), this.zustand.set_worker(t), this.on_setWorker(t);
  }
  async restart_worker(t) {
    this.ws?.send(JSON.stringify({ type: "restart_worker", workerid: t }));
  }
  calculateReconnectTimeout() {
    return Math.min(
      this.initialTimeout * Math.pow(2, this.reconnectAttempts),
      this.maxTimeout
    );
  }
  reconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      let t = this.calculateReconnectTimeout();
      this.zustand.logger.info(`Attempting to reconnect in ${t} ms`), setTimeout(() => {
        this.ws && this.ws.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
      }, t);
    } else
      this.zustand.logger.warn(
        "Maximum reconnect attempts reached. Giving up."
      );
  }
  onclose() {
    this.zustand.logger.warn("WorkerManager: onclose"), this.reconnect();
  }
  set_active(t) {
    this.ws && this.ws.send(JSON.stringify({ type: "set_active", workerid: t }));
  }
  new_worker({
    name: t,
    reference: n,
    copyLib: r,
    copyNS: a,
    in_venv: s
  }) {
    t || (t = void 0), r || (r = !1), a || (a = !1), n || (n = void 0, r = !1, a = !1), this.ws && this.ws.send(
      JSON.stringify({
        type: "new_worker",
        kwargs: {
          name: t,
          reference: n,
          copyLib: r,
          copyNS: a,
          in_venv: s
        }
      })
    );
  }
  remove() {
    for (let t in this.workers)
      this.workers[t].disconnect();
    this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.ws && (this.ws.onclose = () => {
    }, this.ws.onerror = () => {
    }, this.ws.onmessage = () => {
    }, this.ws.onopen = () => {
    }, this.ws.close());
  }
}
const Oa = () => {
  const e = Sn();
  return e.worker ? {
    ...e.worker.api,
    worker: e.worker
  } : {
    node: void 0,
    group: void 0,
    edge: void 0,
    hooks: void 0,
    lib: void 0,
    worker: e.worker
  };
}, oye = {
  show: !0
}, aye = {
  show: !0,
  showmenu: !0
}, iye = {
  minimap: !0,
  static: !1,
  minZoom: 0.1,
  maxZoom: 5,
  allowFullScreen: !0,
  allowExpand: !0,
  showNodeSettings: !0
}, sye = {
  id: "",
  // required
  debug: !1,
  useWorkerManager: !0,
  show_library: !0,
  header: aye,
  flow: iye,
  library: oye
}, HH = [
  "classic",
  "metal",
  "light",
  "solarized",
  "midnight",
  "forest",
  "scientific",
  "neon",
  "ocean",
  "sunset"
];
function zr(e) {
  if (typeof e == "string" || typeof e == "number") return "" + e;
  let t = "";
  if (Array.isArray(e))
    for (let n = 0, r; n < e.length; n++)
      (r = zr(e[n])) !== "" && (t += (t && " ") + r);
  else
    for (let n in e)
      e[n] && (t += (t && " ") + n);
  return t;
}
var lye = { value: () => {
} };
function eC() {
  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
    if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r)) throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new T_(n);
}
function T_(e) {
  this._ = e;
}
function uye(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var r = "", a = n.indexOf(".");
    if (a >= 0 && (r = n.slice(a + 1), n = n.slice(0, a)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
T_.prototype = eC.prototype = {
  constructor: T_,
  on: function(e, t) {
    var n = this._, r = uye(e + "", n), a, s = -1, l = r.length;
    if (arguments.length < 2) {
      for (; ++s < l; ) if ((a = (e = r[s]).type) && (a = cye(n[a], e.name))) return a;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++s < l; )
      if (a = (e = r[s]).type) n[a] = J$(n[a], e.name, t);
      else if (t == null) for (a in n) n[a] = J$(n[a], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t) e[n] = t[n].slice();
    return new T_(e);
  },
  call: function(e, t) {
    if ((a = arguments.length - 2) > 0) for (var n = new Array(a), r = 0, a, s; r < a; ++r) n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (s = this._[e], r = 0, a = s.length; r < a; ++r) s[r].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (var r = this._[e], a = 0, s = r.length; a < s; ++a) r[a].value.apply(t, n);
  }
};
function cye(e, t) {
  for (var n = 0, r = e.length, a; n < r; ++n)
    if ((a = e[n]).name === t)
      return a.value;
}
function J$(e, t, n) {
  for (var r = 0, a = e.length; r < a; ++r)
    if (e[r].name === t) {
      e[r] = lye, e = e.slice(0, r).concat(e.slice(r + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var b3 = "http://www.w3.org/1999/xhtml";
const Q$ = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: b3,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function tC(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), Q$.hasOwnProperty(t) ? { space: Q$[t], local: e } : e;
}
function dye(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === b3 && t.documentElement.namespaceURI === b3 ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function fye(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function WH(e) {
  var t = tC(e);
  return (t.local ? fye : dye)(t);
}
function pye() {
}
function rj(e) {
  return e == null ? pye : function() {
    return this.querySelector(e);
  };
}
function mye(e) {
  typeof e != "function" && (e = rj(e));
  for (var t = this._groups, n = t.length, r = new Array(n), a = 0; a < n; ++a)
    for (var s = t[a], l = s.length, c = r[a] = new Array(l), d, f, m = 0; m < l; ++m)
      (d = s[m]) && (f = e.call(d, d.__data__, m, s)) && ("__data__" in d && (f.__data__ = d.__data__), c[m] = f);
  return new Mi(r, this._parents);
}
function hye(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function gye() {
  return [];
}
function qH(e) {
  return e == null ? gye : function() {
    return this.querySelectorAll(e);
  };
}
function vye(e) {
  return function() {
    return hye(e.apply(this, arguments));
  };
}
function yye(e) {
  typeof e == "function" ? e = vye(e) : e = qH(e);
  for (var t = this._groups, n = t.length, r = [], a = [], s = 0; s < n; ++s)
    for (var l = t[s], c = l.length, d, f = 0; f < c; ++f)
      (d = l[f]) && (r.push(e.call(d, d.__data__, f, l)), a.push(d));
  return new Mi(r, a);
}
function GH(e) {
  return function() {
    return this.matches(e);
  };
}
function KH(e) {
  return function(t) {
    return t.matches(e);
  };
}
var bye = Array.prototype.find;
function wye(e) {
  return function() {
    return bye.call(this.children, e);
  };
}
function xye() {
  return this.firstElementChild;
}
function Sye(e) {
  return this.select(e == null ? xye : wye(typeof e == "function" ? e : KH(e)));
}
var kye = Array.prototype.filter;
function _ye() {
  return Array.from(this.children);
}
function Eye(e) {
  return function() {
    return kye.call(this.children, e);
  };
}
function Cye(e) {
  return this.selectAll(e == null ? _ye : Eye(typeof e == "function" ? e : KH(e)));
}
function Oye(e) {
  typeof e != "function" && (e = GH(e));
  for (var t = this._groups, n = t.length, r = new Array(n), a = 0; a < n; ++a)
    for (var s = t[a], l = s.length, c = r[a] = [], d, f = 0; f < l; ++f)
      (d = s[f]) && e.call(d, d.__data__, f, s) && c.push(d);
  return new Mi(r, this._parents);
}
function YH(e) {
  return new Array(e.length);
}
function Mye() {
  return new Mi(this._enter || this._groups.map(YH), this._parents);
}
function E2(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
E2.prototype = {
  constructor: E2,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function Nye(e) {
  return function() {
    return e;
  };
}
function Aye(e, t, n, r, a, s) {
  for (var l = 0, c, d = t.length, f = s.length; l < f; ++l)
    (c = t[l]) ? (c.__data__ = s[l], r[l] = c) : n[l] = new E2(e, s[l]);
  for (; l < d; ++l)
    (c = t[l]) && (a[l] = c);
}
function Rye(e, t, n, r, a, s, l) {
  var c, d, f = /* @__PURE__ */ new Map(), m = t.length, h = s.length, v = new Array(m), g;
  for (c = 0; c < m; ++c)
    (d = t[c]) && (v[c] = g = l.call(d, d.__data__, c, t) + "", f.has(g) ? a[c] = d : f.set(g, d));
  for (c = 0; c < h; ++c)
    g = l.call(e, s[c], c, s) + "", (d = f.get(g)) ? (r[c] = d, d.__data__ = s[c], f.delete(g)) : n[c] = new E2(e, s[c]);
  for (c = 0; c < m; ++c)
    (d = t[c]) && f.get(v[c]) === d && (a[c] = d);
}
function jye(e) {
  return e.__data__;
}
function Pye(e, t) {
  if (!arguments.length) return Array.from(this, jye);
  var n = t ? Rye : Aye, r = this._parents, a = this._groups;
  typeof e != "function" && (e = Nye(e));
  for (var s = a.length, l = new Array(s), c = new Array(s), d = new Array(s), f = 0; f < s; ++f) {
    var m = r[f], h = a[f], v = h.length, g = Dye(e.call(m, m && m.__data__, f, r)), b = g.length, x = c[f] = new Array(b), w = l[f] = new Array(b), k = d[f] = new Array(v);
    n(m, h, x, w, k, g, t);
    for (var E = 0, _ = 0, O, N; E < b; ++E)
      if (O = x[E]) {
        for (E >= _ && (_ = E + 1); !(N = w[_]) && ++_ < b; ) ;
        O._next = N || null;
      }
  }
  return l = new Mi(l, r), l._enter = c, l._exit = d, l;
}
function Dye(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function Iye() {
  return new Mi(this._exit || this._groups.map(YH), this._parents);
}
function $ye(e, t, n) {
  var r = this.enter(), a = this, s = this.exit();
  return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (a = t(a), a && (a = a.selection())), n == null ? s.remove() : n(s), r && a ? r.merge(a).order() : a;
}
function zye(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, a = n.length, s = r.length, l = Math.min(a, s), c = new Array(a), d = 0; d < l; ++d)
    for (var f = n[d], m = r[d], h = f.length, v = c[d] = new Array(h), g, b = 0; b < h; ++b)
      (g = f[b] || m[b]) && (v[b] = g);
  for (; d < a; ++d)
    c[d] = n[d];
  return new Mi(c, this._parents);
}
function Tye() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var r = e[t], a = r.length - 1, s = r[a], l; --a >= 0; )
      (l = r[a]) && (s && l.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(l, s), s = l);
  return this;
}
function Lye(e) {
  e || (e = Fye);
  function t(h, v) {
    return h && v ? e(h.__data__, v.__data__) : !h - !v;
  }
  for (var n = this._groups, r = n.length, a = new Array(r), s = 0; s < r; ++s) {
    for (var l = n[s], c = l.length, d = a[s] = new Array(c), f, m = 0; m < c; ++m)
      (f = l[m]) && (d[m] = f);
    d.sort(t);
  }
  return new Mi(a, this._parents).order();
}
function Fye(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function Bye() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function Uye() {
  return Array.from(this);
}
function Vye() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], a = 0, s = r.length; a < s; ++a) {
      var l = r[a];
      if (l) return l;
    }
  return null;
}
function Hye() {
  let e = 0;
  for (const t of this) ++e;
  return e;
}
function Wye() {
  return !this.node();
}
function qye(e) {
  for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
    for (var a = t[n], s = 0, l = a.length, c; s < l; ++s)
      (c = a[s]) && e.call(c, c.__data__, s, a);
  return this;
}
function Gye(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function Kye(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function Yye(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function Xye(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function Jye(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function Qye(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function Zye(e, t) {
  var n = tC(e);
  if (arguments.length < 2) {
    var r = this.node();
    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
  }
  return this.each((t == null ? n.local ? Kye : Gye : typeof t == "function" ? n.local ? Qye : Jye : n.local ? Xye : Yye)(n, t));
}
function XH(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function ebe(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function tbe(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function nbe(e, t, n) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n);
  };
}
function rbe(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? ebe : typeof t == "function" ? nbe : tbe)(e, t, n ?? "")) : bg(this.node(), e);
}
function bg(e, t) {
  return e.style.getPropertyValue(t) || XH(e).getComputedStyle(e, null).getPropertyValue(t);
}
function obe(e) {
  return function() {
    delete this[e];
  };
}
function abe(e, t) {
  return function() {
    this[e] = t;
  };
}
function ibe(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function sbe(e, t) {
  return arguments.length > 1 ? this.each((t == null ? obe : typeof t == "function" ? ibe : abe)(e, t)) : this.node()[e];
}
function JH(e) {
  return e.trim().split(/^|\s+/);
}
function oj(e) {
  return e.classList || new QH(e);
}
function QH(e) {
  this._node = e, this._names = JH(e.getAttribute("class") || "");
}
QH.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function ZH(e, t) {
  for (var n = oj(e), r = -1, a = t.length; ++r < a; ) n.add(t[r]);
}
function eW(e, t) {
  for (var n = oj(e), r = -1, a = t.length; ++r < a; ) n.remove(t[r]);
}
function lbe(e) {
  return function() {
    ZH(this, e);
  };
}
function ube(e) {
  return function() {
    eW(this, e);
  };
}
function cbe(e, t) {
  return function() {
    (t.apply(this, arguments) ? ZH : eW)(this, e);
  };
}
function dbe(e, t) {
  var n = JH(e + "");
  if (arguments.length < 2) {
    for (var r = oj(this.node()), a = -1, s = n.length; ++a < s; ) if (!r.contains(n[a])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? cbe : t ? lbe : ube)(n, t));
}
function fbe() {
  this.textContent = "";
}
function pbe(e) {
  return function() {
    this.textContent = e;
  };
}
function mbe(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function hbe(e) {
  return arguments.length ? this.each(e == null ? fbe : (typeof e == "function" ? mbe : pbe)(e)) : this.node().textContent;
}
function gbe() {
  this.innerHTML = "";
}
function vbe(e) {
  return function() {
    this.innerHTML = e;
  };
}
function ybe(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function bbe(e) {
  return arguments.length ? this.each(e == null ? gbe : (typeof e == "function" ? ybe : vbe)(e)) : this.node().innerHTML;
}
function wbe() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function xbe() {
  return this.each(wbe);
}
function Sbe() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function kbe() {
  return this.each(Sbe);
}
function _be(e) {
  var t = typeof e == "function" ? e : WH(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function Ebe() {
  return null;
}
function Cbe(e, t) {
  var n = typeof e == "function" ? e : WH(e), r = t == null ? Ebe : typeof t == "function" ? t : rj(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
  });
}
function Obe() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function Mbe() {
  return this.each(Obe);
}
function Nbe() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function Abe() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function Rbe(e) {
  return this.select(e ? Abe : Nbe);
}
function jbe(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function Pbe(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function Dbe(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", r = t.indexOf(".");
    return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };
  });
}
function Ibe(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, r = -1, a = t.length, s; n < a; ++n)
        s = t[n], (!e.type || s.type === e.type) && s.name === e.name ? this.removeEventListener(s.type, s.listener, s.options) : t[++r] = s;
      ++r ? t.length = r : delete this.__on;
    }
  };
}
function $be(e, t, n) {
  return function() {
    var r = this.__on, a, s = Pbe(t);
    if (r) {
      for (var l = 0, c = r.length; l < c; ++l)
        if ((a = r[l]).type === e.type && a.name === e.name) {
          this.removeEventListener(a.type, a.listener, a.options), this.addEventListener(a.type, a.listener = s, a.options = n), a.value = t;
          return;
        }
    }
    this.addEventListener(e.type, s, n), a = { type: e.type, name: e.name, value: t, listener: s, options: n }, r ? r.push(a) : this.__on = [a];
  };
}
function zbe(e, t, n) {
  var r = Dbe(e + ""), a, s = r.length, l;
  if (arguments.length < 2) {
    var c = this.node().__on;
    if (c) {
      for (var d = 0, f = c.length, m; d < f; ++d)
        for (a = 0, m = c[d]; a < s; ++a)
          if ((l = r[a]).type === m.type && l.name === m.name)
            return m.value;
    }
    return;
  }
  for (c = t ? $be : Ibe, a = 0; a < s; ++a) this.each(c(r[a], t, n));
  return this;
}
function tW(e, t, n) {
  var r = XH(e), a = r.CustomEvent;
  typeof a == "function" ? a = new a(t, n) : (a = r.document.createEvent("Event"), n ? (a.initEvent(t, n.bubbles, n.cancelable), a.detail = n.detail) : a.initEvent(t, !1, !1)), e.dispatchEvent(a);
}
function Tbe(e, t) {
  return function() {
    return tW(this, e, t);
  };
}
function Lbe(e, t) {
  return function() {
    return tW(this, e, t.apply(this, arguments));
  };
}
function Fbe(e, t) {
  return this.each((typeof t == "function" ? Lbe : Tbe)(e, t));
}
function* Bbe() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], a = 0, s = r.length, l; a < s; ++a)
      (l = r[a]) && (yield l);
}
var nW = [null];
function Mi(e, t) {
  this._groups = e, this._parents = t;
}
function ck() {
  return new Mi([[document.documentElement]], nW);
}
function Ube() {
  return this;
}
Mi.prototype = ck.prototype = {
  constructor: Mi,
  select: mye,
  selectAll: yye,
  selectChild: Sye,
  selectChildren: Cye,
  filter: Oye,
  data: Pye,
  enter: Mye,
  exit: Iye,
  join: $ye,
  merge: zye,
  selection: Ube,
  order: Tye,
  sort: Lye,
  call: Bye,
  nodes: Uye,
  node: Vye,
  size: Hye,
  empty: Wye,
  each: qye,
  attr: Zye,
  style: rbe,
  property: sbe,
  classed: dbe,
  text: hbe,
  html: bbe,
  raise: xbe,
  lower: kbe,
  append: _be,
  insert: Cbe,
  remove: Mbe,
  clone: Rbe,
  datum: jbe,
  on: zbe,
  dispatch: Fbe,
  [Symbol.iterator]: Bbe
};
function _i(e) {
  return typeof e == "string" ? new Mi([[document.querySelector(e)]], [document.documentElement]) : new Mi([[e]], nW);
}
function Vbe(e) {
  let t;
  for (; t = e.sourceEvent; ) e = t;
  return e;
}
function Hs(e, t) {
  if (e = Vbe(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var r = n.createSVGPoint();
      return r.x = e.clientX, r.y = e.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
    }
    if (t.getBoundingClientRect) {
      var a = t.getBoundingClientRect();
      return [e.clientX - a.left - t.clientLeft, e.clientY - a.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
const Hbe = { passive: !1 }, cS = { capture: !0, passive: !1 };
function r5(e) {
  e.stopImmediatePropagation();
}
function ag(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function rW(e) {
  var t = e.document.documentElement, n = _i(e).on("dragstart.drag", ag, cS);
  "onselectstart" in t ? n.on("selectstart.drag", ag, cS) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function oW(e, t) {
  var n = e.document.documentElement, r = _i(e).on("dragstart.drag", null);
  t && (r.on("click.drag", ag, cS), setTimeout(function() {
    r.on("click.drag", null);
  }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
const l0 = (e) => () => e;
function w3(e, {
  sourceEvent: t,
  subject: n,
  target: r,
  identifier: a,
  active: s,
  x: l,
  y: c,
  dx: d,
  dy: f,
  dispatch: m
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    subject: { value: n, enumerable: !0, configurable: !0 },
    target: { value: r, enumerable: !0, configurable: !0 },
    identifier: { value: a, enumerable: !0, configurable: !0 },
    active: { value: s, enumerable: !0, configurable: !0 },
    x: { value: l, enumerable: !0, configurable: !0 },
    y: { value: c, enumerable: !0, configurable: !0 },
    dx: { value: d, enumerable: !0, configurable: !0 },
    dy: { value: f, enumerable: !0, configurable: !0 },
    _: { value: m }
  });
}
w3.prototype.on = function() {
  var e = this._.on.apply(this._, arguments);
  return e === this._ ? this : e;
};
function Wbe(e) {
  return !e.ctrlKey && !e.button;
}
function qbe() {
  return this.parentNode;
}
function Gbe(e, t) {
  return t ?? { x: e.x, y: e.y };
}
function Kbe() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function aW() {
  var e = Wbe, t = qbe, n = Gbe, r = Kbe, a = {}, s = eC("start", "drag", "end"), l = 0, c, d, f, m, h = 0;
  function v(O) {
    O.on("mousedown.drag", g).filter(r).on("touchstart.drag", w).on("touchmove.drag", k, Hbe).on("touchend.drag touchcancel.drag", E).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function g(O, N) {
    if (!(m || !e.call(this, O, N))) {
      var A = _(this, t.call(this, O, N), O, N, "mouse");
      A && (_i(O.view).on("mousemove.drag", b, cS).on("mouseup.drag", x, cS), rW(O.view), r5(O), f = !1, c = O.clientX, d = O.clientY, A("start", O));
    }
  }
  function b(O) {
    if (ag(O), !f) {
      var N = O.clientX - c, A = O.clientY - d;
      f = N * N + A * A > h;
    }
    a.mouse("drag", O);
  }
  function x(O) {
    _i(O.view).on("mousemove.drag mouseup.drag", null), oW(O.view, f), ag(O), a.mouse("end", O);
  }
  function w(O, N) {
    if (e.call(this, O, N)) {
      var A = O.changedTouches, R = t.call(this, O, N), D = A.length, I, z;
      for (I = 0; I < D; ++I)
        (z = _(this, R, O, N, A[I].identifier, A[I])) && (r5(O), z("start", O, A[I]));
    }
  }
  function k(O) {
    var N = O.changedTouches, A = N.length, R, D;
    for (R = 0; R < A; ++R)
      (D = a[N[R].identifier]) && (ag(O), D("drag", O, N[R]));
  }
  function E(O) {
    var N = O.changedTouches, A = N.length, R, D;
    for (m && clearTimeout(m), m = setTimeout(function() {
      m = null;
    }, 500), R = 0; R < A; ++R)
      (D = a[N[R].identifier]) && (r5(O), D("end", O, N[R]));
  }
  function _(O, N, A, R, D, I) {
    var z = s.copy(), B = Hs(I || A, N), P, H, L;
    if ((L = n.call(O, new w3("beforestart", {
      sourceEvent: A,
      target: v,
      identifier: D,
      active: l,
      x: B[0],
      y: B[1],
      dx: 0,
      dy: 0,
      dispatch: z
    }), R)) != null)
      return P = L.x - B[0] || 0, H = L.y - B[1] || 0, function G($, K, q) {
        var Z = B, V;
        switch ($) {
          case "start":
            a[D] = G, V = l++;
            break;
          case "end":
            delete a[D], --l;
          // falls through
          case "drag":
            B = Hs(q || K, N), V = l;
            break;
        }
        z.call(
          $,
          O,
          new w3($, {
            sourceEvent: K,
            subject: L,
            target: v,
            identifier: D,
            active: V,
            x: B[0] + P,
            y: B[1] + H,
            dx: B[0] - Z[0],
            dy: B[1] - Z[1],
            dispatch: z
          }),
          R
        );
      };
  }
  return v.filter = function(O) {
    return arguments.length ? (e = typeof O == "function" ? O : l0(!!O), v) : e;
  }, v.container = function(O) {
    return arguments.length ? (t = typeof O == "function" ? O : l0(O), v) : t;
  }, v.subject = function(O) {
    return arguments.length ? (n = typeof O == "function" ? O : l0(O), v) : n;
  }, v.touchable = function(O) {
    return arguments.length ? (r = typeof O == "function" ? O : l0(!!O), v) : r;
  }, v.on = function() {
    var O = s.on.apply(s, arguments);
    return O === s ? v : O;
  }, v.clickDistance = function(O) {
    return arguments.length ? (h = (O = +O) * O, v) : Math.sqrt(h);
  }, v;
}
function aj(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function iW(e, t) {
  var n = Object.create(e.prototype);
  for (var r in t) n[r] = t[r];
  return n;
}
function dk() {
}
var dS = 0.7, C2 = 1 / dS, ig = "\\s*([+-]?\\d+)\\s*", fS = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Ul = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Ybe = /^#([0-9a-f]{3,8})$/, Xbe = new RegExp(`^rgb\\(${ig},${ig},${ig}\\)$`), Jbe = new RegExp(`^rgb\\(${Ul},${Ul},${Ul}\\)$`), Qbe = new RegExp(`^rgba\\(${ig},${ig},${ig},${fS}\\)$`), Zbe = new RegExp(`^rgba\\(${Ul},${Ul},${Ul},${fS}\\)$`), ewe = new RegExp(`^hsl\\(${fS},${Ul},${Ul}\\)$`), twe = new RegExp(`^hsla\\(${fS},${Ul},${Ul},${fS}\\)$`), Z$ = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
aj(dk, Lm, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: e6,
  // Deprecated! Use color.formatHex.
  formatHex: e6,
  formatHex8: nwe,
  formatHsl: rwe,
  formatRgb: t6,
  toString: t6
});
function e6() {
  return this.rgb().formatHex();
}
function nwe() {
  return this.rgb().formatHex8();
}
function rwe() {
  return sW(this).formatHsl();
}
function t6() {
  return this.rgb().formatRgb();
}
function Lm(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = Ybe.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? n6(t) : n === 3 ? new ja(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? u0(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? u0(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = Xbe.exec(e)) ? new ja(t[1], t[2], t[3], 1) : (t = Jbe.exec(e)) ? new ja(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = Qbe.exec(e)) ? u0(t[1], t[2], t[3], t[4]) : (t = Zbe.exec(e)) ? u0(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = ewe.exec(e)) ? a6(t[1], t[2] / 100, t[3] / 100, 1) : (t = twe.exec(e)) ? a6(t[1], t[2] / 100, t[3] / 100, t[4]) : Z$.hasOwnProperty(e) ? n6(Z$[e]) : e === "transparent" ? new ja(NaN, NaN, NaN, 0) : null;
}
function n6(e) {
  return new ja(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function u0(e, t, n, r) {
  return r <= 0 && (e = t = n = NaN), new ja(e, t, n, r);
}
function owe(e) {
  return e instanceof dk || (e = Lm(e)), e ? (e = e.rgb(), new ja(e.r, e.g, e.b, e.opacity)) : new ja();
}
function x3(e, t, n, r) {
  return arguments.length === 1 ? owe(e) : new ja(e, t, n, r ?? 1);
}
function ja(e, t, n, r) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
}
aj(ja, x3, iW(dk, {
  brighter(e) {
    return e = e == null ? C2 : Math.pow(C2, e), new ja(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? dS : Math.pow(dS, e), new ja(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new ja(Rm(this.r), Rm(this.g), Rm(this.b), O2(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: r6,
  // Deprecated! Use color.formatHex.
  formatHex: r6,
  formatHex8: awe,
  formatRgb: o6,
  toString: o6
}));
function r6() {
  return `#${Mm(this.r)}${Mm(this.g)}${Mm(this.b)}`;
}
function awe() {
  return `#${Mm(this.r)}${Mm(this.g)}${Mm(this.b)}${Mm((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function o6() {
  const e = O2(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${Rm(this.r)}, ${Rm(this.g)}, ${Rm(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function O2(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function Rm(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Mm(e) {
  return e = Rm(e), (e < 16 ? "0" : "") + e.toString(16);
}
function a6(e, t, n, r) {
  return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Ws(e, t, n, r);
}
function sW(e) {
  if (e instanceof Ws) return new Ws(e.h, e.s, e.l, e.opacity);
  if (e instanceof dk || (e = Lm(e)), !e) return new Ws();
  if (e instanceof Ws) return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, r = e.b / 255, a = Math.min(t, n, r), s = Math.max(t, n, r), l = NaN, c = s - a, d = (s + a) / 2;
  return c ? (t === s ? l = (n - r) / c + (n < r) * 6 : n === s ? l = (r - t) / c + 2 : l = (t - n) / c + 4, c /= d < 0.5 ? s + a : 2 - s - a, l *= 60) : c = d > 0 && d < 1 ? 0 : l, new Ws(l, c, d, e.opacity);
}
function iwe(e, t, n, r) {
  return arguments.length === 1 ? sW(e) : new Ws(e, t, n, r ?? 1);
}
function Ws(e, t, n, r) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
}
aj(Ws, iwe, iW(dk, {
  brighter(e) {
    return e = e == null ? C2 : Math.pow(C2, e), new Ws(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? dS : Math.pow(dS, e), new Ws(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, a = 2 * n - r;
    return new ja(
      o5(e >= 240 ? e - 240 : e + 120, a, r),
      o5(e, a, r),
      o5(e < 120 ? e + 240 : e - 120, a, r),
      this.opacity
    );
  },
  clamp() {
    return new Ws(i6(this.h), c0(this.s), c0(this.l), O2(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = O2(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${i6(this.h)}, ${c0(this.s) * 100}%, ${c0(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function i6(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function c0(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function o5(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const ij = (e) => () => e;
function swe(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function lwe(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {
    return Math.pow(e + r * t, n);
  };
}
function uwe(e) {
  return (e = +e) == 1 ? lW : function(t, n) {
    return n - t ? lwe(t, n, e) : ij(isNaN(t) ? n : t);
  };
}
function lW(e, t) {
  var n = t - e;
  return n ? swe(e, n) : ij(isNaN(e) ? t : e);
}
const M2 = (function e(t) {
  var n = uwe(t);
  function r(a, s) {
    var l = n((a = x3(a)).r, (s = x3(s)).r), c = n(a.g, s.g), d = n(a.b, s.b), f = lW(a.opacity, s.opacity);
    return function(m) {
      return a.r = l(m), a.g = c(m), a.b = d(m), a.opacity = f(m), a + "";
    };
  }
  return r.gamma = e, r;
})(1);
function cwe(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, r = t.slice(), a;
  return function(s) {
    for (a = 0; a < n; ++a) r[a] = e[a] * (1 - s) + t[a] * s;
    return r;
  };
}
function dwe(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function fwe(e, t) {
  var n = t ? t.length : 0, r = e ? Math.min(n, e.length) : 0, a = new Array(r), s = new Array(n), l;
  for (l = 0; l < r; ++l) a[l] = Ix(e[l], t[l]);
  for (; l < n; ++l) s[l] = t[l];
  return function(c) {
    for (l = 0; l < r; ++l) s[l] = a[l](c);
    return s;
  };
}
function pwe(e, t) {
  var n = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(r) {
    return n.setTime(e * (1 - r) + t * r), n;
  };
}
function kl(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function mwe(e, t) {
  var n = {}, r = {}, a;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (a in t)
    a in e ? n[a] = Ix(e[a], t[a]) : r[a] = t[a];
  return function(s) {
    for (a in n) r[a] = n[a](s);
    return r;
  };
}
var S3 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, a5 = new RegExp(S3.source, "g");
function hwe(e) {
  return function() {
    return e;
  };
}
function gwe(e) {
  return function(t) {
    return e(t) + "";
  };
}
function uW(e, t) {
  var n = S3.lastIndex = a5.lastIndex = 0, r, a, s, l = -1, c = [], d = [];
  for (e = e + "", t = t + ""; (r = S3.exec(e)) && (a = a5.exec(t)); )
    (s = a.index) > n && (s = t.slice(n, s), c[l] ? c[l] += s : c[++l] = s), (r = r[0]) === (a = a[0]) ? c[l] ? c[l] += a : c[++l] = a : (c[++l] = null, d.push({ i: l, x: kl(r, a) })), n = a5.lastIndex;
  return n < t.length && (s = t.slice(n), c[l] ? c[l] += s : c[++l] = s), c.length < 2 ? d[0] ? gwe(d[0].x) : hwe(t) : (t = d.length, function(f) {
    for (var m = 0, h; m < t; ++m) c[(h = d[m]).i] = h.x(f);
    return c.join("");
  });
}
function Ix(e, t) {
  var n = typeof t, r;
  return t == null || n === "boolean" ? ij(t) : (n === "number" ? kl : n === "string" ? (r = Lm(t)) ? (t = r, M2) : uW : t instanceof Lm ? M2 : t instanceof Date ? pwe : dwe(t) ? cwe : Array.isArray(t) ? fwe : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? mwe : kl)(e, t);
}
var s6 = 180 / Math.PI, cW = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function dW(e, t, n, r, a, s) {
  var l, c, d;
  return (l = Math.sqrt(e * e + t * t)) && (e /= l, t /= l), (d = e * n + t * r) && (n -= e * d, r -= t * d), (c = Math.sqrt(n * n + r * r)) && (n /= c, r /= c, d /= c), e * r < t * n && (e = -e, t = -t, d = -d, l = -l), {
    translateX: a,
    translateY: s,
    rotate: Math.atan2(t, e) * s6,
    skewX: Math.atan(d) * s6,
    scaleX: l,
    scaleY: c
  };
}
var d0;
function vwe(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? cW : dW(t.a, t.b, t.c, t.d, t.e, t.f);
}
function ywe(e) {
  return e == null || (d0 || (d0 = document.createElementNS("http://www.w3.org/2000/svg", "g")), d0.setAttribute("transform", e), !(e = d0.transform.baseVal.consolidate())) ? cW : (e = e.matrix, dW(e.a, e.b, e.c, e.d, e.e, e.f));
}
function fW(e, t, n, r) {
  function a(f) {
    return f.length ? f.pop() + " " : "";
  }
  function s(f, m, h, v, g, b) {
    if (f !== h || m !== v) {
      var x = g.push("translate(", null, t, null, n);
      b.push({ i: x - 4, x: kl(f, h) }, { i: x - 2, x: kl(m, v) });
    } else (h || v) && g.push("translate(" + h + t + v + n);
  }
  function l(f, m, h, v) {
    f !== m ? (f - m > 180 ? m += 360 : m - f > 180 && (f += 360), v.push({ i: h.push(a(h) + "rotate(", null, r) - 2, x: kl(f, m) })) : m && h.push(a(h) + "rotate(" + m + r);
  }
  function c(f, m, h, v) {
    f !== m ? v.push({ i: h.push(a(h) + "skewX(", null, r) - 2, x: kl(f, m) }) : m && h.push(a(h) + "skewX(" + m + r);
  }
  function d(f, m, h, v, g, b) {
    if (f !== h || m !== v) {
      var x = g.push(a(g) + "scale(", null, ",", null, ")");
      b.push({ i: x - 4, x: kl(f, h) }, { i: x - 2, x: kl(m, v) });
    } else (h !== 1 || v !== 1) && g.push(a(g) + "scale(" + h + "," + v + ")");
  }
  return function(f, m) {
    var h = [], v = [];
    return f = e(f), m = e(m), s(f.translateX, f.translateY, m.translateX, m.translateY, h, v), l(f.rotate, m.rotate, h, v), c(f.skewX, m.skewX, h, v), d(f.scaleX, f.scaleY, m.scaleX, m.scaleY, h, v), f = m = null, function(g) {
      for (var b = -1, x = v.length, w; ++b < x; ) h[(w = v[b]).i] = w.x(g);
      return h.join("");
    };
  };
}
var bwe = fW(vwe, "px, ", "px)", "deg)"), wwe = fW(ywe, ", ", ")", ")"), xwe = 1e-12;
function l6(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function Swe(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function kwe(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const L_ = (function e(t, n, r) {
  function a(s, l) {
    var c = s[0], d = s[1], f = s[2], m = l[0], h = l[1], v = l[2], g = m - c, b = h - d, x = g * g + b * b, w, k;
    if (x < xwe)
      k = Math.log(v / f) / t, w = function(R) {
        return [
          c + R * g,
          d + R * b,
          f * Math.exp(t * R * k)
        ];
      };
    else {
      var E = Math.sqrt(x), _ = (v * v - f * f + r * x) / (2 * f * n * E), O = (v * v - f * f - r * x) / (2 * v * n * E), N = Math.log(Math.sqrt(_ * _ + 1) - _), A = Math.log(Math.sqrt(O * O + 1) - O);
      k = (A - N) / t, w = function(R) {
        var D = R * k, I = l6(N), z = f / (n * E) * (I * kwe(t * D + N) - Swe(N));
        return [
          c + z * g,
          d + z * b,
          f * I / l6(t * D + N)
        ];
      };
    }
    return w.duration = k * 1e3 * t / Math.SQRT2, w;
  }
  return a.rho = function(s) {
    var l = Math.max(1e-3, +s), c = l * l, d = c * c;
    return e(l, c, d);
  }, a;
})(Math.SQRT2, 2, 4);
var wg = 0, bx = 0, Xw = 0, pW = 1e3, N2, wx, A2 = 0, Fm = 0, nC = 0, pS = typeof performance == "object" && performance.now ? performance : Date, mW = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function sj() {
  return Fm || (mW(_we), Fm = pS.now() + nC);
}
function _we() {
  Fm = 0;
}
function R2() {
  this._call = this._time = this._next = null;
}
R2.prototype = hW.prototype = {
  constructor: R2,
  restart: function(e, t, n) {
    if (typeof e != "function") throw new TypeError("callback is not a function");
    n = (n == null ? sj() : +n) + (t == null ? 0 : +t), !this._next && wx !== this && (wx ? wx._next = this : N2 = this, wx = this), this._call = e, this._time = n, k3();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, k3());
  }
};
function hW(e, t, n) {
  var r = new R2();
  return r.restart(e, t, n), r;
}
function Ewe() {
  sj(), ++wg;
  for (var e = N2, t; e; )
    (t = Fm - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --wg;
}
function u6() {
  Fm = (A2 = pS.now()) + nC, wg = bx = 0;
  try {
    Ewe();
  } finally {
    wg = 0, Owe(), Fm = 0;
  }
}
function Cwe() {
  var e = pS.now(), t = e - A2;
  t > pW && (nC -= t, A2 = e);
}
function Owe() {
  for (var e, t = N2, n, r = 1 / 0; t; )
    t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : N2 = n);
  wx = e, k3(r);
}
function k3(e) {
  if (!wg) {
    bx && (bx = clearTimeout(bx));
    var t = e - Fm;
    t > 24 ? (e < 1 / 0 && (bx = setTimeout(u6, e - pS.now() - nC)), Xw && (Xw = clearInterval(Xw))) : (Xw || (A2 = pS.now(), Xw = setInterval(Cwe, pW)), wg = 1, mW(u6));
  }
}
function c6(e, t, n) {
  var r = new R2();
  return t = t == null ? 0 : +t, r.restart((a) => {
    r.stop(), e(a + t);
  }, t, n), r;
}
var Mwe = eC("start", "end", "cancel", "interrupt"), Nwe = [], gW = 0, d6 = 1, _3 = 2, F_ = 3, f6 = 4, E3 = 5, B_ = 6;
function rC(e, t, n, r, a, s) {
  var l = e.__transition;
  if (!l) e.__transition = {};
  else if (n in l) return;
  Awe(e, n, {
    name: t,
    index: r,
    // For context during callback.
    group: a,
    // For context during callback.
    on: Mwe,
    tween: Nwe,
    time: s.time,
    delay: s.delay,
    duration: s.duration,
    ease: s.ease,
    timer: null,
    state: gW
  });
}
function lj(e, t) {
  var n = ll(e, t);
  if (n.state > gW) throw new Error("too late; already scheduled");
  return n;
}
function Jl(e, t) {
  var n = ll(e, t);
  if (n.state > F_) throw new Error("too late; already running");
  return n;
}
function ll(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t])) throw new Error("transition not found");
  return n;
}
function Awe(e, t, n) {
  var r = e.__transition, a;
  r[t] = n, n.timer = hW(s, 0, n.time);
  function s(f) {
    n.state = d6, n.timer.restart(l, n.delay, n.time), n.delay <= f && l(f - n.delay);
  }
  function l(f) {
    var m, h, v, g;
    if (n.state !== d6) return d();
    for (m in r)
      if (g = r[m], g.name === n.name) {
        if (g.state === F_) return c6(l);
        g.state === f6 ? (g.state = B_, g.timer.stop(), g.on.call("interrupt", e, e.__data__, g.index, g.group), delete r[m]) : +m < t && (g.state = B_, g.timer.stop(), g.on.call("cancel", e, e.__data__, g.index, g.group), delete r[m]);
      }
    if (c6(function() {
      n.state === F_ && (n.state = f6, n.timer.restart(c, n.delay, n.time), c(f));
    }), n.state = _3, n.on.call("start", e, e.__data__, n.index, n.group), n.state === _3) {
      for (n.state = F_, a = new Array(v = n.tween.length), m = 0, h = -1; m < v; ++m)
        (g = n.tween[m].value.call(e, e.__data__, n.index, n.group)) && (a[++h] = g);
      a.length = h + 1;
    }
  }
  function c(f) {
    for (var m = f < n.duration ? n.ease.call(null, f / n.duration) : (n.timer.restart(d), n.state = E3, 1), h = -1, v = a.length; ++h < v; )
      a[h].call(e, m);
    n.state === E3 && (n.on.call("end", e, e.__data__, n.index, n.group), d());
  }
  function d() {
    n.state = B_, n.timer.stop(), delete r[t];
    for (var f in r) return;
    delete e.__transition;
  }
}
function U_(e, t) {
  var n = e.__transition, r, a, s = !0, l;
  if (n) {
    t = t == null ? null : t + "";
    for (l in n) {
      if ((r = n[l]).name !== t) {
        s = !1;
        continue;
      }
      a = r.state > _3 && r.state < E3, r.state = B_, r.timer.stop(), r.on.call(a ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete n[l];
    }
    s && delete e.__transition;
  }
}
function Rwe(e) {
  return this.each(function() {
    U_(this, e);
  });
}
function jwe(e, t) {
  var n, r;
  return function() {
    var a = Jl(this, e), s = a.tween;
    if (s !== n) {
      r = n = s;
      for (var l = 0, c = r.length; l < c; ++l)
        if (r[l].name === t) {
          r = r.slice(), r.splice(l, 1);
          break;
        }
    }
    a.tween = r;
  };
}
function Pwe(e, t, n) {
  var r, a;
  if (typeof n != "function") throw new Error();
  return function() {
    var s = Jl(this, e), l = s.tween;
    if (l !== r) {
      a = (r = l).slice();
      for (var c = { name: t, value: n }, d = 0, f = a.length; d < f; ++d)
        if (a[d].name === t) {
          a[d] = c;
          break;
        }
      d === f && a.push(c);
    }
    s.tween = a;
  };
}
function Dwe(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var r = ll(this.node(), n).tween, a = 0, s = r.length, l; a < s; ++a)
      if ((l = r[a]).name === e)
        return l.value;
    return null;
  }
  return this.each((t == null ? jwe : Pwe)(n, e, t));
}
function uj(e, t, n) {
  var r = e._id;
  return e.each(function() {
    var a = Jl(this, r);
    (a.value || (a.value = {}))[t] = n.apply(this, arguments);
  }), function(a) {
    return ll(a, r).value[t];
  };
}
function vW(e, t) {
  var n;
  return (typeof t == "number" ? kl : t instanceof Lm ? M2 : (n = Lm(t)) ? (t = n, M2) : uW)(e, t);
}
function Iwe(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function $we(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function zwe(e, t, n) {
  var r, a = n + "", s;
  return function() {
    var l = this.getAttribute(e);
    return l === a ? null : l === r ? s : s = t(r = l, n);
  };
}
function Twe(e, t, n) {
  var r, a = n + "", s;
  return function() {
    var l = this.getAttributeNS(e.space, e.local);
    return l === a ? null : l === r ? s : s = t(r = l, n);
  };
}
function Lwe(e, t, n) {
  var r, a, s;
  return function() {
    var l, c = n(this), d;
    return c == null ? void this.removeAttribute(e) : (l = this.getAttribute(e), d = c + "", l === d ? null : l === r && d === a ? s : (a = d, s = t(r = l, c)));
  };
}
function Fwe(e, t, n) {
  var r, a, s;
  return function() {
    var l, c = n(this), d;
    return c == null ? void this.removeAttributeNS(e.space, e.local) : (l = this.getAttributeNS(e.space, e.local), d = c + "", l === d ? null : l === r && d === a ? s : (a = d, s = t(r = l, c)));
  };
}
function Bwe(e, t) {
  var n = tC(e), r = n === "transform" ? wwe : vW;
  return this.attrTween(e, typeof t == "function" ? (n.local ? Fwe : Lwe)(n, r, uj(this, "attr." + e, t)) : t == null ? (n.local ? $we : Iwe)(n) : (n.local ? Twe : zwe)(n, r, t));
}
function Uwe(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function Vwe(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function Hwe(e, t) {
  var n, r;
  function a() {
    var s = t.apply(this, arguments);
    return s !== r && (n = (r = s) && Vwe(e, s)), n;
  }
  return a._value = t, a;
}
function Wwe(e, t) {
  var n, r;
  function a() {
    var s = t.apply(this, arguments);
    return s !== r && (n = (r = s) && Uwe(e, s)), n;
  }
  return a._value = t, a;
}
function qwe(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (t == null) return this.tween(n, null);
  if (typeof t != "function") throw new Error();
  var r = tC(e);
  return this.tween(n, (r.local ? Hwe : Wwe)(r, t));
}
function Gwe(e, t) {
  return function() {
    lj(this, e).delay = +t.apply(this, arguments);
  };
}
function Kwe(e, t) {
  return t = +t, function() {
    lj(this, e).delay = t;
  };
}
function Ywe(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? Gwe : Kwe)(t, e)) : ll(this.node(), t).delay;
}
function Xwe(e, t) {
  return function() {
    Jl(this, e).duration = +t.apply(this, arguments);
  };
}
function Jwe(e, t) {
  return t = +t, function() {
    Jl(this, e).duration = t;
  };
}
function Qwe(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? Xwe : Jwe)(t, e)) : ll(this.node(), t).duration;
}
function Zwe(e, t) {
  if (typeof t != "function") throw new Error();
  return function() {
    Jl(this, e).ease = t;
  };
}
function exe(e) {
  var t = this._id;
  return arguments.length ? this.each(Zwe(t, e)) : ll(this.node(), t).ease;
}
function txe(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    Jl(this, e).ease = n;
  };
}
function nxe(e) {
  if (typeof e != "function") throw new Error();
  return this.each(txe(this._id, e));
}
function rxe(e) {
  typeof e != "function" && (e = GH(e));
  for (var t = this._groups, n = t.length, r = new Array(n), a = 0; a < n; ++a)
    for (var s = t[a], l = s.length, c = r[a] = [], d, f = 0; f < l; ++f)
      (d = s[f]) && e.call(d, d.__data__, f, s) && c.push(d);
  return new Uc(r, this._parents, this._name, this._id);
}
function oxe(e) {
  if (e._id !== this._id) throw new Error();
  for (var t = this._groups, n = e._groups, r = t.length, a = n.length, s = Math.min(r, a), l = new Array(r), c = 0; c < s; ++c)
    for (var d = t[c], f = n[c], m = d.length, h = l[c] = new Array(m), v, g = 0; g < m; ++g)
      (v = d[g] || f[g]) && (h[g] = v);
  for (; c < r; ++c)
    l[c] = t[c];
  return new Uc(l, this._parents, this._name, this._id);
}
function axe(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function ixe(e, t, n) {
  var r, a, s = axe(t) ? lj : Jl;
  return function() {
    var l = s(this, e), c = l.on;
    c !== r && (a = (r = c).copy()).on(t, n), l.on = a;
  };
}
function sxe(e, t) {
  var n = this._id;
  return arguments.length < 2 ? ll(this.node(), n).on.on(e) : this.each(ixe(n, e, t));
}
function lxe(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition) if (+n !== e) return;
    t && t.removeChild(this);
  };
}
function uxe() {
  return this.on("end.remove", lxe(this._id));
}
function cxe(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = rj(e));
  for (var r = this._groups, a = r.length, s = new Array(a), l = 0; l < a; ++l)
    for (var c = r[l], d = c.length, f = s[l] = new Array(d), m, h, v = 0; v < d; ++v)
      (m = c[v]) && (h = e.call(m, m.__data__, v, c)) && ("__data__" in m && (h.__data__ = m.__data__), f[v] = h, rC(f[v], t, n, v, f, ll(m, n)));
  return new Uc(s, this._parents, t, n);
}
function dxe(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = qH(e));
  for (var r = this._groups, a = r.length, s = [], l = [], c = 0; c < a; ++c)
    for (var d = r[c], f = d.length, m, h = 0; h < f; ++h)
      if (m = d[h]) {
        for (var v = e.call(m, m.__data__, h, d), g, b = ll(m, n), x = 0, w = v.length; x < w; ++x)
          (g = v[x]) && rC(g, t, n, x, v, b);
        s.push(v), l.push(m);
      }
  return new Uc(s, l, t, n);
}
var fxe = ck.prototype.constructor;
function pxe() {
  return new fxe(this._groups, this._parents);
}
function mxe(e, t) {
  var n, r, a;
  return function() {
    var s = bg(this, e), l = (this.style.removeProperty(e), bg(this, e));
    return s === l ? null : s === n && l === r ? a : a = t(n = s, r = l);
  };
}
function yW(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function hxe(e, t, n) {
  var r, a = n + "", s;
  return function() {
    var l = bg(this, e);
    return l === a ? null : l === r ? s : s = t(r = l, n);
  };
}
function gxe(e, t, n) {
  var r, a, s;
  return function() {
    var l = bg(this, e), c = n(this), d = c + "";
    return c == null && (d = c = (this.style.removeProperty(e), bg(this, e))), l === d ? null : l === r && d === a ? s : (a = d, s = t(r = l, c));
  };
}
function vxe(e, t) {
  var n, r, a, s = "style." + t, l = "end." + s, c;
  return function() {
    var d = Jl(this, e), f = d.on, m = d.value[s] == null ? c || (c = yW(t)) : void 0;
    (f !== n || a !== m) && (r = (n = f).copy()).on(l, a = m), d.on = r;
  };
}
function yxe(e, t, n) {
  var r = (e += "") == "transform" ? bwe : vW;
  return t == null ? this.styleTween(e, mxe(e, r)).on("end.style." + e, yW(e)) : typeof t == "function" ? this.styleTween(e, gxe(e, r, uj(this, "style." + e, t))).each(vxe(this._id, e)) : this.styleTween(e, hxe(e, r, t), n).on("end.style." + e, null);
}
function bxe(e, t, n) {
  return function(r) {
    this.style.setProperty(e, t.call(this, r), n);
  };
}
function wxe(e, t, n) {
  var r, a;
  function s() {
    var l = t.apply(this, arguments);
    return l !== a && (r = (a = l) && bxe(e, l, n)), r;
  }
  return s._value = t, s;
}
function xxe(e, t, n) {
  var r = "style." + (e += "");
  if (arguments.length < 2) return (r = this.tween(r)) && r._value;
  if (t == null) return this.tween(r, null);
  if (typeof t != "function") throw new Error();
  return this.tween(r, wxe(e, t, n ?? ""));
}
function Sxe(e) {
  return function() {
    this.textContent = e;
  };
}
function kxe(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function _xe(e) {
  return this.tween("text", typeof e == "function" ? kxe(uj(this, "text", e)) : Sxe(e == null ? "" : e + ""));
}
function Exe(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function Cxe(e) {
  var t, n;
  function r() {
    var a = e.apply(this, arguments);
    return a !== n && (t = (n = a) && Exe(a)), t;
  }
  return r._value = e, r;
}
function Oxe(e) {
  var t = "text";
  if (arguments.length < 1) return (t = this.tween(t)) && t._value;
  if (e == null) return this.tween(t, null);
  if (typeof e != "function") throw new Error();
  return this.tween(t, Cxe(e));
}
function Mxe() {
  for (var e = this._name, t = this._id, n = bW(), r = this._groups, a = r.length, s = 0; s < a; ++s)
    for (var l = r[s], c = l.length, d, f = 0; f < c; ++f)
      if (d = l[f]) {
        var m = ll(d, t);
        rC(d, e, n, f, l, {
          time: m.time + m.delay + m.duration,
          delay: 0,
          duration: m.duration,
          ease: m.ease
        });
      }
  return new Uc(r, this._parents, e, n);
}
function Nxe() {
  var e, t, n = this, r = n._id, a = n.size();
  return new Promise(function(s, l) {
    var c = { value: l }, d = { value: function() {
      --a === 0 && s();
    } };
    n.each(function() {
      var f = Jl(this, r), m = f.on;
      m !== e && (t = (e = m).copy(), t._.cancel.push(c), t._.interrupt.push(c), t._.end.push(d)), f.on = t;
    }), a === 0 && s();
  });
}
var Axe = 0;
function Uc(e, t, n, r) {
  this._groups = e, this._parents = t, this._name = n, this._id = r;
}
function bW() {
  return ++Axe;
}
var bc = ck.prototype;
Uc.prototype = {
  constructor: Uc,
  select: cxe,
  selectAll: dxe,
  selectChild: bc.selectChild,
  selectChildren: bc.selectChildren,
  filter: rxe,
  merge: oxe,
  selection: pxe,
  transition: Mxe,
  call: bc.call,
  nodes: bc.nodes,
  node: bc.node,
  size: bc.size,
  empty: bc.empty,
  each: bc.each,
  on: sxe,
  attr: Bwe,
  attrTween: qwe,
  style: yxe,
  styleTween: xxe,
  text: _xe,
  textTween: Oxe,
  remove: uxe,
  tween: Dwe,
  delay: Ywe,
  duration: Qwe,
  ease: exe,
  easeVarying: nxe,
  end: Nxe,
  [Symbol.iterator]: bc[Symbol.iterator]
};
function Rxe(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var jxe = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: Rxe
};
function Pxe(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function Dxe(e) {
  var t, n;
  e instanceof Uc ? (t = e._id, e = e._name) : (t = bW(), (n = jxe).time = sj(), e = e == null ? null : e + "");
  for (var r = this._groups, a = r.length, s = 0; s < a; ++s)
    for (var l = r[s], c = l.length, d, f = 0; f < c; ++f)
      (d = l[f]) && rC(d, e, t, f, l, n || Pxe(d, t));
  return new Uc(r, this._parents, e, t);
}
ck.prototype.interrupt = Rwe;
ck.prototype.transition = Dxe;
const f0 = (e) => () => e;
function Ixe(e, {
  sourceEvent: t,
  target: n,
  transform: r,
  dispatch: a
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    transform: { value: r, enumerable: !0, configurable: !0 },
    _: { value: a }
  });
}
function Nc(e, t, n) {
  this.k = e, this.x = t, this.y = n;
}
Nc.prototype = {
  constructor: Nc,
  scale: function(e) {
    return e === 1 ? this : new Nc(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new Nc(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var oC = new Nc(1, 0, 0);
wW.prototype = Nc.prototype;
function wW(e) {
  for (; !e.__zoom; ) if (!(e = e.parentNode)) return oC;
  return e.__zoom;
}
function i5(e) {
  e.stopImmediatePropagation();
}
function Jw(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function $xe(e) {
  return (!e.ctrlKey || e.type === "wheel") && !e.button;
}
function zxe() {
  var e = this;
  return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
}
function p6() {
  return this.__zoom || oC;
}
function Txe(e) {
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
}
function Lxe() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Fxe(e, t, n) {
  var r = e.invertX(t[0][0]) - n[0][0], a = e.invertX(t[1][0]) - n[1][0], s = e.invertY(t[0][1]) - n[0][1], l = e.invertY(t[1][1]) - n[1][1];
  return e.translate(
    a > r ? (r + a) / 2 : Math.min(0, r) || Math.max(0, a),
    l > s ? (s + l) / 2 : Math.min(0, s) || Math.max(0, l)
  );
}
function xW() {
  var e = $xe, t = zxe, n = Fxe, r = Txe, a = Lxe, s = [0, 1 / 0], l = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], c = 250, d = L_, f = eC("start", "zoom", "end"), m, h, v, g = 500, b = 150, x = 0, w = 10;
  function k(L) {
    L.property("__zoom", p6).on("wheel.zoom", D, { passive: !1 }).on("mousedown.zoom", I).on("dblclick.zoom", z).filter(a).on("touchstart.zoom", B).on("touchmove.zoom", P).on("touchend.zoom touchcancel.zoom", H).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  k.transform = function(L, G, $, K) {
    var q = L.selection ? L.selection() : L;
    q.property("__zoom", p6), L !== q ? N(L, G, $, K) : q.interrupt().each(function() {
      A(this, arguments).event(K).start().zoom(null, typeof G == "function" ? G.apply(this, arguments) : G).end();
    });
  }, k.scaleBy = function(L, G, $, K) {
    k.scaleTo(L, function() {
      var q = this.__zoom.k, Z = typeof G == "function" ? G.apply(this, arguments) : G;
      return q * Z;
    }, $, K);
  }, k.scaleTo = function(L, G, $, K) {
    k.transform(L, function() {
      var q = t.apply(this, arguments), Z = this.__zoom, V = $ == null ? O(q) : typeof $ == "function" ? $.apply(this, arguments) : $, F = Z.invert(V), Y = typeof G == "function" ? G.apply(this, arguments) : G;
      return n(_(E(Z, Y), V, F), q, l);
    }, $, K);
  }, k.translateBy = function(L, G, $, K) {
    k.transform(L, function() {
      return n(this.__zoom.translate(
        typeof G == "function" ? G.apply(this, arguments) : G,
        typeof $ == "function" ? $.apply(this, arguments) : $
      ), t.apply(this, arguments), l);
    }, null, K);
  }, k.translateTo = function(L, G, $, K, q) {
    k.transform(L, function() {
      var Z = t.apply(this, arguments), V = this.__zoom, F = K == null ? O(Z) : typeof K == "function" ? K.apply(this, arguments) : K;
      return n(oC.translate(F[0], F[1]).scale(V.k).translate(
        typeof G == "function" ? -G.apply(this, arguments) : -G,
        typeof $ == "function" ? -$.apply(this, arguments) : -$
      ), Z, l);
    }, K, q);
  };
  function E(L, G) {
    return G = Math.max(s[0], Math.min(s[1], G)), G === L.k ? L : new Nc(G, L.x, L.y);
  }
  function _(L, G, $) {
    var K = G[0] - $[0] * L.k, q = G[1] - $[1] * L.k;
    return K === L.x && q === L.y ? L : new Nc(L.k, K, q);
  }
  function O(L) {
    return [(+L[0][0] + +L[1][0]) / 2, (+L[0][1] + +L[1][1]) / 2];
  }
  function N(L, G, $, K) {
    L.on("start.zoom", function() {
      A(this, arguments).event(K).start();
    }).on("interrupt.zoom end.zoom", function() {
      A(this, arguments).event(K).end();
    }).tween("zoom", function() {
      var q = this, Z = arguments, V = A(q, Z).event(K), F = t.apply(q, Z), Y = $ == null ? O(F) : typeof $ == "function" ? $.apply(q, Z) : $, U = Math.max(F[1][0] - F[0][0], F[1][1] - F[0][1]), W = q.__zoom, J = typeof G == "function" ? G.apply(q, Z) : G, oe = d(W.invert(Y).concat(U / W.k), J.invert(Y).concat(U / J.k));
      return function(fe) {
        if (fe === 1) fe = J;
        else {
          var ie = oe(fe), ce = U / ie[2];
          fe = new Nc(ce, Y[0] - ie[0] * ce, Y[1] - ie[1] * ce);
        }
        V.zoom(null, fe);
      };
    });
  }
  function A(L, G, $) {
    return !$ && L.__zooming || new R(L, G);
  }
  function R(L, G) {
    this.that = L, this.args = G, this.active = 0, this.sourceEvent = null, this.extent = t.apply(L, G), this.taps = 0;
  }
  R.prototype = {
    event: function(L) {
      return L && (this.sourceEvent = L), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(L, G) {
      return this.mouse && L !== "mouse" && (this.mouse[1] = G.invert(this.mouse[0])), this.touch0 && L !== "touch" && (this.touch0[1] = G.invert(this.touch0[0])), this.touch1 && L !== "touch" && (this.touch1[1] = G.invert(this.touch1[0])), this.that.__zoom = G, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(L) {
      var G = _i(this.that).datum();
      f.call(
        L,
        this.that,
        new Ixe(L, {
          sourceEvent: this.sourceEvent,
          target: k,
          transform: this.that.__zoom,
          dispatch: f
        }),
        G
      );
    }
  };
  function D(L, ...G) {
    if (!e.apply(this, arguments)) return;
    var $ = A(this, G).event(L), K = this.__zoom, q = Math.max(s[0], Math.min(s[1], K.k * Math.pow(2, r.apply(this, arguments)))), Z = Hs(L);
    if ($.wheel)
      ($.mouse[0][0] !== Z[0] || $.mouse[0][1] !== Z[1]) && ($.mouse[1] = K.invert($.mouse[0] = Z)), clearTimeout($.wheel);
    else {
      if (K.k === q) return;
      $.mouse = [Z, K.invert(Z)], U_(this), $.start();
    }
    Jw(L), $.wheel = setTimeout(V, b), $.zoom("mouse", n(_(E(K, q), $.mouse[0], $.mouse[1]), $.extent, l));
    function V() {
      $.wheel = null, $.end();
    }
  }
  function I(L, ...G) {
    if (v || !e.apply(this, arguments)) return;
    var $ = L.currentTarget, K = A(this, G, !0).event(L), q = _i(L.view).on("mousemove.zoom", Y, !0).on("mouseup.zoom", U, !0), Z = Hs(L, $), V = L.clientX, F = L.clientY;
    rW(L.view), i5(L), K.mouse = [Z, this.__zoom.invert(Z)], U_(this), K.start();
    function Y(W) {
      if (Jw(W), !K.moved) {
        var J = W.clientX - V, oe = W.clientY - F;
        K.moved = J * J + oe * oe > x;
      }
      K.event(W).zoom("mouse", n(_(K.that.__zoom, K.mouse[0] = Hs(W, $), K.mouse[1]), K.extent, l));
    }
    function U(W) {
      q.on("mousemove.zoom mouseup.zoom", null), oW(W.view, K.moved), Jw(W), K.event(W).end();
    }
  }
  function z(L, ...G) {
    if (e.apply(this, arguments)) {
      var $ = this.__zoom, K = Hs(L.changedTouches ? L.changedTouches[0] : L, this), q = $.invert(K), Z = $.k * (L.shiftKey ? 0.5 : 2), V = n(_(E($, Z), K, q), t.apply(this, G), l);
      Jw(L), c > 0 ? _i(this).transition().duration(c).call(N, V, K, L) : _i(this).call(k.transform, V, K, L);
    }
  }
  function B(L, ...G) {
    if (e.apply(this, arguments)) {
      var $ = L.touches, K = $.length, q = A(this, G, L.changedTouches.length === K).event(L), Z, V, F, Y;
      for (i5(L), V = 0; V < K; ++V)
        F = $[V], Y = Hs(F, this), Y = [Y, this.__zoom.invert(Y), F.identifier], q.touch0 ? !q.touch1 && q.touch0[2] !== Y[2] && (q.touch1 = Y, q.taps = 0) : (q.touch0 = Y, Z = !0, q.taps = 1 + !!m);
      m && (m = clearTimeout(m)), Z && (q.taps < 2 && (h = Y[0], m = setTimeout(function() {
        m = null;
      }, g)), U_(this), q.start());
    }
  }
  function P(L, ...G) {
    if (this.__zooming) {
      var $ = A(this, G).event(L), K = L.changedTouches, q = K.length, Z, V, F, Y;
      for (Jw(L), Z = 0; Z < q; ++Z)
        V = K[Z], F = Hs(V, this), $.touch0 && $.touch0[2] === V.identifier ? $.touch0[0] = F : $.touch1 && $.touch1[2] === V.identifier && ($.touch1[0] = F);
      if (V = $.that.__zoom, $.touch1) {
        var U = $.touch0[0], W = $.touch0[1], J = $.touch1[0], oe = $.touch1[1], fe = (fe = J[0] - U[0]) * fe + (fe = J[1] - U[1]) * fe, ie = (ie = oe[0] - W[0]) * ie + (ie = oe[1] - W[1]) * ie;
        V = E(V, Math.sqrt(fe / ie)), F = [(U[0] + J[0]) / 2, (U[1] + J[1]) / 2], Y = [(W[0] + oe[0]) / 2, (W[1] + oe[1]) / 2];
      } else if ($.touch0) F = $.touch0[0], Y = $.touch0[1];
      else return;
      $.zoom("touch", n(_(V, F, Y), $.extent, l));
    }
  }
  function H(L, ...G) {
    if (this.__zooming) {
      var $ = A(this, G).event(L), K = L.changedTouches, q = K.length, Z, V;
      for (i5(L), v && clearTimeout(v), v = setTimeout(function() {
        v = null;
      }, g), Z = 0; Z < q; ++Z)
        V = K[Z], $.touch0 && $.touch0[2] === V.identifier ? delete $.touch0 : $.touch1 && $.touch1[2] === V.identifier && delete $.touch1;
      if ($.touch1 && !$.touch0 && ($.touch0 = $.touch1, delete $.touch1), $.touch0) $.touch0[1] = this.__zoom.invert($.touch0[0]);
      else if ($.end(), $.taps === 2 && (V = Hs(V, this), Math.hypot(h[0] - V[0], h[1] - V[1]) < w)) {
        var F = _i(this).on("dblclick.zoom");
        F && F.apply(this, arguments);
      }
    }
  }
  return k.wheelDelta = function(L) {
    return arguments.length ? (r = typeof L == "function" ? L : f0(+L), k) : r;
  }, k.filter = function(L) {
    return arguments.length ? (e = typeof L == "function" ? L : f0(!!L), k) : e;
  }, k.touchable = function(L) {
    return arguments.length ? (a = typeof L == "function" ? L : f0(!!L), k) : a;
  }, k.extent = function(L) {
    return arguments.length ? (t = typeof L == "function" ? L : f0([[+L[0][0], +L[0][1]], [+L[1][0], +L[1][1]]]), k) : t;
  }, k.scaleExtent = function(L) {
    return arguments.length ? (s[0] = +L[0], s[1] = +L[1], k) : [s[0], s[1]];
  }, k.translateExtent = function(L) {
    return arguments.length ? (l[0][0] = +L[0][0], l[1][0] = +L[1][0], l[0][1] = +L[0][1], l[1][1] = +L[1][1], k) : [[l[0][0], l[0][1]], [l[1][0], l[1][1]]];
  }, k.constrain = function(L) {
    return arguments.length ? (n = L, k) : n;
  }, k.duration = function(L) {
    return arguments.length ? (c = +L, k) : c;
  }, k.interpolate = function(L) {
    return arguments.length ? (d = L, k) : d;
  }, k.on = function() {
    var L = f.on.apply(f, arguments);
    return L === f ? k : L;
  }, k.clickDistance = function(L) {
    return arguments.length ? (x = (L = +L) * L, k) : Math.sqrt(x);
  }, k.tapDistance = function(L) {
    return arguments.length ? (w = +L, k) : w;
  }, k;
}
const Hl = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (e) => `Node type "${e}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (e) => `The old edge with id=${e} does not exist.`,
  error009: (e) => `Marker type "${e}" doesn't exist.`,
  error008: (e, { id: t, sourceHandle: n, targetHandle: r }) => `Couldn't create edge for ${e} handle id: "${e === "source" ? n : r}", edge id: ${t}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (e) => `Edge type "${e}" not found. Using fallback type "default".`,
  error012: (e) => `Node with id "${e}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
  error013: (e = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${e}/dist/style.css' or base.css to make sure everything is working properly.`,
  error014: () => "useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.",
  error015: () => "It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs."
}, mS = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
], SW = ["Enter", " ", "Escape"], kW = {
  "node.a11yDescription.default": "Press enter or space to select a node. Press delete to remove it and escape to cancel.",
  "node.a11yDescription.keyboardDisabled": "Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.",
  "node.a11yDescription.ariaLiveMessage": ({ direction: e, x: t, y: n }) => `Moved selected node ${e}. New position, x: ${t}, y: ${n}`,
  "edge.a11yDescription.default": "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.",
  // Control elements
  "controls.ariaLabel": "Control Panel",
  "controls.zoomIn.ariaLabel": "Zoom In",
  "controls.zoomOut.ariaLabel": "Zoom Out",
  "controls.fitView.ariaLabel": "Fit View",
  "controls.interactive.ariaLabel": "Toggle Interactivity",
  // Mini map
  "minimap.ariaLabel": "Mini Map",
  // Handle
  "handle.ariaLabel": "Handle"
};
var xg;
(function(e) {
  e.Strict = "strict", e.Loose = "loose";
})(xg || (xg = {}));
var jm;
(function(e) {
  e.Free = "free", e.Vertical = "vertical", e.Horizontal = "horizontal";
})(jm || (jm = {}));
var hS;
(function(e) {
  e.Partial = "partial", e.Full = "full";
})(hS || (hS = {}));
const _W = {
  inProgress: !1,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null,
  pointer: null
};
var md;
(function(e) {
  e.Bezier = "default", e.Straight = "straight", e.Step = "step", e.SmoothStep = "smoothstep", e.SimpleBezier = "simplebezier";
})(md || (md = {}));
var j2;
(function(e) {
  e.Arrow = "arrow", e.ArrowClosed = "arrowclosed";
})(j2 || (j2 = {}));
var lt;
(function(e) {
  e.Left = "left", e.Top = "top", e.Right = "right", e.Bottom = "bottom";
})(lt || (lt = {}));
const m6 = {
  [lt.Left]: lt.Right,
  [lt.Right]: lt.Left,
  [lt.Top]: lt.Bottom,
  [lt.Bottom]: lt.Top
};
function EW(e) {
  return e === null ? null : e ? "valid" : "invalid";
}
const CW = (e) => "id" in e && "source" in e && "target" in e, Bxe = (e) => "id" in e && "position" in e && !("source" in e) && !("target" in e), cj = (e) => "id" in e && "internals" in e && !("source" in e) && !("target" in e), fk = (e, t = [0, 0]) => {
  const { width: n, height: r } = Jc(e), a = e.origin ?? t, s = n * a[0], l = r * a[1];
  return {
    x: e.position.x - s,
    y: e.position.y - l
  };
}, Uxe = (e, t = { nodeOrigin: [0, 0] }) => {
  if (e.length === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  const n = e.reduce((r, a) => {
    const s = typeof a == "string";
    let l = !t.nodeLookup && !s ? a : void 0;
    t.nodeLookup && (l = s ? t.nodeLookup.get(a) : cj(a) ? a : t.nodeLookup.get(a.id));
    const c = l ? P2(l, t.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
    return aC(r, c);
  }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 });
  return iC(n);
}, pk = (e, t = {}) => {
  let n = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 }, r = !1;
  return e.forEach((a) => {
    (t.filter === void 0 || t.filter(a)) && (n = aC(n, P2(a)), r = !0);
  }), r ? iC(n) : { x: 0, y: 0, width: 0, height: 0 };
}, dj = (e, t, [n, r, a] = [0, 0, 1], s = !1, l = !1) => {
  const c = {
    ...hk(t, [n, r, a]),
    width: t.width / a,
    height: t.height / a
  }, d = [];
  for (const f of e.values()) {
    const { measured: m, selectable: h = !0, hidden: v = !1 } = f;
    if (l && !h || v)
      continue;
    const g = m.width ?? f.width ?? f.initialWidth ?? null, b = m.height ?? f.height ?? f.initialHeight ?? null, x = gS(c, kg(f)), w = (g ?? 0) * (b ?? 0), k = s && x > 0;
    (!f.internals.handleBounds || k || x >= w || f.dragging) && d.push(f);
  }
  return d;
}, Vxe = (e, t) => {
  const n = /* @__PURE__ */ new Set();
  return e.forEach((r) => {
    n.add(r.id);
  }), t.filter((r) => n.has(r.source) || n.has(r.target));
};
function Hxe(e, t) {
  const n = /* @__PURE__ */ new Map(), r = t?.nodes ? new Set(t.nodes.map((a) => a.id)) : null;
  return e.forEach((a) => {
    a.measured.width && a.measured.height && (t?.includeHiddenNodes || !a.hidden) && (!r || r.has(a.id)) && n.set(a.id, a);
  }), n;
}
async function Wxe({ nodes: e, width: t, height: n, panZoom: r, minZoom: a, maxZoom: s }, l) {
  if (e.size === 0)
    return Promise.resolve(!0);
  const c = Hxe(e, l), d = pk(c), f = fj(d, t, n, l?.minZoom ?? a, l?.maxZoom ?? s, l?.padding ?? 0.1);
  return await r.setViewport(f, {
    duration: l?.duration,
    ease: l?.ease,
    interpolate: l?.interpolate
  }), Promise.resolve(!0);
}
function OW({ nodeId: e, nextPosition: t, nodeLookup: n, nodeOrigin: r = [0, 0], nodeExtent: a, onError: s }) {
  const l = n.get(e), c = l.parentId ? n.get(l.parentId) : void 0, { x: d, y: f } = c ? c.internals.positionAbsolute : { x: 0, y: 0 }, m = l.origin ?? r;
  let h = l.extent || a;
  if (l.extent === "parent" && !l.expandParent)
    if (!c)
      s?.("005", Hl.error005());
    else {
      const g = c.measured.width, b = c.measured.height;
      g && b && (h = [
        [d, f],
        [d + g, f + b]
      ]);
    }
  else c && _g(l.extent) && (h = [
    [l.extent[0][0] + d, l.extent[0][1] + f],
    [l.extent[1][0] + d, l.extent[1][1] + f]
  ]);
  const v = _g(h) ? Bm(t, h, l.measured) : t;
  return (l.measured.width === void 0 || l.measured.height === void 0) && s?.("015", Hl.error015()), {
    position: {
      x: v.x - d + (l.measured.width ?? 0) * m[0],
      y: v.y - f + (l.measured.height ?? 0) * m[1]
    },
    positionAbsolute: v
  };
}
async function qxe({ nodesToRemove: e = [], edgesToRemove: t = [], nodes: n, edges: r, onBeforeDelete: a }) {
  const s = new Set(e.map((h) => h.id)), l = [];
  for (const h of n) {
    if (h.deletable === !1)
      continue;
    const v = s.has(h.id), g = !v && h.parentId && l.find((b) => b.id === h.parentId);
    (v || g) && l.push(h);
  }
  const c = new Set(t.map((h) => h.id)), d = r.filter((h) => h.deletable !== !1), f = Vxe(l, d);
  for (const h of d)
    c.has(h.id) && !f.find((v) => v.id === h.id) && f.push(h);
  if (!a)
    return {
      edges: f,
      nodes: l
    };
  const m = await a({
    nodes: l,
    edges: f
  });
  return typeof m == "boolean" ? m ? { edges: f, nodes: l } : { edges: [], nodes: [] } : m;
}
const Sg = (e, t = 0, n = 1) => Math.min(Math.max(e, t), n), Bm = (e = { x: 0, y: 0 }, t, n) => ({
  x: Sg(e.x, t[0][0], t[1][0] - (n?.width ?? 0)),
  y: Sg(e.y, t[0][1], t[1][1] - (n?.height ?? 0))
});
function MW(e, t, n) {
  const { width: r, height: a } = Jc(n), { x: s, y: l } = n.internals.positionAbsolute;
  return Bm(e, [
    [s, l],
    [s + r, l + a]
  ], t);
}
const h6 = (e, t, n) => e < t ? Sg(Math.abs(e - t), 1, t) / t : e > n ? -Sg(Math.abs(e - n), 1, t) / t : 0, NW = (e, t, n = 15, r = 40) => {
  const a = h6(e.x, r, t.width - r) * n, s = h6(e.y, r, t.height - r) * n;
  return [a, s];
}, aC = (e, t) => ({
  x: Math.min(e.x, t.x),
  y: Math.min(e.y, t.y),
  x2: Math.max(e.x2, t.x2),
  y2: Math.max(e.y2, t.y2)
}), C3 = ({ x: e, y: t, width: n, height: r }) => ({
  x: e,
  y: t,
  x2: e + n,
  y2: t + r
}), iC = ({ x: e, y: t, x2: n, y2: r }) => ({
  x: e,
  y: t,
  width: n - e,
  height: r - t
}), kg = (e, t = [0, 0]) => {
  const { x: n, y: r } = cj(e) ? e.internals.positionAbsolute : fk(e, t);
  return {
    x: n,
    y: r,
    width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
    height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0
  };
}, P2 = (e, t = [0, 0]) => {
  const { x: n, y: r } = cj(e) ? e.internals.positionAbsolute : fk(e, t);
  return {
    x: n,
    y: r,
    x2: n + (e.measured?.width ?? e.width ?? e.initialWidth ?? 0),
    y2: r + (e.measured?.height ?? e.height ?? e.initialHeight ?? 0)
  };
}, AW = (e, t) => iC(aC(C3(e), C3(t))), gS = (e, t) => {
  const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)), r = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y));
  return Math.ceil(n * r);
}, g6 = (e) => Ks(e.width) && Ks(e.height) && Ks(e.x) && Ks(e.y), Ks = (e) => !isNaN(e) && isFinite(e), Gxe = (e, t) => {
}, mk = (e, t = [1, 1]) => ({
  x: t[0] * Math.round(e.x / t[0]),
  y: t[1] * Math.round(e.y / t[1])
}), hk = ({ x: e, y: t }, [n, r, a], s = !1, l = [1, 1]) => {
  const c = {
    x: (e - n) / a,
    y: (t - r) / a
  };
  return s ? mk(c, l) : c;
}, D2 = ({ x: e, y: t }, [n, r, a]) => ({
  x: e * a + n,
  y: t * a + r
});
function _h(e, t) {
  if (typeof e == "number")
    return Math.floor((t - t / (1 + e)) * 0.5);
  if (typeof e == "string" && e.endsWith("px")) {
    const n = parseFloat(e);
    if (!Number.isNaN(n))
      return Math.floor(n);
  }
  if (typeof e == "string" && e.endsWith("%")) {
    const n = parseFloat(e);
    if (!Number.isNaN(n))
      return Math.floor(t * n * 0.01);
  }
  return console.error(`[React Flow] The padding value "${e}" is invalid. Please provide a number or a string with a valid unit (px or %).`), 0;
}
function Kxe(e, t, n) {
  if (typeof e == "string" || typeof e == "number") {
    const r = _h(e, n), a = _h(e, t);
    return {
      top: r,
      right: a,
      bottom: r,
      left: a,
      x: a * 2,
      y: r * 2
    };
  }
  if (typeof e == "object") {
    const r = _h(e.top ?? e.y ?? 0, n), a = _h(e.bottom ?? e.y ?? 0, n), s = _h(e.left ?? e.x ?? 0, t), l = _h(e.right ?? e.x ?? 0, t);
    return { top: r, right: l, bottom: a, left: s, x: s + l, y: r + a };
  }
  return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };
}
function Yxe(e, t, n, r, a, s) {
  const { x: l, y: c } = D2(e, [t, n, r]), { x: d, y: f } = D2({ x: e.x + e.width, y: e.y + e.height }, [t, n, r]), m = a - d, h = s - f;
  return {
    left: Math.floor(l),
    top: Math.floor(c),
    right: Math.floor(m),
    bottom: Math.floor(h)
  };
}
const fj = (e, t, n, r, a, s) => {
  const l = Kxe(s, t, n), c = (t - l.x) / e.width, d = (n - l.y) / e.height, f = Math.min(c, d), m = Sg(f, r, a), h = e.x + e.width / 2, v = e.y + e.height / 2, g = t / 2 - h * m, b = n / 2 - v * m, x = Yxe(e, g, b, m, t, n), w = {
    left: Math.min(x.left - l.left, 0),
    top: Math.min(x.top - l.top, 0),
    right: Math.min(x.right - l.right, 0),
    bottom: Math.min(x.bottom - l.bottom, 0)
  };
  return {
    x: g - w.left + w.right,
    y: b - w.top + w.bottom,
    zoom: m
  };
}, vS = () => typeof navigator < "u" && navigator?.userAgent?.indexOf("Mac") >= 0;
function _g(e) {
  return e != null && e !== "parent";
}
function Jc(e) {
  return {
    width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
    height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0
  };
}
function RW(e) {
  return (e.measured?.width ?? e.width ?? e.initialWidth) !== void 0 && (e.measured?.height ?? e.height ?? e.initialHeight) !== void 0;
}
function jW(e, t = { width: 0, height: 0 }, n, r, a) {
  const s = { ...e }, l = r.get(n);
  if (l) {
    const c = l.origin || a;
    s.x += l.internals.positionAbsolute.x - (t.width ?? 0) * c[0], s.y += l.internals.positionAbsolute.y - (t.height ?? 0) * c[1];
  }
  return s;
}
function v6(e, t) {
  if (e.size !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
}
function Xxe() {
  let e, t;
  return { promise: new Promise((n, r) => {
    e = n, t = r;
  }), resolve: e, reject: t };
}
function Jxe(e) {
  return { ...kW, ...e || {} };
}
function $x(e, { snapGrid: t = [0, 0], snapToGrid: n = !1, transform: r, containerBounds: a }) {
  const { x: s, y: l } = Ys(e), c = hk({ x: s - (a?.left ?? 0), y: l - (a?.top ?? 0) }, r), { x: d, y: f } = n ? mk(c, t) : c;
  return {
    xSnapped: d,
    ySnapped: f,
    ...c
  };
}
const pj = (e) => ({
  width: e.offsetWidth,
  height: e.offsetHeight
}), PW = (e) => e?.getRootNode?.() || window?.document, Qxe = ["INPUT", "SELECT", "TEXTAREA"];
function DW(e) {
  const t = e.composedPath?.()?.[0] || e.target;
  return t?.nodeType !== 1 ? !1 : Qxe.includes(t.nodeName) || t.hasAttribute("contenteditable") || !!t.closest(".nokey");
}
const IW = (e) => "clientX" in e, Ys = (e, t) => {
  const n = IW(e), r = n ? e.clientX : e.touches?.[0].clientX, a = n ? e.clientY : e.touches?.[0].clientY;
  return {
    x: r - (t?.left ?? 0),
    y: a - (t?.top ?? 0)
  };
}, y6 = (e, t, n, r, a) => {
  const s = t.querySelectorAll(`.${e}`);
  return !s || !s.length ? null : Array.from(s).map((l) => {
    const c = l.getBoundingClientRect();
    return {
      id: l.getAttribute("data-handleid"),
      type: e,
      nodeId: a,
      position: l.getAttribute("data-handlepos"),
      x: (c.left - n.left) / r,
      y: (c.top - n.top) / r,
      ...pj(l)
    };
  });
};
function $W({ sourceX: e, sourceY: t, targetX: n, targetY: r, sourceControlX: a, sourceControlY: s, targetControlX: l, targetControlY: c }) {
  const d = e * 0.125 + a * 0.375 + l * 0.375 + n * 0.125, f = t * 0.125 + s * 0.375 + c * 0.375 + r * 0.125, m = Math.abs(d - e), h = Math.abs(f - t);
  return [d, f, m, h];
}
function p0(e, t) {
  return e >= 0 ? 0.5 * e : t * 25 * Math.sqrt(-e);
}
function b6({ pos: e, x1: t, y1: n, x2: r, y2: a, c: s }) {
  switch (e) {
    case lt.Left:
      return [t - p0(t - r, s), n];
    case lt.Right:
      return [t + p0(r - t, s), n];
    case lt.Top:
      return [t, n - p0(n - a, s)];
    case lt.Bottom:
      return [t, n + p0(a - n, s)];
  }
}
function mj({ sourceX: e, sourceY: t, sourcePosition: n = lt.Bottom, targetX: r, targetY: a, targetPosition: s = lt.Top, curvature: l = 0.25 }) {
  const [c, d] = b6({
    pos: n,
    x1: e,
    y1: t,
    x2: r,
    y2: a,
    c: l
  }), [f, m] = b6({
    pos: s,
    x1: r,
    y1: a,
    x2: e,
    y2: t,
    c: l
  }), [h, v, g, b] = $W({
    sourceX: e,
    sourceY: t,
    targetX: r,
    targetY: a,
    sourceControlX: c,
    sourceControlY: d,
    targetControlX: f,
    targetControlY: m
  });
  return [
    `M${e},${t} C${c},${d} ${f},${m} ${r},${a}`,
    h,
    v,
    g,
    b
  ];
}
function zW({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
  const a = Math.abs(n - e) / 2, s = n < e ? n + a : n - a, l = Math.abs(r - t) / 2, c = r < t ? r + l : r - l;
  return [s, c, a, l];
}
function Zxe({ sourceNode: e, targetNode: t, selected: n = !1, zIndex: r = 0, elevateOnSelect: a = !1, zIndexMode: s = "basic" }) {
  if (s === "manual")
    return r;
  const l = a && n ? r + 1e3 : r, c = Math.max(e.parentId || a && e.selected ? e.internals.z : 0, t.parentId || a && t.selected ? t.internals.z : 0);
  return l + c;
}
function eSe({ sourceNode: e, targetNode: t, width: n, height: r, transform: a }) {
  const s = aC(P2(e), P2(t));
  s.x === s.x2 && (s.x2 += 1), s.y === s.y2 && (s.y2 += 1);
  const l = {
    x: -a[0] / a[2],
    y: -a[1] / a[2],
    width: n / a[2],
    height: r / a[2]
  };
  return gS(l, iC(s)) > 0;
}
const tSe = ({ source: e, sourceHandle: t, target: n, targetHandle: r }) => `xy-edge__${e}${t || ""}-${n}${r || ""}`, nSe = (e, t) => t.some((n) => n.source === e.source && n.target === e.target && (n.sourceHandle === e.sourceHandle || !n.sourceHandle && !e.sourceHandle) && (n.targetHandle === e.targetHandle || !n.targetHandle && !e.targetHandle)), rSe = (e, t, n = {}) => {
  if (!e.source || !e.target)
    return t;
  const r = n.getEdgeId || tSe;
  let a;
  return CW(e) ? a = { ...e } : a = {
    ...e,
    id: r(e)
  }, nSe(a, t) ? t : (a.sourceHandle === null && delete a.sourceHandle, a.targetHandle === null && delete a.targetHandle, t.concat(a));
};
function TW({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
  const [a, s, l, c] = zW({
    sourceX: e,
    sourceY: t,
    targetX: n,
    targetY: r
  });
  return [`M ${e},${t}L ${n},${r}`, a, s, l, c];
}
const w6 = {
  [lt.Left]: { x: -1, y: 0 },
  [lt.Right]: { x: 1, y: 0 },
  [lt.Top]: { x: 0, y: -1 },
  [lt.Bottom]: { x: 0, y: 1 }
}, oSe = ({ source: e, sourcePosition: t = lt.Bottom, target: n }) => t === lt.Left || t === lt.Right ? e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, x6 = (e, t) => Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
function aSe({ source: e, sourcePosition: t = lt.Bottom, target: n, targetPosition: r = lt.Top, center: a, offset: s, stepPosition: l }) {
  const c = w6[t], d = w6[r], f = { x: e.x + c.x * s, y: e.y + c.y * s }, m = { x: n.x + d.x * s, y: n.y + d.y * s }, h = oSe({
    source: f,
    sourcePosition: t,
    target: m
  }), v = h.x !== 0 ? "x" : "y", g = h[v];
  let b = [], x, w;
  const k = { x: 0, y: 0 }, E = { x: 0, y: 0 }, [, , _, O] = zW({
    sourceX: e.x,
    sourceY: e.y,
    targetX: n.x,
    targetY: n.y
  });
  if (c[v] * d[v] === -1) {
    v === "x" ? (x = a.x ?? f.x + (m.x - f.x) * l, w = a.y ?? (f.y + m.y) / 2) : (x = a.x ?? (f.x + m.x) / 2, w = a.y ?? f.y + (m.y - f.y) * l);
    const N = [
      { x, y: f.y },
      { x, y: m.y }
    ], A = [
      { x: f.x, y: w },
      { x: m.x, y: w }
    ];
    c[v] === g ? b = v === "x" ? N : A : b = v === "x" ? A : N;
  } else {
    const N = [{ x: f.x, y: m.y }], A = [{ x: m.x, y: f.y }];
    if (v === "x" ? b = c.x === g ? A : N : b = c.y === g ? N : A, t === r) {
      const B = Math.abs(e[v] - n[v]);
      if (B <= s) {
        const P = Math.min(s - 1, s - B);
        c[v] === g ? k[v] = (f[v] > e[v] ? -1 : 1) * P : E[v] = (m[v] > n[v] ? -1 : 1) * P;
      }
    }
    if (t !== r) {
      const B = v === "x" ? "y" : "x", P = c[v] === d[B], H = f[B] > m[B], L = f[B] < m[B];
      (c[v] === 1 && (!P && H || P && L) || c[v] !== 1 && (!P && L || P && H)) && (b = v === "x" ? N : A);
    }
    const R = { x: f.x + k.x, y: f.y + k.y }, D = { x: m.x + E.x, y: m.y + E.y }, I = Math.max(Math.abs(R.x - b[0].x), Math.abs(D.x - b[0].x)), z = Math.max(Math.abs(R.y - b[0].y), Math.abs(D.y - b[0].y));
    I >= z ? (x = (R.x + D.x) / 2, w = b[0].y) : (x = b[0].x, w = (R.y + D.y) / 2);
  }
  return [[
    e,
    { x: f.x + k.x, y: f.y + k.y },
    ...b,
    { x: m.x + E.x, y: m.y + E.y },
    n
  ], x, w, _, O];
}
function iSe(e, t, n, r) {
  const a = Math.min(x6(e, t) / 2, x6(t, n) / 2, r), { x: s, y: l } = t;
  if (e.x === s && s === n.x || e.y === l && l === n.y)
    return `L${s} ${l}`;
  if (e.y === l) {
    const f = e.x < n.x ? -1 : 1, m = e.y < n.y ? 1 : -1;
    return `L ${s + a * f},${l}Q ${s},${l} ${s},${l + a * m}`;
  }
  const c = e.x < n.x ? 1 : -1, d = e.y < n.y ? -1 : 1;
  return `L ${s},${l + a * d}Q ${s},${l} ${s + a * c},${l}`;
}
function O3({ sourceX: e, sourceY: t, sourcePosition: n = lt.Bottom, targetX: r, targetY: a, targetPosition: s = lt.Top, borderRadius: l = 5, centerX: c, centerY: d, offset: f = 20, stepPosition: m = 0.5 }) {
  const [h, v, g, b, x] = aSe({
    source: { x: e, y: t },
    sourcePosition: n,
    target: { x: r, y: a },
    targetPosition: s,
    center: { x: c, y: d },
    offset: f,
    stepPosition: m
  });
  return [h.reduce((w, k, E) => {
    let _ = "";
    return E > 0 && E < h.length - 1 ? _ = iSe(h[E - 1], k, h[E + 1], l) : _ = `${E === 0 ? "M" : "L"}${k.x} ${k.y}`, w += _, w;
  }, ""), v, g, b, x];
}
function S6(e) {
  return e && !!(e.internals.handleBounds || e.handles?.length) && !!(e.measured.width || e.width || e.initialWidth);
}
function sSe(e) {
  const { sourceNode: t, targetNode: n } = e;
  if (!S6(t) || !S6(n))
    return null;
  const r = t.internals.handleBounds || k6(t.handles), a = n.internals.handleBounds || k6(n.handles), s = _6(r?.source ?? [], e.sourceHandle), l = _6(
    // when connection type is loose we can define all handles as sources and connect source -> source
    e.connectionMode === xg.Strict ? a?.target ?? [] : (a?.target ?? []).concat(a?.source ?? []),
    e.targetHandle
  );
  if (!s || !l)
    return e.onError?.("008", Hl.error008(s ? "target" : "source", {
      id: e.id,
      sourceHandle: e.sourceHandle,
      targetHandle: e.targetHandle
    })), null;
  const c = s?.position || lt.Bottom, d = l?.position || lt.Top, f = Um(t, s, c), m = Um(n, l, d);
  return {
    sourceX: f.x,
    sourceY: f.y,
    targetX: m.x,
    targetY: m.y,
    sourcePosition: c,
    targetPosition: d
  };
}
function k6(e) {
  if (!e)
    return null;
  const t = [], n = [];
  for (const r of e)
    r.width = r.width ?? 1, r.height = r.height ?? 1, r.type === "source" ? t.push(r) : r.type === "target" && n.push(r);
  return {
    source: t,
    target: n
  };
}
function Um(e, t, n = lt.Left, r = !1) {
  const a = (t?.x ?? 0) + e.internals.positionAbsolute.x, s = (t?.y ?? 0) + e.internals.positionAbsolute.y, { width: l, height: c } = t ?? Jc(e);
  if (r)
    return { x: a + l / 2, y: s + c / 2 };
  switch (t?.position ?? n) {
    case lt.Top:
      return { x: a + l / 2, y: s };
    case lt.Right:
      return { x: a + l, y: s + c / 2 };
    case lt.Bottom:
      return { x: a + l / 2, y: s + c };
    case lt.Left:
      return { x: a, y: s + c / 2 };
  }
}
function _6(e, t) {
  return e && (t ? e.find((n) => n.id === t) : e[0]) || null;
}
function M3(e, t) {
  return e ? typeof e == "string" ? e : `${t ? `${t}__` : ""}${Object.keys(e).sort().map((n) => `${n}=${e[n]}`).join("&")}` : "";
}
function lSe(e, { id: t, defaultColor: n, defaultMarkerStart: r, defaultMarkerEnd: a }) {
  const s = /* @__PURE__ */ new Set();
  return e.reduce((l, c) => ([c.markerStart || r, c.markerEnd || a].forEach((d) => {
    if (d && typeof d == "object") {
      const f = M3(d, t);
      s.has(f) || (l.push({ id: f, color: d.color || n, ...d }), s.add(f));
    }
  }), l), []).sort((l, c) => l.id.localeCompare(c.id));
}
const LW = 1e3, uSe = 10, hj = {
  nodeOrigin: [0, 0],
  nodeExtent: mS,
  elevateNodesOnSelect: !0,
  zIndexMode: "basic",
  defaults: {}
}, cSe = {
  ...hj,
  checkEquality: !0
};
function gj(e, t) {
  const n = { ...e };
  for (const r in t)
    t[r] !== void 0 && (n[r] = t[r]);
  return n;
}
function dSe(e, t, n) {
  const r = gj(hj, n);
  for (const a of e.values())
    if (a.parentId)
      yj(a, e, t, r);
    else {
      const s = fk(a, r.nodeOrigin), l = _g(a.extent) ? a.extent : r.nodeExtent, c = Bm(s, l, Jc(a));
      a.internals.positionAbsolute = c;
    }
}
function fSe(e, t) {
  if (!e.handles)
    return e.measured ? t?.internals.handleBounds : void 0;
  const n = [], r = [];
  for (const a of e.handles) {
    const s = {
      id: a.id,
      width: a.width ?? 1,
      height: a.height ?? 1,
      nodeId: e.id,
      x: a.x,
      y: a.y,
      position: a.position,
      type: a.type
    };
    a.type === "source" ? n.push(s) : a.type === "target" && r.push(s);
  }
  return {
    source: n,
    target: r
  };
}
function vj(e) {
  return e === "manual";
}
function N3(e, t, n, r = {}) {
  const a = gj(cSe, r), s = { i: 0 }, l = new Map(t), c = a?.elevateNodesOnSelect && !vj(a.zIndexMode) ? LW : 0;
  let d = e.length > 0;
  t.clear(), n.clear();
  for (const f of e) {
    let m = l.get(f.id);
    if (a.checkEquality && f === m?.internals.userNode)
      t.set(f.id, m);
    else {
      const h = fk(f, a.nodeOrigin), v = _g(f.extent) ? f.extent : a.nodeExtent, g = Bm(h, v, Jc(f));
      m = {
        ...a.defaults,
        ...f,
        measured: {
          width: f.measured?.width,
          height: f.measured?.height
        },
        internals: {
          positionAbsolute: g,
          // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
          handleBounds: fSe(f, m),
          z: FW(f, c, a.zIndexMode),
          userNode: f
        }
      }, t.set(f.id, m);
    }
    (m.measured === void 0 || m.measured.width === void 0 || m.measured.height === void 0) && !m.hidden && (d = !1), f.parentId && yj(m, t, n, r, s);
  }
  return d;
}
function pSe(e, t) {
  if (!e.parentId)
    return;
  const n = t.get(e.parentId);
  n ? n.set(e.id, e) : t.set(e.parentId, /* @__PURE__ */ new Map([[e.id, e]]));
}
function yj(e, t, n, r, a) {
  const { elevateNodesOnSelect: s, nodeOrigin: l, nodeExtent: c, zIndexMode: d } = gj(hj, r), f = e.parentId, m = t.get(f);
  if (!m) {
    console.warn(`Parent node ${f} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
    return;
  }
  pSe(e, n), a && !m.parentId && m.internals.rootParentIndex === void 0 && d === "auto" && (m.internals.rootParentIndex = ++a.i, m.internals.z = m.internals.z + a.i * uSe), a && m.internals.rootParentIndex !== void 0 && (a.i = m.internals.rootParentIndex);
  const h = s && !vj(d) ? LW : 0, { x: v, y: g, z: b } = mSe(e, m, l, c, h, d), { positionAbsolute: x } = e.internals, w = v !== x.x || g !== x.y;
  (w || b !== e.internals.z) && t.set(e.id, {
    ...e,
    internals: {
      ...e.internals,
      positionAbsolute: w ? { x: v, y: g } : x,
      z: b
    }
  });
}
function FW(e, t, n) {
  const r = Ks(e.zIndex) ? e.zIndex : 0;
  return vj(n) ? r : r + (e.selected ? t : 0);
}
function mSe(e, t, n, r, a, s) {
  const { x: l, y: c } = t.internals.positionAbsolute, d = Jc(e), f = fk(e, n), m = _g(e.extent) ? Bm(f, e.extent, d) : f;
  let h = Bm({ x: l + m.x, y: c + m.y }, r, d);
  e.extent === "parent" && (h = MW(h, d, t));
  const v = FW(e, a, s), g = t.internals.z ?? 0;
  return {
    x: h.x,
    y: h.y,
    z: g >= v ? g + 1 : v
  };
}
function bj(e, t, n, r = [0, 0]) {
  const a = [], s = /* @__PURE__ */ new Map();
  for (const l of e) {
    const c = t.get(l.parentId);
    if (!c)
      continue;
    const d = s.get(l.parentId)?.expandedRect ?? kg(c), f = AW(d, l.rect);
    s.set(l.parentId, { expandedRect: f, parent: c });
  }
  return s.size > 0 && s.forEach(({ expandedRect: l, parent: c }, d) => {
    const f = c.internals.positionAbsolute, m = Jc(c), h = c.origin ?? r, v = l.x < f.x ? Math.round(Math.abs(f.x - l.x)) : 0, g = l.y < f.y ? Math.round(Math.abs(f.y - l.y)) : 0, b = Math.max(m.width, Math.round(l.width)), x = Math.max(m.height, Math.round(l.height)), w = (b - m.width) * h[0], k = (x - m.height) * h[1];
    (v > 0 || g > 0 || w || k) && (a.push({
      id: d,
      type: "position",
      position: {
        x: c.position.x - v + w,
        y: c.position.y - g + k
      }
    }), n.get(d)?.forEach((E) => {
      e.some((_) => _.id === E.id) || a.push({
        id: E.id,
        type: "position",
        position: {
          x: E.position.x + v,
          y: E.position.y + g
        }
      });
    })), (m.width < l.width || m.height < l.height || v || g) && a.push({
      id: d,
      type: "dimensions",
      setAttributes: !0,
      dimensions: {
        width: b + (v ? h[0] * v - w : 0),
        height: x + (g ? h[1] * g - k : 0)
      }
    });
  }), a;
}
function hSe(e, t, n, r, a, s, l) {
  const c = r?.querySelector(".xyflow__viewport");
  let d = !1;
  if (!c)
    return { changes: [], updatedInternals: d };
  const f = [], m = window.getComputedStyle(c), { m22: h } = new window.DOMMatrixReadOnly(m.transform), v = [];
  for (const g of e.values()) {
    const b = t.get(g.id);
    if (!b)
      continue;
    if (b.hidden) {
      t.set(b.id, {
        ...b,
        internals: {
          ...b.internals,
          handleBounds: void 0
        }
      }), d = !0;
      continue;
    }
    const x = pj(g.nodeElement), w = b.measured.width !== x.width || b.measured.height !== x.height;
    if (x.width && x.height && (w || !b.internals.handleBounds || g.force)) {
      const k = g.nodeElement.getBoundingClientRect(), E = _g(b.extent) ? b.extent : s;
      let { positionAbsolute: _ } = b.internals;
      b.parentId && b.extent === "parent" ? _ = MW(_, x, t.get(b.parentId)) : E && (_ = Bm(_, E, x));
      const O = {
        ...b,
        measured: x,
        internals: {
          ...b.internals,
          positionAbsolute: _,
          handleBounds: {
            source: y6("source", g.nodeElement, k, h, b.id),
            target: y6("target", g.nodeElement, k, h, b.id)
          }
        }
      };
      t.set(b.id, O), b.parentId && yj(O, t, n, { nodeOrigin: a, zIndexMode: l }), d = !0, w && (f.push({
        id: b.id,
        type: "dimensions",
        dimensions: x
      }), b.expandParent && b.parentId && v.push({
        id: b.id,
        parentId: b.parentId,
        rect: kg(O, a)
      }));
    }
  }
  if (v.length > 0) {
    const g = bj(v, t, n, a);
    f.push(...g);
  }
  return { changes: f, updatedInternals: d };
}
async function gSe({ delta: e, panZoom: t, transform: n, translateExtent: r, width: a, height: s }) {
  if (!t || !e.x && !e.y)
    return Promise.resolve(!1);
  const l = await t.setViewportConstrained({
    x: n[0] + e.x,
    y: n[1] + e.y,
    zoom: n[2]
  }, [
    [0, 0],
    [a, s]
  ], r), c = !!l && (l.x !== n[0] || l.y !== n[1] || l.k !== n[2]);
  return Promise.resolve(c);
}
function E6(e, t, n, r, a, s) {
  let l = a;
  const c = r.get(l) || /* @__PURE__ */ new Map();
  r.set(l, c.set(n, t)), l = `${a}-${e}`;
  const d = r.get(l) || /* @__PURE__ */ new Map();
  if (r.set(l, d.set(n, t)), s) {
    l = `${a}-${e}-${s}`;
    const f = r.get(l) || /* @__PURE__ */ new Map();
    r.set(l, f.set(n, t));
  }
}
function BW(e, t, n) {
  e.clear(), t.clear();
  for (const r of n) {
    const { source: a, target: s, sourceHandle: l = null, targetHandle: c = null } = r, d = { edgeId: r.id, source: a, target: s, sourceHandle: l, targetHandle: c }, f = `${a}-${l}--${s}-${c}`, m = `${s}-${c}--${a}-${l}`;
    E6("source", d, m, e, a, l), E6("target", d, f, e, s, c), t.set(r.id, r);
  }
}
function UW(e, t) {
  if (!e.parentId)
    return !1;
  const n = t.get(e.parentId);
  return n ? n.selected ? !0 : UW(n, t) : !1;
}
function C6(e, t, n) {
  let r = e;
  do {
    if (r?.matches?.(t))
      return !0;
    if (r === n)
      return !1;
    r = r?.parentElement;
  } while (r);
  return !1;
}
function vSe(e, t, n, r) {
  const a = /* @__PURE__ */ new Map();
  for (const [s, l] of e)
    if ((l.selected || l.id === r) && (!l.parentId || !UW(l, e)) && (l.draggable || t && typeof l.draggable > "u")) {
      const c = e.get(s);
      c && a.set(s, {
        id: s,
        position: c.position || { x: 0, y: 0 },
        distance: {
          x: n.x - c.internals.positionAbsolute.x,
          y: n.y - c.internals.positionAbsolute.y
        },
        extent: c.extent,
        parentId: c.parentId,
        origin: c.origin,
        expandParent: c.expandParent,
        internals: {
          positionAbsolute: c.internals.positionAbsolute || { x: 0, y: 0 }
        },
        measured: {
          width: c.measured.width ?? 0,
          height: c.measured.height ?? 0
        }
      });
    }
  return a;
}
function s5({ nodeId: e, dragItems: t, nodeLookup: n, dragging: r = !0 }) {
  const a = [];
  for (const [l, c] of t) {
    const d = n.get(l)?.internals.userNode;
    d && a.push({
      ...d,
      position: c.position,
      dragging: r
    });
  }
  if (!e)
    return [a[0], a];
  const s = n.get(e)?.internals.userNode;
  return [
    s ? {
      ...s,
      position: t.get(e)?.position || s.position,
      dragging: r
    } : a[0],
    a
  ];
}
function ySe({ dragItems: e, snapGrid: t, x: n, y: r }) {
  const a = e.values().next().value;
  if (!a)
    return null;
  const s = {
    x: n - a.distance.x,
    y: r - a.distance.y
  }, l = mk(s, t);
  return {
    x: l.x - s.x,
    y: l.y - s.y
  };
}
function bSe({ onNodeMouseDown: e, getStoreItems: t, onDragStart: n, onDrag: r, onDragStop: a }) {
  let s = { x: null, y: null }, l = 0, c = /* @__PURE__ */ new Map(), d = !1, f = { x: 0, y: 0 }, m = null, h = !1, v = null, g = !1, b = !1, x = null;
  function w({ noDragClassName: E, handleSelector: _, domNode: O, isSelectable: N, nodeId: A, nodeClickDistance: R = 0 }) {
    v = _i(O);
    function D({ x: P, y: H }) {
      const { nodeLookup: L, nodeExtent: G, snapGrid: $, snapToGrid: K, nodeOrigin: q, onNodeDrag: Z, onSelectionDrag: V, onError: F, updateNodePositions: Y } = t();
      s = { x: P, y: H };
      let U = !1;
      const W = c.size > 1, J = W && G ? C3(pk(c)) : null, oe = W && K ? ySe({
        dragItems: c,
        snapGrid: $,
        x: P,
        y: H
      }) : null;
      for (const [fe, ie] of c) {
        if (!L.has(fe))
          continue;
        let ce = { x: P - ie.distance.x, y: H - ie.distance.y };
        K && (ce = oe ? {
          x: Math.round(ce.x + oe.x),
          y: Math.round(ce.y + oe.y)
        } : mk(ce, $));
        let ge = null;
        if (W && G && !ie.extent && J) {
          const { positionAbsolute: me } = ie.internals, ve = me.x - J.x + G[0][0], xe = me.x + ie.measured.width - J.x2 + G[1][0], _e = me.y - J.y + G[0][1], Ge = me.y + ie.measured.height - J.y2 + G[1][1];
          ge = [
            [ve, _e],
            [xe, Ge]
          ];
        }
        const { position: re, positionAbsolute: le } = OW({
          nodeId: fe,
          nextPosition: ce,
          nodeLookup: L,
          nodeExtent: ge || G,
          nodeOrigin: q,
          onError: F
        });
        U = U || ie.position.x !== re.x || ie.position.y !== re.y, ie.position = re, ie.internals.positionAbsolute = le;
      }
      if (b = b || U, !!U && (Y(c, !0), x && (r || Z || !A && V))) {
        const [fe, ie] = s5({
          nodeId: A,
          dragItems: c,
          nodeLookup: L
        });
        r?.(x, c, fe, ie), Z?.(x, fe, ie), A || V?.(x, ie);
      }
    }
    async function I() {
      if (!m)
        return;
      const { transform: P, panBy: H, autoPanSpeed: L, autoPanOnNodeDrag: G } = t();
      if (!G) {
        d = !1, cancelAnimationFrame(l);
        return;
      }
      const [$, K] = NW(f, m, L);
      ($ !== 0 || K !== 0) && (s.x = (s.x ?? 0) - $ / P[2], s.y = (s.y ?? 0) - K / P[2], await H({ x: $, y: K }) && D(s)), l = requestAnimationFrame(I);
    }
    function z(P) {
      const { nodeLookup: H, multiSelectionActive: L, nodesDraggable: G, transform: $, snapGrid: K, snapToGrid: q, selectNodesOnDrag: Z, onNodeDragStart: V, onSelectionDragStart: F, unselectNodesAndEdges: Y } = t();
      h = !0, (!Z || !N) && !L && A && (H.get(A)?.selected || Y()), N && Z && A && e?.(A);
      const U = $x(P.sourceEvent, { transform: $, snapGrid: K, snapToGrid: q, containerBounds: m });
      if (s = U, c = vSe(H, G, U, A), c.size > 0 && (n || V || !A && F)) {
        const [W, J] = s5({
          nodeId: A,
          dragItems: c,
          nodeLookup: H
        });
        n?.(P.sourceEvent, c, W, J), V?.(P.sourceEvent, W, J), A || F?.(P.sourceEvent, J);
      }
    }
    const B = aW().clickDistance(R).on("start", (P) => {
      const { domNode: H, nodeDragThreshold: L, transform: G, snapGrid: $, snapToGrid: K } = t();
      m = H?.getBoundingClientRect() || null, g = !1, b = !1, x = P.sourceEvent, L === 0 && z(P), s = $x(P.sourceEvent, { transform: G, snapGrid: $, snapToGrid: K, containerBounds: m }), f = Ys(P.sourceEvent, m);
    }).on("drag", (P) => {
      const { autoPanOnNodeDrag: H, transform: L, snapGrid: G, snapToGrid: $, nodeDragThreshold: K, nodeLookup: q } = t(), Z = $x(P.sourceEvent, { transform: L, snapGrid: G, snapToGrid: $, containerBounds: m });
      if (x = P.sourceEvent, (P.sourceEvent.type === "touchmove" && P.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors
      A && !q.has(A)) && (g = !0), !g) {
        if (!d && H && h && (d = !0, I()), !h) {
          const V = Ys(P.sourceEvent, m), F = V.x - f.x, Y = V.y - f.y;
          Math.sqrt(F * F + Y * Y) > K && z(P);
        }
        (s.x !== Z.xSnapped || s.y !== Z.ySnapped) && c && h && (f = Ys(P.sourceEvent, m), D(Z));
      }
    }).on("end", (P) => {
      if (!(!h || g) && (d = !1, h = !1, cancelAnimationFrame(l), c.size > 0)) {
        const { nodeLookup: H, updateNodePositions: L, onNodeDragStop: G, onSelectionDragStop: $ } = t();
        if (b && (L(c, !1), b = !1), a || G || !A && $) {
          const [K, q] = s5({
            nodeId: A,
            dragItems: c,
            nodeLookup: H,
            dragging: !1
          });
          a?.(P.sourceEvent, c, K, q), G?.(P.sourceEvent, K, q), A || $?.(P.sourceEvent, q);
        }
      }
    }).filter((P) => {
      const H = P.target;
      return !P.button && (!E || !C6(H, `.${E}`, O)) && (!_ || C6(H, _, O));
    });
    v.call(B);
  }
  function k() {
    v?.on(".drag", null);
  }
  return {
    update: w,
    destroy: k
  };
}
function wSe(e, t, n) {
  const r = [], a = {
    x: e.x - n,
    y: e.y - n,
    width: n * 2,
    height: n * 2
  };
  for (const s of t.values())
    gS(a, kg(s)) > 0 && r.push(s);
  return r;
}
const xSe = 250;
function SSe(e, t, n, r) {
  let a = [], s = 1 / 0;
  const l = wSe(e, n, t + xSe);
  for (const c of l) {
    const d = [...c.internals.handleBounds?.source ?? [], ...c.internals.handleBounds?.target ?? []];
    for (const f of d) {
      if (r.nodeId === f.nodeId && r.type === f.type && r.id === f.id)
        continue;
      const { x: m, y: h } = Um(c, f, f.position, !0), v = Math.sqrt(Math.pow(m - e.x, 2) + Math.pow(h - e.y, 2));
      v > t || (v < s ? (a = [{ ...f, x: m, y: h }], s = v) : v === s && a.push({ ...f, x: m, y: h }));
    }
  }
  if (!a.length)
    return null;
  if (a.length > 1) {
    const c = r.type === "source" ? "target" : "source";
    return a.find((d) => d.type === c) ?? a[0];
  }
  return a[0];
}
function VW(e, t, n, r, a, s = !1) {
  const l = r.get(e);
  if (!l)
    return null;
  const c = a === "strict" ? l.internals.handleBounds?.[t] : [...l.internals.handleBounds?.source ?? [], ...l.internals.handleBounds?.target ?? []], d = (n ? c?.find((f) => f.id === n) : c?.[0]) ?? null;
  return d && s ? { ...d, ...Um(l, d, d.position, !0) } : d;
}
function HW(e, t) {
  return e || (t?.classList.contains("target") ? "target" : t?.classList.contains("source") ? "source" : null);
}
function kSe(e, t) {
  let n = null;
  return t ? n = !0 : e && !t && (n = !1), n;
}
const WW = () => !0;
function _Se(e, { connectionMode: t, connectionRadius: n, handleId: r, nodeId: a, edgeUpdaterType: s, isTarget: l, domNode: c, nodeLookup: d, lib: f, autoPanOnConnect: m, flowId: h, panBy: v, cancelConnection: g, onConnectStart: b, onConnect: x, onConnectEnd: w, isValidConnection: k = WW, onReconnectEnd: E, updateConnection: _, getTransform: O, getFromHandle: N, autoPanSpeed: A, dragThreshold: R = 1, handleDomNode: D }) {
  const I = PW(e.target);
  let z = 0, B;
  const { x: P, y: H } = Ys(e), L = HW(s, D), G = c?.getBoundingClientRect();
  let $ = !1;
  if (!G || !L)
    return;
  const K = VW(a, L, r, d, t);
  if (!K)
    return;
  let q = Ys(e, G), Z = !1, V = null, F = !1, Y = null;
  function U() {
    if (!m || !G)
      return;
    const [ge, re] = NW(q, G, A);
    v({ x: ge, y: re }), z = requestAnimationFrame(U);
  }
  const W = {
    ...K,
    nodeId: a,
    type: L,
    position: K.position
  }, J = d.get(a);
  let oe = {
    inProgress: !0,
    isValid: null,
    from: Um(J, W, lt.Left, !0),
    fromHandle: W,
    fromPosition: W.position,
    fromNode: J,
    to: q,
    toHandle: null,
    toPosition: m6[W.position],
    toNode: null,
    pointer: q
  };
  function fe() {
    $ = !0, _(oe), b?.(e, { nodeId: a, handleId: r, handleType: L });
  }
  R === 0 && fe();
  function ie(ge) {
    if (!$) {
      const { x: _e, y: Ge } = Ys(ge), Xe = _e - P, tt = Ge - H;
      if (!(Xe * Xe + tt * tt > R * R))
        return;
      fe();
    }
    if (!N() || !W) {
      ce(ge);
      return;
    }
    const re = O();
    q = Ys(ge, G), B = SSe(hk(q, re, !1, [1, 1]), n, d, W), Z || (U(), Z = !0);
    const le = qW(ge, {
      handle: B,
      connectionMode: t,
      fromNodeId: a,
      fromHandleId: r,
      fromType: l ? "target" : "source",
      isValidConnection: k,
      doc: I,
      lib: f,
      flowId: h,
      nodeLookup: d
    });
    Y = le.handleDomNode, V = le.connection, F = kSe(!!B, le.isValid);
    const me = d.get(a), ve = me ? Um(me, W, lt.Left, !0) : oe.from, xe = {
      ...oe,
      from: ve,
      isValid: F,
      to: le.toHandle && F ? D2({ x: le.toHandle.x, y: le.toHandle.y }, re) : q,
      toHandle: le.toHandle,
      toPosition: F && le.toHandle ? le.toHandle.position : m6[W.position],
      toNode: le.toHandle ? d.get(le.toHandle.nodeId) : null,
      pointer: q
    };
    _(xe), oe = xe;
  }
  function ce(ge) {
    if (!("touches" in ge && ge.touches.length > 0)) {
      if ($) {
        (B || Y) && V && F && x?.(V);
        const { inProgress: re, ...le } = oe, me = {
          ...le,
          toPosition: oe.toHandle ? oe.toPosition : null
        };
        w?.(ge, me), s && E?.(ge, me);
      }
      g(), cancelAnimationFrame(z), Z = !1, F = !1, V = null, Y = null, I.removeEventListener("mousemove", ie), I.removeEventListener("mouseup", ce), I.removeEventListener("touchmove", ie), I.removeEventListener("touchend", ce);
    }
  }
  I.addEventListener("mousemove", ie), I.addEventListener("mouseup", ce), I.addEventListener("touchmove", ie), I.addEventListener("touchend", ce);
}
function qW(e, { handle: t, connectionMode: n, fromNodeId: r, fromHandleId: a, fromType: s, doc: l, lib: c, flowId: d, isValidConnection: f = WW, nodeLookup: m }) {
  const h = s === "target", v = t ? l.querySelector(`.${c}-flow__handle[data-id="${d}-${t?.nodeId}-${t?.id}-${t?.type}"]`) : null, { x: g, y: b } = Ys(e), x = l.elementFromPoint(g, b), w = x?.classList.contains(`${c}-flow__handle`) ? x : v, k = {
    handleDomNode: w,
    isValid: !1,
    connection: null,
    toHandle: null
  };
  if (w) {
    const E = HW(void 0, w), _ = w.getAttribute("data-nodeid"), O = w.getAttribute("data-handleid"), N = w.classList.contains("connectable"), A = w.classList.contains("connectableend");
    if (!_ || !E)
      return k;
    const R = {
      source: h ? _ : r,
      sourceHandle: h ? O : a,
      target: h ? r : _,
      targetHandle: h ? a : O
    };
    k.connection = R;
    const D = N && A && (n === xg.Strict ? h && E === "source" || !h && E === "target" : _ !== r || O !== a);
    k.isValid = D && f(R), k.toHandle = VW(_, E, O, m, n, !0);
  }
  return k;
}
const A3 = {
  onPointerDown: _Se,
  isValid: qW
};
function ESe({ domNode: e, panZoom: t, getTransform: n, getViewScale: r }) {
  const a = _i(e);
  function s({ translateExtent: c, width: d, height: f, zoomStep: m = 1, pannable: h = !0, zoomable: v = !0, inversePan: g = !1 }) {
    const b = (_) => {
      if (_.sourceEvent.type !== "wheel" || !t)
        return;
      const O = n(), N = _.sourceEvent.ctrlKey && vS() ? 10 : 1, A = -_.sourceEvent.deltaY * (_.sourceEvent.deltaMode === 1 ? 0.05 : _.sourceEvent.deltaMode ? 1 : 2e-3) * m, R = O[2] * Math.pow(2, A * N);
      t.scaleTo(R);
    };
    let x = [0, 0];
    const w = (_) => {
      (_.sourceEvent.type === "mousedown" || _.sourceEvent.type === "touchstart") && (x = [
        _.sourceEvent.clientX ?? _.sourceEvent.touches[0].clientX,
        _.sourceEvent.clientY ?? _.sourceEvent.touches[0].clientY
      ]);
    }, k = (_) => {
      const O = n();
      if (_.sourceEvent.type !== "mousemove" && _.sourceEvent.type !== "touchmove" || !t)
        return;
      const N = [
        _.sourceEvent.clientX ?? _.sourceEvent.touches[0].clientX,
        _.sourceEvent.clientY ?? _.sourceEvent.touches[0].clientY
      ], A = [N[0] - x[0], N[1] - x[1]];
      x = N;
      const R = r() * Math.max(O[2], Math.log(O[2])) * (g ? -1 : 1), D = {
        x: O[0] - A[0] * R,
        y: O[1] - A[1] * R
      }, I = [
        [0, 0],
        [d, f]
      ];
      t.setViewportConstrained({
        x: D.x,
        y: D.y,
        zoom: O[2]
      }, I, c);
    }, E = xW().on("start", w).on("zoom", h ? k : null).on("zoom.wheel", v ? b : null);
    a.call(E, {});
  }
  function l() {
    a.on("zoom", null);
  }
  return {
    update: s,
    destroy: l,
    pointer: Hs
  };
}
const sC = (e) => ({
  x: e.x,
  y: e.y,
  zoom: e.k
}), l5 = ({ x: e, y: t, zoom: n }) => oC.translate(e, t).scale(n), Hh = (e, t) => e.target.closest(`.${t}`), GW = (e, t) => t === 2 && Array.isArray(e) && e.includes(2), CSe = (e) => ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2, u5 = (e, t = 0, n = CSe, r = () => {
}) => {
  const a = typeof t == "number" && t > 0;
  return a || r(), a ? e.transition().duration(t).ease(n).on("end", r) : e;
}, KW = (e) => {
  const t = e.ctrlKey && vS() ? 10 : 1;
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * t;
};
function OSe({ zoomPanValues: e, noWheelClassName: t, d3Selection: n, d3Zoom: r, panOnScrollMode: a, panOnScrollSpeed: s, zoomOnPinch: l, onPanZoomStart: c, onPanZoom: d, onPanZoomEnd: f }) {
  return (m) => {
    if (Hh(m, t))
      return m.ctrlKey && m.preventDefault(), !1;
    m.preventDefault(), m.stopImmediatePropagation();
    const h = n.property("__zoom").k || 1;
    if (m.ctrlKey && l) {
      const w = Hs(m), k = KW(m), E = h * Math.pow(2, k);
      r.scaleTo(n, E, w, m);
      return;
    }
    const v = m.deltaMode === 1 ? 20 : 1;
    let g = a === jm.Vertical ? 0 : m.deltaX * v, b = a === jm.Horizontal ? 0 : m.deltaY * v;
    !vS() && m.shiftKey && a !== jm.Vertical && (g = m.deltaY * v, b = 0), r.translateBy(
      n,
      -(g / h) * s,
      -(b / h) * s,
      // @ts-ignore
      { internal: !0 }
    );
    const x = sC(n.property("__zoom"));
    clearTimeout(e.panScrollTimeout), e.isPanScrolling ? (d?.(m, x), e.panScrollTimeout = setTimeout(() => {
      f?.(m, x), e.isPanScrolling = !1;
    }, 150)) : (e.isPanScrolling = !0, c?.(m, x));
  };
}
function MSe({ noWheelClassName: e, preventScrolling: t, d3ZoomHandler: n }) {
  return function(r, a) {
    const s = r.type === "wheel", l = !t && s && !r.ctrlKey, c = Hh(r, e);
    if (r.ctrlKey && s && c && r.preventDefault(), l || c)
      return null;
    r.preventDefault(), n.call(this, r, a);
  };
}
function NSe({ zoomPanValues: e, onDraggingChange: t, onPanZoomStart: n }) {
  return (r) => {
    if (r.sourceEvent?.internal)
      return;
    const a = sC(r.transform);
    e.mouseButton = r.sourceEvent?.button || 0, e.isZoomingOrPanning = !0, e.prevViewport = a, r.sourceEvent?.type === "mousedown" && t(!0), n && n?.(r.sourceEvent, a);
  };
}
function ASe({ zoomPanValues: e, panOnDrag: t, onPaneContextMenu: n, onTransformChange: r, onPanZoom: a }) {
  return (s) => {
    e.usedRightMouseButton = !!(n && GW(t, e.mouseButton ?? 0)), s.sourceEvent?.sync || r([s.transform.x, s.transform.y, s.transform.k]), a && !s.sourceEvent?.internal && a?.(s.sourceEvent, sC(s.transform));
  };
}
function RSe({ zoomPanValues: e, panOnDrag: t, panOnScroll: n, onDraggingChange: r, onPanZoomEnd: a, onPaneContextMenu: s }) {
  return (l) => {
    if (!l.sourceEvent?.internal && (e.isZoomingOrPanning = !1, s && GW(t, e.mouseButton ?? 0) && !e.usedRightMouseButton && l.sourceEvent && s(l.sourceEvent), e.usedRightMouseButton = !1, r(!1), a)) {
      const c = sC(l.transform);
      e.prevViewport = c, clearTimeout(e.timerId), e.timerId = setTimeout(
        () => {
          a?.(l.sourceEvent, c);
        },
        // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
        n ? 150 : 0
      );
    }
  };
}
function jSe({ zoomActivationKeyPressed: e, zoomOnScroll: t, zoomOnPinch: n, panOnDrag: r, panOnScroll: a, zoomOnDoubleClick: s, userSelectionActive: l, noWheelClassName: c, noPanClassName: d, lib: f, connectionInProgress: m }) {
  return (h) => {
    const v = e || t, g = n && h.ctrlKey, b = h.type === "wheel";
    if (h.button === 1 && h.type === "mousedown" && (Hh(h, `${f}-flow__node`) || Hh(h, `${f}-flow__edge`)))
      return !0;
    if (!r && !v && !a && !s && !n || l || m && !b || Hh(h, c) && b || Hh(h, d) && (!b || a && b && !e) || !n && h.ctrlKey && b)
      return !1;
    if (!n && h.type === "touchstart" && h.touches?.length > 1)
      return h.preventDefault(), !1;
    if (!v && !a && !g && b || !r && (h.type === "mousedown" || h.type === "touchstart") || Array.isArray(r) && !r.includes(h.button) && h.type === "mousedown")
      return !1;
    const x = Array.isArray(r) && r.includes(h.button) || !h.button || h.button <= 1;
    return (!h.ctrlKey || b) && x;
  };
}
function PSe({ domNode: e, minZoom: t, maxZoom: n, translateExtent: r, viewport: a, onPanZoom: s, onPanZoomStart: l, onPanZoomEnd: c, onDraggingChange: d }) {
  const f = {
    isZoomingOrPanning: !1,
    usedRightMouseButton: !1,
    prevViewport: {},
    mouseButton: 0,
    timerId: void 0,
    panScrollTimeout: void 0,
    isPanScrolling: !1
  }, m = e.getBoundingClientRect(), h = xW().scaleExtent([t, n]).translateExtent(r), v = _i(e).call(h);
  E({
    x: a.x,
    y: a.y,
    zoom: Sg(a.zoom, t, n)
  }, [
    [0, 0],
    [m.width, m.height]
  ], r);
  const g = v.on("wheel.zoom"), b = v.on("dblclick.zoom");
  h.wheelDelta(KW);
  function x(B, P) {
    return v ? new Promise((H) => {
      h?.interpolate(P?.interpolate === "linear" ? Ix : L_).transform(u5(v, P?.duration, P?.ease, () => H(!0)), B);
    }) : Promise.resolve(!1);
  }
  function w({ noWheelClassName: B, noPanClassName: P, onPaneContextMenu: H, userSelectionActive: L, panOnScroll: G, panOnDrag: $, panOnScrollMode: K, panOnScrollSpeed: q, preventScrolling: Z, zoomOnPinch: V, zoomOnScroll: F, zoomOnDoubleClick: Y, zoomActivationKeyPressed: U, lib: W, onTransformChange: J, connectionInProgress: oe, paneClickDistance: fe, selectionOnDrag: ie }) {
    L && !f.isZoomingOrPanning && k();
    const ce = G && !U && !L;
    h.clickDistance(ie ? 1 / 0 : !Ks(fe) || fe < 0 ? 0 : fe);
    const ge = ce ? OSe({
      zoomPanValues: f,
      noWheelClassName: B,
      d3Selection: v,
      d3Zoom: h,
      panOnScrollMode: K,
      panOnScrollSpeed: q,
      zoomOnPinch: V,
      onPanZoomStart: l,
      onPanZoom: s,
      onPanZoomEnd: c
    }) : MSe({
      noWheelClassName: B,
      preventScrolling: Z,
      d3ZoomHandler: g
    });
    if (v.on("wheel.zoom", ge, { passive: !1 }), !L) {
      const le = NSe({
        zoomPanValues: f,
        onDraggingChange: d,
        onPanZoomStart: l
      });
      h.on("start", le);
      const me = ASe({
        zoomPanValues: f,
        panOnDrag: $,
        onPaneContextMenu: !!H,
        onPanZoom: s,
        onTransformChange: J
      });
      h.on("zoom", me);
      const ve = RSe({
        zoomPanValues: f,
        panOnDrag: $,
        panOnScroll: G,
        onPaneContextMenu: H,
        onPanZoomEnd: c,
        onDraggingChange: d
      });
      h.on("end", ve);
    }
    const re = jSe({
      zoomActivationKeyPressed: U,
      panOnDrag: $,
      zoomOnScroll: F,
      panOnScroll: G,
      zoomOnDoubleClick: Y,
      zoomOnPinch: V,
      userSelectionActive: L,
      noPanClassName: P,
      noWheelClassName: B,
      lib: W,
      connectionInProgress: oe
    });
    h.filter(re), Y ? v.on("dblclick.zoom", b) : v.on("dblclick.zoom", null);
  }
  function k() {
    h.on("zoom", null);
  }
  async function E(B, P, H) {
    const L = l5(B), G = h?.constrain()(L, P, H);
    return G && await x(G), new Promise(($) => $(G));
  }
  async function _(B, P) {
    const H = l5(B);
    return await x(H, P), new Promise((L) => L(H));
  }
  function O(B) {
    if (v) {
      const P = l5(B), H = v.property("__zoom");
      (H.k !== B.zoom || H.x !== B.x || H.y !== B.y) && h?.transform(v, P, null, { sync: !0 });
    }
  }
  function N() {
    const B = v ? wW(v.node()) : { x: 0, y: 0, k: 1 };
    return { x: B.x, y: B.y, zoom: B.k };
  }
  function A(B, P) {
    return v ? new Promise((H) => {
      h?.interpolate(P?.interpolate === "linear" ? Ix : L_).scaleTo(u5(v, P?.duration, P?.ease, () => H(!0)), B);
    }) : Promise.resolve(!1);
  }
  function R(B, P) {
    return v ? new Promise((H) => {
      h?.interpolate(P?.interpolate === "linear" ? Ix : L_).scaleBy(u5(v, P?.duration, P?.ease, () => H(!0)), B);
    }) : Promise.resolve(!1);
  }
  function D(B) {
    h?.scaleExtent(B);
  }
  function I(B) {
    h?.translateExtent(B);
  }
  function z(B) {
    const P = !Ks(B) || B < 0 ? 0 : B;
    h?.clickDistance(P);
  }
  return {
    update: w,
    destroy: k,
    setViewport: _,
    setViewportConstrained: E,
    getViewport: N,
    scaleTo: A,
    scaleBy: R,
    setScaleExtent: D,
    setTranslateExtent: I,
    syncViewport: O,
    setClickDistance: z
  };
}
var Eg;
(function(e) {
  e.Line = "line", e.Handle = "handle";
})(Eg || (Eg = {}));
function DSe({ width: e, prevWidth: t, height: n, prevHeight: r, affectsX: a, affectsY: s }) {
  const l = e - t, c = n - r, d = [l > 0 ? 1 : l < 0 ? -1 : 0, c > 0 ? 1 : c < 0 ? -1 : 0];
  return l && a && (d[0] = d[0] * -1), c && s && (d[1] = d[1] * -1), d;
}
function O6(e) {
  const t = e.includes("right") || e.includes("left"), n = e.includes("bottom") || e.includes("top"), r = e.includes("left"), a = e.includes("top");
  return {
    isHorizontal: t,
    isVertical: n,
    affectsX: r,
    affectsY: a
  };
}
function ad(e, t) {
  return Math.max(0, t - e);
}
function id(e, t) {
  return Math.max(0, e - t);
}
function m0(e, t, n) {
  return Math.max(0, t - e, e - n);
}
function M6(e, t) {
  return e ? !t : t;
}
function ISe(e, t, n, r, a, s, l, c) {
  let { affectsX: d, affectsY: f } = t;
  const { isHorizontal: m, isVertical: h } = t, v = m && h, { xSnapped: g, ySnapped: b } = n, { minWidth: x, maxWidth: w, minHeight: k, maxHeight: E } = r, { x: _, y: O, width: N, height: A, aspectRatio: R } = e;
  let D = Math.floor(m ? g - e.pointerX : 0), I = Math.floor(h ? b - e.pointerY : 0);
  const z = N + (d ? -D : D), B = A + (f ? -I : I), P = -s[0] * N, H = -s[1] * A;
  let L = m0(z, x, w), G = m0(B, k, E);
  if (l) {
    let q = 0, Z = 0;
    d && D < 0 ? q = ad(_ + D + P, l[0][0]) : !d && D > 0 && (q = id(_ + z + P, l[1][0])), f && I < 0 ? Z = ad(O + I + H, l[0][1]) : !f && I > 0 && (Z = id(O + B + H, l[1][1])), L = Math.max(L, q), G = Math.max(G, Z);
  }
  if (c) {
    let q = 0, Z = 0;
    d && D > 0 ? q = id(_ + D, c[0][0]) : !d && D < 0 && (q = ad(_ + z, c[1][0])), f && I > 0 ? Z = id(O + I, c[0][1]) : !f && I < 0 && (Z = ad(O + B, c[1][1])), L = Math.max(L, q), G = Math.max(G, Z);
  }
  if (a) {
    if (m) {
      const q = m0(z / R, k, E) * R;
      if (L = Math.max(L, q), l) {
        let Z = 0;
        !d && !f || d && !f && v ? Z = id(O + H + z / R, l[1][1]) * R : Z = ad(O + H + (d ? D : -D) / R, l[0][1]) * R, L = Math.max(L, Z);
      }
      if (c) {
        let Z = 0;
        !d && !f || d && !f && v ? Z = ad(O + z / R, c[1][1]) * R : Z = id(O + (d ? D : -D) / R, c[0][1]) * R, L = Math.max(L, Z);
      }
    }
    if (h) {
      const q = m0(B * R, x, w) / R;
      if (G = Math.max(G, q), l) {
        let Z = 0;
        !d && !f || f && !d && v ? Z = id(_ + B * R + P, l[1][0]) / R : Z = ad(_ + (f ? I : -I) * R + P, l[0][0]) / R, G = Math.max(G, Z);
      }
      if (c) {
        let Z = 0;
        !d && !f || f && !d && v ? Z = ad(_ + B * R, c[1][0]) / R : Z = id(_ + (f ? I : -I) * R, c[0][0]) / R, G = Math.max(G, Z);
      }
    }
  }
  I = I + (I < 0 ? G : -G), D = D + (D < 0 ? L : -L), a && (v ? z > B * R ? I = (M6(d, f) ? -D : D) / R : D = (M6(d, f) ? -I : I) * R : m ? (I = D / R, f = d) : (D = I * R, d = f));
  const $ = d ? _ + D : _, K = f ? O + I : O;
  return {
    width: N + (d ? -D : D),
    height: A + (f ? -I : I),
    x: s[0] * D * (d ? -1 : 1) + $,
    y: s[1] * I * (f ? -1 : 1) + K
  };
}
const YW = { width: 0, height: 0, x: 0, y: 0 }, $Se = {
  ...YW,
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
};
function zSe(e) {
  return [
    [0, 0],
    [e.measured.width, e.measured.height]
  ];
}
function TSe(e, t, n) {
  const r = t.position.x + e.position.x, a = t.position.y + e.position.y, s = e.measured.width ?? 0, l = e.measured.height ?? 0, c = n[0] * s, d = n[1] * l;
  return [
    [r - c, a - d],
    [r + s - c, a + l - d]
  ];
}
function LSe({ domNode: e, nodeId: t, getStoreItems: n, onChange: r, onEnd: a }) {
  const s = _i(e);
  let l = {
    controlDirection: O6("bottom-right"),
    boundaries: {
      minWidth: 0,
      minHeight: 0,
      maxWidth: Number.MAX_VALUE,
      maxHeight: Number.MAX_VALUE
    },
    resizeDirection: void 0,
    keepAspectRatio: !1
  };
  function c({ controlPosition: f, boundaries: m, keepAspectRatio: h, resizeDirection: v, onResizeStart: g, onResize: b, onResizeEnd: x, shouldResize: w }) {
    let k = { ...YW }, E = { ...$Se };
    l = {
      boundaries: m,
      resizeDirection: v,
      keepAspectRatio: h,
      controlDirection: O6(f)
    };
    let _, O = null, N = [], A, R, D, I = !1;
    const z = aW().on("start", (B) => {
      const { nodeLookup: P, transform: H, snapGrid: L, snapToGrid: G, nodeOrigin: $, paneDomNode: K } = n();
      if (_ = P.get(t), !_)
        return;
      O = K?.getBoundingClientRect() ?? null;
      const { xSnapped: q, ySnapped: Z } = $x(B.sourceEvent, {
        transform: H,
        snapGrid: L,
        snapToGrid: G,
        containerBounds: O
      });
      k = {
        width: _.measured.width ?? 0,
        height: _.measured.height ?? 0,
        x: _.position.x ?? 0,
        y: _.position.y ?? 0
      }, E = {
        ...k,
        pointerX: q,
        pointerY: Z,
        aspectRatio: k.width / k.height
      }, A = void 0, _.parentId && (_.extent === "parent" || _.expandParent) && (A = P.get(_.parentId), R = A && _.extent === "parent" ? zSe(A) : void 0), N = [], D = void 0;
      for (const [V, F] of P)
        if (F.parentId === t && (N.push({
          id: V,
          position: { ...F.position },
          extent: F.extent
        }), F.extent === "parent" || F.expandParent)) {
          const Y = TSe(F, _, F.origin ?? $);
          D ? D = [
            [Math.min(Y[0][0], D[0][0]), Math.min(Y[0][1], D[0][1])],
            [Math.max(Y[1][0], D[1][0]), Math.max(Y[1][1], D[1][1])]
          ] : D = Y;
        }
      g?.(B, { ...k });
    }).on("drag", (B) => {
      const { transform: P, snapGrid: H, snapToGrid: L, nodeOrigin: G } = n(), $ = $x(B.sourceEvent, {
        transform: P,
        snapGrid: H,
        snapToGrid: L,
        containerBounds: O
      }), K = [];
      if (!_)
        return;
      const { x: q, y: Z, width: V, height: F } = k, Y = {}, U = _.origin ?? G, { width: W, height: J, x: oe, y: fe } = ISe(E, l.controlDirection, $, l.boundaries, l.keepAspectRatio, U, R, D), ie = W !== V, ce = J !== F, ge = oe !== q && ie, re = fe !== Z && ce;
      if (!ge && !re && !ie && !ce)
        return;
      if ((ge || re || U[0] === 1 || U[1] === 1) && (Y.x = ge ? oe : k.x, Y.y = re ? fe : k.y, k.x = Y.x, k.y = Y.y, N.length > 0)) {
        const ve = oe - q, xe = fe - Z;
        for (const _e of N)
          _e.position = {
            x: _e.position.x - ve + U[0] * (W - V),
            y: _e.position.y - xe + U[1] * (J - F)
          }, K.push(_e);
      }
      if ((ie || ce) && (Y.width = ie && (!l.resizeDirection || l.resizeDirection === "horizontal") ? W : k.width, Y.height = ce && (!l.resizeDirection || l.resizeDirection === "vertical") ? J : k.height, k.width = Y.width, k.height = Y.height), A && _.expandParent) {
        const ve = U[0] * (Y.width ?? 0);
        Y.x && Y.x < ve && (k.x = ve, E.x = E.x - (Y.x - ve));
        const xe = U[1] * (Y.height ?? 0);
        Y.y && Y.y < xe && (k.y = xe, E.y = E.y - (Y.y - xe));
      }
      const le = DSe({
        width: k.width,
        prevWidth: V,
        height: k.height,
        prevHeight: F,
        affectsX: l.controlDirection.affectsX,
        affectsY: l.controlDirection.affectsY
      }), me = { ...k, direction: le };
      w?.(B, me) !== !1 && (I = !0, b?.(B, me), r(Y, K));
    }).on("end", (B) => {
      I && (x?.(B, { ...k }), a?.({ ...k }), I = !1);
    });
    s.call(z);
  }
  function d() {
    s.on(".drag", null);
  }
  return {
    update: c,
    destroy: d
  };
}
const { useDebugValue: FSe } = jt, { useSyncExternalStoreWithSelector: BSe } = pH, USe = (e) => e;
function XW(e, t = USe, n) {
  const r = BSe(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return FSe(r), r;
}
const N6 = (e, t) => {
  const n = fH(e), r = (a, s = t) => XW(n, a, s);
  return Object.assign(r, n), r;
}, VSe = (e, t) => e ? N6(e, t) : N6;
function mr(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1;
    for (const [r, a] of e)
      if (!Object.is(a, t.get(r)))
        return !1;
    return !0;
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1;
    for (const r of e)
      if (!t.has(r))
        return !1;
    return !0;
  }
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !1;
  for (const r of n)
    if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
      return !1;
  return !0;
}
const lC = M.createContext(null), HSe = lC.Provider, JW = Hl.error001();
function pn(e, t) {
  const n = M.useContext(lC);
  if (n === null)
    throw new Error(JW);
  return XW(n, e, t);
}
function gr() {
  const e = M.useContext(lC);
  if (e === null)
    throw new Error(JW);
  return M.useMemo(() => ({
    getState: e.getState,
    setState: e.setState,
    subscribe: e.subscribe
  }), [e]);
}
const A6 = { display: "none" }, WSe = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0px, 0px, 0px, 0px)",
  clipPath: "inset(100%)"
}, QW = "react-flow__node-desc", ZW = "react-flow__edge-desc", qSe = "react-flow__aria-live", GSe = (e) => e.ariaLiveMessage, KSe = (e) => e.ariaLabelConfig;
function YSe({ rfId: e }) {
  const t = pn(GSe);
  return C.jsx("div", { id: `${qSe}-${e}`, "aria-live": "assertive", "aria-atomic": "true", style: WSe, children: t });
}
function XSe({ rfId: e, disableKeyboardA11y: t }) {
  const n = pn(KSe);
  return C.jsxs(C.Fragment, { children: [C.jsx("div", { id: `${QW}-${e}`, style: A6, children: t ? n["node.a11yDescription.default"] : n["node.a11yDescription.keyboardDisabled"] }), C.jsx("div", { id: `${ZW}-${e}`, style: A6, children: n["edge.a11yDescription.default"] }), !t && C.jsx(YSe, { rfId: e })] });
}
const uC = M.forwardRef(({ position: e = "top-left", children: t, className: n, style: r, ...a }, s) => {
  const l = `${e}`.split("-");
  return C.jsx("div", { className: zr(["react-flow__panel", n, ...l]), style: r, ref: s, ...a, children: t });
});
uC.displayName = "Panel";
function JSe({ proOptions: e, position: t = "bottom-right" }) {
  return e?.hideAttribution ? null : C.jsx(uC, { position: t, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children: C.jsx("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution", children: "React Flow" }) });
}
const QSe = (e) => {
  const t = [], n = [];
  for (const [, r] of e.nodeLookup)
    r.selected && t.push(r.internals.userNode);
  for (const [, r] of e.edgeLookup)
    r.selected && n.push(r);
  return { selectedNodes: t, selectedEdges: n };
}, h0 = (e) => e.id;
function ZSe(e, t) {
  return mr(e.selectedNodes.map(h0), t.selectedNodes.map(h0)) && mr(e.selectedEdges.map(h0), t.selectedEdges.map(h0));
}
function eke({ onSelectionChange: e }) {
  const t = gr(), { selectedNodes: n, selectedEdges: r } = pn(QSe, ZSe);
  return M.useEffect(() => {
    const a = { nodes: n, edges: r };
    e?.(a), t.getState().onSelectionChangeHandlers.forEach((s) => s(a));
  }, [n, r, e]), null;
}
const tke = (e) => !!e.onSelectionChangeHandlers;
function nke({ onSelectionChange: e }) {
  const t = pn(tke);
  return e || t ? C.jsx(eke, { onSelectionChange: e }) : null;
}
const eq = [0, 0], rke = { x: 0, y: 0, zoom: 1 }, oke = [
  "nodes",
  "edges",
  "defaultNodes",
  "defaultEdges",
  "onConnect",
  "onConnectStart",
  "onConnectEnd",
  "onClickConnectStart",
  "onClickConnectEnd",
  "nodesDraggable",
  "autoPanOnNodeFocus",
  "nodesConnectable",
  "nodesFocusable",
  "edgesFocusable",
  "edgesReconnectable",
  "elevateNodesOnSelect",
  "elevateEdgesOnSelect",
  "minZoom",
  "maxZoom",
  "nodeExtent",
  "onNodesChange",
  "onEdgesChange",
  "elementsSelectable",
  "connectionMode",
  "snapGrid",
  "snapToGrid",
  "translateExtent",
  "connectOnClick",
  "defaultEdgeOptions",
  "fitView",
  "fitViewOptions",
  "onNodesDelete",
  "onEdgesDelete",
  "onDelete",
  "onNodeDrag",
  "onNodeDragStart",
  "onNodeDragStop",
  "onSelectionDrag",
  "onSelectionDragStart",
  "onSelectionDragStop",
  "onMoveStart",
  "onMove",
  "onMoveEnd",
  "noPanClassName",
  "nodeOrigin",
  "autoPanOnConnect",
  "autoPanOnNodeDrag",
  "onError",
  "connectionRadius",
  "isValidConnection",
  "selectNodesOnDrag",
  "nodeDragThreshold",
  "connectionDragThreshold",
  "onBeforeDelete",
  "debug",
  "autoPanSpeed",
  "ariaLabelConfig",
  "zIndexMode"
], R6 = [...oke, "rfId"], ake = (e) => ({
  setNodes: e.setNodes,
  setEdges: e.setEdges,
  setMinZoom: e.setMinZoom,
  setMaxZoom: e.setMaxZoom,
  setTranslateExtent: e.setTranslateExtent,
  setNodeExtent: e.setNodeExtent,
  reset: e.reset,
  setDefaultNodesAndEdges: e.setDefaultNodesAndEdges
}), j6 = {
  /*
   * these are values that are also passed directly to other components
   * than the StoreUpdater. We can reduce the number of setStore calls
   * by setting the same values here as prev fields.
   */
  translateExtent: mS,
  nodeOrigin: eq,
  minZoom: 0.5,
  maxZoom: 2,
  elementsSelectable: !0,
  noPanClassName: "nopan",
  rfId: "1"
};
function ike(e) {
  const { setNodes: t, setEdges: n, setMinZoom: r, setMaxZoom: a, setTranslateExtent: s, setNodeExtent: l, reset: c, setDefaultNodesAndEdges: d } = pn(ake, mr), f = gr();
  M.useEffect(() => (d(e.defaultNodes, e.defaultEdges), () => {
    m.current = j6, c();
  }), []);
  const m = M.useRef(j6);
  return M.useEffect(
    () => {
      for (const h of R6) {
        const v = e[h], g = m.current[h];
        v !== g && (typeof e[h] > "u" || (h === "nodes" ? t(v) : h === "edges" ? n(v) : h === "minZoom" ? r(v) : h === "maxZoom" ? a(v) : h === "translateExtent" ? s(v) : h === "nodeExtent" ? l(v) : h === "ariaLabelConfig" ? f.setState({ ariaLabelConfig: Jxe(v) }) : h === "fitView" ? f.setState({ fitViewQueued: v }) : h === "fitViewOptions" ? f.setState({ fitViewOptions: v }) : f.setState({ [h]: v })));
      }
      m.current = e;
    },
    // Only re-run the effect if one of the fields we track changes
    R6.map((h) => e[h])
  ), null;
}
function P6() {
  return typeof window > "u" || !window.matchMedia ? null : window.matchMedia("(prefers-color-scheme: dark)");
}
function ske(e) {
  const [t, n] = M.useState(e === "system" ? null : e);
  return M.useEffect(() => {
    if (e !== "system") {
      n(e);
      return;
    }
    const r = P6(), a = () => n(r?.matches ? "dark" : "light");
    return a(), r?.addEventListener("change", a), () => {
      r?.removeEventListener("change", a);
    };
  }, [e]), t !== null ? t : P6()?.matches ? "dark" : "light";
}
const D6 = typeof document < "u" ? document : null;
function Ac(e = null, t = { target: D6, actInsideInputWithModifier: !0 }) {
  const [n, r] = M.useState(!1), a = M.useRef(!1), s = M.useRef(/* @__PURE__ */ new Set([])), [l, c] = M.useMemo(() => {
    if (e !== null) {
      const d = (Array.isArray(e) ? e : [e]).filter((m) => typeof m == "string").map((m) => m.replace("+", `
`).replace(`

`, `
+`).split(`
`)), f = d.reduce((m, h) => m.concat(...h), []);
      return [d, f];
    }
    return [[], []];
  }, [e]);
  return M.useEffect(() => {
    const d = t?.target ?? D6, f = t?.actInsideInputWithModifier ?? !0;
    if (e !== null) {
      const m = (g) => {
        if (a.current = g.ctrlKey || g.metaKey || g.shiftKey || g.altKey, (!a.current || a.current && !f) && DW(g))
          return !1;
        const b = $6(g.code, c);
        if (s.current.add(g[b]), I6(l, s.current, !1)) {
          const x = g.composedPath?.()?.[0] || g.target, w = x?.nodeName === "BUTTON" || x?.nodeName === "A";
          t.preventDefault !== !1 && (a.current || !w) && g.preventDefault(), r(!0);
        }
      }, h = (g) => {
        const b = $6(g.code, c);
        I6(l, s.current, !0) ? (r(!1), s.current.clear()) : s.current.delete(g[b]), g.key === "Meta" && s.current.clear(), a.current = !1;
      }, v = () => {
        s.current.clear(), r(!1);
      };
      return d?.addEventListener("keydown", m), d?.addEventListener("keyup", h), window.addEventListener("blur", v), window.addEventListener("contextmenu", v), () => {
        d?.removeEventListener("keydown", m), d?.removeEventListener("keyup", h), window.removeEventListener("blur", v), window.removeEventListener("contextmenu", v);
      };
    }
  }, [e, r]), n;
}
function I6(e, t, n) {
  return e.filter((r) => n || r.length === t.size).some((r) => r.every((a) => t.has(a)));
}
function $6(e, t) {
  return t.includes(e) ? "code" : "key";
}
const lke = () => {
  const e = gr();
  return M.useMemo(() => ({
    zoomIn: (t) => {
      const { panZoom: n } = e.getState();
      return n ? n.scaleBy(1.2, { duration: t?.duration }) : Promise.resolve(!1);
    },
    zoomOut: (t) => {
      const { panZoom: n } = e.getState();
      return n ? n.scaleBy(1 / 1.2, { duration: t?.duration }) : Promise.resolve(!1);
    },
    zoomTo: (t, n) => {
      const { panZoom: r } = e.getState();
      return r ? r.scaleTo(t, { duration: n?.duration }) : Promise.resolve(!1);
    },
    getZoom: () => e.getState().transform[2],
    setViewport: async (t, n) => {
      const { transform: [r, a, s], panZoom: l } = e.getState();
      return l ? (await l.setViewport({
        x: t.x ?? r,
        y: t.y ?? a,
        zoom: t.zoom ?? s
      }, n), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    getViewport: () => {
      const [t, n, r] = e.getState().transform;
      return { x: t, y: n, zoom: r };
    },
    setCenter: async (t, n, r) => e.getState().setCenter(t, n, r),
    fitBounds: async (t, n) => {
      const { width: r, height: a, minZoom: s, maxZoom: l, panZoom: c } = e.getState(), d = fj(t, r, a, s, l, n?.padding ?? 0.1);
      return c ? (await c.setViewport(d, {
        duration: n?.duration,
        ease: n?.ease,
        interpolate: n?.interpolate
      }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    screenToFlowPosition: (t, n = {}) => {
      const { transform: r, snapGrid: a, snapToGrid: s, domNode: l } = e.getState();
      if (!l)
        return t;
      const { x: c, y: d } = l.getBoundingClientRect(), f = {
        x: t.x - c,
        y: t.y - d
      }, m = n.snapGrid ?? a, h = n.snapToGrid ?? s;
      return hk(f, r, h, m);
    },
    flowToScreenPosition: (t) => {
      const { transform: n, domNode: r } = e.getState();
      if (!r)
        return t;
      const { x: a, y: s } = r.getBoundingClientRect(), l = D2(t, n);
      return {
        x: l.x + a,
        y: l.y + s
      };
    }
  }), []);
};
function tq(e, t) {
  const n = [], r = /* @__PURE__ */ new Map(), a = [];
  for (const s of e)
    if (s.type === "add") {
      a.push(s);
      continue;
    } else if (s.type === "remove" || s.type === "replace")
      r.set(s.id, [s]);
    else {
      const l = r.get(s.id);
      l ? l.push(s) : r.set(s.id, [s]);
    }
  for (const s of t) {
    const l = r.get(s.id);
    if (!l) {
      n.push(s);
      continue;
    }
    if (l[0].type === "remove")
      continue;
    if (l[0].type === "replace") {
      n.push({ ...l[0].item });
      continue;
    }
    const c = { ...s };
    for (const d of l)
      uke(d, c);
    n.push(c);
  }
  return a.length && a.forEach((s) => {
    s.index !== void 0 ? n.splice(s.index, 0, { ...s.item }) : n.push({ ...s.item });
  }), n;
}
function uke(e, t) {
  switch (e.type) {
    case "select": {
      t.selected = e.selected;
      break;
    }
    case "position": {
      typeof e.position < "u" && (t.position = e.position), typeof e.dragging < "u" && (t.dragging = e.dragging);
      break;
    }
    case "dimensions": {
      typeof e.dimensions < "u" && (t.measured = {
        ...e.dimensions
      }, e.setAttributes && ((e.setAttributes === !0 || e.setAttributes === "width") && (t.width = e.dimensions.width), (e.setAttributes === !0 || e.setAttributes === "height") && (t.height = e.dimensions.height))), typeof e.resizing == "boolean" && (t.resizing = e.resizing);
      break;
    }
  }
}
function wj(e, t) {
  return tq(e, t);
}
function nq(e, t) {
  return tq(e, t);
}
function wm(e, t) {
  return {
    id: e,
    type: "select",
    selected: t
  };
}
function Wh(e, t = /* @__PURE__ */ new Set(), n = !1) {
  const r = [];
  for (const [a, s] of e) {
    const l = t.has(a);
    !(s.selected === void 0 && !l) && s.selected !== l && (n && (s.selected = l), r.push(wm(s.id, l)));
  }
  return r;
}
function z6({ items: e = [], lookup: t }) {
  const n = [], r = new Map(e.map((a) => [a.id, a]));
  for (const [a, s] of e.entries()) {
    const l = t.get(s.id), c = l?.internals?.userNode ?? l;
    c !== void 0 && c !== s && n.push({ id: s.id, item: s, type: "replace" }), c === void 0 && n.push({ item: s, type: "add", index: a });
  }
  for (const [a] of t)
    r.get(a) === void 0 && n.push({ id: a, type: "remove" });
  return n;
}
function T6(e) {
  return {
    id: e.id,
    type: "remove"
  };
}
const L6 = (e) => Bxe(e), cke = (e) => CW(e);
function rq(e) {
  return M.forwardRef(e);
}
const dke = typeof window < "u" ? M.useLayoutEffect : M.useEffect;
function F6(e) {
  const [t, n] = M.useState(BigInt(0)), [r] = M.useState(() => fke(() => n((a) => a + BigInt(1))));
  return dke(() => {
    const a = r.get();
    a.length && (e(a), r.reset());
  }, [t]), r;
}
function fke(e) {
  let t = [];
  return {
    get: () => t,
    reset: () => {
      t = [];
    },
    push: (n) => {
      t.push(n), e();
    }
  };
}
const oq = M.createContext(null);
function pke({ children: e }) {
  const t = gr(), n = M.useCallback((c) => {
    const { nodes: d = [], setNodes: f, hasDefaultNodes: m, onNodesChange: h, nodeLookup: v, fitViewQueued: g, onNodesChangeMiddlewareMap: b } = t.getState();
    let x = d;
    for (const k of c)
      x = typeof k == "function" ? k(x) : k;
    let w = z6({
      items: x,
      lookup: v
    });
    for (const k of b.values())
      w = k(w);
    m && f(x), w.length > 0 ? h?.(w) : g && window.requestAnimationFrame(() => {
      const { fitViewQueued: k, nodes: E, setNodes: _ } = t.getState();
      k && _(E);
    });
  }, []), r = F6(n), a = M.useCallback((c) => {
    const { edges: d = [], setEdges: f, hasDefaultEdges: m, onEdgesChange: h, edgeLookup: v } = t.getState();
    let g = d;
    for (const b of c)
      g = typeof b == "function" ? b(g) : b;
    m ? f(g) : h && h(z6({
      items: g,
      lookup: v
    }));
  }, []), s = F6(a), l = M.useMemo(() => ({ nodeQueue: r, edgeQueue: s }), []);
  return C.jsx(oq.Provider, { value: l, children: e });
}
function mke() {
  const e = M.useContext(oq);
  if (!e)
    throw new Error("useBatchContext must be used within a BatchProvider");
  return e;
}
const hke = (e) => !!e.panZoom;
function Jm() {
  const e = lke(), t = gr(), n = mke(), r = pn(hke), a = M.useMemo(() => {
    const s = (h) => t.getState().nodeLookup.get(h), l = (h) => {
      n.nodeQueue.push(h);
    }, c = (h) => {
      n.edgeQueue.push(h);
    }, d = (h) => {
      const { nodeLookup: v, nodeOrigin: g } = t.getState(), b = L6(h) ? h : v.get(h.id), x = b.parentId ? jW(b.position, b.measured, b.parentId, v, g) : b.position, w = {
        ...b,
        position: x,
        width: b.measured?.width ?? b.width,
        height: b.measured?.height ?? b.height
      };
      return kg(w);
    }, f = (h, v, g = { replace: !1 }) => {
      l((b) => b.map((x) => {
        if (x.id === h) {
          const w = typeof v == "function" ? v(x) : v;
          return g.replace && L6(w) ? w : { ...x, ...w };
        }
        return x;
      }));
    }, m = (h, v, g = { replace: !1 }) => {
      c((b) => b.map((x) => {
        if (x.id === h) {
          const w = typeof v == "function" ? v(x) : v;
          return g.replace && cke(w) ? w : { ...x, ...w };
        }
        return x;
      }));
    };
    return {
      getNodes: () => t.getState().nodes.map((h) => ({ ...h })),
      getNode: (h) => s(h)?.internals.userNode,
      getInternalNode: s,
      getEdges: () => {
        const { edges: h = [] } = t.getState();
        return h.map((v) => ({ ...v }));
      },
      getEdge: (h) => t.getState().edgeLookup.get(h),
      setNodes: l,
      setEdges: c,
      addNodes: (h) => {
        const v = Array.isArray(h) ? h : [h];
        n.nodeQueue.push((g) => [...g, ...v]);
      },
      addEdges: (h) => {
        const v = Array.isArray(h) ? h : [h];
        n.edgeQueue.push((g) => [...g, ...v]);
      },
      toObject: () => {
        const { nodes: h = [], edges: v = [], transform: g } = t.getState(), [b, x, w] = g;
        return {
          nodes: h.map((k) => ({ ...k })),
          edges: v.map((k) => ({ ...k })),
          viewport: {
            x: b,
            y: x,
            zoom: w
          }
        };
      },
      deleteElements: async ({ nodes: h = [], edges: v = [] }) => {
        const { nodes: g, edges: b, onNodesDelete: x, onEdgesDelete: w, triggerNodeChanges: k, triggerEdgeChanges: E, onDelete: _, onBeforeDelete: O } = t.getState(), { nodes: N, edges: A } = await qxe({
          nodesToRemove: h,
          edgesToRemove: v,
          nodes: g,
          edges: b,
          onBeforeDelete: O
        }), R = A.length > 0, D = N.length > 0;
        if (R) {
          const I = A.map(T6);
          w?.(A), E(I);
        }
        if (D) {
          const I = N.map(T6);
          x?.(N), k(I);
        }
        return (D || R) && _?.({ nodes: N, edges: A }), { deletedNodes: N, deletedEdges: A };
      },
      /**
       * Partial is defined as "the 2 nodes/areas are intersecting partially".
       * If a is contained in b or b is contained in a, they are both
       * considered fully intersecting.
       */
      getIntersectingNodes: (h, v = !0, g) => {
        const b = g6(h), x = b ? h : d(h), w = g !== void 0;
        return x ? (g || t.getState().nodes).filter((k) => {
          const E = t.getState().nodeLookup.get(k.id);
          if (E && !b && (k.id === h.id || !E.internals.positionAbsolute))
            return !1;
          const _ = kg(w ? k : E), O = gS(_, x);
          return v && O > 0 || O >= _.width * _.height || O >= x.width * x.height;
        }) : [];
      },
      isNodeIntersecting: (h, v, g = !0) => {
        const b = g6(h) ? h : d(h);
        if (!b)
          return !1;
        const x = gS(b, v);
        return g && x > 0 || x >= v.width * v.height || x >= b.width * b.height;
      },
      updateNode: f,
      updateNodeData: (h, v, g = { replace: !1 }) => {
        f(h, (b) => {
          const x = typeof v == "function" ? v(b) : v;
          return g.replace ? { ...b, data: x } : { ...b, data: { ...b.data, ...x } };
        }, g);
      },
      updateEdge: m,
      updateEdgeData: (h, v, g = { replace: !1 }) => {
        m(h, (b) => {
          const x = typeof v == "function" ? v(b) : v;
          return g.replace ? { ...b, data: x } : { ...b, data: { ...b.data, ...x } };
        }, g);
      },
      getNodesBounds: (h) => {
        const { nodeLookup: v, nodeOrigin: g } = t.getState();
        return Uxe(h, { nodeLookup: v, nodeOrigin: g });
      },
      getHandleConnections: ({ type: h, id: v, nodeId: g }) => Array.from(t.getState().connectionLookup.get(`${g}-${h}${v ? `-${v}` : ""}`)?.values() ?? []),
      getNodeConnections: ({ type: h, handleId: v, nodeId: g }) => Array.from(t.getState().connectionLookup.get(`${g}${h ? v ? `-${h}-${v}` : `-${h}` : ""}`)?.values() ?? []),
      fitView: async (h) => {
        const v = t.getState().fitViewResolver ?? Xxe();
        return t.setState({ fitViewQueued: !0, fitViewOptions: h, fitViewResolver: v }), n.nodeQueue.push((g) => [...g]), v.promise;
      }
    };
  }, []);
  return M.useMemo(() => ({
    ...a,
    ...e,
    viewportInitialized: r
  }), [r]);
}
const B6 = (e) => e.selected, gke = typeof window < "u" ? window : void 0;
function vke({ deleteKeyCode: e, multiSelectionKeyCode: t }) {
  const n = gr(), { deleteElements: r } = Jm(), a = Ac(e, { actInsideInputWithModifier: !1 }), s = Ac(t, { target: gke });
  M.useEffect(() => {
    if (a) {
      const { edges: l, nodes: c } = n.getState();
      r({ nodes: c.filter(B6), edges: l.filter(B6) }), n.setState({ nodesSelectionActive: !1 });
    }
  }, [a]), M.useEffect(() => {
    n.setState({ multiSelectionActive: s });
  }, [s]);
}
function yke(e) {
  const t = gr();
  M.useEffect(() => {
    const n = () => {
      if (!e.current || !(e.current.checkVisibility?.() ?? !0))
        return !1;
      const r = pj(e.current);
      (r.height === 0 || r.width === 0) && t.getState().onError?.("004", Hl.error004()), t.setState({ width: r.width || 500, height: r.height || 500 });
    };
    if (e.current) {
      n(), window.addEventListener("resize", n);
      const r = new ResizeObserver(() => n());
      return r.observe(e.current), () => {
        window.removeEventListener("resize", n), r && e.current && r.unobserve(e.current);
      };
    }
  }, []);
}
const cC = {
  position: "absolute",
  width: "100%",
  height: "100%",
  top: 0,
  left: 0
}, bke = (e) => ({
  userSelectionActive: e.userSelectionActive,
  lib: e.lib,
  connectionInProgress: e.connection.inProgress
});
function wke({ onPaneContextMenu: e, zoomOnScroll: t = !0, zoomOnPinch: n = !0, panOnScroll: r = !1, panOnScrollSpeed: a = 0.5, panOnScrollMode: s = jm.Free, zoomOnDoubleClick: l = !0, panOnDrag: c = !0, defaultViewport: d, translateExtent: f, minZoom: m, maxZoom: h, zoomActivationKeyCode: v, preventScrolling: g = !0, children: b, noWheelClassName: x, noPanClassName: w, onViewportChange: k, isControlledViewport: E, paneClickDistance: _, selectionOnDrag: O }) {
  const N = gr(), A = M.useRef(null), { userSelectionActive: R, lib: D, connectionInProgress: I } = pn(bke, mr), z = Ac(v), B = M.useRef();
  yke(A);
  const P = M.useCallback((H) => {
    k?.({ x: H[0], y: H[1], zoom: H[2] }), E || N.setState({ transform: H });
  }, [k, E]);
  return M.useEffect(() => {
    if (A.current) {
      B.current = PSe({
        domNode: A.current,
        minZoom: m,
        maxZoom: h,
        translateExtent: f,
        viewport: d,
        onDraggingChange: ($) => N.setState({ paneDragging: $ }),
        onPanZoomStart: ($, K) => {
          const { onViewportChangeStart: q, onMoveStart: Z } = N.getState();
          Z?.($, K), q?.(K);
        },
        onPanZoom: ($, K) => {
          const { onViewportChange: q, onMove: Z } = N.getState();
          Z?.($, K), q?.(K);
        },
        onPanZoomEnd: ($, K) => {
          const { onViewportChangeEnd: q, onMoveEnd: Z } = N.getState();
          Z?.($, K), q?.(K);
        }
      });
      const { x: H, y: L, zoom: G } = B.current.getViewport();
      return N.setState({
        panZoom: B.current,
        transform: [H, L, G],
        domNode: A.current.closest(".react-flow")
      }), () => {
        B.current?.destroy();
      };
    }
  }, []), M.useEffect(() => {
    B.current?.update({
      onPaneContextMenu: e,
      zoomOnScroll: t,
      zoomOnPinch: n,
      panOnScroll: r,
      panOnScrollSpeed: a,
      panOnScrollMode: s,
      zoomOnDoubleClick: l,
      panOnDrag: c,
      zoomActivationKeyPressed: z,
      preventScrolling: g,
      noPanClassName: w,
      userSelectionActive: R,
      noWheelClassName: x,
      lib: D,
      onTransformChange: P,
      connectionInProgress: I,
      selectionOnDrag: O,
      paneClickDistance: _
    });
  }, [
    e,
    t,
    n,
    r,
    a,
    s,
    l,
    c,
    z,
    g,
    w,
    R,
    x,
    D,
    P,
    I,
    O,
    _
  ]), C.jsx("div", { className: "react-flow__renderer", ref: A, style: cC, children: b });
}
const xke = (e) => ({
  userSelectionActive: e.userSelectionActive,
  userSelectionRect: e.userSelectionRect
});
function Ske() {
  const { userSelectionActive: e, userSelectionRect: t } = pn(xke, mr);
  return e && t ? C.jsx("div", { className: "react-flow__selection react-flow__container", style: {
    width: t.width,
    height: t.height,
    transform: `translate(${t.x}px, ${t.y}px)`
  } }) : null;
}
const c5 = (e, t) => (n) => {
  n.target === t.current && e?.(n);
}, kke = (e) => ({
  userSelectionActive: e.userSelectionActive,
  elementsSelectable: e.elementsSelectable,
  connectionInProgress: e.connection.inProgress,
  dragging: e.paneDragging
});
function _ke({ isSelecting: e, selectionKeyPressed: t, selectionMode: n = hS.Full, panOnDrag: r, paneClickDistance: a, selectionOnDrag: s, onSelectionStart: l, onSelectionEnd: c, onPaneClick: d, onPaneContextMenu: f, onPaneScroll: m, onPaneMouseEnter: h, onPaneMouseMove: v, onPaneMouseLeave: g, children: b }) {
  const x = gr(), { userSelectionActive: w, elementsSelectable: k, dragging: E, connectionInProgress: _ } = pn(kke, mr), O = k && (e || w), N = M.useRef(null), A = M.useRef(), R = M.useRef(/* @__PURE__ */ new Set()), D = M.useRef(/* @__PURE__ */ new Set()), I = M.useRef(!1), z = (q) => {
    if (I.current || _) {
      I.current = !1;
      return;
    }
    d?.(q), x.getState().resetSelectedElements(), x.setState({ nodesSelectionActive: !1 });
  }, B = (q) => {
    if (Array.isArray(r) && r?.includes(2)) {
      q.preventDefault();
      return;
    }
    f?.(q);
  }, P = m ? (q) => m(q) : void 0, H = (q) => {
    I.current && (q.stopPropagation(), I.current = !1);
  }, L = (q) => {
    const { domNode: Z } = x.getState();
    if (A.current = Z?.getBoundingClientRect(), !A.current)
      return;
    const V = q.target === N.current;
    if (!V && q.target.closest(".nokey") || !e || !(s && V || t) || q.button !== 0 || !q.isPrimary)
      return;
    q.target?.setPointerCapture?.(q.pointerId), I.current = !1;
    const { x: F, y: Y } = Ys(q.nativeEvent, A.current);
    x.setState({
      userSelectionRect: {
        width: 0,
        height: 0,
        startX: F,
        startY: Y,
        x: F,
        y: Y
      }
    }), V || (q.stopPropagation(), q.preventDefault());
  }, G = (q) => {
    const { userSelectionRect: Z, transform: V, nodeLookup: F, edgeLookup: Y, connectionLookup: U, triggerNodeChanges: W, triggerEdgeChanges: J, defaultEdgeOptions: oe, resetSelectedElements: fe } = x.getState();
    if (!A.current || !Z)
      return;
    const { x: ie, y: ce } = Ys(q.nativeEvent, A.current), { startX: ge, startY: re } = Z;
    if (!I.current) {
      const _e = t ? 0 : a;
      if (Math.hypot(ie - ge, ce - re) <= _e)
        return;
      fe(), l?.(q);
    }
    I.current = !0;
    const le = {
      startX: ge,
      startY: re,
      x: ie < ge ? ie : ge,
      y: ce < re ? ce : re,
      width: Math.abs(ie - ge),
      height: Math.abs(ce - re)
    }, me = R.current, ve = D.current;
    R.current = new Set(dj(F, le, V, n === hS.Partial, !0).map((_e) => _e.id)), D.current = /* @__PURE__ */ new Set();
    const xe = oe?.selectable ?? !0;
    for (const _e of R.current) {
      const Ge = U.get(_e);
      if (Ge)
        for (const { edgeId: Xe } of Ge.values()) {
          const tt = Y.get(Xe);
          tt && (tt.selectable ?? xe) && D.current.add(Xe);
        }
    }
    if (!v6(me, R.current)) {
      const _e = Wh(F, R.current, !0);
      W(_e);
    }
    if (!v6(ve, D.current)) {
      const _e = Wh(Y, D.current);
      J(_e);
    }
    x.setState({
      userSelectionRect: le,
      userSelectionActive: !0,
      nodesSelectionActive: !1
    });
  }, $ = (q) => {
    q.button === 0 && (q.target?.releasePointerCapture?.(q.pointerId), !w && q.target === N.current && x.getState().userSelectionRect && z?.(q), x.setState({
      userSelectionActive: !1,
      userSelectionRect: null
    }), I.current && (c?.(q), x.setState({
      nodesSelectionActive: R.current.size > 0
    })));
  }, K = r === !0 || Array.isArray(r) && r.includes(0);
  return C.jsxs("div", { className: zr(["react-flow__pane", { draggable: K, dragging: E, selection: e }]), onClick: O ? void 0 : c5(z, N), onContextMenu: c5(B, N), onWheel: c5(P, N), onPointerEnter: O ? void 0 : h, onPointerMove: O ? G : v, onPointerUp: O ? $ : void 0, onPointerDownCapture: O ? L : void 0, onClickCapture: O ? H : void 0, onPointerLeave: g, ref: N, style: cC, children: [b, C.jsx(Ske, {})] });
}
function R3({ id: e, store: t, unselect: n = !1, nodeRef: r }) {
  const { addSelectedNodes: a, unselectNodesAndEdges: s, multiSelectionActive: l, nodeLookup: c, onError: d } = t.getState(), f = c.get(e);
  if (!f) {
    d?.("012", Hl.error012(e));
    return;
  }
  t.setState({ nodesSelectionActive: !1 }), f.selected ? (n || f.selected && l) && (s({ nodes: [f], edges: [] }), requestAnimationFrame(() => r?.current?.blur())) : a([e]);
}
function aq({ nodeRef: e, disabled: t = !1, noDragClassName: n, handleSelector: r, nodeId: a, isSelectable: s, nodeClickDistance: l }) {
  const c = gr(), [d, f] = M.useState(!1), m = M.useRef();
  return M.useEffect(() => {
    m.current = bSe({
      getStoreItems: () => c.getState(),
      onNodeMouseDown: (h) => {
        R3({
          id: h,
          store: c,
          nodeRef: e
        });
      },
      onDragStart: () => {
        f(!0);
      },
      onDragStop: () => {
        f(!1);
      }
    });
  }, []), M.useEffect(() => {
    if (t)
      m.current?.destroy();
    else if (e.current)
      return m.current?.update({
        noDragClassName: n,
        handleSelector: r,
        domNode: e.current,
        isSelectable: s,
        nodeId: a,
        nodeClickDistance: l
      }), () => {
        m.current?.destroy();
      };
  }, [n, r, t, s, e, a]), d;
}
const Eke = (e) => (t) => t.selected && (t.draggable || e && typeof t.draggable > "u");
function iq() {
  const e = gr();
  return M.useCallback((t) => {
    const { nodeExtent: n, snapToGrid: r, snapGrid: a, nodesDraggable: s, onError: l, updateNodePositions: c, nodeLookup: d, nodeOrigin: f } = e.getState(), m = /* @__PURE__ */ new Map(), h = Eke(s), v = r ? a[0] : 5, g = r ? a[1] : 5, b = t.direction.x * v * t.factor, x = t.direction.y * g * t.factor;
    for (const [, w] of d) {
      if (!h(w))
        continue;
      let k = {
        x: w.internals.positionAbsolute.x + b,
        y: w.internals.positionAbsolute.y + x
      };
      r && (k = mk(k, a));
      const { position: E, positionAbsolute: _ } = OW({
        nodeId: w.id,
        nextPosition: k,
        nodeLookup: d,
        nodeExtent: n,
        nodeOrigin: f,
        onError: l
      });
      w.position = E, w.internals.positionAbsolute = _, m.set(w.id, w);
    }
    c(m);
  }, []);
}
const xj = M.createContext(null), Cke = xj.Provider;
xj.Consumer;
const sq = () => M.useContext(xj), Oke = (e) => ({
  connectOnClick: e.connectOnClick,
  noPanClassName: e.noPanClassName,
  rfId: e.rfId
}), Mke = (e, t, n) => (r) => {
  const { connectionClickStartHandle: a, connectionMode: s, connection: l } = r, { fromHandle: c, toHandle: d, isValid: f } = l, m = d?.nodeId === e && d?.id === t && d?.type === n;
  return {
    connectingFrom: c?.nodeId === e && c?.id === t && c?.type === n,
    connectingTo: m,
    clickConnecting: a?.nodeId === e && a?.id === t && a?.type === n,
    isPossibleEndHandle: s === xg.Strict ? c?.type !== n : e !== c?.nodeId || t !== c?.id,
    connectionInProcess: !!c,
    clickConnectionInProcess: !!a,
    valid: m && f
  };
};
function Nke({ type: e = "source", position: t = lt.Top, isValidConnection: n, isConnectable: r = !0, isConnectableStart: a = !0, isConnectableEnd: s = !0, id: l, onConnect: c, children: d, className: f, onMouseDown: m, onTouchStart: h, ...v }, g) {
  const b = l || null, x = e === "target", w = gr(), k = sq(), { connectOnClick: E, noPanClassName: _, rfId: O } = pn(Oke, mr), { connectingFrom: N, connectingTo: A, clickConnecting: R, isPossibleEndHandle: D, connectionInProcess: I, clickConnectionInProcess: z, valid: B } = pn(Mke(k, b, e), mr);
  k || w.getState().onError?.("010", Hl.error010());
  const P = (G) => {
    const { defaultEdgeOptions: $, onConnect: K, hasDefaultEdges: q } = w.getState(), Z = {
      ...$,
      ...G
    };
    if (q) {
      const { edges: V, setEdges: F } = w.getState();
      F(rSe(Z, V));
    }
    K?.(Z), c?.(Z);
  }, H = (G) => {
    if (!k)
      return;
    const $ = IW(G.nativeEvent);
    if (a && ($ && G.button === 0 || !$)) {
      const K = w.getState();
      A3.onPointerDown(G.nativeEvent, {
        handleDomNode: G.currentTarget,
        autoPanOnConnect: K.autoPanOnConnect,
        connectionMode: K.connectionMode,
        connectionRadius: K.connectionRadius,
        domNode: K.domNode,
        nodeLookup: K.nodeLookup,
        lib: K.lib,
        isTarget: x,
        handleId: b,
        nodeId: k,
        flowId: K.rfId,
        panBy: K.panBy,
        cancelConnection: K.cancelConnection,
        onConnectStart: K.onConnectStart,
        onConnectEnd: K.onConnectEnd,
        updateConnection: K.updateConnection,
        onConnect: P,
        isValidConnection: n || K.isValidConnection,
        getTransform: () => w.getState().transform,
        getFromHandle: () => w.getState().connection.fromHandle,
        autoPanSpeed: K.autoPanSpeed,
        dragThreshold: K.connectionDragThreshold
      });
    }
    $ ? m?.(G) : h?.(G);
  }, L = (G) => {
    const { onClickConnectStart: $, onClickConnectEnd: K, connectionClickStartHandle: q, connectionMode: Z, isValidConnection: V, lib: F, rfId: Y, nodeLookup: U, connection: W } = w.getState();
    if (!k || !q && !a)
      return;
    if (!q) {
      $?.(G.nativeEvent, { nodeId: k, handleId: b, handleType: e }), w.setState({ connectionClickStartHandle: { nodeId: k, type: e, id: b } });
      return;
    }
    const J = PW(G.target), oe = n || V, { connection: fe, isValid: ie } = A3.isValid(G.nativeEvent, {
      handle: {
        nodeId: k,
        id: b,
        type: e
      },
      connectionMode: Z,
      fromNodeId: q.nodeId,
      fromHandleId: q.id || null,
      fromType: q.type,
      isValidConnection: oe,
      flowId: Y,
      doc: J,
      lib: F,
      nodeLookup: U
    });
    ie && fe && P(fe);
    const ce = structuredClone(W);
    delete ce.inProgress, ce.toPosition = ce.toHandle ? ce.toHandle.position : null, K?.(G, ce), w.setState({ connectionClickStartHandle: null });
  };
  return C.jsx("div", { "data-handleid": b, "data-nodeid": k, "data-handlepos": t, "data-id": `${O}-${k}-${b}-${e}`, className: zr([
    "react-flow__handle",
    `react-flow__handle-${t}`,
    "nodrag",
    _,
    f,
    {
      source: !x,
      target: x,
      connectable: r,
      connectablestart: a,
      connectableend: s,
      clickconnecting: R,
      connectingfrom: N,
      connectingto: A,
      valid: B,
      /*
       * shows where you can start a connection from
       * and where you can end it while connecting
       */
      connectionindicator: r && (!I || D) && (I || z ? s : a)
    }
  ]), onMouseDown: H, onTouchStart: H, onClick: E ? L : void 0, ref: g, ...v, children: d });
}
const yS = M.memo(rq(Nke));
function Ake({ data: e, isConnectable: t, sourcePosition: n = lt.Bottom }) {
  return C.jsxs(C.Fragment, { children: [e?.label, C.jsx(yS, { type: "source", position: n, isConnectable: t })] });
}
function Rke({ data: e, isConnectable: t, targetPosition: n = lt.Top, sourcePosition: r = lt.Bottom }) {
  return C.jsxs(C.Fragment, { children: [C.jsx(yS, { type: "target", position: n, isConnectable: t }), e?.label, C.jsx(yS, { type: "source", position: r, isConnectable: t })] });
}
function jke() {
  return null;
}
function Pke({ data: e, isConnectable: t, targetPosition: n = lt.Top }) {
  return C.jsxs(C.Fragment, { children: [C.jsx(yS, { type: "target", position: n, isConnectable: t }), e?.label] });
}
const I2 = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
}, U6 = {
  input: Ake,
  default: Rke,
  output: Pke,
  group: jke
};
function Dke(e) {
  return e.internals.handleBounds === void 0 ? {
    width: e.width ?? e.initialWidth ?? e.style?.width,
    height: e.height ?? e.initialHeight ?? e.style?.height
  } : {
    width: e.width ?? e.style?.width,
    height: e.height ?? e.style?.height
  };
}
const Ike = (e) => {
  const { width: t, height: n, x: r, y: a } = pk(e.nodeLookup, {
    filter: (s) => !!s.selected
  });
  return {
    width: Ks(t) ? t : null,
    height: Ks(n) ? n : null,
    userSelectionActive: e.userSelectionActive,
    transformString: `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]}) translate(${r}px,${a}px)`
  };
};
function $ke({ onSelectionContextMenu: e, noPanClassName: t, disableKeyboardA11y: n }) {
  const r = gr(), { width: a, height: s, transformString: l, userSelectionActive: c } = pn(Ike, mr), d = iq(), f = M.useRef(null);
  if (M.useEffect(() => {
    n || f.current?.focus({
      preventScroll: !0
    });
  }, [n]), aq({
    nodeRef: f
  }), c || !a || !s)
    return null;
  const m = e ? (v) => {
    const g = r.getState().nodes.filter((b) => b.selected);
    e(v, g);
  } : void 0, h = (v) => {
    Object.prototype.hasOwnProperty.call(I2, v.key) && (v.preventDefault(), d({
      direction: I2[v.key],
      factor: v.shiftKey ? 4 : 1
    }));
  };
  return C.jsx("div", { className: zr(["react-flow__nodesselection", "react-flow__container", t]), style: {
    transform: l
  }, children: C.jsx("div", { ref: f, className: "react-flow__nodesselection-rect", onContextMenu: m, tabIndex: n ? void 0 : -1, onKeyDown: n ? void 0 : h, style: {
    width: a,
    height: s
  } }) });
}
const V6 = typeof window < "u" ? window : void 0, zke = (e) => ({ nodesSelectionActive: e.nodesSelectionActive, userSelectionActive: e.userSelectionActive });
function lq({ children: e, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: a, onPaneContextMenu: s, onPaneScroll: l, paneClickDistance: c, deleteKeyCode: d, selectionKeyCode: f, selectionOnDrag: m, selectionMode: h, onSelectionStart: v, onSelectionEnd: g, multiSelectionKeyCode: b, panActivationKeyCode: x, zoomActivationKeyCode: w, elementsSelectable: k, zoomOnScroll: E, zoomOnPinch: _, panOnScroll: O, panOnScrollSpeed: N, panOnScrollMode: A, zoomOnDoubleClick: R, panOnDrag: D, defaultViewport: I, translateExtent: z, minZoom: B, maxZoom: P, preventScrolling: H, onSelectionContextMenu: L, noWheelClassName: G, noPanClassName: $, disableKeyboardA11y: K, onViewportChange: q, isControlledViewport: Z }) {
  const { nodesSelectionActive: V, userSelectionActive: F } = pn(zke, mr), Y = Ac(f, { target: V6 }), U = Ac(x, { target: V6 }), W = U || D, J = U || O, oe = m && W !== !0, fe = Y || F || oe;
  return vke({ deleteKeyCode: d, multiSelectionKeyCode: b }), C.jsx(wke, { onPaneContextMenu: s, elementsSelectable: k, zoomOnScroll: E, zoomOnPinch: _, panOnScroll: J, panOnScrollSpeed: N, panOnScrollMode: A, zoomOnDoubleClick: R, panOnDrag: !Y && W, defaultViewport: I, translateExtent: z, minZoom: B, maxZoom: P, zoomActivationKeyCode: w, preventScrolling: H, noWheelClassName: G, noPanClassName: $, onViewportChange: q, isControlledViewport: Z, paneClickDistance: c, selectionOnDrag: oe, children: C.jsxs(_ke, { onSelectionStart: v, onSelectionEnd: g, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: a, onPaneContextMenu: s, onPaneScroll: l, panOnDrag: W, isSelecting: !!fe, selectionMode: h, selectionKeyPressed: Y, paneClickDistance: c, selectionOnDrag: oe, children: [e, V && C.jsx($ke, { onSelectionContextMenu: L, noPanClassName: $, disableKeyboardA11y: K })] }) });
}
lq.displayName = "FlowRenderer";
const Tke = M.memo(lq), Lke = (e) => (t) => e ? dj(t.nodeLookup, { x: 0, y: 0, width: t.width, height: t.height }, t.transform, !0).map((n) => n.id) : Array.from(t.nodeLookup.keys());
function Fke(e) {
  return pn(M.useCallback(Lke(e), [e]), mr);
}
const Bke = (e) => e.updateNodeInternals;
function Uke() {
  const e = pn(Bke), [t] = M.useState(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((n) => {
    const r = /* @__PURE__ */ new Map();
    n.forEach((a) => {
      const s = a.target.getAttribute("data-id");
      r.set(s, {
        id: s,
        nodeElement: a.target,
        force: !0
      });
    }), e(r);
  }));
  return M.useEffect(() => () => {
    t?.disconnect();
  }, [t]), t;
}
function Vke({ node: e, nodeType: t, hasDimensions: n, resizeObserver: r }) {
  const a = gr(), s = M.useRef(null), l = M.useRef(null), c = M.useRef(e.sourcePosition), d = M.useRef(e.targetPosition), f = M.useRef(t), m = n && !!e.internals.handleBounds;
  return M.useEffect(() => {
    s.current && !e.hidden && (!m || l.current !== s.current) && (l.current && r?.unobserve(l.current), r?.observe(s.current), l.current = s.current);
  }, [m, e.hidden]), M.useEffect(() => () => {
    l.current && (r?.unobserve(l.current), l.current = null);
  }, []), M.useEffect(() => {
    if (s.current) {
      const h = f.current !== t, v = c.current !== e.sourcePosition, g = d.current !== e.targetPosition;
      (h || v || g) && (f.current = t, c.current = e.sourcePosition, d.current = e.targetPosition, a.getState().updateNodeInternals(/* @__PURE__ */ new Map([[e.id, { id: e.id, nodeElement: s.current, force: !0 }]])));
    }
  }, [e.id, t, e.sourcePosition, e.targetPosition]), s;
}
function Hke({ id: e, onClick: t, onMouseEnter: n, onMouseMove: r, onMouseLeave: a, onContextMenu: s, onDoubleClick: l, nodesDraggable: c, elementsSelectable: d, nodesConnectable: f, nodesFocusable: m, resizeObserver: h, noDragClassName: v, noPanClassName: g, disableKeyboardA11y: b, rfId: x, nodeTypes: w, nodeClickDistance: k, onError: E }) {
  const { node: _, internals: O, isParent: N } = pn((ie) => {
    const ce = ie.nodeLookup.get(e), ge = ie.parentLookup.has(e);
    return {
      node: ce,
      internals: ce.internals,
      isParent: ge
    };
  }, mr);
  let A = _.type || "default", R = w?.[A] || U6[A];
  R === void 0 && (E?.("003", Hl.error003(A)), A = "default", R = w?.default || U6.default);
  const D = !!(_.draggable || c && typeof _.draggable > "u"), I = !!(_.selectable || d && typeof _.selectable > "u"), z = !!(_.connectable || f && typeof _.connectable > "u"), B = !!(_.focusable || m && typeof _.focusable > "u"), P = gr(), H = RW(_), L = Vke({ node: _, nodeType: A, hasDimensions: H, resizeObserver: h }), G = aq({
    nodeRef: L,
    disabled: _.hidden || !D,
    noDragClassName: v,
    handleSelector: _.dragHandle,
    nodeId: e,
    isSelectable: I,
    nodeClickDistance: k
  }), $ = iq();
  if (_.hidden)
    return null;
  const K = Jc(_), q = Dke(_), Z = I || D || t || n || r || a, V = n ? (ie) => n(ie, { ...O.userNode }) : void 0, F = r ? (ie) => r(ie, { ...O.userNode }) : void 0, Y = a ? (ie) => a(ie, { ...O.userNode }) : void 0, U = s ? (ie) => s(ie, { ...O.userNode }) : void 0, W = l ? (ie) => l(ie, { ...O.userNode }) : void 0, J = (ie) => {
    const { selectNodesOnDrag: ce, nodeDragThreshold: ge } = P.getState();
    I && (!ce || !D || ge > 0) && R3({
      id: e,
      store: P,
      nodeRef: L
    }), t && t(ie, { ...O.userNode });
  }, oe = (ie) => {
    if (!(DW(ie.nativeEvent) || b)) {
      if (SW.includes(ie.key) && I) {
        const ce = ie.key === "Escape";
        R3({
          id: e,
          store: P,
          unselect: ce,
          nodeRef: L
        });
      } else if (D && _.selected && Object.prototype.hasOwnProperty.call(I2, ie.key)) {
        ie.preventDefault();
        const { ariaLabelConfig: ce } = P.getState();
        P.setState({
          ariaLiveMessage: ce["node.a11yDescription.ariaLiveMessage"]({
            direction: ie.key.replace("Arrow", "").toLowerCase(),
            x: ~~O.positionAbsolute.x,
            y: ~~O.positionAbsolute.y
          })
        }), $({
          direction: I2[ie.key],
          factor: ie.shiftKey ? 4 : 1
        });
      }
    }
  }, fe = () => {
    if (b || !L.current?.matches(":focus-visible"))
      return;
    const { transform: ie, width: ce, height: ge, autoPanOnNodeFocus: re, setCenter: le } = P.getState();
    re && (dj(/* @__PURE__ */ new Map([[e, _]]), { x: 0, y: 0, width: ce, height: ge }, ie, !0).length > 0 || le(_.position.x + K.width / 2, _.position.y + K.height / 2, {
      zoom: ie[2]
    }));
  };
  return C.jsx("div", { className: zr([
    "react-flow__node",
    `react-flow__node-${A}`,
    {
      // this is overwritable by passing `nopan` as a class name
      [g]: D
    },
    _.className,
    {
      selected: _.selected,
      selectable: I,
      parent: N,
      draggable: D,
      dragging: G
    }
  ]), ref: L, style: {
    zIndex: O.z,
    transform: `translate(${O.positionAbsolute.x}px,${O.positionAbsolute.y}px)`,
    pointerEvents: Z ? "all" : "none",
    visibility: H ? "visible" : "hidden",
    ..._.style,
    ...q
  }, "data-id": e, "data-testid": `rf__node-${e}`, onMouseEnter: V, onMouseMove: F, onMouseLeave: Y, onContextMenu: U, onClick: J, onDoubleClick: W, onKeyDown: B ? oe : void 0, tabIndex: B ? 0 : void 0, onFocus: B ? fe : void 0, role: _.ariaRole ?? (B ? "group" : void 0), "aria-roledescription": "node", "aria-describedby": b ? void 0 : `${QW}-${x}`, "aria-label": _.ariaLabel, ..._.domAttributes, children: C.jsx(Cke, { value: e, children: C.jsx(R, { id: e, data: _.data, type: A, positionAbsoluteX: O.positionAbsolute.x, positionAbsoluteY: O.positionAbsolute.y, selected: _.selected ?? !1, selectable: I, draggable: D, deletable: _.deletable ?? !0, isConnectable: z, sourcePosition: _.sourcePosition, targetPosition: _.targetPosition, dragging: G, dragHandle: _.dragHandle, zIndex: O.z, parentId: _.parentId, ...K }) }) });
}
var Wke = M.memo(Hke);
const qke = (e) => ({
  nodesDraggable: e.nodesDraggable,
  nodesConnectable: e.nodesConnectable,
  nodesFocusable: e.nodesFocusable,
  elementsSelectable: e.elementsSelectable,
  onError: e.onError
});
function uq(e) {
  const { nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: a, onError: s } = pn(qke, mr), l = Fke(e.onlyRenderVisibleElements), c = Uke();
  return C.jsx("div", { className: "react-flow__nodes", style: cC, children: l.map((d) => (
    /*
     * The split of responsibilities between NodeRenderer and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For example, when youre dragging a single node, that node gets
     * updated multiple times per second. If `NodeRenderer` were to update
     * every time, it would have to re-run the `nodes.map()` loop every
     * time. This gets pricey with hundreds of nodes, especially if every
     * loop cycle does more than just rendering a JSX element!
     *
     * As a result of this choice, we took the following implementation
     * decisions:
     * - NodeRenderer subscribes *only* to node IDs  and therefore
     *   rerender *only* when visible nodes are added or removed.
     * - NodeRenderer performs all operations the result of which can be
     *   shared between nodes (such as creating the `ResizeObserver`
     *   instance, or subscribing to `selector`). This means extra prop
     *   drilling into `NodeComponentWrapper`, but it means we need to run
     *   these operations only once  instead of once per node.
     * - Any operations that youd normally write inside `nodes.map` are
     *   moved into `NodeComponentWrapper`. This ensures they are
     *   memorized  so if `NodeRenderer` *has* to rerender, it only
     *   needs to regenerate the list of nodes, nothing else.
     */
    C.jsx(Wke, { id: d, nodeTypes: e.nodeTypes, nodeExtent: e.nodeExtent, onClick: e.onNodeClick, onMouseEnter: e.onNodeMouseEnter, onMouseMove: e.onNodeMouseMove, onMouseLeave: e.onNodeMouseLeave, onContextMenu: e.onNodeContextMenu, onDoubleClick: e.onNodeDoubleClick, noDragClassName: e.noDragClassName, noPanClassName: e.noPanClassName, rfId: e.rfId, disableKeyboardA11y: e.disableKeyboardA11y, resizeObserver: c, nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: a, nodeClickDistance: e.nodeClickDistance, onError: s }, d)
  )) });
}
uq.displayName = "NodeRenderer";
const Gke = M.memo(uq);
function Kke(e) {
  return pn(M.useCallback((t) => {
    if (!e)
      return t.edges.map((r) => r.id);
    const n = [];
    if (t.width && t.height)
      for (const r of t.edges) {
        const a = t.nodeLookup.get(r.source), s = t.nodeLookup.get(r.target);
        a && s && eSe({
          sourceNode: a,
          targetNode: s,
          width: t.width,
          height: t.height,
          transform: t.transform
        }) && n.push(r.id);
      }
    return n;
  }, [e]), mr);
}
const Yke = ({ color: e = "none", strokeWidth: t = 1 }) => {
  const n = {
    strokeWidth: t,
    ...e && { stroke: e }
  };
  return C.jsx("polyline", { className: "arrow", style: n, strokeLinecap: "round", fill: "none", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4" });
}, Xke = ({ color: e = "none", strokeWidth: t = 1 }) => {
  const n = {
    strokeWidth: t,
    ...e && { stroke: e, fill: e }
  };
  return C.jsx("polyline", { className: "arrowclosed", style: n, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" });
}, H6 = {
  [j2.Arrow]: Yke,
  [j2.ArrowClosed]: Xke
};
function Jke(e) {
  const t = gr();
  return M.useMemo(() => Object.prototype.hasOwnProperty.call(H6, e) ? H6[e] : (t.getState().onError?.("009", Hl.error009(e)), null), [e]);
}
const Qke = ({ id: e, type: t, color: n, width: r = 12.5, height: a = 12.5, markerUnits: s = "strokeWidth", strokeWidth: l, orient: c = "auto-start-reverse" }) => {
  const d = Jke(t);
  return d ? C.jsx("marker", { className: "react-flow__arrowhead", id: e, markerWidth: `${r}`, markerHeight: `${a}`, viewBox: "-10 -10 20 20", markerUnits: s, orient: c, refX: "0", refY: "0", children: C.jsx(d, { color: n, strokeWidth: l }) }) : null;
}, cq = ({ defaultColor: e, rfId: t }) => {
  const n = pn((s) => s.edges), r = pn((s) => s.defaultEdgeOptions), a = M.useMemo(() => lSe(n, {
    id: t,
    defaultColor: e,
    defaultMarkerStart: r?.markerStart,
    defaultMarkerEnd: r?.markerEnd
  }), [n, r, t, e]);
  return a.length ? C.jsx("svg", { className: "react-flow__marker", "aria-hidden": "true", children: C.jsx("defs", { children: a.map((s) => C.jsx(Qke, { id: s.id, type: s.type, color: s.color, width: s.width, height: s.height, markerUnits: s.markerUnits, strokeWidth: s.strokeWidth, orient: s.orient }, s.id)) }) }) : null;
};
cq.displayName = "MarkerDefinitions";
var Zke = M.memo(cq);
function dq({ x: e, y: t, label: n, labelStyle: r, labelShowBg: a = !0, labelBgStyle: s, labelBgPadding: l = [2, 4], labelBgBorderRadius: c = 2, children: d, className: f, ...m }) {
  const [h, v] = M.useState({ x: 1, y: 0, width: 0, height: 0 }), g = zr(["react-flow__edge-textwrapper", f]), b = M.useRef(null);
  return M.useEffect(() => {
    if (b.current) {
      const x = b.current.getBBox();
      v({
        x: x.x,
        y: x.y,
        width: x.width,
        height: x.height
      });
    }
  }, [n]), n ? C.jsxs("g", { transform: `translate(${e - h.width / 2} ${t - h.height / 2})`, className: g, visibility: h.width ? "visible" : "hidden", ...m, children: [a && C.jsx("rect", { width: h.width + 2 * l[0], x: -l[0], y: -l[1], height: h.height + 2 * l[1], className: "react-flow__edge-textbg", style: s, rx: c, ry: c }), C.jsx("text", { className: "react-flow__edge-text", y: h.height / 2, dy: "0.3em", ref: b, style: r, children: n }), d] }) : null;
}
dq.displayName = "EdgeText";
const e0e = M.memo(dq);
function gk({ path: e, labelX: t, labelY: n, label: r, labelStyle: a, labelShowBg: s, labelBgStyle: l, labelBgPadding: c, labelBgBorderRadius: d, interactionWidth: f = 20, ...m }) {
  return C.jsxs(C.Fragment, { children: [C.jsx("path", { ...m, d: e, fill: "none", className: zr(["react-flow__edge-path", m.className]) }), f ? C.jsx("path", { d: e, fill: "none", strokeOpacity: 0, strokeWidth: f, className: "react-flow__edge-interaction" }) : null, r && Ks(t) && Ks(n) ? C.jsx(e0e, { x: t, y: n, label: r, labelStyle: a, labelShowBg: s, labelBgStyle: l, labelBgPadding: c, labelBgBorderRadius: d }) : null] });
}
function W6({ pos: e, x1: t, y1: n, x2: r, y2: a }) {
  return e === lt.Left || e === lt.Right ? [0.5 * (t + r), n] : [t, 0.5 * (n + a)];
}
function fq({ sourceX: e, sourceY: t, sourcePosition: n = lt.Bottom, targetX: r, targetY: a, targetPosition: s = lt.Top }) {
  const [l, c] = W6({
    pos: n,
    x1: e,
    y1: t,
    x2: r,
    y2: a
  }), [d, f] = W6({
    pos: s,
    x1: r,
    y1: a,
    x2: e,
    y2: t
  }), [m, h, v, g] = $W({
    sourceX: e,
    sourceY: t,
    targetX: r,
    targetY: a,
    sourceControlX: l,
    sourceControlY: c,
    targetControlX: d,
    targetControlY: f
  });
  return [
    `M${e},${t} C${l},${c} ${d},${f} ${r},${a}`,
    m,
    h,
    v,
    g
  ];
}
function pq(e) {
  return M.memo(({ id: t, sourceX: n, sourceY: r, targetX: a, targetY: s, sourcePosition: l, targetPosition: c, label: d, labelStyle: f, labelShowBg: m, labelBgStyle: h, labelBgPadding: v, labelBgBorderRadius: g, style: b, markerEnd: x, markerStart: w, interactionWidth: k }) => {
    const [E, _, O] = fq({
      sourceX: n,
      sourceY: r,
      sourcePosition: l,
      targetX: a,
      targetY: s,
      targetPosition: c
    }), N = e.isInternal ? void 0 : t;
    return C.jsx(gk, { id: N, path: E, labelX: _, labelY: O, label: d, labelStyle: f, labelShowBg: m, labelBgStyle: h, labelBgPadding: v, labelBgBorderRadius: g, style: b, markerEnd: x, markerStart: w, interactionWidth: k });
  });
}
const t0e = pq({ isInternal: !1 }), mq = pq({ isInternal: !0 });
t0e.displayName = "SimpleBezierEdge";
mq.displayName = "SimpleBezierEdgeInternal";
function hq(e) {
  return M.memo(({ id: t, sourceX: n, sourceY: r, targetX: a, targetY: s, label: l, labelStyle: c, labelShowBg: d, labelBgStyle: f, labelBgPadding: m, labelBgBorderRadius: h, style: v, sourcePosition: g = lt.Bottom, targetPosition: b = lt.Top, markerEnd: x, markerStart: w, pathOptions: k, interactionWidth: E }) => {
    const [_, O, N] = O3({
      sourceX: n,
      sourceY: r,
      sourcePosition: g,
      targetX: a,
      targetY: s,
      targetPosition: b,
      borderRadius: k?.borderRadius,
      offset: k?.offset,
      stepPosition: k?.stepPosition
    }), A = e.isInternal ? void 0 : t;
    return C.jsx(gk, { id: A, path: _, labelX: O, labelY: N, label: l, labelStyle: c, labelShowBg: d, labelBgStyle: f, labelBgPadding: m, labelBgBorderRadius: h, style: v, markerEnd: x, markerStart: w, interactionWidth: E });
  });
}
const gq = hq({ isInternal: !1 }), vq = hq({ isInternal: !0 });
gq.displayName = "SmoothStepEdge";
vq.displayName = "SmoothStepEdgeInternal";
function yq(e) {
  return M.memo(({ id: t, ...n }) => {
    const r = e.isInternal ? void 0 : t;
    return C.jsx(gq, { ...n, id: r, pathOptions: M.useMemo(() => ({ borderRadius: 0, offset: n.pathOptions?.offset }), [n.pathOptions?.offset]) });
  });
}
const n0e = yq({ isInternal: !1 }), bq = yq({ isInternal: !0 });
n0e.displayName = "StepEdge";
bq.displayName = "StepEdgeInternal";
function wq(e) {
  return M.memo(({ id: t, sourceX: n, sourceY: r, targetX: a, targetY: s, label: l, labelStyle: c, labelShowBg: d, labelBgStyle: f, labelBgPadding: m, labelBgBorderRadius: h, style: v, markerEnd: g, markerStart: b, interactionWidth: x }) => {
    const [w, k, E] = TW({ sourceX: n, sourceY: r, targetX: a, targetY: s }), _ = e.isInternal ? void 0 : t;
    return C.jsx(gk, { id: _, path: w, labelX: k, labelY: E, label: l, labelStyle: c, labelShowBg: d, labelBgStyle: f, labelBgPadding: m, labelBgBorderRadius: h, style: v, markerEnd: g, markerStart: b, interactionWidth: x });
  });
}
const r0e = wq({ isInternal: !1 }), xq = wq({ isInternal: !0 });
r0e.displayName = "StraightEdge";
xq.displayName = "StraightEdgeInternal";
function Sq(e) {
  return M.memo(({ id: t, sourceX: n, sourceY: r, targetX: a, targetY: s, sourcePosition: l = lt.Bottom, targetPosition: c = lt.Top, label: d, labelStyle: f, labelShowBg: m, labelBgStyle: h, labelBgPadding: v, labelBgBorderRadius: g, style: b, markerEnd: x, markerStart: w, pathOptions: k, interactionWidth: E }) => {
    const [_, O, N] = mj({
      sourceX: n,
      sourceY: r,
      sourcePosition: l,
      targetX: a,
      targetY: s,
      targetPosition: c,
      curvature: k?.curvature
    }), A = e.isInternal ? void 0 : t;
    return C.jsx(gk, { id: A, path: _, labelX: O, labelY: N, label: d, labelStyle: f, labelShowBg: m, labelBgStyle: h, labelBgPadding: v, labelBgBorderRadius: g, style: b, markerEnd: x, markerStart: w, interactionWidth: E });
  });
}
const o0e = Sq({ isInternal: !1 }), kq = Sq({ isInternal: !0 });
o0e.displayName = "BezierEdge";
kq.displayName = "BezierEdgeInternal";
const q6 = {
  default: kq,
  straight: xq,
  step: bq,
  smoothstep: vq,
  simplebezier: mq
}, G6 = {
  sourceX: null,
  sourceY: null,
  targetX: null,
  targetY: null,
  sourcePosition: null,
  targetPosition: null
}, a0e = (e, t, n) => n === lt.Left ? e - t : n === lt.Right ? e + t : e, i0e = (e, t, n) => n === lt.Top ? e - t : n === lt.Bottom ? e + t : e, K6 = "react-flow__edgeupdater";
function Y6({ position: e, centerX: t, centerY: n, radius: r = 10, onMouseDown: a, onMouseEnter: s, onMouseOut: l, type: c }) {
  return C.jsx("circle", { onMouseDown: a, onMouseEnter: s, onMouseOut: l, className: zr([K6, `${K6}-${c}`]), cx: a0e(t, r, e), cy: i0e(n, r, e), r, stroke: "transparent", fill: "transparent" });
}
function s0e({ isReconnectable: e, reconnectRadius: t, edge: n, sourceX: r, sourceY: a, targetX: s, targetY: l, sourcePosition: c, targetPosition: d, onReconnect: f, onReconnectStart: m, onReconnectEnd: h, setReconnecting: v, setUpdateHover: g }) {
  const b = gr(), x = (O, N) => {
    if (O.button !== 0)
      return;
    const { autoPanOnConnect: A, domNode: R, isValidConnection: D, connectionMode: I, connectionRadius: z, lib: B, onConnectStart: P, onConnectEnd: H, cancelConnection: L, nodeLookup: G, rfId: $, panBy: K, updateConnection: q } = b.getState(), Z = N.type === "target", V = (U, W) => {
      v(!1), h?.(U, n, N.type, W);
    }, F = (U) => f?.(n, U), Y = (U, W) => {
      v(!0), m?.(O, n, N.type), P?.(U, W);
    };
    A3.onPointerDown(O.nativeEvent, {
      autoPanOnConnect: A,
      connectionMode: I,
      connectionRadius: z,
      domNode: R,
      handleId: N.id,
      nodeId: N.nodeId,
      nodeLookup: G,
      isTarget: Z,
      edgeUpdaterType: N.type,
      lib: B,
      flowId: $,
      cancelConnection: L,
      panBy: K,
      isValidConnection: D,
      onConnect: F,
      onConnectStart: Y,
      onConnectEnd: H,
      onReconnectEnd: V,
      updateConnection: q,
      getTransform: () => b.getState().transform,
      getFromHandle: () => b.getState().connection.fromHandle,
      dragThreshold: b.getState().connectionDragThreshold,
      handleDomNode: O.currentTarget
    });
  }, w = (O) => x(O, { nodeId: n.target, id: n.targetHandle ?? null, type: "target" }), k = (O) => x(O, { nodeId: n.source, id: n.sourceHandle ?? null, type: "source" }), E = () => g(!0), _ = () => g(!1);
  return C.jsxs(C.Fragment, { children: [(e === !0 || e === "source") && C.jsx(Y6, { position: c, centerX: r, centerY: a, radius: t, onMouseDown: w, onMouseEnter: E, onMouseOut: _, type: "source" }), (e === !0 || e === "target") && C.jsx(Y6, { position: d, centerX: s, centerY: l, radius: t, onMouseDown: k, onMouseEnter: E, onMouseOut: _, type: "target" })] });
}
function l0e({ id: e, edgesFocusable: t, edgesReconnectable: n, elementsSelectable: r, onClick: a, onDoubleClick: s, onContextMenu: l, onMouseEnter: c, onMouseMove: d, onMouseLeave: f, reconnectRadius: m, onReconnect: h, onReconnectStart: v, onReconnectEnd: g, rfId: b, edgeTypes: x, noPanClassName: w, onError: k, disableKeyboardA11y: E }) {
  let _ = pn((le) => le.edgeLookup.get(e));
  const O = pn((le) => le.defaultEdgeOptions);
  _ = O ? { ...O, ..._ } : _;
  let N = _.type || "default", A = x?.[N] || q6[N];
  A === void 0 && (k?.("011", Hl.error011(N)), N = "default", A = x?.default || q6.default);
  const R = !!(_.focusable || t && typeof _.focusable > "u"), D = typeof h < "u" && (_.reconnectable || n && typeof _.reconnectable > "u"), I = !!(_.selectable || r && typeof _.selectable > "u"), z = M.useRef(null), [B, P] = M.useState(!1), [H, L] = M.useState(!1), G = gr(), { zIndex: $, sourceX: K, sourceY: q, targetX: Z, targetY: V, sourcePosition: F, targetPosition: Y } = pn(M.useCallback((le) => {
    const me = le.nodeLookup.get(_.source), ve = le.nodeLookup.get(_.target);
    if (!me || !ve)
      return {
        zIndex: _.zIndex,
        ...G6
      };
    const xe = sSe({
      id: e,
      sourceNode: me,
      targetNode: ve,
      sourceHandle: _.sourceHandle || null,
      targetHandle: _.targetHandle || null,
      connectionMode: le.connectionMode,
      onError: k
    });
    return {
      zIndex: Zxe({
        selected: _.selected,
        zIndex: _.zIndex,
        sourceNode: me,
        targetNode: ve,
        elevateOnSelect: le.elevateEdgesOnSelect,
        zIndexMode: le.zIndexMode
      }),
      ...xe || G6
    };
  }, [_.source, _.target, _.sourceHandle, _.targetHandle, _.selected, _.zIndex]), mr), U = M.useMemo(() => _.markerStart ? `url('#${M3(_.markerStart, b)}')` : void 0, [_.markerStart, b]), W = M.useMemo(() => _.markerEnd ? `url('#${M3(_.markerEnd, b)}')` : void 0, [_.markerEnd, b]);
  if (_.hidden || K === null || q === null || Z === null || V === null)
    return null;
  const J = (le) => {
    const { addSelectedEdges: me, unselectNodesAndEdges: ve, multiSelectionActive: xe } = G.getState();
    I && (G.setState({ nodesSelectionActive: !1 }), _.selected && xe ? (ve({ nodes: [], edges: [_] }), z.current?.blur()) : me([e])), a && a(le, _);
  }, oe = s ? (le) => {
    s(le, { ..._ });
  } : void 0, fe = l ? (le) => {
    l(le, { ..._ });
  } : void 0, ie = c ? (le) => {
    c(le, { ..._ });
  } : void 0, ce = d ? (le) => {
    d(le, { ..._ });
  } : void 0, ge = f ? (le) => {
    f(le, { ..._ });
  } : void 0, re = (le) => {
    if (!E && SW.includes(le.key) && I) {
      const { unselectNodesAndEdges: me, addSelectedEdges: ve } = G.getState();
      le.key === "Escape" ? (z.current?.blur(), me({ edges: [_] })) : ve([e]);
    }
  };
  return C.jsx("svg", { style: { zIndex: $ }, children: C.jsxs("g", { className: zr([
    "react-flow__edge",
    `react-flow__edge-${N}`,
    _.className,
    w,
    {
      selected: _.selected,
      animated: _.animated,
      inactive: !I && !a,
      updating: B,
      selectable: I
    }
  ]), onClick: J, onDoubleClick: oe, onContextMenu: fe, onMouseEnter: ie, onMouseMove: ce, onMouseLeave: ge, onKeyDown: R ? re : void 0, tabIndex: R ? 0 : void 0, role: _.ariaRole ?? (R ? "group" : "img"), "aria-roledescription": "edge", "data-id": e, "data-testid": `rf__edge-${e}`, "aria-label": _.ariaLabel === null ? void 0 : _.ariaLabel || `Edge from ${_.source} to ${_.target}`, "aria-describedby": R ? `${ZW}-${b}` : void 0, ref: z, ..._.domAttributes, children: [!H && C.jsx(A, { id: e, source: _.source, target: _.target, type: _.type, selected: _.selected, animated: _.animated, selectable: I, deletable: _.deletable ?? !0, label: _.label, labelStyle: _.labelStyle, labelShowBg: _.labelShowBg, labelBgStyle: _.labelBgStyle, labelBgPadding: _.labelBgPadding, labelBgBorderRadius: _.labelBgBorderRadius, sourceX: K, sourceY: q, targetX: Z, targetY: V, sourcePosition: F, targetPosition: Y, data: _.data, style: _.style, sourceHandleId: _.sourceHandle, targetHandleId: _.targetHandle, markerStart: U, markerEnd: W, pathOptions: "pathOptions" in _ ? _.pathOptions : void 0, interactionWidth: _.interactionWidth }), D && C.jsx(s0e, { edge: _, isReconnectable: D, reconnectRadius: m, onReconnect: h, onReconnectStart: v, onReconnectEnd: g, sourceX: K, sourceY: q, targetX: Z, targetY: V, sourcePosition: F, targetPosition: Y, setUpdateHover: P, setReconnecting: L })] }) });
}
var u0e = M.memo(l0e);
const c0e = (e) => ({
  edgesFocusable: e.edgesFocusable,
  edgesReconnectable: e.edgesReconnectable,
  elementsSelectable: e.elementsSelectable,
  connectionMode: e.connectionMode,
  onError: e.onError
});
function _q({ defaultMarkerColor: e, onlyRenderVisibleElements: t, rfId: n, edgeTypes: r, noPanClassName: a, onReconnect: s, onEdgeContextMenu: l, onEdgeMouseEnter: c, onEdgeMouseMove: d, onEdgeMouseLeave: f, onEdgeClick: m, reconnectRadius: h, onEdgeDoubleClick: v, onReconnectStart: g, onReconnectEnd: b, disableKeyboardA11y: x }) {
  const { edgesFocusable: w, edgesReconnectable: k, elementsSelectable: E, onError: _ } = pn(c0e, mr), O = Kke(t);
  return C.jsxs("div", { className: "react-flow__edges", children: [C.jsx(Zke, { defaultColor: e, rfId: n }), O.map((N) => C.jsx(u0e, { id: N, edgesFocusable: w, edgesReconnectable: k, elementsSelectable: E, noPanClassName: a, onReconnect: s, onContextMenu: l, onMouseEnter: c, onMouseMove: d, onMouseLeave: f, onClick: m, reconnectRadius: h, onDoubleClick: v, onReconnectStart: g, onReconnectEnd: b, rfId: n, onError: _, edgeTypes: r, disableKeyboardA11y: x }, N))] });
}
_q.displayName = "EdgeRenderer";
const d0e = M.memo(_q), f0e = (e) => `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`;
function p0e({ children: e }) {
  const t = pn(f0e);
  return C.jsx("div", { className: "react-flow__viewport xyflow__viewport react-flow__container", style: { transform: t }, children: e });
}
function m0e(e) {
  const t = Jm(), n = M.useRef(!1);
  M.useEffect(() => {
    !n.current && t.viewportInitialized && e && (setTimeout(() => e(t), 1), n.current = !0);
  }, [e, t.viewportInitialized]);
}
const h0e = (e) => e.panZoom?.syncViewport;
function g0e(e) {
  const t = pn(h0e), n = gr();
  return M.useEffect(() => {
    e && (t?.(e), n.setState({ transform: [e.x, e.y, e.zoom] }));
  }, [e, t]), null;
}
function v0e(e) {
  return e.connection.inProgress ? { ...e.connection, to: hk(e.connection.to, e.transform) } : { ...e.connection };
}
function y0e(e) {
  return v0e;
}
function b0e(e) {
  const t = y0e();
  return pn(t, mr);
}
const w0e = (e) => ({
  nodesConnectable: e.nodesConnectable,
  isValid: e.connection.isValid,
  inProgress: e.connection.inProgress,
  width: e.width,
  height: e.height
});
function x0e({ containerStyle: e, style: t, type: n, component: r }) {
  const { nodesConnectable: a, width: s, height: l, isValid: c, inProgress: d } = pn(w0e, mr);
  return s && a && d ? C.jsx("svg", { style: e, width: s, height: l, className: "react-flow__connectionline react-flow__container", children: C.jsx("g", { className: zr(["react-flow__connection", EW(c)]), children: C.jsx(Eq, { style: t, type: n, CustomComponent: r, isValid: c }) }) }) : null;
}
const Eq = ({ style: e, type: t = md.Bezier, CustomComponent: n, isValid: r }) => {
  const { inProgress: a, from: s, fromNode: l, fromHandle: c, fromPosition: d, to: f, toNode: m, toHandle: h, toPosition: v, pointer: g } = b0e();
  if (!a)
    return;
  if (n)
    return C.jsx(n, { connectionLineType: t, connectionLineStyle: e, fromNode: l, fromHandle: c, fromX: s.x, fromY: s.y, toX: f.x, toY: f.y, fromPosition: d, toPosition: v, connectionStatus: EW(r), toNode: m, toHandle: h, pointer: g });
  let b = "";
  const x = {
    sourceX: s.x,
    sourceY: s.y,
    sourcePosition: d,
    targetX: f.x,
    targetY: f.y,
    targetPosition: v
  };
  switch (t) {
    case md.Bezier:
      [b] = mj(x);
      break;
    case md.SimpleBezier:
      [b] = fq(x);
      break;
    case md.Step:
      [b] = O3({
        ...x,
        borderRadius: 0
      });
      break;
    case md.SmoothStep:
      [b] = O3(x);
      break;
    default:
      [b] = TW(x);
  }
  return C.jsx("path", { d: b, fill: "none", className: "react-flow__connection-path", style: e });
};
Eq.displayName = "ConnectionLine";
const S0e = {};
function X6(e = S0e) {
  M.useRef(e), gr(), M.useEffect(() => {
  }, [e]);
}
function k0e() {
  gr(), M.useRef(!1), M.useEffect(() => {
  }, []);
}
function Cq({ nodeTypes: e, edgeTypes: t, onInit: n, onNodeClick: r, onEdgeClick: a, onNodeDoubleClick: s, onEdgeDoubleClick: l, onNodeMouseEnter: c, onNodeMouseMove: d, onNodeMouseLeave: f, onNodeContextMenu: m, onSelectionContextMenu: h, onSelectionStart: v, onSelectionEnd: g, connectionLineType: b, connectionLineStyle: x, connectionLineComponent: w, connectionLineContainerStyle: k, selectionKeyCode: E, selectionOnDrag: _, selectionMode: O, multiSelectionKeyCode: N, panActivationKeyCode: A, zoomActivationKeyCode: R, deleteKeyCode: D, onlyRenderVisibleElements: I, elementsSelectable: z, defaultViewport: B, translateExtent: P, minZoom: H, maxZoom: L, preventScrolling: G, defaultMarkerColor: $, zoomOnScroll: K, zoomOnPinch: q, panOnScroll: Z, panOnScrollSpeed: V, panOnScrollMode: F, zoomOnDoubleClick: Y, panOnDrag: U, onPaneClick: W, onPaneMouseEnter: J, onPaneMouseMove: oe, onPaneMouseLeave: fe, onPaneScroll: ie, onPaneContextMenu: ce, paneClickDistance: ge, nodeClickDistance: re, onEdgeContextMenu: le, onEdgeMouseEnter: me, onEdgeMouseMove: ve, onEdgeMouseLeave: xe, reconnectRadius: _e, onReconnect: Ge, onReconnectStart: Xe, onReconnectEnd: tt, noDragClassName: nt, noWheelClassName: je, noPanClassName: cn, disableKeyboardA11y: pt, nodeExtent: Ce, rfId: Me, viewport: he, onViewportChange: ye }) {
  return X6(e), X6(t), k0e(), m0e(n), g0e(he), C.jsx(Tke, { onPaneClick: W, onPaneMouseEnter: J, onPaneMouseMove: oe, onPaneMouseLeave: fe, onPaneContextMenu: ce, onPaneScroll: ie, paneClickDistance: ge, deleteKeyCode: D, selectionKeyCode: E, selectionOnDrag: _, selectionMode: O, onSelectionStart: v, onSelectionEnd: g, multiSelectionKeyCode: N, panActivationKeyCode: A, zoomActivationKeyCode: R, elementsSelectable: z, zoomOnScroll: K, zoomOnPinch: q, zoomOnDoubleClick: Y, panOnScroll: Z, panOnScrollSpeed: V, panOnScrollMode: F, panOnDrag: U, defaultViewport: B, translateExtent: P, minZoom: H, maxZoom: L, onSelectionContextMenu: h, preventScrolling: G, noDragClassName: nt, noWheelClassName: je, noPanClassName: cn, disableKeyboardA11y: pt, onViewportChange: ye, isControlledViewport: !!he, children: C.jsxs(p0e, { children: [C.jsx(d0e, { edgeTypes: t, onEdgeClick: a, onEdgeDoubleClick: l, onReconnect: Ge, onReconnectStart: Xe, onReconnectEnd: tt, onlyRenderVisibleElements: I, onEdgeContextMenu: le, onEdgeMouseEnter: me, onEdgeMouseMove: ve, onEdgeMouseLeave: xe, reconnectRadius: _e, defaultMarkerColor: $, noPanClassName: cn, disableKeyboardA11y: pt, rfId: Me }), C.jsx(x0e, { style: x, type: b, component: w, containerStyle: k }), C.jsx("div", { className: "react-flow__edgelabel-renderer" }), C.jsx(Gke, { nodeTypes: e, onNodeClick: r, onNodeDoubleClick: s, onNodeMouseEnter: c, onNodeMouseMove: d, onNodeMouseLeave: f, onNodeContextMenu: m, nodeClickDistance: re, onlyRenderVisibleElements: I, noPanClassName: cn, noDragClassName: nt, disableKeyboardA11y: pt, nodeExtent: Ce, rfId: Me }), C.jsx("div", { className: "react-flow__viewport-portal" })] }) });
}
Cq.displayName = "GraphView";
const _0e = M.memo(Cq), J6 = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: a, height: s, fitView: l, fitViewOptions: c, minZoom: d = 0.5, maxZoom: f = 2, nodeOrigin: m, nodeExtent: h, zIndexMode: v = "basic" } = {}) => {
  const g = /* @__PURE__ */ new Map(), b = /* @__PURE__ */ new Map(), x = /* @__PURE__ */ new Map(), w = /* @__PURE__ */ new Map(), k = r ?? t ?? [], E = n ?? e ?? [], _ = m ?? [0, 0], O = h ?? mS;
  BW(x, w, k);
  const N = N3(E, g, b, {
    nodeOrigin: _,
    nodeExtent: O,
    zIndexMode: v
  });
  let A = [0, 0, 1];
  if (l && a && s) {
    const R = pk(g, {
      filter: (B) => !!((B.width || B.initialWidth) && (B.height || B.initialHeight))
    }), { x: D, y: I, zoom: z } = fj(R, a, s, d, f, c?.padding ?? 0.1);
    A = [D, I, z];
  }
  return {
    rfId: "1",
    width: a ?? 0,
    height: s ?? 0,
    transform: A,
    nodes: E,
    nodesInitialized: N,
    nodeLookup: g,
    parentLookup: b,
    edges: k,
    edgeLookup: w,
    connectionLookup: x,
    onNodesChange: null,
    onEdgesChange: null,
    hasDefaultNodes: n !== void 0,
    hasDefaultEdges: r !== void 0,
    panZoom: null,
    minZoom: d,
    maxZoom: f,
    translateExtent: mS,
    nodeExtent: O,
    nodesSelectionActive: !1,
    userSelectionActive: !1,
    userSelectionRect: null,
    connectionMode: xg.Strict,
    domNode: null,
    paneDragging: !1,
    noPanClassName: "nopan",
    nodeOrigin: _,
    nodeDragThreshold: 1,
    connectionDragThreshold: 1,
    snapGrid: [15, 15],
    snapToGrid: !1,
    nodesDraggable: !0,
    nodesConnectable: !0,
    nodesFocusable: !0,
    edgesFocusable: !0,
    edgesReconnectable: !0,
    elementsSelectable: !0,
    elevateNodesOnSelect: !0,
    elevateEdgesOnSelect: !0,
    selectNodesOnDrag: !0,
    multiSelectionActive: !1,
    fitViewQueued: l ?? !1,
    fitViewOptions: c,
    fitViewResolver: null,
    connection: { ..._W },
    connectionClickStartHandle: null,
    connectOnClick: !0,
    ariaLiveMessage: "",
    autoPanOnConnect: !0,
    autoPanOnNodeDrag: !0,
    autoPanOnNodeFocus: !0,
    autoPanSpeed: 15,
    connectionRadius: 20,
    onError: Gxe,
    isValidConnection: void 0,
    onSelectionChangeHandlers: [],
    lib: "react",
    debug: !1,
    ariaLabelConfig: kW,
    zIndexMode: v,
    onNodesChangeMiddlewareMap: /* @__PURE__ */ new Map(),
    onEdgesChangeMiddlewareMap: /* @__PURE__ */ new Map()
  };
}, E0e = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: a, height: s, fitView: l, fitViewOptions: c, minZoom: d, maxZoom: f, nodeOrigin: m, nodeExtent: h, zIndexMode: v }) => VSe((g, b) => {
  async function x() {
    const { nodeLookup: w, panZoom: k, fitViewOptions: E, fitViewResolver: _, width: O, height: N, minZoom: A, maxZoom: R } = b();
    k && (await Wxe({
      nodes: w,
      width: O,
      height: N,
      panZoom: k,
      minZoom: A,
      maxZoom: R
    }, E), _?.resolve(!0), g({ fitViewResolver: null }));
  }
  return {
    ...J6({
      nodes: e,
      edges: t,
      width: a,
      height: s,
      fitView: l,
      fitViewOptions: c,
      minZoom: d,
      maxZoom: f,
      nodeOrigin: m,
      nodeExtent: h,
      defaultNodes: n,
      defaultEdges: r,
      zIndexMode: v
    }),
    setNodes: (w) => {
      const { nodeLookup: k, parentLookup: E, nodeOrigin: _, elevateNodesOnSelect: O, fitViewQueued: N, zIndexMode: A } = b(), R = N3(w, k, E, {
        nodeOrigin: _,
        nodeExtent: h,
        elevateNodesOnSelect: O,
        checkEquality: !0,
        zIndexMode: A
      });
      N && R ? (x(), g({ nodes: w, nodesInitialized: R, fitViewQueued: !1, fitViewOptions: void 0 })) : g({ nodes: w, nodesInitialized: R });
    },
    setEdges: (w) => {
      const { connectionLookup: k, edgeLookup: E } = b();
      BW(k, E, w), g({ edges: w });
    },
    setDefaultNodesAndEdges: (w, k) => {
      if (w) {
        const { setNodes: E } = b();
        E(w), g({ hasDefaultNodes: !0 });
      }
      if (k) {
        const { setEdges: E } = b();
        E(k), g({ hasDefaultEdges: !0 });
      }
    },
    /*
     * Every node gets registerd at a ResizeObserver. Whenever a node
     * changes its dimensions, this function is called to measure the
     * new dimensions and update the nodes.
     */
    updateNodeInternals: (w) => {
      const { triggerNodeChanges: k, nodeLookup: E, parentLookup: _, domNode: O, nodeOrigin: N, nodeExtent: A, debug: R, fitViewQueued: D, zIndexMode: I } = b(), { changes: z, updatedInternals: B } = hSe(w, E, _, O, N, A, I);
      B && (dSe(E, _, { nodeOrigin: N, nodeExtent: A, zIndexMode: I }), D ? (x(), g({ fitViewQueued: !1, fitViewOptions: void 0 })) : g({}), z?.length > 0 && (R && console.log("React Flow: trigger node changes", z), k?.(z)));
    },
    updateNodePositions: (w, k = !1) => {
      const E = [];
      let _ = [];
      const { nodeLookup: O, triggerNodeChanges: N, connection: A, updateConnection: R, onNodesChangeMiddlewareMap: D } = b();
      for (const [I, z] of w) {
        const B = O.get(I), P = !!(B?.expandParent && B?.parentId && z?.position), H = {
          id: I,
          type: "position",
          position: P ? {
            x: Math.max(0, z.position.x),
            y: Math.max(0, z.position.y)
          } : z.position,
          dragging: k
        };
        if (B && A.inProgress && A.fromNode.id === B.id) {
          const L = Um(B, A.fromHandle, lt.Left, !0);
          R({ ...A, from: L });
        }
        P && B.parentId && E.push({
          id: I,
          parentId: B.parentId,
          rect: {
            ...z.internals.positionAbsolute,
            width: z.measured.width ?? 0,
            height: z.measured.height ?? 0
          }
        }), _.push(H);
      }
      if (E.length > 0) {
        const { parentLookup: I, nodeOrigin: z } = b(), B = bj(E, O, I, z);
        _.push(...B);
      }
      for (const I of D.values())
        _ = I(_);
      N(_);
    },
    triggerNodeChanges: (w) => {
      const { onNodesChange: k, setNodes: E, nodes: _, hasDefaultNodes: O, debug: N } = b();
      if (w?.length) {
        if (O) {
          const A = wj(w, _);
          E(A);
        }
        N && console.log("React Flow: trigger node changes", w), k?.(w);
      }
    },
    triggerEdgeChanges: (w) => {
      const { onEdgesChange: k, setEdges: E, edges: _, hasDefaultEdges: O, debug: N } = b();
      if (w?.length) {
        if (O) {
          const A = nq(w, _);
          E(A);
        }
        N && console.log("React Flow: trigger edge changes", w), k?.(w);
      }
    },
    addSelectedNodes: (w) => {
      const { multiSelectionActive: k, edgeLookup: E, nodeLookup: _, triggerNodeChanges: O, triggerEdgeChanges: N } = b();
      if (k) {
        const A = w.map((R) => wm(R, !0));
        O(A);
        return;
      }
      O(Wh(_, /* @__PURE__ */ new Set([...w]), !0)), N(Wh(E));
    },
    addSelectedEdges: (w) => {
      const { multiSelectionActive: k, edgeLookup: E, nodeLookup: _, triggerNodeChanges: O, triggerEdgeChanges: N } = b();
      if (k) {
        const A = w.map((R) => wm(R, !0));
        N(A);
        return;
      }
      N(Wh(E, /* @__PURE__ */ new Set([...w]))), O(Wh(_, /* @__PURE__ */ new Set(), !0));
    },
    unselectNodesAndEdges: ({ nodes: w, edges: k } = {}) => {
      const { edges: E, nodes: _, nodeLookup: O, triggerNodeChanges: N, triggerEdgeChanges: A } = b(), R = w || _, D = k || E, I = R.map((B) => {
        const P = O.get(B.id);
        return P && (P.selected = !1), wm(B.id, !1);
      }), z = D.map((B) => wm(B.id, !1));
      N(I), A(z);
    },
    setMinZoom: (w) => {
      const { panZoom: k, maxZoom: E } = b();
      k?.setScaleExtent([w, E]), g({ minZoom: w });
    },
    setMaxZoom: (w) => {
      const { panZoom: k, minZoom: E } = b();
      k?.setScaleExtent([E, w]), g({ maxZoom: w });
    },
    setTranslateExtent: (w) => {
      b().panZoom?.setTranslateExtent(w), g({ translateExtent: w });
    },
    resetSelectedElements: () => {
      const { edges: w, nodes: k, triggerNodeChanges: E, triggerEdgeChanges: _, elementsSelectable: O } = b();
      if (!O)
        return;
      const N = k.reduce((R, D) => D.selected ? [...R, wm(D.id, !1)] : R, []), A = w.reduce((R, D) => D.selected ? [...R, wm(D.id, !1)] : R, []);
      E(N), _(A);
    },
    setNodeExtent: (w) => {
      const { nodes: k, nodeLookup: E, parentLookup: _, nodeOrigin: O, elevateNodesOnSelect: N, nodeExtent: A, zIndexMode: R } = b();
      w[0][0] === A[0][0] && w[0][1] === A[0][1] && w[1][0] === A[1][0] && w[1][1] === A[1][1] || (N3(k, E, _, {
        nodeOrigin: O,
        nodeExtent: w,
        elevateNodesOnSelect: N,
        checkEquality: !1,
        zIndexMode: R
      }), g({ nodeExtent: w }));
    },
    panBy: (w) => {
      const { transform: k, width: E, height: _, panZoom: O, translateExtent: N } = b();
      return gSe({ delta: w, panZoom: O, transform: k, translateExtent: N, width: E, height: _ });
    },
    setCenter: async (w, k, E) => {
      const { width: _, height: O, maxZoom: N, panZoom: A } = b();
      if (!A)
        return Promise.resolve(!1);
      const R = typeof E?.zoom < "u" ? E.zoom : N;
      return await A.setViewport({
        x: _ / 2 - w * R,
        y: O / 2 - k * R,
        zoom: R
      }, { duration: E?.duration, ease: E?.ease, interpolate: E?.interpolate }), Promise.resolve(!0);
    },
    cancelConnection: () => {
      g({
        connection: { ..._W }
      });
    },
    updateConnection: (w) => {
      g({ connection: w });
    },
    reset: () => g({ ...J6() })
  };
}, Object.is);
function C0e({ initialNodes: e, initialEdges: t, defaultNodes: n, defaultEdges: r, initialWidth: a, initialHeight: s, initialMinZoom: l, initialMaxZoom: c, initialFitViewOptions: d, fitView: f, nodeOrigin: m, nodeExtent: h, zIndexMode: v, children: g }) {
  const [b] = M.useState(() => E0e({
    nodes: e,
    edges: t,
    defaultNodes: n,
    defaultEdges: r,
    width: a,
    height: s,
    fitView: f,
    minZoom: l,
    maxZoom: c,
    fitViewOptions: d,
    nodeOrigin: m,
    nodeExtent: h,
    zIndexMode: v
  }));
  return C.jsx(HSe, { value: b, children: C.jsx(pke, { children: g }) });
}
function O0e({ children: e, nodes: t, edges: n, defaultNodes: r, defaultEdges: a, width: s, height: l, fitView: c, fitViewOptions: d, minZoom: f, maxZoom: m, nodeOrigin: h, nodeExtent: v, zIndexMode: g }) {
  return M.useContext(lC) ? C.jsx(C.Fragment, { children: e }) : C.jsx(C0e, { initialNodes: t, initialEdges: n, defaultNodes: r, defaultEdges: a, initialWidth: s, initialHeight: l, fitView: c, initialFitViewOptions: d, initialMinZoom: f, initialMaxZoom: m, nodeOrigin: h, nodeExtent: v, zIndexMode: g, children: e });
}
const M0e = {
  width: "100%",
  height: "100%",
  overflow: "hidden",
  position: "relative",
  zIndex: 0
};
function N0e({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, className: a, nodeTypes: s, edgeTypes: l, onNodeClick: c, onEdgeClick: d, onInit: f, onMove: m, onMoveStart: h, onMoveEnd: v, onConnect: g, onConnectStart: b, onConnectEnd: x, onClickConnectStart: w, onClickConnectEnd: k, onNodeMouseEnter: E, onNodeMouseMove: _, onNodeMouseLeave: O, onNodeContextMenu: N, onNodeDoubleClick: A, onNodeDragStart: R, onNodeDrag: D, onNodeDragStop: I, onNodesDelete: z, onEdgesDelete: B, onDelete: P, onSelectionChange: H, onSelectionDragStart: L, onSelectionDrag: G, onSelectionDragStop: $, onSelectionContextMenu: K, onSelectionStart: q, onSelectionEnd: Z, onBeforeDelete: V, connectionMode: F, connectionLineType: Y = md.Bezier, connectionLineStyle: U, connectionLineComponent: W, connectionLineContainerStyle: J, deleteKeyCode: oe = "Backspace", selectionKeyCode: fe = "Shift", selectionOnDrag: ie = !1, selectionMode: ce = hS.Full, panActivationKeyCode: ge = "Space", multiSelectionKeyCode: re = vS() ? "Meta" : "Control", zoomActivationKeyCode: le = vS() ? "Meta" : "Control", snapToGrid: me, snapGrid: ve, onlyRenderVisibleElements: xe = !1, selectNodesOnDrag: _e, nodesDraggable: Ge, autoPanOnNodeFocus: Xe, nodesConnectable: tt, nodesFocusable: nt, nodeOrigin: je = eq, edgesFocusable: cn, edgesReconnectable: pt, elementsSelectable: Ce = !0, defaultViewport: Me = rke, minZoom: he = 0.5, maxZoom: ye = 2, translateExtent: Ee = mS, preventScrolling: Te = !0, nodeExtent: Fe, defaultMarkerColor: Ut = "#b1b1b7", zoomOnScroll: Vt = !0, zoomOnPinch: Xt = !0, panOnScroll: Nt = !1, panOnScrollSpeed: kn = 0.5, panOnScrollMode: Ae = jm.Free, zoomOnDoubleClick: Ht = !0, panOnDrag: Zt = !0, onPaneClick: Bo, onPaneMouseEnter: Uo, onPaneMouseMove: hn, onPaneMouseLeave: On, onPaneScroll: _r, onPaneContextMenu: Vo, paneClickDistance: vr = 1, nodeClickDistance: Zg = 0, children: qd, onReconnect: tu, onReconnectStart: Ta, onReconnectEnd: ev, onEdgeContextMenu: Gd, onEdgeDoubleClick: Kd, onEdgeMouseEnter: Yd, onEdgeMouseMove: nu, onEdgeMouseLeave: ru, reconnectRadius: Xd = 10, onNodesChange: Jd, onEdgesChange: Tr, noDragClassName: en = "nodrag", noWheelClassName: yn = "nowheel", noPanClassName: Ho = "nopan", fitView: cl, fitViewOptions: dh, connectOnClick: tv, attributionPosition: Qd, proOptions: La, defaultEdgeOptions: ou, elevateNodesOnSelect: na = !0, elevateEdgesOnSelect: ra = !1, disableKeyboardA11y: Na = !1, autoPanOnConnect: oa, autoPanOnNodeDrag: Wt, autoPanSpeed: Zd, connectionRadius: ef, isValidConnection: lo, onError: aa, style: nv, id: od, nodeDragThreshold: tf, connectionDragThreshold: rv, viewport: Ji, onViewportChange: Qi, width: Er, height: Fn, colorMode: nf = "light", debug: ov, onScroll: dl, ariaLabelConfig: rf, zIndexMode: Di = "basic", ...av }, Jn) {
  const Zi = od || "1", of = ske(nf), au = M.useCallback((Wo) => {
    Wo.currentTarget.scrollTo({ top: 0, left: 0, behavior: "instant" }), dl?.(Wo);
  }, [dl]);
  return C.jsx("div", { "data-testid": "rf__wrapper", ...av, onScroll: au, style: { ...nv, ...M0e }, ref: Jn, className: zr(["react-flow", a, of]), id: od, role: "application", children: C.jsxs(O0e, { nodes: e, edges: t, width: Er, height: Fn, fitView: cl, fitViewOptions: dh, minZoom: he, maxZoom: ye, nodeOrigin: je, nodeExtent: Fe, zIndexMode: Di, children: [C.jsx(_0e, { onInit: f, onNodeClick: c, onEdgeClick: d, onNodeMouseEnter: E, onNodeMouseMove: _, onNodeMouseLeave: O, onNodeContextMenu: N, onNodeDoubleClick: A, nodeTypes: s, edgeTypes: l, connectionLineType: Y, connectionLineStyle: U, connectionLineComponent: W, connectionLineContainerStyle: J, selectionKeyCode: fe, selectionOnDrag: ie, selectionMode: ce, deleteKeyCode: oe, multiSelectionKeyCode: re, panActivationKeyCode: ge, zoomActivationKeyCode: le, onlyRenderVisibleElements: xe, defaultViewport: Me, translateExtent: Ee, minZoom: he, maxZoom: ye, preventScrolling: Te, zoomOnScroll: Vt, zoomOnPinch: Xt, zoomOnDoubleClick: Ht, panOnScroll: Nt, panOnScrollSpeed: kn, panOnScrollMode: Ae, panOnDrag: Zt, onPaneClick: Bo, onPaneMouseEnter: Uo, onPaneMouseMove: hn, onPaneMouseLeave: On, onPaneScroll: _r, onPaneContextMenu: Vo, paneClickDistance: vr, nodeClickDistance: Zg, onSelectionContextMenu: K, onSelectionStart: q, onSelectionEnd: Z, onReconnect: tu, onReconnectStart: Ta, onReconnectEnd: ev, onEdgeContextMenu: Gd, onEdgeDoubleClick: Kd, onEdgeMouseEnter: Yd, onEdgeMouseMove: nu, onEdgeMouseLeave: ru, reconnectRadius: Xd, defaultMarkerColor: Ut, noDragClassName: en, noWheelClassName: yn, noPanClassName: Ho, rfId: Zi, disableKeyboardA11y: Na, nodeExtent: Fe, viewport: Ji, onViewportChange: Qi }), C.jsx(ike, { nodes: e, edges: t, defaultNodes: n, defaultEdges: r, onConnect: g, onConnectStart: b, onConnectEnd: x, onClickConnectStart: w, onClickConnectEnd: k, nodesDraggable: Ge, autoPanOnNodeFocus: Xe, nodesConnectable: tt, nodesFocusable: nt, edgesFocusable: cn, edgesReconnectable: pt, elementsSelectable: Ce, elevateNodesOnSelect: na, elevateEdgesOnSelect: ra, minZoom: he, maxZoom: ye, nodeExtent: Fe, onNodesChange: Jd, onEdgesChange: Tr, snapToGrid: me, snapGrid: ve, connectionMode: F, translateExtent: Ee, connectOnClick: tv, defaultEdgeOptions: ou, fitView: cl, fitViewOptions: dh, onNodesDelete: z, onEdgesDelete: B, onDelete: P, onNodeDragStart: R, onNodeDrag: D, onNodeDragStop: I, onSelectionDrag: G, onSelectionDragStart: L, onSelectionDragStop: $, onMove: m, onMoveStart: h, onMoveEnd: v, noPanClassName: Ho, nodeOrigin: je, rfId: Zi, autoPanOnConnect: oa, autoPanOnNodeDrag: Wt, autoPanSpeed: Zd, onError: aa, connectionRadius: ef, isValidConnection: lo, selectNodesOnDrag: _e, nodeDragThreshold: tf, connectionDragThreshold: rv, onBeforeDelete: V, debug: ov, ariaLabelConfig: rf, zIndexMode: Di }), C.jsx(nke, { onSelectionChange: H }), qd, C.jsx(JSe, { proOptions: La, position: Qd }), C.jsx(XSe, { rfId: Zi, disableKeyboardA11y: Na })] }) });
}
var A0e = rq(N0e);
function R0e({ dimensions: e, lineWidth: t, variant: n, className: r }) {
  return C.jsx("path", { strokeWidth: t, d: `M${e[0] / 2} 0 V${e[1]} M0 ${e[1] / 2} H${e[0]}`, className: zr(["react-flow__background-pattern", n, r]) });
}
function j0e({ radius: e, className: t }) {
  return C.jsx("circle", { cx: e, cy: e, r: e, className: zr(["react-flow__background-pattern", "dots", t]) });
}
var _a;
(function(e) {
  e.Lines = "lines", e.Dots = "dots", e.Cross = "cross";
})(_a || (_a = {}));
const P0e = {
  [_a.Dots]: 1,
  [_a.Lines]: 1,
  [_a.Cross]: 6
}, D0e = (e) => ({ transform: e.transform, patternId: `pattern-${e.rfId}` });
function Oq({
  id: e,
  variant: t = _a.Dots,
  // only used for dots and cross
  gap: n = 20,
  // only used for lines and cross
  size: r,
  lineWidth: a = 1,
  offset: s = 0,
  color: l,
  bgColor: c,
  style: d,
  className: f,
  patternClassName: m
}) {
  const h = M.useRef(null), { transform: v, patternId: g } = pn(D0e, mr), b = r || P0e[t], x = t === _a.Dots, w = t === _a.Cross, k = Array.isArray(n) ? n : [n, n], E = [k[0] * v[2] || 1, k[1] * v[2] || 1], _ = b * v[2], O = Array.isArray(s) ? s : [s, s], N = w ? [_, _] : E, A = [
    O[0] * v[2] || 1 + N[0] / 2,
    O[1] * v[2] || 1 + N[1] / 2
  ], R = `${g}${e || ""}`;
  return C.jsxs("svg", { className: zr(["react-flow__background", f]), style: {
    ...d,
    ...cC,
    "--xy-background-color-props": c,
    "--xy-background-pattern-color-props": l
  }, ref: h, "data-testid": "rf__background", children: [C.jsx("pattern", { id: R, x: v[0] % E[0], y: v[1] % E[1], width: E[0], height: E[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${A[0]},-${A[1]})`, children: x ? C.jsx(j0e, { radius: _ / 2, className: m }) : C.jsx(R0e, { dimensions: N, lineWidth: a, variant: t, className: m }) }), C.jsx("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${R})` })] });
}
Oq.displayName = "Background";
const I0e = M.memo(Oq);
function $0e() {
  return C.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: C.jsx("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" }) });
}
function z0e() {
  return C.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5", children: C.jsx("path", { d: "M0 0h32v4.2H0z" }) });
}
function T0e() {
  return C.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30", children: C.jsx("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" }) });
}
function L0e() {
  return C.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: C.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" }) });
}
function F0e() {
  return C.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: C.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" }) });
}
function g0({ children: e, className: t, ...n }) {
  return C.jsx("button", { type: "button", className: zr(["react-flow__controls-button", t]), ...n, children: e });
}
const B0e = (e) => ({
  isInteractive: e.nodesDraggable || e.nodesConnectable || e.elementsSelectable,
  minZoomReached: e.transform[2] <= e.minZoom,
  maxZoomReached: e.transform[2] >= e.maxZoom,
  ariaLabelConfig: e.ariaLabelConfig
});
function Mq({ style: e, showZoom: t = !0, showFitView: n = !0, showInteractive: r = !0, fitViewOptions: a, onZoomIn: s, onZoomOut: l, onFitView: c, onInteractiveChange: d, className: f, children: m, position: h = "bottom-left", orientation: v = "vertical", "aria-label": g }) {
  const b = gr(), { isInteractive: x, minZoomReached: w, maxZoomReached: k, ariaLabelConfig: E } = pn(B0e, mr), { zoomIn: _, zoomOut: O, fitView: N } = Jm(), A = () => {
    _(), s?.();
  }, R = () => {
    O(), l?.();
  }, D = () => {
    N(a), c?.();
  }, I = () => {
    b.setState({
      nodesDraggable: !x,
      nodesConnectable: !x,
      elementsSelectable: !x
    }), d?.(!x);
  }, z = v === "horizontal" ? "horizontal" : "vertical";
  return C.jsxs(uC, { className: zr(["react-flow__controls", z, f]), position: h, style: e, "data-testid": "rf__controls", "aria-label": g ?? E["controls.ariaLabel"], children: [t && C.jsxs(C.Fragment, { children: [C.jsx(g0, { onClick: A, className: "react-flow__controls-zoomin", title: E["controls.zoomIn.ariaLabel"], "aria-label": E["controls.zoomIn.ariaLabel"], disabled: k, children: C.jsx($0e, {}) }), C.jsx(g0, { onClick: R, className: "react-flow__controls-zoomout", title: E["controls.zoomOut.ariaLabel"], "aria-label": E["controls.zoomOut.ariaLabel"], disabled: w, children: C.jsx(z0e, {}) })] }), n && C.jsx(g0, { className: "react-flow__controls-fitview", onClick: D, title: E["controls.fitView.ariaLabel"], "aria-label": E["controls.fitView.ariaLabel"], children: C.jsx(T0e, {}) }), r && C.jsx(g0, { className: "react-flow__controls-interactive", onClick: I, title: E["controls.interactive.ariaLabel"], "aria-label": E["controls.interactive.ariaLabel"], children: x ? C.jsx(F0e, {}) : C.jsx(L0e, {}) }), m] });
}
Mq.displayName = "Controls";
M.memo(Mq);
function U0e({ id: e, x: t, y: n, width: r, height: a, style: s, color: l, strokeColor: c, strokeWidth: d, className: f, borderRadius: m, shapeRendering: h, selected: v, onClick: g }) {
  const { background: b, backgroundColor: x } = s || {}, w = l || b || x;
  return C.jsx("rect", { className: zr(["react-flow__minimap-node", { selected: v }, f]), x: t, y: n, rx: m, ry: m, width: r, height: a, style: {
    fill: w,
    stroke: c,
    strokeWidth: d
  }, shapeRendering: h, onClick: g ? (k) => g(k, e) : void 0 });
}
const V0e = M.memo(U0e), H0e = (e) => e.nodes.map((t) => t.id), d5 = (e) => e instanceof Function ? e : () => e;
function W0e({
  nodeStrokeColor: e,
  nodeColor: t,
  nodeClassName: n = "",
  nodeBorderRadius: r = 5,
  nodeStrokeWidth: a,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: s = V0e,
  onClick: l
}) {
  const c = pn(H0e, mr), d = d5(t), f = d5(e), m = d5(n), h = typeof window > "u" || window.chrome ? "crispEdges" : "geometricPrecision";
  return C.jsx(C.Fragment, { children: c.map((v) => (
    /*
     * The split of responsibilities between MiniMapNodes and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For more details, see a similar commit in `NodeRenderer/index.tsx`.
     */
    C.jsx(G0e, { id: v, nodeColorFunc: d, nodeStrokeColorFunc: f, nodeClassNameFunc: m, nodeBorderRadius: r, nodeStrokeWidth: a, NodeComponent: s, onClick: l, shapeRendering: h }, v)
  )) });
}
function q0e({ id: e, nodeColorFunc: t, nodeStrokeColorFunc: n, nodeClassNameFunc: r, nodeBorderRadius: a, nodeStrokeWidth: s, shapeRendering: l, NodeComponent: c, onClick: d }) {
  const { node: f, x: m, y: h, width: v, height: g } = pn((b) => {
    const { internals: x } = b.nodeLookup.get(e), w = x.userNode, { x: k, y: E } = x.positionAbsolute, { width: _, height: O } = Jc(w);
    return {
      node: w,
      x: k,
      y: E,
      width: _,
      height: O
    };
  }, mr);
  return !f || f.hidden || !RW(f) ? null : C.jsx(c, { x: m, y: h, width: v, height: g, style: f.style, selected: !!f.selected, className: r(f), color: t(f), borderRadius: a, strokeColor: n(f), strokeWidth: s, shapeRendering: l, onClick: d, id: f.id });
}
const G0e = M.memo(q0e);
var K0e = M.memo(W0e);
const Y0e = 200, X0e = 150, J0e = (e) => !e.hidden, Q0e = (e) => {
  const t = {
    x: -e.transform[0] / e.transform[2],
    y: -e.transform[1] / e.transform[2],
    width: e.width / e.transform[2],
    height: e.height / e.transform[2]
  };
  return {
    viewBB: t,
    boundingRect: e.nodeLookup.size > 0 ? AW(pk(e.nodeLookup, { filter: J0e }), t) : t,
    rfId: e.rfId,
    panZoom: e.panZoom,
    translateExtent: e.translateExtent,
    flowWidth: e.width,
    flowHeight: e.height,
    ariaLabelConfig: e.ariaLabelConfig
  };
}, Z0e = "react-flow__minimap-desc";
function Nq({
  style: e,
  className: t,
  nodeStrokeColor: n,
  nodeColor: r,
  nodeClassName: a = "",
  nodeBorderRadius: s = 5,
  nodeStrokeWidth: l,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: c,
  bgColor: d,
  maskColor: f,
  maskStrokeColor: m,
  maskStrokeWidth: h,
  position: v = "bottom-right",
  onClick: g,
  onNodeClick: b,
  pannable: x = !1,
  zoomable: w = !1,
  ariaLabel: k,
  inversePan: E,
  zoomStep: _ = 1,
  offsetScale: O = 5
}) {
  const N = gr(), A = M.useRef(null), { boundingRect: R, viewBB: D, rfId: I, panZoom: z, translateExtent: B, flowWidth: P, flowHeight: H, ariaLabelConfig: L } = pn(Q0e, mr), G = e?.width ?? Y0e, $ = e?.height ?? X0e, K = R.width / G, q = R.height / $, Z = Math.max(K, q), V = Z * G, F = Z * $, Y = O * Z, U = R.x - (V - R.width) / 2 - Y, W = R.y - (F - R.height) / 2 - Y, J = V + Y * 2, oe = F + Y * 2, fe = `${Z0e}-${I}`, ie = M.useRef(0), ce = M.useRef();
  ie.current = Z, M.useEffect(() => {
    if (A.current && z)
      return ce.current = ESe({
        domNode: A.current,
        panZoom: z,
        getTransform: () => N.getState().transform,
        getViewScale: () => ie.current
      }), () => {
        ce.current?.destroy();
      };
  }, [z]), M.useEffect(() => {
    ce.current?.update({
      translateExtent: B,
      width: P,
      height: H,
      inversePan: E,
      pannable: x,
      zoomStep: _,
      zoomable: w
    });
  }, [x, w, E, _, B, P, H]);
  const ge = g ? (me) => {
    const [ve, xe] = ce.current?.pointer(me) || [0, 0];
    g(me, { x: ve, y: xe });
  } : void 0, re = b ? M.useCallback((me, ve) => {
    const xe = N.getState().nodeLookup.get(ve).internals.userNode;
    b(me, xe);
  }, []) : void 0, le = k ?? L["minimap.ariaLabel"];
  return C.jsx(uC, { position: v, style: {
    ...e,
    "--xy-minimap-background-color-props": typeof d == "string" ? d : void 0,
    "--xy-minimap-mask-background-color-props": typeof f == "string" ? f : void 0,
    "--xy-minimap-mask-stroke-color-props": typeof m == "string" ? m : void 0,
    "--xy-minimap-mask-stroke-width-props": typeof h == "number" ? h * Z : void 0,
    "--xy-minimap-node-background-color-props": typeof r == "string" ? r : void 0,
    "--xy-minimap-node-stroke-color-props": typeof n == "string" ? n : void 0,
    "--xy-minimap-node-stroke-width-props": typeof l == "number" ? l : void 0
  }, className: zr(["react-flow__minimap", t]), "data-testid": "rf__minimap", children: C.jsxs("svg", { width: G, height: $, viewBox: `${U} ${W} ${J} ${oe}`, className: "react-flow__minimap-svg", role: "img", "aria-labelledby": fe, ref: A, onClick: ge, children: [le && C.jsx("title", { id: fe, children: le }), C.jsx(K0e, { onClick: re, nodeColor: r, nodeStrokeColor: n, nodeBorderRadius: s, nodeClassName: a, nodeStrokeWidth: l, nodeComponent: c }), C.jsx("path", { className: "react-flow__minimap-mask", d: `M${U - Y},${W - Y}h${J + Y * 2}v${oe + Y * 2}h${-J - Y * 2}z
        M${D.x},${D.y}h${D.width}v${D.height}h${-D.width}z`, fillRule: "evenodd", pointerEvents: "none" })] }) });
}
Nq.displayName = "MiniMap";
const e_e = M.memo(Nq), t_e = (e) => (t) => e ? `${Math.max(1 / t.transform[2], 1)}` : void 0, n_e = {
  [Eg.Line]: "right",
  [Eg.Handle]: "bottom-right"
};
function r_e({ nodeId: e, position: t, variant: n = Eg.Handle, className: r, style: a = void 0, children: s, color: l, minWidth: c = 10, minHeight: d = 10, maxWidth: f = Number.MAX_VALUE, maxHeight: m = Number.MAX_VALUE, keepAspectRatio: h = !1, resizeDirection: v, autoScale: g = !0, shouldResize: b, onResizeStart: x, onResize: w, onResizeEnd: k }) {
  const E = sq(), _ = typeof e == "string" ? e : E, O = gr(), N = M.useRef(null), A = n === Eg.Handle, R = pn(M.useCallback(t_e(A && g), [A, g]), mr), D = M.useRef(null), I = t ?? n_e[n];
  M.useEffect(() => {
    if (!(!N.current || !_))
      return D.current || (D.current = LSe({
        domNode: N.current,
        nodeId: _,
        getStoreItems: () => {
          const { nodeLookup: B, transform: P, snapGrid: H, snapToGrid: L, nodeOrigin: G, domNode: $ } = O.getState();
          return {
            nodeLookup: B,
            transform: P,
            snapGrid: H,
            snapToGrid: L,
            nodeOrigin: G,
            paneDomNode: $
          };
        },
        onChange: (B, P) => {
          const { triggerNodeChanges: H, nodeLookup: L, parentLookup: G, nodeOrigin: $ } = O.getState(), K = [], q = { x: B.x, y: B.y }, Z = L.get(_);
          if (Z && Z.expandParent && Z.parentId) {
            const V = Z.origin ?? $, F = B.width ?? Z.measured.width ?? 0, Y = B.height ?? Z.measured.height ?? 0, U = {
              id: Z.id,
              parentId: Z.parentId,
              rect: {
                width: F,
                height: Y,
                ...jW({
                  x: B.x ?? Z.position.x,
                  y: B.y ?? Z.position.y
                }, { width: F, height: Y }, Z.parentId, L, V)
              }
            }, W = bj([U], L, G, $);
            K.push(...W), q.x = B.x ? Math.max(V[0] * F, B.x) : void 0, q.y = B.y ? Math.max(V[1] * Y, B.y) : void 0;
          }
          if (q.x !== void 0 && q.y !== void 0) {
            const V = {
              id: _,
              type: "position",
              position: { ...q }
            };
            K.push(V);
          }
          if (B.width !== void 0 && B.height !== void 0) {
            const V = {
              id: _,
              type: "dimensions",
              resizing: !0,
              setAttributes: v ? v === "horizontal" ? "width" : "height" : !0,
              dimensions: {
                width: B.width,
                height: B.height
              }
            };
            K.push(V);
          }
          for (const V of P) {
            const F = {
              ...V,
              type: "position"
            };
            K.push(F);
          }
          H(K);
        },
        onEnd: ({ width: B, height: P }) => {
          const H = {
            id: _,
            type: "dimensions",
            resizing: !1,
            dimensions: {
              width: B,
              height: P
            }
          };
          O.getState().triggerNodeChanges([H]);
        }
      })), D.current.update({
        controlPosition: I,
        boundaries: {
          minWidth: c,
          minHeight: d,
          maxWidth: f,
          maxHeight: m
        },
        keepAspectRatio: h,
        resizeDirection: v,
        onResizeStart: x,
        onResize: w,
        onResizeEnd: k,
        shouldResize: b
      }), () => {
        D.current?.destroy();
      };
  }, [
    I,
    c,
    d,
    f,
    m,
    h,
    x,
    w,
    k,
    b
  ]);
  const z = I.split("-");
  return C.jsx("div", { className: zr(["react-flow__resize-control", "nodrag", ...z, n, r]), ref: N, style: {
    ...a,
    scale: R,
    ...l && { [A ? "backgroundColor" : "borderColor"]: l }
  }, children: s });
}
M.memo(r_e);
function o_e(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1;
    for (const [r, a] of e)
      if (!Object.is(a, t.get(r)))
        return !1;
    return !0;
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1;
    for (const r of e)
      if (!t.has(r))
        return !1;
    return !0;
  }
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !1;
  for (const r of n)
    if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
      return !1;
  return !0;
}
const { useRef: a_e } = jt;
function Sj(e) {
  const t = a_e();
  return (n) => {
    const r = e(n);
    return o_e(t.current, r) ? t.current : t.current = r;
  };
}
const i_e = () => {
  const { group: e } = Oa();
  return async (t, n) => {
    if (e)
      return await e.group_nodes(t, n);
  };
}, s_e = () => {
  const { group: e } = Oa();
  return async (t) => {
    if (e)
      for (const n of t)
        await e.remove_group(n);
  };
}, l_e = ({ data: e }) => {
  const t = e?.group?.id || e?.id, n = s_e(), r = M.useCallback(
    (a) => {
      a.stopPropagation(), t && n([t]);
    },
    [t, n]
  );
  return /* @__PURE__ */ C.jsxs("div", { className: "fn-group", children: [
    /* @__PURE__ */ C.jsx(
      "button",
      {
        className: "fn-group-remove",
        title: "Remove group",
        onClick: r,
        children: /* @__PURE__ */ C.jsx(LE, {})
      }
    ),
    "Group"
  ] });
}, Aq = (e, t) => {
  if (typeof e == "string")
    return e in t ? [t[e], e] : [e, e];
  if ("allOf" in e && e.allOf !== void 0)
    return [void 0, void 0];
  if ("anyOf" in e && e.anyOf !== void 0) {
    const n = e.anyOf.map(
      (r) => Aq(r || "any", t)
    );
    for (const r of n)
      switch (r[0]) {
        case "bool":
          return ["bool", r[1]];
        case "enum":
          return ["enum", r[1]];
        case "float":
          return ["float", r[1]];
        case "int":
          return ["int", r[1]];
        case "string":
          return ["string", r[1]];
        case "str":
          return ["string", r[1]];
      }
    return [void 0, void 0];
  }
  return !("type" in e) || e.type === void 0 ? [void 0, void 0] : e.type === "enum" ? ["enum", "enum"] : [void 0, void 0];
}, Qm = (e, t) => Aq(e.render_options?.type ?? "any", t), kj = M.memo(
  ({ value: e }) => {
    const t = e?.toString() ?? "", n = Math.round(3 * t.length / 4);
    return /* @__PURE__ */ C.jsx("div", { children: /* @__PURE__ */ C.jsxs("pre", { children: [
      "Bytes(",
      n,
      ")"
    ] }) });
  }
), Rq = M.memo(
  ({ value: e }) => typeof e != "string" ? /* @__PURE__ */ C.jsx("div", { children: "Invalid SVG" }) : /* @__PURE__ */ C.jsx(khe, { value: e })
), jq = ({
  value: e,
  preValue: t,
  onLoaded: n
}) => {
  const [r, a] = M.useState(
    t?.toString() || e?.toString()
  );
  return M.useEffect(() => {
    if (e === t || e == null) return;
    const s = new Image(), l = e.toString();
    return s.onload = () => {
      n?.(), a(l);
    }, s.src = l, () => {
      s.onload = null;
    };
  }, [e, t, n]), r === void 0 ? /* @__PURE__ */ C.jsx(C.Fragment, {}) : typeof r != "string" ? (console.error("ImageRenderer: value is not a string", r), /* @__PURE__ */ C.jsx(C.Fragment, {})) : r.startsWith("data:") || r.startsWith("blob:") ? /* @__PURE__ */ C.jsx(_he, { src: r }) : /* @__PURE__ */ C.jsx(She, { value: r, format: "jpeg" });
}, u_e = M.memo(
  ({ value: e }) => {
    let t = "";
    try {
      t = JSON.stringify(e);
    } catch {
    }
    return /* @__PURE__ */ C.jsx("div", { children: /* @__PURE__ */ C.jsx("pre", { children: t }) });
  }
), dC = ({
  value: e
}) => /* @__PURE__ */ C.jsx(ihe, { data: e }), Pq = M.memo(
  ({ value: e }) => {
    if (typeof e != "object" || e == null)
      return /* @__PURE__ */ C.jsx("div", { children: "Invalid Table" });
    if (!("columns" in e && "index" in e && "data" in e))
      return /* @__PURE__ */ C.jsx("div", { children: "Invalid Table" });
    if (!Array.isArray(e.columns) || !Array.isArray(e.index) || !Array.isArray(e.data) || !e.data.every((n) => Array.isArray(n)))
      return /* @__PURE__ */ C.jsx("div", { children: "Invalid Table" });
    const t = {
      columns: e.columns || [],
      index: e.index || [],
      data: e.data || []
    };
    return /* @__PURE__ */ C.jsx(H7, { tabledata: t });
  }
), $2 = (e) => /* @__PURE__ */ C.jsx(u_e, { ...e }), z2 = dC, _j = {
  string: $2,
  str: $2,
  table: Pq,
  image: jq,
  svg: Rq,
  dict: dC,
  bytes: kj
}, fC = M.createContext({}), Ri = () => M.useContext(fC), Pd = M.createContext(void 0);
function hr(e) {
  if (e)
    return Ri().io_stores.get(e);
  {
    const t = M.useContext(Pd);
    if (!t)
      throw new Error("IOContext not set");
    return t;
  }
}
const c_e = () => {
  const e = hr(), { full: t, preview: n } = e.valuestore(), r = JSON.stringify(t?.value || n?.value) || "";
  return `Bytes(${Math.round(3 * r.length / 4)})`;
}, d_e = {
  bytes: c_e
}, pC = (e) => ({ value: t, preValue: n, onLoaded: r }) => /* @__PURE__ */ C.jsx(e, { value: t, preValue: n, onLoaded: r }), Ra = (e, t = void 0, n = {}) => ({}) => {
  const r = hr(), { full: a, preview: s } = r.valuestore(), l = (a === void 0 ? s : a)?.value || t;
  return /* @__PURE__ */ C.jsx(e, { value: l, ...n });
}, Dq = (e) => ({}) => /* @__PURE__ */ C.jsx(e, {}), Iq = (e, t = void 0) => ({}) => {
  const n = hr(), { full: r, preview: a } = n.valuestore(), s = (r === void 0 ? a : r)?.value || t;
  return /* @__PURE__ */ C.jsx(e, { value: s });
}, f_e = {
  ...Object.fromEntries(
    Object.entries(_j).map(([e, t]) => [
      e,
      t ? pC(t) : void 0
    ])
  )
}, Q6 = pC(dC), $q = {
  ...Object.fromEntries(
    Object.entries(_j).map(([e, t]) => [
      e,
      t ? Ra(t) : void 0
    ])
  ),
  string: Ra($2),
  str: Ra($2),
  table: Ra(Pq, void 0, {
    pageSize: 10
  }),
  image: Ra(jq),
  svg: Ra(Rq, ""),
  dict: Ra(dC, "{}"),
  bytes: Ra(kj, "")
}, p_e = {
  ...Object.fromEntries(
    Object.entries($q).map(([e, t]) => [
      e,
      t ? Dq(t) : void 0
    ])
  )
}, m_e = () => {
  const e = hr(), { preview: t, full: n } = e.valuestore();
  let r = (JSON.stringify(n || t) || "").replace(/\\n/g, `
`);
  return r.length > 63 && (r = r.slice(0, 60) + "..."), /* @__PURE__ */ C.jsx("div", { children: r });
}, h_e = {};
function Zm(e) {
  const { node: t } = Oa();
  if (e || (e = hr().use()), typeof e == "string" && (e = hr(e)?.use(), !e))
    throw new Error(`No IO found for ${e}`);
  if (!e)
    throw new Error("No IO found");
  return M.useCallback(
    (n, r) => {
      t?.set_io_value({
        nid: e.node,
        ioid: e.id,
        value: n,
        set_default: r ?? e.render_options.set_default
      });
    },
    [e, t]
  );
}
function g_e(e) {
  const { node: t } = Oa();
  let n, r;
  if (!e) {
    const a = hr().useShallow((s) => ({
      io_id: s.id,
      node_id: s.node
    }));
    n = a.io_id, r = a.node_id;
  }
  if (typeof e == "string") {
    const a = hr(e);
    if (!a)
      throw new Error(`No IO found for ${e}`);
    const s = a.useShallow((l) => ({
      io_id: l.id,
      node_id: l.node
    }));
    n = s.io_id, r = s.node_id;
  } else {
    if (!e)
      throw new Error("No IO found");
    n = e.id, r = e.node;
  }
  return M.useCallback(
    (a) => {
      t?.set_io_value_options({
        nid: r,
        ioid: n,
        values: a.values ?? a.keys,
        keys: a.keys,
        nullable: a.nullable ?? !1
      });
    },
    [t, n, r]
  );
}
function v_e(e) {
  return hr(e)?.valuestore();
}
function vk(e) {
  const t = hr(e);
  if (!t) return;
  const { node: n, id: r } = t.useShallow((s) => ({
    node: s.node,
    id: s.id
  })), { node: a } = Oa();
  return M.useCallback(async () => {
    const s = await a?.get_io_full_value({ nid: n, ioid: r });
    return t.updateValueStore({ full: s }), s;
  }, [a, n, r]);
}
function Ej(e) {
  const t = hr(e);
  if (!t) return;
  const { node: n, id: r } = t.useShallow((s) => ({
    node: s.node,
    id: s.id
  })), { node: a } = Oa();
  return M.useCallback(
    (s) => {
      a?.update_io_options({
        nid: n,
        ioid: r,
        options: { hidden: s }
      });
    },
    [a, n, r]
  );
}
const y_e = ({ inputconverter: e }) => {
  const t = hr(), { preview: n } = t.valuestore(), r = t.use(), a = n?.value === void 0, s = M.useRef(null), l = Zm(r);
  M.useEffect(() => {
    s.current && (s.current.indeterminate = a);
  }, [s, a]);
  const c = M.useCallback(
    (d) => {
      let f = d.target.checked;
      try {
        f = e[0](d.target.checked);
      } catch {
      }
      l(f);
    },
    [l, e]
  );
  return /* @__PURE__ */ C.jsx(
    "input",
    {
      ref: s,
      type: "checkbox",
      className: "styledcheckbox booleaninput",
      checked: !!e[1](n?.value),
      onChange: c,
      disabled: r.connected
    }
  );
}, b_e = ({}) => {
  const e = hr(), t = Sn(), n = e.use(), { preview: r, full: a } = e.valuestore(), s = a === void 0 ? r?.value : a.value, l = Zm(n), c = typeof s == "string" || Array.isArray(s) && s.every((v) => typeof v == "number") ? s : void 0, d = n.value_options?.colorspace || "hex", f = M.useCallback(
    (v) => {
      let g = "<NoValue>";
      v && (v[d] ? g = v[d]() : g = v.hex()), v === null && (g = null);
      try {
        g = g;
      } catch {
      }
      l(g);
    },
    [l, d]
  );
  let m = !1;
  typeof n.type != "string" && "anyOf" in n.type && n.type.anyOf !== void 0 && (m = n.type.anyOf.some((v) => v === "None"));
  const h = t.local_state(() => t.reactflowRef);
  return /* @__PURE__ */ C.jsx(
    cfe,
    {
      onChange: f,
      inicolordata: c,
      allow_null: m,
      inicolorspace: d,
      portalContainer: h
    }
  );
};
function zq(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
var w_e = M.createContext(void 0);
function mC(e) {
  const t = M.useContext(w_e);
  return e || t || "ltr";
}
function x_e(e) {
  const t = M.useRef({ value: e, previous: e });
  return M.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
}
var Tq = ["PageUp", "PageDown"], Lq = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], Fq = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, Hg = "Slider", [j3, S_e, k_e] = qE(Hg), [Bq] = Kl(Hg, [
  k_e
]), [__e, hC] = Bq(Hg), Uq = M.forwardRef(
  (e, t) => {
    const {
      name: n,
      min: r = 0,
      max: a = 100,
      step: s = 1,
      orientation: l = "horizontal",
      disabled: c = !1,
      minStepsBetweenThumbs: d = 0,
      defaultValue: f = [r],
      value: m,
      onValueChange: h = () => {
      },
      onValueCommit: v = () => {
      },
      inverted: g = !1,
      form: b,
      ...x
    } = e, w = M.useRef(/* @__PURE__ */ new Set()), k = M.useRef(0), E = l === "horizontal" ? E_e : C_e, [_ = [], O] = Bd({
      prop: m,
      defaultProp: f,
      onChange: (z) => {
        [...w.current][k.current]?.focus(), h(z);
      }
    }), N = M.useRef(_);
    function A(z) {
      const B = R_e(_, z);
      I(z, B);
    }
    function R(z) {
      I(z, k.current);
    }
    function D() {
      const z = N.current[k.current];
      _[k.current] !== z && v(_);
    }
    function I(z, B, { commit: P } = { commit: !1 }) {
      const H = I_e(s), L = $_e(Math.round((z - r) / s) * s + r, H), G = zq(L, [r, a]);
      O(($ = []) => {
        const K = N_e($, G, B);
        if (D_e(K, d * s)) {
          k.current = K.indexOf(G);
          const q = String(K) !== String($);
          return q && P && v(K), q ? K : $;
        } else
          return $;
      });
    }
    return /* @__PURE__ */ C.jsx(
      __e,
      {
        scope: e.__scopeSlider,
        name: n,
        disabled: c,
        min: r,
        max: a,
        valueIndexToChangeRef: k,
        thumbs: w.current,
        values: _,
        orientation: l,
        form: b,
        children: /* @__PURE__ */ C.jsx(j3.Provider, { scope: e.__scopeSlider, children: /* @__PURE__ */ C.jsx(j3.Slot, { scope: e.__scopeSlider, children: /* @__PURE__ */ C.jsx(
          E,
          {
            "aria-disabled": c,
            "data-disabled": c ? "" : void 0,
            ...x,
            ref: t,
            onPointerDown: et(x.onPointerDown, () => {
              c || (N.current = _);
            }),
            min: r,
            max: a,
            inverted: g,
            onSlideStart: c ? void 0 : A,
            onSlideMove: c ? void 0 : R,
            onSlideEnd: c ? void 0 : D,
            onHomeKeyDown: () => !c && I(r, 0, { commit: !0 }),
            onEndKeyDown: () => !c && I(a, _.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: z, direction: B }) => {
              if (!c) {
                const P = Tq.includes(z.key) || z.shiftKey && Lq.includes(z.key) ? 10 : 1, H = k.current, L = _[H], G = s * P * B;
                I(L + G, H, { commit: !0 });
              }
            }
          }
        ) }) })
      }
    );
  }
);
Uq.displayName = Hg;
var [Vq, Hq] = Bq(Hg, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), E_e = M.forwardRef(
  (e, t) => {
    const {
      min: n,
      max: r,
      dir: a,
      inverted: s,
      onSlideStart: l,
      onSlideMove: c,
      onSlideEnd: d,
      onStepKeyDown: f,
      ...m
    } = e, [h, v] = M.useState(null), g = Xn(t, (_) => v(_)), b = M.useRef(void 0), x = mC(a), w = x === "ltr", k = w && !s || !w && s;
    function E(_) {
      const O = b.current || h.getBoundingClientRect(), N = [0, O.width], A = Cj(N, k ? [n, r] : [r, n]);
      return b.current = O, A(_ - O.left);
    }
    return /* @__PURE__ */ C.jsx(
      Vq,
      {
        scope: e.__scopeSlider,
        startEdge: k ? "left" : "right",
        endEdge: k ? "right" : "left",
        direction: k ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ C.jsx(
          Wq,
          {
            dir: x,
            "data-orientation": "horizontal",
            ...m,
            ref: g,
            style: {
              ...m.style,
              "--radix-slider-thumb-transform": "translateX(-50%)"
            },
            onSlideStart: (_) => {
              const O = E(_.clientX);
              l?.(O);
            },
            onSlideMove: (_) => {
              const O = E(_.clientX);
              c?.(O);
            },
            onSlideEnd: () => {
              b.current = void 0, d?.();
            },
            onStepKeyDown: (_) => {
              const O = Fq[k ? "from-left" : "from-right"].includes(_.key);
              f?.({ event: _, direction: O ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), C_e = M.forwardRef(
  (e, t) => {
    const {
      min: n,
      max: r,
      inverted: a,
      onSlideStart: s,
      onSlideMove: l,
      onSlideEnd: c,
      onStepKeyDown: d,
      ...f
    } = e, m = M.useRef(null), h = Xn(t, m), v = M.useRef(void 0), g = !a;
    function b(x) {
      const w = v.current || m.current.getBoundingClientRect(), k = [0, w.height], E = Cj(k, g ? [r, n] : [n, r]);
      return v.current = w, E(x - w.top);
    }
    return /* @__PURE__ */ C.jsx(
      Vq,
      {
        scope: e.__scopeSlider,
        startEdge: g ? "bottom" : "top",
        endEdge: g ? "top" : "bottom",
        size: "height",
        direction: g ? 1 : -1,
        children: /* @__PURE__ */ C.jsx(
          Wq,
          {
            "data-orientation": "vertical",
            ...f,
            ref: h,
            style: {
              ...f.style,
              "--radix-slider-thumb-transform": "translateY(50%)"
            },
            onSlideStart: (x) => {
              const w = b(x.clientY);
              s?.(w);
            },
            onSlideMove: (x) => {
              const w = b(x.clientY);
              l?.(w);
            },
            onSlideEnd: () => {
              v.current = void 0, c?.();
            },
            onStepKeyDown: (x) => {
              const w = Fq[g ? "from-bottom" : "from-top"].includes(x.key);
              d?.({ event: x, direction: w ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), Wq = M.forwardRef(
  (e, t) => {
    const {
      __scopeSlider: n,
      onSlideStart: r,
      onSlideMove: a,
      onSlideEnd: s,
      onHomeKeyDown: l,
      onEndKeyDown: c,
      onStepKeyDown: d,
      ...f
    } = e, m = hC(Hg, n);
    return /* @__PURE__ */ C.jsx(
      Qt.span,
      {
        ...f,
        ref: t,
        onKeyDown: et(e.onKeyDown, (h) => {
          h.key === "Home" ? (l(h), h.preventDefault()) : h.key === "End" ? (c(h), h.preventDefault()) : Tq.concat(Lq).includes(h.key) && (d(h), h.preventDefault());
        }),
        onPointerDown: et(e.onPointerDown, (h) => {
          const v = h.target;
          v.setPointerCapture(h.pointerId), h.preventDefault(), m.thumbs.has(v) ? v.focus() : r(h);
        }),
        onPointerMove: et(e.onPointerMove, (h) => {
          h.target.hasPointerCapture(h.pointerId) && a(h);
        }),
        onPointerUp: et(e.onPointerUp, (h) => {
          const v = h.target;
          v.hasPointerCapture(h.pointerId) && (v.releasePointerCapture(h.pointerId), s(h));
        })
      }
    );
  }
), qq = "SliderTrack", Gq = M.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, ...r } = e, a = hC(qq, n);
    return /* @__PURE__ */ C.jsx(
      Qt.span,
      {
        "data-disabled": a.disabled ? "" : void 0,
        "data-orientation": a.orientation,
        ...r,
        ref: t
      }
    );
  }
);
Gq.displayName = qq;
var P3 = "SliderRange", Kq = M.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, ...r } = e, a = hC(P3, n), s = Hq(P3, n), l = M.useRef(null), c = Xn(t, l), d = a.values.length, f = a.values.map(
      (v) => Jq(v, a.min, a.max)
    ), m = d > 1 ? Math.min(...f) : 0, h = 100 - Math.max(...f);
    return /* @__PURE__ */ C.jsx(
      Qt.span,
      {
        "data-orientation": a.orientation,
        "data-disabled": a.disabled ? "" : void 0,
        ...r,
        ref: c,
        style: {
          ...e.style,
          [s.startEdge]: m + "%",
          [s.endEdge]: h + "%"
        }
      }
    );
  }
);
Kq.displayName = P3;
var D3 = "SliderThumb", Yq = M.forwardRef(
  (e, t) => {
    const n = S_e(e.__scopeSlider), [r, a] = M.useState(null), s = Xn(t, (c) => a(c)), l = M.useMemo(
      () => r ? n().findIndex((c) => c.ref.current === r) : -1,
      [n, r]
    );
    return /* @__PURE__ */ C.jsx(O_e, { ...e, ref: s, index: l });
  }
), O_e = M.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, index: r, name: a, ...s } = e, l = hC(D3, n), c = Hq(D3, n), [d, f] = M.useState(null), m = Xn(t, (E) => f(E)), h = d ? l.form || !!d.closest("form") : !0, v = WU(d), g = l.values[r], b = g === void 0 ? 0 : Jq(g, l.min, l.max), x = A_e(r, l.values.length), w = v?.[c.size], k = w ? j_e(w, b, c.direction) : 0;
    return M.useEffect(() => {
      if (d)
        return l.thumbs.add(d), () => {
          l.thumbs.delete(d);
        };
    }, [d, l.thumbs]), /* @__PURE__ */ C.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [c.startEdge]: `calc(${b}% + ${k}px)`
        },
        children: [
          /* @__PURE__ */ C.jsx(j3.ItemSlot, { scope: e.__scopeSlider, children: /* @__PURE__ */ C.jsx(
            Qt.span,
            {
              role: "slider",
              "aria-label": e["aria-label"] || x,
              "aria-valuemin": l.min,
              "aria-valuenow": g,
              "aria-valuemax": l.max,
              "aria-orientation": l.orientation,
              "data-orientation": l.orientation,
              "data-disabled": l.disabled ? "" : void 0,
              tabIndex: l.disabled ? void 0 : 0,
              ...s,
              ref: m,
              style: g === void 0 ? { display: "none" } : e.style,
              onFocus: et(e.onFocus, () => {
                l.valueIndexToChangeRef.current = r;
              })
            }
          ) }),
          h && /* @__PURE__ */ C.jsx(
            Xq,
            {
              name: a ?? (l.name ? l.name + (l.values.length > 1 ? "[]" : "") : void 0),
              form: l.form,
              value: g
            },
            r
          )
        ]
      }
    );
  }
);
Yq.displayName = D3;
var M_e = "RadioBubbleInput", Xq = M.forwardRef(
  ({ __scopeSlider: e, value: t, ...n }, r) => {
    const a = M.useRef(null), s = Xn(a, r), l = x_e(t);
    return M.useEffect(() => {
      const c = a.current;
      if (!c) return;
      const d = window.HTMLInputElement.prototype, f = Object.getOwnPropertyDescriptor(d, "value").set;
      if (l !== t && f) {
        const m = new Event("input", { bubbles: !0 });
        f.call(c, t), c.dispatchEvent(m);
      }
    }, [l, t]), /* @__PURE__ */ C.jsx(
      Qt.input,
      {
        style: { display: "none" },
        ...n,
        ref: s,
        defaultValue: t
      }
    );
  }
);
Xq.displayName = M_e;
function N_e(e = [], t, n) {
  const r = [...e];
  return r[n] = t, r.sort((a, s) => a - s);
}
function Jq(e, t, n) {
  const r = 100 / (n - t) * (e - t);
  return zq(r, [0, 100]);
}
function A_e(e, t) {
  return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][e] : void 0;
}
function R_e(e, t) {
  if (e.length === 1) return 0;
  const n = e.map((a) => Math.abs(a - t)), r = Math.min(...n);
  return n.indexOf(r);
}
function j_e(e, t, n) {
  const r = e / 2, a = Cj([0, 50], [0, r]);
  return (r - a(t) * n) * n;
}
function P_e(e) {
  return e.slice(0, -1).map((t, n) => e[n + 1] - t);
}
function D_e(e, t) {
  if (t > 0) {
    const n = P_e(e);
    return Math.min(...n) >= t;
  }
  return !0;
}
function Cj(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const r = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + r * (n - e[0]);
  };
}
function I_e(e) {
  return (String(e).split(".")[1] || "").length;
}
function $_e(e, t) {
  const n = Math.pow(10, t);
  return Math.round(e * n) / n;
}
var z_e = Uq, T_e = Gq, L_e = Kq, F_e = Yq;
function B_e(e) {
  return e === 0 ? 0 : Math.abs(e) < 1e-12 ? e : Number(e.toPrecision(12));
}
const Qq = ({
  inputconverter: e,
  parser: t = (n) => parseFloat(n)
}) => {
  const n = hr(), { preview: r } = n.valuestore(), a = n.use(), s = Zm(a), [l, c] = M.useState(
    e[1](r?.value)
  );
  M.useEffect(() => {
    c(e[1](r?.value));
  }, [r]);
  const d = M.useCallback(
    (g) => {
      g = t(
        parseFloat(g.toString()).toString()
        // parse float first for e notation
      ), isNaN(g) ? (g = "<NoValue>", c("")) : (a.value_options?.min !== void 0 && g < a.value_options.min && (g = a.value_options.min), a.value_options?.max !== void 0 && g > a.value_options.max && (g = a.value_options.max), g = B_e(g), c(g.toString()));
      try {
        g = e[0](g);
      } catch {
      }
      g !== r?.value && s(g);
    },
    [a, e, s]
  ), f = M.useCallback(
    (g) => {
      d(g.target.value);
    },
    [d]
  );
  let m = a.connected ? e[1](r?.value) : l;
  m === void 0 && (m = a.value_options?.min), m === void 0 && (m = a.value_options?.max), m === void 0 && (m = ""), m === null && (m = "");
  let h = null, v = 1;
  return a.value_options?.step !== void 0 ? v = a.value_options.step : a.value_options?.max !== void 0 && a.value_options?.min !== void 0 && (v = (a.value_options?.max - a.value_options?.min) / 1e3), a.value_options?.max !== void 0 && a.value_options?.min !== void 0 && !a.connected && (h = /* @__PURE__ */ C.jsx("div", { style: { minWidth: "6.25rem" }, className: "SliderContainer", children: /* @__PURE__ */ C.jsxs(
    z_e,
    {
      className: "SliderRoot",
      value: [m === void 0 ? a.value_options?.min : m],
      min: a.value_options?.min,
      max: a.value_options?.max,
      step: v,
      disabled: a.connected,
      onValueCommit: (g) => {
        isNaN(g[0]) || d(g[0]);
      },
      onValueChange: (g) => {
        isNaN(g[0]) || c(g[0].toString());
      },
      onKeyDown: (g) => {
        ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(
          g.key
        ) && g.stopPropagation();
      },
      children: [
        /* @__PURE__ */ C.jsx(T_e, { className: "SliderTrack", children: /* @__PURE__ */ C.jsx(L_e, { className: "SliderRange" }) }),
        /* @__PURE__ */ C.jsx(F_e, { className: "SliderThumb" })
      ]
    }
  ) })), /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
    h,
    /* @__PURE__ */ C.jsx(
      "input",
      {
        type: "text",
        className: "nodedatainput styledinput numberinput",
        value: m,
        onChange: (g) => c(g.target.value),
        onBlur: f,
        step: v,
        onKeyDown: (g) => {
          if (!(g.ctrlKey || g.metaKey)) {
            if (g.key === "ArrowUp") {
              g.shiftKey && (v *= 10);
              let b = (parseFloat(m) || 0) + v;
              d(b);
              return;
            }
            if (g.key === "ArrowDown") {
              g.shiftKey && (v *= 10);
              let b = (parseFloat(m) || 0) - v;
              d(b);
              return;
            }
            !/^[0-9.eE+-]$/.test(g.key) && !["Backspace", "ArrowLeft", "ArrowRight", "Delete", "Tab"].includes(
              g.key
            ) && g.preventDefault();
          }
        },
        disabled: a.connected,
        min: a.value_options?.min,
        max: a.value_options?.max
      }
    )
  ] });
}, U_e = ({ inputconverter: e }) => Qq({ inputconverter: e, parser: parseFloat }), V_e = ({ inputconverter: e }) => Qq({ inputconverter: e, parser: parseInt }), H_e = (e) => e, W_e = (e) => parseFloat(e), q_e = (e) => !!e, G_e = (e) => e === "null" ? null : e, K_e = (e) => e === "nuinputconvertermber" ? W_e : e === "boolean" ? q_e : e === "undefined" ? G_e : H_e, bS = ({
  inputconverter: e,
  parser: t
}) => {
  const n = hr(), r = n.use(), { preview: a, full: s } = n.valuestore(), l = s === void 0 ? a?.value : s.value, c = Zm(r);
  let d = r.value_options?.options || [];
  Array.isArray(d) && (d = {
    type: "enum",
    values: d,
    keys: d.map((x) => x === null ? "None" : x.toString()),
    nullable: !1
  }), d.type !== "enum" && (d = {
    type: "enum",
    values: Object.values(d),
    keys: Object.keys(d),
    nullable: !1
  }), d = d, d.nullable && !d.values.includes(null) && !d.keys.includes("None") && (d.values.unshift(null), d.keys.unshift("None"));
  const f = [];
  for (let x = 0; x < d.values.length; x++) {
    const w = d.values[x] === null || d.values[x] === void 0 ? "undefined" : typeof d.values[x];
    let k = d.values[x];
    k === null && (k = "null"), k === void 0 && (k = "undefined"), f.push([d.keys[x], k.toString(), w]);
  }
  const m = M.useCallback(
    ({
      value: x,
      // label
      datatype: w
    }) => {
      let k = (t || K_e(w))(x);
      try {
        k = e[0](x);
      } catch {
      }
      c(k);
    },
    [r, e, c]
  );
  let h = l;
  h === null && (h = "null"), h === void 0 && (h = "undefined");
  const v = f.find((x) => x[1] === h.toString());
  let g;
  v !== void 0 && (g = {
    value: v[1],
    label: v[0],
    datatype: v[2]
  });
  const b = f.map(
    (x) => ({
      value: x[1],
      label: x[0],
      datatype: x[2]
    })
  );
  return (
    // <Suspense fallback={<select disabled={true}></select>}>
    /* @__PURE__ */ C.jsx(
      Vme,
      {
        className: "nodedatainput styleddropdown",
        options: b,
        defaultValue: g,
        onChange: (x) => {
          if (x === null) {
            m({
              value: "<NoValue>",
              datatype: "string"
            });
            return;
          }
          m(x);
        }
      }
    )
  );
}, Z6 = ({ inputconverter: e }) => {
  const t = hr(), { preview: n, full: r } = t.valuestore(), a = t.use(), s = r === void 0 ? n?.value : r?.value, l = Zm(a), [c, d] = M.useState(e[1](s));
  M.useEffect(() => {
    d(e[1](s));
  }, [s]);
  const f = M.useCallback(
    (g) => {
      let b = g.target.value;
      b || (b = "<NoValue>");
      try {
        b = e[0](b);
      } catch {
      }
      b !== s && l(b);
    },
    [l, e, s]
  );
  let m = a.connected ? e[1](s) : c;
  m == null && (m = ""), m = m.toString();
  const h = (m.toString().match(/\n/g) || []).length, v = Math.max(...m.split(`
`).map((g) => g.length), 0);
  return /* @__PURE__ */ C.jsx(
    "textarea",
    {
      className: "nodedatainput styledinput stringinput",
      value: m,
      onChange: (g) => d(g.target.value),
      onBlur: (g) => {
        f(g);
      },
      disabled: a.connected,
      rows: h + 1,
      cols: v + 1
    }
  );
};
function un(e) {
  return typeof e != "object" || e === null || typeof e.lastModified == "number" && typeof File < "u" && e instanceof File || typeof e.getMonth == "function" && typeof Date < "u" && e instanceof Date ? !1 : !Array.isArray(e);
}
function Y_e(e) {
  return e.additionalItems === !0 && console.warn("additionalItems=true is currently not supported"), un(e.additionalItems);
}
function ez(e) {
  if (e === "")
    return;
  if (e === null)
    return null;
  if (/\.$/.test(e) || /\.0$/.test(e) || /\.\d*0$/.test(e))
    return e;
  const t = Number(e);
  return typeof t == "number" && !Number.isNaN(t) ? t : e;
}
const Pc = "__additional_property", T2 = "additionalProperties", Dd = "allOf", dn = "anyOf", qi = "const", gC = "default", Oj = "dependencies", X_e = "enum", zo = "__errors", Ln = "$id", J_e = "if", Cg = "items", Q_e = "_$junk_option_schema_id$_", V_ = "$name", Kt = "oneOf", I3 = "patternProperties", gn = "properties", f5 = "readonly", Zq = "required", L2 = "submitButtonOptions", cr = "$ref", xx = "$schema", eG = "root", tG = "_", Z_e = ["discriminator", "propertyName"], tz = "formContext", e2e = "layoutGridLookupMap", Mj = "__rjsf_additionalProperties", nG = "__rjsf_rootSchema", t2e = "ui:field", Nj = "ui:widget", wd = "ui:options", $3 = "ui:globalOptions", n2e = "https://json-schema.org/draft/2019-09/schema", H_ = "https://json-schema.org/draft/2020-12/schema";
function vt(e = {}, t = {}) {
  return e ? Object.keys(e).filter((n) => n.indexOf("ui:") === 0).reduce((n, r) => {
    const a = e[r];
    return r === Nj && un(a) ? (console.error("Setting options via ui:widget object is no longer supported, use ui:options instead"), n) : r === wd && un(a) ? { ...n, ...a } : { ...n, [r.substring(3)]: a };
  }, { ...t }) : { ...t };
}
function rG(e, t = {}, n) {
  if (!(e.additionalProperties || e.patternProperties))
    return !1;
  const { expandable: r = !0 } = vt(t);
  return r === !1 ? r : e.maxProperties !== void 0 && n ? Object.keys(n).length < e.maxProperties : !0;
}
var oG = typeof km == "object" && km && km.Object === Object && km, r2e = typeof self == "object" && self && self.Object === Object && self, Ql = oG || r2e || Function("return this")(), Gi = Ql.Symbol, aG = Object.prototype, o2e = aG.hasOwnProperty, a2e = aG.toString, Qw = Gi ? Gi.toStringTag : void 0;
function i2e(e) {
  var t = o2e.call(e, Qw), n = e[Qw];
  try {
    e[Qw] = void 0;
    var r = !0;
  } catch {
  }
  var a = a2e.call(e);
  return r && (t ? e[Qw] = n : delete e[Qw]), a;
}
var s2e = Object.prototype, l2e = s2e.toString;
function u2e(e) {
  return l2e.call(e);
}
var c2e = "[object Null]", d2e = "[object Undefined]", nz = Gi ? Gi.toStringTag : void 0;
function Qc(e) {
  return e == null ? e === void 0 ? d2e : c2e : nz && nz in Object(e) ? i2e(e) : u2e(e);
}
function iG(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var vC = iG(Object.getPrototypeOf, Object);
function Ki(e) {
  return e != null && typeof e == "object";
}
var f2e = "[object Object]", p2e = Function.prototype, m2e = Object.prototype, sG = p2e.toString, h2e = m2e.hasOwnProperty, g2e = sG.call(Object);
function Id(e) {
  if (!Ki(e) || Qc(e) != f2e)
    return !1;
  var t = vC(e);
  if (t === null)
    return !0;
  var n = h2e.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && sG.call(n) == g2e;
}
function z3(e) {
  const t = {
    // We store the list of errors for this node in a property named __errors
    // to avoid name collision with a possible sub schema field named
    // 'errors' (see `utils.toErrorSchema`).
    [zo]: [],
    addError(n) {
      this[zo].push(n);
    }
  };
  if (Array.isArray(e))
    return e.reduce((n, r, a) => ({ ...n, [a]: z3(r) }), t);
  if (Id(e)) {
    const n = e;
    return Object.keys(n).reduce((r, a) => ({ ...r, [a]: z3(n[a]) }), t);
  }
  return t;
}
function v2e() {
  this.__data__ = [], this.size = 0;
}
function yk(e, t) {
  return e === t || e !== e && t !== t;
}
function yC(e, t) {
  for (var n = e.length; n--; )
    if (yk(e[n][0], t))
      return n;
  return -1;
}
var y2e = Array.prototype, b2e = y2e.splice;
function w2e(e) {
  var t = this.__data__, n = yC(t, e);
  if (n < 0)
    return !1;
  var r = t.length - 1;
  return n == r ? t.pop() : b2e.call(t, n, 1), --this.size, !0;
}
function x2e(e) {
  var t = this.__data__, n = yC(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function S2e(e) {
  return yC(this.__data__, e) > -1;
}
function k2e(e, t) {
  var n = this.__data__, r = yC(n, e);
  return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
}
function Zc(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Zc.prototype.clear = v2e;
Zc.prototype.delete = w2e;
Zc.prototype.get = x2e;
Zc.prototype.has = S2e;
Zc.prototype.set = k2e;
function _2e() {
  this.__data__ = new Zc(), this.size = 0;
}
function E2e(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function C2e(e) {
  return this.__data__.get(e);
}
function O2e(e) {
  return this.__data__.has(e);
}
function mn(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var M2e = "[object AsyncFunction]", N2e = "[object Function]", A2e = "[object GeneratorFunction]", R2e = "[object Proxy]";
function bk(e) {
  if (!mn(e))
    return !1;
  var t = Qc(e);
  return t == N2e || t == A2e || t == M2e || t == R2e;
}
var p5 = Ql["__core-js_shared__"], rz = (function() {
  var e = /[^.]+$/.exec(p5 && p5.keys && p5.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
})();
function j2e(e) {
  return !!rz && rz in e;
}
var P2e = Function.prototype, D2e = P2e.toString;
function eh(e) {
  if (e != null) {
    try {
      return D2e.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var I2e = /[\\^$.*+?()[\]{}|]/g, $2e = /^\[object .+?Constructor\]$/, z2e = Function.prototype, T2e = Object.prototype, L2e = z2e.toString, F2e = T2e.hasOwnProperty, B2e = RegExp(
  "^" + L2e.call(F2e).replace(I2e, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function U2e(e) {
  if (!mn(e) || j2e(e))
    return !1;
  var t = bk(e) ? B2e : $2e;
  return t.test(eh(e));
}
function V2e(e, t) {
  return e?.[t];
}
function th(e, t) {
  var n = V2e(e, t);
  return U2e(n) ? n : void 0;
}
var wS = th(Ql, "Map"), xS = th(Object, "create");
function H2e() {
  this.__data__ = xS ? xS(null) : {}, this.size = 0;
}
function W2e(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var q2e = "__lodash_hash_undefined__", G2e = Object.prototype, K2e = G2e.hasOwnProperty;
function Y2e(e) {
  var t = this.__data__;
  if (xS) {
    var n = t[e];
    return n === q2e ? void 0 : n;
  }
  return K2e.call(t, e) ? t[e] : void 0;
}
var X2e = Object.prototype, J2e = X2e.hasOwnProperty;
function Q2e(e) {
  var t = this.__data__;
  return xS ? t[e] !== void 0 : J2e.call(t, e);
}
var Z2e = "__lodash_hash_undefined__";
function eEe(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = xS && t === void 0 ? Z2e : t, this;
}
function Vm(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Vm.prototype.clear = H2e;
Vm.prototype.delete = W2e;
Vm.prototype.get = Y2e;
Vm.prototype.has = Q2e;
Vm.prototype.set = eEe;
function tEe() {
  this.size = 0, this.__data__ = {
    hash: new Vm(),
    map: new (wS || Zc)(),
    string: new Vm()
  };
}
function nEe(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function bC(e, t) {
  var n = e.__data__;
  return nEe(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function rEe(e) {
  var t = bC(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function oEe(e) {
  return bC(this, e).get(e);
}
function aEe(e) {
  return bC(this, e).has(e);
}
function iEe(e, t) {
  var n = bC(this, e), r = n.size;
  return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
}
function ed(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
ed.prototype.clear = tEe;
ed.prototype.delete = rEe;
ed.prototype.get = oEe;
ed.prototype.has = aEe;
ed.prototype.set = iEe;
var sEe = 200;
function lEe(e, t) {
  var n = this.__data__;
  if (n instanceof Zc) {
    var r = n.__data__;
    if (!wS || r.length < sEe - 1)
      return r.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new ed(r);
  }
  return n.set(e, t), this.size = n.size, this;
}
function Js(e) {
  var t = this.__data__ = new Zc(e);
  this.size = t.size;
}
Js.prototype.clear = _2e;
Js.prototype.delete = E2e;
Js.prototype.get = C2e;
Js.prototype.has = O2e;
Js.prototype.set = lEe;
var uEe = "__lodash_hash_undefined__";
function cEe(e) {
  return this.__data__.set(e, uEe), this;
}
function dEe(e) {
  return this.__data__.has(e);
}
function Hm(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new ed(); ++t < n; )
    this.add(e[t]);
}
Hm.prototype.add = Hm.prototype.push = cEe;
Hm.prototype.has = dEe;
function fEe(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
function SS(e, t) {
  return e.has(t);
}
var pEe = 1, mEe = 2;
function lG(e, t, n, r, a, s) {
  var l = n & pEe, c = e.length, d = t.length;
  if (c != d && !(l && d > c))
    return !1;
  var f = s.get(e), m = s.get(t);
  if (f && m)
    return f == t && m == e;
  var h = -1, v = !0, g = n & mEe ? new Hm() : void 0;
  for (s.set(e, t), s.set(t, e); ++h < c; ) {
    var b = e[h], x = t[h];
    if (r)
      var w = l ? r(x, b, h, t, e, s) : r(b, x, h, e, t, s);
    if (w !== void 0) {
      if (w)
        continue;
      v = !1;
      break;
    }
    if (g) {
      if (!fEe(t, function(k, E) {
        if (!SS(g, E) && (b === k || a(b, k, n, r, s)))
          return g.push(E);
      })) {
        v = !1;
        break;
      }
    } else if (!(b === x || a(b, x, n, r, s))) {
      v = !1;
      break;
    }
  }
  return s.delete(e), s.delete(t), v;
}
var F2 = Ql.Uint8Array;
function hEe(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r, a) {
    n[++t] = [a, r];
  }), n;
}
function Aj(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r) {
    n[++t] = r;
  }), n;
}
var gEe = 1, vEe = 2, yEe = "[object Boolean]", bEe = "[object Date]", wEe = "[object Error]", xEe = "[object Map]", SEe = "[object Number]", kEe = "[object RegExp]", _Ee = "[object Set]", EEe = "[object String]", CEe = "[object Symbol]", OEe = "[object ArrayBuffer]", MEe = "[object DataView]", oz = Gi ? Gi.prototype : void 0, m5 = oz ? oz.valueOf : void 0;
function NEe(e, t, n, r, a, s, l) {
  switch (n) {
    case MEe:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case OEe:
      return !(e.byteLength != t.byteLength || !s(new F2(e), new F2(t)));
    case yEe:
    case bEe:
    case SEe:
      return yk(+e, +t);
    case wEe:
      return e.name == t.name && e.message == t.message;
    case kEe:
    case EEe:
      return e == t + "";
    case xEe:
      var c = hEe;
    case _Ee:
      var d = r & gEe;
      if (c || (c = Aj), e.size != t.size && !d)
        return !1;
      var f = l.get(e);
      if (f)
        return f == t;
      r |= vEe, l.set(e, t);
      var m = lG(c(e), c(t), r, a, s, l);
      return l.delete(e), m;
    case CEe:
      if (m5)
        return m5.call(e) == m5.call(t);
  }
  return !1;
}
function Rj(e, t) {
  for (var n = -1, r = t.length, a = e.length; ++n < r; )
    e[a + n] = t[n];
  return e;
}
var oo = Array.isArray;
function uG(e, t, n) {
  var r = t(e);
  return oo(e) ? r : Rj(r, n(e));
}
function AEe(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, a = 0, s = []; ++n < r; ) {
    var l = e[n];
    t(l, n, e) && (s[a++] = l);
  }
  return s;
}
function cG() {
  return [];
}
var REe = Object.prototype, jEe = REe.propertyIsEnumerable, az = Object.getOwnPropertySymbols, jj = az ? function(e) {
  return e == null ? [] : (e = Object(e), AEe(az(e), function(t) {
    return jEe.call(e, t);
  }));
} : cG;
function dG(e, t) {
  for (var n = -1, r = Array(e); ++n < e; )
    r[n] = t(n);
  return r;
}
var PEe = "[object Arguments]";
function iz(e) {
  return Ki(e) && Qc(e) == PEe;
}
var fG = Object.prototype, DEe = fG.hasOwnProperty, IEe = fG.propertyIsEnumerable, Og = iz(/* @__PURE__ */ (function() {
  return arguments;
})()) ? iz : function(e) {
  return Ki(e) && DEe.call(e, "callee") && !IEe.call(e, "callee");
};
function $Ee() {
  return !1;
}
var pG = typeof exports == "object" && exports && !exports.nodeType && exports, sz = pG && typeof module == "object" && module && !module.nodeType && module, zEe = sz && sz.exports === pG, lz = zEe ? Ql.Buffer : void 0, TEe = lz ? lz.isBuffer : void 0, Wm = TEe || $Ee, LEe = 9007199254740991, FEe = /^(?:0|[1-9]\d*)$/;
function wC(e, t) {
  var n = typeof e;
  return t = t ?? LEe, !!t && (n == "number" || n != "symbol" && FEe.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
var BEe = 9007199254740991;
function Pj(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= BEe;
}
var UEe = "[object Arguments]", VEe = "[object Array]", HEe = "[object Boolean]", WEe = "[object Date]", qEe = "[object Error]", GEe = "[object Function]", KEe = "[object Map]", YEe = "[object Number]", XEe = "[object Object]", JEe = "[object RegExp]", QEe = "[object Set]", ZEe = "[object String]", eCe = "[object WeakMap]", tCe = "[object ArrayBuffer]", nCe = "[object DataView]", rCe = "[object Float32Array]", oCe = "[object Float64Array]", aCe = "[object Int8Array]", iCe = "[object Int16Array]", sCe = "[object Int32Array]", lCe = "[object Uint8Array]", uCe = "[object Uint8ClampedArray]", cCe = "[object Uint16Array]", dCe = "[object Uint32Array]", lr = {};
lr[rCe] = lr[oCe] = lr[aCe] = lr[iCe] = lr[sCe] = lr[lCe] = lr[uCe] = lr[cCe] = lr[dCe] = !0;
lr[UEe] = lr[VEe] = lr[tCe] = lr[HEe] = lr[nCe] = lr[WEe] = lr[qEe] = lr[GEe] = lr[KEe] = lr[YEe] = lr[XEe] = lr[JEe] = lr[QEe] = lr[ZEe] = lr[eCe] = !1;
function fCe(e) {
  return Ki(e) && Pj(e.length) && !!lr[Qc(e)];
}
function Dj(e) {
  return function(t) {
    return e(t);
  };
}
var mG = typeof exports == "object" && exports && !exports.nodeType && exports, zx = mG && typeof module == "object" && module && !module.nodeType && module, pCe = zx && zx.exports === mG, h5 = pCe && oG.process, Mg = (function() {
  try {
    var e = zx && zx.require && zx.require("util").types;
    return e || h5 && h5.binding && h5.binding("util");
  } catch {
  }
})(), uz = Mg && Mg.isTypedArray, wk = uz ? Dj(uz) : fCe, mCe = Object.prototype, hCe = mCe.hasOwnProperty;
function hG(e, t) {
  var n = oo(e), r = !n && Og(e), a = !n && !r && Wm(e), s = !n && !r && !a && wk(e), l = n || r || a || s, c = l ? dG(e.length, String) : [], d = c.length;
  for (var f in e)
    (t || hCe.call(e, f)) && !(l && // Safari 9 has enumerable `arguments.length` in strict mode.
    (f == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    a && (f == "offset" || f == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (f == "buffer" || f == "byteLength" || f == "byteOffset") || // Skip index properties.
    wC(f, d))) && c.push(f);
  return c;
}
var gCe = Object.prototype;
function xC(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || gCe;
  return e === n;
}
var vCe = iG(Object.keys, Object), yCe = Object.prototype, bCe = yCe.hasOwnProperty;
function gG(e) {
  if (!xC(e))
    return vCe(e);
  var t = [];
  for (var n in Object(e))
    bCe.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
function nh(e) {
  return e != null && Pj(e.length) && !bk(e);
}
function qs(e) {
  return nh(e) ? hG(e) : gG(e);
}
function T3(e) {
  return uG(e, qs, jj);
}
var wCe = 1, xCe = Object.prototype, SCe = xCe.hasOwnProperty;
function kCe(e, t, n, r, a, s) {
  var l = n & wCe, c = T3(e), d = c.length, f = T3(t), m = f.length;
  if (d != m && !l)
    return !1;
  for (var h = d; h--; ) {
    var v = c[h];
    if (!(l ? v in t : SCe.call(t, v)))
      return !1;
  }
  var g = s.get(e), b = s.get(t);
  if (g && b)
    return g == t && b == e;
  var x = !0;
  s.set(e, t), s.set(t, e);
  for (var w = l; ++h < d; ) {
    v = c[h];
    var k = e[v], E = t[v];
    if (r)
      var _ = l ? r(E, k, v, t, e, s) : r(k, E, v, e, t, s);
    if (!(_ === void 0 ? k === E || a(k, E, n, r, s) : _)) {
      x = !1;
      break;
    }
    w || (w = v == "constructor");
  }
  if (x && !w) {
    var O = e.constructor, N = t.constructor;
    O != N && "constructor" in e && "constructor" in t && !(typeof O == "function" && O instanceof O && typeof N == "function" && N instanceof N) && (x = !1);
  }
  return s.delete(e), s.delete(t), x;
}
var L3 = th(Ql, "DataView"), F3 = th(Ql, "Promise"), sg = th(Ql, "Set"), B3 = th(Ql, "WeakMap"), cz = "[object Map]", _Ce = "[object Object]", dz = "[object Promise]", fz = "[object Set]", pz = "[object WeakMap]", mz = "[object DataView]", ECe = eh(L3), CCe = eh(wS), OCe = eh(F3), MCe = eh(sg), NCe = eh(B3), Fi = Qc;
(L3 && Fi(new L3(new ArrayBuffer(1))) != mz || wS && Fi(new wS()) != cz || F3 && Fi(F3.resolve()) != dz || sg && Fi(new sg()) != fz || B3 && Fi(new B3()) != pz) && (Fi = function(e) {
  var t = Qc(e), n = t == _Ce ? e.constructor : void 0, r = n ? eh(n) : "";
  if (r)
    switch (r) {
      case ECe:
        return mz;
      case CCe:
        return cz;
      case OCe:
        return dz;
      case MCe:
        return fz;
      case NCe:
        return pz;
    }
  return t;
});
var ACe = 1, hz = "[object Arguments]", gz = "[object Array]", v0 = "[object Object]", RCe = Object.prototype, vz = RCe.hasOwnProperty;
function jCe(e, t, n, r, a, s) {
  var l = oo(e), c = oo(t), d = l ? gz : Fi(e), f = c ? gz : Fi(t);
  d = d == hz ? v0 : d, f = f == hz ? v0 : f;
  var m = d == v0, h = f == v0, v = d == f;
  if (v && Wm(e)) {
    if (!Wm(t))
      return !1;
    l = !0, m = !1;
  }
  if (v && !m)
    return s || (s = new Js()), l || wk(e) ? lG(e, t, n, r, a, s) : NEe(e, t, d, n, r, a, s);
  if (!(n & ACe)) {
    var g = m && vz.call(e, "__wrapped__"), b = h && vz.call(t, "__wrapped__");
    if (g || b) {
      var x = g ? e.value() : e, w = b ? t.value() : t;
      return s || (s = new Js()), a(x, w, n, r, s);
    }
  }
  return v ? (s || (s = new Js()), kCe(e, t, n, r, a, s)) : !1;
}
function xk(e, t, n, r, a) {
  return e === t ? !0 : e == null || t == null || !Ki(e) && !Ki(t) ? e !== e && t !== t : jCe(e, t, n, r, xk, a);
}
function PCe(e, t, n) {
  n = typeof n == "function" ? n : void 0;
  var r = n ? n(e, t) : void 0;
  return r === void 0 ? xk(e, t, void 0, n) : !!r;
}
function er(e, t) {
  return PCe(e, t, (n, r) => {
    if (typeof n == "function" && typeof r == "function")
      return !0;
  });
}
var DCe = "[object Symbol]";
function Sk(e) {
  return typeof e == "symbol" || Ki(e) && Qc(e) == DCe;
}
var ICe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, $Ce = /^\w*$/;
function Ij(e, t) {
  if (oo(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || Sk(e) ? !0 : $Ce.test(e) || !ICe.test(e) || t != null && e in Object(t);
}
var zCe = "Expected a function";
function $j(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(zCe);
  var n = function() {
    var r = arguments, a = t ? t.apply(this, r) : r[0], s = n.cache;
    if (s.has(a))
      return s.get(a);
    var l = e.apply(this, r);
    return n.cache = s.set(a, l) || s, l;
  };
  return n.cache = new ($j.Cache || ed)(), n;
}
$j.Cache = ed;
var TCe = 500;
function LCe(e) {
  var t = $j(e, function(r) {
    return n.size === TCe && n.clear(), r;
  }), n = t.cache;
  return t;
}
var FCe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, BCe = /\\(\\)?/g, vG = LCe(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(FCe, function(n, r, a, s) {
    t.push(a ? s.replace(BCe, "$1") : r || n);
  }), t;
});
function Wg(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, a = Array(r); ++n < r; )
    a[n] = t(e[n], n, e);
  return a;
}
var yz = Gi ? Gi.prototype : void 0, bz = yz ? yz.toString : void 0;
function yG(e) {
  if (typeof e == "string")
    return e;
  if (oo(e))
    return Wg(e, yG) + "";
  if (Sk(e))
    return bz ? bz.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function zj(e) {
  return e == null ? "" : yG(e);
}
function qg(e, t) {
  return oo(e) ? e : Ij(e, t) ? [e] : vG(zj(e));
}
function rh(e) {
  if (typeof e == "string" || Sk(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function SC(e, t) {
  t = qg(t, e);
  for (var n = 0, r = t.length; e != null && n < r; )
    e = e[rh(t[n++])];
  return n && n == r ? e : void 0;
}
function Re(e, t, n) {
  var r = e == null ? void 0 : SC(e, t);
  return r === void 0 ? n : r;
}
var UCe = Object.prototype, VCe = UCe.hasOwnProperty;
function HCe(e, t) {
  return e != null && VCe.call(e, t);
}
function bG(e, t, n) {
  t = qg(t, e);
  for (var r = -1, a = t.length, s = !1; ++r < a; ) {
    var l = rh(t[r]);
    if (!(s = e != null && n(e, l)))
      break;
    e = e[l];
  }
  return s || ++r != a ? s : (a = e == null ? 0 : e.length, !!a && Pj(a) && wC(l, a) && (oo(e) || Og(e)));
}
function rn(e, t) {
  return e != null && bG(e, t, HCe);
}
function kS(e, t) {
  return xk(e, t);
}
var B2 = (function() {
  try {
    var e = th(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
})();
function Tj(e, t, n) {
  t == "__proto__" && B2 ? B2(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
var WCe = Object.prototype, qCe = WCe.hasOwnProperty;
function Lj(e, t, n) {
  var r = e[t];
  (!(qCe.call(e, t) && yk(r, n)) || n === void 0 && !(t in e)) && Tj(e, t, n);
}
function Fj(e, t, n, r) {
  if (!mn(e))
    return e;
  t = qg(t, e);
  for (var a = -1, s = t.length, l = s - 1, c = e; c != null && ++a < s; ) {
    var d = rh(t[a]), f = n;
    if (d === "__proto__" || d === "constructor" || d === "prototype")
      return e;
    if (a != l) {
      var m = c[d];
      f = r ? r(m, d, c) : void 0, f === void 0 && (f = mn(m) ? m : wC(t[a + 1]) ? [] : {});
    }
    Lj(c, d, f), c = c[d];
  }
  return e;
}
function zn(e, t, n) {
  return e == null ? e : Fj(e, t, n);
}
function kC(e) {
  return e;
}
function wG(e) {
  return typeof e == "function" ? e : kC;
}
var GCe = /\s/;
function KCe(e) {
  for (var t = e.length; t-- && GCe.test(e.charAt(t)); )
    ;
  return t;
}
var YCe = /^\s+/;
function XCe(e) {
  return e && e.slice(0, KCe(e) + 1).replace(YCe, "");
}
var wz = NaN, JCe = /^[-+]0x[0-9a-f]+$/i, QCe = /^0b[01]+$/i, ZCe = /^0o[0-7]+$/i, eOe = parseInt;
function tOe(e) {
  if (typeof e == "number")
    return e;
  if (Sk(e))
    return wz;
  if (mn(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = mn(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = XCe(e);
  var n = QCe.test(e);
  return n || ZCe.test(e) ? eOe(e.slice(2), n ? 2 : 8) : JCe.test(e) ? wz : +e;
}
var xz = 1 / 0, nOe = 17976931348623157e292;
function rOe(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = tOe(e), e === xz || e === -xz) {
    var t = e < 0 ? -1 : 1;
    return t * nOe;
  }
  return e === e ? e : 0;
}
function xG(e) {
  var t = rOe(e), n = t % 1;
  return t === t ? n ? t - n : t : 0;
}
var oOe = 9007199254740991, g5 = 4294967295, aOe = Math.min;
function SG(e, t) {
  if (e = xG(e), e < 1 || e > oOe)
    return [];
  var n = g5, r = aOe(e, g5);
  t = wG(t), e -= g5;
  for (var a = dG(r, t); ++n < e; )
    t(n);
  return a;
}
function Bj(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r && t(e[n], n, e) !== !1; )
    ;
  return e;
}
var Sz = Object.create, kG = /* @__PURE__ */ (function() {
  function e() {
  }
  return function(t) {
    if (!mn(t))
      return {};
    if (Sz)
      return Sz(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
})();
function iOe(e) {
  return function(t, n, r) {
    for (var a = -1, s = Object(t), l = r(t), c = l.length; c--; ) {
      var d = l[++a];
      if (n(s[d], d, s) === !1)
        break;
    }
    return t;
  };
}
var _G = iOe();
function EG(e, t) {
  return e && _G(e, t, qs);
}
var sOe = 1, lOe = 2;
function uOe(e, t, n, r) {
  var a = n.length, s = a;
  if (e == null)
    return !s;
  for (e = Object(e); a--; ) {
    var l = n[a];
    if (l[2] ? l[1] !== e[l[0]] : !(l[0] in e))
      return !1;
  }
  for (; ++a < s; ) {
    l = n[a];
    var c = l[0], d = e[c], f = l[1];
    if (l[2]) {
      if (d === void 0 && !(c in e))
        return !1;
    } else {
      var m = new Js(), h;
      if (!(h === void 0 ? xk(f, d, sOe | lOe, r, m) : h))
        return !1;
    }
  }
  return !0;
}
function CG(e) {
  return e === e && !mn(e);
}
function cOe(e) {
  for (var t = qs(e), n = t.length; n--; ) {
    var r = t[n], a = e[r];
    t[n] = [r, a, CG(a)];
  }
  return t;
}
function OG(e, t) {
  return function(n) {
    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
  };
}
function dOe(e) {
  var t = cOe(e);
  return t.length == 1 && t[0][2] ? OG(t[0][0], t[0][1]) : function(n) {
    return n === e || uOe(n, e, t);
  };
}
function fOe(e, t) {
  return e != null && t in Object(e);
}
function MG(e, t) {
  return e != null && bG(e, t, fOe);
}
var pOe = 1, mOe = 2;
function hOe(e, t) {
  return Ij(e) && CG(t) ? OG(rh(e), t) : function(n) {
    var r = Re(n, e);
    return r === void 0 && r === t ? MG(n, e) : xk(t, r, pOe | mOe);
  };
}
function gOe(e) {
  return function(t) {
    return t?.[e];
  };
}
function vOe(e) {
  return function(t) {
    return SC(t, e);
  };
}
function yOe(e) {
  return Ij(e) ? gOe(rh(e)) : vOe(e);
}
function Uj(e) {
  return typeof e == "function" ? e : e == null ? kC : typeof e == "object" ? oo(e) ? hOe(e[0], e[1]) : dOe(e) : yOe(e);
}
function bOe(e, t, n) {
  var r = oo(e), a = r || Wm(e) || wk(e);
  if (t = Uj(t), n == null) {
    var s = e && e.constructor;
    a ? n = r ? new s() : [] : mn(e) ? n = bk(s) ? kG(vC(e)) : {} : n = {};
  }
  return (a ? Bj : EG)(e, function(l, c, d) {
    return t(n, l, c, d);
  }), n;
}
function U3(e, t, n) {
  (n !== void 0 && !yk(e[t], n) || n === void 0 && !(t in e)) && Tj(e, t, n);
}
var NG = typeof exports == "object" && exports && !exports.nodeType && exports, kz = NG && typeof module == "object" && module && !module.nodeType && module, wOe = kz && kz.exports === NG, _z = wOe ? Ql.Buffer : void 0, Ez = _z ? _z.allocUnsafe : void 0;
function AG(e, t) {
  if (t)
    return e.slice();
  var n = e.length, r = Ez ? Ez(n) : new e.constructor(n);
  return e.copy(r), r;
}
function Vj(e) {
  var t = new e.constructor(e.byteLength);
  return new F2(t).set(new F2(e)), t;
}
function RG(e, t) {
  var n = t ? Vj(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.length);
}
function Hj(e, t) {
  var n = -1, r = e.length;
  for (t || (t = Array(r)); ++n < r; )
    t[n] = e[n];
  return t;
}
function jG(e) {
  return typeof e.constructor == "function" && !xC(e) ? kG(vC(e)) : {};
}
function _S(e) {
  return Ki(e) && nh(e);
}
function V3(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
function Gg(e, t, n, r) {
  var a = !n;
  n || (n = {});
  for (var s = -1, l = t.length; ++s < l; ) {
    var c = t[s], d = void 0;
    d === void 0 && (d = e[c]), a ? Tj(n, c, d) : Lj(n, c, d);
  }
  return n;
}
function xOe(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var SOe = Object.prototype, kOe = SOe.hasOwnProperty;
function _Oe(e) {
  if (!mn(e))
    return xOe(e);
  var t = xC(e), n = [];
  for (var r in e)
    r == "constructor" && (t || !kOe.call(e, r)) || n.push(r);
  return n;
}
function kk(e) {
  return nh(e) ? hG(e, !0) : _Oe(e);
}
function EOe(e) {
  return Gg(e, kk(e));
}
function COe(e, t, n, r, a, s, l) {
  var c = V3(e, n), d = V3(t, n), f = l.get(d);
  if (f) {
    U3(e, n, f);
    return;
  }
  var m = s ? s(c, d, n + "", e, t, l) : void 0, h = m === void 0;
  if (h) {
    var v = oo(d), g = !v && Wm(d), b = !v && !g && wk(d);
    m = d, v || g || b ? oo(c) ? m = c : _S(c) ? m = Hj(c) : g ? (h = !1, m = AG(d, !0)) : b ? (h = !1, m = RG(d, !0)) : m = [] : Id(d) || Og(d) ? (m = c, Og(c) ? m = EOe(c) : (!mn(c) || bk(c)) && (m = jG(d))) : h = !1;
  }
  h && (l.set(d, m), a(m, d, r, s, l), l.delete(d)), U3(e, n, m);
}
function PG(e, t, n, r, a) {
  e !== t && _G(t, function(s, l) {
    if (a || (a = new Js()), mn(s))
      COe(e, t, l, n, PG, r, a);
    else {
      var c = r ? r(V3(e, l), s, l + "", e, t, a) : void 0;
      c === void 0 && (c = s), U3(e, l, c);
    }
  }, kk);
}
function OOe(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
var Cz = Math.max;
function DG(e, t, n) {
  return t = Cz(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var r = arguments, a = -1, s = Cz(r.length - t, 0), l = Array(s); ++a < s; )
      l[a] = r[t + a];
    a = -1;
    for (var c = Array(t + 1); ++a < t; )
      c[a] = r[a];
    return c[t] = n(l), OOe(e, this, c);
  };
}
function MOe(e) {
  return function() {
    return e;
  };
}
var NOe = B2 ? function(e, t) {
  return B2(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: MOe(t),
    writable: !0
  });
} : kC, AOe = 800, ROe = 16, jOe = Date.now;
function POe(e) {
  var t = 0, n = 0;
  return function() {
    var r = jOe(), a = ROe - (r - n);
    if (n = r, a > 0) {
      if (++t >= AOe)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
var IG = POe(NOe);
function _C(e, t) {
  return IG(DG(e, t, kC), e + "");
}
function DOe(e, t, n) {
  if (!mn(n))
    return !1;
  var r = typeof t;
  return (r == "number" ? nh(n) && wC(t, n.length) : r == "string" && t in n) ? yk(n[t], e) : !1;
}
function IOe(e) {
  return _C(function(t, n) {
    var r = -1, a = n.length, s = a > 1 ? n[a - 1] : void 0, l = a > 2 ? n[2] : void 0;
    for (s = e.length > 3 && typeof s == "function" ? (a--, s) : void 0, l && DOe(n[0], n[1], l) && (s = a < 3 ? void 0 : s, a = 1), t = Object(t); ++r < a; ) {
      var c = n[r];
      c && e(t, c, r, s);
    }
    return t;
  });
}
var $Oe = IOe(function(e, t, n) {
  PG(e, t, n);
}), Oz = Gi ? Gi.isConcatSpreadable : void 0;
function zOe(e) {
  return oo(e) || Og(e) || !!(Oz && e && e[Oz]);
}
function _k(e, t, n, r, a) {
  var s = -1, l = e.length;
  for (n || (n = zOe), a || (a = []); ++s < l; ) {
    var c = e[s];
    t > 0 && n(c) ? t > 1 ? _k(c, t - 1, n, r, a) : Rj(a, c) : r || (a[a.length] = c);
  }
  return a;
}
var TOe = 1 / 0;
function LOe(e) {
  var t = e == null ? 0 : e.length;
  return t ? _k(e, TOe) : [];
}
function FOe(e, t, n, r) {
  for (var a = e.length, s = n + -1; ++s < a; )
    if (t(e[s], s, e))
      return s;
  return -1;
}
function BOe(e) {
  return e !== e;
}
function UOe(e, t, n) {
  for (var r = n - 1, a = e.length; ++r < a; )
    if (e[r] === t)
      return r;
  return -1;
}
function $G(e, t, n) {
  return t === t ? UOe(e, t, n) : FOe(e, BOe, n);
}
function Wj(e, t) {
  var n = e == null ? 0 : e.length;
  return !!n && $G(e, t, 0) > -1;
}
function W_() {
}
var VOe = 1 / 0, HOe = sg && 1 / Aj(new sg([, -0]))[1] == VOe ? function(e) {
  return new sg(e);
} : W_, WOe = 200;
function zG(e, t, n) {
  var r = -1, a = Wj, s = e.length, l = !0, c = [], d = c;
  if (s >= WOe) {
    var f = HOe(e);
    if (f)
      return Aj(f);
    l = !1, a = SS, d = new Hm();
  } else
    d = c;
  e:
    for (; ++r < s; ) {
      var m = e[r], h = m;
      if (m = m !== 0 ? m : 0, l && h === h) {
        for (var v = d.length; v--; )
          if (d[v] === h)
            continue e;
        c.push(m);
      } else a(d, h, n) || (d !== c && d.push(h), c.push(m));
    }
  return c;
}
function TG(e) {
  return e && e.length ? zG(e) : [];
}
var qOe = "[object Map]", GOe = "[object Set]", KOe = Object.prototype, YOe = KOe.hasOwnProperty;
function $r(e) {
  if (e == null)
    return !0;
  if (nh(e) && (oo(e) || typeof e == "string" || typeof e.splice == "function" || Wm(e) || wk(e) || Og(e)))
    return !e.length;
  var t = Fi(e);
  if (t == qOe || t == GOe)
    return !e.size;
  if (xC(e))
    return !gG(e).length;
  for (var n in e)
    if (YOe.call(e, n))
      return !1;
  return !0;
}
const XOe = Object.prototype;
function Sx(e) {
  for (const t in e)
    if (XOe.hasOwnProperty.call(e, t))
      return !1;
  return !0;
}
const JOe = [
  "array",
  "boolean",
  "integer",
  "null",
  "number",
  "object",
  "string"
];
new Set(JOe);
const QOe = [
  "$defs",
  "definitions",
  "properties",
  "patternProperties",
  "dependencies"
];
new Set(QOe);
const ZOe = [
  "items",
  "allOf",
  "oneOf",
  "anyOf"
];
new Set(ZOe);
const eMe = [
  "items",
  "additionalItems",
  "additionalProperties",
  "propertyNames",
  "contains",
  "if",
  "then",
  "else",
  "not"
];
new Set(eMe);
function q_(e) {
  return typeof e == "object";
}
function wl(e) {
  return q_(e) ? Sx(e) : e === !0;
}
function qh(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function v5(e, t) {
  const n = e.length;
  if (n === 0)
    return t;
  let r = t.length;
  if (r === 0)
    return e;
  if (n < r) {
    const s = e;
    e = t, t = s, r = n;
  }
  const a = new Set(e);
  for (let s = 0; s < r; s++)
    a.add(t[s]);
  return Array.from(a);
}
function tMe(e, t) {
  const n = [];
  if (e.length === 0 || t.length === 0)
    return n;
  if (e.length > t.length) {
    const a = e;
    e = t, t = a;
  }
  const r = new Set(t);
  for (let a = 0; a < e.length && r.size > 0; a++) {
    const s = e[a];
    r.delete(s) && n.push(s);
  }
  return n;
}
function Mz(e) {
  return e.length === 0;
}
function y5(e) {
  return (t, n) => {
    const r = t.length - n.length;
    if (r !== 0)
      return r;
    for (let a = 0; a < t.length; a++)
      if (t[a] !== n[a]) {
        const s = e(t[a], n[a]);
        if (s !== 0)
          return s;
      }
    return 0;
  };
}
function LG(e, { threshold: t = 12 } = {}) {
  return (n) => {
    const r = n.length;
    if (r === 0)
      return n;
    if (r <= t) {
      const l = [];
      let c = 0;
      e: for (let d = 0; d < r; d++) {
        const f = n[d];
        for (let m = 0; m < c; m++)
          if (e(f, l[m]) === 0)
            continue e;
        c = l.push(f);
      }
      return l;
    }
    const a = n.slice().sort(e);
    let s = 0;
    for (let l = 1; l < r; l++)
      e(a[s], a[l]) !== 0 && ++s !== l && (a[s] = a[l]);
    return a.length = s + 1, a;
  };
}
function nMe(e) {
  return (t, n) => {
    const r = [];
    let a = t.length, s = n.length;
    if (a === 0 || s === 0)
      return r;
    if (a > s) {
      const m = t;
      t = n, n = m;
      const h = a;
      a = s, s = h;
    }
    const l = [...t].sort(e), c = [...n].sort(e);
    let d = 0, f = 0;
    for (; d < a && f < s; ) {
      const m = e(l[d], c[f]);
      m === 0 ? ((r.length === 0 || e(r[r.length - 1], l[d]) !== 0) && r.push(l[d]), d++, f++) : m < 0 ? d++ : f++;
    }
    return r;
  };
}
function rMe(e, t) {
  return (n) => {
    if (e.has(n))
      return e.get(n);
    const r = t(n);
    return e.set(n, r), r;
  };
}
const Nz = rMe, FG = () => 0, oMe = (e) => e === void 0, aMe = (e) => typeof e != "object", Az = {
  boolean: 0,
  number: 1,
  string: 2
};
function iMe(e, t) {
  const n = typeof e, r = typeof t;
  return n === r ? qh(e, t) : Az[n] - Az[r];
}
function sMe(e, t) {
  const n = e.length;
  if (n === 0)
    return t;
  const r = t.length;
  if (r === 0)
    return e;
  if (r > n) {
    const l = e;
    e = t, t = l;
  }
  const a = new Set(e), s = t.length;
  for (let l = 0; l < s; l++) {
    const c = t[l];
    a.has(c) || e.push(c);
  }
  return e;
}
function EC(e, t, n = FG) {
  return (r, a) => e(r) ? e(a) ? n(r, a) : -1 : e(a) ? 1 : t(r, a);
}
function Lh(e) {
  return EC(oMe, e);
}
function dd(e, t) {
  return EC((n) => n === void 0 || e(n), t);
}
function b5(e, t) {
  return EC(Array.isArray, e, t);
}
const jr = Lh(qh), w5 = dd((e) => e === 0, (e, t) => e - t);
function lMe({ deduplicationCache: e = /* @__PURE__ */ new WeakMap(), sortedKeysCache: t = /* @__PURE__ */ new WeakMap() } = {}) {
  const n = Nz(t, (x) => Object.keys(x).sort());
  function r(x) {
    return (w, k) => {
      const E = n(w), _ = n(k), O = Math.min(E.length, _.length);
      for (let N = 0; N < O; N++) {
        const A = qh(E[N], _[N]);
        if (A !== 0)
          return A;
      }
      if (E.length !== _.length)
        return E.length - _.length;
      for (let N = 0; N < O; N++) {
        const A = E[N], R = x(w[A], k[A]);
        if (R !== 0)
          return R;
      }
      return 0;
    };
  }
  function a(x) {
    const w = y5(x), k = Nz(
      e,
      // NOTE: Always sort output
      LG(x, { threshold: 0 })
    );
    return (E, _) => w(k(E), k(_));
  }
  const s = a(qh);
  function l(x, w) {
    if (q_(x)) {
      if (q_(w)) {
        const k = Object.keys(x), E = Object.keys(w), _ = sMe(k, E), O = _.length;
        for (let N = 0; N < O; N++) {
          const A = _[N];
          if (x[A] === w[A])
            continue;
          const R = (b[A] ?? c)(x[A], w[A]);
          if (R !== 0)
            return R;
        }
        return 0;
      }
      return w === !0 && Sx(x) ? 0 : 1;
    }
    return q_(w) ? x === !0 && Sx(w) ? 0 : -1 : qh(x, w);
  }
  const c = Lh(f), d = EC(aMe, b5(r(c), y5(f)), iMe);
  function f(x, w) {
    return x === null ? -1 : w === null ? 1 : d(x, w);
  }
  const m = Lh(l), h = dd(Sx, r(m)), v = Lh(a(l)), g = dd(wl, l), b = {
    $id: jr,
    $comment: jr,
    $defs: h,
    $ref: jr,
    $schema: jr,
    const: c,
    contains: m,
    contentEncoding: jr,
    contentMediaType: jr,
    default: c,
    definitions: h,
    description: jr,
    else: m,
    examples: c,
    exclusiveMaximum: jr,
    exclusiveMinimum: jr,
    format: jr,
    if: m,
    maximum: jr,
    maxItems: jr,
    maxLength: jr,
    maxProperties: jr,
    minimum: jr,
    multipleOf: jr,
    not: m,
    pattern: jr,
    propertyNames: m,
    readOnly: jr,
    then: m,
    title: jr,
    writeOnly: jr,
    uniqueItems: dd((x) => x === !1, FG),
    minLength: w5,
    minItems: w5,
    minProperties: w5,
    required: dd(Mz, s),
    enum: dd(Mz, a(f)),
    type: Lh((x, w) => {
      const k = Array.isArray(x), E = Array.isArray(w);
      return !k && !E ? qh(x, w) : s(k ? x : [x], E ? w : [w]);
    }),
    items: dd((x) => !Array.isArray(x) && wl(x), b5(l, y5(l))),
    anyOf: v,
    allOf: v,
    oneOf: v,
    properties: h,
    patternProperties: h,
    additionalProperties: g,
    additionalItems: g,
    dependencies: dd(Sx, r(Lh(b5(l, s))))
  };
  return {
    compareSchemaValues: f,
    compareSchemaDefinitions: l
  };
}
function Rz(e) {
  return e;
}
const BG = (e, t) => e ? BG(t % e, e) : t, uMe = (e, t) => Math.abs(e * t) / BG(e, t);
function cMe(e, t) {
  return e === t ? e : `^(?=.*(?:${e}))(?=.*(?:${t})).*$`;
}
function* x5(e, t, n) {
  const r = e.length, a = t.length;
  if (r > 0 && a > 0)
    for (let s = 0; s < r; s++) {
      const l = e[s];
      for (let c = 0; c < a; c++)
        yield n(l, t[c]);
    }
}
function S5(e, t) {
  return e || t;
}
function jz(e) {
  return (t, n) => {
    const r = { ...t }, a = Object.keys(n), s = a.length;
    for (let l = 0; l < s; l++) {
      const c = a[l];
      r[c] = t[c] === void 0 ? n[c] : e(t[c], n[c]);
    }
    return r;
  };
}
function dMe(e) {
  const t = /* @__PURE__ */ new Map();
  for (const n of e)
    for (const r of n[0])
      t.set(r, n[1]);
  return t;
}
function dm(e, t, n) {
  n === void 0 || wl(n) ? delete e[t] : e[t] = n;
}
const fMe = [
  "properties",
  "patternProperties",
  "additionalProperties"
];
function Pz(e) {
  const t = Object.keys(e), n = t.length, r = [];
  for (let a = 0; a < n; a++) {
    const s = t[a];
    r.push({
      regExp: new RegExp(s),
      schema: e[s]
    });
  }
  return [r, t];
}
const Dz = [[], []];
function Iz(e, t, n) {
  const r = n.length;
  for (let a = 0; a < r; a++) {
    const s = n[a];
    if (!s.regExp.test(t))
      continue;
    const l = s.schema;
    if (l === !1)
      return !0;
    e.push(l);
  }
  return !1;
}
const pMe = [
  "items",
  "additionalItems"
], mMe = [
  "if",
  "then",
  "else"
];
function $z(e, t) {
  return t.if !== void 0 && (e.if = t.if), t.then !== void 0 && (e.then = t.then), t.else !== void 0 && (e.else = t.else), e;
}
function k5(e, t) {
  if (e === t)
    return e;
  switch (e) {
    case "number":
      if (t === "integer")
        return "integer";
    // eslint-disable-next-line no-fallthrough
    case "integer":
      if (t === "number")
        return "integer";
    // eslint-disable-next-line no-fallthrough
    default:
      return;
  }
}
function fm(e, t, n) {
  return [e, t, n];
}
function hMe(e) {
  const t = /* @__PURE__ */ new Map();
  for (const [n, r, a] of e) {
    const s = (l) => {
      if (!a(l))
        throw new Error(`Schema keys '${n}' and '${r}' are conflicting (${n}: ${JSON.stringify(l[n])}, ${r}: ${JSON.stringify(l[r])})`);
    };
    for (const l of [
      [n, r],
      [r, n]
    ]) {
      let c = t.get(l[0]);
      c === void 0 && (c = [], t.set(l[0], c)), c.push({ oppositeKey: l[1], check: s });
    }
  }
  return t;
}
const gMe = [
  fm("minimum", "maximum", (e) => e.maximum >= e.minimum),
  fm("exclusiveMinimum", "maximum", (e) => e.maximum > e.exclusiveMinimum),
  fm("minimum", "exclusiveMaximum", (e) => e.exclusiveMaximum > e.minimum),
  fm("exclusiveMinimum", "exclusiveMaximum", (e) => e.exclusiveMaximum > e.exclusiveMinimum),
  fm("minLength", "maxLength", (e) => e.maxLength >= e.minLength),
  fm("minItems", "maxItems", (e) => e.maxItems >= e.minItems),
  fm("minProperties", "maxProperties", (e) => e.maxProperties >= e.minProperties)
];
function vMe({ mergePatterns: e = cMe, isSubRegExp: t = Object.is, intersectJson: n = tMe, deduplicateJsonSchemaDef: r = Rz, defaultMerger: a = Rz, assigners: s = [], checks: l = gMe, mergers: c } = {}) {
  function d(O) {
    const N = O.length;
    let A = O[0];
    for (let R = 1; R < N; R++) {
      const D = k(A, O[R]);
      if (D === !1)
        return !1;
      wl(D) || (A = D);
    }
    return A;
  }
  function f(O, N, A, R, D, I, z) {
    if (O.length = 0, A === !1)
      return !1;
    if (O.push(A), D !== void 0) {
      if (D === !1)
        return !1;
      O.push(D);
    }
    if (Iz(O, N, I))
      return !1;
    const B = O.length < 2;
    if (z === !1) {
      if (B)
        return;
      if (Iz(O, N, R))
        return !1;
    } else B && z !== void 0 && O.push(z);
    return O.length === 1 ? O[0] : d(O);
  }
  function m(O, N, A, R, D, I) {
    const z = A.length;
    if (z > 0 && D !== !1)
      if (I)
        Object.assign(O, N);
      else
        for (let B = 0; B < z; B++) {
          const P = A[B];
          R.has(P) || (O[P] = k(N[P], D));
        }
    return O;
  }
  const h = (O, { properties: N = {}, patternProperties: A, additionalProperties: R = !0 }, { properties: D = {}, patternProperties: I, additionalProperties: z = !0 }) => {
    const B = wl(R), P = wl(z);
    if (B && P)
      return dm(O, "properties", E(N, D)), dm(O, "patternProperties", A && I ? E(A, I) : A ?? I), delete O.additionalProperties, O;
    const H = k(R, z);
    dm(O, "additionalProperties", H);
    const L = {}, G = Object.keys(N), $ = G.length, [K, q] = A ? Pz(A) : Dz, [Z, V] = I ? Pz(I) : Dz, F = [], Y = /* @__PURE__ */ new Set(), U = P ? void 0 : z;
    for (let ce = 0; ce < $; ce++) {
      const ge = G[ce];
      Y.add(ge);
      const re = f(F, ge, N[ge], K, D[ge], Z, U);
      re !== void 0 && (L[ge] = re);
    }
    const W = Object.keys(D), J = W.length, oe = B ? void 0 : R;
    for (let ce = 0; ce < J; ce++) {
      const ge = W[ce];
      if (Y.has(ge))
        continue;
      const re = f(F, ge, D[ge], Z, void 0, K, oe);
      re !== void 0 && (L[ge] = re);
    }
    dm(O, "properties", L);
    let fe = {};
    const ie = /* @__PURE__ */ new Set();
    if (q.length > 0 && V.length > 0) {
      const ce = x5(q, V, (ge, re) => {
        t(ge, re) && ie.add(ge), t(re, ge) && ie.add(re), fe[e(ge, re)] = k(A[ge], I[re]);
      });
      for (; !ce.next().done; )
        ;
    }
    return fe = m(fe, A, q, ie, z, P), fe = m(fe, I, V, ie, R, B), dm(O, "patternProperties", fe), O;
  }, v = (O, { items: N = [], additionalItems: A }, { items: R = [], additionalItems: D }) => {
    const I = Array.isArray(N), z = Array.isArray(R), B = [];
    if (O.items = B, I && z) {
      const [P, H, L] = N.length < R.length ? [N.length, A, R] : [R.length, D, N];
      let G = 0;
      for (; G < P; G++)
        B.push(k(N[G], R[G]));
      if (H === !1)
        O.additionalItems = !1;
      else {
        const $ = H === void 0 || wl(H);
        for (; G < L.length; G++)
          B.push($ ? L[G] : k(L[G], H));
        dm(O, "additionalItems", A !== void 0 && D !== void 0 ? k(A, D) : A ?? D);
      }
    } else if (I || z) {
      const [P, H, L] = I ? [N, R, A] : [R, N, D];
      dm(O, "additionalItems", L && k(L, H));
      for (let G = 0; G < P.length; G++)
        B.push(k(P[G], H));
    } else
      delete O.additionalItems, O.items = k(N, R);
    return O;
  }, g = (O, N, A) => {
    $z(O, N);
    const R = $z({}, A);
    return O.allOf === void 0 ? O.allOf = [R] : O.allOf = O.allOf.concat(R), O;
  };
  function b(O, N) {
    return r(Array.from(x5(O, N, k)));
  }
  const x = dMe([
    [fMe, h],
    [pMe, v],
    [mMe, g],
    ...s
  ]), w = hMe(l);
  function k(O, N) {
    if (O === !1 || N === !1)
      return !1;
    if (wl(O))
      return wl(N) ? !0 : N;
    if (wl(N))
      return O;
    let A = { ...O };
    const R = /* @__PURE__ */ new Set(), D = /* @__PURE__ */ new Set(), I = Object.keys(N), z = I.length;
    for (let B = 0; B < z; B++) {
      const P = I[B], H = N[P];
      if (H === void 0)
        continue;
      const L = w.get(P);
      if (L !== void 0) {
        const q = L.length;
        for (let Z = 0; Z < q; Z++) {
          const V = L[Z];
          O[V.oppositeKey] !== void 0 && D.add(V.check);
        }
      }
      const G = O[P];
      if (G === void 0) {
        A[P] = H;
        continue;
      }
      const $ = x.get(P);
      if ($) {
        R.add($);
        continue;
      }
      const K = _[P] ?? a;
      A[P] = K(G, H);
    }
    for (const B of R)
      A = B(A, O, N);
    for (const B of D)
      B(A);
    return A;
  }
  const E = jz(k), _ = {
    $id: a,
    $ref: a,
    $schema: a,
    $comment: a,
    $defs: E,
    definitions: E,
    type: (O, N) => {
      if (O === N)
        return O;
      const A = Array.isArray(O), R = Array.isArray(N);
      if (!A && !R) {
        const D = k5(O, N);
        if (D !== void 0)
          return D;
      } else if (A || R) {
        const D = /* @__PURE__ */ new Set();
        if (A && R)
          for (const z of x5(O, N, k5))
            z !== void 0 && D.add(z);
        else {
          const z = A ? O : N, B = A ? N : O, P = z.length;
          for (let H = 0; H < P; H++) {
            const L = k5(B, z[H]);
            L !== void 0 && D.add(L);
          }
        }
        const I = D.size;
        if (I === 1)
          return D.values().next().value;
        if (I > 1)
          return Array.from(D);
      }
      throw new Error(`It is not possible to create an intersection of the following incompatible types: ${O.toString()}, ${N.toString()}`);
    },
    default: a,
    description: a,
    title: a,
    const: a,
    format: a,
    contentEncoding: a,
    contentMediaType: a,
    not: (O, N) => {
      const A = r([O, N]);
      return A.length === 1 ? A[0] : { anyOf: A };
    },
    pattern: e,
    readOnly: S5,
    writeOnly: S5,
    enum: (O, N) => {
      const A = n(O, N);
      if (A.length === 0)
        throw new Error(`Intersection of the following enums is empty: "${JSON.stringify(O)}", "${JSON.stringify(N)}"`);
      return A;
    },
    anyOf: b,
    oneOf: b,
    allOf: (O, N) => r(O.concat(N)),
    propertyNames: k,
    contains: k,
    dependencies: jz((O, N) => Array.isArray(O) ? Array.isArray(N) ? v5(O, N) : k(N, { required: O }) : Array.isArray(N) ? k(O, { required: N }) : k(O, N)),
    examples: (O, N) => {
      if (!Array.isArray(O) || !Array.isArray(N))
        throw new Error(`Value of the 'examples' field should be an array, but got "${JSON.stringify(O)}" and "${JSON.stringify(N)}"`);
      return v5(O, N);
    },
    multipleOf: (O, N) => {
      let A = 1;
      for (; !Number.isInteger(O) || !Number.isInteger(N); )
        A *= 10, O *= 10, N *= 10;
      return uMe(O, N) / A;
    },
    exclusiveMaximum: Math.min,
    maximum: Math.min,
    maxItems: Math.min,
    maxLength: Math.min,
    maxProperties: Math.min,
    exclusiveMinimum: Math.max,
    minimum: Math.max,
    minItems: Math.max,
    minLength: Math.max,
    minProperties: Math.max,
    uniqueItems: S5,
    required: v5,
    ...c
  };
  return {
    mergeSchemaDefinitions: k,
    mergeArrayOfSchemaDefinitions: d
  };
}
function yMe(e) {
  const t = [], n = [e];
  for (; n.length > 0; ) {
    const r = n.pop();
    if (typeof r == "boolean" || r.allOf === void 0) {
      t.push(r);
      continue;
    }
    const { allOf: a, ...s } = r;
    t.push(s);
    for (let l = a.length - 1; l >= 0; l--)
      n.push(a[l]);
  }
  return t;
}
function bMe(e) {
  return (t) => e(yMe(t));
}
var Zw = {}, zz;
function wMe() {
  if (zz) return Zw;
  zz = 1;
  var e = /~/, t = /~[01]/g;
  function n(f) {
    switch (f) {
      case "~1":
        return "/";
      case "~0":
        return "~";
    }
    throw new Error("Invalid tilde escape: " + f);
  }
  function r(f) {
    return e.test(f) ? f.replace(t, n) : f;
  }
  function a(f, m, h) {
    for (var v, g, b = 1, x = m.length; b < x; ) {
      if (m[b] === "constructor" || m[b] === "prototype" || m[b] === "__proto__") return f;
      if (v = r(m[b++]), g = x > b, typeof f[v] > "u" && (Array.isArray(f) && v === "-" && (v = f.length), g && (m[b] !== "" && m[b] < 1 / 0 || m[b] === "-" ? f[v] = [] : f[v] = {})), !g) break;
      f = f[v];
    }
    var w = f[v];
    return h === void 0 ? delete f[v] : f[v] = h, w;
  }
  function s(f) {
    if (typeof f == "string") {
      if (f = f.split("/"), f[0] === "") return f;
      throw new Error("Invalid JSON pointer.");
    } else if (Array.isArray(f)) {
      for (const m of f)
        if (typeof m != "string" && typeof m != "number")
          throw new Error("Invalid JSON pointer. Must be of type string or number.");
      return f;
    }
    throw new Error("Invalid JSON pointer.");
  }
  function l(f, m) {
    if (typeof f != "object") throw new Error("Invalid input object.");
    m = s(m);
    var h = m.length;
    if (h === 1) return f;
    for (var v = 1; v < h; ) {
      if (f = f[r(m[v++])], h === v) return f;
      if (typeof f != "object" || f === null) return;
    }
  }
  function c(f, m, h) {
    if (typeof f != "object") throw new Error("Invalid input object.");
    if (m = s(m), m.length === 0) throw new Error("Invalid JSON pointer for set.");
    return a(f, m, h);
  }
  function d(f) {
    var m = s(f);
    return {
      get: function(h) {
        return l(h, m);
      },
      set: function(h, v) {
        return c(h, m, v);
      }
    };
  }
  return Zw.get = l, Zw.set = c, Zw.compile = d, Zw;
}
var xMe = wMe();
const _5 = /* @__PURE__ */ Gc(xMe);
function SMe(e, t) {
  return e && Gg(t, qs(t), e);
}
function kMe(e, t) {
  return e && Gg(t, kk(t), e);
}
function _Me(e, t) {
  return Gg(e, jj(e), t);
}
var EMe = Object.getOwnPropertySymbols, UG = EMe ? function(e) {
  for (var t = []; e; )
    Rj(t, jj(e)), e = vC(e);
  return t;
} : cG;
function CMe(e, t) {
  return Gg(e, UG(e), t);
}
function qj(e) {
  return uG(e, kk, UG);
}
var OMe = Object.prototype, MMe = OMe.hasOwnProperty;
function NMe(e) {
  var t = e.length, n = new e.constructor(t);
  return t && typeof e[0] == "string" && MMe.call(e, "index") && (n.index = e.index, n.input = e.input), n;
}
function AMe(e, t) {
  var n = t ? Vj(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.byteLength);
}
var RMe = /\w*$/;
function jMe(e) {
  var t = new e.constructor(e.source, RMe.exec(e));
  return t.lastIndex = e.lastIndex, t;
}
var Tz = Gi ? Gi.prototype : void 0, Lz = Tz ? Tz.valueOf : void 0;
function PMe(e) {
  return Lz ? Object(Lz.call(e)) : {};
}
var DMe = "[object Boolean]", IMe = "[object Date]", $Me = "[object Map]", zMe = "[object Number]", TMe = "[object RegExp]", LMe = "[object Set]", FMe = "[object String]", BMe = "[object Symbol]", UMe = "[object ArrayBuffer]", VMe = "[object DataView]", HMe = "[object Float32Array]", WMe = "[object Float64Array]", qMe = "[object Int8Array]", GMe = "[object Int16Array]", KMe = "[object Int32Array]", YMe = "[object Uint8Array]", XMe = "[object Uint8ClampedArray]", JMe = "[object Uint16Array]", QMe = "[object Uint32Array]";
function ZMe(e, t, n) {
  var r = e.constructor;
  switch (t) {
    case UMe:
      return Vj(e);
    case DMe:
    case IMe:
      return new r(+e);
    case VMe:
      return AMe(e, n);
    case HMe:
    case WMe:
    case qMe:
    case GMe:
    case KMe:
    case YMe:
    case XMe:
    case JMe:
    case QMe:
      return RG(e, n);
    case $Me:
      return new r();
    case zMe:
    case FMe:
      return new r(e);
    case TMe:
      return jMe(e);
    case LMe:
      return new r();
    case BMe:
      return PMe(e);
  }
}
var eNe = "[object Map]";
function tNe(e) {
  return Ki(e) && Fi(e) == eNe;
}
var Fz = Mg && Mg.isMap, nNe = Fz ? Dj(Fz) : tNe, rNe = "[object Set]";
function oNe(e) {
  return Ki(e) && Fi(e) == rNe;
}
var Bz = Mg && Mg.isSet, aNe = Bz ? Dj(Bz) : oNe, iNe = 1, sNe = 2, lNe = 4, VG = "[object Arguments]", uNe = "[object Array]", cNe = "[object Boolean]", dNe = "[object Date]", fNe = "[object Error]", HG = "[object Function]", pNe = "[object GeneratorFunction]", mNe = "[object Map]", hNe = "[object Number]", WG = "[object Object]", gNe = "[object RegExp]", vNe = "[object Set]", yNe = "[object String]", bNe = "[object Symbol]", wNe = "[object WeakMap]", xNe = "[object ArrayBuffer]", SNe = "[object DataView]", kNe = "[object Float32Array]", _Ne = "[object Float64Array]", ENe = "[object Int8Array]", CNe = "[object Int16Array]", ONe = "[object Int32Array]", MNe = "[object Uint8Array]", NNe = "[object Uint8ClampedArray]", ANe = "[object Uint16Array]", RNe = "[object Uint32Array]", Qn = {};
Qn[VG] = Qn[uNe] = Qn[xNe] = Qn[SNe] = Qn[cNe] = Qn[dNe] = Qn[kNe] = Qn[_Ne] = Qn[ENe] = Qn[CNe] = Qn[ONe] = Qn[mNe] = Qn[hNe] = Qn[WG] = Qn[gNe] = Qn[vNe] = Qn[yNe] = Qn[bNe] = Qn[MNe] = Qn[NNe] = Qn[ANe] = Qn[RNe] = !0;
Qn[fNe] = Qn[HG] = Qn[wNe] = !1;
function Tx(e, t, n, r, a, s) {
  var l, c = t & iNe, d = t & sNe, f = t & lNe;
  if (n && (l = a ? n(e, r, a, s) : n(e)), l !== void 0)
    return l;
  if (!mn(e))
    return e;
  var m = oo(e);
  if (m) {
    if (l = NMe(e), !c)
      return Hj(e, l);
  } else {
    var h = Fi(e), v = h == HG || h == pNe;
    if (Wm(e))
      return AG(e, c);
    if (h == WG || h == VG || v && !a) {
      if (l = d || v ? {} : jG(e), !c)
        return d ? CMe(e, kMe(l, e)) : _Me(e, SMe(l, e));
    } else {
      if (!Qn[h])
        return a ? e : {};
      l = ZMe(e, h, c);
    }
  }
  s || (s = new Js());
  var g = s.get(e);
  if (g)
    return g;
  s.set(e, l), aNe(e) ? e.forEach(function(w) {
    l.add(Tx(w, t, n, w, e, s));
  }) : nNe(e) && e.forEach(function(w, k) {
    l.set(k, Tx(w, t, n, k, e, s));
  });
  var b = f ? d ? qj : T3 : d ? kk : qs, x = m ? void 0 : b(e);
  return Bj(x || e, function(w, k) {
    x && (k = w, w = e[k]), Lj(l, k, Tx(w, t, n, k, e, s));
  }), l;
}
function qG(e) {
  var t = e == null ? 0 : e.length;
  return t ? e[t - 1] : void 0;
}
function jNe(e, t, n) {
  var r = -1, a = e.length;
  t < 0 && (t = -t > a ? 0 : a + t), n = n > a ? a : n, n < 0 && (n += a), a = t > n ? 0 : n - t >>> 0, t >>>= 0;
  for (var s = Array(a); ++r < a; )
    s[r] = e[r + t];
  return s;
}
function PNe(e, t) {
  return t.length < 2 ? e : SC(e, jNe(t, 0, -1));
}
function GG(e, t) {
  return t = qg(t, e), e = PNe(e, t), e == null || delete e[rh(qG(t))];
}
function DNe(e) {
  return Id(e) ? void 0 : e;
}
function H3(e) {
  var t = e == null ? 0 : e.length;
  return t ? _k(e, 1) : [];
}
function KG(e) {
  return IG(DG(e, void 0, H3), e + "");
}
var INe = 1, $Ne = 2, zNe = 4, ES = KG(function(e, t) {
  var n = {};
  if (e == null)
    return n;
  var r = !1;
  t = Wg(t, function(s) {
    return s = qg(s, e), r || (r = s.length > 1), s;
  }), Gg(e, qj(e), n), r && (n = Tx(n, INe | $Ne | zNe, DNe));
  for (var a = t.length; a--; )
    GG(n, t[a]);
  return n;
}), ex = { exports: {} }, E5, Uz;
function YG() {
  if (Uz) return E5;
  Uz = 1;
  const e = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu), t = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
  function n(v) {
    let g = "", b = 0, x = 0;
    for (x = 0; x < v.length; x++)
      if (b = v[x].charCodeAt(0), b !== 48) {
        if (!(b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102))
          return "";
        g += v[x];
        break;
      }
    for (x += 1; x < v.length; x++) {
      if (b = v[x].charCodeAt(0), !(b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102))
        return "";
      g += v[x];
    }
    return g;
  }
  const r = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
  function a(v) {
    return v.length = 0, !0;
  }
  function s(v, g, b) {
    if (v.length) {
      const x = n(v);
      if (x !== "")
        g.push(x);
      else
        return b.error = !0, !1;
      v.length = 0;
    }
    return !0;
  }
  function l(v) {
    let g = 0;
    const b = { error: !1, address: "", zone: "" }, x = [], w = [];
    let k = !1, E = !1, _ = s;
    for (let O = 0; O < v.length; O++) {
      const N = v[O];
      if (!(N === "[" || N === "]"))
        if (N === ":") {
          if (k === !0 && (E = !0), !_(w, x, b))
            break;
          if (++g > 7) {
            b.error = !0;
            break;
          }
          O > 0 && v[O - 1] === ":" && (k = !0), x.push(":");
          continue;
        } else if (N === "%") {
          if (!_(w, x, b))
            break;
          _ = a;
        } else {
          w.push(N);
          continue;
        }
    }
    return w.length && (_ === a ? b.zone = w.join("") : E ? x.push(w.join("")) : x.push(n(w))), b.address = x.join(""), b;
  }
  function c(v) {
    if (d(v, ":") < 2)
      return { host: v, isIPV6: !1 };
    const g = l(v);
    if (g.error)
      return { host: v, isIPV6: !1 };
    {
      let b = g.address, x = g.address;
      return g.zone && (b += "%" + g.zone, x += "%25" + g.zone), { host: b, isIPV6: !0, escapedHost: x };
    }
  }
  function d(v, g) {
    let b = 0;
    for (let x = 0; x < v.length; x++)
      v[x] === g && b++;
    return b;
  }
  function f(v) {
    let g = v;
    const b = [];
    let x = -1, w = 0;
    for (; w = g.length; ) {
      if (w === 1) {
        if (g === ".")
          break;
        if (g === "/") {
          b.push("/");
          break;
        } else {
          b.push(g);
          break;
        }
      } else if (w === 2) {
        if (g[0] === ".") {
          if (g[1] === ".")
            break;
          if (g[1] === "/") {
            g = g.slice(2);
            continue;
          }
        } else if (g[0] === "/" && (g[1] === "." || g[1] === "/")) {
          b.push("/");
          break;
        }
      } else if (w === 3 && g === "/..") {
        b.length !== 0 && b.pop(), b.push("/");
        break;
      }
      if (g[0] === ".") {
        if (g[1] === ".") {
          if (g[2] === "/") {
            g = g.slice(3);
            continue;
          }
        } else if (g[1] === "/") {
          g = g.slice(2);
          continue;
        }
      } else if (g[0] === "/" && g[1] === ".") {
        if (g[2] === "/") {
          g = g.slice(2);
          continue;
        } else if (g[2] === "." && g[3] === "/") {
          g = g.slice(3), b.length !== 0 && b.pop();
          continue;
        }
      }
      if ((x = g.indexOf("/", 1)) === -1) {
        b.push(g);
        break;
      } else
        b.push(g.slice(0, x)), g = g.slice(x);
    }
    return b.join("");
  }
  function m(v, g) {
    const b = g !== !0 ? escape : unescape;
    return v.scheme !== void 0 && (v.scheme = b(v.scheme)), v.userinfo !== void 0 && (v.userinfo = b(v.userinfo)), v.host !== void 0 && (v.host = b(v.host)), v.path !== void 0 && (v.path = b(v.path)), v.query !== void 0 && (v.query = b(v.query)), v.fragment !== void 0 && (v.fragment = b(v.fragment)), v;
  }
  function h(v) {
    const g = [];
    if (v.userinfo !== void 0 && (g.push(v.userinfo), g.push("@")), v.host !== void 0) {
      let b = unescape(v.host);
      if (!t(b)) {
        const x = c(b);
        x.isIPV6 === !0 ? b = `[${x.escapedHost}]` : b = v.host;
      }
      g.push(b);
    }
    return (typeof v.port == "number" || typeof v.port == "string") && (g.push(":"), g.push(String(v.port))), g.length ? g.join("") : void 0;
  }
  return E5 = {
    nonSimpleDomain: r,
    recomposeAuthority: h,
    normalizeComponentEncoding: m,
    removeDotSegments: f,
    isIPv4: t,
    isUUID: e,
    normalizeIPv6: c,
    stringArrayToHexStripped: n
  }, E5;
}
var C5, Vz;
function TNe() {
  if (Vz) return C5;
  Vz = 1;
  const { isUUID: e } = YG(), t = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu, n = (
    /** @type {const} */
    [
      "http",
      "https",
      "ws",
      "wss",
      "urn",
      "urn:uuid"
    ]
  );
  function r(_) {
    return n.indexOf(
      /** @type {*} */
      _
    ) !== -1;
  }
  function a(_) {
    return _.secure === !0 ? !0 : _.secure === !1 ? !1 : _.scheme ? _.scheme.length === 3 && (_.scheme[0] === "w" || _.scheme[0] === "W") && (_.scheme[1] === "s" || _.scheme[1] === "S") && (_.scheme[2] === "s" || _.scheme[2] === "S") : !1;
  }
  function s(_) {
    return _.host || (_.error = _.error || "HTTP URIs must have a host."), _;
  }
  function l(_) {
    const O = String(_.scheme).toLowerCase() === "https";
    return (_.port === (O ? 443 : 80) || _.port === "") && (_.port = void 0), _.path || (_.path = "/"), _;
  }
  function c(_) {
    return _.secure = a(_), _.resourceName = (_.path || "/") + (_.query ? "?" + _.query : ""), _.path = void 0, _.query = void 0, _;
  }
  function d(_) {
    if ((_.port === (a(_) ? 443 : 80) || _.port === "") && (_.port = void 0), typeof _.secure == "boolean" && (_.scheme = _.secure ? "wss" : "ws", _.secure = void 0), _.resourceName) {
      const [O, N] = _.resourceName.split("?");
      _.path = O && O !== "/" ? O : void 0, _.query = N, _.resourceName = void 0;
    }
    return _.fragment = void 0, _;
  }
  function f(_, O) {
    if (!_.path)
      return _.error = "URN can not be parsed", _;
    const N = _.path.match(t);
    if (N) {
      const A = O.scheme || _.scheme || "urn";
      _.nid = N[1].toLowerCase(), _.nss = N[2];
      const R = `${A}:${O.nid || _.nid}`, D = E(R);
      _.path = void 0, D && (_ = D.parse(_, O));
    } else
      _.error = _.error || "URN can not be parsed.";
    return _;
  }
  function m(_, O) {
    if (_.nid === void 0)
      throw new Error("URN without nid cannot be serialized");
    const N = O.scheme || _.scheme || "urn", A = _.nid.toLowerCase(), R = `${N}:${O.nid || A}`, D = E(R);
    D && (_ = D.serialize(_, O));
    const I = _, z = _.nss;
    return I.path = `${A || O.nid}:${z}`, O.skipEscape = !0, I;
  }
  function h(_, O) {
    const N = _;
    return N.uuid = N.nss, N.nss = void 0, !O.tolerant && (!N.uuid || !e(N.uuid)) && (N.error = N.error || "UUID is not valid."), N;
  }
  function v(_) {
    const O = _;
    return O.nss = (_.uuid || "").toLowerCase(), O;
  }
  const g = (
    /** @type {SchemeHandler} */
    {
      scheme: "http",
      domainHost: !0,
      parse: s,
      serialize: l
    }
  ), b = (
    /** @type {SchemeHandler} */
    {
      scheme: "https",
      domainHost: g.domainHost,
      parse: s,
      serialize: l
    }
  ), x = (
    /** @type {SchemeHandler} */
    {
      scheme: "ws",
      domainHost: !0,
      parse: c,
      serialize: d
    }
  ), w = (
    /** @type {SchemeHandler} */
    {
      scheme: "wss",
      domainHost: x.domainHost,
      parse: x.parse,
      serialize: x.serialize
    }
  ), k = (
    /** @type {Record<SchemeName, SchemeHandler>} */
    {
      http: g,
      https: b,
      ws: x,
      wss: w,
      urn: (
        /** @type {SchemeHandler} */
        {
          scheme: "urn",
          parse: f,
          serialize: m,
          skipNormalize: !0
        }
      ),
      "urn:uuid": (
        /** @type {SchemeHandler} */
        {
          scheme: "urn:uuid",
          parse: h,
          serialize: v,
          skipNormalize: !0
        }
      )
    }
  );
  Object.setPrototypeOf(k, null);
  function E(_) {
    return _ && (k[
      /** @type {SchemeName} */
      _
    ] || k[
      /** @type {SchemeName} */
      _.toLowerCase()
    ]) || void 0;
  }
  return C5 = {
    wsIsSecure: a,
    SCHEMES: k,
    isValidSchemeName: r,
    getSchemeHandler: E
  }, C5;
}
var Hz;
function LNe() {
  if (Hz) return ex.exports;
  Hz = 1;
  const { normalizeIPv6: e, removeDotSegments: t, recomposeAuthority: n, normalizeComponentEncoding: r, isIPv4: a, nonSimpleDomain: s } = YG(), { SCHEMES: l, getSchemeHandler: c } = TNe();
  function d(w, k) {
    return typeof w == "string" ? w = /** @type {T} */
    v(b(w, k), k) : typeof w == "object" && (w = /** @type {T} */
    b(v(w, k), k)), w;
  }
  function f(w, k, E) {
    const _ = E ? Object.assign({ scheme: "null" }, E) : { scheme: "null" }, O = m(b(w, _), b(k, _), _, !0);
    return _.skipEscape = !0, v(O, _);
  }
  function m(w, k, E, _) {
    const O = {};
    return _ || (w = b(v(w, E), E), k = b(v(k, E), E)), E = E || {}, !E.tolerant && k.scheme ? (O.scheme = k.scheme, O.userinfo = k.userinfo, O.host = k.host, O.port = k.port, O.path = t(k.path || ""), O.query = k.query) : (k.userinfo !== void 0 || k.host !== void 0 || k.port !== void 0 ? (O.userinfo = k.userinfo, O.host = k.host, O.port = k.port, O.path = t(k.path || ""), O.query = k.query) : (k.path ? (k.path[0] === "/" ? O.path = t(k.path) : ((w.userinfo !== void 0 || w.host !== void 0 || w.port !== void 0) && !w.path ? O.path = "/" + k.path : w.path ? O.path = w.path.slice(0, w.path.lastIndexOf("/") + 1) + k.path : O.path = k.path, O.path = t(O.path)), O.query = k.query) : (O.path = w.path, k.query !== void 0 ? O.query = k.query : O.query = w.query), O.userinfo = w.userinfo, O.host = w.host, O.port = w.port), O.scheme = w.scheme), O.fragment = k.fragment, O;
  }
  function h(w, k, E) {
    return typeof w == "string" ? (w = unescape(w), w = v(r(b(w, E), !0), { ...E, skipEscape: !0 })) : typeof w == "object" && (w = v(r(w, !0), { ...E, skipEscape: !0 })), typeof k == "string" ? (k = unescape(k), k = v(r(b(k, E), !0), { ...E, skipEscape: !0 })) : typeof k == "object" && (k = v(r(k, !0), { ...E, skipEscape: !0 })), w.toLowerCase() === k.toLowerCase();
  }
  function v(w, k) {
    const E = {
      host: w.host,
      scheme: w.scheme,
      userinfo: w.userinfo,
      port: w.port,
      path: w.path,
      query: w.query,
      nid: w.nid,
      nss: w.nss,
      uuid: w.uuid,
      fragment: w.fragment,
      reference: w.reference,
      resourceName: w.resourceName,
      secure: w.secure,
      error: ""
    }, _ = Object.assign({}, k), O = [], N = c(_.scheme || E.scheme);
    N && N.serialize && N.serialize(E, _), E.path !== void 0 && (_.skipEscape ? E.path = unescape(E.path) : (E.path = escape(E.path), E.scheme !== void 0 && (E.path = E.path.split("%3A").join(":")))), _.reference !== "suffix" && E.scheme && O.push(E.scheme, ":");
    const A = n(E);
    if (A !== void 0 && (_.reference !== "suffix" && O.push("//"), O.push(A), E.path && E.path[0] !== "/" && O.push("/")), E.path !== void 0) {
      let R = E.path;
      !_.absolutePath && (!N || !N.absolutePath) && (R = t(R)), A === void 0 && R[0] === "/" && R[1] === "/" && (R = "/%2F" + R.slice(2)), O.push(R);
    }
    return E.query !== void 0 && O.push("?", E.query), E.fragment !== void 0 && O.push("#", E.fragment), O.join("");
  }
  const g = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function b(w, k) {
    const E = Object.assign({}, k), _ = {
      scheme: void 0,
      userinfo: void 0,
      host: "",
      port: void 0,
      path: "",
      query: void 0,
      fragment: void 0
    };
    let O = !1;
    E.reference === "suffix" && (E.scheme ? w = E.scheme + ":" + w : w = "//" + w);
    const N = w.match(g);
    if (N) {
      if (_.scheme = N[1], _.userinfo = N[3], _.host = N[4], _.port = parseInt(N[5], 10), _.path = N[6] || "", _.query = N[7], _.fragment = N[8], isNaN(_.port) && (_.port = N[5]), _.host)
        if (a(_.host) === !1) {
          const R = e(_.host);
          _.host = R.host.toLowerCase(), O = R.isIPV6;
        } else
          O = !0;
      _.scheme === void 0 && _.userinfo === void 0 && _.host === void 0 && _.port === void 0 && _.query === void 0 && !_.path ? _.reference = "same-document" : _.scheme === void 0 ? _.reference = "relative" : _.fragment === void 0 ? _.reference = "absolute" : _.reference = "uri", E.reference && E.reference !== "suffix" && E.reference !== _.reference && (_.error = _.error || "URI is not a " + E.reference + " reference.");
      const A = c(E.scheme || _.scheme);
      if (!E.unicodeSupport && (!A || !A.unicodeSupport) && _.host && (E.domainHost || A && A.domainHost) && O === !1 && s(_.host))
        try {
          _.host = URL.domainToASCII(_.host.toLowerCase());
        } catch (R) {
          _.error = _.error || "Host's domain name can not be converted to ASCII: " + R;
        }
      (!A || A && !A.skipNormalize) && (w.indexOf("%") !== -1 && (_.scheme !== void 0 && (_.scheme = unescape(_.scheme)), _.host !== void 0 && (_.host = unescape(_.host))), _.path && (_.path = escape(unescape(_.path))), _.fragment && (_.fragment = encodeURI(decodeURIComponent(_.fragment)))), A && A.parse && A.parse(_, E);
    } else
      _.error = _.error || "URI can not be parsed.";
    return _;
  }
  const x = {
    SCHEMES: l,
    normalize: d,
    resolve: f,
    resolveComponent: m,
    equal: h,
    serialize: v,
    parse: b
  };
  return ex.exports = x, ex.exports.default = x, ex.exports.fastUri = x, ex.exports;
}
var FNe = LNe();
const Gj = /* @__PURE__ */ Gc(FNe);
function U2(e, t) {
  if (Ln in e && Gj.equal(e[Ln], t))
    return e;
  for (const n of Object.values(e))
    if (Array.isArray(n)) {
      for (const r of n)
        if (mn(r)) {
          const a = U2(r, t);
          if (a !== void 0)
            return a;
        }
    } else if (mn(n)) {
      const r = U2(n, t);
      if (r !== void 0)
        return r;
    }
}
function W3(e, t) {
  const n = Re(e, Ln, t);
  cr in e && (e = { ...e, [cr]: Gj.resolve(n, e[cr]) });
  for (const [r, a] of Object.entries(e))
    Array.isArray(a) ? e = {
      ...e,
      [r]: a.map((s) => mn(s) ? W3(s, n) : s)
    } : mn(a) && (e = { ...e, [r]: W3(a, n) });
  return e;
}
function Kj(e, t) {
  const n = t[e];
  return [ES(t, [e]), n];
}
function XG(e, t = {}, n = [], r = Re(t, [Ln])) {
  const a = e || "";
  let s;
  if (a.startsWith("#")) {
    const c = decodeURIComponent(a.substring(1));
    r === void 0 || Ln in t && t[Ln] === r ? s = _5.get(t, c) : t[xx] === H_ && (s = U2(t, r.replace(/\/$/, "")), s !== void 0 && (s = _5.get(s, c)));
  } else if (t[xx] === H_) {
    const c = r ? Gj.resolve(r, a) : a, [d, ...f] = c.replace(/#\/?$/, "").split("#");
    s = U2(t, d.replace(/\/$/, "")), s !== void 0 && (r = s[Ln], $r(f) || (s = _5.get(s, decodeURIComponent(f.join("#")))));
  }
  if (s === void 0)
    throw new Error(`Could not find a definition for ${e}.`);
  const l = s[cr];
  if (l) {
    if (n.includes(l)) {
      if (n.length === 1)
        throw new Error(`Definition for ${e} is a circular reference`);
      const [m, ...h] = n, v = [...h, a, m].join(" -> ");
      throw new Error(`Definition for ${m} contains a circular reference through ${v}`);
    }
    const [c, d] = Kj(cr, s), f = XG(d, t, [...n, a], r);
    return Object.keys(c).length > 0 ? t[xx] === n2e || t[xx] === H_ ? { [Dd]: [c, f] } : { ...c, ...f } : f;
  }
  return s;
}
function JG(e, t = {}, n = Re(t, [Ln])) {
  return XG(e, t, [], n);
}
var BNe = "[object String]";
function $d(e) {
  return typeof e == "string" || !oo(e) && Ki(e) && Qc(e) == BNe;
}
function Wl(e) {
  let t;
  const n = Re(e, Z_e);
  return $d(n) ? t = n : n !== void 0 && console.warn(`Expecting discriminator to be a string, got "${typeof n}" instead`), t;
}
function CS(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : e == null ? "null" : typeof e == "boolean" ? "boolean" : isNaN(e) ? typeof e == "object" ? "object" : "string" : "number";
}
var UNe = _C(function(e) {
  return zG(_k(e, 1, _S, !0));
});
function rl(e) {
  let { type: t } = e;
  return !t && e.const ? CS(e.const) : !t && e.enum ? "string" : !t && (e.properties || e.additionalProperties || e.patternProperties) ? "object" : (Array.isArray(t) && (t.length === 2 && t.includes("null") ? t = t.find((n) => n !== "null") : t = t[0]), t);
}
function Vc(e, t) {
  const n = Object.assign({}, e);
  return Object.keys(t).reduce((r, a) => {
    const s = e ? e[a] : {}, l = t[a];
    return e && a in e && un(l) ? r[a] = Vc(s, l) : e && t && (rl(e) === "object" || rl(t) === "object") && a === Zq && Array.isArray(s) && Array.isArray(l) ? r[a] = UNe(s, l) : r[a] = l, r;
  }, n);
}
var VNe = "[object Number]";
function QG(e) {
  return typeof e == "number" || Ki(e) && Qc(e) == VNe;
}
function ZG(e, t, n) {
  var r;
  if (e && n) {
    const a = Re(e, n);
    if (a === void 0)
      return;
    for (let s = 0; s < t.length; s++) {
      const l = t[s], c = Re(l, [gn, n], {});
      if (!(c.type === "object" || c.type === "array") && (c.const === a || !((r = c.enum) === null || r === void 0) && r.includes(a)))
        return s;
    }
  }
}
function Yj(e, t, n, r, a) {
  if (t === void 0)
    return 0;
  const s = ZG(t, n, a);
  if (QG(s))
    return s;
  for (let l = 0; l < n.length; l++) {
    const c = n[l];
    if (a && rn(c, [gn, a])) {
      const d = Re(t, a), f = Re(c, [gn, a], {});
      if (e.isValid(f, d, r))
        return l;
    } else if (c[gn]) {
      const d = {
        anyOf: Object.keys(c[gn]).map((m) => ({
          required: [m]
        }))
      };
      let f;
      if (c.anyOf) {
        const { ...m } = c;
        m.allOf ? m.allOf = m.allOf.slice() : m.allOf = [], m.allOf.push(d), f = m;
      } else
        f = Object.assign({}, c, d);
      if (delete f.required, e.isValid(f, t, r))
        return l;
    } else if (e.isValid(c, t, r))
      return l;
  }
  return 0;
}
function Xo(e, t, n = {}, r, a, s = !1) {
  return Al(e, t, n, r, void 0, void 0, a, s)[0];
}
function HNe(e, t, n, r, a, s, l) {
  const { if: c, then: d, else: f, ...m } = t, h = e.isValid(c, s || {}, n);
  let v = [m], g = [];
  if (r)
    d && typeof d != "boolean" && (g = g.concat(Al(e, d, n, s, r, a, l))), f && typeof f != "boolean" && (g = g.concat(Al(e, f, n, s, r, a, l)));
  else {
    const b = h ? d : f;
    b && typeof b != "boolean" && (g = g.concat(Al(e, b, n, s, r, a, l)));
  }
  return g.length && (v = g.map((b) => Vc(m, b))), v.flatMap((b) => Al(e, b, n, s, r, a, l));
}
function eK(e) {
  return e.reduce((t, n) => n.length > 1 ? n.flatMap((r) => SG(t.length, (a) => [...t[a]].concat(r))) : (t.forEach((r) => r.push(n[0])), t), [[]]);
}
function tK(e, t) {
  return Object.keys(e.patternProperties).filter((n) => RegExp(n).test(t)).reduce((n, r) => (zn(n, [r], e.patternProperties[r]), n), {});
}
function WNe(e, t, n, r, a, s, l, c) {
  const d = nK(e, t, n, r, a, s, l, c);
  if (d.length > 1 || d[0] !== t)
    return d;
  if (Oj in t)
    return rK(e, t, n, r, a, s, l).flatMap((f) => Al(e, f, n, s, r, a, l));
  if (Dd in t && Array.isArray(t[Dd])) {
    const f = t.allOf.map((m) => Al(e, m, n, s, r, a, l));
    return eK(f).map((m) => ({
      ...t,
      allOf: m
    }));
  }
  return [t];
}
function nK(e, t, n, r, a, s, l, c) {
  const d = lg(t, n, a, void 0, c);
  return d !== t ? Al(e, d, n, s, r, a, l, c) : [t];
}
function lg(e, t, n, r, a) {
  if (!un(e))
    return e;
  let s = e;
  if (cr in s) {
    const { $ref: l, ...c } = s;
    if (n.includes(l))
      return s;
    n.push(l), s = { ...JG(l, t, r), ...c }, Ln in s && (r = s[Ln]);
  }
  if (gn in s) {
    const l = [], c = bOe(s[gn], (d, f, m) => {
      const h = [...n];
      d[m] = lg(f, t, h, r, a), l.push(h);
    }, {});
    $Oe(n, TG(LOe(l))), s = { ...s, [gn]: c };
  }
  if (Cg in s && !Array.isArray(s.items) && typeof s.items != "boolean" && (s = {
    ...s,
    items: lg(s.items, t, n, r, a)
  }), a) {
    let l, c;
    dn in e && Array.isArray(e[dn]) ? (l = dn, c = s[dn]) : Kt in e && Array.isArray(e[Kt]) && (l = Kt, c = s[Kt]), l && c && (s = {
      ...s,
      [l]: c.map((d) => lg(d, t, n, r, a))
    });
  }
  return er(e, s) ? e : s;
}
function qNe(e, t, n, r, a) {
  const s = {
    ...t,
    properties: { ...t.properties }
  }, l = r && un(r) ? r : {};
  return Object.keys(l).forEach((c) => {
    if (!(c in s.properties)) {
      if (I3 in s) {
        const d = tK(s, c);
        if (!$r(d)) {
          s.properties[c] = Xo(e, { [Dd]: Object.values(d) }, n, Re(l, [c]), a), zn(s.properties, [c, Pc], !0);
          return;
        }
      }
      if (T2 in s && s.additionalProperties !== !1) {
        let d;
        typeof s.additionalProperties != "boolean" ? cr in s.additionalProperties ? d = Xo(e, { [cr]: Re(s.additionalProperties, [cr]) }, n, l, a) : "type" in s.additionalProperties ? d = { ...s.additionalProperties } : dn in s.additionalProperties || Kt in s.additionalProperties ? d = {
          type: "object",
          ...s.additionalProperties
        } : d = { type: CS(Re(l, [c])) } : d = { type: CS(Re(l, [c])) }, s.properties[c] = d, zn(s.properties, [c, Pc], !0);
      } else
        s.properties[c] = { type: "null" }, zn(s.properties, [c, Pc], !0);
    }
  }), s;
}
const { compareSchemaDefinitions: GNe, compareSchemaValues: KNe } = lMe(), { mergeArrayOfSchemaDefinitions: YNe } = vMe({
  intersectJson: nMe(KNe),
  deduplicateJsonSchemaDef: LG(GNe)
}), XNe = bMe(YNe);
function JNe(e) {
  return XNe(e);
}
function Al(e, t, n, r, a = !1, s = [], l, c) {
  return un(t) ? WNe(e, t, n, a, s, r, l, c).flatMap((d) => {
    var f;
    let m = d;
    if (J_e in m)
      return HNe(e, m, n, a, s, r, l);
    if (Dd in m) {
      if (a) {
        const { allOf: h, ...v } = m;
        return [...h, v];
      }
      try {
        const h = [], v = [];
        (f = m.allOf) === null || f === void 0 || f.forEach((g) => {
          typeof g == "object" && g.contains ? h.push(g) : v.push(g);
        }), h.length && (m = { ...m, allOf: v }), m = l ? l(m) : JNe(m), h.length && (m.allOf = h);
      } catch (h) {
        console.warn(`could not merge subschemas in allOf:
`, h);
        const { allOf: v, ...g } = m;
        return g;
      }
    }
    return gn in m && I3 in m && (m = Object.keys(m.properties).reduce((h, v) => {
      const g = tK(h, v);
      return $r(g) || (h.properties[v] = Xo(e, { allOf: [h.properties[v], ...Object.values(g)] }, n, Re(r, [v]), l)), h;
    }, {
      ...m,
      properties: { ...m.properties }
    })), I3 in m || T2 in m && m.additionalProperties !== !1 ? qNe(e, m, n, r, l) : m;
  }) : [{}];
}
function QNe(e, t, n, r, a) {
  let s;
  const { oneOf: l, anyOf: c, ...d } = t;
  if (Array.isArray(l) ? s = l : Array.isArray(c) && (s = c), s) {
    const f = a === void 0 && r ? {} : a, m = Wl(t);
    s = s.map((v) => lg(v, n, []));
    const h = Yj(e, f, s, n, m);
    if (r)
      return s.map((v) => Vc(d, v));
    t = Vc(d, s[h]);
  }
  return [t];
}
function rK(e, t, n, r, a, s, l) {
  const { dependencies: c, ...d } = t;
  return QNe(e, d, n, r, s).flatMap((f) => oK(e, c, f, n, r, a, s, l));
}
function oK(e, t, n, r, a, s, l, c) {
  let d = [n];
  for (const f in t) {
    if (!a && Re(l, [f]) === void 0 || n.properties && !(f in n.properties))
      continue;
    const [m, h] = Kj(f, t);
    return Array.isArray(h) ? d[0] = ZNe(n, h) : un(h) && (d = e5e(e, n, r, f, h, a, s, l, c)), d.flatMap((v) => oK(e, m, v, r, a, s, l, c));
  }
  return d;
}
function ZNe(e, t) {
  if (!t)
    return e;
  const n = Array.isArray(e.required) ? Array.from(/* @__PURE__ */ new Set([...e.required, ...t])) : t;
  return { ...e, required: n };
}
function e5e(e, t, n, r, a, s, l, c, d) {
  return Al(e, a, n, c, s, l, d).flatMap((f) => {
    const { oneOf: m, ...h } = f;
    if (t = Vc(t, h), m === void 0)
      return t;
    const v = m.map((g) => typeof g == "boolean" || !(cr in g) ? [g] : nK(e, g, n, s, l, c));
    return eK(v).flatMap((g) => t5e(e, t, n, r, g, s, l, c, d));
  });
}
function t5e(e, t, n, r, a, s, l, c, d) {
  const f = a.filter((m) => {
    if (typeof m == "boolean" || !m || !m.properties)
      return !1;
    const { [r]: h } = m.properties;
    if (h) {
      const v = {
        type: "object",
        properties: {
          [r]: h
        }
      };
      return e.isValid(v, c, n) || s;
    }
    return !1;
  });
  return !s && f.length !== 1 ? (console.warn("ignoring oneOf in dependencies because there isn't exactly one subschema that is valid"), [t]) : f.flatMap((m) => {
    const h = m, [v] = Kj(r, h.properties), g = { ...h, properties: v };
    return Al(e, g, n, c, s, l, d).map((b) => Vc(t, b));
  });
}
function kx(e, t, n, r, a, s = {}, l) {
  if (Array.isArray(n[a])) {
    const c = Wl(n) || r, d = n[a].map((m) => Xo(e, m, t, s, l)), f = Re(s, c);
    if (f !== void 0)
      return d.find((m) => kS(Re(m, [gn, c, gC], Re(m, [gn, c, qi])), f));
  }
}
function aK(e, t, n, r, a) {
  let s = n;
  if (rn(n, cr) && (s = Xo(e, n, t, void 0, a)), $r(r))
    return s;
  const l = Array.isArray(r) ? r : r.split("."), [c, ...d] = l;
  if (c && rn(s, c))
    return s = Re(s, c), aK(e, t, s, d, a);
}
function G_(e, t, n, r, a, s) {
  const l = aK(e, t, n, r, s);
  return l === void 0 ? a : l;
}
const Wz = { title: "!@#$_UNKNOWN_$#@!" };
function n5e(e, t, n, r, a = {}, s) {
  const l = Array.isArray(r) ? [...r] : r.split(".");
  let c = n;
  const d = l.pop();
  l.length && l.forEach((v) => {
    c = G_(e, t, c, [gn, v], {}, s), rn(c, Kt) ? c = kx(e, t, c, d, Kt, Re(a, v), s) : rn(c, dn) && (c = kx(e, t, c, d, dn, Re(a, v), s));
  }), rn(c, Kt) ? c = kx(e, t, c, d, Kt, a, s) : rn(c, dn) && (c = kx(e, t, c, d, dn, a, s));
  let f = G_(e, t, c, [gn, d], Wz, s);
  f === Wz && (f = void 0);
  const m = G_(e, t, c, Zq, [], s);
  let h;
  return f && Array.isArray(m) && (h = m.includes(d)), { field: f, isRequired: h };
}
function r5e(e, t, n, r) {
  var a = -1, s = e == null ? 0 : e.length;
  for (r && s && (n = e[++a]); ++a < s; )
    n = t(n, e[a], a, e);
  return n;
}
function o5e(e, t) {
  return function(n, r) {
    if (n == null)
      return n;
    if (!nh(n))
      return e(n, r);
    for (var a = n.length, s = -1, l = Object(n); ++s < a && r(l[s], s, l) !== !1; )
      ;
    return n;
  };
}
var iK = o5e(EG);
function a5e(e, t, n, r, a) {
  return a(e, function(s, l, c) {
    n = r ? (r = !1, s) : t(n, s, l, c);
  }), n;
}
function i5e(e, t, n) {
  var r = oo(e) ? r5e : a5e, a = arguments.length < 3;
  return r(e, Uj(t), n, a, iK);
}
const s5e = {
  type: "object",
  $id: Q_e,
  properties: {
    __not_really_there__: {
      type: "number"
    }
  }
};
function q3(e, t, n, r, a) {
  let s = 0;
  return n && (mn(n.properties) ? s += i5e(n.properties, (l, c, d) => {
    const f = Re(r, d);
    if (typeof c == "boolean")
      return l;
    if (rn(c, cr)) {
      const m = Xo(e, c, t, f, a);
      return l + q3(e, t, m, f || {}, a);
    }
    if ((rn(c, Kt) || rn(c, dn)) && f) {
      const m = rn(c, Kt) ? Kt : dn, h = Wl(c);
      return l + OS(e, t, f, Re(c, m), -1, h, a);
    }
    if (c.type === "object")
      return mn(f) && (l += 1), l + q3(e, t, c, f, a);
    if (c.type === CS(f)) {
      let m = l + 1;
      return c.default ? m += f === c.default ? 1 : -1 : c.const && (m += f === c.const ? 1 : -1), m;
    }
    return l;
  }, 0) : $d(n.type) && n.type === CS(r) && (s += 1)), s;
}
function OS(e, t, n, r, a = -1, s, l) {
  const c = r.map((v) => lg(v, t, [])), d = ZG(n, r, s);
  if (QG(d))
    return d;
  const f = c.reduce((v, g, b) => (Yj(e, n, [s5e, g], t, s) === 1 && v.push(b), v), []);
  if (f.length === 1)
    return f[0];
  f.length || SG(c.length, (v) => f.push(v));
  const m = /* @__PURE__ */ new Set(), { bestIndex: h } = f.reduce((v, g) => {
    const { bestScore: b } = v, x = c[g], w = q3(e, t, x, n, l);
    return m.add(w), w > b ? { bestIndex: g, bestScore: w } : v;
  }, { bestIndex: a, bestScore: 0 });
  return m.size === 1 && a >= 0 ? a : h;
}
function Xj(e) {
  return Array.isArray(e.items) && e.items.length > 0 && e.items.every((t) => un(t));
}
function V2(e) {
  return e == null;
}
function MS(e, t, n = !1, r = !1, a = !1) {
  if (Array.isArray(t)) {
    const s = Array.isArray(e) ? e : [], l = a ? s : t, c = a ? t : s, d = l.map((f, m) => c[m] !== void 0 ? MS(s[m], t[m], n, r, a) : f);
    return (n || a) && d.length < c.length && d.push(...c.slice(d.length)), d;
  }
  if (un(t)) {
    const s = Object.assign({}, e);
    return Object.keys(t).reduce((l, c) => {
      var d;
      const f = Re(t, c), m = un(e) && c in e, h = c in t, v = (d = Re(e, c)) !== null && d !== void 0 ? d : {}, g = m && Object.entries(v).some(([, w]) => un(w)), b = m && un(Re(e, c)), x = h && un(f);
      return b && x && !g ? (l[c] = {
        ...Re(e, c),
        ...f
      }, l) : (l[c] = MS(
        Re(e, c),
        f,
        n,
        r,
        // overrideFormDataWithDefaults can be true only when the key value exists in defaults
        // Or if the key value doesn't exist in formData
        a && (m || !h)
      ), l);
    }, s);
  }
  return r && (e !== void 0 && V2(t) || typeof t == "number" && isNaN(t)) || a && !V2(t) ? e : t;
}
function NS(e, t, n = !1) {
  return Object.keys(t).reduce((r, a) => {
    const s = e ? e[a] : {}, l = t[a];
    if (e && a in e && un(l))
      r[a] = NS(s, l, n);
    else if (n && Array.isArray(s) && Array.isArray(l)) {
      let c = l;
      n === "preventDuplicates" && (c = l.reduce((d, f) => (s.includes(f) || d.push(f), d), [])), r[a] = s.concat(c);
    } else
      r[a] = l;
    return r;
  }, Object.assign({}, e));
}
function sK(e) {
  return Array.isArray(e.enum) && e.enum.length === 1 || qi in e;
}
function Jj(e, t, n = {}, r) {
  const a = Xo(e, t, n, void 0, r), s = a.oneOf || a.anyOf;
  return Array.isArray(a.enum) ? !0 : Array.isArray(s) ? s.every((l) => typeof l != "boolean" && sK(l)) : !1;
}
function Qj(e, t, n, r) {
  return !t.uniqueItems || !t.items || typeof t.items == "boolean" ? !1 : Jj(e, t.items, n, r);
}
function lK(e) {
  const t = e[qi], n = rl(e);
  return un(t) && $d(t?.$data) && n !== "object" && n !== "array";
}
function l5e(e) {
  if (X_e in e && Array.isArray(e.enum) && e.enum.length === 1)
    return e.enum[0];
  if (qi in e)
    return e.const;
  throw new Error("schema cannot be inferred as a constant");
}
function Ng(e, t) {
  if (e.enum) {
    let s;
    if (t) {
      const { enumNames: l } = vt(t);
      s = l;
    }
    return e.enum.map((l, c) => ({ label: s?.[c] || String(l), value: l }));
  }
  let n, r;
  e.anyOf ? (n = e.anyOf, r = t?.anyOf) : e.oneOf && (n = e.oneOf, r = t?.oneOf);
  let a = Wl(e);
  if (t) {
    const { optionsSchemaSelector: s = a } = vt(t);
    a = s;
  }
  return n && n.map((s, l) => {
    const { title: c } = vt(r?.[l]), d = s;
    let f, m = c;
    if (a) {
      const h = Re(d, [gn, a], {});
      f = Re(h, gC, Re(h, qi)), m = m || h?.title || d.title || String(f);
    } else
      f = l5e(d), m = m || d.title || String(f);
    return {
      schema: d,
      label: m,
      value: f
    };
  });
}
const u5e = ["string", "number", "integer", "boolean", "null"];
var Ag;
(function(e) {
  e[e.Ignore = 0] = "Ignore", e[e.Invert = 1] = "Invert", e[e.Fallback = 2] = "Fallback";
})(Ag || (Ag = {}));
function O5(e, t = Ag.Ignore, n = -1) {
  if (n >= 0) {
    if (Array.isArray(e.items) && n < e.items.length) {
      const r = e.items[n];
      if (typeof r != "boolean")
        return r;
    }
  } else if (e.items && !Array.isArray(e.items) && typeof e.items != "boolean")
    return e.items;
  return t !== Ag.Ignore && un(e.additionalItems) ? e.additionalItems : {};
}
function uK(e, t) {
  const { default: n, type: r } = e;
  return Array.isArray(r) && r.includes("null") && $r(t) && n === null ? null : t;
}
function qz(e, t, n, r, a, s = [], l = {}, c = !1, d = !1) {
  const { emptyObjectFields: f = "populateAllDefaults" } = l;
  if (r === !0 || c)
    e[t] = n;
  else if (r === "excludeObjectChildren")
    (d && n !== void 0 || !un(n) || !$r(n)) && (e[t] = n);
  else if (f !== "skipDefaults") {
    const m = a === void 0 ? s.includes(t) : a;
    un(n) ? f === "skipEmptyDefaults" ? $r(n) || (e[t] = n) : (!$r(n) || s.includes(t)) && (m || f !== "populateRequiredDefaults") && (e[t] = n) : (
      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions
      // Condition 1: computedDefault is not undefined
      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or 'skipEmptyDefaults)
      // Or if isSelfOrParentRequired is 'true' and the key is a required field
      n !== void 0 && (f === "populateAllDefaults" || f === "skipEmptyDefaults" || m && s.includes(t)) && (e[t] = n)
    );
  }
}
function xd(e, t, n = {}) {
  const { parentDefaults: r, rawFormData: a, rootSchema: s = {}, includeUndefinedValues: l = !1, _recurseList: c = [], experimental_defaultFormStateBehavior: d = void 0, experimental_customMergeAllOf: f = void 0, required: m, shouldMergeDefaultsIntoFormData: h = !1, initialDefaultsGenerated: v } = n;
  let g = un(a) ? a : {};
  const b = un(t) ? t : {};
  let x = r, w = null, k = d, E = c;
  if (b[qi] !== void 0 && d?.constAsDefaults !== "never" && !lK(b))
    x = b[qi];
  else if (un(x) && un(b.default))
    x = NS(x, b.default);
  else if (gC in b && !b[dn] && !b[Kt] && !b[cr])
    x = b.default;
  else if (cr in b) {
    const N = b[cr];
    c.includes(N) || (E = c.concat(N), w = JG(N, s)), w && !x && (x = b.default), h && w && !un(a) && (g = a);
  } else if (Oj in b) {
    const N = {
      ...Gz(e, b, n, x),
      ...g
    };
    w = rK(e, b, s, !1, [], N, f)[0];
  } else if (Xj(b))
    x = b.items.map((N, A) => xd(e, N, {
      rootSchema: s,
      includeUndefinedValues: l,
      _recurseList: c,
      experimental_defaultFormStateBehavior: d,
      experimental_customMergeAllOf: f,
      parentDefaults: Array.isArray(r) ? r[A] : void 0,
      rawFormData: g,
      required: m,
      shouldMergeDefaultsIntoFormData: h
    }));
  else if (Kt in b) {
    const { oneOf: N, ...A } = b;
    if (N.length === 0)
      return;
    const R = Wl(b), { type: D = "null" } = A;
    !Array.isArray(D) && u5e.includes(D) && k?.constAsDefaults === "skipOneOf" && (k = {
      ...k,
      constAsDefaults: "never"
    }), w = N[OS(e, s, a ?? b.default, N, 0, R, f)], w = Vc(A, w);
  } else if (dn in b) {
    const { anyOf: N, ...A } = b;
    if (N.length === 0)
      return;
    const R = Wl(b);
    w = N[OS(e, s, a ?? b.default, N, 0, R, f)], w = Vc(A, w);
  }
  if (w)
    return xd(e, w, {
      rootSchema: s,
      includeUndefinedValues: l,
      _recurseList: E,
      experimental_defaultFormStateBehavior: k,
      experimental_customMergeAllOf: f,
      parentDefaults: x,
      rawFormData: a ?? g,
      required: m,
      shouldMergeDefaultsIntoFormData: h,
      initialDefaultsGenerated: v
    });
  x === void 0 && (x = b.default);
  let O = Gz(e, b, n, x) ?? x;
  if (h) {
    const { arrayMinItems: N = {} } = d || {}, { mergeExtraDefaults: A } = N, R = c5e(e, b, s, a, d, f);
    (!un(a) || Dd in b) && (O = MS(O, R, A, !0));
  }
  return O;
}
function c5e(e, t, n, r, a, s) {
  const l = !sK(t) && Jj(e, t, n, s);
  let c = r;
  return l && (c = Ng(t)?.some((f) => er(f.value, r)) ? r : void 0), t[qi] && a?.constAsDefaults === "always" && (c = t.const), c;
}
function d5e(e, t, { rawFormData: n, rootSchema: r = {}, includeUndefinedValues: a = !1, _recurseList: s = [], experimental_defaultFormStateBehavior: l = void 0, experimental_customMergeAllOf: c = void 0, required: d, shouldMergeDefaultsIntoFormData: f, initialDefaultsGenerated: m } = {}, h) {
  {
    const v = un(n) ? n : {}, g = t, b = l?.allOf === "populateDefaults" && Dd in g ? Xo(e, g, r, v, c) : g, x = b[qi], w = Object.keys(b.properties || {}).reduce((k, E) => {
      var _;
      const O = Re(b, [gn, E], {}), N = un(x) && x[E] !== void 0, A = (un(O) && qi in O || N) && l?.constAsDefaults !== "never" && !lK(O), R = xd(e, O, {
        rootSchema: r,
        _recurseList: s,
        experimental_defaultFormStateBehavior: l,
        experimental_customMergeAllOf: c,
        includeUndefinedValues: a === !0,
        parentDefaults: Re(h, [E]),
        rawFormData: Re(v, [E]),
        required: (_ = b.required) === null || _ === void 0 ? void 0 : _.includes(E),
        shouldMergeDefaultsIntoFormData: f,
        initialDefaultsGenerated: m
      });
      return qz(k, E, R, a, d, b.required, l, A, O?.type === "null"), k;
    }, {});
    if (b.additionalProperties && !m) {
      const k = un(b.additionalProperties) ? b.additionalProperties : {}, E = /* @__PURE__ */ new Set();
      un(h) && Object.keys(h).filter((O) => !b.properties || !b.properties[O]).forEach((O) => E.add(O));
      const _ = [];
      Object.keys(v).filter((O) => !b.properties || !b.properties[O]).forEach((O) => {
        E.add(O), _.push(O);
      }), E.forEach((O) => {
        var N;
        const A = xd(e, k, {
          rootSchema: r,
          _recurseList: s,
          experimental_defaultFormStateBehavior: l,
          experimental_customMergeAllOf: c,
          includeUndefinedValues: a === !0,
          parentDefaults: Re(h, [O]),
          rawFormData: Re(v, [O]),
          required: (N = b.required) === null || N === void 0 ? void 0 : N.includes(O),
          shouldMergeDefaultsIntoFormData: f,
          initialDefaultsGenerated: m
        });
        qz(w, O, A, a, d, _);
      });
    }
    return uK(t, w);
  }
}
function f5e(e, t, { rawFormData: n, rootSchema: r = {}, _recurseList: a = [], experimental_defaultFormStateBehavior: s = void 0, experimental_customMergeAllOf: l = void 0, required: c, requiredAsRoot: d = !1, shouldMergeDefaultsIntoFormData: f, initialDefaultsGenerated: m } = {}, h) {
  var v, g;
  const b = t, x = (v = s?.arrayMinItems) !== null && v !== void 0 ? v : {}, { populate: w, mergeExtraDefaults: k } = x, E = w === "never", _ = w === "requiredOnly", O = w === "all" || !E && !_, N = (g = x?.computeSkipPopulate) !== null && g !== void 0 ? g : (() => !1), A = s?.emptyObjectFields === "skipEmptyDefaults" ? void 0 : [];
  if (Array.isArray(h) && (h = h.map((I, z) => {
    const B = O5(b, Ag.Fallback, z);
    return xd(e, B, {
      rootSchema: r,
      _recurseList: a,
      experimental_defaultFormStateBehavior: s,
      experimental_customMergeAllOf: l,
      parentDefaults: I,
      required: c,
      shouldMergeDefaultsIntoFormData: f,
      initialDefaultsGenerated: m
    });
  })), Array.isArray(n)) {
    const I = O5(b);
    if (E)
      h = n;
    else {
      const z = n.map((B, P) => xd(e, I, {
        rootSchema: r,
        _recurseList: a,
        experimental_defaultFormStateBehavior: s,
        experimental_customMergeAllOf: l,
        rawFormData: B,
        parentDefaults: Re(h, [P]),
        required: c,
        shouldMergeDefaultsIntoFormData: f,
        initialDefaultsGenerated: m
      }));
      h = MS(h, z, (_ && c || O) && k);
    }
  }
  if ((un(b) && qi in b && s?.constAsDefaults !== "never") === !1) {
    if (E)
      return h ?? A;
    if (_ && !c)
      return h || void 0;
  }
  let R;
  const D = Array.isArray(h) ? h.length : 0;
  if (!b.minItems || Qj(e, b, r, l) || N(e, b, r) || b.minItems <= D)
    R = h || !c && !d ? h : A;
  else {
    const I = h || [], z = O5(b, Ag.Invert), B = z.default, P = Array.from({ length: b.minItems - D }, () => xd(e, z, {
      parentDefaults: B,
      rootSchema: r,
      _recurseList: a,
      experimental_defaultFormStateBehavior: s,
      experimental_customMergeAllOf: l,
      required: c,
      shouldMergeDefaultsIntoFormData: f
    }));
    R = I.concat(P);
  }
  return uK(t, R);
}
function Gz(e, t, n = {}, r) {
  switch (rl(t)) {
    // We need to recurse for object schema inner default values.
    case "object":
      return d5e(e, t, n, r);
    case "array":
      return f5e(e, t, n, r);
  }
}
function cK(e, t, n, r, a = !1, s, l, c) {
  if (!un(t))
    throw new Error("Invalid schema: " + t);
  const d = Xo(e, t, r, n, l), f = xd(e, d, {
    rootSchema: r,
    includeUndefinedValues: a,
    experimental_defaultFormStateBehavior: s,
    experimental_customMergeAllOf: l,
    rawFormData: n,
    shouldMergeDefaultsIntoFormData: !0,
    initialDefaultsGenerated: c,
    requiredAsRoot: !0
  });
  if (d.type !== "object" && un(d.default))
    return {
      ...f,
      ...n
    };
  if (un(n) || Array.isArray(n)) {
    const { mergeDefaultsIntoFormData: m } = s || {};
    return MS(
      f,
      n,
      !0,
      m === "useDefaultIfFormDataUndefined",
      !0
    );
  }
  return f;
}
function dK(e = {}) {
  return (
    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.
    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets
    "widget" in vt(e) && vt(e).widget !== "hidden"
  );
}
function fK(e, t, n = {}, r, a) {
  if (n[Nj] === "files")
    return !0;
  if (t.items) {
    const s = Xo(e, t.items, r, void 0, a);
    return s.type === "string" && s.format === "data-url";
  }
  return !1;
}
function p5e(e, t, n = {}, r, a, s) {
  const l = vt(n, a), { label: c = !0 } = l;
  let d = !!c;
  if (d) {
    const f = rl(t), m = Re(t, Pc, !1);
    f === "array" && (d = m || Qj(e, t, r, s) || fK(e, t, n, r, s) || dK(n)), f === "object" && (d = m), f === "boolean" && n && !n[Nj] && (d = !1), n && n[t2e] && (d = !1);
  }
  return d;
}
const Eh = /* @__PURE__ */ Symbol("no Value");
function G3(e, t, n, r, a = {}, s) {
  let l;
  if (rn(n, gn)) {
    const c = {};
    if (rn(r, gn)) {
      const m = Re(r, gn, {});
      Object.keys(m).forEach((h) => {
        rn(a, h) && (c[h] = void 0);
      });
    }
    const d = Object.keys(Re(n, gn, {})), f = {};
    d.forEach((m) => {
      const h = Re(a, m);
      let v = Re(r, [gn, m], {}), g = Re(n, [gn, m], {});
      rn(v, cr) && (v = Xo(e, v, t, h, s)), rn(g, cr) && (g = Xo(e, g, t, h, s));
      const b = Re(v, "type"), x = Re(g, "type");
      if (!b || b === x)
        if (rn(c, m) && delete c[m], x === "object" || x === "array" && Array.isArray(h)) {
          const w = G3(e, t, g, v, h, s);
          (w !== void 0 || x === "array") && (f[m] = w);
        } else {
          const w = Re(g, "default", Eh), k = Re(v, "default", Eh);
          w !== Eh && w !== h && (k === h ? c[m] = w : Re(g, "readOnly") === !0 && (c[m] = void 0));
          const E = Re(g, "const", Eh), _ = Re(v, "const", Eh);
          E !== Eh && E !== h && (c[m] = _ === h ? E : void 0);
        }
    }), l = {
      ...typeof a == "string" || Array.isArray(a) ? void 0 : a,
      ...c,
      ...f
    };
  } else if (Re(r, "type") === "array" && Re(n, "type") === "array" && Array.isArray(a)) {
    let c = Re(r, "items"), d = Re(n, "items");
    if (typeof c == "object" && typeof d == "object" && !Array.isArray(c) && !Array.isArray(d)) {
      rn(c, cr) && (c = Xo(e, c, t, a, s)), rn(d, cr) && (d = Xo(e, d, t, a, s));
      const f = Re(c, "type"), m = Re(d, "type");
      if (!f || f === m) {
        const h = Re(n, "maxItems", -1);
        m === "object" ? l = a.reduce((v, g) => {
          const b = G3(e, t, d, c, g, s);
          return b !== void 0 && (h < 0 || v.length < h) && v.push(b), v;
        }, []) : l = h > 0 && a.length > h ? a.slice(0, h) : a;
      }
    } else typeof c == "boolean" && typeof d == "boolean" && c === d && (l = a);
  }
  return l;
}
function xm(e, t, n, r, a, s = [], l) {
  if (cr in t || Oj in t || Dd in t) {
    const d = Xo(e, t, r, a, l);
    if (s.findIndex((f) => er(f, d)) === -1)
      return xm(e, d, n, r, a, s.concat(d), l);
  }
  let c = {
    [V_]: n.replace(/^\./, "")
  };
  if (Kt in t || dn in t) {
    const d = Kt in t ? t.oneOf : t.anyOf, f = Wl(t), m = OS(e, r, a, d, 0, f, l), h = d[m];
    c = {
      ...c,
      ...xm(e, h, n, r, a, s, l)
    };
  }
  if (T2 in t && t[T2] !== !1 && zn(c, Mj, !0), Cg in t && Array.isArray(a)) {
    const { items: d, additionalItems: f } = t;
    Array.isArray(d) ? a.forEach((m, h) => {
      d[h] ? c[h] = xm(e, d[h], `${n}.${h}`, r, m, s, l) : f ? c[h] = xm(e, f, `${n}.${h}`, r, m, s, l) : console.warn(`Unable to generate path schema for "${n}.${h}". No schema defined for it`);
    }) : a.forEach((m, h) => {
      c[h] = xm(e, d, `${n}.${h}`, r, m, s, l);
    });
  } else if (gn in t)
    for (const d in t.properties) {
      const f = Re(t, [gn, d], {});
      c[d] = xm(
        e,
        f,
        `${n}.${d}`,
        r,
        // It's possible that formData is not an object -- this can happen if an
        // array item has just been added, but not populated with data yet
        Re(a, [d]),
        s,
        l
      );
    }
  return c;
}
function m5e(e, t, n = "", r, a, s) {
  return xm(e, t, n, r, a, void 0, s);
}
class h5e {
  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables
   *
   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs
   * @param rootSchema - The root schema that will be forwarded to all the APIs
   * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior
   * @param [experimental_customMergeAllOf] - Optional function that allows for custom merging of `allOf` schemas
   */
  constructor(t, n, r, a) {
    n && n[xx] === H_ ? this.rootSchema = W3(n, Re(n, Ln, "#")) : this.rootSchema = n, this.validator = t, this.experimental_defaultFormStateBehavior = r, this.experimental_customMergeAllOf = a;
  }
  /** Returns the `rootSchema` in the `SchemaUtilsType`
   *
   * @returns - The `rootSchema`
   */
  getRootSchema() {
    return this.rootSchema;
  }
  /** Returns the `ValidatorType` in the `SchemaUtilsType`
   *
   * @returns - The `ValidatorType`
   */
  getValidator() {
    return this.validator;
  }
  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of
   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation
   * of a new `SchemaUtilsType` with incomplete properties.
   *
   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one
   * @param rootSchema - The root schema that will be compared against the current one
   * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior
   * @param [experimental_customMergeAllOf] - Optional function that allows for custom merging of `allOf` schemas
   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`
   */
  doesSchemaUtilsDiffer(t, n, r = {}, a) {
    return !t || !n ? !1 : this.validator !== t || !er(this.rootSchema, n) || !er(this.experimental_defaultFormStateBehavior, r) || this.experimental_customMergeAllOf !== a;
  }
  /** Finds the field specified by the `path` within the root or recursed `schema`. If there is no field for the specified
   * `path`, then the default `{ field: undefined, isRequired: undefined }` is returned. It determines whether a leaf
   * field is in the `required` list for its parent and if so, it is marked as required on return.
   *
   * @param schema - The current node within the JSON schema
   * @param path - The remaining keys in the path to the desired field
   * @param [formData] - The form data that is used to determine which oneOf option
   * @returns - An object that contains the field and its required state. If no field can be found then
   *            `{ field: undefined, isRequired: undefined }` is returned.
   */
  findFieldInSchema(t, n, r) {
    return n5e(this.validator, this.rootSchema, t, n, r, this.experimental_customMergeAllOf);
  }
  /** Finds the oneOf option inside the `schema['any/oneOf']` list which has the `properties[selectorField].default` that
   * matches the `formData[selectorField]` value. For the purposes of this function, `selectorField` is either
   * `schema.discriminator.propertyName` or `fallbackField`.
   *
   * @param schema - The schema element in which to search for the selected oneOf option
   * @param fallbackField - The field to use as a backup selector field if the schema does not have a required field
   * @param xxx - Either `oneOf` or `anyOf`, defines which value is being sought
   * @param [formData={}] - The form data that is used to determine which oneOf option
   * @returns - The anyOf/oneOf option that matches the selector field in the schema or undefined if nothing is selected
   */
  findSelectedOptionInXxxOf(t, n, r, a) {
    return kx(this.validator, this.rootSchema, t, n, r, a, this.experimental_customMergeAllOf);
  }
  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have
   * computed to have defaults provided in the `schema`.
   *
   * @param schema - The schema for which the default state is desired
   * @param [formData] - The current formData, if any, onto which to provide any missing defaults
   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.
   *          If "excludeObjectChildren", pass `includeUndefinedValues` as false when computing defaults for any nested
   *          object properties.
   * @param initialDefaultsGenerated - Indicates whether or not initial defaults have been generated
   * @returns - The resulting `formData` with all the defaults provided
   */
  getDefaultFormState(t, n, r = !1, a) {
    return cK(this.validator, t, n, this.rootSchema, r, this.experimental_defaultFormStateBehavior, this.experimental_customMergeAllOf, a);
  }
  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`
   * should be displayed in a UI.
   *
   * @param schema - The schema for which the display label flag is desired
   * @param [uiSchema] - The UI schema from which to derive potentially displayable information
   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options
   * @returns - True if the label should be displayed or false if it should not
   */
  getDisplayLabel(t, n, r) {
    return p5e(this.validator, t, n, this.rootSchema, r, this.experimental_customMergeAllOf);
  }
  /** Determines which of the given `options` provided most closely matches the `formData`.
   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.
   *
   * The closest match is determined using the number of matching properties, and more heavily favors options with
   * matching readOnly, default, or const values.
   *
   * @param formData - The form data associated with the schema
   * @param options - The list of options that can be selected from
   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified
   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
   *          determine which option is selected
   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match
   */
  getClosestMatchingOption(t, n, r, a) {
    return OS(this.validator, this.rootSchema, t, n, r, a, this.experimental_customMergeAllOf);
  }
  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.
   * Always returns the first option if there is nothing that matches.
   *
   * @param formData - The current formData, if any, used to figure out a match
   * @param options - The list of options to find a matching options from
   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
   *          determine which option is selected
   * @returns - The firstindex of the matched option or 0 if none is available
   */
  getFirstMatchingOption(t, n, r) {
    return Yj(this.validator, t, n, this.rootSchema, r);
  }
  getFromSchema(t, n, r) {
    return G_(
      this.validator,
      this.rootSchema,
      t,
      n,
      // @ts-expect-error TS2769: No overload matches this call
      r,
      this.experimental_customMergeAllOf
    );
  }
  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files
   *
   * @param schema - The schema for which check for array of files flag is desired
   * @param [uiSchema] - The UI schema from which to check the widget
   * @returns - True if schema/uiSchema contains an array of files, otherwise false
   */
  isFilesArray(t, n) {
    return fK(this.validator, t, n, this.rootSchema, this.experimental_customMergeAllOf);
  }
  /** Checks to see if the `schema` combination represents a multi-select
   *
   * @param schema - The schema for which check for a multi-select flag is desired
   * @returns - True if schema contains a multi-select, otherwise false
   */
  isMultiSelect(t) {
    return Qj(this.validator, t, this.rootSchema, this.experimental_customMergeAllOf);
  }
  /** Checks to see if the `schema` combination represents a select
   *
   * @param schema - The schema for which check for a select flag is desired
   * @returns - True if schema contains a select, otherwise false
   */
  isSelect(t) {
    return Jj(this.validator, t, this.rootSchema, this.experimental_customMergeAllOf);
  }
  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and
   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially
   * recursive resolution.
   *
   * @param schema - The schema for which retrieving a schema is desired
   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema
   * @param [resolveAnyOfOrOneOfRefs] - Optional flag indicating whether to resolved refs in anyOf/oneOf lists
   * @returns - The schema having its conditions, additional properties, references and dependencies resolved
   */
  retrieveSchema(t, n, r) {
    return Xo(this.validator, t, this.rootSchema, n, this.experimental_customMergeAllOf, r);
  }
  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the
   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the
   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the
   * old schemas that are non-existent in the new schema are set to `undefined`.
   *
   * @param [newSchema] - The new schema for which the data is being sanitized
   * @param [oldSchema] - The old schema from which the data originated
   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined
   * @returns - The new form data, with all the fields uniquely associated with the old schema set
   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.
   */
  sanitizeDataForNewSchema(t, n, r) {
    return G3(this.validator, this.rootSchema, t, n, r, this.experimental_customMergeAllOf);
  }
  /** Generates an `PathSchema` object for the `schema`, recursively
   *
   * @param schema - The schema for which the display label flag is desired
   * @param [name] - The base name for the schema
   * @param [formData] - The current formData, if any, onto which to provide any missing defaults
   * @returns - The `PathSchema` object for the `schema`
   */
  toPathSchema(t, n, r) {
    return m5e(this.validator, t, n, this.rootSchema, r, this.experimental_customMergeAllOf);
  }
}
function g5e(e, t, n = {}, r) {
  return new h5e(e, t, n, r);
}
function v5e(e) {
  var t;
  if (e.indexOf("data:") === -1)
    throw new Error("File is invalid: URI must be a dataURI");
  const n = e.slice(5).split(";base64,");
  if (n.length !== 2)
    throw new Error("File is invalid: dataURI must be base64");
  const [r, a] = n, [s, ...l] = r.split(";"), c = s || "", d = decodeURI(
    // parse the parameters into key-value pairs, find a key, and extract a value
    // if no key is found, then the name is unknown
    ((t = l.map((f) => f.split("=")).find(([f]) => f === "name")) === null || t === void 0 ? void 0 : t[1]) || "unknown"
  );
  try {
    const f = atob(a), m = new Array(f.length);
    for (let h = 0; h < f.length; h++)
      m[h] = f.charCodeAt(h);
    return { blob: new window.Blob([new Uint8Array(m)], { type: c }), name: d };
  } catch (f) {
    throw new Error("File is invalid: " + f.message);
  }
}
function fd(e, t) {
  let n = String(e);
  for (; n.length < t; )
    n = "0" + n;
  return n;
}
function pK(e, t) {
  if (e <= 0 && t <= 0)
    e = (/* @__PURE__ */ new Date()).getFullYear() + e, t = (/* @__PURE__ */ new Date()).getFullYear() + t;
  else if (e < 0 || t < 0)
    throw new Error(`Both start (${e}) and stop (${t}) must both be <= 0 or > 0, got one of each`);
  if (e > t)
    return pK(t, e).reverse();
  const n = [];
  for (let r = e; r <= t; r++)
    n.push({ value: r, label: fd(r, 2) });
  return n;
}
function Kz(e, t) {
  if (Object.is(e, t))
    return !0;
  if (e == null || t == null || typeof e != "object" || typeof t != "object")
    return !1;
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length)
    return !1;
  for (let a = 0; a < n.length; a++) {
    const s = n[a];
    if (!Object.prototype.hasOwnProperty.call(t, s) || !Object.is(e[s], t[s]))
      return !1;
  }
  return !0;
}
function y5e(e, t) {
  let n = e;
  if (Array.isArray(t)) {
    const r = n.split(/(%\d)/);
    t.forEach((a, s) => {
      const l = r.findIndex((c) => c === `%${s + 1}`);
      l >= 0 && (r[l] = a);
    }), n = r.join("");
  }
  return n;
}
function b5e(e, t) {
  return y5e(e, t);
}
function ao(e, t = [], n) {
  if (Array.isArray(e))
    return e.map((s) => ao(s, t)).filter((s) => s !== n);
  const r = e === "" || e === null ? -1 : Number(e), a = t[r];
  return a ? a.value : n;
}
function mK(e, t, n = []) {
  const r = ao(e, n);
  return Array.isArray(t) ? t.filter((a) => !er(a, r)) : er(r, t) ? void 0 : t;
}
function CC(e, t) {
  return Array.isArray(t) ? t.some((n) => er(n, e)) : er(t, e);
}
function Zj(e, t = [], n = !1) {
  const r = t.map((a, s) => CC(a.value, e) ? String(s) : void 0).filter((a) => typeof a < "u");
  return n ? r : r[0];
}
function hK(e, t, n = []) {
  const r = ao(e, n);
  if (!V2(r)) {
    const a = n.findIndex((l) => r === l.value), s = n.map(({ value: l }) => l);
    return t.slice(0, a).concat(r, t.slice(a)).sort((l, c) => +(s.indexOf(l) > s.indexOf(c)));
  }
  return t;
}
var w5e = 1, x5e = 4;
function eP(e) {
  return Tx(e, w5e | x5e);
}
function S5e(e, t, n, r) {
  return r = typeof r == "function" ? r : void 0, e == null ? e : Fj(e, t, n, r);
}
class gK {
  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.
   *
   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class
   */
  constructor(t) {
    this.errorSchema = {}, this.resetAllErrors(t);
  }
  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`
   */
  get ErrorSchema() {
    return this.errorSchema;
  }
  /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.
   *
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)
   * @returns - The error block for the given `pathOfError` or the root if not provided
   * @private
   */
  getOrCreateErrorBlock(t) {
    let n = Array.isArray(t) && t.length > 0 || typeof t == "string" ? Re(this.errorSchema, t) : this.errorSchema;
    return !n && t && (n = {}, S5e(this.errorSchema, t, n, Object)), n;
  }
  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.
   *
   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  resetAllErrors(t) {
    return this.errorSchema = t ? eP(t) : {}, this;
  }
  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within
   * the schema described by the `pathOfError`. For more information about how to specify the path see the
   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
   *
   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  addErrors(t, n) {
    const r = this.getOrCreateErrorBlock(n);
    let a = Re(r, zo);
    return Array.isArray(a) || (a = [], r[zo] = a), Array.isArray(t) ? zn(r, zo, [.../* @__PURE__ */ new Set([...a, ...t])]) : zn(r, zo, [.../* @__PURE__ */ new Set([...a, t])]), this;
  }
  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location
   * within the schema described by the `pathOfError`. For more information about how to specify the path see the
   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
   *
   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  setErrors(t, n) {
    const r = this.getOrCreateErrorBlock(n), a = Array.isArray(t) ? [.../* @__PURE__ */ new Set([...t])] : [t];
    return zn(r, zo, a), this;
  }
  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by
   * the `pathOfError`. For more information about how to specify the path see the
   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
   *
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  clearErrors(t) {
    const n = this.getOrCreateErrorBlock(t);
    return zn(n, zo, []), this;
  }
}
function vK(e, t, n) {
  for (var r = -1, a = t.length, s = {}; ++r < a; ) {
    var l = t[r], c = SC(e, l);
    n(c, l) && Fj(s, qg(l, e), c);
  }
  return s;
}
function k5e(e, t) {
  if (e == null)
    return {};
  var n = Wg(qj(e), function(r) {
    return [r];
  });
  return t = Uj(t), vK(e, n, function(r, a) {
    return t(r, a[0]);
  });
}
var _5e = 200;
function E5e(e, t, n, r) {
  var a = -1, s = Wj, l = !0, c = e.length, d = [], f = t.length;
  if (!c)
    return d;
  t.length >= _5e && (s = SS, l = !1, t = new Hm(t));
  e:
    for (; ++a < c; ) {
      var m = e[a], h = m;
      if (m = m !== 0 ? m : 0, l && h === h) {
        for (var v = f; v--; )
          if (t[v] === h)
            continue e;
        d.push(m);
      } else s(t, h, r) || d.push(m);
    }
  return d;
}
var C5e = _C(function(e, t) {
  return _S(e) ? E5e(e, _k(t, 1, _S, !0)) : [];
});
function Yz(e, t) {
  const n = Id(e), r = Id(t);
  if (e === t || !n && !r)
    return [];
  if (n && !r)
    return qs(e);
  if (!n && r)
    return qs(t);
  {
    const a = qs(k5e(e, (l, c) => !er(l, Re(t, c)))), s = C5e(qs(t), qs(e));
    return [...a, ...s];
  }
}
function O5e(e, t, n = [1900, (/* @__PURE__ */ new Date()).getFullYear() + 2], r = "YMD") {
  const { day: a, month: s, year: l, hour: c, minute: d, second: f } = e, m = { type: "day", range: [1, 31], value: a }, h = { type: "month", range: [1, 12], value: s }, v = { type: "year", range: n, value: l }, g = [];
  switch (r) {
    case "MDY":
      g.push(h, m, v);
      break;
    case "DMY":
      g.push(m, h, v);
      break;
    default:
      g.push(v, h, m);
  }
  return t && g.push({ type: "hour", range: [0, 23], value: c }, { type: "minute", range: [0, 59], value: d }, { type: "second", range: [0, 59], value: f }), g;
}
function yK(e) {
  const t = {};
  return e.multipleOf && (t.step = e.multipleOf), (e.minimum || e.minimum === 0) && (t.min = e.minimum), (e.maximum || e.maximum === 0) && (t.max = e.maximum), t;
}
function bK(e, t, n = {}, r = !0) {
  const a = {
    type: t || "text",
    ...yK(e)
  };
  return n.inputType ? a.type = n.inputType : t || (e.type === "number" ? (a.type = "number", r && a.step === void 0 && (a.step = "any")) : e.type === "integer" && (a.type = "number", a.step === void 0 && (a.step = 1))), n.autocomplete && (a.autoComplete = n.autocomplete), n.accept && (a.accept = n.accept), a;
}
const Xz = {
  props: {
    disabled: !1
  },
  submitText: "Submit",
  norender: !1
};
function wK(e = {}) {
  const t = vt(e);
  if (t && t[L2]) {
    const n = t[L2];
    return { ...Xz, ...n };
  }
  return Xz;
}
function xt(e, t, n = {}) {
  const { templates: r } = t;
  if (e === "ButtonTemplates")
    return r[e];
  if (Object.hasOwn(n, e) && typeof n[e] == "string" && Object.hasOwn(r, n[e])) {
    const a = n[e];
    return r[a];
  }
  return (
    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent
    // To avoid that, we cast uiOptions to `any` before accessing the name field
    n[e] || r[e]
  );
}
var M5e = 0;
function xK(e) {
  var t = ++M5e;
  return zj(e) + t;
}
function tP() {
  if (typeof process > "u" || Re(process, "env.NODE_ENV") !== "test")
    return {};
  const e = /* @__PURE__ */ new Map();
  return new Proxy({}, {
    get(t, n) {
      return e.has(n) || e.set(n, xK("test-id-")), e.get(n);
    }
  });
}
var Jz = { exports: {} }, En = {}, Qz;
function N5e() {
  if (Qz) return En;
  Qz = 1;
  var e = /* @__PURE__ */ Symbol.for("react.element"), t = /* @__PURE__ */ Symbol.for("react.portal"), n = /* @__PURE__ */ Symbol.for("react.fragment"), r = /* @__PURE__ */ Symbol.for("react.strict_mode"), a = /* @__PURE__ */ Symbol.for("react.profiler"), s = /* @__PURE__ */ Symbol.for("react.provider"), l = /* @__PURE__ */ Symbol.for("react.context"), c = /* @__PURE__ */ Symbol.for("react.server_context"), d = /* @__PURE__ */ Symbol.for("react.forward_ref"), f = /* @__PURE__ */ Symbol.for("react.suspense"), m = /* @__PURE__ */ Symbol.for("react.suspense_list"), h = /* @__PURE__ */ Symbol.for("react.memo"), v = /* @__PURE__ */ Symbol.for("react.lazy"), g = /* @__PURE__ */ Symbol.for("react.offscreen"), b;
  b = /* @__PURE__ */ Symbol.for("react.module.reference");
  function x(w) {
    if (typeof w == "object" && w !== null) {
      var k = w.$$typeof;
      switch (k) {
        case e:
          switch (w = w.type, w) {
            case n:
            case a:
            case r:
            case f:
            case m:
              return w;
            default:
              switch (w = w && w.$$typeof, w) {
                case c:
                case l:
                case d:
                case v:
                case h:
                case s:
                  return w;
                default:
                  return k;
              }
          }
        case t:
          return k;
      }
    }
  }
  return En.ContextConsumer = l, En.ContextProvider = s, En.Element = e, En.ForwardRef = d, En.Fragment = n, En.Lazy = v, En.Memo = h, En.Portal = t, En.Profiler = a, En.StrictMode = r, En.Suspense = f, En.SuspenseList = m, En.isAsyncMode = function() {
    return !1;
  }, En.isConcurrentMode = function() {
    return !1;
  }, En.isContextConsumer = function(w) {
    return x(w) === l;
  }, En.isContextProvider = function(w) {
    return x(w) === s;
  }, En.isElement = function(w) {
    return typeof w == "object" && w !== null && w.$$typeof === e;
  }, En.isForwardRef = function(w) {
    return x(w) === d;
  }, En.isFragment = function(w) {
    return x(w) === n;
  }, En.isLazy = function(w) {
    return x(w) === v;
  }, En.isMemo = function(w) {
    return x(w) === h;
  }, En.isPortal = function(w) {
    return x(w) === t;
  }, En.isProfiler = function(w) {
    return x(w) === a;
  }, En.isStrictMode = function(w) {
    return x(w) === r;
  }, En.isSuspense = function(w) {
    return x(w) === f;
  }, En.isSuspenseList = function(w) {
    return x(w) === m;
  }, En.isValidElementType = function(w) {
    return typeof w == "string" || typeof w == "function" || w === n || w === a || w === r || w === f || w === m || w === g || typeof w == "object" && w !== null && (w.$$typeof === v || w.$$typeof === h || w.$$typeof === s || w.$$typeof === l || w.$$typeof === d || w.$$typeof === b || w.getModuleId !== void 0);
  }, En.typeOf = x, En;
}
var Zz;
function A5e() {
  return Zz || (Zz = 1, Jz.exports = N5e()), Jz.exports;
}
var R5e = A5e();
const eT = /* @__PURE__ */ Gc(R5e), M5 = {
  boolean: {
    checkbox: "CheckboxWidget",
    radio: "RadioWidget",
    select: "SelectWidget",
    hidden: "HiddenWidget"
  },
  string: {
    text: "TextWidget",
    password: "PasswordWidget",
    email: "EmailWidget",
    hostname: "TextWidget",
    ipv4: "TextWidget",
    ipv6: "TextWidget",
    uri: "URLWidget",
    "data-url": "FileWidget",
    radio: "RadioWidget",
    select: "SelectWidget",
    textarea: "TextareaWidget",
    hidden: "HiddenWidget",
    date: "DateWidget",
    datetime: "DateTimeWidget",
    "date-time": "DateTimeWidget",
    "alt-date": "AltDateWidget",
    "alt-datetime": "AltDateTimeWidget",
    time: "TimeWidget",
    color: "ColorWidget",
    file: "FileWidget"
  },
  number: {
    text: "TextWidget",
    select: "SelectWidget",
    updown: "UpDownWidget",
    range: "RangeWidget",
    radio: "RadioWidget",
    hidden: "HiddenWidget"
  },
  integer: {
    text: "TextWidget",
    select: "SelectWidget",
    updown: "UpDownWidget",
    range: "RangeWidget",
    radio: "RadioWidget",
    hidden: "HiddenWidget"
  },
  array: {
    select: "SelectWidget",
    checkboxes: "CheckboxesWidget",
    files: "FileWidget",
    hidden: "HiddenWidget"
  }
};
function j5e(e) {
  let t = Re(e, "MergedWidget");
  if (!t) {
    const n = e.defaultProps && e.defaultProps.options || {};
    t = ({ options: r, ...a }) => C.jsx(e, { options: { ...n, ...r }, ...a }), zn(e, "MergedWidget", t);
  }
  return t;
}
function ql(e, t, n = {}) {
  const r = rl(e);
  if (typeof t == "function" || t && eT.isForwardRef(M.createElement(t)) || eT.isMemo(t))
    return j5e(t);
  if (typeof t != "string")
    throw new Error(`Unsupported widget definition: ${typeof t} in schema: ${JSON.stringify(e)}`);
  if (t in n) {
    const a = n[t];
    return ql(e, a, n);
  }
  if (typeof r == "string") {
    if (!(r in M5))
      throw new Error(`No widget for type '${r}' in schema: ${JSON.stringify(e)}`);
    if (t in M5[r]) {
      const a = n[M5[r][t]];
      return ql(e, a, n);
    }
  }
  throw new Error(`No widget '${t}' for type '${r}' in schema: ${JSON.stringify(e)}`);
}
function P5e(e) {
  let t = 0;
  for (let n = 0; n < e.length; n += 1) {
    const r = e.charCodeAt(n);
    t = (t << 5) - t + r, t = t & t;
  }
  return t.toString(16);
}
function D5e(e) {
  const t = /* @__PURE__ */ new Set();
  return JSON.stringify(e, (n, r) => (t.add(n), r)), JSON.stringify(e, Array.from(t).sort());
}
function Rl(e) {
  return P5e(D5e(e));
}
function I5e(e) {
  return Rl(e);
}
function $5e(e, t, n = {}) {
  try {
    return ql(e, t, n), !0;
  } catch (r) {
    const a = r;
    if (a.message && (a.message.startsWith("No widget") || a.message.startsWith("Unsupported widget")))
      return !1;
    throw r;
  }
}
function oh(e, t) {
  return `${$d(e) ? e : e[Ln]}__${t}`;
}
function ah(e) {
  return oh(e, "description");
}
function nP(e) {
  return oh(e, "error");
}
function AS(e) {
  return oh(e, "examples");
}
function rP(e) {
  return oh(e, "help");
}
function OC(e) {
  return oh(e, "title");
}
function ji(e, t = !1) {
  const n = t ? ` ${AS(e)}` : "";
  return `${nP(e)} ${ah(e)} ${rP(e)}${n}`;
}
function MC(e, t) {
  return `${e}-${t}`;
}
function jl(e, t) {
  return oh(e, t);
}
function N5(e, t) {
  return oh(e, `optional${t}`);
}
function Kg(e) {
  return !V2(e) && (!mn(e) || Array.isArray(e) || !$r(e));
}
function z5e(e, t) {
  const { rootSchema: n, schemaUtils: r } = e;
  if (kS(t, n))
    return !0;
  if (cr in n) {
    const a = r.retrieveSchema(n);
    return kS(t, a);
  }
  return !1;
}
function ih(e, t, n) {
  return t ? n : e;
}
function T5e(e) {
  return e ? new Date(e).toJSON() : void 0;
}
function oP(e, t, n) {
  const r = [e2e];
  return rn(e, tz) && r.unshift(tz), Re(e, [...r, t], n);
}
function L5e(e, t) {
  if (!Array.isArray(t))
    return e;
  const n = (m) => m.reduce((h, v) => (h[v] = !0, h), {}), r = (m) => m.length > 1 ? `properties '${m.join("', '")}'` : `property '${m[0]}'`, a = n(e), s = t.filter((m) => m === "*" || a[m]), l = n(s), c = e.filter((m) => !l[m]), d = s.indexOf("*");
  if (d === -1) {
    if (c.length)
      throw new Error(`uiSchema order list does not contain ${r(c)}`);
    return s;
  }
  if (d !== s.lastIndexOf("*"))
    throw new Error("uiSchema order list contains more than one wildcard item");
  const f = [...s];
  return f.splice(d, 1, ...c), f;
}
function A5(e, t = !0) {
  if (!e)
    return {
      year: -1,
      month: -1,
      day: -1,
      hour: t ? -1 : 0,
      minute: t ? -1 : 0,
      second: t ? -1 : 0
    };
  const n = new Date(e);
  if (Number.isNaN(n.getTime()))
    throw new Error("Unable to parse date " + e);
  return {
    year: n.getUTCFullYear(),
    month: n.getUTCMonth() + 1,
    // oh you, javascript.
    day: n.getUTCDate(),
    hour: t ? n.getUTCHours() : 0,
    minute: t ? n.getUTCMinutes() : 0,
    second: t ? n.getUTCSeconds() : 0
  };
}
function Lx(e) {
  if (e.const || e.enum && e.enum.length === 1 && e.enum[0] === !0)
    return !0;
  if (e.anyOf && e.anyOf.length === 1)
    return Lx(e.anyOf[0]);
  if (e.oneOf && e.oneOf.length === 1)
    return Lx(e.oneOf[0]);
  if (e.allOf) {
    const t = (n) => Lx(n);
    return e.allOf.some(t);
  }
  return !1;
}
function SK(e, t, n, r = "customDeep") {
  if (r === "always")
    return !0;
  if (r === "shallow") {
    const { props: l, state: c } = e;
    return !Kz(l, t) || !Kz(c, n);
  }
  const { props: a, state: s } = e;
  return !er(a, t) || !er(s, n);
}
function tT(e) {
  const t = TG(e.map((n) => mn(n) ? rl(n) : void 0).flat().filter((n) => n !== void 0));
  return t.length === 1 ? t[0] : t;
}
function Ek(e, t, n, r) {
  const { enableOptionalDataFieldForType: a = [] } = vt(r, e.globalUiOptions);
  let s;
  return dn in t && Array.isArray(t[dn]) ? s = tT(t[dn]) : Kt in t && Array.isArray(t[Kt]) ? s = tT(t[Kt]) : s = rl(t), !z5e(e, t) && !n && !!s && !Array.isArray(s) && !!a.find((l) => l === s);
}
function nT(e, t = !0) {
  const { year: n, month: r, day: a, hour: s = 0, minute: l = 0, second: c = 0 } = e, d = Date.UTC(n, r - 1, a, s, l, c), f = new Date(d).toJSON();
  return t ? f : f.slice(0, 10);
}
function aP(e, t = []) {
  if (!e)
    return [];
  let n = [];
  return zo in e && (n = n.concat(e[zo].map((r) => {
    const a = `.${t.join(".")}`;
    return {
      property: a,
      message: r,
      stack: `${a} ${r}`
    };
  }))), Object.keys(e).reduce((r, a) => {
    if (a !== zo) {
      const s = e[a];
      Id(s) && (r = r.concat(aP(s, [...t, a])));
    }
    return r;
  }, n);
}
function kK(e) {
  return oo(e) ? Wg(e, rh) : Sk(e) ? [e] : Hj(vG(zj(e)));
}
function F5e(e) {
  const t = new gK();
  return e.length && e.forEach((n) => {
    const { property: r, message: a } = n, s = r === "." ? [] : kK(r);
    s.length > 0 && s[0] === "" && s.splice(0, 1), a && t.addErrors(a, s);
  }), t.ErrorSchema;
}
function Yi(e, t, n, r) {
  const a = Array.isArray(n) ? n : n?.path, s = e === "" ? [] : [e], l = a ? a.concat(...s) : s, c = [t.idPrefix, ...l].join(t.idSeparator);
  let d;
  return t.nameGenerator && l.length > 0 && (d = t.nameGenerator(l, t.idPrefix, r)), { path: l, [Ln]: c, ...d !== void 0 && { name: d } };
}
function _K(e) {
  return Object.keys(e).reduce((t, n) => {
    if (n === "addError")
      return t;
    {
      const r = e[n];
      return Id(r) ? {
        ...t,
        [n]: _K(r)
      } : { ...t, [n]: r };
    }
  }, {});
}
function B5e(e) {
  return Object.values(e).every((t) => t !== -1);
}
function U5e(e) {
  const { className: t = "form-control", type: n, range: r, value: a, select: s, rootId: l, name: c, disabled: d, readonly: f, autofocus: m, registry: h, onBlur: v, onFocus: g } = e, b = `${l}_${n}`, { SelectWidget: x } = h.widgets, w = M.useCallback((k) => s(n, k), [s, n]);
  return C.jsx(x, { schema: { type: "integer" }, id: b, name: c, className: t, options: { enumOptions: pK(r[0], r[1]) }, placeholder: n, value: a, disabled: d, readonly: f, autofocus: m, onChange: w, onBlur: v, onFocus: g, registry: h, label: "", "aria-describedby": ji(l) });
}
function V5e(e) {
  const { time: t = !1, disabled: n = !1, readonly: r = !1, options: a, onChange: s, value: l } = e, [c, d] = M.useState(A5(l, t));
  M.useEffect(() => {
    d(A5(l, t));
  }, [t, l]);
  const f = M.useCallback((v, g) => {
    const b = {
      ...c,
      [v]: typeof g > "u" ? -1 : g
    };
    B5e(b) ? s(nT(b, t)) : d(b);
  }, [c, s, t]), m = M.useCallback((v) => {
    v.preventDefault(), !(n || r) && s(void 0);
  }, [n, r, s]), h = M.useCallback((v) => {
    if (v.preventDefault(), n || r)
      return;
    const g = A5((/* @__PURE__ */ new Date()).toJSON(), t);
    s(nT(g, t));
  }, [n, r, t, s]);
  return { elements: M.useMemo(() => O5e(c, t, a.yearsRange, a.format), [c, t, a.yearsRange, a.format]), handleChange: f, handleClear: m, handleSetNow: h };
}
function sh(e) {
  const t = M.useRef(e);
  return kS(e, t.current) || (t.current = e), t.current;
}
function H5e(e, t) {
  return e.replace(";base64", `;name=${encodeURIComponent(t)};base64`);
}
function W5e(e) {
  const { name: t, size: n, type: r } = e;
  return new Promise((a, s) => {
    const l = new window.FileReader();
    l.onerror = s, l.onload = (c) => {
      var d;
      typeof ((d = c.target) === null || d === void 0 ? void 0 : d.result) == "string" ? a({
        dataURL: H5e(c.target.result, t),
        name: t,
        size: n,
        type: r
      }) : a({
        dataURL: null,
        name: t,
        size: n,
        type: r
      });
    }, l.readAsDataURL(e);
  });
}
function q5e(e) {
  return Promise.all(Array.from(e).map(W5e));
}
function rT(e) {
  return e.reduce((t, n) => {
    if (!n)
      return t;
    try {
      const { blob: r, name: a } = v5e(n);
      return [
        ...t,
        {
          dataURL: n,
          name: a,
          size: r.size,
          type: r.type
        }
      ];
    } catch {
      return t;
    }
  }, []);
}
function G5e(e, t, n = !1) {
  const r = M.useMemo(() => n && e ? Array.isArray(e) ? e : [e] : [], [e, n]), a = M.useMemo(() => Array.isArray(e) ? rT(e) : rT([e || ""]), [e]), s = M.useCallback((c) => {
    q5e(c).then((d) => {
      const f = d.map((m) => m.dataURL || null);
      t(n ? r.concat(...f) : f[0]);
    });
  }, [r, n, t]), l = M.useCallback((c) => {
    if (n) {
      const d = r.filter((f, m) => m !== c);
      t(d);
    } else
      t(void 0);
  }, [r, n, t]);
  return { filesInfo: a, handleChange: s, handleRemove: l };
}
function K5e(e) {
  if (!e)
    return "";
  const t = new Date(e), n = fd(t.getFullYear(), 4), r = fd(t.getMonth() + 1, 2), a = fd(t.getDate(), 2), s = fd(t.getHours(), 2), l = fd(t.getMinutes(), 2), c = fd(t.getSeconds(), 2), d = fd(t.getMilliseconds(), 3);
  return `${n}-${r}-${a}T${s}:${l}:${c}.${d}`;
}
function K_(e, t, n = !1) {
  if (!t)
    return e;
  const { errors: r, errorSchema: a } = e;
  let s = aP(t), l = t;
  return $r(a) || (l = NS(a, t, n ? "preventDuplicates" : !0), s = [...r].concat(s)), { errorSchema: l, errors: s };
}
function Y5e(e) {
  for (const t in e) {
    const n = e, r = n[t];
    t === cr && typeof r == "string" && r.startsWith("#") ? n[t] = nG + r : n[t] = iP(r);
  }
  return e;
}
function X5e(e) {
  for (let t = 0; t < e.length; t++)
    e[t] = iP(e[t]);
  return e;
}
function iP(e) {
  return Array.isArray(e) ? X5e([...e]) : mn(e) ? Y5e({ ...e }) : e;
}
var Jt;
(function(e) {
  e.ArrayItemTitle = "Item", e.MissingItems = "Missing items definition", e.EmptyArray = "No items yet. Use the button below to add some.", e.YesLabel = "Yes", e.NoLabel = "No", e.CloseLabel = "Close", e.ErrorsLabel = "Errors", e.NewStringDefault = "New Value", e.AddButton = "Add", e.AddItemButton = "Add Item", e.CopyButton = "Copy", e.MoveDownButton = "Move down", e.MoveUpButton = "Move up", e.RemoveButton = "Remove", e.NowLabel = "Now", e.ClearLabel = "Clear", e.AriaDateLabel = "Select a date", e.PreviewLabel = "Preview", e.DecrementAriaLabel = "Decrease value by 1", e.IncrementAriaLabel = "Increase value by 1", e.OptionalObjectAdd = "Add data for optional field", e.OptionalObjectRemove = "Remove data for optional field", e.OptionalObjectEmptyMsg = "No data for optional field", e.Type = "Type", e.Value = "Value", e.UnknownFieldType = "Unknown field type %1", e.OptionPrefix = "Option %1", e.TitleOptionPrefix = "%1 option %2", e.KeyLabel = "%1 Key", e.InvalidObjectField = 'Invalid "%1" object field configuration: _%2_.', e.UnsupportedField = "Unsupported field schema.", e.UnsupportedFieldWithId = "Unsupported field schema for field `%1`.", e.UnsupportedFieldWithReason = "Unsupported field schema: _%1_.", e.UnsupportedFieldWithIdAndReason = "Unsupported field schema for field `%1`: _%2_.", e.FilesInfo = "**%1** (%2, %3 bytes)";
})(Jt || (Jt = {}));
function J5e(e, t) {
  var n = oo(e) ? Bj : iK;
  return n(e, wG(t));
}
var R5 = { exports: {} }, oT = {}, wc = {}, pm = {}, aT = {}, iT = {}, sT = {}, lT;
function H2() {
  return lT || (lT = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.regexpCode = e.getEsmExportName = e.getProperty = e.safeStringify = e.stringify = e.strConcat = e.addCodeArg = e.str = e._ = e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0;
    class t {
    }
    e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class n extends t {
      constructor(E) {
        if (super(), !e.IDENTIFIER.test(E))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = E;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    e.Name = n;
    class r extends t {
      constructor(E) {
        super(), this._items = typeof E == "string" ? [E] : E;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return !1;
        const E = this._items[0];
        return E === "" || E === '""';
      }
      get str() {
        var E;
        return (E = this._str) !== null && E !== void 0 ? E : this._str = this._items.reduce((_, O) => `${_}${O}`, "");
      }
      get names() {
        var E;
        return (E = this._names) !== null && E !== void 0 ? E : this._names = this._items.reduce((_, O) => (O instanceof n && (_[O.str] = (_[O.str] || 0) + 1), _), {});
      }
    }
    e._Code = r, e.nil = new r("");
    function a(k, ...E) {
      const _ = [k[0]];
      let O = 0;
      for (; O < E.length; )
        c(_, E[O]), _.push(k[++O]);
      return new r(_);
    }
    e._ = a;
    const s = new r("+");
    function l(k, ...E) {
      const _ = [g(k[0])];
      let O = 0;
      for (; O < E.length; )
        _.push(s), c(_, E[O]), _.push(s, g(k[++O]));
      return d(_), new r(_);
    }
    e.str = l;
    function c(k, E) {
      E instanceof r ? k.push(...E._items) : E instanceof n ? k.push(E) : k.push(h(E));
    }
    e.addCodeArg = c;
    function d(k) {
      let E = 1;
      for (; E < k.length - 1; ) {
        if (k[E] === s) {
          const _ = f(k[E - 1], k[E + 1]);
          if (_ !== void 0) {
            k.splice(E - 1, 3, _);
            continue;
          }
          k[E++] = "+";
        }
        E++;
      }
    }
    function f(k, E) {
      if (E === '""')
        return k;
      if (k === '""')
        return E;
      if (typeof k == "string")
        return E instanceof n || k[k.length - 1] !== '"' ? void 0 : typeof E != "string" ? `${k.slice(0, -1)}${E}"` : E[0] === '"' ? k.slice(0, -1) + E.slice(1) : void 0;
      if (typeof E == "string" && E[0] === '"' && !(k instanceof n))
        return `"${k}${E.slice(1)}`;
    }
    function m(k, E) {
      return E.emptyStr() ? k : k.emptyStr() ? E : l`${k}${E}`;
    }
    e.strConcat = m;
    function h(k) {
      return typeof k == "number" || typeof k == "boolean" || k === null ? k : g(Array.isArray(k) ? k.join(",") : k);
    }
    function v(k) {
      return new r(g(k));
    }
    e.stringify = v;
    function g(k) {
      return JSON.stringify(k).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    e.safeStringify = g;
    function b(k) {
      return typeof k == "string" && e.IDENTIFIER.test(k) ? new r(`.${k}`) : a`[${k}]`;
    }
    e.getProperty = b;
    function x(k) {
      if (typeof k == "string" && e.IDENTIFIER.test(k))
        return new r(`${k}`);
      throw new Error(`CodeGen: invalid export name: ${k}, use explicit $id name mapping`);
    }
    e.getEsmExportName = x;
    function w(k) {
      return new r(k.toString());
    }
    e.regexpCode = w;
  })(sT)), sT;
}
var uT = {}, cT;
function dT() {
  return cT || (cT = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
    const t = H2();
    class n extends Error {
      constructor(f) {
        super(`CodeGen: "code" for ${f} not defined`), this.value = f.value;
      }
    }
    var r;
    (function(d) {
      d[d.Started = 0] = "Started", d[d.Completed = 1] = "Completed";
    })(r || (e.UsedValueState = r = {})), e.varKinds = {
      const: new t.Name("const"),
      let: new t.Name("let"),
      var: new t.Name("var")
    };
    class a {
      constructor({ prefixes: f, parent: m } = {}) {
        this._names = {}, this._prefixes = f, this._parent = m;
      }
      toName(f) {
        return f instanceof t.Name ? f : this.name(f);
      }
      name(f) {
        return new t.Name(this._newName(f));
      }
      _newName(f) {
        const m = this._names[f] || this._nameGroup(f);
        return `${f}${m.index++}`;
      }
      _nameGroup(f) {
        var m, h;
        if (!((h = (m = this._parent) === null || m === void 0 ? void 0 : m._prefixes) === null || h === void 0) && h.has(f) || this._prefixes && !this._prefixes.has(f))
          throw new Error(`CodeGen: prefix "${f}" is not allowed in this scope`);
        return this._names[f] = { prefix: f, index: 0 };
      }
    }
    e.Scope = a;
    class s extends t.Name {
      constructor(f, m) {
        super(m), this.prefix = f;
      }
      setValue(f, { property: m, itemIndex: h }) {
        this.value = f, this.scopePath = (0, t._)`.${new t.Name(m)}[${h}]`;
      }
    }
    e.ValueScopeName = s;
    const l = (0, t._)`\n`;
    class c extends a {
      constructor(f) {
        super(f), this._values = {}, this._scope = f.scope, this.opts = { ...f, _n: f.lines ? l : t.nil };
      }
      get() {
        return this._scope;
      }
      name(f) {
        return new s(f, this._newName(f));
      }
      value(f, m) {
        var h;
        if (m.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const v = this.toName(f), { prefix: g } = v, b = (h = m.key) !== null && h !== void 0 ? h : m.ref;
        let x = this._values[g];
        if (x) {
          const E = x.get(b);
          if (E)
            return E;
        } else
          x = this._values[g] = /* @__PURE__ */ new Map();
        x.set(b, v);
        const w = this._scope[g] || (this._scope[g] = []), k = w.length;
        return w[k] = m.ref, v.setValue(m, { property: g, itemIndex: k }), v;
      }
      getValue(f, m) {
        const h = this._values[f];
        if (h)
          return h.get(m);
      }
      scopeRefs(f, m = this._values) {
        return this._reduceValues(m, (h) => {
          if (h.scopePath === void 0)
            throw new Error(`CodeGen: name "${h}" has no value`);
          return (0, t._)`${f}${h.scopePath}`;
        });
      }
      scopeCode(f = this._values, m, h) {
        return this._reduceValues(f, (v) => {
          if (v.value === void 0)
            throw new Error(`CodeGen: name "${v}" has no value`);
          return v.value.code;
        }, m, h);
      }
      _reduceValues(f, m, h = {}, v) {
        let g = t.nil;
        for (const b in f) {
          const x = f[b];
          if (!x)
            continue;
          const w = h[b] = h[b] || /* @__PURE__ */ new Map();
          x.forEach((k) => {
            if (w.has(k))
              return;
            w.set(k, r.Started);
            let E = m(k);
            if (E) {
              const _ = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
              g = (0, t._)`${g}${_} ${k} = ${E};${this.opts._n}`;
            } else if (E = v?.(k))
              g = (0, t._)`${g}${E}${this.opts._n}`;
            else
              throw new n(k);
            w.set(k, r.Completed);
          });
        }
        return g;
      }
    }
    e.ValueScope = c;
  })(uT)), uT;
}
var fT;
function Yt() {
  return fT || (fT = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
    const t = H2(), n = dT();
    var r = H2();
    Object.defineProperty(e, "_", { enumerable: !0, get: function() {
      return r._;
    } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
      return r.str;
    } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
      return r.strConcat;
    } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
      return r.nil;
    } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
      return r.getProperty;
    } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
      return r.stringify;
    } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
      return r.regexpCode;
    } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
      return r.Name;
    } });
    var a = dT();
    Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
      return a.Scope;
    } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
      return a.ValueScope;
    } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
      return a.ValueScopeName;
    } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
      return a.varKinds;
    } }), e.operators = {
      GT: new t._Code(">"),
      GTE: new t._Code(">="),
      LT: new t._Code("<"),
      LTE: new t._Code("<="),
      EQ: new t._Code("==="),
      NEQ: new t._Code("!=="),
      NOT: new t._Code("!"),
      OR: new t._Code("||"),
      AND: new t._Code("&&"),
      ADD: new t._Code("+")
    };
    class s {
      optimizeNodes() {
        return this;
      }
      optimizeNames(W, J) {
        return this;
      }
    }
    class l extends s {
      constructor(W, J, oe) {
        super(), this.varKind = W, this.name = J, this.rhs = oe;
      }
      render({ es5: W, _n: J }) {
        const oe = W ? n.varKinds.var : this.varKind, fe = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${oe} ${this.name}${fe};` + J;
      }
      optimizeNames(W, J) {
        if (W[this.name.str])
          return this.rhs && (this.rhs = L(this.rhs, W, J)), this;
      }
      get names() {
        return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
      }
    }
    class c extends s {
      constructor(W, J, oe) {
        super(), this.lhs = W, this.rhs = J, this.sideEffects = oe;
      }
      render({ _n: W }) {
        return `${this.lhs} = ${this.rhs};` + W;
      }
      optimizeNames(W, J) {
        if (!(this.lhs instanceof t.Name && !W[this.lhs.str] && !this.sideEffects))
          return this.rhs = L(this.rhs, W, J), this;
      }
      get names() {
        const W = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
        return H(W, this.rhs);
      }
    }
    class d extends c {
      constructor(W, J, oe, fe) {
        super(W, oe, fe), this.op = J;
      }
      render({ _n: W }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + W;
      }
    }
    class f extends s {
      constructor(W) {
        super(), this.label = W, this.names = {};
      }
      render({ _n: W }) {
        return `${this.label}:` + W;
      }
    }
    class m extends s {
      constructor(W) {
        super(), this.label = W, this.names = {};
      }
      render({ _n: W }) {
        return `break${this.label ? ` ${this.label}` : ""};` + W;
      }
    }
    class h extends s {
      constructor(W) {
        super(), this.error = W;
      }
      render({ _n: W }) {
        return `throw ${this.error};` + W;
      }
      get names() {
        return this.error.names;
      }
    }
    class v extends s {
      constructor(W) {
        super(), this.code = W;
      }
      render({ _n: W }) {
        return `${this.code};` + W;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(W, J) {
        return this.code = L(this.code, W, J), this;
      }
      get names() {
        return this.code instanceof t._CodeOrName ? this.code.names : {};
      }
    }
    class g extends s {
      constructor(W = []) {
        super(), this.nodes = W;
      }
      render(W) {
        return this.nodes.reduce((J, oe) => J + oe.render(W), "");
      }
      optimizeNodes() {
        const { nodes: W } = this;
        let J = W.length;
        for (; J--; ) {
          const oe = W[J].optimizeNodes();
          Array.isArray(oe) ? W.splice(J, 1, ...oe) : oe ? W[J] = oe : W.splice(J, 1);
        }
        return W.length > 0 ? this : void 0;
      }
      optimizeNames(W, J) {
        const { nodes: oe } = this;
        let fe = oe.length;
        for (; fe--; ) {
          const ie = oe[fe];
          ie.optimizeNames(W, J) || (G(W, ie.names), oe.splice(fe, 1));
        }
        return oe.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((W, J) => P(W, J.names), {});
      }
    }
    class b extends g {
      render(W) {
        return "{" + W._n + super.render(W) + "}" + W._n;
      }
    }
    class x extends g {
    }
    class w extends b {
    }
    w.kind = "else";
    class k extends b {
      constructor(W, J) {
        super(J), this.condition = W;
      }
      render(W) {
        let J = `if(${this.condition})` + super.render(W);
        return this.else && (J += "else " + this.else.render(W)), J;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const W = this.condition;
        if (W === !0)
          return this.nodes;
        let J = this.else;
        if (J) {
          const oe = J.optimizeNodes();
          J = this.else = Array.isArray(oe) ? new w(oe) : oe;
        }
        if (J)
          return W === !1 ? J instanceof k ? J : J.nodes : this.nodes.length ? this : new k($(W), J instanceof k ? [J] : J.nodes);
        if (!(W === !1 || !this.nodes.length))
          return this;
      }
      optimizeNames(W, J) {
        var oe;
        if (this.else = (oe = this.else) === null || oe === void 0 ? void 0 : oe.optimizeNames(W, J), !!(super.optimizeNames(W, J) || this.else))
          return this.condition = L(this.condition, W, J), this;
      }
      get names() {
        const W = super.names;
        return H(W, this.condition), this.else && P(W, this.else.names), W;
      }
    }
    k.kind = "if";
    class E extends b {
    }
    E.kind = "for";
    class _ extends E {
      constructor(W) {
        super(), this.iteration = W;
      }
      render(W) {
        return `for(${this.iteration})` + super.render(W);
      }
      optimizeNames(W, J) {
        if (super.optimizeNames(W, J))
          return this.iteration = L(this.iteration, W, J), this;
      }
      get names() {
        return P(super.names, this.iteration.names);
      }
    }
    class O extends E {
      constructor(W, J, oe, fe) {
        super(), this.varKind = W, this.name = J, this.from = oe, this.to = fe;
      }
      render(W) {
        const J = W.es5 ? n.varKinds.var : this.varKind, { name: oe, from: fe, to: ie } = this;
        return `for(${J} ${oe}=${fe}; ${oe}<${ie}; ${oe}++)` + super.render(W);
      }
      get names() {
        const W = H(super.names, this.from);
        return H(W, this.to);
      }
    }
    class N extends E {
      constructor(W, J, oe, fe) {
        super(), this.loop = W, this.varKind = J, this.name = oe, this.iterable = fe;
      }
      render(W) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(W);
      }
      optimizeNames(W, J) {
        if (super.optimizeNames(W, J))
          return this.iterable = L(this.iterable, W, J), this;
      }
      get names() {
        return P(super.names, this.iterable.names);
      }
    }
    class A extends b {
      constructor(W, J, oe) {
        super(), this.name = W, this.args = J, this.async = oe;
      }
      render(W) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(W);
      }
    }
    A.kind = "func";
    class R extends g {
      render(W) {
        return "return " + super.render(W);
      }
    }
    R.kind = "return";
    class D extends b {
      render(W) {
        let J = "try" + super.render(W);
        return this.catch && (J += this.catch.render(W)), this.finally && (J += this.finally.render(W)), J;
      }
      optimizeNodes() {
        var W, J;
        return super.optimizeNodes(), (W = this.catch) === null || W === void 0 || W.optimizeNodes(), (J = this.finally) === null || J === void 0 || J.optimizeNodes(), this;
      }
      optimizeNames(W, J) {
        var oe, fe;
        return super.optimizeNames(W, J), (oe = this.catch) === null || oe === void 0 || oe.optimizeNames(W, J), (fe = this.finally) === null || fe === void 0 || fe.optimizeNames(W, J), this;
      }
      get names() {
        const W = super.names;
        return this.catch && P(W, this.catch.names), this.finally && P(W, this.finally.names), W;
      }
    }
    class I extends b {
      constructor(W) {
        super(), this.error = W;
      }
      render(W) {
        return `catch(${this.error})` + super.render(W);
      }
    }
    I.kind = "catch";
    class z extends b {
      render(W) {
        return "finally" + super.render(W);
      }
    }
    z.kind = "finally";
    class B {
      constructor(W, J = {}) {
        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...J, _n: J.lines ? `
` : "" }, this._extScope = W, this._scope = new n.Scope({ parent: W }), this._nodes = [new x()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(W) {
        return this._scope.name(W);
      }
      // reserves unique name in the external scope
      scopeName(W) {
        return this._extScope.name(W);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(W, J) {
        const oe = this._extScope.value(W, J);
        return (this._values[oe.prefix] || (this._values[oe.prefix] = /* @__PURE__ */ new Set())).add(oe), oe;
      }
      getScopeValue(W, J) {
        return this._extScope.getValue(W, J);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(W) {
        return this._extScope.scopeRefs(W, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(W, J, oe, fe) {
        const ie = this._scope.toName(J);
        return oe !== void 0 && fe && (this._constants[ie.str] = oe), this._leafNode(new l(W, ie, oe)), ie;
      }
      // `const` declaration (`var` in es5 mode)
      const(W, J, oe) {
        return this._def(n.varKinds.const, W, J, oe);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(W, J, oe) {
        return this._def(n.varKinds.let, W, J, oe);
      }
      // `var` declaration with optional assignment
      var(W, J, oe) {
        return this._def(n.varKinds.var, W, J, oe);
      }
      // assignment code
      assign(W, J, oe) {
        return this._leafNode(new c(W, J, oe));
      }
      // `+=` code
      add(W, J) {
        return this._leafNode(new d(W, e.operators.ADD, J));
      }
      // appends passed SafeExpr to code or executes Block
      code(W) {
        return typeof W == "function" ? W() : W !== t.nil && this._leafNode(new v(W)), this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...W) {
        const J = ["{"];
        for (const [oe, fe] of W)
          J.length > 1 && J.push(","), J.push(oe), (oe !== fe || this.opts.es5) && (J.push(":"), (0, t.addCodeArg)(J, fe));
        return J.push("}"), new t._Code(J);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(W, J, oe) {
        if (this._blockNode(new k(W)), J && oe)
          this.code(J).else().code(oe).endIf();
        else if (J)
          this.code(J).endIf();
        else if (oe)
          throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(W) {
        return this._elseNode(new k(W));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new w());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(k, w);
      }
      _for(W, J) {
        return this._blockNode(W), J && this.code(J).endFor(), this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(W, J) {
        return this._for(new _(W), J);
      }
      // `for` statement for a range of values
      forRange(W, J, oe, fe, ie = this.opts.es5 ? n.varKinds.var : n.varKinds.let) {
        const ce = this._scope.toName(W);
        return this._for(new O(ie, ce, J, oe), () => fe(ce));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(W, J, oe, fe = n.varKinds.const) {
        const ie = this._scope.toName(W);
        if (this.opts.es5) {
          const ce = J instanceof t.Name ? J : this.var("_arr", J);
          return this.forRange("_i", 0, (0, t._)`${ce}.length`, (ge) => {
            this.var(ie, (0, t._)`${ce}[${ge}]`), oe(ie);
          });
        }
        return this._for(new N("of", fe, ie, J), () => oe(ie));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(W, J, oe, fe = this.opts.es5 ? n.varKinds.var : n.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(W, (0, t._)`Object.keys(${J})`, oe);
        const ie = this._scope.toName(W);
        return this._for(new N("in", fe, ie, J), () => oe(ie));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(E);
      }
      // `label` statement
      label(W) {
        return this._leafNode(new f(W));
      }
      // `break` statement
      break(W) {
        return this._leafNode(new m(W));
      }
      // `return` statement
      return(W) {
        const J = new R();
        if (this._blockNode(J), this.code(W), J.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(R);
      }
      // `try` statement
      try(W, J, oe) {
        if (!J && !oe)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const fe = new D();
        if (this._blockNode(fe), this.code(W), J) {
          const ie = this.name("e");
          this._currNode = fe.catch = new I(ie), J(ie);
        }
        return oe && (this._currNode = fe.finally = new z(), this.code(oe)), this._endBlockNode(I, z);
      }
      // `throw` statement
      throw(W) {
        return this._leafNode(new h(W));
      }
      // start self-balancing block
      block(W, J) {
        return this._blockStarts.push(this._nodes.length), W && this.code(W).endBlock(J), this;
      }
      // end the current self-balancing block
      endBlock(W) {
        const J = this._blockStarts.pop();
        if (J === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const oe = this._nodes.length - J;
        if (oe < 0 || W !== void 0 && oe !== W)
          throw new Error(`CodeGen: wrong number of nodes: ${oe} vs ${W} expected`);
        return this._nodes.length = J, this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(W, J = t.nil, oe, fe) {
        return this._blockNode(new A(W, J, oe)), fe && this.code(fe).endFunc(), this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(A);
      }
      optimize(W = 1) {
        for (; W-- > 0; )
          this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
      }
      _leafNode(W) {
        return this._currNode.nodes.push(W), this;
      }
      _blockNode(W) {
        this._currNode.nodes.push(W), this._nodes.push(W);
      }
      _endBlockNode(W, J) {
        const oe = this._currNode;
        if (oe instanceof W || J && oe instanceof J)
          return this._nodes.pop(), this;
        throw new Error(`CodeGen: not in block "${J ? `${W.kind}/${J.kind}` : W.kind}"`);
      }
      _elseNode(W) {
        const J = this._currNode;
        if (!(J instanceof k))
          throw new Error('CodeGen: "else" without "if"');
        return this._currNode = J.else = W, this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const W = this._nodes;
        return W[W.length - 1];
      }
      set _currNode(W) {
        const J = this._nodes;
        J[J.length - 1] = W;
      }
    }
    e.CodeGen = B;
    function P(U, W) {
      for (const J in W)
        U[J] = (U[J] || 0) + (W[J] || 0);
      return U;
    }
    function H(U, W) {
      return W instanceof t._CodeOrName ? P(U, W.names) : U;
    }
    function L(U, W, J) {
      if (U instanceof t.Name)
        return oe(U);
      if (!fe(U))
        return U;
      return new t._Code(U._items.reduce((ie, ce) => (ce instanceof t.Name && (ce = oe(ce)), ce instanceof t._Code ? ie.push(...ce._items) : ie.push(ce), ie), []));
      function oe(ie) {
        const ce = J[ie.str];
        return ce === void 0 || W[ie.str] !== 1 ? ie : (delete W[ie.str], ce);
      }
      function fe(ie) {
        return ie instanceof t._Code && ie._items.some((ce) => ce instanceof t.Name && W[ce.str] === 1 && J[ce.str] !== void 0);
      }
    }
    function G(U, W) {
      for (const J in W)
        U[J] = (U[J] || 0) - (W[J] || 0);
    }
    function $(U) {
      return typeof U == "boolean" || typeof U == "number" || U === null ? !U : (0, t._)`!${Y(U)}`;
    }
    e.not = $;
    const K = F(e.operators.AND);
    function q(...U) {
      return U.reduce(K);
    }
    e.and = q;
    const Z = F(e.operators.OR);
    function V(...U) {
      return U.reduce(Z);
    }
    e.or = V;
    function F(U) {
      return (W, J) => W === t.nil ? J : J === t.nil ? W : (0, t._)`${Y(W)} ${U} ${Y(J)}`;
    }
    function Y(U) {
      return U instanceof t.Name ? U : (0, t._)`(${U})`;
    }
  })(iT)), iT;
}
var Gt = {}, pT;
function vn() {
  if (pT) return Gt;
  pT = 1, Object.defineProperty(Gt, "__esModule", { value: !0 }), Gt.checkStrictMode = Gt.getErrorPath = Gt.Type = Gt.useFunc = Gt.setEvaluated = Gt.evaluatedPropsToName = Gt.mergeEvaluated = Gt.eachItem = Gt.unescapeJsonPointer = Gt.escapeJsonPointer = Gt.escapeFragment = Gt.unescapeFragment = Gt.schemaRefOrVal = Gt.schemaHasRulesButRef = Gt.schemaHasRules = Gt.checkUnknownRules = Gt.alwaysValidSchema = Gt.toHash = void 0;
  const e = Yt(), t = H2();
  function n(N) {
    const A = {};
    for (const R of N)
      A[R] = !0;
    return A;
  }
  Gt.toHash = n;
  function r(N, A) {
    return typeof A == "boolean" ? A : Object.keys(A).length === 0 ? !0 : (a(N, A), !s(A, N.self.RULES.all));
  }
  Gt.alwaysValidSchema = r;
  function a(N, A = N.schema) {
    const { opts: R, self: D } = N;
    if (!R.strictSchema || typeof A == "boolean")
      return;
    const I = D.RULES.keywords;
    for (const z in A)
      I[z] || O(N, `unknown keyword: "${z}"`);
  }
  Gt.checkUnknownRules = a;
  function s(N, A) {
    if (typeof N == "boolean")
      return !N;
    for (const R in N)
      if (A[R])
        return !0;
    return !1;
  }
  Gt.schemaHasRules = s;
  function l(N, A) {
    if (typeof N == "boolean")
      return !N;
    for (const R in N)
      if (R !== "$ref" && A.all[R])
        return !0;
    return !1;
  }
  Gt.schemaHasRulesButRef = l;
  function c({ topSchemaRef: N, schemaPath: A }, R, D, I) {
    if (!I) {
      if (typeof R == "number" || typeof R == "boolean")
        return R;
      if (typeof R == "string")
        return (0, e._)`${R}`;
    }
    return (0, e._)`${N}${A}${(0, e.getProperty)(D)}`;
  }
  Gt.schemaRefOrVal = c;
  function d(N) {
    return h(decodeURIComponent(N));
  }
  Gt.unescapeFragment = d;
  function f(N) {
    return encodeURIComponent(m(N));
  }
  Gt.escapeFragment = f;
  function m(N) {
    return typeof N == "number" ? `${N}` : N.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  Gt.escapeJsonPointer = m;
  function h(N) {
    return N.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  Gt.unescapeJsonPointer = h;
  function v(N, A) {
    if (Array.isArray(N))
      for (const R of N)
        A(R);
    else
      A(N);
  }
  Gt.eachItem = v;
  function g({ mergeNames: N, mergeToName: A, mergeValues: R, resultToName: D }) {
    return (I, z, B, P) => {
      const H = B === void 0 ? z : B instanceof e.Name ? (z instanceof e.Name ? N(I, z, B) : A(I, z, B), B) : z instanceof e.Name ? (A(I, B, z), z) : R(z, B);
      return P === e.Name && !(H instanceof e.Name) ? D(I, H) : H;
    };
  }
  Gt.mergeEvaluated = {
    props: g({
      mergeNames: (N, A, R) => N.if((0, e._)`${R} !== true && ${A} !== undefined`, () => {
        N.if((0, e._)`${A} === true`, () => N.assign(R, !0), () => N.assign(R, (0, e._)`${R} || {}`).code((0, e._)`Object.assign(${R}, ${A})`));
      }),
      mergeToName: (N, A, R) => N.if((0, e._)`${R} !== true`, () => {
        A === !0 ? N.assign(R, !0) : (N.assign(R, (0, e._)`${R} || {}`), x(N, R, A));
      }),
      mergeValues: (N, A) => N === !0 ? !0 : { ...N, ...A },
      resultToName: b
    }),
    items: g({
      mergeNames: (N, A, R) => N.if((0, e._)`${R} !== true && ${A} !== undefined`, () => N.assign(R, (0, e._)`${A} === true ? true : ${R} > ${A} ? ${R} : ${A}`)),
      mergeToName: (N, A, R) => N.if((0, e._)`${R} !== true`, () => N.assign(R, A === !0 ? !0 : (0, e._)`${R} > ${A} ? ${R} : ${A}`)),
      mergeValues: (N, A) => N === !0 ? !0 : Math.max(N, A),
      resultToName: (N, A) => N.var("items", A)
    })
  };
  function b(N, A) {
    if (A === !0)
      return N.var("props", !0);
    const R = N.var("props", (0, e._)`{}`);
    return A !== void 0 && x(N, R, A), R;
  }
  Gt.evaluatedPropsToName = b;
  function x(N, A, R) {
    Object.keys(R).forEach((D) => N.assign((0, e._)`${A}${(0, e.getProperty)(D)}`, !0));
  }
  Gt.setEvaluated = x;
  const w = {};
  function k(N, A) {
    return N.scopeValue("func", {
      ref: A,
      code: w[A.code] || (w[A.code] = new t._Code(A.code))
    });
  }
  Gt.useFunc = k;
  var E;
  (function(N) {
    N[N.Num = 0] = "Num", N[N.Str = 1] = "Str";
  })(E || (Gt.Type = E = {}));
  function _(N, A, R) {
    if (N instanceof e.Name) {
      const D = A === E.Num;
      return R ? D ? (0, e._)`"[" + ${N} + "]"` : (0, e._)`"['" + ${N} + "']"` : D ? (0, e._)`"/" + ${N}` : (0, e._)`"/" + ${N}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return R ? (0, e.getProperty)(N).toString() : "/" + m(N);
  }
  Gt.getErrorPath = _;
  function O(N, A, R = N.opts.strictSchema) {
    if (R) {
      if (A = `strict mode: ${A}`, R === !0)
        throw new Error(A);
      N.self.logger.warn(A);
    }
  }
  return Gt.checkStrictMode = O, Gt;
}
var y0 = {}, mT;
function Vd() {
  if (mT) return y0;
  mT = 1, Object.defineProperty(y0, "__esModule", { value: !0 });
  const e = Yt(), t = {
    // validation function arguments
    data: new e.Name("data"),
    // data passed to validation function
    // args passed from referencing schema
    valCxt: new e.Name("valCxt"),
    // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new e.Name("instancePath"),
    parentData: new e.Name("parentData"),
    parentDataProperty: new e.Name("parentDataProperty"),
    rootData: new e.Name("rootData"),
    // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new e.Name("dynamicAnchors"),
    // used to support recursiveRef and dynamicRef
    // function scoped variables
    vErrors: new e.Name("vErrors"),
    // null or array of validation errors
    errors: new e.Name("errors"),
    // counter of validation errors
    this: new e.Name("this"),
    // "globals"
    self: new e.Name("self"),
    scope: new e.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new e.Name("json"),
    jsonPos: new e.Name("jsonPos"),
    jsonLen: new e.Name("jsonLen"),
    jsonPart: new e.Name("jsonPart")
  };
  return y0.default = t, y0;
}
var hT;
function NC() {
  return hT || (hT = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
    const t = Yt(), n = vn(), r = Vd();
    e.keywordError = {
      message: ({ keyword: w }) => (0, t.str)`must pass "${w}" keyword validation`
    }, e.keyword$DataError = {
      message: ({ keyword: w, schemaType: k }) => k ? (0, t.str)`"${w}" keyword must be ${k} ($data)` : (0, t.str)`"${w}" keyword is invalid ($data)`
    };
    function a(w, k = e.keywordError, E, _) {
      const { it: O } = w, { gen: N, compositeRule: A, allErrors: R } = O, D = h(w, k, E);
      _ ?? (A || R) ? d(N, D) : f(O, (0, t._)`[${D}]`);
    }
    e.reportError = a;
    function s(w, k = e.keywordError, E) {
      const { it: _ } = w, { gen: O, compositeRule: N, allErrors: A } = _, R = h(w, k, E);
      d(O, R), N || A || f(_, r.default.vErrors);
    }
    e.reportExtraError = s;
    function l(w, k) {
      w.assign(r.default.errors, k), w.if((0, t._)`${r.default.vErrors} !== null`, () => w.if(k, () => w.assign((0, t._)`${r.default.vErrors}.length`, k), () => w.assign(r.default.vErrors, null)));
    }
    e.resetErrorsCount = l;
    function c({ gen: w, keyword: k, schemaValue: E, data: _, errsCount: O, it: N }) {
      if (O === void 0)
        throw new Error("ajv implementation error");
      const A = w.name("err");
      w.forRange("i", O, r.default.errors, (R) => {
        w.const(A, (0, t._)`${r.default.vErrors}[${R}]`), w.if((0, t._)`${A}.instancePath === undefined`, () => w.assign((0, t._)`${A}.instancePath`, (0, t.strConcat)(r.default.instancePath, N.errorPath))), w.assign((0, t._)`${A}.schemaPath`, (0, t.str)`${N.errSchemaPath}/${k}`), N.opts.verbose && (w.assign((0, t._)`${A}.schema`, E), w.assign((0, t._)`${A}.data`, _));
      });
    }
    e.extendErrors = c;
    function d(w, k) {
      const E = w.const("err", k);
      w.if((0, t._)`${r.default.vErrors} === null`, () => w.assign(r.default.vErrors, (0, t._)`[${E}]`), (0, t._)`${r.default.vErrors}.push(${E})`), w.code((0, t._)`${r.default.errors}++`);
    }
    function f(w, k) {
      const { gen: E, validateName: _, schemaEnv: O } = w;
      O.$async ? E.throw((0, t._)`new ${w.ValidationError}(${k})`) : (E.assign((0, t._)`${_}.errors`, k), E.return(!1));
    }
    const m = {
      keyword: new t.Name("keyword"),
      schemaPath: new t.Name("schemaPath"),
      // also used in JTD errors
      params: new t.Name("params"),
      propertyName: new t.Name("propertyName"),
      message: new t.Name("message"),
      schema: new t.Name("schema"),
      parentSchema: new t.Name("parentSchema")
    };
    function h(w, k, E) {
      const { createErrors: _ } = w.it;
      return _ === !1 ? (0, t._)`{}` : v(w, k, E);
    }
    function v(w, k, E = {}) {
      const { gen: _, it: O } = w, N = [
        g(O, E),
        b(w, E)
      ];
      return x(w, k, N), _.object(...N);
    }
    function g({ errorPath: w }, { instancePath: k }) {
      const E = k ? (0, t.str)`${w}${(0, n.getErrorPath)(k, n.Type.Str)}` : w;
      return [r.default.instancePath, (0, t.strConcat)(r.default.instancePath, E)];
    }
    function b({ keyword: w, it: { errSchemaPath: k } }, { schemaPath: E, parentSchema: _ }) {
      let O = _ ? k : (0, t.str)`${k}/${w}`;
      return E && (O = (0, t.str)`${O}${(0, n.getErrorPath)(E, n.Type.Str)}`), [m.schemaPath, O];
    }
    function x(w, { params: k, message: E }, _) {
      const { keyword: O, data: N, schemaValue: A, it: R } = w, { opts: D, propertyName: I, topSchemaRef: z, schemaPath: B } = R;
      _.push([m.keyword, O], [m.params, typeof k == "function" ? k(w) : k || (0, t._)`{}`]), D.messages && _.push([m.message, typeof E == "function" ? E(w) : E]), D.verbose && _.push([m.schema, A], [m.parentSchema, (0, t._)`${z}${B}`], [r.default.data, N]), I && _.push([m.propertyName, I]);
    }
  })(aT)), aT;
}
var gT;
function Q5e() {
  if (gT) return pm;
  gT = 1, Object.defineProperty(pm, "__esModule", { value: !0 }), pm.boolOrEmptySchema = pm.topBoolOrEmptySchema = void 0;
  const e = NC(), t = Yt(), n = Vd(), r = {
    message: "boolean schema is false"
  };
  function a(c) {
    const { gen: d, schema: f, validateName: m } = c;
    f === !1 ? l(c, !1) : typeof f == "object" && f.$async === !0 ? d.return(n.default.data) : (d.assign((0, t._)`${m}.errors`, null), d.return(!0));
  }
  pm.topBoolOrEmptySchema = a;
  function s(c, d) {
    const { gen: f, schema: m } = c;
    m === !1 ? (f.var(d, !1), l(c)) : f.var(d, !0);
  }
  pm.boolOrEmptySchema = s;
  function l(c, d) {
    const { gen: f, data: m } = c, h = {
      gen: f,
      keyword: "false schema",
      data: m,
      schema: !1,
      schemaCode: !1,
      schemaValue: !1,
      params: {},
      it: c
    };
    (0, e.reportError)(h, r, void 0, d);
  }
  return pm;
}
var Po = {}, mm = {}, vT;
function EK() {
  if (vT) return mm;
  vT = 1, Object.defineProperty(mm, "__esModule", { value: !0 }), mm.getRules = mm.isJSONType = void 0;
  const e = ["string", "number", "integer", "boolean", "null", "object", "array"], t = new Set(e);
  function n(a) {
    return typeof a == "string" && t.has(a);
  }
  mm.isJSONType = n;
  function r() {
    const a = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...a, integer: !0, boolean: !0, null: !0 },
      rules: [{ rules: [] }, a.number, a.string, a.array, a.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  return mm.getRules = r, mm;
}
var xc = {}, yT;
function CK() {
  if (yT) return xc;
  yT = 1, Object.defineProperty(xc, "__esModule", { value: !0 }), xc.shouldUseRule = xc.shouldUseGroup = xc.schemaHasRulesForType = void 0;
  function e({ schema: r, self: a }, s) {
    const l = a.RULES.types[s];
    return l && l !== !0 && t(r, l);
  }
  xc.schemaHasRulesForType = e;
  function t(r, a) {
    return a.rules.some((s) => n(r, s));
  }
  xc.shouldUseGroup = t;
  function n(r, a) {
    var s;
    return r[a.keyword] !== void 0 || ((s = a.definition.implements) === null || s === void 0 ? void 0 : s.some((l) => r[l] !== void 0));
  }
  return xc.shouldUseRule = n, xc;
}
var bT;
function W2() {
  if (bT) return Po;
  bT = 1, Object.defineProperty(Po, "__esModule", { value: !0 }), Po.reportTypeError = Po.checkDataTypes = Po.checkDataType = Po.coerceAndCheckDataType = Po.getJSONTypes = Po.getSchemaTypes = Po.DataType = void 0;
  const e = EK(), t = CK(), n = NC(), r = Yt(), a = vn();
  var s;
  (function(E) {
    E[E.Correct = 0] = "Correct", E[E.Wrong = 1] = "Wrong";
  })(s || (Po.DataType = s = {}));
  function l(E) {
    const _ = c(E.type);
    if (_.includes("null")) {
      if (E.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!_.length && E.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      E.nullable === !0 && _.push("null");
    }
    return _;
  }
  Po.getSchemaTypes = l;
  function c(E) {
    const _ = Array.isArray(E) ? E : E ? [E] : [];
    if (_.every(e.isJSONType))
      return _;
    throw new Error("type must be JSONType or JSONType[]: " + _.join(","));
  }
  Po.getJSONTypes = c;
  function d(E, _) {
    const { gen: O, data: N, opts: A } = E, R = m(_, A.coerceTypes), D = _.length > 0 && !(R.length === 0 && _.length === 1 && (0, t.schemaHasRulesForType)(E, _[0]));
    if (D) {
      const I = b(_, N, A.strictNumbers, s.Wrong);
      O.if(I, () => {
        R.length ? h(E, _, R) : w(E);
      });
    }
    return D;
  }
  Po.coerceAndCheckDataType = d;
  const f = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function m(E, _) {
    return _ ? E.filter((O) => f.has(O) || _ === "array" && O === "array") : [];
  }
  function h(E, _, O) {
    const { gen: N, data: A, opts: R } = E, D = N.let("dataType", (0, r._)`typeof ${A}`), I = N.let("coerced", (0, r._)`undefined`);
    R.coerceTypes === "array" && N.if((0, r._)`${D} == 'object' && Array.isArray(${A}) && ${A}.length == 1`, () => N.assign(A, (0, r._)`${A}[0]`).assign(D, (0, r._)`typeof ${A}`).if(b(_, A, R.strictNumbers), () => N.assign(I, A))), N.if((0, r._)`${I} !== undefined`);
    for (const B of O)
      (f.has(B) || B === "array" && R.coerceTypes === "array") && z(B);
    N.else(), w(E), N.endIf(), N.if((0, r._)`${I} !== undefined`, () => {
      N.assign(A, I), v(E, I);
    });
    function z(B) {
      switch (B) {
        case "string":
          N.elseIf((0, r._)`${D} == "number" || ${D} == "boolean"`).assign(I, (0, r._)`"" + ${A}`).elseIf((0, r._)`${A} === null`).assign(I, (0, r._)`""`);
          return;
        case "number":
          N.elseIf((0, r._)`${D} == "boolean" || ${A} === null
              || (${D} == "string" && ${A} && ${A} == +${A})`).assign(I, (0, r._)`+${A}`);
          return;
        case "integer":
          N.elseIf((0, r._)`${D} === "boolean" || ${A} === null
              || (${D} === "string" && ${A} && ${A} == +${A} && !(${A} % 1))`).assign(I, (0, r._)`+${A}`);
          return;
        case "boolean":
          N.elseIf((0, r._)`${A} === "false" || ${A} === 0 || ${A} === null`).assign(I, !1).elseIf((0, r._)`${A} === "true" || ${A} === 1`).assign(I, !0);
          return;
        case "null":
          N.elseIf((0, r._)`${A} === "" || ${A} === 0 || ${A} === false`), N.assign(I, null);
          return;
        case "array":
          N.elseIf((0, r._)`${D} === "string" || ${D} === "number"
              || ${D} === "boolean" || ${A} === null`).assign(I, (0, r._)`[${A}]`);
      }
    }
  }
  function v({ gen: E, parentData: _, parentDataProperty: O }, N) {
    E.if((0, r._)`${_} !== undefined`, () => E.assign((0, r._)`${_}[${O}]`, N));
  }
  function g(E, _, O, N = s.Correct) {
    const A = N === s.Correct ? r.operators.EQ : r.operators.NEQ;
    let R;
    switch (E) {
      case "null":
        return (0, r._)`${_} ${A} null`;
      case "array":
        R = (0, r._)`Array.isArray(${_})`;
        break;
      case "object":
        R = (0, r._)`${_} && typeof ${_} == "object" && !Array.isArray(${_})`;
        break;
      case "integer":
        R = D((0, r._)`!(${_} % 1) && !isNaN(${_})`);
        break;
      case "number":
        R = D();
        break;
      default:
        return (0, r._)`typeof ${_} ${A} ${E}`;
    }
    return N === s.Correct ? R : (0, r.not)(R);
    function D(I = r.nil) {
      return (0, r.and)((0, r._)`typeof ${_} == "number"`, I, O ? (0, r._)`isFinite(${_})` : r.nil);
    }
  }
  Po.checkDataType = g;
  function b(E, _, O, N) {
    if (E.length === 1)
      return g(E[0], _, O, N);
    let A;
    const R = (0, a.toHash)(E);
    if (R.array && R.object) {
      const D = (0, r._)`typeof ${_} != "object"`;
      A = R.null ? D : (0, r._)`!${_} || ${D}`, delete R.null, delete R.array, delete R.object;
    } else
      A = r.nil;
    R.number && delete R.integer;
    for (const D in R)
      A = (0, r.and)(A, g(D, _, O, N));
    return A;
  }
  Po.checkDataTypes = b;
  const x = {
    message: ({ schema: E }) => `must be ${E}`,
    params: ({ schema: E, schemaValue: _ }) => typeof E == "string" ? (0, r._)`{type: ${E}}` : (0, r._)`{type: ${_}}`
  };
  function w(E) {
    const _ = k(E);
    (0, n.reportError)(_, x);
  }
  Po.reportTypeError = w;
  function k(E) {
    const { gen: _, data: O, schema: N } = E, A = (0, a.schemaRefOrVal)(E, N, "type");
    return {
      gen: _,
      keyword: "type",
      data: O,
      schema: N.type,
      schemaCode: A,
      schemaValue: A,
      parentSchema: N,
      params: {},
      it: E
    };
  }
  return Po;
}
var tx = {}, wT;
function Z5e() {
  if (wT) return tx;
  wT = 1, Object.defineProperty(tx, "__esModule", { value: !0 }), tx.assignDefaults = void 0;
  const e = Yt(), t = vn();
  function n(a, s) {
    const { properties: l, items: c } = a.schema;
    if (s === "object" && l)
      for (const d in l)
        r(a, d, l[d].default);
    else s === "array" && Array.isArray(c) && c.forEach((d, f) => r(a, f, d.default));
  }
  tx.assignDefaults = n;
  function r(a, s, l) {
    const { gen: c, compositeRule: d, data: f, opts: m } = a;
    if (l === void 0)
      return;
    const h = (0, e._)`${f}${(0, e.getProperty)(s)}`;
    if (d) {
      (0, t.checkStrictMode)(a, `default is ignored for: ${h}`);
      return;
    }
    let v = (0, e._)`${h} === undefined`;
    m.useDefaults === "empty" && (v = (0, e._)`${v} || ${h} === null || ${h} === ""`), c.if(v, (0, e._)`${h} = ${(0, e.stringify)(l)}`);
  }
  return tx;
}
var Bs = {}, $n = {}, xT;
function ul() {
  if (xT) return $n;
  xT = 1, Object.defineProperty($n, "__esModule", { value: !0 }), $n.validateUnion = $n.validateArray = $n.usePattern = $n.callValidateCode = $n.schemaProperties = $n.allSchemaProperties = $n.noPropertyInData = $n.propertyInData = $n.isOwnProperty = $n.hasPropFunc = $n.reportMissingProp = $n.checkMissingProp = $n.checkReportMissingProp = void 0;
  const e = Yt(), t = vn(), n = Vd(), r = vn();
  function a(E, _) {
    const { gen: O, data: N, it: A } = E;
    O.if(m(O, N, _, A.opts.ownProperties), () => {
      E.setParams({ missingProperty: (0, e._)`${_}` }, !0), E.error();
    });
  }
  $n.checkReportMissingProp = a;
  function s({ gen: E, data: _, it: { opts: O } }, N, A) {
    return (0, e.or)(...N.map((R) => (0, e.and)(m(E, _, R, O.ownProperties), (0, e._)`${A} = ${R}`)));
  }
  $n.checkMissingProp = s;
  function l(E, _) {
    E.setParams({ missingProperty: _ }, !0), E.error();
  }
  $n.reportMissingProp = l;
  function c(E) {
    return E.scopeValue("func", {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ref: Object.prototype.hasOwnProperty,
      code: (0, e._)`Object.prototype.hasOwnProperty`
    });
  }
  $n.hasPropFunc = c;
  function d(E, _, O) {
    return (0, e._)`${c(E)}.call(${_}, ${O})`;
  }
  $n.isOwnProperty = d;
  function f(E, _, O, N) {
    const A = (0, e._)`${_}${(0, e.getProperty)(O)} !== undefined`;
    return N ? (0, e._)`${A} && ${d(E, _, O)}` : A;
  }
  $n.propertyInData = f;
  function m(E, _, O, N) {
    const A = (0, e._)`${_}${(0, e.getProperty)(O)} === undefined`;
    return N ? (0, e.or)(A, (0, e.not)(d(E, _, O))) : A;
  }
  $n.noPropertyInData = m;
  function h(E) {
    return E ? Object.keys(E).filter((_) => _ !== "__proto__") : [];
  }
  $n.allSchemaProperties = h;
  function v(E, _) {
    return h(_).filter((O) => !(0, t.alwaysValidSchema)(E, _[O]));
  }
  $n.schemaProperties = v;
  function g({ schemaCode: E, data: _, it: { gen: O, topSchemaRef: N, schemaPath: A, errorPath: R }, it: D }, I, z, B) {
    const P = B ? (0, e._)`${E}, ${_}, ${N}${A}` : _, H = [
      [n.default.instancePath, (0, e.strConcat)(n.default.instancePath, R)],
      [n.default.parentData, D.parentData],
      [n.default.parentDataProperty, D.parentDataProperty],
      [n.default.rootData, n.default.rootData]
    ];
    D.opts.dynamicRef && H.push([n.default.dynamicAnchors, n.default.dynamicAnchors]);
    const L = (0, e._)`${P}, ${O.object(...H)}`;
    return z !== e.nil ? (0, e._)`${I}.call(${z}, ${L})` : (0, e._)`${I}(${L})`;
  }
  $n.callValidateCode = g;
  const b = (0, e._)`new RegExp`;
  function x({ gen: E, it: { opts: _ } }, O) {
    const N = _.unicodeRegExp ? "u" : "", { regExp: A } = _.code, R = A(O, N);
    return E.scopeValue("pattern", {
      key: R.toString(),
      ref: R,
      code: (0, e._)`${A.code === "new RegExp" ? b : (0, r.useFunc)(E, A)}(${O}, ${N})`
    });
  }
  $n.usePattern = x;
  function w(E) {
    const { gen: _, data: O, keyword: N, it: A } = E, R = _.name("valid");
    if (A.allErrors) {
      const I = _.let("valid", !0);
      return D(() => _.assign(I, !1)), I;
    }
    return _.var(R, !0), D(() => _.break()), R;
    function D(I) {
      const z = _.const("len", (0, e._)`${O}.length`);
      _.forRange("i", 0, z, (B) => {
        E.subschema({
          keyword: N,
          dataProp: B,
          dataPropType: t.Type.Num
        }, R), _.if((0, e.not)(R), I);
      });
    }
  }
  $n.validateArray = w;
  function k(E) {
    const { gen: _, schema: O, keyword: N, it: A } = E;
    if (!Array.isArray(O))
      throw new Error("ajv implementation error");
    if (O.some((I) => (0, t.alwaysValidSchema)(A, I)) && !A.opts.unevaluated)
      return;
    const R = _.let("valid", !1), D = _.name("_valid");
    _.block(() => O.forEach((I, z) => {
      const B = E.subschema({
        keyword: N,
        schemaProp: z,
        compositeRule: !0
      }, D);
      _.assign(R, (0, e._)`${R} || ${D}`), E.mergeValidEvaluated(B, D) || _.if((0, e.not)(R));
    })), E.result(R, () => E.reset(), () => E.error(!0));
  }
  return $n.validateUnion = k, $n;
}
var ST;
function eAe() {
  if (ST) return Bs;
  ST = 1, Object.defineProperty(Bs, "__esModule", { value: !0 }), Bs.validateKeywordUsage = Bs.validSchemaType = Bs.funcKeywordCode = Bs.macroKeywordCode = void 0;
  const e = Yt(), t = Vd(), n = ul(), r = NC();
  function a(v, g) {
    const { gen: b, keyword: x, schema: w, parentSchema: k, it: E } = v, _ = g.macro.call(E.self, w, k, E), O = f(b, x, _);
    E.opts.validateSchema !== !1 && E.self.validateSchema(_, !0);
    const N = b.name("valid");
    v.subschema({
      schema: _,
      schemaPath: e.nil,
      errSchemaPath: `${E.errSchemaPath}/${x}`,
      topSchemaRef: O,
      compositeRule: !0
    }, N), v.pass(N, () => v.error(!0));
  }
  Bs.macroKeywordCode = a;
  function s(v, g) {
    var b;
    const { gen: x, keyword: w, schema: k, parentSchema: E, $data: _, it: O } = v;
    d(O, g);
    const N = !_ && g.compile ? g.compile.call(O.self, k, E, O) : g.validate, A = f(x, w, N), R = x.let("valid");
    v.block$data(R, D), v.ok((b = g.valid) !== null && b !== void 0 ? b : R);
    function D() {
      if (g.errors === !1)
        B(), g.modifying && l(v), P(() => v.error());
      else {
        const H = g.async ? I() : z();
        g.modifying && l(v), P(() => c(v, H));
      }
    }
    function I() {
      const H = x.let("ruleErrs", null);
      return x.try(() => B((0, e._)`await `), (L) => x.assign(R, !1).if((0, e._)`${L} instanceof ${O.ValidationError}`, () => x.assign(H, (0, e._)`${L}.errors`), () => x.throw(L))), H;
    }
    function z() {
      const H = (0, e._)`${A}.errors`;
      return x.assign(H, null), B(e.nil), H;
    }
    function B(H = g.async ? (0, e._)`await ` : e.nil) {
      const L = O.opts.passContext ? t.default.this : t.default.self, G = !("compile" in g && !_ || g.schema === !1);
      x.assign(R, (0, e._)`${H}${(0, n.callValidateCode)(v, A, L, G)}`, g.modifying);
    }
    function P(H) {
      var L;
      x.if((0, e.not)((L = g.valid) !== null && L !== void 0 ? L : R), H);
    }
  }
  Bs.funcKeywordCode = s;
  function l(v) {
    const { gen: g, data: b, it: x } = v;
    g.if(x.parentData, () => g.assign(b, (0, e._)`${x.parentData}[${x.parentDataProperty}]`));
  }
  function c(v, g) {
    const { gen: b } = v;
    b.if((0, e._)`Array.isArray(${g})`, () => {
      b.assign(t.default.vErrors, (0, e._)`${t.default.vErrors} === null ? ${g} : ${t.default.vErrors}.concat(${g})`).assign(t.default.errors, (0, e._)`${t.default.vErrors}.length`), (0, r.extendErrors)(v);
    }, () => v.error());
  }
  function d({ schemaEnv: v }, g) {
    if (g.async && !v.$async)
      throw new Error("async keyword in sync schema");
  }
  function f(v, g, b) {
    if (b === void 0)
      throw new Error(`keyword "${g}" failed to compile`);
    return v.scopeValue("keyword", typeof b == "function" ? { ref: b } : { ref: b, code: (0, e.stringify)(b) });
  }
  function m(v, g, b = !1) {
    return !g.length || g.some((x) => x === "array" ? Array.isArray(v) : x === "object" ? v && typeof v == "object" && !Array.isArray(v) : typeof v == x || b && typeof v > "u");
  }
  Bs.validSchemaType = m;
  function h({ schema: v, opts: g, self: b, errSchemaPath: x }, w, k) {
    if (Array.isArray(w.keyword) ? !w.keyword.includes(k) : w.keyword !== k)
      throw new Error("ajv implementation error");
    const E = w.dependencies;
    if (E?.some((_) => !Object.prototype.hasOwnProperty.call(v, _)))
      throw new Error(`parent schema must have dependencies of ${k}: ${E.join(",")}`);
    if (w.validateSchema && !w.validateSchema(v[k])) {
      const _ = `keyword "${k}" value is invalid at path "${x}": ` + b.errorsText(w.validateSchema.errors);
      if (g.validateSchema === "log")
        b.logger.error(_);
      else
        throw new Error(_);
    }
  }
  return Bs.validateKeywordUsage = h, Bs;
}
var Sc = {}, kT;
function tAe() {
  if (kT) return Sc;
  kT = 1, Object.defineProperty(Sc, "__esModule", { value: !0 }), Sc.extendSubschemaMode = Sc.extendSubschemaData = Sc.getSubschema = void 0;
  const e = Yt(), t = vn();
  function n(s, { keyword: l, schemaProp: c, schema: d, schemaPath: f, errSchemaPath: m, topSchemaRef: h }) {
    if (l !== void 0 && d !== void 0)
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    if (l !== void 0) {
      const v = s.schema[l];
      return c === void 0 ? {
        schema: v,
        schemaPath: (0, e._)`${s.schemaPath}${(0, e.getProperty)(l)}`,
        errSchemaPath: `${s.errSchemaPath}/${l}`
      } : {
        schema: v[c],
        schemaPath: (0, e._)`${s.schemaPath}${(0, e.getProperty)(l)}${(0, e.getProperty)(c)}`,
        errSchemaPath: `${s.errSchemaPath}/${l}/${(0, t.escapeFragment)(c)}`
      };
    }
    if (d !== void 0) {
      if (f === void 0 || m === void 0 || h === void 0)
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      return {
        schema: d,
        schemaPath: f,
        topSchemaRef: h,
        errSchemaPath: m
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  Sc.getSubschema = n;
  function r(s, l, { dataProp: c, dataPropType: d, data: f, dataTypes: m, propertyName: h }) {
    if (f !== void 0 && c !== void 0)
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    const { gen: v } = l;
    if (c !== void 0) {
      const { errorPath: b, dataPathArr: x, opts: w } = l, k = v.let("data", (0, e._)`${l.data}${(0, e.getProperty)(c)}`, !0);
      g(k), s.errorPath = (0, e.str)`${b}${(0, t.getErrorPath)(c, d, w.jsPropertySyntax)}`, s.parentDataProperty = (0, e._)`${c}`, s.dataPathArr = [...x, s.parentDataProperty];
    }
    if (f !== void 0) {
      const b = f instanceof e.Name ? f : v.let("data", f, !0);
      g(b), h !== void 0 && (s.propertyName = h);
    }
    m && (s.dataTypes = m);
    function g(b) {
      s.data = b, s.dataLevel = l.dataLevel + 1, s.dataTypes = [], l.definedProperties = /* @__PURE__ */ new Set(), s.parentData = l.data, s.dataNames = [...l.dataNames, b];
    }
  }
  Sc.extendSubschemaData = r;
  function a(s, { jtdDiscriminator: l, jtdMetadata: c, compositeRule: d, createErrors: f, allErrors: m }) {
    d !== void 0 && (s.compositeRule = d), f !== void 0 && (s.createErrors = f), m !== void 0 && (s.allErrors = m), s.jtdDiscriminator = l, s.jtdMetadata = c;
  }
  return Sc.extendSubschemaMode = a, Sc;
}
var Sa = {}, _T, ET;
function OK() {
  return ET || (ET = 1, _T = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, a, s;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (a = r; a-- !== 0; )
          if (!e(t[a], n[a])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (s = Object.keys(t), r = s.length, r !== Object.keys(n).length) return !1;
      for (a = r; a-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(n, s[a])) return !1;
      for (a = r; a-- !== 0; ) {
        var l = s[a];
        if (!e(t[l], n[l])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), _T;
}
var j5 = { exports: {} }, CT;
function nAe() {
  if (CT) return j5.exports;
  CT = 1;
  var e = j5.exports = function(r, a, s) {
    typeof a == "function" && (s = a, a = {}), s = a.cb || s;
    var l = typeof s == "function" ? s : s.pre || function() {
    }, c = s.post || function() {
    };
    t(a, l, c, r, "", r);
  };
  e.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0,
    if: !0,
    then: !0,
    else: !0
  }, e.arrayKeywords = {
    items: !0,
    allOf: !0,
    anyOf: !0,
    oneOf: !0
  }, e.propsKeywords = {
    $defs: !0,
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0
  }, e.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0
  };
  function t(r, a, s, l, c, d, f, m, h, v) {
    if (l && typeof l == "object" && !Array.isArray(l)) {
      a(l, c, d, f, m, h, v);
      for (var g in l) {
        var b = l[g];
        if (Array.isArray(b)) {
          if (g in e.arrayKeywords)
            for (var x = 0; x < b.length; x++)
              t(r, a, s, b[x], c + "/" + g + "/" + x, d, c, g, l, x);
        } else if (g in e.propsKeywords) {
          if (b && typeof b == "object")
            for (var w in b)
              t(r, a, s, b[w], c + "/" + g + "/" + n(w), d, c, g, l, w);
        } else (g in e.keywords || r.allKeys && !(g in e.skipKeywords)) && t(r, a, s, b, c + "/" + g, d, c, g, l);
      }
      s(l, c, d, f, m, h, v);
    }
  }
  function n(r) {
    return r.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return j5.exports;
}
var OT;
function AC() {
  if (OT) return Sa;
  OT = 1, Object.defineProperty(Sa, "__esModule", { value: !0 }), Sa.getSchemaRefs = Sa.resolveUrl = Sa.normalizeId = Sa._getFullPath = Sa.getFullPath = Sa.inlineRef = void 0;
  const e = vn(), t = OK(), n = nAe(), r = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function a(x, w = !0) {
    return typeof x == "boolean" ? !0 : w === !0 ? !l(x) : w ? c(x) <= w : !1;
  }
  Sa.inlineRef = a;
  const s = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function l(x) {
    for (const w in x) {
      if (s.has(w))
        return !0;
      const k = x[w];
      if (Array.isArray(k) && k.some(l) || typeof k == "object" && l(k))
        return !0;
    }
    return !1;
  }
  function c(x) {
    let w = 0;
    for (const k in x)
      if (k === "$ref" || (w++, !r.has(k) && (typeof x[k] == "object" && (0, e.eachItem)(x[k], (E) => w += c(E)), w === 1 / 0)))
        return 1 / 0;
    return w;
  }
  function d(x, w = "", k) {
    k !== !1 && (w = h(w));
    const E = x.parse(w);
    return f(x, E);
  }
  Sa.getFullPath = d;
  function f(x, w) {
    return x.serialize(w).split("#")[0] + "#";
  }
  Sa._getFullPath = f;
  const m = /#\/?$/;
  function h(x) {
    return x ? x.replace(m, "") : "";
  }
  Sa.normalizeId = h;
  function v(x, w, k) {
    return k = h(k), x.resolve(w, k);
  }
  Sa.resolveUrl = v;
  const g = /^[a-z_][-a-z0-9._]*$/i;
  function b(x, w) {
    if (typeof x == "boolean")
      return {};
    const { schemaId: k, uriResolver: E } = this.opts, _ = h(x[k] || w), O = { "": _ }, N = d(E, _, !1), A = {}, R = /* @__PURE__ */ new Set();
    return n(x, { allKeys: !0 }, (z, B, P, H) => {
      if (H === void 0)
        return;
      const L = N + B;
      let G = O[H];
      typeof z[k] == "string" && (G = $.call(this, z[k])), K.call(this, z.$anchor), K.call(this, z.$dynamicAnchor), O[B] = G;
      function $(q) {
        const Z = this.opts.uriResolver.resolve;
        if (q = h(G ? Z(G, q) : q), R.has(q))
          throw I(q);
        R.add(q);
        let V = this.refs[q];
        return typeof V == "string" && (V = this.refs[V]), typeof V == "object" ? D(z, V.schema, q) : q !== h(L) && (q[0] === "#" ? (D(z, A[q], q), A[q] = z) : this.refs[q] = L), q;
      }
      function K(q) {
        if (typeof q == "string") {
          if (!g.test(q))
            throw new Error(`invalid anchor "${q}"`);
          $.call(this, `#${q}`);
        }
      }
    }), A;
    function D(z, B, P) {
      if (B !== void 0 && !t(z, B))
        throw I(P);
    }
    function I(z) {
      return new Error(`reference "${z}" resolves to more than one schema`);
    }
  }
  return Sa.getSchemaRefs = b, Sa;
}
var MT;
function RC() {
  if (MT) return wc;
  MT = 1, Object.defineProperty(wc, "__esModule", { value: !0 }), wc.getData = wc.KeywordCxt = wc.validateFunctionCode = void 0;
  const e = Q5e(), t = W2(), n = CK(), r = W2(), a = Z5e(), s = eAe(), l = tAe(), c = Yt(), d = Vd(), f = AC(), m = vn(), h = NC();
  function v(re) {
    if (N(re) && (R(re), O(re))) {
      w(re);
      return;
    }
    g(re, () => (0, e.topBoolOrEmptySchema)(re));
  }
  wc.validateFunctionCode = v;
  function g({ gen: re, validateName: le, schema: me, schemaEnv: ve, opts: xe }, _e) {
    xe.code.es5 ? re.func(le, (0, c._)`${d.default.data}, ${d.default.valCxt}`, ve.$async, () => {
      re.code((0, c._)`"use strict"; ${E(me, xe)}`), x(re, xe), re.code(_e);
    }) : re.func(le, (0, c._)`${d.default.data}, ${b(xe)}`, ve.$async, () => re.code(E(me, xe)).code(_e));
  }
  function b(re) {
    return (0, c._)`{${d.default.instancePath}="", ${d.default.parentData}, ${d.default.parentDataProperty}, ${d.default.rootData}=${d.default.data}${re.dynamicRef ? (0, c._)`, ${d.default.dynamicAnchors}={}` : c.nil}}={}`;
  }
  function x(re, le) {
    re.if(d.default.valCxt, () => {
      re.var(d.default.instancePath, (0, c._)`${d.default.valCxt}.${d.default.instancePath}`), re.var(d.default.parentData, (0, c._)`${d.default.valCxt}.${d.default.parentData}`), re.var(d.default.parentDataProperty, (0, c._)`${d.default.valCxt}.${d.default.parentDataProperty}`), re.var(d.default.rootData, (0, c._)`${d.default.valCxt}.${d.default.rootData}`), le.dynamicRef && re.var(d.default.dynamicAnchors, (0, c._)`${d.default.valCxt}.${d.default.dynamicAnchors}`);
    }, () => {
      re.var(d.default.instancePath, (0, c._)`""`), re.var(d.default.parentData, (0, c._)`undefined`), re.var(d.default.parentDataProperty, (0, c._)`undefined`), re.var(d.default.rootData, d.default.data), le.dynamicRef && re.var(d.default.dynamicAnchors, (0, c._)`{}`);
    });
  }
  function w(re) {
    const { schema: le, opts: me, gen: ve } = re;
    g(re, () => {
      me.$comment && le.$comment && H(re), z(re), ve.let(d.default.vErrors, null), ve.let(d.default.errors, 0), me.unevaluated && k(re), D(re), L(re);
    });
  }
  function k(re) {
    const { gen: le, validateName: me } = re;
    re.evaluated = le.const("evaluated", (0, c._)`${me}.evaluated`), le.if((0, c._)`${re.evaluated}.dynamicProps`, () => le.assign((0, c._)`${re.evaluated}.props`, (0, c._)`undefined`)), le.if((0, c._)`${re.evaluated}.dynamicItems`, () => le.assign((0, c._)`${re.evaluated}.items`, (0, c._)`undefined`));
  }
  function E(re, le) {
    const me = typeof re == "object" && re[le.schemaId];
    return me && (le.code.source || le.code.process) ? (0, c._)`/*# sourceURL=${me} */` : c.nil;
  }
  function _(re, le) {
    if (N(re) && (R(re), O(re))) {
      A(re, le);
      return;
    }
    (0, e.boolOrEmptySchema)(re, le);
  }
  function O({ schema: re, self: le }) {
    if (typeof re == "boolean")
      return !re;
    for (const me in re)
      if (le.RULES.all[me])
        return !0;
    return !1;
  }
  function N(re) {
    return typeof re.schema != "boolean";
  }
  function A(re, le) {
    const { schema: me, gen: ve, opts: xe } = re;
    xe.$comment && me.$comment && H(re), B(re), P(re);
    const _e = ve.const("_errs", d.default.errors);
    D(re, _e), ve.var(le, (0, c._)`${_e} === ${d.default.errors}`);
  }
  function R(re) {
    (0, m.checkUnknownRules)(re), I(re);
  }
  function D(re, le) {
    if (re.opts.jtd)
      return $(re, [], !1, le);
    const me = (0, t.getSchemaTypes)(re.schema), ve = (0, t.coerceAndCheckDataType)(re, me);
    $(re, me, !ve, le);
  }
  function I(re) {
    const { schema: le, errSchemaPath: me, opts: ve, self: xe } = re;
    le.$ref && ve.ignoreKeywordsWithRef && (0, m.schemaHasRulesButRef)(le, xe.RULES) && xe.logger.warn(`$ref: keywords ignored in schema at path "${me}"`);
  }
  function z(re) {
    const { schema: le, opts: me } = re;
    le.default !== void 0 && me.useDefaults && me.strictSchema && (0, m.checkStrictMode)(re, "default is ignored in the schema root");
  }
  function B(re) {
    const le = re.schema[re.opts.schemaId];
    le && (re.baseId = (0, f.resolveUrl)(re.opts.uriResolver, re.baseId, le));
  }
  function P(re) {
    if (re.schema.$async && !re.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function H({ gen: re, schemaEnv: le, schema: me, errSchemaPath: ve, opts: xe }) {
    const _e = me.$comment;
    if (xe.$comment === !0)
      re.code((0, c._)`${d.default.self}.logger.log(${_e})`);
    else if (typeof xe.$comment == "function") {
      const Ge = (0, c.str)`${ve}/$comment`, Xe = re.scopeValue("root", { ref: le.root });
      re.code((0, c._)`${d.default.self}.opts.$comment(${_e}, ${Ge}, ${Xe}.schema)`);
    }
  }
  function L(re) {
    const { gen: le, schemaEnv: me, validateName: ve, ValidationError: xe, opts: _e } = re;
    me.$async ? le.if((0, c._)`${d.default.errors} === 0`, () => le.return(d.default.data), () => le.throw((0, c._)`new ${xe}(${d.default.vErrors})`)) : (le.assign((0, c._)`${ve}.errors`, d.default.vErrors), _e.unevaluated && G(re), le.return((0, c._)`${d.default.errors} === 0`));
  }
  function G({ gen: re, evaluated: le, props: me, items: ve }) {
    me instanceof c.Name && re.assign((0, c._)`${le}.props`, me), ve instanceof c.Name && re.assign((0, c._)`${le}.items`, ve);
  }
  function $(re, le, me, ve) {
    const { gen: xe, schema: _e, data: Ge, allErrors: Xe, opts: tt, self: nt } = re, { RULES: je } = nt;
    if (_e.$ref && (tt.ignoreKeywordsWithRef || !(0, m.schemaHasRulesButRef)(_e, je))) {
      xe.block(() => fe(re, "$ref", je.all.$ref.definition));
      return;
    }
    tt.jtd || q(re, le), xe.block(() => {
      for (const pt of je.rules)
        cn(pt);
      cn(je.post);
    });
    function cn(pt) {
      (0, n.shouldUseGroup)(_e, pt) && (pt.type ? (xe.if((0, r.checkDataType)(pt.type, Ge, tt.strictNumbers)), K(re, pt), le.length === 1 && le[0] === pt.type && me && (xe.else(), (0, r.reportTypeError)(re)), xe.endIf()) : K(re, pt), Xe || xe.if((0, c._)`${d.default.errors} === ${ve || 0}`));
    }
  }
  function K(re, le) {
    const { gen: me, schema: ve, opts: { useDefaults: xe } } = re;
    xe && (0, a.assignDefaults)(re, le.type), me.block(() => {
      for (const _e of le.rules)
        (0, n.shouldUseRule)(ve, _e) && fe(re, _e.keyword, _e.definition, le.type);
    });
  }
  function q(re, le) {
    re.schemaEnv.meta || !re.opts.strictTypes || (Z(re, le), re.opts.allowUnionTypes || V(re, le), F(re, re.dataTypes));
  }
  function Z(re, le) {
    if (le.length) {
      if (!re.dataTypes.length) {
        re.dataTypes = le;
        return;
      }
      le.forEach((me) => {
        U(re.dataTypes, me) || J(re, `type "${me}" not allowed by context "${re.dataTypes.join(",")}"`);
      }), W(re, le);
    }
  }
  function V(re, le) {
    le.length > 1 && !(le.length === 2 && le.includes("null")) && J(re, "use allowUnionTypes to allow union type keyword");
  }
  function F(re, le) {
    const me = re.self.RULES.all;
    for (const ve in me) {
      const xe = me[ve];
      if (typeof xe == "object" && (0, n.shouldUseRule)(re.schema, xe)) {
        const { type: _e } = xe.definition;
        _e.length && !_e.some((Ge) => Y(le, Ge)) && J(re, `missing type "${_e.join(",")}" for keyword "${ve}"`);
      }
    }
  }
  function Y(re, le) {
    return re.includes(le) || le === "number" && re.includes("integer");
  }
  function U(re, le) {
    return re.includes(le) || le === "integer" && re.includes("number");
  }
  function W(re, le) {
    const me = [];
    for (const ve of re.dataTypes)
      U(le, ve) ? me.push(ve) : le.includes("integer") && ve === "number" && me.push("integer");
    re.dataTypes = me;
  }
  function J(re, le) {
    const me = re.schemaEnv.baseId + re.errSchemaPath;
    le += ` at "${me}" (strictTypes)`, (0, m.checkStrictMode)(re, le, re.opts.strictTypes);
  }
  class oe {
    constructor(le, me, ve) {
      if ((0, s.validateKeywordUsage)(le, me, ve), this.gen = le.gen, this.allErrors = le.allErrors, this.keyword = ve, this.data = le.data, this.schema = le.schema[ve], this.$data = me.$data && le.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, m.schemaRefOrVal)(le, this.schema, ve, this.$data), this.schemaType = me.schemaType, this.parentSchema = le.schema, this.params = {}, this.it = le, this.def = me, this.$data)
        this.schemaCode = le.gen.const("vSchema", ge(this.$data, le));
      else if (this.schemaCode = this.schemaValue, !(0, s.validSchemaType)(this.schema, me.schemaType, me.allowUndefined))
        throw new Error(`${ve} value must be ${JSON.stringify(me.schemaType)}`);
      ("code" in me ? me.trackErrors : me.errors !== !1) && (this.errsCount = le.gen.const("_errs", d.default.errors));
    }
    result(le, me, ve) {
      this.failResult((0, c.not)(le), me, ve);
    }
    failResult(le, me, ve) {
      this.gen.if(le), ve ? ve() : this.error(), me ? (this.gen.else(), me(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    pass(le, me) {
      this.failResult((0, c.not)(le), void 0, me);
    }
    fail(le) {
      if (le === void 0) {
        this.error(), this.allErrors || this.gen.if(!1);
        return;
      }
      this.gen.if(le), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    fail$data(le) {
      if (!this.$data)
        return this.fail(le);
      const { schemaCode: me } = this;
      this.fail((0, c._)`${me} !== undefined && (${(0, c.or)(this.invalid$data(), le)})`);
    }
    error(le, me, ve) {
      if (me) {
        this.setParams(me), this._error(le, ve), this.setParams({});
        return;
      }
      this._error(le, ve);
    }
    _error(le, me) {
      (le ? h.reportExtraError : h.reportError)(this, this.def.error, me);
    }
    $dataError() {
      (0, h.reportError)(this, this.def.$dataError || h.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, h.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(le) {
      this.allErrors || this.gen.if(le);
    }
    setParams(le, me) {
      me ? Object.assign(this.params, le) : this.params = le;
    }
    block$data(le, me, ve = c.nil) {
      this.gen.block(() => {
        this.check$data(le, ve), me();
      });
    }
    check$data(le = c.nil, me = c.nil) {
      if (!this.$data)
        return;
      const { gen: ve, schemaCode: xe, schemaType: _e, def: Ge } = this;
      ve.if((0, c.or)((0, c._)`${xe} === undefined`, me)), le !== c.nil && ve.assign(le, !0), (_e.length || Ge.validateSchema) && (ve.elseIf(this.invalid$data()), this.$dataError(), le !== c.nil && ve.assign(le, !1)), ve.else();
    }
    invalid$data() {
      const { gen: le, schemaCode: me, schemaType: ve, def: xe, it: _e } = this;
      return (0, c.or)(Ge(), Xe());
      function Ge() {
        if (ve.length) {
          if (!(me instanceof c.Name))
            throw new Error("ajv implementation error");
          const tt = Array.isArray(ve) ? ve : [ve];
          return (0, c._)`${(0, r.checkDataTypes)(tt, me, _e.opts.strictNumbers, r.DataType.Wrong)}`;
        }
        return c.nil;
      }
      function Xe() {
        if (xe.validateSchema) {
          const tt = le.scopeValue("validate$data", { ref: xe.validateSchema });
          return (0, c._)`!${tt}(${me})`;
        }
        return c.nil;
      }
    }
    subschema(le, me) {
      const ve = (0, l.getSubschema)(this.it, le);
      (0, l.extendSubschemaData)(ve, this.it, le), (0, l.extendSubschemaMode)(ve, le);
      const xe = { ...this.it, ...ve, items: void 0, props: void 0 };
      return _(xe, me), xe;
    }
    mergeEvaluated(le, me) {
      const { it: ve, gen: xe } = this;
      ve.opts.unevaluated && (ve.props !== !0 && le.props !== void 0 && (ve.props = m.mergeEvaluated.props(xe, le.props, ve.props, me)), ve.items !== !0 && le.items !== void 0 && (ve.items = m.mergeEvaluated.items(xe, le.items, ve.items, me)));
    }
    mergeValidEvaluated(le, me) {
      const { it: ve, gen: xe } = this;
      if (ve.opts.unevaluated && (ve.props !== !0 || ve.items !== !0))
        return xe.if(me, () => this.mergeEvaluated(le, c.Name)), !0;
    }
  }
  wc.KeywordCxt = oe;
  function fe(re, le, me, ve) {
    const xe = new oe(re, me, le);
    "code" in me ? me.code(xe, ve) : xe.$data && me.validate ? (0, s.funcKeywordCode)(xe, me) : "macro" in me ? (0, s.macroKeywordCode)(xe, me) : (me.compile || me.validate) && (0, s.funcKeywordCode)(xe, me);
  }
  const ie = /^\/(?:[^~]|~0|~1)*$/, ce = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function ge(re, { dataLevel: le, dataNames: me, dataPathArr: ve }) {
    let xe, _e;
    if (re === "")
      return d.default.rootData;
    if (re[0] === "/") {
      if (!ie.test(re))
        throw new Error(`Invalid JSON-pointer: ${re}`);
      xe = re, _e = d.default.rootData;
    } else {
      const nt = ce.exec(re);
      if (!nt)
        throw new Error(`Invalid JSON-pointer: ${re}`);
      const je = +nt[1];
      if (xe = nt[2], xe === "#") {
        if (je >= le)
          throw new Error(tt("property/index", je));
        return ve[le - je];
      }
      if (je > le)
        throw new Error(tt("data", je));
      if (_e = me[le - je], !xe)
        return _e;
    }
    let Ge = _e;
    const Xe = xe.split("/");
    for (const nt of Xe)
      nt && (_e = (0, c._)`${_e}${(0, c.getProperty)((0, m.unescapeJsonPointer)(nt))}`, Ge = (0, c._)`${Ge} && ${_e}`);
    return Ge;
    function tt(nt, je) {
      return `Cannot access ${nt} ${je} levels up, current level is ${le}`;
    }
  }
  return wc.getData = ge, wc;
}
var b0 = {}, NT;
function sP() {
  if (NT) return b0;
  NT = 1, Object.defineProperty(b0, "__esModule", { value: !0 });
  class e extends Error {
    constructor(n) {
      super("validation failed"), this.errors = n, this.ajv = this.validation = !0;
    }
  }
  return b0.default = e, b0;
}
var w0 = {}, AT;
function jC() {
  if (AT) return w0;
  AT = 1, Object.defineProperty(w0, "__esModule", { value: !0 });
  const e = AC();
  class t extends Error {
    constructor(r, a, s, l) {
      super(l || `can't resolve reference ${s} from id ${a}`), this.missingRef = (0, e.resolveUrl)(r, a, s), this.missingSchema = (0, e.normalizeId)((0, e.getFullPath)(r, this.missingRef));
    }
  }
  return w0.default = t, w0;
}
var yi = {}, RT;
function lP() {
  if (RT) return yi;
  RT = 1, Object.defineProperty(yi, "__esModule", { value: !0 }), yi.resolveSchema = yi.getCompilingSchema = yi.resolveRef = yi.compileSchema = yi.SchemaEnv = void 0;
  const e = Yt(), t = sP(), n = Vd(), r = AC(), a = vn(), s = RC();
  class l {
    constructor(k) {
      var E;
      this.refs = {}, this.dynamicAnchors = {};
      let _;
      typeof k.schema == "object" && (_ = k.schema), this.schema = k.schema, this.schemaId = k.schemaId, this.root = k.root || this, this.baseId = (E = k.baseId) !== null && E !== void 0 ? E : (0, r.normalizeId)(_?.[k.schemaId || "$id"]), this.schemaPath = k.schemaPath, this.localRefs = k.localRefs, this.meta = k.meta, this.$async = _?.$async, this.refs = {};
    }
  }
  yi.SchemaEnv = l;
  function c(w) {
    const k = m.call(this, w);
    if (k)
      return k;
    const E = (0, r.getFullPath)(this.opts.uriResolver, w.root.baseId), { es5: _, lines: O } = this.opts.code, { ownProperties: N } = this.opts, A = new e.CodeGen(this.scope, { es5: _, lines: O, ownProperties: N });
    let R;
    w.$async && (R = A.scopeValue("Error", {
      ref: t.default,
      code: (0, e._)`require("ajv/dist/runtime/validation_error").default`
    }));
    const D = A.scopeName("validate");
    w.validateName = D;
    const I = {
      gen: A,
      allErrors: this.opts.allErrors,
      data: n.default.data,
      parentData: n.default.parentData,
      parentDataProperty: n.default.parentDataProperty,
      dataNames: [n.default.data],
      dataPathArr: [e.nil],
      // TODO can its length be used as dataLevel if nil is removed?
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: A.scopeValue("schema", this.opts.code.source === !0 ? { ref: w.schema, code: (0, e.stringify)(w.schema) } : { ref: w.schema }),
      validateName: D,
      ValidationError: R,
      schema: w.schema,
      schemaEnv: w,
      rootId: E,
      baseId: w.baseId || E,
      schemaPath: e.nil,
      errSchemaPath: w.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, e._)`""`,
      opts: this.opts,
      self: this
    };
    let z;
    try {
      this._compilations.add(w), (0, s.validateFunctionCode)(I), A.optimize(this.opts.code.optimize);
      const B = A.toString();
      z = `${A.scopeRefs(n.default.scope)}return ${B}`, this.opts.code.process && (z = this.opts.code.process(z, w));
      const P = new Function(`${n.default.self}`, `${n.default.scope}`, z)(this, this.scope.get());
      if (this.scope.value(D, { ref: P }), P.errors = null, P.schema = w.schema, P.schemaEnv = w, w.$async && (P.$async = !0), this.opts.code.source === !0 && (P.source = { validateName: D, validateCode: B, scopeValues: A._values }), this.opts.unevaluated) {
        const { props: H, items: L } = I;
        P.evaluated = {
          props: H instanceof e.Name ? void 0 : H,
          items: L instanceof e.Name ? void 0 : L,
          dynamicProps: H instanceof e.Name,
          dynamicItems: L instanceof e.Name
        }, P.source && (P.source.evaluated = (0, e.stringify)(P.evaluated));
      }
      return w.validate = P, w;
    } catch (B) {
      throw delete w.validate, delete w.validateName, z && this.logger.error("Error compiling schema, function code:", z), B;
    } finally {
      this._compilations.delete(w);
    }
  }
  yi.compileSchema = c;
  function d(w, k, E) {
    var _;
    E = (0, r.resolveUrl)(this.opts.uriResolver, k, E);
    const O = w.refs[E];
    if (O)
      return O;
    let N = v.call(this, w, E);
    if (N === void 0) {
      const A = (_ = w.localRefs) === null || _ === void 0 ? void 0 : _[E], { schemaId: R } = this.opts;
      A && (N = new l({ schema: A, schemaId: R, root: w, baseId: k }));
    }
    if (N !== void 0)
      return w.refs[E] = f.call(this, N);
  }
  yi.resolveRef = d;
  function f(w) {
    return (0, r.inlineRef)(w.schema, this.opts.inlineRefs) ? w.schema : w.validate ? w : c.call(this, w);
  }
  function m(w) {
    for (const k of this._compilations)
      if (h(k, w))
        return k;
  }
  yi.getCompilingSchema = m;
  function h(w, k) {
    return w.schema === k.schema && w.root === k.root && w.baseId === k.baseId;
  }
  function v(w, k) {
    let E;
    for (; typeof (E = this.refs[k]) == "string"; )
      k = E;
    return E || this.schemas[k] || g.call(this, w, k);
  }
  function g(w, k) {
    const E = this.opts.uriResolver.parse(k), _ = (0, r._getFullPath)(this.opts.uriResolver, E);
    let O = (0, r.getFullPath)(this.opts.uriResolver, w.baseId, void 0);
    if (Object.keys(w.schema).length > 0 && _ === O)
      return x.call(this, E, w);
    const N = (0, r.normalizeId)(_), A = this.refs[N] || this.schemas[N];
    if (typeof A == "string") {
      const R = g.call(this, w, A);
      return typeof R?.schema != "object" ? void 0 : x.call(this, E, R);
    }
    if (typeof A?.schema == "object") {
      if (A.validate || c.call(this, A), N === (0, r.normalizeId)(k)) {
        const { schema: R } = A, { schemaId: D } = this.opts, I = R[D];
        return I && (O = (0, r.resolveUrl)(this.opts.uriResolver, O, I)), new l({ schema: R, schemaId: D, root: w, baseId: O });
      }
      return x.call(this, E, A);
    }
  }
  yi.resolveSchema = g;
  const b = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function x(w, { baseId: k, schema: E, root: _ }) {
    var O;
    if (((O = w.fragment) === null || O === void 0 ? void 0 : O[0]) !== "/")
      return;
    for (const R of w.fragment.slice(1).split("/")) {
      if (typeof E == "boolean")
        return;
      const D = E[(0, a.unescapeFragment)(R)];
      if (D === void 0)
        return;
      E = D;
      const I = typeof E == "object" && E[this.opts.schemaId];
      !b.has(R) && I && (k = (0, r.resolveUrl)(this.opts.uriResolver, k, I));
    }
    let N;
    if (typeof E != "boolean" && E.$ref && !(0, a.schemaHasRulesButRef)(E, this.RULES)) {
      const R = (0, r.resolveUrl)(this.opts.uriResolver, k, E.$ref);
      N = g.call(this, _, R);
    }
    const { schemaId: A } = this.opts;
    if (N = N || new l({ schema: E, schemaId: A, root: _, baseId: k }), N.schema !== N.root.schema)
      return N;
  }
  return yi;
}
const rAe = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", oAe = "Meta-schema for $data reference (JSON AnySchema extension proposal)", aAe = "object", iAe = ["$data"], sAe = { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, lAe = !1, uAe = {
  $id: rAe,
  description: oAe,
  type: aAe,
  required: iAe,
  properties: sAe,
  additionalProperties: lAe
};
var x0 = {}, nx = { exports: {} }, jT, PT;
function cAe() {
  return PT || (PT = 1, jT = {
    HEX: {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    }
  }), jT;
}
var P5, DT;
function dAe() {
  if (DT) return P5;
  DT = 1;
  const { HEX: e } = cAe(), t = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
  function n(x) {
    if (c(x, ".") < 3)
      return { host: x, isIPV4: !1 };
    const w = x.match(t) || [], [k] = w;
    return k ? { host: l(k, "."), isIPV4: !0 } : { host: x, isIPV4: !1 };
  }
  function r(x, w = !1) {
    let k = "", E = !0;
    for (const _ of x) {
      if (e[_] === void 0) return;
      _ !== "0" && E === !0 && (E = !1), E || (k += _);
    }
    return w && k.length === 0 && (k = "0"), k;
  }
  function a(x) {
    let w = 0;
    const k = { error: !1, address: "", zone: "" }, E = [], _ = [];
    let O = !1, N = !1, A = !1;
    function R() {
      if (_.length) {
        if (O === !1) {
          const D = r(_);
          if (D !== void 0)
            E.push(D);
          else
            return k.error = !0, !1;
        }
        _.length = 0;
      }
      return !0;
    }
    for (let D = 0; D < x.length; D++) {
      const I = x[D];
      if (!(I === "[" || I === "]"))
        if (I === ":") {
          if (N === !0 && (A = !0), !R())
            break;
          if (w++, E.push(":"), w > 7) {
            k.error = !0;
            break;
          }
          D - 1 >= 0 && x[D - 1] === ":" && (N = !0);
          continue;
        } else if (I === "%") {
          if (!R())
            break;
          O = !0;
        } else {
          _.push(I);
          continue;
        }
    }
    return _.length && (O ? k.zone = _.join("") : A ? E.push(_.join("")) : E.push(r(_))), k.address = E.join(""), k;
  }
  function s(x) {
    if (c(x, ":") < 2)
      return { host: x, isIPV6: !1 };
    const w = a(x);
    if (w.error)
      return { host: x, isIPV6: !1 };
    {
      let k = w.address, E = w.address;
      return w.zone && (k += "%" + w.zone, E += "%25" + w.zone), { host: k, escapedHost: E, isIPV6: !0 };
    }
  }
  function l(x, w) {
    let k = "", E = !0;
    const _ = x.length;
    for (let O = 0; O < _; O++) {
      const N = x[O];
      N === "0" && E ? (O + 1 <= _ && x[O + 1] === w || O + 1 === _) && (k += N, E = !1) : (N === w ? E = !0 : E = !1, k += N);
    }
    return k;
  }
  function c(x, w) {
    let k = 0;
    for (let E = 0; E < x.length; E++)
      x[E] === w && k++;
    return k;
  }
  const d = /^\.\.?\//u, f = /^\/\.(?:\/|$)/u, m = /^\/\.\.(?:\/|$)/u, h = /^\/?(?:.|\n)*?(?=\/|$)/u;
  function v(x) {
    const w = [];
    for (; x.length; )
      if (x.match(d))
        x = x.replace(d, "");
      else if (x.match(f))
        x = x.replace(f, "/");
      else if (x.match(m))
        x = x.replace(m, "/"), w.pop();
      else if (x === "." || x === "..")
        x = "";
      else {
        const k = x.match(h);
        if (k) {
          const E = k[0];
          x = x.slice(E.length), w.push(E);
        } else
          throw new Error("Unexpected dot segment condition");
      }
    return w.join("");
  }
  function g(x, w) {
    const k = w !== !0 ? escape : unescape;
    return x.scheme !== void 0 && (x.scheme = k(x.scheme)), x.userinfo !== void 0 && (x.userinfo = k(x.userinfo)), x.host !== void 0 && (x.host = k(x.host)), x.path !== void 0 && (x.path = k(x.path)), x.query !== void 0 && (x.query = k(x.query)), x.fragment !== void 0 && (x.fragment = k(x.fragment)), x;
  }
  function b(x) {
    const w = [];
    if (x.userinfo !== void 0 && (w.push(x.userinfo), w.push("@")), x.host !== void 0) {
      let k = unescape(x.host);
      const E = n(k);
      if (E.isIPV4)
        k = E.host;
      else {
        const _ = s(E.host);
        _.isIPV6 === !0 ? k = `[${_.escapedHost}]` : k = x.host;
      }
      w.push(k);
    }
    return (typeof x.port == "number" || typeof x.port == "string") && (w.push(":"), w.push(String(x.port))), w.length ? w.join("") : void 0;
  }
  return P5 = {
    recomposeAuthority: b,
    normalizeComponentEncoding: g,
    removeDotSegments: v,
    normalizeIPv4: n,
    normalizeIPv6: s,
    stringArrayToHexStripped: r
  }, P5;
}
var D5, IT;
function fAe() {
  if (IT) return D5;
  IT = 1;
  const e = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu, t = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
  function n(w) {
    return typeof w.secure == "boolean" ? w.secure : String(w.scheme).toLowerCase() === "wss";
  }
  function r(w) {
    return w.host || (w.error = w.error || "HTTP URIs must have a host."), w;
  }
  function a(w) {
    const k = String(w.scheme).toLowerCase() === "https";
    return (w.port === (k ? 443 : 80) || w.port === "") && (w.port = void 0), w.path || (w.path = "/"), w;
  }
  function s(w) {
    return w.secure = n(w), w.resourceName = (w.path || "/") + (w.query ? "?" + w.query : ""), w.path = void 0, w.query = void 0, w;
  }
  function l(w) {
    if ((w.port === (n(w) ? 443 : 80) || w.port === "") && (w.port = void 0), typeof w.secure == "boolean" && (w.scheme = w.secure ? "wss" : "ws", w.secure = void 0), w.resourceName) {
      const [k, E] = w.resourceName.split("?");
      w.path = k && k !== "/" ? k : void 0, w.query = E, w.resourceName = void 0;
    }
    return w.fragment = void 0, w;
  }
  function c(w, k) {
    if (!w.path)
      return w.error = "URN can not be parsed", w;
    const E = w.path.match(t);
    if (E) {
      const _ = k.scheme || w.scheme || "urn";
      w.nid = E[1].toLowerCase(), w.nss = E[2];
      const O = `${_}:${k.nid || w.nid}`, N = x[O];
      w.path = void 0, N && (w = N.parse(w, k));
    } else
      w.error = w.error || "URN can not be parsed.";
    return w;
  }
  function d(w, k) {
    const E = k.scheme || w.scheme || "urn", _ = w.nid.toLowerCase(), O = `${E}:${k.nid || _}`, N = x[O];
    N && (w = N.serialize(w, k));
    const A = w, R = w.nss;
    return A.path = `${_ || k.nid}:${R}`, k.skipEscape = !0, A;
  }
  function f(w, k) {
    const E = w;
    return E.uuid = E.nss, E.nss = void 0, !k.tolerant && (!E.uuid || !e.test(E.uuid)) && (E.error = E.error || "UUID is not valid."), E;
  }
  function m(w) {
    const k = w;
    return k.nss = (w.uuid || "").toLowerCase(), k;
  }
  const h = {
    scheme: "http",
    domainHost: !0,
    parse: r,
    serialize: a
  }, v = {
    scheme: "https",
    domainHost: h.domainHost,
    parse: r,
    serialize: a
  }, g = {
    scheme: "ws",
    domainHost: !0,
    parse: s,
    serialize: l
  }, b = {
    scheme: "wss",
    domainHost: g.domainHost,
    parse: g.parse,
    serialize: g.serialize
  }, x = {
    http: h,
    https: v,
    ws: g,
    wss: b,
    urn: {
      scheme: "urn",
      parse: c,
      serialize: d,
      skipNormalize: !0
    },
    "urn:uuid": {
      scheme: "urn:uuid",
      parse: f,
      serialize: m,
      skipNormalize: !0
    }
  };
  return D5 = x, D5;
}
var $T;
function pAe() {
  if ($T) return nx.exports;
  $T = 1;
  const { normalizeIPv6: e, normalizeIPv4: t, removeDotSegments: n, recomposeAuthority: r, normalizeComponentEncoding: a } = dAe(), s = fAe();
  function l(w, k) {
    return typeof w == "string" ? w = m(b(w, k), k) : typeof w == "object" && (w = b(m(w, k), k)), w;
  }
  function c(w, k, E) {
    const _ = Object.assign({ scheme: "null" }, E), O = d(b(w, _), b(k, _), _, !0);
    return m(O, { ..._, skipEscape: !0 });
  }
  function d(w, k, E, _) {
    const O = {};
    return _ || (w = b(m(w, E), E), k = b(m(k, E), E)), E = E || {}, !E.tolerant && k.scheme ? (O.scheme = k.scheme, O.userinfo = k.userinfo, O.host = k.host, O.port = k.port, O.path = n(k.path || ""), O.query = k.query) : (k.userinfo !== void 0 || k.host !== void 0 || k.port !== void 0 ? (O.userinfo = k.userinfo, O.host = k.host, O.port = k.port, O.path = n(k.path || ""), O.query = k.query) : (k.path ? (k.path.charAt(0) === "/" ? O.path = n(k.path) : ((w.userinfo !== void 0 || w.host !== void 0 || w.port !== void 0) && !w.path ? O.path = "/" + k.path : w.path ? O.path = w.path.slice(0, w.path.lastIndexOf("/") + 1) + k.path : O.path = k.path, O.path = n(O.path)), O.query = k.query) : (O.path = w.path, k.query !== void 0 ? O.query = k.query : O.query = w.query), O.userinfo = w.userinfo, O.host = w.host, O.port = w.port), O.scheme = w.scheme), O.fragment = k.fragment, O;
  }
  function f(w, k, E) {
    return typeof w == "string" ? (w = unescape(w), w = m(a(b(w, E), !0), { ...E, skipEscape: !0 })) : typeof w == "object" && (w = m(a(w, !0), { ...E, skipEscape: !0 })), typeof k == "string" ? (k = unescape(k), k = m(a(b(k, E), !0), { ...E, skipEscape: !0 })) : typeof k == "object" && (k = m(a(k, !0), { ...E, skipEscape: !0 })), w.toLowerCase() === k.toLowerCase();
  }
  function m(w, k) {
    const E = {
      host: w.host,
      scheme: w.scheme,
      userinfo: w.userinfo,
      port: w.port,
      path: w.path,
      query: w.query,
      nid: w.nid,
      nss: w.nss,
      uuid: w.uuid,
      fragment: w.fragment,
      reference: w.reference,
      resourceName: w.resourceName,
      secure: w.secure,
      error: ""
    }, _ = Object.assign({}, k), O = [], N = s[(_.scheme || E.scheme || "").toLowerCase()];
    N && N.serialize && N.serialize(E, _), E.path !== void 0 && (_.skipEscape ? E.path = unescape(E.path) : (E.path = escape(E.path), E.scheme !== void 0 && (E.path = E.path.split("%3A").join(":")))), _.reference !== "suffix" && E.scheme && O.push(E.scheme, ":");
    const A = r(E);
    if (A !== void 0 && (_.reference !== "suffix" && O.push("//"), O.push(A), E.path && E.path.charAt(0) !== "/" && O.push("/")), E.path !== void 0) {
      let R = E.path;
      !_.absolutePath && (!N || !N.absolutePath) && (R = n(R)), A === void 0 && (R = R.replace(/^\/\//u, "/%2F")), O.push(R);
    }
    return E.query !== void 0 && O.push("?", E.query), E.fragment !== void 0 && O.push("#", E.fragment), O.join("");
  }
  const h = Array.from({ length: 127 }, (w, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
  function v(w) {
    let k = 0;
    for (let E = 0, _ = w.length; E < _; ++E)
      if (k = w.charCodeAt(E), k > 126 || h[k])
        return !0;
    return !1;
  }
  const g = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function b(w, k) {
    const E = Object.assign({}, k), _ = {
      scheme: void 0,
      userinfo: void 0,
      host: "",
      port: void 0,
      path: "",
      query: void 0,
      fragment: void 0
    }, O = w.indexOf("%") !== -1;
    let N = !1;
    E.reference === "suffix" && (w = (E.scheme ? E.scheme + ":" : "") + "//" + w);
    const A = w.match(g);
    if (A) {
      if (_.scheme = A[1], _.userinfo = A[3], _.host = A[4], _.port = parseInt(A[5], 10), _.path = A[6] || "", _.query = A[7], _.fragment = A[8], isNaN(_.port) && (_.port = A[5]), _.host) {
        const D = t(_.host);
        if (D.isIPV4 === !1) {
          const I = e(D.host);
          _.host = I.host.toLowerCase(), N = I.isIPV6;
        } else
          _.host = D.host, N = !0;
      }
      _.scheme === void 0 && _.userinfo === void 0 && _.host === void 0 && _.port === void 0 && _.query === void 0 && !_.path ? _.reference = "same-document" : _.scheme === void 0 ? _.reference = "relative" : _.fragment === void 0 ? _.reference = "absolute" : _.reference = "uri", E.reference && E.reference !== "suffix" && E.reference !== _.reference && (_.error = _.error || "URI is not a " + E.reference + " reference.");
      const R = s[(E.scheme || _.scheme || "").toLowerCase()];
      if (!E.unicodeSupport && (!R || !R.unicodeSupport) && _.host && (E.domainHost || R && R.domainHost) && N === !1 && v(_.host))
        try {
          _.host = URL.domainToASCII(_.host.toLowerCase());
        } catch (D) {
          _.error = _.error || "Host's domain name can not be converted to ASCII: " + D;
        }
      (!R || R && !R.skipNormalize) && (O && _.scheme !== void 0 && (_.scheme = unescape(_.scheme)), O && _.host !== void 0 && (_.host = unescape(_.host)), _.path && (_.path = escape(unescape(_.path))), _.fragment && (_.fragment = encodeURI(decodeURIComponent(_.fragment)))), R && R.parse && R.parse(_, E);
    } else
      _.error = _.error || "URI can not be parsed.";
    return _;
  }
  const x = {
    SCHEMES: s,
    normalize: l,
    resolve: c,
    resolveComponents: d,
    equal: f,
    serialize: m,
    parse: b
  };
  return nx.exports = x, nx.exports.default = x, nx.exports.fastUri = x, nx.exports;
}
var zT;
function mAe() {
  if (zT) return x0;
  zT = 1, Object.defineProperty(x0, "__esModule", { value: !0 });
  const e = pAe();
  return e.code = 'require("ajv/dist/runtime/uri").default', x0.default = e, x0;
}
var TT;
function hAe() {
  return TT || (TT = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
    var t = RC();
    Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
      return t.KeywordCxt;
    } });
    var n = Yt();
    Object.defineProperty(e, "_", { enumerable: !0, get: function() {
      return n._;
    } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
      return n.str;
    } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
      return n.stringify;
    } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
      return n.nil;
    } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
      return n.Name;
    } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
      return n.CodeGen;
    } });
    const r = sP(), a = jC(), s = EK(), l = lP(), c = Yt(), d = AC(), f = W2(), m = vn(), h = uAe, v = mAe(), g = (V, F) => new RegExp(V, F);
    g.code = "new RegExp";
    const b = ["removeAdditional", "useDefaults", "coerceTypes"], x = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]), w = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    }, k = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    }, E = 200;
    function _(V) {
      var F, Y, U, W, J, oe, fe, ie, ce, ge, re, le, me, ve, xe, _e, Ge, Xe, tt, nt, je, cn, pt, Ce, Me;
      const he = V.strict, ye = (F = V.code) === null || F === void 0 ? void 0 : F.optimize, Ee = ye === !0 || ye === void 0 ? 1 : ye || 0, Te = (U = (Y = V.code) === null || Y === void 0 ? void 0 : Y.regExp) !== null && U !== void 0 ? U : g, Fe = (W = V.uriResolver) !== null && W !== void 0 ? W : v.default;
      return {
        strictSchema: (oe = (J = V.strictSchema) !== null && J !== void 0 ? J : he) !== null && oe !== void 0 ? oe : !0,
        strictNumbers: (ie = (fe = V.strictNumbers) !== null && fe !== void 0 ? fe : he) !== null && ie !== void 0 ? ie : !0,
        strictTypes: (ge = (ce = V.strictTypes) !== null && ce !== void 0 ? ce : he) !== null && ge !== void 0 ? ge : "log",
        strictTuples: (le = (re = V.strictTuples) !== null && re !== void 0 ? re : he) !== null && le !== void 0 ? le : "log",
        strictRequired: (ve = (me = V.strictRequired) !== null && me !== void 0 ? me : he) !== null && ve !== void 0 ? ve : !1,
        code: V.code ? { ...V.code, optimize: Ee, regExp: Te } : { optimize: Ee, regExp: Te },
        loopRequired: (xe = V.loopRequired) !== null && xe !== void 0 ? xe : E,
        loopEnum: (_e = V.loopEnum) !== null && _e !== void 0 ? _e : E,
        meta: (Ge = V.meta) !== null && Ge !== void 0 ? Ge : !0,
        messages: (Xe = V.messages) !== null && Xe !== void 0 ? Xe : !0,
        inlineRefs: (tt = V.inlineRefs) !== null && tt !== void 0 ? tt : !0,
        schemaId: (nt = V.schemaId) !== null && nt !== void 0 ? nt : "$id",
        addUsedSchema: (je = V.addUsedSchema) !== null && je !== void 0 ? je : !0,
        validateSchema: (cn = V.validateSchema) !== null && cn !== void 0 ? cn : !0,
        validateFormats: (pt = V.validateFormats) !== null && pt !== void 0 ? pt : !0,
        unicodeRegExp: (Ce = V.unicodeRegExp) !== null && Ce !== void 0 ? Ce : !0,
        int32range: (Me = V.int32range) !== null && Me !== void 0 ? Me : !0,
        uriResolver: Fe
      };
    }
    class O {
      constructor(F = {}) {
        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), F = this.opts = { ...F, ..._(F) };
        const { es5: Y, lines: U } = this.opts.code;
        this.scope = new c.ValueScope({ scope: {}, prefixes: x, es5: Y, lines: U }), this.logger = P(F.logger);
        const W = F.validateFormats;
        F.validateFormats = !1, this.RULES = (0, s.getRules)(), N.call(this, w, F, "NOT SUPPORTED"), N.call(this, k, F, "DEPRECATED", "warn"), this._metaOpts = z.call(this), F.formats && D.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), F.keywords && I.call(this, F.keywords), typeof F.meta == "object" && this.addMetaSchema(F.meta), R.call(this), F.validateFormats = W;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data: F, meta: Y, schemaId: U } = this.opts;
        let W = h;
        U === "id" && (W = { ...h }, W.id = W.$id, delete W.$id), Y && F && this.addMetaSchema(W, W[U], !1);
      }
      defaultMeta() {
        const { meta: F, schemaId: Y } = this.opts;
        return this.opts.defaultMeta = typeof F == "object" ? F[Y] || F : void 0;
      }
      validate(F, Y) {
        let U;
        if (typeof F == "string") {
          if (U = this.getSchema(F), !U)
            throw new Error(`no schema with key or ref "${F}"`);
        } else
          U = this.compile(F);
        const W = U(Y);
        return "$async" in U || (this.errors = U.errors), W;
      }
      compile(F, Y) {
        const U = this._addSchema(F, Y);
        return U.validate || this._compileSchemaEnv(U);
      }
      compileAsync(F, Y) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        const { loadSchema: U } = this.opts;
        return W.call(this, F, Y);
        async function W(ge, re) {
          await J.call(this, ge.$schema);
          const le = this._addSchema(ge, re);
          return le.validate || oe.call(this, le);
        }
        async function J(ge) {
          ge && !this.getSchema(ge) && await W.call(this, { $ref: ge }, !0);
        }
        async function oe(ge) {
          try {
            return this._compileSchemaEnv(ge);
          } catch (re) {
            if (!(re instanceof a.default))
              throw re;
            return fe.call(this, re), await ie.call(this, re.missingSchema), oe.call(this, ge);
          }
        }
        function fe({ missingSchema: ge, missingRef: re }) {
          if (this.refs[ge])
            throw new Error(`AnySchema ${ge} is loaded but ${re} cannot be resolved`);
        }
        async function ie(ge) {
          const re = await ce.call(this, ge);
          this.refs[ge] || await J.call(this, re.$schema), this.refs[ge] || this.addSchema(re, ge, Y);
        }
        async function ce(ge) {
          const re = this._loading[ge];
          if (re)
            return re;
          try {
            return await (this._loading[ge] = U(ge));
          } finally {
            delete this._loading[ge];
          }
        }
      }
      // Adds schema to the instance
      addSchema(F, Y, U, W = this.opts.validateSchema) {
        if (Array.isArray(F)) {
          for (const oe of F)
            this.addSchema(oe, void 0, U, W);
          return this;
        }
        let J;
        if (typeof F == "object") {
          const { schemaId: oe } = this.opts;
          if (J = F[oe], J !== void 0 && typeof J != "string")
            throw new Error(`schema ${oe} must be string`);
        }
        return Y = (0, d.normalizeId)(Y || J), this._checkUnique(Y), this.schemas[Y] = this._addSchema(F, U, Y, W, !0), this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(F, Y, U = this.opts.validateSchema) {
        return this.addSchema(F, Y, !0, U), this;
      }
      //  Validate schema against its meta-schema
      validateSchema(F, Y) {
        if (typeof F == "boolean")
          return !0;
        let U;
        if (U = F.$schema, U !== void 0 && typeof U != "string")
          throw new Error("$schema must be a string");
        if (U = U || this.opts.defaultMeta || this.defaultMeta(), !U)
          return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        const W = this.validate(U, F);
        if (!W && Y) {
          const J = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(J);
          else
            throw new Error(J);
        }
        return W;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(F) {
        let Y;
        for (; typeof (Y = A.call(this, F)) == "string"; )
          F = Y;
        if (Y === void 0) {
          const { schemaId: U } = this.opts, W = new l.SchemaEnv({ schema: {}, schemaId: U });
          if (Y = l.resolveSchema.call(this, W, F), !Y)
            return;
          this.refs[F] = Y;
        }
        return Y.validate || this._compileSchemaEnv(Y);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(F) {
        if (F instanceof RegExp)
          return this._removeAllSchemas(this.schemas, F), this._removeAllSchemas(this.refs, F), this;
        switch (typeof F) {
          case "undefined":
            return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
          case "string": {
            const Y = A.call(this, F);
            return typeof Y == "object" && this._cache.delete(Y.schema), delete this.schemas[F], delete this.refs[F], this;
          }
          case "object": {
            const Y = F;
            this._cache.delete(Y);
            let U = F[this.opts.schemaId];
            return U && (U = (0, d.normalizeId)(U), delete this.schemas[U], delete this.refs[U]), this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(F) {
        for (const Y of F)
          this.addKeyword(Y);
        return this;
      }
      addKeyword(F, Y) {
        let U;
        if (typeof F == "string")
          U = F, typeof Y == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), Y.keyword = U);
        else if (typeof F == "object" && Y === void 0) {
          if (Y = F, U = Y.keyword, Array.isArray(U) && !U.length)
            throw new Error("addKeywords: keyword must be string or non-empty array");
        } else
          throw new Error("invalid addKeywords parameters");
        if (L.call(this, U, Y), !Y)
          return (0, m.eachItem)(U, (J) => G.call(this, J)), this;
        K.call(this, Y);
        const W = {
          ...Y,
          type: (0, f.getJSONTypes)(Y.type),
          schemaType: (0, f.getJSONTypes)(Y.schemaType)
        };
        return (0, m.eachItem)(U, W.type.length === 0 ? (J) => G.call(this, J, W) : (J) => W.type.forEach((oe) => G.call(this, J, W, oe))), this;
      }
      getKeyword(F) {
        const Y = this.RULES.all[F];
        return typeof Y == "object" ? Y.definition : !!Y;
      }
      // Remove keyword
      removeKeyword(F) {
        const { RULES: Y } = this;
        delete Y.keywords[F], delete Y.all[F];
        for (const U of Y.rules) {
          const W = U.rules.findIndex((J) => J.keyword === F);
          W >= 0 && U.rules.splice(W, 1);
        }
        return this;
      }
      // Add format
      addFormat(F, Y) {
        return typeof Y == "string" && (Y = new RegExp(Y)), this.formats[F] = Y, this;
      }
      errorsText(F = this.errors, { separator: Y = ", ", dataVar: U = "data" } = {}) {
        return !F || F.length === 0 ? "No errors" : F.map((W) => `${U}${W.instancePath} ${W.message}`).reduce((W, J) => W + Y + J);
      }
      $dataMetaSchema(F, Y) {
        const U = this.RULES.all;
        F = JSON.parse(JSON.stringify(F));
        for (const W of Y) {
          const J = W.split("/").slice(1);
          let oe = F;
          for (const fe of J)
            oe = oe[fe];
          for (const fe in U) {
            const ie = U[fe];
            if (typeof ie != "object")
              continue;
            const { $data: ce } = ie.definition, ge = oe[fe];
            ce && ge && (oe[fe] = Z(ge));
          }
        }
        return F;
      }
      _removeAllSchemas(F, Y) {
        for (const U in F) {
          const W = F[U];
          (!Y || Y.test(U)) && (typeof W == "string" ? delete F[U] : W && !W.meta && (this._cache.delete(W.schema), delete F[U]));
        }
      }
      _addSchema(F, Y, U, W = this.opts.validateSchema, J = this.opts.addUsedSchema) {
        let oe;
        const { schemaId: fe } = this.opts;
        if (typeof F == "object")
          oe = F[fe];
        else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          if (typeof F != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let ie = this._cache.get(F);
        if (ie !== void 0)
          return ie;
        U = (0, d.normalizeId)(oe || U);
        const ce = d.getSchemaRefs.call(this, F, U);
        return ie = new l.SchemaEnv({ schema: F, schemaId: fe, meta: Y, baseId: U, localRefs: ce }), this._cache.set(ie.schema, ie), J && !U.startsWith("#") && (U && this._checkUnique(U), this.refs[U] = ie), W && this.validateSchema(F, !0), ie;
      }
      _checkUnique(F) {
        if (this.schemas[F] || this.refs[F])
          throw new Error(`schema with key or id "${F}" already exists`);
      }
      _compileSchemaEnv(F) {
        if (F.meta ? this._compileMetaSchema(F) : l.compileSchema.call(this, F), !F.validate)
          throw new Error("ajv implementation error");
        return F.validate;
      }
      _compileMetaSchema(F) {
        const Y = this.opts;
        this.opts = this._metaOpts;
        try {
          l.compileSchema.call(this, F);
        } finally {
          this.opts = Y;
        }
      }
    }
    O.ValidationError = r.default, O.MissingRefError = a.default, e.default = O;
    function N(V, F, Y, U = "error") {
      for (const W in V) {
        const J = W;
        J in F && this.logger[U](`${Y}: option ${W}. ${V[J]}`);
      }
    }
    function A(V) {
      return V = (0, d.normalizeId)(V), this.schemas[V] || this.refs[V];
    }
    function R() {
      const V = this.opts.schemas;
      if (V)
        if (Array.isArray(V))
          this.addSchema(V);
        else
          for (const F in V)
            this.addSchema(V[F], F);
    }
    function D() {
      for (const V in this.opts.formats) {
        const F = this.opts.formats[V];
        F && this.addFormat(V, F);
      }
    }
    function I(V) {
      if (Array.isArray(V)) {
        this.addVocabulary(V);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const F in V) {
        const Y = V[F];
        Y.keyword || (Y.keyword = F), this.addKeyword(Y);
      }
    }
    function z() {
      const V = { ...this.opts };
      for (const F of b)
        delete V[F];
      return V;
    }
    const B = { log() {
    }, warn() {
    }, error() {
    } };
    function P(V) {
      if (V === !1)
        return B;
      if (V === void 0)
        return console;
      if (V.log && V.warn && V.error)
        return V;
      throw new Error("logger must implement log, warn and error methods");
    }
    const H = /^[a-z_$][a-z0-9_$:-]*$/i;
    function L(V, F) {
      const { RULES: Y } = this;
      if ((0, m.eachItem)(V, (U) => {
        if (Y.keywords[U])
          throw new Error(`Keyword ${U} is already defined`);
        if (!H.test(U))
          throw new Error(`Keyword ${U} has invalid name`);
      }), !!F && F.$data && !("code" in F || "validate" in F))
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    function G(V, F, Y) {
      var U;
      const W = F?.post;
      if (Y && W)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES: J } = this;
      let oe = W ? J.post : J.rules.find(({ type: ie }) => ie === Y);
      if (oe || (oe = { type: Y, rules: [] }, J.rules.push(oe)), J.keywords[V] = !0, !F)
        return;
      const fe = {
        keyword: V,
        definition: {
          ...F,
          type: (0, f.getJSONTypes)(F.type),
          schemaType: (0, f.getJSONTypes)(F.schemaType)
        }
      };
      F.before ? $.call(this, oe, fe, F.before) : oe.rules.push(fe), J.all[V] = fe, (U = F.implements) === null || U === void 0 || U.forEach((ie) => this.addKeyword(ie));
    }
    function $(V, F, Y) {
      const U = V.rules.findIndex((W) => W.keyword === Y);
      U >= 0 ? V.rules.splice(U, 0, F) : (V.rules.push(F), this.logger.warn(`rule ${Y} is not defined`));
    }
    function K(V) {
      let { metaSchema: F } = V;
      F !== void 0 && (V.$data && this.opts.$data && (F = Z(F)), V.validateSchema = this.compile(F, !0));
    }
    const q = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function Z(V) {
      return { anyOf: [V, q] };
    }
  })(oT)), oT;
}
var S0 = {}, k0 = {}, _0 = {}, LT;
function gAe() {
  if (LT) return _0;
  LT = 1, Object.defineProperty(_0, "__esModule", { value: !0 });
  const e = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  return _0.default = e, _0;
}
var sd = {}, FT;
function vAe() {
  if (FT) return sd;
  FT = 1, Object.defineProperty(sd, "__esModule", { value: !0 }), sd.callRef = sd.getValidate = void 0;
  const e = jC(), t = ul(), n = Yt(), r = Vd(), a = lP(), s = vn(), l = {
    keyword: "$ref",
    schemaType: "string",
    code(f) {
      const { gen: m, schema: h, it: v } = f, { baseId: g, schemaEnv: b, validateName: x, opts: w, self: k } = v, { root: E } = b;
      if ((h === "#" || h === "#/") && g === E.baseId)
        return O();
      const _ = a.resolveRef.call(k, E, g, h);
      if (_ === void 0)
        throw new e.default(v.opts.uriResolver, g, h);
      if (_ instanceof a.SchemaEnv)
        return N(_);
      return A(_);
      function O() {
        if (b === E)
          return d(f, x, b, b.$async);
        const R = m.scopeValue("root", { ref: E });
        return d(f, (0, n._)`${R}.validate`, E, E.$async);
      }
      function N(R) {
        const D = c(f, R);
        d(f, D, R, R.$async);
      }
      function A(R) {
        const D = m.scopeValue("schema", w.code.source === !0 ? { ref: R, code: (0, n.stringify)(R) } : { ref: R }), I = m.name("valid"), z = f.subschema({
          schema: R,
          dataTypes: [],
          schemaPath: n.nil,
          topSchemaRef: D,
          errSchemaPath: h
        }, I);
        f.mergeEvaluated(z), f.ok(I);
      }
    }
  };
  function c(f, m) {
    const { gen: h } = f;
    return m.validate ? h.scopeValue("validate", { ref: m.validate }) : (0, n._)`${h.scopeValue("wrapper", { ref: m })}.validate`;
  }
  sd.getValidate = c;
  function d(f, m, h, v) {
    const { gen: g, it: b } = f, { allErrors: x, schemaEnv: w, opts: k } = b, E = k.passContext ? r.default.this : n.nil;
    v ? _() : O();
    function _() {
      if (!w.$async)
        throw new Error("async schema referenced by sync schema");
      const R = g.let("valid");
      g.try(() => {
        g.code((0, n._)`await ${(0, t.callValidateCode)(f, m, E)}`), A(m), x || g.assign(R, !0);
      }, (D) => {
        g.if((0, n._)`!(${D} instanceof ${b.ValidationError})`, () => g.throw(D)), N(D), x || g.assign(R, !1);
      }), f.ok(R);
    }
    function O() {
      f.result((0, t.callValidateCode)(f, m, E), () => A(m), () => N(m));
    }
    function N(R) {
      const D = (0, n._)`${R}.errors`;
      g.assign(r.default.vErrors, (0, n._)`${r.default.vErrors} === null ? ${D} : ${r.default.vErrors}.concat(${D})`), g.assign(r.default.errors, (0, n._)`${r.default.vErrors}.length`);
    }
    function A(R) {
      var D;
      if (!b.opts.unevaluated)
        return;
      const I = (D = h?.validate) === null || D === void 0 ? void 0 : D.evaluated;
      if (b.props !== !0)
        if (I && !I.dynamicProps)
          I.props !== void 0 && (b.props = s.mergeEvaluated.props(g, I.props, b.props));
        else {
          const z = g.var("props", (0, n._)`${R}.evaluated.props`);
          b.props = s.mergeEvaluated.props(g, z, b.props, n.Name);
        }
      if (b.items !== !0)
        if (I && !I.dynamicItems)
          I.items !== void 0 && (b.items = s.mergeEvaluated.items(g, I.items, b.items));
        else {
          const z = g.var("items", (0, n._)`${R}.evaluated.items`);
          b.items = s.mergeEvaluated.items(g, z, b.items, n.Name);
        }
    }
  }
  return sd.callRef = d, sd.default = l, sd;
}
var BT;
function yAe() {
  if (BT) return k0;
  BT = 1, Object.defineProperty(k0, "__esModule", { value: !0 });
  const e = gAe(), t = vAe(), n = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    e.default,
    t.default
  ];
  return k0.default = n, k0;
}
var E0 = {}, C0 = {}, UT;
function bAe() {
  if (UT) return C0;
  UT = 1, Object.defineProperty(C0, "__esModule", { value: !0 });
  const e = Yt(), t = e.operators, n = {
    maximum: { okStr: "<=", ok: t.LTE, fail: t.GT },
    minimum: { okStr: ">=", ok: t.GTE, fail: t.LT },
    exclusiveMaximum: { okStr: "<", ok: t.LT, fail: t.GTE },
    exclusiveMinimum: { okStr: ">", ok: t.GT, fail: t.LTE }
  }, r = {
    message: ({ keyword: s, schemaCode: l }) => (0, e.str)`must be ${n[s].okStr} ${l}`,
    params: ({ keyword: s, schemaCode: l }) => (0, e._)`{comparison: ${n[s].okStr}, limit: ${l}}`
  }, a = {
    keyword: Object.keys(n),
    type: "number",
    schemaType: "number",
    $data: !0,
    error: r,
    code(s) {
      const { keyword: l, data: c, schemaCode: d } = s;
      s.fail$data((0, e._)`${c} ${n[l].fail} ${d} || isNaN(${c})`);
    }
  };
  return C0.default = a, C0;
}
var O0 = {}, VT;
function wAe() {
  if (VT) return O0;
  VT = 1, Object.defineProperty(O0, "__esModule", { value: !0 });
  const e = Yt(), t = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, e.str)`must be multiple of ${n}`,
      params: ({ schemaCode: n }) => (0, e._)`{multipleOf: ${n}}`
    },
    code(n) {
      const { gen: r, data: a, schemaCode: s, it: l } = n, c = l.opts.multipleOfPrecision, d = r.let("res"), f = c ? (0, e._)`Math.abs(Math.round(${d}) - ${d}) > 1e-${c}` : (0, e._)`${d} !== parseInt(${d})`;
      n.fail$data((0, e._)`(${s} === 0 || (${d} = ${a}/${s}, ${f}))`);
    }
  };
  return O0.default = t, O0;
}
var M0 = {}, N0 = {}, HT;
function xAe() {
  if (HT) return N0;
  HT = 1, Object.defineProperty(N0, "__esModule", { value: !0 });
  function e(t) {
    const n = t.length;
    let r = 0, a = 0, s;
    for (; a < n; )
      r++, s = t.charCodeAt(a++), s >= 55296 && s <= 56319 && a < n && (s = t.charCodeAt(a), (s & 64512) === 56320 && a++);
    return r;
  }
  return N0.default = e, e.code = 'require("ajv/dist/runtime/ucs2length").default', N0;
}
var WT;
function SAe() {
  if (WT) return M0;
  WT = 1, Object.defineProperty(M0, "__esModule", { value: !0 });
  const e = Yt(), t = vn(), n = xAe(), r = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: a, schemaCode: s }) {
        const l = a === "maxLength" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${l} than ${s} characters`;
      },
      params: ({ schemaCode: a }) => (0, e._)`{limit: ${a}}`
    },
    code(a) {
      const { keyword: s, data: l, schemaCode: c, it: d } = a, f = s === "maxLength" ? e.operators.GT : e.operators.LT, m = d.opts.unicode === !1 ? (0, e._)`${l}.length` : (0, e._)`${(0, t.useFunc)(a.gen, n.default)}(${l})`;
      a.fail$data((0, e._)`${m} ${f} ${c}`);
    }
  };
  return M0.default = r, M0;
}
var A0 = {}, qT;
function kAe() {
  if (qT) return A0;
  qT = 1, Object.defineProperty(A0, "__esModule", { value: !0 });
  const e = ul(), t = Yt(), n = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: r }) => (0, t.str)`must match pattern "${r}"`,
      params: ({ schemaCode: r }) => (0, t._)`{pattern: ${r}}`
    },
    code(r) {
      const { data: a, $data: s, schema: l, schemaCode: c, it: d } = r, f = d.opts.unicodeRegExp ? "u" : "", m = s ? (0, t._)`(new RegExp(${c}, ${f}))` : (0, e.usePattern)(r, l);
      r.fail$data((0, t._)`!${m}.test(${a})`);
    }
  };
  return A0.default = n, A0;
}
var R0 = {}, GT;
function _Ae() {
  if (GT) return R0;
  GT = 1, Object.defineProperty(R0, "__esModule", { value: !0 });
  const e = Yt(), t = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: r }) {
        const a = n === "maxProperties" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${a} than ${r} properties`;
      },
      params: ({ schemaCode: n }) => (0, e._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: r, data: a, schemaCode: s } = n, l = r === "maxProperties" ? e.operators.GT : e.operators.LT;
      n.fail$data((0, e._)`Object.keys(${a}).length ${l} ${s}`);
    }
  };
  return R0.default = t, R0;
}
var j0 = {}, KT;
function EAe() {
  if (KT) return j0;
  KT = 1, Object.defineProperty(j0, "__esModule", { value: !0 });
  const e = ul(), t = Yt(), n = vn(), r = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: !0,
    error: {
      message: ({ params: { missingProperty: a } }) => (0, t.str)`must have required property '${a}'`,
      params: ({ params: { missingProperty: a } }) => (0, t._)`{missingProperty: ${a}}`
    },
    code(a) {
      const { gen: s, schema: l, schemaCode: c, data: d, $data: f, it: m } = a, { opts: h } = m;
      if (!f && l.length === 0)
        return;
      const v = l.length >= h.loopRequired;
      if (m.allErrors ? g() : b(), h.strictRequired) {
        const k = a.parentSchema.properties, { definedProperties: E } = a.it;
        for (const _ of l)
          if (k?.[_] === void 0 && !E.has(_)) {
            const O = m.schemaEnv.baseId + m.errSchemaPath, N = `required property "${_}" is not defined at "${O}" (strictRequired)`;
            (0, n.checkStrictMode)(m, N, m.opts.strictRequired);
          }
      }
      function g() {
        if (v || f)
          a.block$data(t.nil, x);
        else
          for (const k of l)
            (0, e.checkReportMissingProp)(a, k);
      }
      function b() {
        const k = s.let("missing");
        if (v || f) {
          const E = s.let("valid", !0);
          a.block$data(E, () => w(k, E)), a.ok(E);
        } else
          s.if((0, e.checkMissingProp)(a, l, k)), (0, e.reportMissingProp)(a, k), s.else();
      }
      function x() {
        s.forOf("prop", c, (k) => {
          a.setParams({ missingProperty: k }), s.if((0, e.noPropertyInData)(s, d, k, h.ownProperties), () => a.error());
        });
      }
      function w(k, E) {
        a.setParams({ missingProperty: k }), s.forOf(k, c, () => {
          s.assign(E, (0, e.propertyInData)(s, d, k, h.ownProperties)), s.if((0, t.not)(E), () => {
            a.error(), s.break();
          });
        }, t.nil);
      }
    }
  };
  return j0.default = r, j0;
}
var P0 = {}, YT;
function CAe() {
  if (YT) return P0;
  YT = 1, Object.defineProperty(P0, "__esModule", { value: !0 });
  const e = Yt(), t = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: n, schemaCode: r }) {
        const a = n === "maxItems" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${a} than ${r} items`;
      },
      params: ({ schemaCode: n }) => (0, e._)`{limit: ${n}}`
    },
    code(n) {
      const { keyword: r, data: a, schemaCode: s } = n, l = r === "maxItems" ? e.operators.GT : e.operators.LT;
      n.fail$data((0, e._)`${a}.length ${l} ${s}`);
    }
  };
  return P0.default = t, P0;
}
var D0 = {}, I0 = {}, XT;
function uP() {
  if (XT) return I0;
  XT = 1, Object.defineProperty(I0, "__esModule", { value: !0 });
  const e = OK();
  return e.code = 'require("ajv/dist/runtime/equal").default', I0.default = e, I0;
}
var JT;
function OAe() {
  if (JT) return D0;
  JT = 1, Object.defineProperty(D0, "__esModule", { value: !0 });
  const e = W2(), t = Yt(), n = vn(), r = uP(), a = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: !0,
    error: {
      message: ({ params: { i: s, j: l } }) => (0, t.str)`must NOT have duplicate items (items ## ${l} and ${s} are identical)`,
      params: ({ params: { i: s, j: l } }) => (0, t._)`{i: ${s}, j: ${l}}`
    },
    code(s) {
      const { gen: l, data: c, $data: d, schema: f, parentSchema: m, schemaCode: h, it: v } = s;
      if (!d && !f)
        return;
      const g = l.let("valid"), b = m.items ? (0, e.getSchemaTypes)(m.items) : [];
      s.block$data(g, x, (0, t._)`${h} === false`), s.ok(g);
      function x() {
        const _ = l.let("i", (0, t._)`${c}.length`), O = l.let("j");
        s.setParams({ i: _, j: O }), l.assign(g, !0), l.if((0, t._)`${_} > 1`, () => (w() ? k : E)(_, O));
      }
      function w() {
        return b.length > 0 && !b.some((_) => _ === "object" || _ === "array");
      }
      function k(_, O) {
        const N = l.name("item"), A = (0, e.checkDataTypes)(b, N, v.opts.strictNumbers, e.DataType.Wrong), R = l.const("indices", (0, t._)`{}`);
        l.for((0, t._)`;${_}--;`, () => {
          l.let(N, (0, t._)`${c}[${_}]`), l.if(A, (0, t._)`continue`), b.length > 1 && l.if((0, t._)`typeof ${N} == "string"`, (0, t._)`${N} += "_"`), l.if((0, t._)`typeof ${R}[${N}] == "number"`, () => {
            l.assign(O, (0, t._)`${R}[${N}]`), s.error(), l.assign(g, !1).break();
          }).code((0, t._)`${R}[${N}] = ${_}`);
        });
      }
      function E(_, O) {
        const N = (0, n.useFunc)(l, r.default), A = l.name("outer");
        l.label(A).for((0, t._)`;${_}--;`, () => l.for((0, t._)`${O} = ${_}; ${O}--;`, () => l.if((0, t._)`${N}(${c}[${_}], ${c}[${O}])`, () => {
          s.error(), l.assign(g, !1).break(A);
        })));
      }
    }
  };
  return D0.default = a, D0;
}
var $0 = {}, QT;
function MAe() {
  if (QT) return $0;
  QT = 1, Object.defineProperty($0, "__esModule", { value: !0 });
  const e = Yt(), t = vn(), n = uP(), r = {
    keyword: "const",
    $data: !0,
    error: {
      message: "must be equal to constant",
      params: ({ schemaCode: a }) => (0, e._)`{allowedValue: ${a}}`
    },
    code(a) {
      const { gen: s, data: l, $data: c, schemaCode: d, schema: f } = a;
      c || f && typeof f == "object" ? a.fail$data((0, e._)`!${(0, t.useFunc)(s, n.default)}(${l}, ${d})`) : a.fail((0, e._)`${f} !== ${l}`);
    }
  };
  return $0.default = r, $0;
}
var z0 = {}, ZT;
function NAe() {
  if (ZT) return z0;
  ZT = 1, Object.defineProperty(z0, "__esModule", { value: !0 });
  const e = Yt(), t = vn(), n = uP(), r = {
    keyword: "enum",
    schemaType: "array",
    $data: !0,
    error: {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode: a }) => (0, e._)`{allowedValues: ${a}}`
    },
    code(a) {
      const { gen: s, data: l, $data: c, schema: d, schemaCode: f, it: m } = a;
      if (!c && d.length === 0)
        throw new Error("enum must have non-empty array");
      const h = d.length >= m.opts.loopEnum;
      let v;
      const g = () => v ?? (v = (0, t.useFunc)(s, n.default));
      let b;
      if (h || c)
        b = s.let("valid"), a.block$data(b, x);
      else {
        if (!Array.isArray(d))
          throw new Error("ajv implementation error");
        const k = s.const("vSchema", f);
        b = (0, e.or)(...d.map((E, _) => w(k, _)));
      }
      a.pass(b);
      function x() {
        s.assign(b, !1), s.forOf("v", f, (k) => s.if((0, e._)`${g()}(${l}, ${k})`, () => s.assign(b, !0).break()));
      }
      function w(k, E) {
        const _ = d[E];
        return typeof _ == "object" && _ !== null ? (0, e._)`${g()}(${l}, ${k}[${E}])` : (0, e._)`${l} === ${_}`;
      }
    }
  };
  return z0.default = r, z0;
}
var eL;
function AAe() {
  if (eL) return E0;
  eL = 1, Object.defineProperty(E0, "__esModule", { value: !0 });
  const e = bAe(), t = wAe(), n = SAe(), r = kAe(), a = _Ae(), s = EAe(), l = CAe(), c = OAe(), d = MAe(), f = NAe(), m = [
    // number
    e.default,
    t.default,
    // string
    n.default,
    r.default,
    // object
    a.default,
    s.default,
    // array
    l.default,
    c.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    d.default,
    f.default
  ];
  return E0.default = m, E0;
}
var T0 = {}, Ch = {}, tL;
function MK() {
  if (tL) return Ch;
  tL = 1, Object.defineProperty(Ch, "__esModule", { value: !0 }), Ch.validateAdditionalItems = void 0;
  const e = Yt(), t = vn(), n = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: a } }) => (0, e.str)`must NOT have more than ${a} items`,
      params: ({ params: { len: a } }) => (0, e._)`{limit: ${a}}`
    },
    code(a) {
      const { parentSchema: s, it: l } = a, { items: c } = s;
      if (!Array.isArray(c)) {
        (0, t.checkStrictMode)(l, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      r(a, c);
    }
  };
  function r(a, s) {
    const { gen: l, schema: c, data: d, keyword: f, it: m } = a;
    m.items = !0;
    const h = l.const("len", (0, e._)`${d}.length`);
    if (c === !1)
      a.setParams({ len: s.length }), a.pass((0, e._)`${h} <= ${s.length}`);
    else if (typeof c == "object" && !(0, t.alwaysValidSchema)(m, c)) {
      const g = l.var("valid", (0, e._)`${h} <= ${s.length}`);
      l.if((0, e.not)(g), () => v(g)), a.ok(g);
    }
    function v(g) {
      l.forRange("i", s.length, h, (b) => {
        a.subschema({ keyword: f, dataProp: b, dataPropType: t.Type.Num }, g), m.allErrors || l.if((0, e.not)(g), () => l.break());
      });
    }
  }
  return Ch.validateAdditionalItems = r, Ch.default = n, Ch;
}
var L0 = {}, Oh = {}, nL;
function NK() {
  if (nL) return Oh;
  nL = 1, Object.defineProperty(Oh, "__esModule", { value: !0 }), Oh.validateTuple = void 0;
  const e = Yt(), t = vn(), n = ul(), r = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(s) {
      const { schema: l, it: c } = s;
      if (Array.isArray(l))
        return a(s, "additionalItems", l);
      c.items = !0, !(0, t.alwaysValidSchema)(c, l) && s.ok((0, n.validateArray)(s));
    }
  };
  function a(s, l, c = s.schema) {
    const { gen: d, parentSchema: f, data: m, keyword: h, it: v } = s;
    x(f), v.opts.unevaluated && c.length && v.items !== !0 && (v.items = t.mergeEvaluated.items(d, c.length, v.items));
    const g = d.name("valid"), b = d.const("len", (0, e._)`${m}.length`);
    c.forEach((w, k) => {
      (0, t.alwaysValidSchema)(v, w) || (d.if((0, e._)`${b} > ${k}`, () => s.subschema({
        keyword: h,
        schemaProp: k,
        dataProp: k
      }, g)), s.ok(g));
    });
    function x(w) {
      const { opts: k, errSchemaPath: E } = v, _ = c.length, O = _ === w.minItems && (_ === w.maxItems || w[l] === !1);
      if (k.strictTuples && !O) {
        const N = `"${h}" is ${_}-tuple, but minItems or maxItems/${l} are not specified or different at path "${E}"`;
        (0, t.checkStrictMode)(v, N, k.strictTuples);
      }
    }
  }
  return Oh.validateTuple = a, Oh.default = r, Oh;
}
var rL;
function RAe() {
  if (rL) return L0;
  rL = 1, Object.defineProperty(L0, "__esModule", { value: !0 });
  const e = NK(), t = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (n) => (0, e.validateTuple)(n, "items")
  };
  return L0.default = t, L0;
}
var F0 = {}, oL;
function jAe() {
  if (oL) return F0;
  oL = 1, Object.defineProperty(F0, "__esModule", { value: !0 });
  const e = Yt(), t = vn(), n = ul(), r = MK(), a = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: s } }) => (0, e.str)`must NOT have more than ${s} items`,
      params: ({ params: { len: s } }) => (0, e._)`{limit: ${s}}`
    },
    code(s) {
      const { schema: l, parentSchema: c, it: d } = s, { prefixItems: f } = c;
      d.items = !0, !(0, t.alwaysValidSchema)(d, l) && (f ? (0, r.validateAdditionalItems)(s, f) : s.ok((0, n.validateArray)(s)));
    }
  };
  return F0.default = a, F0;
}
var B0 = {}, aL;
function PAe() {
  if (aL) return B0;
  aL = 1, Object.defineProperty(B0, "__esModule", { value: !0 });
  const e = Yt(), t = vn(), n = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: !0,
    error: {
      message: ({ params: { min: r, max: a } }) => a === void 0 ? (0, e.str)`must contain at least ${r} valid item(s)` : (0, e.str)`must contain at least ${r} and no more than ${a} valid item(s)`,
      params: ({ params: { min: r, max: a } }) => a === void 0 ? (0, e._)`{minContains: ${r}}` : (0, e._)`{minContains: ${r}, maxContains: ${a}}`
    },
    code(r) {
      const { gen: a, schema: s, parentSchema: l, data: c, it: d } = r;
      let f, m;
      const { minContains: h, maxContains: v } = l;
      d.opts.next ? (f = h === void 0 ? 1 : h, m = v) : f = 1;
      const g = a.const("len", (0, e._)`${c}.length`);
      if (r.setParams({ min: f, max: m }), m === void 0 && f === 0) {
        (0, t.checkStrictMode)(d, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
        return;
      }
      if (m !== void 0 && f > m) {
        (0, t.checkStrictMode)(d, '"minContains" > "maxContains" is always invalid'), r.fail();
        return;
      }
      if ((0, t.alwaysValidSchema)(d, s)) {
        let E = (0, e._)`${g} >= ${f}`;
        m !== void 0 && (E = (0, e._)`${E} && ${g} <= ${m}`), r.pass(E);
        return;
      }
      d.items = !0;
      const b = a.name("valid");
      m === void 0 && f === 1 ? w(b, () => a.if(b, () => a.break())) : f === 0 ? (a.let(b, !0), m !== void 0 && a.if((0, e._)`${c}.length > 0`, x)) : (a.let(b, !1), x()), r.result(b, () => r.reset());
      function x() {
        const E = a.name("_valid"), _ = a.let("count", 0);
        w(E, () => a.if(E, () => k(_)));
      }
      function w(E, _) {
        a.forRange("i", 0, g, (O) => {
          r.subschema({
            keyword: "contains",
            dataProp: O,
            dataPropType: t.Type.Num,
            compositeRule: !0
          }, E), _();
        });
      }
      function k(E) {
        a.code((0, e._)`${E}++`), m === void 0 ? a.if((0, e._)`${E} >= ${f}`, () => a.assign(b, !0).break()) : (a.if((0, e._)`${E} > ${m}`, () => a.assign(b, !1).break()), f === 1 ? a.assign(b, !0) : a.if((0, e._)`${E} >= ${f}`, () => a.assign(b, !0)));
      }
    }
  };
  return B0.default = n, B0;
}
var iL = {}, sL;
function DAe() {
  return sL || (sL = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
    const t = Yt(), n = vn(), r = ul();
    e.error = {
      message: ({ params: { property: d, depsCount: f, deps: m } }) => {
        const h = f === 1 ? "property" : "properties";
        return (0, t.str)`must have ${h} ${m} when property ${d} is present`;
      },
      params: ({ params: { property: d, depsCount: f, deps: m, missingProperty: h } }) => (0, t._)`{property: ${d},
    missingProperty: ${h},
    depsCount: ${f},
    deps: ${m}}`
      // TODO change to reference
    };
    const a = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: e.error,
      code(d) {
        const [f, m] = s(d);
        l(d, f), c(d, m);
      }
    };
    function s({ schema: d }) {
      const f = {}, m = {};
      for (const h in d) {
        if (h === "__proto__")
          continue;
        const v = Array.isArray(d[h]) ? f : m;
        v[h] = d[h];
      }
      return [f, m];
    }
    function l(d, f = d.schema) {
      const { gen: m, data: h, it: v } = d;
      if (Object.keys(f).length === 0)
        return;
      const g = m.let("missing");
      for (const b in f) {
        const x = f[b];
        if (x.length === 0)
          continue;
        const w = (0, r.propertyInData)(m, h, b, v.opts.ownProperties);
        d.setParams({
          property: b,
          depsCount: x.length,
          deps: x.join(", ")
        }), v.allErrors ? m.if(w, () => {
          for (const k of x)
            (0, r.checkReportMissingProp)(d, k);
        }) : (m.if((0, t._)`${w} && (${(0, r.checkMissingProp)(d, x, g)})`), (0, r.reportMissingProp)(d, g), m.else());
      }
    }
    e.validatePropertyDeps = l;
    function c(d, f = d.schema) {
      const { gen: m, data: h, keyword: v, it: g } = d, b = m.name("valid");
      for (const x in f)
        (0, n.alwaysValidSchema)(g, f[x]) || (m.if(
          (0, r.propertyInData)(m, h, x, g.opts.ownProperties),
          () => {
            const w = d.subschema({ keyword: v, schemaProp: x }, b);
            d.mergeValidEvaluated(w, b);
          },
          () => m.var(b, !0)
          // TODO var
        ), d.ok(b));
    }
    e.validateSchemaDeps = c, e.default = a;
  })(iL)), iL;
}
var U0 = {}, lL;
function IAe() {
  if (lL) return U0;
  lL = 1, Object.defineProperty(U0, "__esModule", { value: !0 });
  const e = Yt(), t = vn(), n = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: {
      message: "property name must be valid",
      params: ({ params: r }) => (0, e._)`{propertyName: ${r.propertyName}}`
    },
    code(r) {
      const { gen: a, schema: s, data: l, it: c } = r;
      if ((0, t.alwaysValidSchema)(c, s))
        return;
      const d = a.name("valid");
      a.forIn("key", l, (f) => {
        r.setParams({ propertyName: f }), r.subschema({
          keyword: "propertyNames",
          data: f,
          dataTypes: ["string"],
          propertyName: f,
          compositeRule: !0
        }, d), a.if((0, e.not)(d), () => {
          r.error(!0), c.allErrors || a.break();
        });
      }), r.ok(d);
    }
  };
  return U0.default = n, U0;
}
var V0 = {}, uL;
function AK() {
  if (uL) return V0;
  uL = 1, Object.defineProperty(V0, "__esModule", { value: !0 });
  const e = ul(), t = Yt(), n = Vd(), r = vn(), a = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: {
      message: "must NOT have additional properties",
      params: ({ params: s }) => (0, t._)`{additionalProperty: ${s.additionalProperty}}`
    },
    code(s) {
      const { gen: l, schema: c, parentSchema: d, data: f, errsCount: m, it: h } = s;
      if (!m)
        throw new Error("ajv implementation error");
      const { allErrors: v, opts: g } = h;
      if (h.props = !0, g.removeAdditional !== "all" && (0, r.alwaysValidSchema)(h, c))
        return;
      const b = (0, e.allSchemaProperties)(d.properties), x = (0, e.allSchemaProperties)(d.patternProperties);
      w(), s.ok((0, t._)`${m} === ${n.default.errors}`);
      function w() {
        l.forIn("key", f, (N) => {
          !b.length && !x.length ? _(N) : l.if(k(N), () => _(N));
        });
      }
      function k(N) {
        let A;
        if (b.length > 8) {
          const R = (0, r.schemaRefOrVal)(h, d.properties, "properties");
          A = (0, e.isOwnProperty)(l, R, N);
        } else b.length ? A = (0, t.or)(...b.map((R) => (0, t._)`${N} === ${R}`)) : A = t.nil;
        return x.length && (A = (0, t.or)(A, ...x.map((R) => (0, t._)`${(0, e.usePattern)(s, R)}.test(${N})`))), (0, t.not)(A);
      }
      function E(N) {
        l.code((0, t._)`delete ${f}[${N}]`);
      }
      function _(N) {
        if (g.removeAdditional === "all" || g.removeAdditional && c === !1) {
          E(N);
          return;
        }
        if (c === !1) {
          s.setParams({ additionalProperty: N }), s.error(), v || l.break();
          return;
        }
        if (typeof c == "object" && !(0, r.alwaysValidSchema)(h, c)) {
          const A = l.name("valid");
          g.removeAdditional === "failing" ? (O(N, A, !1), l.if((0, t.not)(A), () => {
            s.reset(), E(N);
          })) : (O(N, A), v || l.if((0, t.not)(A), () => l.break()));
        }
      }
      function O(N, A, R) {
        const D = {
          keyword: "additionalProperties",
          dataProp: N,
          dataPropType: r.Type.Str
        };
        R === !1 && Object.assign(D, {
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }), s.subschema(D, A);
      }
    }
  };
  return V0.default = a, V0;
}
var H0 = {}, cL;
function $Ae() {
  if (cL) return H0;
  cL = 1, Object.defineProperty(H0, "__esModule", { value: !0 });
  const e = RC(), t = ul(), n = vn(), r = AK(), a = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(s) {
      const { gen: l, schema: c, parentSchema: d, data: f, it: m } = s;
      m.opts.removeAdditional === "all" && d.additionalProperties === void 0 && r.default.code(new e.KeywordCxt(m, r.default, "additionalProperties"));
      const h = (0, t.allSchemaProperties)(c);
      for (const w of h)
        m.definedProperties.add(w);
      m.opts.unevaluated && h.length && m.props !== !0 && (m.props = n.mergeEvaluated.props(l, (0, n.toHash)(h), m.props));
      const v = h.filter((w) => !(0, n.alwaysValidSchema)(m, c[w]));
      if (v.length === 0)
        return;
      const g = l.name("valid");
      for (const w of v)
        b(w) ? x(w) : (l.if((0, t.propertyInData)(l, f, w, m.opts.ownProperties)), x(w), m.allErrors || l.else().var(g, !0), l.endIf()), s.it.definedProperties.add(w), s.ok(g);
      function b(w) {
        return m.opts.useDefaults && !m.compositeRule && c[w].default !== void 0;
      }
      function x(w) {
        s.subschema({
          keyword: "properties",
          schemaProp: w,
          dataProp: w
        }, g);
      }
    }
  };
  return H0.default = a, H0;
}
var W0 = {}, dL;
function zAe() {
  if (dL) return W0;
  dL = 1, Object.defineProperty(W0, "__esModule", { value: !0 });
  const e = ul(), t = Yt(), n = vn(), r = vn(), a = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(s) {
      const { gen: l, schema: c, data: d, parentSchema: f, it: m } = s, { opts: h } = m, v = (0, e.allSchemaProperties)(c), g = v.filter((O) => (0, n.alwaysValidSchema)(m, c[O]));
      if (v.length === 0 || g.length === v.length && (!m.opts.unevaluated || m.props === !0))
        return;
      const b = h.strictSchema && !h.allowMatchingProperties && f.properties, x = l.name("valid");
      m.props !== !0 && !(m.props instanceof t.Name) && (m.props = (0, r.evaluatedPropsToName)(l, m.props));
      const { props: w } = m;
      k();
      function k() {
        for (const O of v)
          b && E(O), m.allErrors ? _(O) : (l.var(x, !0), _(O), l.if(x));
      }
      function E(O) {
        for (const N in b)
          new RegExp(O).test(N) && (0, n.checkStrictMode)(m, `property ${N} matches pattern ${O} (use allowMatchingProperties)`);
      }
      function _(O) {
        l.forIn("key", d, (N) => {
          l.if((0, t._)`${(0, e.usePattern)(s, O)}.test(${N})`, () => {
            const A = g.includes(O);
            A || s.subschema({
              keyword: "patternProperties",
              schemaProp: O,
              dataProp: N,
              dataPropType: r.Type.Str
            }, x), m.opts.unevaluated && w !== !0 ? l.assign((0, t._)`${w}[${N}]`, !0) : !A && !m.allErrors && l.if((0, t.not)(x), () => l.break());
          });
        });
      }
    }
  };
  return W0.default = a, W0;
}
var q0 = {}, fL;
function TAe() {
  if (fL) return q0;
  fL = 1, Object.defineProperty(q0, "__esModule", { value: !0 });
  const e = vn(), t = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    code(n) {
      const { gen: r, schema: a, it: s } = n;
      if ((0, e.alwaysValidSchema)(s, a)) {
        n.fail();
        return;
      }
      const l = r.name("valid");
      n.subschema({
        keyword: "not",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, l), n.failResult(l, () => n.reset(), () => n.error());
    },
    error: { message: "must NOT be valid" }
  };
  return q0.default = t, q0;
}
var G0 = {}, pL;
function LAe() {
  if (pL) return G0;
  pL = 1, Object.defineProperty(G0, "__esModule", { value: !0 });
  const e = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: !0,
    code: ul().validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  return G0.default = e, G0;
}
var K0 = {}, mL;
function FAe() {
  if (mL) return K0;
  mL = 1, Object.defineProperty(K0, "__esModule", { value: !0 });
  const e = Yt(), t = vn(), n = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: !0,
    error: {
      message: "must match exactly one schema in oneOf",
      params: ({ params: r }) => (0, e._)`{passingSchemas: ${r.passing}}`
    },
    code(r) {
      const { gen: a, schema: s, parentSchema: l, it: c } = r;
      if (!Array.isArray(s))
        throw new Error("ajv implementation error");
      if (c.opts.discriminator && l.discriminator)
        return;
      const d = s, f = a.let("valid", !1), m = a.let("passing", null), h = a.name("_valid");
      r.setParams({ passing: m }), a.block(v), r.result(f, () => r.reset(), () => r.error(!0));
      function v() {
        d.forEach((g, b) => {
          let x;
          (0, t.alwaysValidSchema)(c, g) ? a.var(h, !0) : x = r.subschema({
            keyword: "oneOf",
            schemaProp: b,
            compositeRule: !0
          }, h), b > 0 && a.if((0, e._)`${h} && ${f}`).assign(f, !1).assign(m, (0, e._)`[${m}, ${b}]`).else(), a.if(h, () => {
            a.assign(f, !0), a.assign(m, b), x && r.mergeEvaluated(x, e.Name);
          });
        });
      }
    }
  };
  return K0.default = n, K0;
}
var Y0 = {}, hL;
function BAe() {
  if (hL) return Y0;
  hL = 1, Object.defineProperty(Y0, "__esModule", { value: !0 });
  const e = vn(), t = {
    keyword: "allOf",
    schemaType: "array",
    code(n) {
      const { gen: r, schema: a, it: s } = n;
      if (!Array.isArray(a))
        throw new Error("ajv implementation error");
      const l = r.name("valid");
      a.forEach((c, d) => {
        if ((0, e.alwaysValidSchema)(s, c))
          return;
        const f = n.subschema({ keyword: "allOf", schemaProp: d }, l);
        n.ok(l), n.mergeEvaluated(f);
      });
    }
  };
  return Y0.default = t, Y0;
}
var X0 = {}, gL;
function UAe() {
  if (gL) return X0;
  gL = 1, Object.defineProperty(X0, "__esModule", { value: !0 });
  const e = Yt(), t = vn(), n = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    error: {
      message: ({ params: a }) => (0, e.str)`must match "${a.ifClause}" schema`,
      params: ({ params: a }) => (0, e._)`{failingKeyword: ${a.ifClause}}`
    },
    code(a) {
      const { gen: s, parentSchema: l, it: c } = a;
      l.then === void 0 && l.else === void 0 && (0, t.checkStrictMode)(c, '"if" without "then" and "else" is ignored');
      const d = r(c, "then"), f = r(c, "else");
      if (!d && !f)
        return;
      const m = s.let("valid", !0), h = s.name("_valid");
      if (v(), a.reset(), d && f) {
        const b = s.let("ifClause");
        a.setParams({ ifClause: b }), s.if(h, g("then", b), g("else", b));
      } else d ? s.if(h, g("then")) : s.if((0, e.not)(h), g("else"));
      a.pass(m, () => a.error(!0));
      function v() {
        const b = a.subschema({
          keyword: "if",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, h);
        a.mergeEvaluated(b);
      }
      function g(b, x) {
        return () => {
          const w = a.subschema({ keyword: b }, h);
          s.assign(m, h), a.mergeValidEvaluated(w, m), x ? s.assign(x, (0, e._)`${b}`) : a.setParams({ ifClause: b });
        };
      }
    }
  };
  function r(a, s) {
    const l = a.schema[s];
    return l !== void 0 && !(0, t.alwaysValidSchema)(a, l);
  }
  return X0.default = n, X0;
}
var J0 = {}, vL;
function VAe() {
  if (vL) return J0;
  vL = 1, Object.defineProperty(J0, "__esModule", { value: !0 });
  const e = vn(), t = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: n, parentSchema: r, it: a }) {
      r.if === void 0 && (0, e.checkStrictMode)(a, `"${n}" without "if" is ignored`);
    }
  };
  return J0.default = t, J0;
}
var yL;
function HAe() {
  if (yL) return T0;
  yL = 1, Object.defineProperty(T0, "__esModule", { value: !0 });
  const e = MK(), t = RAe(), n = NK(), r = jAe(), a = PAe(), s = DAe(), l = IAe(), c = AK(), d = $Ae(), f = zAe(), m = TAe(), h = LAe(), v = FAe(), g = BAe(), b = UAe(), x = VAe();
  function w(k = !1) {
    const E = [
      // any
      m.default,
      h.default,
      v.default,
      g.default,
      b.default,
      x.default,
      // object
      l.default,
      c.default,
      s.default,
      d.default,
      f.default
    ];
    return k ? E.push(t.default, r.default) : E.push(e.default, n.default), E.push(a.default), E;
  }
  return T0.default = w, T0;
}
var Q0 = {}, Z0 = {}, bL;
function WAe() {
  if (bL) return Z0;
  bL = 1, Object.defineProperty(Z0, "__esModule", { value: !0 });
  const e = Yt(), t = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, e.str)`must match format "${n}"`,
      params: ({ schemaCode: n }) => (0, e._)`{format: ${n}}`
    },
    code(n, r) {
      const { gen: a, data: s, $data: l, schema: c, schemaCode: d, it: f } = n, { opts: m, errSchemaPath: h, schemaEnv: v, self: g } = f;
      if (!m.validateFormats)
        return;
      l ? b() : x();
      function b() {
        const w = a.scopeValue("formats", {
          ref: g.formats,
          code: m.code.formats
        }), k = a.const("fDef", (0, e._)`${w}[${d}]`), E = a.let("fType"), _ = a.let("format");
        a.if((0, e._)`typeof ${k} == "object" && !(${k} instanceof RegExp)`, () => a.assign(E, (0, e._)`${k}.type || "string"`).assign(_, (0, e._)`${k}.validate`), () => a.assign(E, (0, e._)`"string"`).assign(_, k)), n.fail$data((0, e.or)(O(), N()));
        function O() {
          return m.strictSchema === !1 ? e.nil : (0, e._)`${d} && !${_}`;
        }
        function N() {
          const A = v.$async ? (0, e._)`(${k}.async ? await ${_}(${s}) : ${_}(${s}))` : (0, e._)`${_}(${s})`, R = (0, e._)`(typeof ${_} == "function" ? ${A} : ${_}.test(${s}))`;
          return (0, e._)`${_} && ${_} !== true && ${E} === ${r} && !${R}`;
        }
      }
      function x() {
        const w = g.formats[c];
        if (!w) {
          O();
          return;
        }
        if (w === !0)
          return;
        const [k, E, _] = N(w);
        k === r && n.pass(A());
        function O() {
          if (m.strictSchema === !1) {
            g.logger.warn(R());
            return;
          }
          throw new Error(R());
          function R() {
            return `unknown format "${c}" ignored in schema at path "${h}"`;
          }
        }
        function N(R) {
          const D = R instanceof RegExp ? (0, e.regexpCode)(R) : m.code.formats ? (0, e._)`${m.code.formats}${(0, e.getProperty)(c)}` : void 0, I = a.scopeValue("formats", { key: c, ref: R, code: D });
          return typeof R == "object" && !(R instanceof RegExp) ? [R.type || "string", R.validate, (0, e._)`${I}.validate`] : ["string", R, I];
        }
        function A() {
          if (typeof w == "object" && !(w instanceof RegExp) && w.async) {
            if (!v.$async)
              throw new Error("async format in sync schema");
            return (0, e._)`await ${_}(${s})`;
          }
          return typeof E == "function" ? (0, e._)`${_}(${s})` : (0, e._)`${_}.test(${s})`;
        }
      }
    }
  };
  return Z0.default = t, Z0;
}
var wL;
function qAe() {
  if (wL) return Q0;
  wL = 1, Object.defineProperty(Q0, "__esModule", { value: !0 });
  const e = [WAe().default];
  return Q0.default = e, Q0;
}
var Mh = {}, xL;
function GAe() {
  return xL || (xL = 1, Object.defineProperty(Mh, "__esModule", { value: !0 }), Mh.contentVocabulary = Mh.metadataVocabulary = void 0, Mh.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ], Mh.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ]), Mh;
}
var SL;
function KAe() {
  if (SL) return S0;
  SL = 1, Object.defineProperty(S0, "__esModule", { value: !0 });
  const e = yAe(), t = AAe(), n = HAe(), r = qAe(), a = GAe(), s = [
    e.default,
    t.default,
    (0, n.default)(),
    r.default,
    a.metadataVocabulary,
    a.contentVocabulary
  ];
  return S0.default = s, S0;
}
var e_ = {}, rx = {}, kL;
function YAe() {
  if (kL) return rx;
  kL = 1, Object.defineProperty(rx, "__esModule", { value: !0 }), rx.DiscrError = void 0;
  var e;
  return (function(t) {
    t.Tag = "tag", t.Mapping = "mapping";
  })(e || (rx.DiscrError = e = {})), rx;
}
var _L;
function XAe() {
  if (_L) return e_;
  _L = 1, Object.defineProperty(e_, "__esModule", { value: !0 });
  const e = Yt(), t = YAe(), n = lP(), r = jC(), a = vn(), s = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: {
      message: ({ params: { discrError: l, tagName: c } }) => l === t.DiscrError.Tag ? `tag "${c}" must be string` : `value of tag "${c}" must be in oneOf`,
      params: ({ params: { discrError: l, tag: c, tagName: d } }) => (0, e._)`{error: ${l}, tag: ${d}, tagValue: ${c}}`
    },
    code(l) {
      const { gen: c, data: d, schema: f, parentSchema: m, it: h } = l, { oneOf: v } = m;
      if (!h.opts.discriminator)
        throw new Error("discriminator: requires discriminator option");
      const g = f.propertyName;
      if (typeof g != "string")
        throw new Error("discriminator: requires propertyName");
      if (f.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!v)
        throw new Error("discriminator: requires oneOf keyword");
      const b = c.let("valid", !1), x = c.const("tag", (0, e._)`${d}${(0, e.getProperty)(g)}`);
      c.if((0, e._)`typeof ${x} == "string"`, () => w(), () => l.error(!1, { discrError: t.DiscrError.Tag, tag: x, tagName: g })), l.ok(b);
      function w() {
        const _ = E();
        c.if(!1);
        for (const O in _)
          c.elseIf((0, e._)`${x} === ${O}`), c.assign(b, k(_[O]));
        c.else(), l.error(!1, { discrError: t.DiscrError.Mapping, tag: x, tagName: g }), c.endIf();
      }
      function k(_) {
        const O = c.name("valid"), N = l.subschema({ keyword: "oneOf", schemaProp: _ }, O);
        return l.mergeEvaluated(N, e.Name), O;
      }
      function E() {
        var _;
        const O = {}, N = R(m);
        let A = !0;
        for (let z = 0; z < v.length; z++) {
          let B = v[z];
          if (B?.$ref && !(0, a.schemaHasRulesButRef)(B, h.self.RULES)) {
            const H = B.$ref;
            if (B = n.resolveRef.call(h.self, h.schemaEnv.root, h.baseId, H), B instanceof n.SchemaEnv && (B = B.schema), B === void 0)
              throw new r.default(h.opts.uriResolver, h.baseId, H);
          }
          const P = (_ = B?.properties) === null || _ === void 0 ? void 0 : _[g];
          if (typeof P != "object")
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${g}"`);
          A = A && (N || R(B)), D(P, z);
        }
        if (!A)
          throw new Error(`discriminator: "${g}" must be required`);
        return O;
        function R({ required: z }) {
          return Array.isArray(z) && z.includes(g);
        }
        function D(z, B) {
          if (z.const)
            I(z.const, B);
          else if (z.enum)
            for (const P of z.enum)
              I(P, B);
          else
            throw new Error(`discriminator: "properties/${g}" must have "const" or "enum"`);
        }
        function I(z, B) {
          if (typeof z != "string" || z in O)
            throw new Error(`discriminator: "${g}" values must be unique strings`);
          O[z] = B;
        }
      }
    }
  };
  return e_.default = s, e_;
}
const JAe = "http://json-schema.org/draft-07/schema#", QAe = "http://json-schema.org/draft-07/schema#", ZAe = "Core schema meta-schema", e3e = { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, t3e = ["object", "boolean"], n3e = { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: !0, readOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: !0 }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: !0, enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, r3e = {
  $schema: JAe,
  $id: QAe,
  title: ZAe,
  definitions: e3e,
  type: t3e,
  properties: n3e,
  default: !0
};
var EL;
function RK() {
  return EL || (EL = 1, (function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = t.Ajv = void 0;
    const n = hAe(), r = KAe(), a = XAe(), s = r3e, l = ["/properties"], c = "http://json-schema.org/draft-07/schema";
    class d extends n.default {
      _addVocabularies() {
        super._addVocabularies(), r.default.forEach((b) => this.addVocabulary(b)), this.opts.discriminator && this.addKeyword(a.default);
      }
      _addDefaultMetaSchema() {
        if (super._addDefaultMetaSchema(), !this.opts.meta)
          return;
        const b = this.opts.$data ? this.$dataMetaSchema(s, l) : s;
        this.addMetaSchema(b, c, !1), this.refs["http://json-schema.org/schema"] = c;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(c) ? c : void 0);
      }
    }
    t.Ajv = d, e.exports = t = d, e.exports.Ajv = d, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = d;
    var f = RC();
    Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
      return f.KeywordCxt;
    } });
    var m = Yt();
    Object.defineProperty(t, "_", { enumerable: !0, get: function() {
      return m._;
    } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
      return m.str;
    } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
      return m.stringify;
    } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
      return m.nil;
    } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
      return m.Name;
    } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
      return m.CodeGen;
    } });
    var h = sP();
    Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
      return h.default;
    } });
    var v = jC();
    Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
      return v.default;
    } });
  })(R5, R5.exports)), R5.exports;
}
var o3e = RK();
const a3e = /* @__PURE__ */ Gc(o3e);
var I5 = { exports: {} }, CL = {}, OL;
function i3e() {
  return OL || (OL = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.formatNames = e.fastFormats = e.fullFormats = void 0;
    function t(I, z) {
      return { validate: I, compare: z };
    }
    e.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: t(s, l),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: t(d, f),
      "date-time": t(h, v),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri: x,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex: D,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte: k,
      // signed 32 bit integer
      int32: { type: "number", validate: O },
      // signed 64 bit integer
      int64: { type: "number", validate: N },
      // C-type float
      float: { type: "number", validate: A },
      // C-type double
      double: { type: "number", validate: A },
      // hint to the UI to hide input strings
      password: !0,
      // unchecked string payload
      binary: !0
    }, e.fastFormats = {
      ...e.fullFormats,
      date: t(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, l),
      time: t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, f),
      "date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, v),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    }, e.formatNames = Object.keys(e.fullFormats);
    function n(I) {
      return I % 4 === 0 && (I % 100 !== 0 || I % 400 === 0);
    }
    const r = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, a = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function s(I) {
      const z = r.exec(I);
      if (!z)
        return !1;
      const B = +z[1], P = +z[2], H = +z[3];
      return P >= 1 && P <= 12 && H >= 1 && H <= (P === 2 && n(B) ? 29 : a[P]);
    }
    function l(I, z) {
      if (I && z)
        return I > z ? 1 : I < z ? -1 : 0;
    }
    const c = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    function d(I, z) {
      const B = c.exec(I);
      if (!B)
        return !1;
      const P = +B[1], H = +B[2], L = +B[3], G = B[5];
      return (P <= 23 && H <= 59 && L <= 59 || P === 23 && H === 59 && L === 60) && (!z || G !== "");
    }
    function f(I, z) {
      if (!(I && z))
        return;
      const B = c.exec(I), P = c.exec(z);
      if (B && P)
        return I = B[1] + B[2] + B[3] + (B[4] || ""), z = P[1] + P[2] + P[3] + (P[4] || ""), I > z ? 1 : I < z ? -1 : 0;
    }
    const m = /t|\s/i;
    function h(I) {
      const z = I.split(m);
      return z.length === 2 && s(z[0]) && d(z[1], !0);
    }
    function v(I, z) {
      if (!(I && z))
        return;
      const [B, P] = I.split(m), [H, L] = z.split(m), G = l(B, H);
      if (G !== void 0)
        return G || f(P, L);
    }
    const g = /\/|:/, b = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function x(I) {
      return g.test(I) && b.test(I);
    }
    const w = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function k(I) {
      return w.lastIndex = 0, w.test(I);
    }
    const E = -2147483648, _ = 2 ** 31 - 1;
    function O(I) {
      return Number.isInteger(I) && I <= _ && I >= E;
    }
    function N(I) {
      return Number.isInteger(I);
    }
    function A() {
      return !0;
    }
    const R = /[^\\]\\Z/;
    function D(I) {
      if (R.test(I))
        return !1;
      try {
        return new RegExp(I), !0;
      } catch {
        return !1;
      }
    }
  })(CL)), CL;
}
var ML = {}, NL;
function s3e() {
  return NL || (NL = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.formatLimitDefinition = void 0;
    const t = RK(), n = Yt(), r = n.operators, a = {
      formatMaximum: { okStr: "<=", ok: r.LTE, fail: r.GT },
      formatMinimum: { okStr: ">=", ok: r.GTE, fail: r.LT },
      formatExclusiveMaximum: { okStr: "<", ok: r.LT, fail: r.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: r.GT, fail: r.LTE }
    }, s = {
      message: ({ keyword: c, schemaCode: d }) => n.str`should be ${a[c].okStr} ${d}`,
      params: ({ keyword: c, schemaCode: d }) => n._`{comparison: ${a[c].okStr}, limit: ${d}}`
    };
    e.formatLimitDefinition = {
      keyword: Object.keys(a),
      type: "string",
      schemaType: "string",
      $data: !0,
      error: s,
      code(c) {
        const { gen: d, data: f, schemaCode: m, keyword: h, it: v } = c, { opts: g, self: b } = v;
        if (!g.validateFormats)
          return;
        const x = new t.KeywordCxt(v, b.RULES.all.format.definition, "format");
        x.$data ? w() : k();
        function w() {
          const _ = d.scopeValue("formats", {
            ref: b.formats,
            code: g.code.formats
          }), O = d.const("fmt", n._`${_}[${x.schemaCode}]`);
          c.fail$data(n.or(n._`typeof ${O} != "object"`, n._`${O} instanceof RegExp`, n._`typeof ${O}.compare != "function"`, E(O)));
        }
        function k() {
          const _ = x.schema, O = b.formats[_];
          if (!O || O === !0)
            return;
          if (typeof O != "object" || O instanceof RegExp || typeof O.compare != "function")
            throw new Error(`"${h}": format "${_}" does not define "compare" function`);
          const N = d.scopeValue("formats", {
            key: _,
            ref: O,
            code: g.code.formats ? n._`${g.code.formats}${n.getProperty(_)}` : void 0
          });
          c.fail$data(E(N));
        }
        function E(_) {
          return n._`${_}.compare(${f}, ${m}) ${a[h].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    const l = (c) => (c.addKeyword(e.formatLimitDefinition), c);
    e.default = l;
  })(ML)), ML;
}
var AL;
function l3e() {
  return AL || (AL = 1, (function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const n = i3e(), r = s3e(), a = Yt(), s = new a.Name("fullFormats"), l = new a.Name("fastFormats"), c = (f, m = { keywords: !0 }) => {
      if (Array.isArray(m))
        return d(f, m, n.fullFormats, s), f;
      const [h, v] = m.mode === "fast" ? [n.fastFormats, l] : [n.fullFormats, s], g = m.formats || n.formatNames;
      return d(f, g, h, v), m.keywords && r.default(f), f;
    };
    c.get = (f, m = "full") => {
      const h = (m === "fast" ? n.fastFormats : n.fullFormats)[f];
      if (!h)
        throw new Error(`Unknown format "${f}"`);
      return h;
    };
    function d(f, m, h, v) {
      var g, b;
      (g = (b = f.opts.code).formats) !== null && g !== void 0 || (b.formats = a._`require("ajv-formats/dist/formats").${v}`);
      for (const x of m)
        f.addFormat(x, h[x]);
    }
    e.exports = t = c, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = c;
  })(I5, I5.exports)), I5.exports;
}
var u3e = l3e();
const RL = /* @__PURE__ */ Gc(u3e), c3e = {
  allErrors: !0,
  multipleOfPrecision: 8,
  strict: !1,
  verbose: !0,
  discriminator: !1
  // TODO enable this in V6
}, d3e = /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/, f3e = /^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;
function p3e(e, t, n = {}, r, a = a3e, s) {
  let l = new a({ ...c3e, ...n });
  return r ? RL(l, r) : r !== !1 && RL(l), l.addFormat("data-url", f3e), l.addFormat("color", d3e), l.addKeyword(Pc), l.addKeyword(Mj), Array.isArray(e) && l.addMetaSchema(e), mn(t) && Object.keys(t).forEach((c) => {
    l.addFormat(c, t[c]);
  }), s && (l = s(l)), l;
}
function m3e(e = [], t) {
  return e.map((n) => {
    var r;
    const { instancePath: a, keyword: s, params: l, schemaPath: c, parentSchema: d, ...f } = n;
    let { message: m = "" } = f, h = a.replace(/\//g, "."), v = `${h} ${m}`.trim(), g = "";
    const b = [
      ...((r = l.deps) === null || r === void 0 ? void 0 : r.split(", ")) || [],
      l.missingProperty,
      l.property
    ].filter((x) => x);
    if (b.length > 0)
      b.forEach((x) => {
        const w = h ? `${h}.${x}` : x;
        let k = vt(Re(t, `${w.replace(/^\./, "")}`)).title;
        if (k === void 0) {
          const E = c.replace(/\/properties\//g, "/").split("/").slice(1, -1).concat([x]);
          k = vt(Re(t, E)).title;
        }
        if (k)
          m = m.replace(`'${x}'`, `'${k}'`), g = k;
        else {
          const E = Re(d, [gn, x, "title"]);
          E && (m = m.replace(`'${x}'`, `'${E}'`), g = E);
        }
      }), v = m;
    else {
      const x = vt(Re(t, `${h.replace(/^\./, "")}`)).title;
      if (x)
        v = `'${x}' ${m}`.trim(), g = x;
      else {
        const w = d?.title;
        w && (v = `'${w}' ${m}`.trim(), g = w);
      }
    }
    return "missingProperty" in l && (h = h ? `${h}.${l.missingProperty}` : l.missingProperty), {
      name: s,
      property: h,
      message: m,
      params: l,
      // specific to ajv
      stack: v,
      schemaPath: c,
      title: g
    };
  }).reduce((n, r) => {
    const { message: a, schemaPath: s } = r, l = s?.indexOf(`/${dn}/`), c = s?.indexOf(`/${Kt}/`);
    let d;
    return l && l >= 0 ? d = s?.substring(0, l) : c && c >= 0 && (d = s?.substring(0, c)), d && n.find((f) => {
      var m;
      return f.message === a && ((m = f.schemaPath) === null || m === void 0 ? void 0 : m.startsWith(d));
    }) || n.push(r), n;
  }, []);
}
function h3e(e, t, n, r, a, s, l) {
  const { validationError: c } = t;
  let d = m3e(t.errors, l);
  c && (d = [...d, { stack: c.message }]), typeof s == "function" && (d = s(d, l));
  let f = F5e(d);
  if (c && (f = {
    ...f,
    $schema: {
      __errors: [c.message]
    }
  }), typeof a != "function")
    return { errors: d, errorSchema: f };
  const m = cK(e, r, n, r, !0), h = a(m, z3(m), l), v = _K(h);
  return K_({ errors: d, errorSchema: f }, v);
}
class g3e {
  /** Constructs an `AJV8Validator` instance using the `options`
   *
   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance
   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s
   */
  constructor(t, n) {
    const { additionalMetaSchemas: r, customFormats: a, ajvOptionsOverrides: s, ajvFormatOptions: l, AjvClass: c, extenderFn: d } = t;
    this.ajv = p3e(r, a, s, l, c, d), this.localizer = n;
  }
  /** Resets the internal AJV validator to clear schemas from it. Can be helpful for resetting the validator for tests.
   */
  reset() {
    this.ajv.removeSchema();
  }
  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use
   * by the playground. Returns the `errors` from the validation
   *
   * @param schema - The schema against which to validate the form data   * @param schema
   * @param formData - The form data to validate
   */
  rawValidation(t, n) {
    var r, a;
    let s, l;
    try {
      t[Ln] && (l = this.ajv.getSchema(t[Ln])), l === void 0 && (l = this.ajv.compile(t)), l(n);
    } catch (d) {
      s = d;
    }
    let c;
    return l && (typeof this.localizer == "function" && (((r = l.errors) !== null && r !== void 0 ? r : []).forEach((d) => {
      var f;
      ["missingProperty", "property"].forEach((m) => {
        var h;
        !((h = d.params) === null || h === void 0) && h[m] && (d.params[m] = `'${d.params[m]}'`);
      }), !((f = d.params) === null || f === void 0) && f.deps && (d.params.deps = d.params.deps.split(", ").map((m) => `'${m}'`).join(", "));
    }), this.localizer(l.errors), ((a = l.errors) !== null && a !== void 0 ? a : []).forEach((d) => {
      var f;
      ["missingProperty", "property"].forEach((m) => {
        var h;
        !((h = d.params) === null || h === void 0) && h[m] && (d.params[m] = d.params[m].slice(1, -1));
      }), !((f = d.params) === null || f === void 0) && f.deps && (d.params.deps = d.params.deps.split(", ").map((m) => m.slice(1, -1)).join(", "));
    })), c = l.errors || void 0, l.errors = null), {
      errors: c,
      validationError: s
    };
  }
  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives
   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also
   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and
   * transform them in what ever way it chooses.
   *
   * @param formData - The form data to validate
   * @param schema - The schema against which to validate the form data
   * @param [customValidate] - An optional function that is used to perform custom validation
   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation
   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`
   */
  validateFormData(t, n, r, a, s) {
    const l = this.rawValidation(n, t);
    return h3e(this, l, t, n, r, a, s);
  }
  /**
   * This function checks if a schema needs to be added and if the root schemas don't match it removes the old root schema from the ajv instance and adds the new one.
   * @param rootSchema - The root schema used to provide $ref resolutions
   */
  handleSchemaUpdate(t) {
    var n, r;
    const a = (n = t[Ln]) !== null && n !== void 0 ? n : nG;
    this.ajv.getSchema(a) === void 0 ? this.ajv.addSchema(t, a) : er(t, (r = this.ajv.getSchema(a)) === null || r === void 0 ? void 0 : r.schema) || (this.ajv.removeSchema(a), this.ajv.addSchema(t, a));
  }
  /** Validates data against a schema, returning true if the data is valid, or
   * false otherwise. If the schema is invalid, then this function will return
   * false.
   *
   * @param schema - The schema against which to validate the form data
   * @param formData - The form data to validate
   * @param rootSchema - The root schema used to provide $ref resolutions
   */
  isValid(t, n, r) {
    var a;
    try {
      this.handleSchemaUpdate(r);
      const s = iP(t), l = (a = s[Ln]) !== null && a !== void 0 ? a : I5e(s);
      let c;
      return c = this.ajv.getSchema(l), c === void 0 && (c = this.ajv.addSchema(s, l).getSchema(l) || this.ajv.compile(s)), c(n);
    } catch (s) {
      return console.warn("Error encountered compiling schema:", s), !1;
    }
  }
}
function v3e(e = {}, t) {
  return new g3e(e, t);
}
const y3e = v3e();
function b3e(e, t) {
  return vK(e, t, function(n, r) {
    return MG(e, r);
  });
}
var jK = KG(function(e, t) {
  return e == null ? {} : b3e(e, t);
});
function w3e(e, t) {
  return e == null ? !0 : GG(e, t);
}
function K3() {
  return xK("rjsf-array-item-");
}
function jL(e) {
  return Array.isArray(e) ? e.map((t) => ({
    key: K3(),
    item: t
  })) : [];
}
function PK(e) {
  return Array.isArray(e) ? e.map((t) => t.item) : [];
}
function x3e(e) {
  return Array.isArray(e.type) ? !e.type.includes("null") : e.type !== "null";
}
function DK(e, t, n, r) {
  let { addable: a } = vt(r, e.globalUiOptions);
  return a !== !1 && (t.maxItems !== void 0 ? a = n.length < t.maxItems : a = !0), a;
}
function IK(e, t, n, r) {
  if (typeof e.items == "function")
    try {
      return e.items(t, n, r);
    } catch (a) {
      console.error(`Error executing dynamic uiSchema.items function for item at index ${n}:`, a);
      return;
    }
  else
    return e.items;
}
function S3e(e, t) {
  const { schemaUtils: n, globalFormOptions: r } = e;
  let a = t.items;
  return r.useFallbackUiForUnsupportedType && !a ? a = {} : Xj(t) && Y_e(t) && (a = t.additionalItems), n.getDefaultFormState(a);
}
function k3e(e) {
  const { schema: t, fieldPathId: n, uiSchema: r, formData: a = [], disabled: s = !1, readonly: l = !1, autofocus: c = !1, required: d = !1, placeholder: f, onBlur: m, onFocus: h, registry: v, rawErrors: g, name: b, onSelectChange: x } = e, { widgets: w, schemaUtils: k, globalFormOptions: E, globalUiOptions: _ } = v, O = k.retrieveSchema(t.items, a), N = Ng(O, r), { widget: A = "select", title: R, ...D } = vt(r, _), I = ql(t, A, w), z = R ?? t.title ?? b, B = k.getDisplayLabel(t, r, _), P = sh(Yi("", E, n, !0));
  return C.jsx(I, { id: P[Ln], name: b, multiple: !0, onChange: x, onBlur: m, onFocus: h, options: { ...D, enumOptions: N }, schema: t, uiSchema: r, registry: v, value: a, disabled: s, readonly: l, required: d, label: z, hideLabel: !B, placeholder: f, autofocus: c, rawErrors: g, htmlName: P.name });
}
function _3e(e) {
  const { schema: t, fieldPathId: n, uiSchema: r, disabled: a = !1, readonly: s = !1, autofocus: l = !1, required: c = !1, hideError: d, placeholder: f, onBlur: m, onFocus: h, formData: v = [], registry: g, rawErrors: b, name: x, onSelectChange: w } = e, { widgets: k, schemaUtils: E, globalFormOptions: _, globalUiOptions: O } = g, { widget: N, title: A, ...R } = vt(r, O), D = ql(t, N, k), I = A ?? t.title ?? x, z = E.getDisplayLabel(t, r, O), B = sh(Yi("", _, n, !0));
  return C.jsx(D, { id: B[Ln], name: x, multiple: !0, onChange: w, onBlur: m, onFocus: h, options: R, schema: t, uiSchema: r, registry: g, value: v, disabled: a, readonly: s, hideError: d, required: c, label: I, hideLabel: !z, placeholder: f, autofocus: l, rawErrors: b, htmlName: B.name });
}
function E3e(e) {
  const { schema: t, uiSchema: n, fieldPathId: r, name: a, disabled: s = !1, readonly: l = !1, autofocus: c = !1, required: d = !1, onBlur: f, onFocus: m, registry: h, formData: v = [], rawErrors: g, onSelectChange: b } = e, { widgets: x, schemaUtils: w, globalFormOptions: k, globalUiOptions: E } = h, { widget: _ = "files", title: O, ...N } = vt(n, E), A = ql(t, _, x), R = O ?? t.title ?? a, D = w.getDisplayLabel(t, n, E), I = sh(Yi("", k, r, !0));
  return C.jsx(A, { options: N, id: I[Ln], name: a, multiple: !0, onChange: b, onBlur: f, onFocus: m, schema: t, uiSchema: n, value: v, disabled: s, readonly: l, required: d, registry: h, autofocus: c, rawErrors: g, label: R, hideLabel: !D, htmlName: I.name });
}
function $K(e) {
  const { itemKey: t, index: n, name: r, disabled: a, hideError: s, readonly: l, registry: c, uiOptions: d, parentUiSchema: f, canAdd: m, canRemove: h = !0, canMoveUp: v, canMoveDown: g, itemSchema: b, itemData: x, itemUiSchema: w, itemFieldPathId: k, itemErrorSchema: E, autofocus: _, onBlur: O, onFocus: N, onChange: A, rawErrors: R, totalItems: D, title: I, handleAddItem: z, handleCopyItem: B, handleRemoveItem: P, handleReorderItems: H } = e, { schemaUtils: L, fields: { ArraySchemaField: G, SchemaField: $ }, globalUiOptions: K } = c, q = sh(k), Z = G || $, V = xt("ArrayFieldItemTemplate", c, d), F = L.getDisplayLabel(b, w, K), { description: Y } = vt(w), U = !!Y || !!b.description, { orderable: W = !0, removable: J = !0, copyable: oe = !1 } = d, fe = {
    moveUp: W && v,
    moveDown: W && g,
    copy: oe && m,
    remove: J && h,
    toolbar: !1
  };
  fe.toolbar = Object.keys(fe).some((ve) => fe[ve]);
  const ie = M.useCallback((ve) => {
    z(ve, n + 1);
  }, [z, n]), ce = M.useCallback((ve) => {
    B(ve, n);
  }, [B, n]), ge = M.useCallback((ve) => {
    P(ve, n);
  }, [P, n]), re = M.useCallback((ve) => {
    H(ve, n, n - 1);
  }, [H, n]), le = M.useCallback((ve) => {
    H(ve, n, n + 1);
  }, [H, n]), me = {
    children: C.jsx(Z, { name: r, title: I, index: n, schema: b, uiSchema: w, formData: x, errorSchema: E, fieldPathId: q, required: x3e(b), onChange: A, onBlur: O, onFocus: N, registry: c, disabled: a, readonly: l, hideError: s, autofocus: _, rawErrors: R }),
    buttonsProps: {
      fieldPathId: q,
      disabled: a,
      readonly: l,
      canAdd: m,
      hasCopy: fe.copy,
      hasMoveUp: fe.moveUp,
      hasMoveDown: fe.moveDown,
      hasRemove: fe.remove,
      index: n,
      totalItems: D,
      onAddItem: ie,
      onCopyItem: ce,
      onRemoveItem: ge,
      onMoveUpItem: re,
      onMoveDownItem: le,
      registry: c,
      schema: b,
      uiSchema: w
    },
    itemKey: t,
    className: "rjsf-array-item",
    disabled: a,
    hasToolbar: fe.toolbar,
    index: n,
    totalItems: D,
    readonly: l,
    registry: c,
    schema: b,
    uiSchema: w,
    parentUiSchema: f,
    displayLabel: F,
    hasDescription: U
  };
  return C.jsx(V, { ...me });
}
function C3e(e) {
  const { schema: t, uiSchema: n = {}, errorSchema: r, fieldPathId: a, formData: s, name: l, title: c, disabled: d = !1, readonly: f = !1, autofocus: m = !1, required: h = !1, hideError: v = !1, registry: g, onBlur: b, onFocus: x, rawErrors: w, onChange: k, keyedFormData: E, handleAddItem: _, handleCopyItem: O, handleRemoveItem: N, handleReorderItems: A } = e, R = t.title || c || l, { schemaUtils: D, fields: I, formContext: z, globalFormOptions: B, globalUiOptions: P } = g, { OptionalDataControlsField: H } = I, L = vt(n, P), G = mn(t.items) ? t.items : {}, $ = D.retrieveSchema(G), K = PK(E), q = Ek(g, t, h, n), Z = Kg(s), V = DK(g, t, K, n) && (!q || Z), F = Z ? E : [], Y = q ? " rjsf-optional-array-field" : "", U = e.childFieldPathId ?? a, W = q ? C.jsx(H, { ...e, fieldPathId: U }) : void 0, J = {
    canAdd: V,
    items: F.map((fe, ie) => {
      const { key: ce, item: ge } = fe, re = ge, le = D.retrieveSchema(G, re), me = r ? r[ie] : void 0, ve = Yi(ie, B, U), xe = IK(n, ge, ie, z), _e = {
        itemKey: ce,
        index: ie,
        name: l && `${l}-${ie}`,
        registry: g,
        uiOptions: L,
        hideError: v,
        readonly: f,
        disabled: d,
        required: h,
        title: R ? `${R}-${ie + 1}` : void 0,
        canAdd: V,
        canMoveUp: ie > 0,
        canMoveDown: ie < K.length - 1,
        itemSchema: le,
        itemFieldPathId: ve,
        itemErrorSchema: me,
        itemData: re,
        itemUiSchema: xe,
        autofocus: m && ie === 0,
        onBlur: b,
        onFocus: x,
        rawErrors: w,
        totalItems: E.length,
        handleAddItem: _,
        handleCopyItem: O,
        handleRemoveItem: N,
        handleReorderItems: A,
        onChange: k
      };
      return C.jsx($K, { ..._e }, ce);
    }),
    className: `rjsf-field rjsf-field-array rjsf-field-array-of-${$.type}${Y}`,
    disabled: d,
    fieldPathId: a,
    uiSchema: n,
    onAddClick: _,
    readonly: f,
    required: h,
    schema: t,
    title: R,
    formData: K,
    rawErrors: w,
    registry: g,
    optionalDataControl: W
  }, oe = xt("ArrayFieldTemplate", g, L);
  return C.jsx(oe, { ...J });
}
function O3e(e) {
  const { schema: t, uiSchema: n = {}, formData: r, errorSchema: a, fieldPathId: s, name: l, title: c, disabled: d = !1, readonly: f = !1, autofocus: m = !1, required: h = !1, hideError: v = !1, registry: g, onBlur: b, onFocus: x, rawErrors: w, keyedFormData: k, onChange: E, handleAddItem: _, handleCopyItem: O, handleRemoveItem: N, handleReorderItems: A } = e;
  let { formData: R = [] } = e;
  const D = t.title || c || l, { schemaUtils: I, fields: z, formContext: B, globalFormOptions: P, globalUiOptions: H } = g, L = vt(n, H), { OptionalDataControlsField: G } = z, $ = Ek(g, t, h, n), K = Kg(r), q = (mn(t.items) ? t.items : []).map((fe, ie) => I.retrieveSchema(fe, R[ie])), Z = mn(t.additionalItems) ? I.retrieveSchema(t.additionalItems, r) : null, V = e.childFieldPathId ?? s;
  R.length < q.length && (R = R.concat(new Array(q.length - R.length)));
  const F = K ? k : [], Y = $ ? " rjsf-optional-array-field" : "", U = $ ? C.jsx(G, { ...e, fieldPathId: V }) : void 0, W = DK(g, t, R, n) && !!Z && (!$ || K), J = {
    canAdd: W,
    className: `rjsf-field rjsf-field-array rjsf-field-array-fixed-items${Y}`,
    disabled: d,
    fieldPathId: s,
    formData: r,
    items: F.map((fe, ie) => {
      const { key: ce, item: ge } = fe, re = ge, le = ie >= q.length, me = (le && mn(t.additionalItems) ? I.retrieveSchema(t.additionalItems, re) : q[ie]) || {}, ve = Yi(ie, P, V);
      let xe;
      le ? xe = n.additionalItems : Array.isArray(n.items) ? xe = n.items[ie] : xe = IK(n, ge, ie, B);
      const _e = a ? a[ie] : void 0, Ge = {
        index: ie,
        itemKey: ce,
        name: l && `${l}-${ie}`,
        registry: g,
        uiOptions: L,
        hideError: v,
        readonly: f,
        disabled: d,
        required: h,
        title: D ? `${D}-${ie + 1}` : void 0,
        canAdd: W,
        canRemove: le,
        canMoveUp: ie >= q.length + 1,
        canMoveDown: le && ie < R.length - 1,
        itemSchema: me,
        itemData: re,
        itemUiSchema: xe,
        itemFieldPathId: ve,
        itemErrorSchema: _e,
        autofocus: m && ie === 0,
        onBlur: b,
        onFocus: x,
        rawErrors: w,
        totalItems: k.length,
        onChange: E,
        handleAddItem: _,
        handleCopyItem: O,
        handleRemoveItem: N,
        handleReorderItems: A
      };
      return C.jsx($K, { ...Ge }, ce);
    }),
    onAddClick: _,
    readonly: f,
    required: h,
    registry: g,
    schema: t,
    uiSchema: n,
    title: D,
    errorSchema: a,
    rawErrors: w,
    optionalDataControl: U
  }, oe = xt("ArrayFieldTemplate", g, L);
  return C.jsx(oe, { ...J });
}
function M3e(e = []) {
  const t = M.useMemo(() => Rl(e), [e]), [n, r] = M.useState(() => ({
    formDataHash: t,
    keyedFormData: jL(e)
  }));
  let { keyedFormData: a, formDataHash: s } = n;
  if (t !== s) {
    const c = Array.isArray(e) ? e : [], d = a || [];
    a = c.length === d.length ? d.map((f, m) => ({
      key: f.key,
      item: c[m]
    })) : jL(c), s = t, r({ formDataHash: s, keyedFormData: a });
  }
  const l = M.useCallback((c) => {
    const d = PK(c), f = Rl(d);
    return r({ formDataHash: f, keyedFormData: c }), d;
  }, []);
  return { keyedFormData: a, updateKeyedFormData: l };
}
function N3e(e) {
  const { schema: t, uiSchema: n, errorSchema: r, fieldPathId: a, registry: s, formData: l, onChange: c } = e, { globalFormOptions: d, schemaUtils: f, translateString: m } = s, { keyedFormData: h, updateKeyedFormData: v } = M3e(l), g = e.childFieldPathId ?? a, b = M.useCallback((A, R) => {
    A && A.preventDefault();
    let D;
    if (r) {
      D = {};
      for (const B in r) {
        const P = parseInt(B);
        R === void 0 || P < R ? zn(D, [P], r[B]) : P >= R && zn(D, [P + 1], r[B]);
      }
    }
    const I = {
      key: K3(),
      item: S3e(s, t)
    }, z = [...h];
    R !== void 0 ? z.splice(R, 0, I) : z.push(I), c(v(z), g.path, D);
  }, [h, s, t, c, v, r, g]), x = M.useCallback((A, R) => {
    A && A.preventDefault();
    let D;
    if (r) {
      D = {};
      for (const B in r) {
        const P = parseInt(B);
        P <= R ? zn(D, [P], r[B]) : P > R && zn(D, [P + 1], r[B]);
      }
    }
    const I = {
      key: K3(),
      item: eP(h[R].item)
    }, z = [...h];
    R !== void 0 ? z.splice(R + 1, 0, I) : z.push(I), c(v(z), g.path, D);
  }, [h, c, v, r, g]), w = M.useCallback((A, R) => {
    A && A.preventDefault();
    let D;
    if (r) {
      D = {};
      for (const z in r) {
        const B = parseInt(z);
        B < R ? zn(D, [B], r[z]) : B > R && zn(D, [B - 1], r[z]);
      }
    }
    const I = h.filter((z, B) => B !== R);
    c(v(I), g.path, D);
  }, [h, c, v, r, g]), k = M.useCallback((A, R, D) => {
    A && (A.preventDefault(), A.currentTarget.blur());
    let I;
    if (r) {
      I = {};
      for (const P in r) {
        const H = parseInt(P);
        H == R ? zn(I, [D], r[R]) : H == D ? zn(I, [R], r[D]) : zn(I, [P], r[H]);
      }
    }
    function z() {
      const P = h.slice();
      return P.splice(R, 1), P.splice(D, 0, h[R]), P;
    }
    const B = z();
    c(v(B), g.path, I);
  }, [h, c, v, r, g]), E = M.useCallback((A, R, D, I) => {
    c(
      // We need to treat undefined items as nulls to have validation.
      // See https://github.com/tdegrunt/jsonschema/issues/206
      A === void 0 ? null : A,
      R,
      D,
      I
    );
  }, [c]), _ = M.useCallback((A) => {
    c(A, g.path, void 0, g?.[Ln]);
  }, [c, g]), O = {
    ...e,
    formData: l,
    fieldPathId: g,
    onSelectChange: _
  }, N = {
    ...e,
    handleAddItem: b,
    handleCopyItem: x,
    handleRemoveItem: w,
    handleReorderItems: k,
    keyedFormData: h,
    onChange: E
  };
  if (!(Cg in t)) {
    if (!d.useFallbackUiForUnsupportedType) {
      const R = vt(n), D = xt("UnsupportedFieldTemplate", s, R);
      return C.jsx(D, { schema: t, fieldPathId: a, reason: m(Jt.MissingItems), registry: s });
    }
    const A = { ...t, [Cg]: { type: void 0 } };
    O.schema = A, N.schema = A;
  }
  return f.isMultiSelect(O.schema) ? C.jsx(k3e, { ...O }) : dK(n) ? C.jsx(_3e, { ...O }) : Xj(O.schema) ? C.jsx(O3e, { ...N }) : f.isFilesArray(O.schema, n) ? C.jsx(E3e, { ...O }) : C.jsx(C3e, { ...N });
}
function A3e(e) {
  const { schema: t, name: n, uiSchema: r, fieldPathId: a, formData: s, registry: l, required: c, disabled: d, readonly: f, hideError: m, autofocus: h, title: v, onChange: g, onFocus: b, onBlur: x, rawErrors: w } = e, { title: k } = t, { widgets: E, translateString: _, globalUiOptions: O } = l, {
    widget: N = "checkbox",
    title: A,
    // Unlike the other fields, don't use `getDisplayLabel()` since it always returns false for the boolean type
    label: R = !0,
    enumNames: D,
    ...I
  } = vt(r, O), z = ql(t, N, E), B = _(Jt.YesLabel), P = _(Jt.NoLabel);
  let H;
  const L = A ?? k ?? v ?? n;
  if (Array.isArray(t.oneOf))
    H = Ng({
      oneOf: t.oneOf.map(($) => {
        if (mn($))
          return {
            ...$,
            title: $.title || ($.const === !0 ? B : P)
          };
      }).filter(($) => $)
      // cast away the error that typescript can't grok is fixed
    }, r);
  else {
    const $ = t.enum ?? [!0, !1];
    !D && $.length === 2 && $.every((K) => typeof K == "boolean") ? H = [
      {
        value: $[0],
        label: $[0] ? B : P
      },
      {
        value: $[1],
        label: $[1] ? B : P
      }
    ] : H = Ng({ enum: $ }, r);
  }
  const G = M.useCallback(($, K, q) => g($, a.path, K, q), [g, a]);
  return C.jsx(z, { options: { ...I, enumOptions: H }, schema: t, uiSchema: r, id: a.$id, name: n, onChange: G, onFocus: b, onBlur: x, label: L, hideLabel: !R, value: s, required: c, disabled: d, readonly: f, hideError: m, registry: l, autofocus: h, rawErrors: w, htmlName: a.name });
}
function R3e(e) {
  return {
    type: "string",
    enum: ["string", "number", "boolean", "object", "array"],
    default: "string",
    title: e
  };
}
function j3e(e) {
  const t = typeof e;
  return t === "string" || t === "number" || t === "boolean" ? t : t === "object" ? Array.isArray(e) ? "array" : "object" : "string";
}
function P3e(e, t) {
  switch (t) {
    case "string":
      return String(e);
    case "number": {
      const n = Number(e);
      return isNaN(n) ? 0 : n;
    }
    case "boolean":
      return !!e;
    default:
      return e;
  }
}
function D3e(e) {
  const { id: t, formData: n, displayLabel: r = !0, schema: a, name: s, uiSchema: l, required: c, disabled: d = !1, readonly: f = !1, onBlur: m, onFocus: h, registry: v, fieldPathId: g, onChange: b, errorSchema: x } = e, { translateString: w, fields: k, globalFormOptions: E } = v, [_, O] = M.useState(j3e(n)), N = vt(l), A = sh(Yi("__internal_type_selector", E, g)), R = w(Jt.Type), D = M.useMemo(() => R3e(R), [R]), I = (P) => {
    P != null && (O(P), b(P3e(n, P), g.path, x, t));
  };
  if (!E.useFallbackUiForUnsupportedType) {
    const { reason: P = w(Jt.UnknownFieldType, [String(a.type)]) } = e, H = xt("UnsupportedFieldTemplate", v, N);
    return C.jsx(H, { schema: a, fieldPathId: g, reason: P, registry: v });
  }
  const z = xt("FallbackFieldTemplate", v, N), { SchemaField: B } = k;
  return C.jsx(z, { schema: a, registry: v, typeSelector: C.jsx(B, { fieldPathId: A, name: `${s}__fallback_type`, schema: D, formData: _, onChange: I, onBlur: m, onFocus: h, registry: v, hideLabel: !r, disabled: d, readonly: f, required: c }, n ? Rl(n) : "__empty__"), schemaField: C.jsx(B, { ...e, schema: {
    type: _,
    title: w(Jt.Value),
    ..._ === "object" && { additionalProperties: !0 }
  } }) });
}
function I3e(e, t) {
  return Wg(t, function(n) {
    return e[n];
  });
}
function $3e(e) {
  return e == null ? [] : I3e(e, qs(e));
}
var z3e = Math.max;
function T3e(e, t, n, r) {
  e = nh(e) ? e : $3e(e), n = n ? xG(n) : 0;
  var a = e.length;
  return n < 0 && (n = z3e(a + n, 0)), $d(e) ? n <= a && e.indexOf(t, n) > -1 : !!a && $G(e, t, n) > -1;
}
var L3e = Math.min;
function F3e(e, t, n) {
  for (var r = Wj, a = e[0].length, s = e.length, l = s, c = Array(s), d = 1 / 0, f = []; l--; ) {
    var m = e[l];
    d = L3e(m.length, d), c[l] = a >= 120 && m.length >= 120 ? new Hm(l && m) : void 0;
  }
  m = e[0];
  var h = -1, v = c[0];
  e:
    for (; ++h < a && f.length < d; ) {
      var g = m[h], b = g;
      if (g = g !== 0 ? g : 0, !(v ? SS(v, b) : r(f, b))) {
        for (l = s; --l; ) {
          var x = c[l];
          if (!(x ? SS(x, b) : r(e[l], b)))
            continue e;
        }
        v && v.push(b), f.push(g);
      }
    }
  return f;
}
function B3e(e) {
  return _S(e) ? e : [];
}
var PL = _C(function(e) {
  var t = Wg(e, B3e);
  return t.length && t[0] === e[0] ? F3e(t) : [];
});
function zK(e) {
  return e === void 0;
}
var Pl;
(function(e) {
  e.ROW = "ui:row", e.COLUMN = "ui:col", e.COLUMNS = "ui:columns", e.CONDITION = "ui:condition";
})(Pl || (Pl = {}));
var Fx;
(function(e) {
  e.ALL = "all", e.SOME = "some", e.NONE = "none";
})(Fx || (Fx = {}));
const U3e = /^\$lookup=(.+)/, $5 = "layoutGrid";
function DL(e, t) {
  return e ?? t;
}
function V3e(e) {
  return /^\d+?$/.test(e);
}
const Sd = tP();
function H3e(e, t, n, r, a) {
  const s = Re(n, [$3], {}), l = Re(n, e), c = { ...Re(l, [wd], {}), ...t, ...s }, d = { ...l };
  $r(c) || zn(d, [wd], c), $r(s) || zn(d, [$3], s);
  let { readonly: f } = vt(d);
  return (a === !0 || zK(f) && r === !0) && (f = !0, rn(c, f5) ? zn(d, [wd, f5], !0) : zn(d, `ui:${f5}`, !0)), { fieldUiSchema: d, uiReadonly: f };
}
function W3e(e, t, n = "$0m3tH1nG Un3xP3cT3d") {
  const r = H3([t]).sort(), a = H3([n]).sort();
  switch (e) {
    case Fx.ALL:
      return kS(r, a);
    case Fx.SOME:
      return PL(r, a).length > 0;
    case Fx.NONE:
      return PL(r, a).length === 0;
    default:
      return !1;
  }
}
function PC(e, t, n) {
  let r = {}, a = e[t];
  if (Id(a)) {
    const { children: s, className: l, ...c } = a;
    if (a = s, l) {
      const d = l.split(" ").map((f) => oP(n, f, f)).join(" ");
      r = { ...c, className: d };
    } else
      r = c;
  }
  if (!Array.isArray(a))
    throw new TypeError(`Expected array for "${t}" in ${JSON.stringify(e)}`);
  return { children: a, gridProps: r };
}
function IL(e, t, n) {
  let r;
  if (V3e(n) && e && e?.type === "array" && rn(e, Cg)) {
    const a = Number(n), s = e[Cg];
    Array.isArray(s) ? a > s.length ? r = qG(s) : r = s[a] : r = s, t = {
      [Ln]: t[Ln],
      path: [...t.path.slice(0, t.path.length - 1), a]
    };
  }
  return { rawSchema: r, fieldPathId: t };
}
function q3e(e, t, n, r, a) {
  const { schemaUtils: s, globalFormOptions: l } = e;
  let c = n, d = a;
  const f = t.split("."), m = f.pop();
  let h = s.retrieveSchema(c, r), v = r, g = h.readOnly;
  f.forEach((w) => {
    if (d = Yi(w, l, d), rn(h, gn))
      c = Re(h, [gn, w], {});
    else if (h && (rn(h, Kt) || rn(h, dn))) {
      const k = rn(h, Kt) ? Kt : dn, E = s.findSelectedOptionInXxxOf(h, w, k, v);
      c = Re(E, [gn, w], {});
    } else {
      const k = IL(h, d, w);
      c = k.rawSchema ?? {}, d = k.fieldPathId;
    }
    v = Re(v, w, {}), h = s.retrieveSchema(c, v), g = DL(h.readOnly, g);
  });
  let b, x = !1;
  if ($r(h) && (h = void 0), h && m) {
    if (h && (rn(h, Kt) || rn(h, dn))) {
      const k = rn(h, Kt) ? Kt : dn;
      h = s.findSelectedOptionInXxxOf(h, m, k, v);
    }
    d = Yi(m, l, d), x = h !== void 0 && Array.isArray(h.required) && T3e(h.required, m);
    const w = IL(h, d, m);
    if (w.rawSchema ? (h = w.rawSchema, d = w.fieldPathId) : (h = Re(h, [gn, m]), h = h && s.retrieveSchema(h)), g = DL(h?.readOnly, g), h && (rn(h, Kt) || rn(h, dn))) {
      const k = rn(h, Kt) ? Kt : dn, E = Wl(h);
      b = { options: h[k], hasDiscriminator: !!E };
    }
  }
  return { schema: h, isRequired: x, isReadonly: g, optionsInfo: b, fieldPathId: d };
}
function G3e(e, t) {
  let n = e;
  return $d(n) && (n = oP(t, n)), bk(n) ? n : null;
}
function K3e(e, t) {
  let n, r = null, a = {}, s;
  if ($d(t) || zK(t))
    n = t ?? "";
  else {
    const { name: l = "", render: c, ...d } = t;
    n = l, a = d, $r(a) || J5e(a, (f, m) => {
      if ($d(f)) {
        const h = U3e.exec(f);
        if (Array.isArray(h) && h.length > 1) {
          const v = h[1];
          a[m] = oP(e, v, v);
        }
      }
    }), r = G3e(c, e), !l && r && (s = C.jsx(r, { ...d, "data-testid": Sd.uiComponent }));
  }
  return { name: n, UIComponent: r, uiProps: a, rendered: s };
}
function DC(e) {
  const { childrenLayoutGridSchemaId: t, ...n } = e, { registry: r, schema: a, formData: s } = n, { schemaUtils: l } = r, c = l.retrieveSchema(a, s);
  return t.map((d) => M.createElement(cP, { ...n, key: `layoutGrid-${Rl(d)}`, schema: c, layoutGridSchema: d }));
}
function Y3e(e) {
  const { layoutGridSchema: t, ...n } = e, { formData: r, registry: a } = n, { children: s, gridProps: l } = PC(t, Pl.CONDITION, a), { operator: c, field: d = "", value: f } = l, m = Re(r, d, null);
  return W3e(c, m, f) ? C.jsx(DC, { ...n, childrenLayoutGridSchemaId: s }) : null;
}
function X3e(e) {
  const { layoutGridSchema: t, ...n } = e, { registry: r, uiSchema: a } = n, { children: s, gridProps: l } = PC(t, Pl.COLUMN, r), c = vt(a), d = xt("GridTemplate", r, c);
  return C.jsx(d, { column: !0, "data-testid": Sd.col, ...l, children: C.jsx(DC, { ...n, childrenLayoutGridSchemaId: s }) });
}
function J3e(e) {
  const { layoutGridSchema: t, ...n } = e, { registry: r, uiSchema: a } = n, { children: s, gridProps: l } = PC(t, Pl.COLUMNS, r), c = vt(a), d = xt("GridTemplate", r, c);
  return s.map((f) => C.jsx(d, { column: !0, "data-testid": Sd.col, ...l, children: C.jsx(DC, { ...n, childrenLayoutGridSchemaId: [f] }) }, `column-${Rl(f)}`));
}
function Q3e(e) {
  const { layoutGridSchema: t, ...n } = e, { registry: r, uiSchema: a } = n, { children: s, gridProps: l } = PC(t, Pl.ROW, r), c = vt(a), d = xt("GridTemplate", r, c);
  return C.jsx(d, { ...l, "data-testid": Sd.row, children: C.jsx(DC, { ...n, childrenLayoutGridSchemaId: s }) });
}
function Z3e(e) {
  const {
    gridSchema: t,
    schema: n,
    uiSchema: r,
    errorSchema: a,
    fieldPathId: s,
    onBlur: l,
    onFocus: c,
    formData: d,
    readonly: f,
    registry: m,
    layoutGridSchema: h,
    // Used to pull this out of otherProps since we don't want to pass it through
    ...v
  } = e, { onChange: g } = v, { fields: b } = m, { SchemaField: x, LayoutMultiSchemaField: w } = b, k = K3e(m, t), { name: E, UIComponent: _, uiProps: O } = k, { schema: N, isRequired: A, isReadonly: R, optionsInfo: D, fieldPathId: I } = q3e(m, E, n, d, s), z = sh(I);
  if (k.rendered)
    return k.rendered;
  if (N) {
    const B = D?.hasDiscriminator ? w : x, { fieldUiSchema: P, uiReadonly: H } = H3e(E, O, r, R, f);
    return C.jsx(B, { "data-testid": D?.hasDiscriminator ? Sd.layoutMultiSchemaField : Sd.field, ...v, name: E, required: A, readonly: H, schema: N, uiSchema: P, errorSchema: Re(a, E), fieldPathId: z, formData: Re(d, E), onChange: g, onBlur: l, onFocus: c, options: D?.options, registry: m });
  }
  return _ ? C.jsx(_, { "data-testid": Sd.uiComponent, ...v, name: E, required: A, formData: d, readOnly: !!R || f, errorSchema: a, uiSchema: r, schema: n, fieldPathId: s, onBlur: l, onFocus: c, registry: m, ...O }) : null;
}
function cP(e) {
  const { uiSchema: t } = e;
  let { layoutGridSchema: n } = e;
  const r = vt(t);
  if (!n && $5 in r && mn(r[$5]) && (n = r[$5]), mn(n)) {
    if (Pl.ROW in n)
      return C.jsx(Q3e, { ...e, layoutGridSchema: n });
    if (Pl.COLUMN in n)
      return C.jsx(X3e, { ...e, layoutGridSchema: n });
    if (Pl.COLUMNS in n)
      return C.jsx(J3e, { ...e, layoutGridSchema: n });
    if (Pl.CONDITION in n)
      return C.jsx(Y3e, { ...e, layoutGridSchema: n });
  }
  return C.jsx(Z3e, { ...e, gridSchema: n });
}
cP.TEST_IDS = Sd;
function eRe(e) {
  const { fieldPathId: t, title: n, schema: r, uiSchema: a, required: s, registry: l, name: c } = e, d = vt(a, l.globalUiOptions), { title: f } = d, { title: m } = r, h = f || n || m || c;
  if (!h)
    return null;
  const v = xt("TitleFieldTemplate", l, d);
  return C.jsx(v, { id: OC(t), title: h, required: s, schema: r, uiSchema: a, registry: l });
}
function z5(e, t, n) {
  const r = "!@#!@$@#$!@$#";
  return e.map(({ schema: a }) => a).find((a) => {
    const s = Re(a, [gn, t]);
    return Re(s, gC, Re(s, qi, r)) === n;
  });
}
function $L(e, t, n, r, a) {
  const s = t.map((d) => n.retrieveSchema(d, a));
  let l = e;
  rn(e, Kt) ? l = { ...e, [Kt]: s } : rn(e, dn) && (l = { ...e, [dn]: s });
  const c = Ng(l, r);
  if (!c)
    throw new Error(`No enumOptions were computed from the schema ${JSON.stringify(l)}`);
  return c;
}
function tRe(e) {
  const { name: t, baseType: n, disabled: r = !1, formData: a, fieldPathId: s, onBlur: l, onChange: c, options: d, onFocus: f, registry: m, uiSchema: h, schema: v, autofocus: g, readonly: b, required: x, errorSchema: w, hideError: k = !1 } = e, { widgets: E, schemaUtils: _, globalUiOptions: O } = m, [N, A] = M.useState($L(v, d, _, h, a)), R = Re(s, Ln), D = Wl(v), I = xt("FieldErrorTemplate", m, d), z = xt("FieldTemplate", m, d), B = Rl(v), P = Rl(d), H = h ? Rl(h) : "", L = a ? Rl(a) : "";
  M.useEffect(() => {
    A($L(v, d, _, h, a));
  }, [B, P, _, H, L]);
  const { widget: G = D ? "radio" : "select", title: $ = "", placeholder: K = "", optionsSchemaSelector: q = D, hideError: Z, ...V } = vt(h);
  if (!q)
    throw new Error("No selector field provided for the LayoutMultiSchemaField");
  const F = Re(a, q);
  let Y = Re(N[0]?.schema, [gn, q], {});
  const U = z5(N, q, F);
  Y = Y?.type ? Y : { ...Y, type: U?.type || n };
  const W = ql(Y, G, E), J = Z === void 0 ? k : !!Z, oe = Re(w, [zo], []), fe = ES(w, [zo]), ie = _.getDisplayLabel(v, h, O), ce = (le) => {
    const me = z5(N, q, le), ve = z5(N, q, F);
    let xe = _.sanitizeDataForNewSchema(me, ve, a);
    xe && me && (xe = _.getDefaultFormState(me, xe, "excludeObjectChildren")), xe && zn(xe, q, le), c(xe, s.path, void 0, R);
  }, ge = { enumOptions: N, ...V }, re = !J && oe.length > 0 ? C.jsx(I, { fieldPathId: s, schema: v, errors: oe, registry: m }) : void 0;
  return C.jsx(z, { id: R, schema: v, label: ($ || v.title) ?? "", disabled: r || Array.isArray(N) && $r(N), uiSchema: h, required: x, readonly: !!b, registry: m, displayLabel: ie, errors: re, onChange: c, onKeyRename: W_, onKeyRenameBlur: W_, onRemoveProperty: W_, children: C.jsx(W, { id: R, name: t, schema: v, label: ($ || v.title) ?? "", disabled: r || Array.isArray(N) && $r(N), uiSchema: h, autofocus: g, readonly: b, required: x, registry: m, multiple: !1, rawErrors: oe, hideError: J, hideLabel: !ie, errorSchema: fe, placeholder: K, onChange: ce, onBlur: l, onFocus: f, value: F, options: ge, htmlName: s.name }) });
}
class zL extends M.Component {
  /** Constructs an `AnyOfField` with the given `props` to initialize the initially selected option in state
   *
   * @param props - The `FieldProps` for this template
   */
  constructor(n) {
    super(n);
    /** Callback handler to remember what the currently selected option is. In addition to that the `formData` is updated
     * to remove properties that are not part of the newly selected option schema, and then the updated data is passed to
     * the `onChange` handler.
     *
     * @param option - The new option value being selected
     */
    no(this, "onOptionChange", (n) => {
      const { selectedOption: r, retrievedOptions: a } = this.state, { formData: s, onChange: l, registry: c, fieldPathId: d } = this.props, { schemaUtils: f } = c, m = n !== void 0 ? parseInt(n, 10) : -1;
      if (m === r)
        return;
      const h = m >= 0 ? a[m] : void 0, v = r >= 0 ? a[r] : void 0;
      let g = f.sanitizeDataForNewSchema(h, v, s);
      h && (g = f.getDefaultFormState(h, g, "excludeObjectChildren")), this.setState({ selectedOption: m }, () => {
        l(g, d.path, void 0, this.getFieldId());
      });
    });
    const { formData: r, options: a, registry: { schemaUtils: s } } = this.props, l = a.map((c) => s.retrieveSchema(c, r));
    this.state = {
      retrievedOptions: l,
      selectedOption: this.getMatchingOption(0, r, l)
    };
  }
  /** React lifecycle method that is called when the props and/or state for this component is updated. It recomputes the
   * currently selected option based on the overall `formData`
   *
   * @param prevProps - The previous `FieldProps` for this template
   * @param prevState - The previous `AnyOfFieldState` for this template
   */
  componentDidUpdate(n, r) {
    const { formData: a, options: s, fieldPathId: l } = this.props, { selectedOption: c } = this.state;
    let d = this.state;
    if (!er(n.options, s)) {
      const { registry: { schemaUtils: f } } = this.props, m = s.map((h) => f.retrieveSchema(h, a));
      d = { selectedOption: c, retrievedOptions: m };
    }
    if (!er(a, n.formData) && l.$id === n.fieldPathId.$id) {
      const { retrievedOptions: f } = d, m = this.getMatchingOption(c, a, f);
      r && m !== c && (d = { selectedOption: m, retrievedOptions: f });
    }
    d !== this.state && this.setState(d);
  }
  /** Determines the best matching option for the given `formData` and `options`.
   *
   * @param formData - The new formData
   * @param options - The list of options to choose from
   * @return - The index of the `option` that best matches the `formData`
   */
  getMatchingOption(n, r, a) {
    const { schema: s, registry: { schemaUtils: l } } = this.props, c = Wl(s);
    return l.getClosestMatchingOption(r, a, n, c);
  }
  getFieldId() {
    const { fieldPathId: n, schema: r } = this.props;
    return `${n.$id}${r.oneOf ? "__oneof_select" : "__anyof_select"}`;
  }
  /** Renders the `AnyOfField` selector along with a `SchemaField` for the value of the `formData`
   */
  render() {
    const { name: n, disabled: r = !1, errorSchema: a = {}, formData: s, onBlur: l, onFocus: c, readonly: d, required: f = !1, registry: m, schema: h, uiSchema: v } = this.props, { widgets: g, fields: b, translateString: x, globalUiOptions: w, schemaUtils: k } = m, { SchemaField: E } = b, _ = xt("MultiSchemaFieldTemplate", m, w), O = Ek(m, h, f, v), N = Kg(s), { selectedOption: A, retrievedOptions: R } = this.state, { widget: D = "select", placeholder: I, autofocus: z, autocomplete: B, title: P = h.title, ...H } = vt(v, w), L = ql({ type: "number" }, D, g), G = Re(a, zo, []), $ = ES(a, [zo]), K = k.getDisplayLabel(h, v, w), q = A >= 0 && R[A] || null;
    let Z;
    if (q) {
      const { required: fe } = h;
      Z = fe ? Vc({ required: fe }, q) : q;
    }
    let V = [];
    Kt in h && v && Kt in v ? Array.isArray(v[Kt]) ? V = v[Kt] : console.warn(`uiSchema.oneOf is not an array for "${P || n}"`) : dn in h && v && dn in v && (Array.isArray(v[dn]) ? V = v[dn] : console.warn(`uiSchema.anyOf is not an array for "${P || n}"`));
    let F = v;
    A >= 0 && V.length > A && (F = V[A]);
    const Y = P ? Jt.TitleOptionPrefix : Jt.OptionPrefix, U = P ? [P] : [], W = R.map((fe, ie) => {
      const { title: ce = fe.title } = vt(V[ie]);
      return {
        label: ce || x(Y, U.concat(String(ie + 1))),
        value: ie
      };
    }), J = !O || N ? C.jsx(L, { id: this.getFieldId(), name: `${n}${h.oneOf ? "__oneof_select" : "__anyof_select"}`, schema: { type: "number", default: 0 }, onChange: this.onOptionChange, onBlur: l, onFocus: c, disabled: r || $r(W), multiple: !1, rawErrors: G, errorSchema: $, value: A >= 0 ? A : void 0, options: { enumOptions: W, ...H }, registry: m, placeholder: I, autocomplete: B, autofocus: z, label: P ?? n, hideLabel: !K, readonly: d }) : void 0, oe = Z && Z.type !== "null" && C.jsx(E, { ...this.props, schema: Z, uiSchema: F }) || null;
    return C.jsx(_, { schema: h, registry: m, uiSchema: v, selector: J, optionSchemaField: oe });
  }
}
const nRe = /\.([0-9]*0)*$/, rRe = /[0.]0*$/;
function oRe(e) {
  const { registry: t, onChange: n, formData: r, value: a } = e, [s, l] = M.useState(a), { StringField: c } = t.fields;
  let d = r;
  const f = M.useCallback((m, h, v, g) => {
    l(m), `${m}`.charAt(0) === "." && (m = `0${m}`);
    const b = typeof m == "string" && m.match(nRe) ? ez(m.replace(rRe, "")) : ez(m);
    n(b, h, v, g);
  }, [n]);
  if (typeof s == "string" && typeof d == "number") {
    const m = new RegExp(`^(${String(d).replace(".", "\\.")})?\\.?0*$`);
    s.match(m) && (d = s);
  }
  return C.jsx(c, { ...e, formData: d, onChange: f });
}
function _l() {
  return _l = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, _l.apply(null, arguments);
}
const t_ = ["strong", "em", "del", "mark"], TL = [["**", t_[0]], ["__", t_[0]], ["~~", t_[2]], ["==", t_[3]], ["*", "em"], ["_", "em"]];
function aRe(e, t) {
  for (var n = 1, r = t + 1; r < e.length && n > 0; ) e[r] !== "\\" ? (e[r] === "[" && n++, e[r] === "]" && n--, r++) : r += 2;
  if (n === 0 && r < e.length && (e[r] === "(" || e[r] === "[")) {
    var a = e[r] === "(" ? ")" : "]", s = 1;
    for (r++; r < e.length && s > 0; ) e[r] !== "\\" ? (e[r] === "(" && a === ")" && s++, e[r] === a && s--, r++) : r += 2;
    if (s === 0) return r;
  }
  return -1;
}
function iRe(e, t) {
  if (!t || !t.inline && !t.simple) return null;
  var n = e[0];
  if (n !== "*" && n !== "_" && n !== "~" && n !== "=") return null;
  for (var r = "", a = 0, s = "", l = 0; l < 6; l++) {
    var c = TL[l][0];
    if (e.startsWith(c) && e.length >= 2 * c.length) {
      r = c, a = c.length, s = TL[l][1];
      break;
    }
  }
  if (!r) return null;
  for (var d = a, f = !1, m = !1, h = "", v = 0, g = "", b = !1, x = ""; d < e.length; ) {
    var w = e[d];
    if (b) g += w, b = !1, x = w, d++;
    else if (w !== "\\") if (w !== "`" || v !== 0) {
      if (w === "[" && !f && v === 0) {
        var k = aRe(e, d);
        if (k !== -1) {
          g += e.slice(d, k), d = k, x = e[k - 1];
          continue;
        }
      }
      if (m) g += w, h ? w === h && (h = "") : w === '"' || w === "'" ? h = w : w === ">" && (m = !1), x = w, d++;
      else if (w !== "<" || f) {
        if (w === `
` && x === `
` && !f && v === 0) return null;
        if (!f && v === 0) {
          for (var E = 0; d + E < e.length && e[d + E] === r[0]; ) E++;
          if (E >= a && (a !== 1 || r !== "*" && r !== "_" || e[d - 1] !== r && e[d + 1] !== r)) {
            var _ = [e.slice(0, d + E), s, g + e.slice(d + a, d + E)];
            return _.index = 0, _.input = e, _;
          }
        }
        g += w, x = w, d++;
      } else {
        var O = e[d + 1], N = e.indexOf(">", d);
        if (N !== -1) {
          var A = e.slice(d, N + 1).endsWith("/>");
          O === "/" ? v = Math.max(0, v - 1) : A || v++;
        }
        m = !0, g += w, x = w, d++;
      }
    } else f = !f, g += w, x = w, d++;
    else g += w, b = !0, x = w, d++;
  }
  return null;
}
const sRe = ["children", "options"], LL = ["allowFullScreen", "allowTransparency", "autoComplete", "autoFocus", "autoPlay", "cellPadding", "cellSpacing", "charSet", "classId", "colSpan", "contentEditable", "contextMenu", "crossOrigin", "encType", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "frameBorder", "hrefLang", "inputMode", "keyParams", "keyType", "marginHeight", "marginWidth", "maxLength", "mediaGroup", "minLength", "noValidate", "radioGroup", "readOnly", "rowSpan", "spellCheck", "srcDoc", "srcLang", "srcSet", "tabIndex", "useMap"].reduce((e, t) => (e[t.toLowerCase()] = t, e), { class: "className", for: "htmlFor" }), FL = { amp: "&", apos: "'", gt: ">", lt: "<", nbsp: "", quot: "" }, lRe = ["style", "script", "pre"], uRe = ["src", "href", "data", "formAction", "srcDoc", "action"], cRe = /([-A-Z0-9_:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|(?:\{((?:\\.|{[^}]*?}|[^}])*)\})))?/gi, dRe = /\n{2,}$/, BL = /^(\s*>[\s\S]*?)(?=\n\n|$)/, fRe = /^ *> ?/gm, pRe = /^(?:\[!([^\]]*)\]\n)?([\s\S]*)/, mRe = /^ {2,}\n/, hRe = /^(?:([-*_])( *\1){2,}) *(?:\n *)+\n/, UL = /^(?: {1,3})?(`{3,}|~{3,}) *(\S+)? *([^\n]*?)?\n([\s\S]*?)(?:\1\n?|$)/, VL = /^(?: {4}[^\n]+\n*)+(?:\n *)+\n?/, gRe = /^(`+)((?:\\`|(?!\1)`|[^`])+)\1/, vRe = /^(?:\n *)*\n/, yRe = /\r\n?/g, bRe = /^\[\^([^\]]+)](:(.*)((\n+ {4,}.*)|(\n(?!\[\^).+))*)/, wRe = /^\[\^([^\]]+)]/, xRe = /\f/g, SRe = /^---[ \t]*\n(.|\n)*\n---[ \t]*\n/, kRe = /^\[(x|\s)\]/, HL = /^(#{1,6}) *([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, WL = /^ *(#{1,6}) +([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, qL = /^([^\n]+)\n *(=|-)\2{2,} *\n/, dP = /^<([a-z][^ >/]*) ?((?:[^>]*[^/])?)>/i;
function _Re(e) {
  const t = dP.exec(e);
  if (!t) return null;
  const n = t[1], r = n.toLowerCase(), a = r.length + 1;
  let s = t[0].length;
  e[s] === `
` && s++;
  const l = s;
  let c = s, d = 1;
  const f = e.length;
  for (; d > 0; ) {
    const h = e.indexOf("<", s);
    if (h === -1) return null;
    let v = -1, g = -1;
    if (e[h + 1] === "/") g = h;
    else if (e[h + 1] === r[0] || e[h + 1] === n[0]) {
      let b = !0;
      for (let x = 0; x < r.length; x++) {
        const w = e[h + 1 + x];
        if (w !== r[x] && w !== n[x]) {
          b = !1;
          break;
        }
      }
      !b || e[h + a] !== " " && e[h + a] !== ">" || (v = h);
    }
    if (v !== -1 || g !== -1) if (v !== -1 && (g === -1 || v < g)) s = v + a + 1, d++;
    else {
      let b = g + 2;
      for (; b < f; ) {
        const w = e[b];
        if (w !== " " && w !== "	" && w !== `
` && w !== "\r") break;
        b++;
      }
      if (b + r.length > f) return null;
      let x = !0;
      for (let w = 0; w < r.length; w++) {
        const k = e[b + w];
        if (k !== r[w] && k !== n[w]) {
          x = !1;
          break;
        }
      }
      if (!x) {
        s = b;
        continue;
      }
      for (b += r.length; b < f; ) {
        const w = e[b];
        if (w !== " " && w !== "	" && w !== `
` && w !== "\r") break;
        b++;
      }
      if (b >= f || e[b] !== ">") {
        s = b;
        continue;
      }
      c = g, s = b + 1, d--;
    }
    else s = h + 1;
  }
  let m = 0;
  for (; s + m < f && e[s + m] === `
`; ) m++;
  return [e.slice(0, s + m), n, t[2], e.slice(l, c)];
}
const ERe = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi, GL = /^<!--[\s\S]*?(?:-->)/, CRe = /^(data|aria|x)-[a-z_][a-z\d_.-]*$/, Y3 = /^ *<([a-z][a-z0-9:]*)(?:\s+((?:<.*?>|[^>])*))?\/?>(?!<\/\1>)(\s*\n)?/i, ORe = /^\{.*\}$/, MRe = /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/, NRe = /^<([^ >]+[:@\/][^ >]+)>/, ARe = /-([a-z])?/gi, KL = /^(\|.*)\n(?: *(\|? *[-:]+ *\|[-| :]*)\n((?:.*\|.*\n)*))?\n?/, RRe = /^[^\n]+(?:  \n|\n{2,})/, jRe = /^\[([^\]]*)\]:\s+<?([^\s>]+)>?\s*("([^"]*)")?/, PRe = /^!\[([^\]]*)\] ?\[([^\]]*)\]/, DRe = /^\[([^\]]*)\] ?\[([^\]]*)\]/, IRe = /(\n|^[-*]\s|^#|^ {2,}|^-{2,}|^>\s)/, $Re = /\t/g, zRe = /(^ *\||\| *$)/g, TRe = /^ *:-+: *$/, LRe = /^ *:-+ *$/, FRe = /^ *-+: *$/, BRe = /^(:[a-zA-Z0-9-_]+:)/, URe = /^\\([^0-9A-Za-z\s])/, VRe = /\\([^0-9A-Za-z\s])/g, HRe = /^[\s\S](?:(?!  \n|[0-9]\.|http)[^=*_~\-\n:<`\\\[!])*/, WRe = /^\n+/, qRe = /^([ \t]*)/, GRe = /(?:^|\n)( *)$/, fP = "(?:\\d+\\.)", pP = "(?:[*+-])";
function TK(e) {
  return "( *)(" + (e === 1 ? fP : pP) + ") +";
}
const LK = TK(1), FK = TK(2);
function BK(e) {
  return RegExp("^" + (e === 1 ? LK : FK));
}
const KRe = BK(1), YRe = BK(2);
function UK(e) {
  return RegExp("^" + (e === 1 ? LK : FK) + "[^\\n]*(?:\\n(?!\\1" + (e === 1 ? fP : pP) + " )[^\\n]*)*(\\n|$)", "gm");
}
const XRe = UK(1), JRe = UK(2);
function VK(e) {
  const t = e === 1 ? fP : pP;
  return RegExp("^( *)(" + t + ") [\\s\\S]+?(?:\\n{2,}(?! )(?!\\1" + t + " (?!" + t + " ))\\n*|\\s*\\n*$)");
}
const HK = VK(1), WK = VK(2);
function YL(e, t) {
  const n = t === 1, r = n ? HK : WK, a = n ? XRe : JRe, s = n ? KRe : YRe;
  return { t: (l) => s.test(l), o: yd(function(l, c) {
    const d = GRe.exec(c.prevCapture);
    return d && (c.list || !c.inline && !c.simple) ? r.exec(l = d[1] + l) : null;
  }), u: 1, i(l, c, d) {
    const f = n ? +l[2] : void 0, m = l[0].replace(dRe, `
`).match(a), h = s.exec(m[0]), v = RegExp("^ {1," + (h ? h[0].length : 0) + "}", "gm");
    let g = !1;
    return { items: m.map(function(b, x) {
      const w = b.replace(v, "").replace(s, ""), k = x === m.length - 1, E = gl(w, `

`) || k && g;
      g = E;
      const _ = d.inline, O = d.list;
      let N;
      d.list = !0, E ? (d.inline = !1, N = Bx(w) + `

`) : (d.inline = !0, N = Bx(w));
      const A = c(N, d);
      return d.inline = _, d.list = O, A;
    }), ordered: n, start: f };
  } };
}
const QRe = RegExp(`^\\[((?:\\[[^\\[\\]]*(?:\\[[^\\[\\]]*\\][^\\[\\]]*)*\\]|[^\\[\\]])*)\\]\\(\\s*<?((?:\\([^)]*\\)|[^\\s\\\\]|\\\\.)*?)>?(?:\\s+['"]([\\s\\S]*?)['"])?\\s*\\)`), ZRe = /^!\[(.*?)\]\( *((?:\([^)]*\)|[^() ])*) *"?([^)"]*)?"?\)/;
function XL(e) {
  return typeof e == "string";
}
function Bx(e) {
  let t = e.length;
  for (; t > 0 && e[t - 1] <= " "; ) t--;
  return e.slice(0, t);
}
function X3(e, t) {
  return e.startsWith(t);
}
function gl(e, t) {
  return e.indexOf(t) !== -1;
}
function e4e(e, t, n) {
  if (Array.isArray(n)) {
    for (let r = 0; r < n.length; r++) if (X3(e, n[r])) return !0;
    return !1;
  }
  return n(e, t);
}
function ox(e) {
  return e.replace(/[]/g, "a").replace(/[]/g, "c").replace(/[]/g, "d").replace(/[]/g, "e").replace(/[]/g, "i").replace(/[]/g, "n").replace(/[]/g, "o").replace(/[]/g, "u").replace(/[]/g, "y").replace(/[^a-z0-9- ]/gi, "").replace(/ /gi, "-").toLowerCase();
}
function t4e(e) {
  return FRe.test(e) ? "right" : TRe.test(e) ? "center" : LRe.test(e) ? "left" : null;
}
function JL(e, t, n, r) {
  const a = n.inTable;
  n.inTable = !0;
  let s = [[]], l = "";
  function c() {
    if (!l) return;
    const d = s[s.length - 1];
    d.push.apply(d, t(l, n)), l = "";
  }
  return e.trim().split(/(`[^`]*`|\\\||\|)/).filter(Boolean).forEach((d, f, m) => {
    d.trim() === "|" && (c(), r) ? f !== 0 && f !== m.length - 1 && s.push([]) : l += d;
  }), c(), n.inTable = a, s;
}
function n4e(e, t, n) {
  n.inline = !0;
  const r = e[2] ? e[2].replace(zRe, "").split("|").map(t4e) : [], a = e[3] ? (function(l, c, d) {
    return l.trim().split(`
`).map(function(f) {
      return JL(f, c, d, !0);
    });
  })(e[3], t, n) : [], s = JL(e[1], t, n, !!a.length);
  return n.inline = !1, a.length ? { align: r, cells: a, header: s, type: "25" } : { children: s, type: "21" };
}
function QL(e, t) {
  return e.align[t] == null ? {} : { textAlign: e.align[t] };
}
function yd(e) {
  return e.inline = 1, e;
}
function ld(e) {
  return yd(function(t, n) {
    return n.inline ? e.exec(t) : null;
  });
}
function n_(e) {
  return yd(function(t, n) {
    return n.inline || n.simple ? e.exec(t) : null;
  });
}
function kc(e) {
  return function(t, n) {
    return n.inline || n.simple ? null : e.exec(t);
  };
}
function ZL(e) {
  return yd(function(t) {
    return e.exec(t);
  });
}
const r4e = /(javascript|vbscript|data(?!:image)):/i;
function o4e(e) {
  try {
    const t = decodeURIComponent(e).replace(/[^A-Za-z0-9/:]/g, "");
    if (r4e.test(t)) return null;
  } catch {
    return null;
  }
  return e;
}
function yl(e) {
  return e && e.replace(VRe, "$1");
}
function Y_(e, t, n) {
  const r = n.inline || !1, a = n.simple || !1;
  n.inline = !0, n.simple = !0;
  const s = e(t, n);
  return n.inline = r, n.simple = a, s;
}
function a4e(e, t, n) {
  const r = n.inline || !1, a = n.simple || !1;
  n.inline = !1, n.simple = !0;
  const s = e(t, n);
  return n.inline = r, n.simple = a, s;
}
function i4e(e, t, n) {
  const r = n.inline || !1;
  n.inline = !1;
  const a = e(t, n);
  return n.inline = r, a;
}
const s4e = (e, t, n) => ({ children: Y_(t, e[2], n) });
function T5() {
  return {};
}
function l4e(...e) {
  return e.filter(Boolean).join(" ");
}
function L5(e, t, n) {
  let r = e;
  const a = t.split(".");
  for (; a.length && (r = r[a[0]], r !== void 0); ) a.shift();
  return r || n;
}
function F5(e, t, n, r) {
  if (!t || !t.trim()) return null;
  const a = t.match(cRe);
  return a ? a.reduce(function(s, l) {
    const c = l.indexOf("=");
    if (c !== -1) {
      const d = (function(h) {
        return h.indexOf("-") !== -1 && h.match(CRe) === null && (h = h.replace(ARe, function(v, g) {
          return g.toUpperCase();
        })), h;
      })(l.slice(0, c)).trim(), f = LL[d] || d;
      if (f === "ref") return s;
      const m = s[f] = (function(h, v, g, b) {
        return v === "style" ? (function(x) {
          const w = [];
          if (!x) return w;
          let k = "", E = 0, _ = "";
          for (let N = 0; N < x.length; N++) {
            const A = x[N];
            if (A === '"' || A === "'") _ ? A === _ && (_ = "", E--) : (_ = A, E++);
            else if (A === "(" && k.endsWith("url")) E++;
            else if (A === ")" && E > 0) E--;
            else if (A === ";" && E === 0) {
              const R = k.indexOf(":");
              R > 0 && w.push([k.slice(0, R).trim(), k.slice(R + 1).trim()]), k = "";
              continue;
            }
            k += A;
          }
          const O = k.indexOf(":");
          return O > 0 && w.push([k.slice(0, O).trim(), k.slice(O + 1).trim()]), w;
        })(g).reduce(function(x, [w, k]) {
          return x[w.replace(/(-[a-z])/g, (E) => E[1].toUpperCase())] = b(k, h, w), x;
        }, {}) : uRe.indexOf(v) !== -1 ? b(yl(g), h, v) : (g.match(ORe) && (g = yl(g.slice(1, g.length - 1))), g === "true" || g !== "false" && g);
      })(e, d, (function(h) {
        const v = h[0];
        return (v === '"' || v === "'") && h.length >= 2 && h[h.length - 1] === v ? h.slice(1, -1) : h;
      })(l.slice(c + 1).trim()), n);
      typeof m == "string" && (dP.test(m) || Y3.test(m)) && (s[f] = r(m.trim()));
    } else l !== "style" && (s[LL[l] || l] = !0);
    return s;
  }, {}) : null;
}
function e9(e, t) {
  for (let n = 0; n < e.length; n++) if (e[n].test(t)) return !0;
  return !1;
}
function u4e(e = "", t = {}) {
  t.overrides = t.overrides || {}, t.namedCodesToUnicode = t.namedCodesToUnicode ? _l({}, FL, t.namedCodesToUnicode) : FL;
  const n = t.slugify || ox, r = t.sanitizer || o4e, a = t.createElement || M.createElement, s = [BL, UL, VL, t.enforceAtxHeadings ? WL : HL, qL, KL, HK, WK], l = [...s, RRe, dP, GL, Y3];
  function c(b, x, ...w) {
    const k = L5(t.overrides, b + ".props", {});
    return a((function(E, _) {
      const O = L5(_, E);
      return O ? typeof O == "function" || typeof O == "object" && "render" in O ? O : L5(_, E + ".component", E) : E;
    })(b, t.overrides), _l({}, x, k, { className: l4e(x?.className, k.className) || void 0 }), ...w);
  }
  function d(b) {
    b = b.replace(SRe, "");
    let x = !1;
    t.forceInline ? x = !0 : t.forceBlock || (x = IRe.test(b) === !1);
    const w = v(x ? b : Bx(b).replace(WRe, "") + `

`, { inline: x });
    if (t.ast) return w;
    const k = g(w);
    for (; XL(k[k.length - 1]) && !k[k.length - 1].trim(); ) k.pop();
    if (f.length && k.push(c("footer", { key: "footer" }, f.map(function(O) {
      return c("div", { id: n(O.identifier, ox), key: O.identifier }, O.identifier, g(v(O.footnote, { inline: !0 })));
    }))), t.wrapper === null) return k;
    const E = t.wrapper || (x ? "span" : "div");
    let _;
    if (k.length > 1 || t.forceWrapper) _ = k;
    else {
      if (k.length === 1) return _ = k[0], typeof _ == "string" ? c("span", { key: "outer" }, _) : _;
      _ = null;
    }
    return a(E, _l({ key: "outer" }, t.wrapperProps), _);
  }
  const f = [], m = {}, h = { 0: { t: [">"], o: kc(BL), u: 1, i(b, x, w) {
    const [, k, E] = b[0].replace(fRe, "").match(pRe);
    return { alert: k, children: x(E, w) };
  } }, 1: { t: ["  "], o: ld(mRe), u: 1, i: T5 }, 2: { t: function(b, x) {
    if (x.inline || x.simple) return !1;
    var w = b[0];
    return w === "-" || w === "*" || w === "_";
  }, o: kc(hRe), u: 1, i: T5 }, 3: { t: ["    "], o: kc(VL), u: 0, i: (b) => ({ lang: void 0, text: yl(Bx(b[0].replace(/^ {4}/gm, ""))) }) }, 4: { t: ["```", "~~~"], o: kc(UL), u: 0, i: (b) => ({ attrs: F5("code", b[3] || "", r, d), lang: b[2] || void 0, text: b[4], type: "3" }) }, 5: { t: ["`"], o: n_(gRe), u: 3, i: (b) => ({ text: yl(b[2]) }) }, 6: { t: ["[^"], o: kc(bRe), u: 0, i: (b) => (f.push({ footnote: b[2], identifier: b[1] }), {}) }, 7: { t: ["[^"], o: ld(wRe), u: 1, i: (b) => ({ target: "#" + n(b[1], ox), text: b[1] }) }, 8: { t: ["[ ]", "[x]"], o: ld(kRe), u: 1, i: (b) => ({ completed: b[1].toLowerCase() === "x" }) }, 9: { t: ["#"], o: kc(t.enforceAtxHeadings ? WL : HL), u: 1, i: (b, x, w) => ({ children: Y_(x, b[2], w), id: n(b[2], ox), level: b[1].length }) }, 10: { t: (b) => {
    const x = b.indexOf(`
`);
    return x > 0 && x < b.length - 1 && (b[x + 1] === "=" || b[x + 1] === "-");
  }, o: kc(qL), u: 1, i: (b, x, w) => ({ children: Y_(x, b[1], w), level: b[2] === "=" ? 1 : 2, type: "9" }) }, 11: { t: ["<"], o: yd(_Re), u: 1, i(b, x, w) {
    const [, k] = b[3].match(qRe), E = RegExp("^" + k, "gm"), _ = b[3].replace(E, ""), O = e9(l, _) ? i4e : Y_, N = b[1].toLowerCase(), A = lRe.indexOf(N) !== -1, R = (A ? N : b[1]).trim(), D = { attrs: F5(R, b[2], r, d), noInnerParse: A, tag: R };
    if (w.inAnchor = w.inAnchor || N === "a", A) D.text = b[3];
    else {
      const I = w.inHTML;
      w.inHTML = !0, D.children = O(x, _, w), w.inHTML = I;
    }
    return w.inAnchor = !1, D;
  } }, 13: { t: ["<"], o: ZL(Y3), u: 1, i(b) {
    const x = b[1].trim();
    return { attrs: F5(x, b[2] || "", r, d), tag: x };
  } }, 12: { t: ["<!--"], o: ZL(GL), u: 1, i: () => ({}) }, 14: { t: ["!["], o: n_(ZRe), u: 1, i: (b) => ({ alt: yl(b[1]), target: yl(b[2]), title: yl(b[3]) }) }, 15: { t: ["["], o: ld(QRe), u: 3, i: (b, x, w) => ({ children: a4e(x, b[1], w), target: yl(b[2]), title: yl(b[3]) }) }, 16: { t: function(b, x) {
    return !(!x.inline || x.inAnchor) && b[0] === "<" && (gl(b, ":") || gl(b, "@") || gl(b, "/"));
  }, o: ld(NRe), u: 0, i(b) {
    let x = b[1], w = !1;
    return gl(x, "@") && !gl(x, "//") && (w = !0, x = x.replace("mailto:", "")), { children: [{ text: x, type: "27" }], target: w ? "mailto:" + x : x, type: "15" };
  } }, 17: { t: (b, x) => !x.inAnchor && !t.disableAutoLink && X3(b, "http"), o: ld(MRe), u: 0, i: (b) => ({ children: [{ text: b[1], type: "27" }], target: b[1], title: void 0, type: "15" }) }, 20: YL(0, 1), 30: YL(0, 2), 19: { t: [`
`], o: kc(vRe), u: 3, i: T5 }, 21: { t: function(b, x) {
    return !x.inline && !x.simple;
  }, o: yd(function(b, x) {
    if (x.inline || x.simple || x.inHTML && !gl(b, `

`) && !gl(x.prevCapture, `

`)) return null;
    let w = "", k = 0;
    for (; ; ) {
      const _ = b.indexOf(`
`, k), O = b.slice(k, _ === -1 ? void 0 : _ + 1), N = b[k];
      if ((N === ">" || N === "#" || N === "|" || N === "`" || N === "~" || N === "*" || N === "-" || N === "_" || N === " ") && e9(s, O) || (w += O, _ === -1 || !O.trim())) break;
      k = _ + 1;
    }
    const E = Bx(w);
    return E === "" ? null : [w, , E];
  }), u: 3, i: s4e }, 22: { t: ["["], o: ld(jRe), u: 0, i: (b) => (m[b[1]] = { target: b[2], title: b[4] }, {}) }, 23: { t: ["!["], o: n_(PRe), u: 0, i: (b) => ({ alt: b[1] ? yl(b[1]) : void 0, ref: b[2] }) }, 24: { t: (b) => b[0] === "[" && !gl(b, "]("), o: ld(DRe), u: 0, i: (b, x, w) => ({ children: x(b[1], w), fallbackChildren: b[0], ref: b[2] }) }, 25: { t: ["|"], o: kc(KL), u: 1, i: n4e }, 27: { o: yd(function(b, x) {
    let w;
    return X3(b, ":") && (w = BRe.exec(b)), w || HRe.exec(b);
  }), u: 4, i(b) {
    const x = b[0];
    return { text: gl(x, "&") ? x.replace(ERe, (w, k) => t.namedCodesToUnicode[k] || w) : x };
  } }, 34: { t: ["*", "_", "~", "="], o: yd(iRe), u: 2, i: (b, x, w) => ({ children: x(b[2], w), tag: b[1] }) }, 28: { t: ["\\"], o: n_(URe), u: 1, i: (b) => ({ text: b[1], type: "27" }) } };
  t.disableParsingRawHTML === !0 && (delete h[11], delete h[13]);
  const v = (function(b) {
    var x = Object.keys(b);
    function w(k, E) {
      var _ = [];
      if (E.prevCapture = E.prevCapture || "", k.trim()) for (; k; ) for (var O = 0; O < x.length; ) {
        var N = x[O], A = b[N];
        if (!A.t || e4e(k, E, A.t)) {
          var R = A.o(k, E);
          if (R && R[0]) {
            k = k.substring(R[0].length);
            var D = A.i(R, w, E);
            E.prevCapture += R[0], D.type || (D.type = N), _.push(D);
            break;
          }
          O++;
        } else O++;
      }
      return E.prevCapture = "", _;
    }
    return x.sort(function(k, E) {
      return b[k].u - b[E].u || (k < E ? -1 : 1);
    }), function(k, E) {
      return w((function(_) {
        return _.replace(yRe, `
`).replace(xRe, "").replace($Re, "    ");
      })(k), E);
    };
  })(h), g = /* @__PURE__ */ (function(b, x, w, k, E) {
    function _(O) {
      return Array.isArray(O) ? O.map((N) => "text" in N ? N.text : "") : "text" in O ? O.text : "";
    }
    return function O(N, A = {}) {
      const R = (A.renderDepth || 0) + 1;
      if (R > 2500) return _(N);
      A.renderDepth = R;
      try {
        if (Array.isArray(N)) {
          const I = A.key, z = [];
          let B = !1;
          for (let P = 0; P < N.length; P++) {
            A.key = P;
            const H = O(N[P], A), L = XL(H);
            L && B ? z[z.length - 1] += H : H !== null && z.push(H), B = L;
          }
          return A.key = I, A.renderDepth = R - 1, z;
        }
        const D = (function(I, z, B) {
          const P = () => (function(H, L, G, $, K, q, Z) {
            switch (H.type) {
              case "0": {
                const V = { key: G.key };
                return H.alert && (V.className = "markdown-alert-" + q(H.alert.toLowerCase(), ox), H.children.unshift({ attrs: {}, children: [{ type: "27", text: H.alert }], noInnerParse: !0, type: "11", tag: "header" })), $("blockquote", V, L(H.children, G));
              }
              case "1":
                return $("br", { key: G.key });
              case "2":
                return $("hr", { key: G.key });
              case "3":
                return $("pre", { key: G.key }, $("code", _l({}, H.attrs, { className: H.lang ? "lang-" + H.lang : "" }), H.text));
              case "5":
                return $("code", { key: G.key }, H.text);
              case "7":
                return $("a", { key: G.key, href: K(H.target, "a", "href") }, $("sup", { key: G.key }, H.text));
              case "8":
                return $("input", { checked: H.completed, key: G.key, readOnly: !0, type: "checkbox" });
              case "9":
                return $("h" + H.level, { id: H.id, key: G.key }, L(H.children, G));
              case "11":
                return $(H.tag, _l({ key: G.key }, H.attrs), H.text || (H.children ? L(H.children, G) : ""));
              case "13":
                return $(H.tag, _l({}, H.attrs, { key: G.key }));
              case "14":
                return $("img", { key: G.key, alt: H.alt || void 0, title: H.title || void 0, src: K(H.target, "img", "src") });
              case "15":
                return $("a", { key: G.key, href: K(H.target, "a", "href"), title: H.title }, L(H.children, G));
              case "23":
                return Z[H.ref] ? $("img", { key: G.key, alt: H.alt, src: K(Z[H.ref].target, "img", "src"), title: Z[H.ref].title }) : null;
              case "24":
                return Z[H.ref] ? $("a", { key: G.key, href: K(Z[H.ref].target, "a", "href"), title: Z[H.ref].title }, L(H.children, G)) : $("span", { key: G.key }, H.fallbackChildren);
              case "25": {
                const V = H;
                return $("table", { key: G.key }, $("thead", null, $("tr", null, V.header.map(function(F, Y) {
                  return $("th", { key: Y, style: QL(V, Y) }, L(F, G));
                }))), $("tbody", null, V.cells.map(function(F, Y) {
                  return $("tr", { key: Y }, F.map(function(U, W) {
                    return $("td", { key: W, style: QL(V, W) }, L(U, G));
                  }));
                })));
              }
              case "27":
                return H.text;
              case "34":
                return $(H.tag, { key: G.key }, L(H.children, G));
              case "20":
              case "30":
                return $(H.ordered ? "ol" : "ul", { key: G.key, start: H.type === "20" ? H.start : void 0 }, H.items.map(function(V, F) {
                  return $("li", { key: F }, L(V, G));
                }));
              case "19":
                return `
`;
              case "21":
                return $("p", { key: G.key }, L(H.children, G));
              default:
                return null;
            }
          })(I, z, B, x, w, k, E);
          return b ? b(P, I, z, B) : P();
        })(N, O, A);
        return A.renderDepth = R - 1, D;
      } catch (D) {
        if (D instanceof RangeError && D.message.includes("Maximum call stack")) return _(N);
        throw D;
      }
    };
  })(t.renderRule, c, r, n, m);
  return d(e);
}
const Ck = (e) => {
  let { children: t, options: n } = e, r = (function(a, s) {
    if (a == null) return {};
    var l = {};
    for (var c in a) if ({}.hasOwnProperty.call(a, c)) {
      if (s.indexOf(c) !== -1) continue;
      l[c] = a[c];
    }
    return l;
  })(e, sRe);
  return u4e(t ?? "", _l({}, n, { wrapperProps: _l({}, n?.wrapperProps, r) }));
}, qK = /* @__PURE__ */ Symbol("remove-this-key"), t9 = /* @__PURE__ */ Symbol("reset");
function c4e(e, t) {
  return Array.isArray(e.required) && e.required.indexOf(t) !== -1;
}
function d4e(e, t) {
  switch (t) {
    case "array":
      return [];
    case "boolean":
      return !1;
    case "null":
      return null;
    case "number":
      return 0;
    case "object":
      return {};
    default:
      return e(Jt.NewStringDefault);
  }
}
function f4e(e) {
  const { fieldPathId: t, schema: n, registry: r, uiSchema: a, errorSchema: s, formData: l, onChange: c, onBlur: d, onFocus: f, disabled: m, readonly: h, required: v, hideError: g, propertyName: b, handleKeyRename: x, handleRemoveProperty: w, addedByAdditionalProperties: k } = e, [E, _] = M.useState(!1), { globalFormOptions: O, fields: N } = r, { SchemaField: A } = N, R = sh(Yi(b, O, t.path)), D = M.useCallback((P, H, L, G) => {
    P === void 0 && k && (P = ""), c(P, H, L, G);
  }, [c, k]), I = M.useCallback((P) => {
    b !== P && _(!0), x(b, P);
  }, [b, x]), z = M.useCallback((P) => {
    const { target: { value: H } } = P;
    I(H);
  }, [I]), B = M.useCallback(() => {
    w(b);
  }, [b, w]);
  return C.jsx(A, { name: b, required: v, schema: n, uiSchema: a, errorSchema: s, fieldPathId: R, formData: l, wasPropertyKeyModified: E, onKeyRename: I, onKeyRenameBlur: z, onRemoveProperty: B, onChange: D, onBlur: d, onFocus: f, registry: r, disabled: m, readonly: h, hideError: g });
}
function p4e(e) {
  const { schema: t, uiSchema: n = {}, formData: r, errorSchema: a, fieldPathId: s, name: l, required: c = !1, disabled: d, readonly: f, hideError: m, onBlur: h, onFocus: v, onChange: g, registry: b, title: x } = e, { fields: w, schemaUtils: k, translateString: E, globalUiOptions: _ } = b, { OptionalDataControlsField: O } = w, N = k.retrieveSchema(t, r, !0), A = vt(n, _), { properties: R = {} } = N, D = e.childFieldPathId ?? s, I = A.title ?? N.title ?? x ?? l, z = A.description ?? N.description, B = Ek(b, N, c, n), P = Kg(r);
  let H = [];
  const L = M.useCallback((F, Y) => {
    const { duplicateKeySuffixSeparator: U = "-" } = vt(n, _);
    let W = 0, J = F;
    for (; rn(Y, J); )
      J = `${F}${U}${++W}`;
    return J;
  }, [n, _]), G = M.useCallback(() => {
    if (!(N.additionalProperties || N.patternProperties))
      return;
    const { translateString: F } = b, Y = { ...r }, U = L("newKey", Y);
    if (N.patternProperties)
      zn(Y, U, null);
    else {
      let W, J, oe;
      if (mn(N.additionalProperties)) {
        W = N.additionalProperties.type, J = N.additionalProperties.const, oe = N.additionalProperties.default;
        let ie = N.additionalProperties;
        if (cr in ie) {
          const { schemaUtils: ce } = b;
          ie = ce.retrieveSchema({ [cr]: ie[cr] }, r), W = ie.type, J = ie.const, oe = ie.default;
        }
        !W && (dn in ie || Kt in ie) && (W = "object");
      }
      const fe = J ?? oe ?? d4e(F, W);
      zn(Y, U, fe);
    }
    g(Y, D.path);
  }, [r, g, b, D, L, N]), $ = M.useCallback((F, Y) => {
    if (F !== Y) {
      const U = L(Y, r), W = {
        ...r
      }, J = { [F]: U }, oe = Object.keys(W).map((ie) => ({ [J[ie] || ie]: W[ie] })), fe = Object.assign({}, ...oe);
      g(fe, D.path);
    }
  }, [r, g, D, L]), K = M.useCallback((F) => {
    g(qK, [...D.path, F]);
  }, [g, D]);
  if (!B || P)
    try {
      const F = Object.keys(R);
      H = L5e(F, A.order);
    } catch (F) {
      return C.jsxs("div", { children: [C.jsx("p", { className: "rjsf-config-error", style: { color: "red" }, children: C.jsx(Ck, { options: { disableParsingRawHTML: !0 }, children: E(Jt.InvalidObjectField, [l || "root", F.message]) }) }), C.jsx("pre", { children: JSON.stringify(N) })] });
    }
  const q = xt("ObjectFieldTemplate", b, A), Z = B ? C.jsx(O, { ...e, fieldPathId: D, schema: N }) : void 0, V = {
    // getDisplayLabel() always returns false for object types, so just check the `uiOptions.label`
    title: A.label === !1 ? "" : I,
    description: A.label === !1 ? void 0 : z,
    properties: H.map((F) => {
      const Y = rn(N, [gn, F, Pc]), U = Y ? n.additionalProperties : n[F], W = vt(U).widget === "hidden";
      return {
        content: C.jsx(f4e, { propertyName: F, required: c4e(N, F), schema: Re(N, [gn, F], {}), uiSchema: U, errorSchema: Re(a, [F]), fieldPathId: D, formData: Re(r, [F]), handleKeyRename: $, handleRemoveProperty: K, addedByAdditionalProperties: Y, onChange: g, onBlur: h, onFocus: v, registry: b, disabled: d, readonly: f, hideError: m }, F),
        name: F,
        readonly: f,
        disabled: d,
        required: c,
        hidden: W
      };
    }),
    readonly: f,
    disabled: d,
    required: c,
    fieldPathId: s,
    uiSchema: n,
    errorSchema: a,
    schema: N,
    formData: r,
    registry: b,
    optionalDataControl: Z,
    className: B ? "rjsf-optional-object-field" : void 0
  };
  return C.jsx(q, { ...V, onAddProperty: G });
}
function m4e(e) {
  const { schema: t, uiSchema: n = {}, formData: r, disabled: a = !1, readonly: s = !1, onChange: l, errorSchema: c, fieldPathId: d, registry: f } = e, { globalUiOptions: m = {}, schemaUtils: h, translateString: v } = f, g = vt(n, m), b = xt("OptionalDataControlsTemplate", f, g), x = Kg(r);
  let w, k, E, _;
  if (a || s)
    w = N5(d, "Msg"), k = x ? void 0 : v(Jt.OptionalObjectEmptyMsg);
  else {
    const O = x ? Jt.OptionalObjectRemove : Jt.OptionalObjectAdd;
    k = v(O), x ? (w = N5(d, "Remove"), _ = () => l(void 0, d.path, c)) : (w = N5(d, "Add"), E = () => {
      let N = h.getDefaultFormState(t, r, "excludeObjectChildren");
      N === void 0 && (N = rl(t) === "array" ? [] : {}), l(N, d.path, c);
    });
  }
  return k && C.jsx(b, { id: w, registry: f, schema: t, uiSchema: n, label: k, onAddClick: E, onRemoveClick: _ });
}
const h4e = {
  array: "ArrayField",
  boolean: "BooleanField",
  integer: "NumberField",
  number: "NumberField",
  object: "ObjectField",
  string: "StringField",
  null: "NullField"
};
function g4e(e, t, n) {
  const r = t.field, { fields: a } = n;
  if (typeof r == "function")
    return r;
  if (typeof r == "string" && r in a)
    return a[r];
  const s = rl(e), l = Array.isArray(s) ? s[0] : s || "", c = e.$id;
  let d = h4e[l];
  return c && c in a && (d = c), !d && (e.anyOf || e.oneOf) ? () => null : d in a ? a[d] : a.FallbackField;
}
function v4e(e) {
  const { schema: t, fieldPathId: n, uiSchema: r, formData: a, errorSchema: s, name: l, onChange: c, onKeyRename: d, onKeyRenameBlur: f, onRemoveProperty: m, required: h = !1, registry: v, wasPropertyKeyModified: g = !1 } = e, { schemaUtils: b, globalFormOptions: x, globalUiOptions: w, fields: k } = v, { AnyOfField: E, OneOfField: _ } = k, O = vt(r, w), N = xt("FieldTemplate", v, O), A = xt("DescriptionFieldTemplate", v, O), R = xt("FieldHelpTemplate", v, O), D = xt("FieldErrorTemplate", v, O), I = b.retrieveSchema(t, a), z = n[Ln], B = M.useCallback((_e, Ge, Xe, tt) => c(_e, Ge, Xe, tt || z), [z, c]), P = g4e(I, O, v), H = !!(O.disabled ?? e.disabled), L = !!(O.readonly ?? (e.readonly || e.schema.readOnly || I.readOnly)), G = O.hideError, $ = G === void 0 ? e.hideError : !!G, K = !!(O.autofocus ?? e.autofocus);
  if (Object.keys(I).length === 0)
    return null;
  let q = b.getDisplayLabel(I, r, w);
  const Z = O.field && O.fieldReplacesAnyOrOneOf === !0;
  let V, F, Y = { fieldPathId: n };
  if ((dn in I || Kt in I) && !Z && !b.isSelect(I)) {
    I[dn] ? (V = E, F = I[dn].map((Xe) => b.retrieveSchema(mn(Xe) ? Xe : {}, a))) : I[Kt] && (V = _, F = I[Kt].map((Xe) => b.retrieveSchema(mn(Xe) ? Xe : {}, a)));
    const _e = Ek(v, I, h, r), Ge = Kg(a);
    q = q && (!_e || Ge), Y = {
      childFieldPathId: n,
      // The main FieldComponent will add `XxxOf` onto the fieldPathId to avoid duplication with the rendering of the
      // same FieldComponent by the `XxxOfField`
      fieldPathId: Yi("XxxOf", x, n)
    };
  }
  const { __errors: U, ...W } = s || {}, J = ES(r, ["ui:classNames", "classNames", "ui:style"]);
  wd in J && (J[wd] = ES(J[wd], ["classNames", "style"]));
  const oe = C.jsx(P, { ...e, onChange: B, ...Y, schema: I, uiSchema: J, disabled: H, readonly: L, hideError: $, autofocus: K, errorSchema: W, rawErrors: U }), fe = n[Ln];
  let ie;
  g ? ie = l : ie = Pc in I ? l : O.title || e.schema.title || I.title || e.title || l;
  const ce = O.description || e.schema.description || I.description || "", ge = O.help, re = O.widget === "hidden", le = ["rjsf-field", `rjsf-field-${rl(I)}`];
  !$ && U && U.length > 0 && le.push("rjsf-field-error"), O.classNames && le.push(O.classNames);
  const me = C.jsx(R, { help: ge, fieldPathId: n, schema: I, uiSchema: r, hasErrors: !$ && U && U.length > 0, registry: v }), ve = $ || V && !b.isSelect(I) ? void 0 : C.jsx(D, { errors: U, errorSchema: s, fieldPathId: n, schema: I, uiSchema: r, registry: v }), xe = {
    description: C.jsx(A, { id: ah(fe), description: ce, schema: I, uiSchema: r, registry: v }),
    rawDescription: ce,
    help: me,
    rawHelp: typeof ge == "string" ? ge : void 0,
    errors: ve,
    rawErrors: $ ? void 0 : U,
    id: fe,
    label: ie,
    hidden: re,
    onChange: c,
    onKeyRename: d,
    onKeyRenameBlur: f,
    onRemoveProperty: m,
    required: h,
    disabled: H,
    readonly: L,
    hideError: $,
    displayLabel: q,
    classNames: le.join(" ").trim(),
    style: O.style,
    formData: a,
    schema: I,
    uiSchema: r,
    registry: v
  };
  return C.jsx(N, { ...xe, children: C.jsxs(C.Fragment, { children: [oe, V && C.jsx(V, { name: l, disabled: H, readonly: L, hideError: $, errorSchema: s, formData: a, fieldPathId: n, onBlur: e.onBlur, onChange: e.onChange, onFocus: e.onFocus, options: F, registry: v, required: h, schema: I, uiSchema: r })] }) });
}
class y4e extends M.Component {
  shouldComponentUpdate(t) {
    const { registry: { globalFormOptions: n } } = this.props, { experimental_componentUpdateStrategy: r = "customDeep" } = n;
    return SK(this, t, this.state, r);
  }
  render() {
    return C.jsx(v4e, { ...this.props });
  }
}
function b4e(e) {
  const { schema: t, name: n, uiSchema: r, fieldPathId: a, formData: s, required: l, disabled: c = !1, readonly: d = !1, autofocus: f = !1, onChange: m, onBlur: h, onFocus: v, registry: g, rawErrors: b, hideError: x, title: w } = e, { title: k, format: E } = t, { widgets: _, schemaUtils: O, globalUiOptions: N } = g, A = O.isSelect(t) ? Ng(t, r) : void 0;
  let R = A ? "select" : "text";
  E && $5e(t, E, _) && (R = E);
  const { widget: D = R, placeholder: I = "", title: z, ...B } = vt(r), P = O.getDisplayLabel(t, r, N), H = z ?? w ?? k ?? n, L = ql(t, D, _), G = M.useCallback(($, K, q) => m($, a.path, K, q), [m, a]);
  return C.jsx(L, { options: { ...B, enumOptions: A }, schema: t, uiSchema: r, id: a.$id, name: n, label: H, hideLabel: !P, hideError: x, value: s, onChange: G, onBlur: h, onFocus: v, required: l, disabled: c, readonly: d, autofocus: f, registry: g, placeholder: I, rawErrors: b, htmlName: a.name });
}
function w4e(e) {
  const { formData: t, onChange: n, fieldPathId: r } = e;
  return M.useEffect(() => {
    t === void 0 && n(null, r.path);
  }, [r, t, n]), null;
}
function x4e() {
  return {
    AnyOfField: zL,
    ArrayField: N3e,
    // ArrayField falls back to SchemaField if ArraySchemaField is not defined, which it isn't by default
    BooleanField: A3e,
    FallbackField: D3e,
    LayoutGridField: cP,
    LayoutHeaderField: eRe,
    LayoutMultiSchemaField: tRe,
    NumberField: oRe,
    ObjectField: p4e,
    OneOfField: zL,
    OptionalDataControlsField: m4e,
    SchemaField: y4e,
    StringField: b4e,
    NullField: w4e
  };
}
function S4e(e) {
  const { fieldPathId: t, description: n, registry: r, schema: a, uiSchema: s } = e, l = vt(s, r.globalUiOptions), { label: c = !0 } = l;
  if (!n || !c)
    return null;
  const d = xt("DescriptionFieldTemplate", r, l);
  return C.jsx(d, { id: ah(t), description: n, schema: a, uiSchema: s, registry: r });
}
function k4e(e) {
  const { children: t, className: n, buttonsProps: r, displayLabel: a, hasDescription: s, hasToolbar: l, registry: c, uiSchema: d } = e, f = vt(d), m = xt("ArrayFieldItemButtonsTemplate", c, f), h = {
    flex: 1,
    paddingLeft: 6,
    paddingRight: 6,
    fontWeight: "bold"
  }, v = s ? 31 : 9, g = { display: "flex", alignItems: a ? "center" : "baseline" }, b = { display: "flex", justifyContent: "flex-end", marginTop: a ? `${v}px` : 0 };
  return C.jsxs("div", { className: n, style: g, children: [C.jsx("div", { className: l ? "col-xs-9 col-md-10 col-xl-11" : "col-xs-12", children: t }), l && C.jsx("div", { className: "col-xs-3 col-md-2 col-xl-1 array-item-toolbox", children: C.jsx("div", { className: "btn-group", style: b, children: C.jsx(m, { ...r, style: h }) }) })] });
}
function _4e(e) {
  const { disabled: t, hasCopy: n, hasMoveDown: r, hasMoveUp: a, hasRemove: s, fieldPathId: l, onCopyItem: c, onRemoveItem: d, onMoveDownItem: f, onMoveUpItem: m, readonly: h, registry: v, uiSchema: g } = e, { CopyButton: b, MoveDownButton: x, MoveUpButton: w, RemoveButton: k } = v.templates.ButtonTemplates;
  return C.jsxs(C.Fragment, { children: [(a || r) && C.jsx(w, { id: jl(l, "moveUp"), className: "rjsf-array-item-move-up", disabled: t || h || !a, onClick: m, uiSchema: g, registry: v }), (a || r) && C.jsx(x, { id: jl(l, "moveDown"), className: "rjsf-array-item-move-down", disabled: t || h || !r, onClick: f, uiSchema: g, registry: v }), n && C.jsx(b, { id: jl(l, "copy"), className: "rjsf-array-item-copy", disabled: t || h, onClick: c, uiSchema: g, registry: v }), s && C.jsx(k, { id: jl(l, "remove"), className: "rjsf-array-item-remove", disabled: t || h, onClick: d, uiSchema: g, registry: v })] });
}
function E4e(e) {
  const { canAdd: t, className: n, disabled: r, fieldPathId: a, uiSchema: s, items: l, optionalDataControl: c, onAddClick: d, readonly: f, registry: m, required: h, schema: v, title: g } = e, b = vt(s), x = xt("ArrayFieldDescriptionTemplate", m, b), w = xt("ArrayFieldTitleTemplate", m, b), k = !f && !r, { ButtonTemplates: { AddButton: E } } = m.templates;
  return C.jsxs("fieldset", { className: n, id: a.$id, children: [C.jsx(w, { fieldPathId: a, title: b.title || g, required: h, schema: v, uiSchema: s, registry: m, optionalDataControl: k ? c : void 0 }), C.jsx(x, { fieldPathId: a, description: b.description || v.description, schema: v, uiSchema: s, registry: m }), k ? void 0 : c, C.jsx("div", { className: "row array-item-list", children: l }), t && C.jsx(E, { id: jl(a, "add"), className: "rjsf-array-item-add", onClick: d, disabled: r || f, uiSchema: s, registry: m })] });
}
function C4e(e) {
  const { fieldPathId: t, title: n, schema: r, uiSchema: a, required: s, registry: l, optionalDataControl: c } = e, d = vt(a, l.globalUiOptions), { label: f = !0 } = d;
  if (!n || !f)
    return null;
  const m = xt("TitleFieldTemplate", l, d);
  return C.jsx(m, { id: OC(t), title: n, required: s, schema: r, uiSchema: a, registry: l, optionalDataControl: c });
}
function O4e(e) {
  const {
    id: t,
    name: n,
    // remove this from ...rest
    htmlName: r,
    value: a,
    readonly: s,
    disabled: l,
    autofocus: c,
    onBlur: d,
    onFocus: f,
    onChange: m,
    onChangeOverride: h,
    options: v,
    schema: g,
    uiSchema: b,
    registry: x,
    rawErrors: w,
    type: k,
    hideLabel: E,
    // remove this from ...rest
    hideError: _,
    // remove this from ...rest
    ...O
  } = e;
  if (!t)
    throw console.log("No id for", e), new Error(`no id for props ${JSON.stringify(e)}`);
  const N = {
    ...O,
    ...bK(g, k, v)
  };
  let A;
  N.type === "number" || N.type === "integer" ? A = a || a === 0 ? a : "" : A = a ?? "";
  const R = M.useCallback(({ target: { value: z } }) => m(z === "" ? v.emptyValue : z), [m, v]), D = M.useCallback(({ target: z }) => d(t, z && z.value), [d, t]), I = M.useCallback(({ target: z }) => f(t, z && z.value), [f, t]);
  return C.jsxs(C.Fragment, { children: [C.jsx("input", { id: t, name: r || t, className: "form-control", readOnly: s, disabled: l, autoFocus: c, value: A, ...N, list: g.examples ? AS(t) : void 0, onChange: h || R, onBlur: D, onFocus: I, "aria-describedby": ji(t, !!g.examples) }), Array.isArray(g.examples) && C.jsx("datalist", { id: AS(t), children: g.examples.concat(g.default && !g.examples.includes(g.default) ? [g.default] : []).map((z) => C.jsx("option", { value: z }, z)) }, `datalist_${t}`)] });
}
function M4e({ uiSchema: e }) {
  const { submitText: t, norender: n, props: r = {} } = wK(e);
  return n ? null : C.jsx("div", { children: C.jsx("button", { type: "submit", ...r, className: `btn btn-info ${r.className || ""}`, children: t }) });
}
function qm(e) {
  const { iconType: t = "default", icon: n, className: r, uiSchema: a, registry: s, ...l } = e;
  return C.jsx("button", { type: "button", className: `btn btn-${t} ${r}`, ...l, children: C.jsx("i", { className: `glyphicon glyphicon-${n}` }) });
}
function N4e(e) {
  const { registry: { translateString: t } } = e;
  return C.jsx(qm, { title: t(Jt.CopyButton), ...e, icon: "copy" });
}
function A4e(e) {
  const { registry: { translateString: t } } = e;
  return C.jsx(qm, { title: t(Jt.MoveDownButton), ...e, icon: "arrow-down" });
}
function R4e(e) {
  const { registry: { translateString: t } } = e;
  return C.jsx(qm, { title: t(Jt.MoveUpButton), ...e, icon: "arrow-up" });
}
function j4e(e) {
  const { registry: { translateString: t } } = e;
  return C.jsx(qm, { title: t(Jt.RemoveButton), ...e, iconType: "danger", icon: "remove" });
}
function P4e({ id: e, className: t, onClick: n, disabled: r, registry: a }) {
  const { translateString: s } = a;
  return C.jsx("div", { className: "row", children: C.jsx("p", { className: `col-xs-4 col-sm-2 col-lg-1 col-xs-offset-8 col-sm-offset-10 col-lg-offset-11 text-right ${t}`, children: C.jsx(qm, { id: e, iconType: "info", icon: "plus", className: "btn-add col-xs-12", title: s(Jt.AddButton), onClick: n, disabled: r, registry: a }) }) });
}
function D4e() {
  return {
    SubmitButton: M4e,
    AddButton: P4e,
    CopyButton: N4e,
    MoveDownButton: A4e,
    MoveUpButton: R4e,
    RemoveButton: j4e
  };
}
const GK = tP();
function mP({ description: e, registry: t, uiSchema: n = {} }) {
  const { globalUiOptions: r } = t;
  return vt(n, r).enableMarkdownInDescription && typeof e == "string" ? C.jsx(Ck, { options: { disableParsingRawHTML: !0 }, "data-testid": GK.markdown, children: e }) : e;
}
mP.TEST_IDS = GK;
function I4e(e) {
  const { id: t, description: n, registry: r, uiSchema: a } = e;
  return n ? C.jsx("div", { id: t, className: "field-description", children: C.jsx(mP, { description: n, registry: r, uiSchema: a }) }) : null;
}
function $4e({ errors: e, registry: t }) {
  const { translateString: n } = t;
  return C.jsxs("div", { className: "panel panel-danger errors", children: [C.jsx("div", { className: "panel-heading", children: C.jsx("h3", { className: "panel-title", children: n(Jt.ErrorsLabel) }) }), C.jsx("ul", { className: "list-group", children: e.map((r, a) => C.jsx("li", { className: "list-group-item text-danger", children: r.stack }, a)) })] });
}
function z4e(e) {
  const { schema: t, registry: n, typeSelector: r, schemaField: a } = e, s = xt("MultiSchemaFieldTemplate", n);
  return C.jsx(s, { selector: r, optionSchemaField: a, schema: t, registry: n });
}
const T4e = "*";
function KK(e) {
  const { label: t, required: n, id: r } = e;
  return t ? C.jsxs("label", { className: "control-label", htmlFor: r, children: [t, n && C.jsx("span", { className: "required", children: T4e })] }) : null;
}
function L4e(e) {
  const { id: t, label: n, children: r, errors: a, help: s, description: l, hidden: c, required: d, displayLabel: f, registry: m, uiSchema: h } = e, v = vt(h), g = xt("WrapIfAdditionalTemplate", m, v);
  if (c)
    return C.jsx("div", { className: "hidden", children: r });
  const b = v.widget === "checkbox";
  return C.jsxs(g, { ...e, children: [f && !b && C.jsx(KK, { label: n, required: d, id: t }), f && l ? l : null, r, a, s] });
}
function F4e(e) {
  const { errors: t = [], fieldPathId: n } = e;
  if (t.length === 0)
    return null;
  const r = nP(n);
  return C.jsx("div", { children: C.jsx("ul", { id: r, className: "error-detail bs-callout bs-callout-info", children: t.filter((a) => !!a).map((a, s) => C.jsx("li", { className: "text-danger", children: a }, s)) }) });
}
const YK = tP();
function hP({ help: e, registry: t, uiSchema: n = {} }) {
  const { globalUiOptions: r } = t;
  return vt(n, r).enableMarkdownInHelp && typeof e == "string" ? C.jsx(Ck, { options: { disableParsingRawHTML: !0 }, "data-testid": YK.markdown, children: e }) : e;
}
hP.TEST_IDS = YK;
function B4e(e) {
  const { fieldPathId: t, help: n, uiSchema: r, registry: a } = e;
  return n ? C.jsx("div", { id: rP(t), className: "help-block", children: C.jsx(hP, { help: n, registry: a, uiSchema: r }) }) : null;
}
function U4e(e) {
  const { children: t, column: n, className: r, ...a } = e;
  return C.jsx("div", { className: r, ...a, children: t });
}
function V4e(e) {
  const { selector: t, optionSchemaField: n } = e;
  return C.jsxs("div", { className: "panel panel-default panel-body", children: [C.jsx("div", { className: "form-group", children: t }), n] });
}
function H4e(e) {
  const { className: t, description: n, disabled: r, formData: a, fieldPathId: s, onAddProperty: l, optionalDataControl: c, properties: d, readonly: f, registry: m, required: h, schema: v, title: g, uiSchema: b } = e, x = vt(b), w = xt("TitleFieldTemplate", m, x), k = xt("DescriptionFieldTemplate", m, x), E = !f && !r, { ButtonTemplates: { AddButton: _ } } = m.templates;
  return C.jsxs("fieldset", { className: t, id: s.$id, children: [g && C.jsx(w, { id: OC(s), title: g, required: h, schema: v, uiSchema: b, registry: m, optionalDataControl: E ? c : void 0 }), n && C.jsx(k, { id: ah(s), description: n, schema: v, uiSchema: b, registry: m }), E ? void 0 : c, d.map((O) => O.content), rG(v, b, a) && C.jsx(_, { id: jl(s, "add"), className: "rjsf-object-property-expand", onClick: l, disabled: r || f, uiSchema: b, registry: m })] });
}
function W4e(e) {
  const { id: t, registry: n, label: r, onAddClick: a, onRemoveClick: s } = e;
  return a ? C.jsx(qm, { id: t, registry: n, icon: "plus", className: "rjsf-add-optional-data btn-sm", onClick: a, title: r }) : s ? C.jsx(qm, { id: t, registry: n, icon: "remove", className: "rjsf-remove-optional-data btn-sm", onClick: s, title: r }) : C.jsx("em", { id: t, children: r });
}
const q4e = "*";
function G4e(e) {
  const { id: t, title: n, required: r, optionalDataControl: a } = e;
  return C.jsxs("legend", { id: t, children: [n, r && C.jsx("span", { className: "required", children: q4e }), a && C.jsx("span", { className: "pull-right", style: { marginBottom: "2px" }, children: a })] });
}
function K4e(e) {
  const { schema: t, fieldPathId: n, reason: r, registry: a } = e, { translateString: s } = a;
  let l = Jt.UnsupportedField;
  const c = [];
  return n && n.$id && (l = Jt.UnsupportedFieldWithId, c.push(n.$id)), r && (l = l === Jt.UnsupportedField ? Jt.UnsupportedFieldWithReason : Jt.UnsupportedFieldWithIdAndReason, c.push(r)), C.jsxs("div", { className: "unsupported-field", children: [C.jsx("p", { children: C.jsx(Ck, { options: { disableParsingRawHTML: !0 }, children: s(l, c) }) }), t && C.jsx("pre", { children: JSON.stringify(t, null, 2) })] });
}
function Y4e(e) {
  const { id: t, classNames: n, style: r, disabled: a, displayLabel: s, label: l, onKeyRenameBlur: c, onRemoveProperty: d, rawDescription: f, readonly: m, required: h, schema: v, hideError: g, rawErrors: b, children: x, uiSchema: w, registry: k } = e, { templates: E, translateString: _ } = k, { RemoveButton: O } = E.ButtonTemplates, N = _(Jt.KeyLabel, [l]), A = Pc in v, R = !!f, D = ["form-group", n];
  !g && b && b.length > 0 && D.push("has-error has-danger");
  const I = D.join(" ").trim();
  if (!A)
    return C.jsx("div", { className: I, style: r, children: x });
  const z = R ? 46 : 26;
  return C.jsx("div", { className: I, style: r, children: C.jsxs("div", { className: "row", children: [C.jsx("div", { className: "col-xs-5 form-additional", children: C.jsxs("div", { className: "form-group", children: [s && C.jsx(KK, { label: N, required: h, id: `${t}-key` }), s && f && C.jsx("div", { children: "" }), C.jsx("input", { className: "form-control", type: "text", id: `${t}-key`, onBlur: c, defaultValue: l })] }) }), C.jsx("div", { className: "form-additional form-group col-xs-5", children: x }), C.jsx("div", { className: "col-xs-2", style: { marginTop: s ? `${z}px` : void 0 }, children: C.jsx(O, { id: jl(t, "remove"), className: "rjsf-object-property-remove btn-block", style: { border: "0" }, disabled: a || m, onClick: d, uiSchema: w, registry: k }) })] }) });
}
function X4e() {
  return {
    ArrayFieldDescriptionTemplate: S4e,
    ArrayFieldItemTemplate: k4e,
    ArrayFieldItemButtonsTemplate: _4e,
    ArrayFieldTemplate: E4e,
    ArrayFieldTitleTemplate: C4e,
    ButtonTemplates: D4e(),
    BaseInputTemplate: O4e,
    DescriptionFieldTemplate: I4e,
    ErrorListTemplate: $4e,
    FallbackFieldTemplate: z4e,
    FieldTemplate: L4e,
    FieldErrorTemplate: F4e,
    FieldHelpTemplate: B4e,
    GridTemplate: U4e,
    MultiSchemaFieldTemplate: V4e,
    ObjectFieldTemplate: H4e,
    OptionalDataControlsTemplate: W4e,
    TitleFieldTemplate: G4e,
    UnsupportedFieldTemplate: K4e,
    WrapIfAdditionalTemplate: Y4e
  };
}
function J4e(e) {
  const { disabled: t = !1, readonly: n = !1, autofocus: r = !1, options: a, id: s, name: l, registry: c, onBlur: d, onFocus: f } = e, { translateString: m } = c, { elements: h, handleChange: v, handleClear: g, handleSetNow: b } = V5e(e);
  return C.jsxs("ul", { className: "list-inline", children: [h.map((x, w) => C.jsx("li", { className: "list-inline-item", children: C.jsx(U5e, { rootId: s, name: l, select: v, ...x, disabled: t, readonly: n, registry: c, onBlur: d, onFocus: f, autofocus: r && w === 0 }) }, w)), (a.hideNowButton !== "undefined" ? !a.hideNowButton : !0) && C.jsx("li", { className: "list-inline-item", children: C.jsx("a", { href: "#", className: "btn btn-info btn-now", onClick: b, children: m(Jt.NowLabel) }) }), (a.hideClearButton !== "undefined" ? !a.hideClearButton : !0) && C.jsx("li", { className: "list-inline-item", children: C.jsx("a", { href: "#", className: "btn btn-warning btn-clear", onClick: g, children: m(Jt.ClearLabel) }) })] });
}
function Q4e({ time: e = !0, ...t }) {
  const { AltDateWidget: n } = t.registry.widgets;
  return C.jsx(n, { time: e, ...t });
}
function Z4e({ schema: e, uiSchema: t, options: n, id: r, value: a, disabled: s, readonly: l, label: c, hideLabel: d, autofocus: f = !1, onBlur: m, onFocus: h, onChange: v, registry: g, htmlName: b }) {
  const x = xt("DescriptionFieldTemplate", g, n), w = Lx(e), k = M.useCallback((N) => v(N.target.checked), [v]), E = M.useCallback((N) => m(r, N.target.checked), [m, r]), _ = M.useCallback((N) => h(r, N.target.checked), [h, r]), O = vt(t).widget === "checkbox" ? void 0 : n.description ?? e.description;
  return C.jsxs("div", { className: `checkbox ${s || l ? "disabled" : ""}`, children: [!d && O && C.jsx(x, { id: ah(r), description: O, schema: e, uiSchema: t, registry: g }), C.jsxs("label", { children: [C.jsx("input", { type: "checkbox", id: r, name: b || r, checked: typeof a > "u" ? !1 : a, required: w, disabled: s || l, autoFocus: f, onChange: k, onBlur: E, onFocus: _, "aria-describedby": ji(r) }), ih(C.jsx("span", { children: c }), d)] })] });
}
function eje({ id: e, disabled: t, options: { inline: n = !1, enumOptions: r, enumDisabled: a, emptyValue: s }, value: l, autofocus: c = !1, readonly: d, onChange: f, onBlur: m, onFocus: h, htmlName: v }) {
  const g = Array.isArray(l) ? l : [l], b = M.useCallback(({ target: w }) => m(e, ao(w && w.value, r, s)), [m, e, r, s]), x = M.useCallback(({ target: w }) => h(e, ao(w && w.value, r, s)), [h, e, r, s]);
  return C.jsx("div", { className: "checkboxes", id: e, children: Array.isArray(r) && r.map((w, k) => {
    const E = CC(w.value, g), _ = Array.isArray(a) && a.indexOf(w.value) !== -1, O = t || _ || d ? "disabled" : "", N = (R) => {
      R.target.checked ? f(hK(k, g, r)) : f(mK(k, g, r));
    }, A = C.jsxs("span", { children: [C.jsx("input", { type: "checkbox", id: MC(e, k), name: v || e, checked: E, value: String(k), disabled: t || _ || d, autoFocus: c && k === 0, onChange: N, onBlur: b, onFocus: x, "aria-describedby": ji(e) }), C.jsx("span", { children: w.label })] });
    return n ? C.jsx("label", { className: `checkbox-inline ${O}`, children: A }, k) : C.jsx("div", { className: `checkbox ${O}`, children: C.jsx("label", { children: A }) }, k);
  }) });
}
function tje(e) {
  const { disabled: t, readonly: n, options: r, registry: a } = e, s = xt("BaseInputTemplate", a, r);
  return C.jsx(s, { type: "color", ...e, disabled: t || n });
}
function nje(e) {
  const { onChange: t, options: n, registry: r } = e, a = xt("BaseInputTemplate", r, n), s = M.useCallback((l) => t(l || void 0), [t]);
  return C.jsx(a, { type: "date", ...e, onChange: s });
}
function rje(e) {
  const { onChange: t, value: n, options: r, registry: a } = e, s = xt("BaseInputTemplate", a, r);
  return C.jsx(s, { type: "datetime-local", ...e, value: K5e(n), onChange: (l) => t(T5e(l)) });
}
function oje(e) {
  const { options: t, registry: n } = e, r = xt("BaseInputTemplate", n, t);
  return C.jsx(r, { type: "email", ...e });
}
function aje({ fileInfo: e, registry: t }) {
  const { translateString: n } = t, { dataURL: r, type: a, name: s } = e;
  return r ? ["image/jpeg", "image/png"].includes(a) ? C.jsx("img", { src: r, style: { maxWidth: "100%" }, className: "file-preview" }) : C.jsxs(C.Fragment, { children: [" ", C.jsx("a", { download: `preview-${s}`, href: r, className: "file-download", children: n(Jt.PreviewLabel) })] }) : null;
}
function ije({ filesInfo: e, registry: t, preview: n, onRemove: r, options: a }) {
  if (e.length === 0)
    return null;
  const { translateString: s } = t, { RemoveButton: l } = xt("ButtonTemplates", t, a);
  return C.jsx("ul", { className: "file-info", children: e.map((c, d) => {
    const { name: f, size: m, type: h } = c, v = () => r(d);
    return C.jsxs("li", { children: [C.jsx(Ck, { children: s(Jt.FilesInfo, [f, h, String(m)]) }), n && C.jsx(aje, { fileInfo: c, registry: t }), C.jsx(l, { onClick: v, registry: t })] }, d);
  }) });
}
function sje(e) {
  const { disabled: t, readonly: n, required: r, multiple: a, onChange: s, value: l, options: c, registry: d } = e, { filesInfo: f, handleChange: m, handleRemove: h } = G5e(l, s, a), v = xt("BaseInputTemplate", d, c), g = (b) => {
    b.target.files && m(b.target.files);
  };
  return C.jsxs("div", { children: [C.jsx(v, { ...e, disabled: t || n, type: "file", required: l ? !1 : r, onChangeOverride: g, value: "", accept: c.accept ? String(c.accept) : void 0 }), C.jsx(ije, { filesInfo: f, onRemove: h, registry: d, preview: c.filePreview, options: c })] });
}
function lje({ id: e, value: t, htmlName: n }) {
  return C.jsx("input", { type: "hidden", id: e, name: n || e, value: typeof t > "u" ? "" : t });
}
function uje(e) {
  const { options: t, registry: n } = e, r = xt("BaseInputTemplate", n, t);
  return C.jsx(r, { type: "password", ...e });
}
function cje({ options: e, value: t, required: n, disabled: r, readonly: a, autofocus: s = !1, onBlur: l, onFocus: c, onChange: d, id: f, htmlName: m }) {
  const { enumOptions: h, enumDisabled: v, inline: g, emptyValue: b } = e, x = M.useCallback(({ target: k }) => l(f, ao(k && k.value, h, b)), [l, h, b, f]), w = M.useCallback(({ target: k }) => c(f, ao(k && k.value, h, b)), [c, h, b, f]);
  return C.jsx("div", { className: "field-radio-group", id: f, role: "radiogroup", children: Array.isArray(h) && h.map((k, E) => {
    const _ = CC(k.value, t), O = Array.isArray(v) && v.indexOf(k.value) !== -1, N = r || O || a ? "disabled" : "", A = () => d(k.value), R = C.jsxs("span", { children: [C.jsx("input", { type: "radio", id: MC(f, E), checked: _, name: m || f, required: n, value: String(E), disabled: r || O || a, autoFocus: s && E === 0, onChange: A, onBlur: x, onFocus: w, "aria-describedby": ji(f) }), C.jsx("span", { children: k.label })] });
    return g ? C.jsx("label", { className: `radio-inline ${N}`, children: R }, E) : C.jsx("div", { className: `radio ${N}`, children: C.jsx("label", { children: R }) }, E);
  }) });
}
function dje(e) {
  const { value: t, registry: { templates: { BaseInputTemplate: n } } } = e;
  return C.jsxs("div", { className: "field-range-wrapper", children: [C.jsx(n, { type: "range", ...e }), C.jsx("span", { className: "range-view", children: t })] });
}
function fje({ id: e, value: t, required: n, disabled: r, readonly: a, autofocus: s, onChange: l, onFocus: c, onBlur: d, schema: f, options: m, htmlName: h }) {
  const { stars: v = 5, shape: g = "star" } = m, b = f.maximum ? Math.min(f.maximum, 5) : Math.min(Math.max(v, 1), 5), x = f.minimum || 0, w = M.useCallback((O) => {
    !r && !a && l(O);
  }, [l, r, a]), k = M.useCallback((O) => {
    if (c) {
      const N = Number(O.target.dataset.value);
      c(e, N);
    }
  }, [c, e]), E = M.useCallback((O) => {
    if (d) {
      const N = Number(O.target.dataset.value);
      d(e, N);
    }
  }, [d, e]), _ = (O) => g === "heart" ? O ? "" : "" : O ? "" : "";
  return C.jsx(C.Fragment, { children: C.jsxs("div", { className: "rating-widget", style: {
    display: "inline-flex",
    fontSize: "1.5rem",
    cursor: r || a ? "default" : "pointer"
  }, children: [[...Array(b)].map((O, N) => {
    const A = x + N, R = A <= t;
    return C.jsx("span", { onClick: () => w(A), onFocus: k, onBlur: E, "data-value": A, tabIndex: r || a ? -1 : 0, role: "radio", "aria-checked": A === t, "aria-label": `${A} ${g === "heart" ? "heart" : "star"}${A === 1 ? "" : "s"}`, style: {
      color: R ? "#FFD700" : "#ccc",
      padding: "0 0.2rem",
      transition: "color 0.2s",
      userSelect: "none"
    }, children: _(R) }, N);
  }), C.jsx("input", { type: "hidden", id: e, name: h || e, value: t || "", required: n, disabled: r || a, "aria-hidden": "true" })] }) });
}
function B5(e, t) {
  return t ? Array.from(e.target.options).slice().filter((n) => n.selected).map((n) => n.value) : e.target.value;
}
function pje({ schema: e, id: t, options: n, value: r, required: a, disabled: s, readonly: l, multiple: c = !1, autofocus: d = !1, onChange: f, onBlur: m, onFocus: h, placeholder: v, htmlName: g }) {
  const { enumOptions: b, enumDisabled: x, emptyValue: w } = n, k = c ? [] : "", E = M.useCallback((R) => {
    const D = B5(R, c);
    return h(t, ao(D, b, w));
  }, [h, t, c, b, w]), _ = M.useCallback((R) => {
    const D = B5(R, c);
    return m(t, ao(D, b, w));
  }, [m, t, c, b, w]), O = M.useCallback((R) => {
    const D = B5(R, c);
    return f(ao(D, b, w));
  }, [f, c, b, w]), N = Zj(r, b, c), A = !c && e.default === void 0;
  return C.jsxs("select", { id: t, name: g || t, multiple: c, role: "combobox", className: "form-control", value: typeof N > "u" ? k : N, required: a, disabled: s || l, autoFocus: d, onBlur: _, onFocus: E, onChange: O, "aria-describedby": ji(t), children: [A && C.jsx("option", { value: "", children: v }), Array.isArray(b) && b.map(({ value: R, label: D }, I) => {
    const z = x && x.indexOf(R) !== -1;
    return C.jsx("option", { value: String(I), disabled: z, children: D }, I);
  })] });
}
function XK({ id: e, options: t = {}, placeholder: n, value: r, required: a, disabled: s, readonly: l, autofocus: c = !1, onChange: d, onBlur: f, onFocus: m, htmlName: h }) {
  const v = M.useCallback(({ target: { value: x } }) => d(x === "" ? t.emptyValue : x), [d, t.emptyValue]), g = M.useCallback(({ target: x }) => f(e, x && x.value), [f, e]), b = M.useCallback(({ target: x }) => m(e, x && x.value), [e, m]);
  return C.jsx("textarea", { id: e, name: h || e, className: "form-control", value: r || "", placeholder: n, required: a, disabled: s, readOnly: l, autoFocus: c, rows: t.rows, onBlur: g, onFocus: b, onChange: v, "aria-describedby": ji(e) });
}
XK.defaultProps = {
  autofocus: !1,
  options: {}
};
function mje(e) {
  const { options: t, registry: n } = e, r = xt("BaseInputTemplate", n, t);
  return C.jsx(r, { ...e });
}
function hje(e) {
  const { onChange: t, options: n, registry: r } = e, a = xt("BaseInputTemplate", r, n), s = M.useCallback((l) => t(l ? `${l}:00` : void 0), [t]);
  return C.jsx(a, { type: "time", ...e, onChange: s });
}
function gje(e) {
  const { options: t, registry: n } = e, r = xt("BaseInputTemplate", n, t);
  return C.jsx(r, { type: "url", ...e });
}
function vje(e) {
  const { options: t, registry: n } = e, r = xt("BaseInputTemplate", n, t);
  return C.jsx(r, { type: "number", ...e });
}
function yje() {
  return {
    AltDateWidget: J4e,
    AltDateTimeWidget: Q4e,
    CheckboxWidget: Z4e,
    CheckboxesWidget: eje,
    ColorWidget: tje,
    DateWidget: nje,
    DateTimeWidget: rje,
    EmailWidget: oje,
    FileWidget: sje,
    HiddenWidget: lje,
    PasswordWidget: uje,
    RadioWidget: cje,
    RangeWidget: dje,
    RatingWidget: fje,
    SelectWidget: pje,
    TextWidget: mje,
    TextareaWidget: XK,
    TimeWidget: hje,
    UpDownWidget: vje,
    URLWidget: gje
  };
}
function bje() {
  return {
    fields: x4e(),
    templates: X4e(),
    widgets: yje(),
    rootSchema: {},
    formContext: {},
    translateString: b5e,
    globalFormOptions: {
      idPrefix: eG,
      idSeparator: tG,
      useFallbackUiForUnsupportedType: !1
    }
  };
}
function Nh(e, t) {
  return {
    ...jK(e, ["schema", "uiSchema", "fieldPathId", "schemaUtils", "formData", "edit", "errors", "errorSchema"]),
    ...t !== void 0 && { status: t }
  };
}
let wje = class extends M.Component {
  /** Constructs the `Form` from the `props`. Will setup the initial state from the props. It will also call the
   * `onChange` handler if the initially provided `formData` is modified to add missing default values as part of the
   * state construction.
   *
   * @param props - The initial props for the `Form`
   */
  constructor(t) {
    super(t);
    /** The ref used to hold the `form` element, this needs to be `any` because `tagName` or `_internalFormWrapper` can
     * provide any possible type here
     */
    no(this, "formElement");
    /** The list of pending changes
     */
    no(this, "pendingChanges", []);
    /** Returns the `formData` with only the elements specified in the `fields` list
     *
     * @param formData - The data for the `Form`
     * @param fields - The fields to keep while filtering
     */
    no(this, "getUsedFormData", (t, n) => {
      if (n.length === 0 && typeof t != "object")
        return t;
      const r = jK(t, n);
      return Array.isArray(t) ? Object.keys(r).map((a) => r[a]) : r;
    });
    /** Returns the list of field names from inspecting the `pathSchema` as well as using the `formData`
     *
     * @param pathSchema - The `PathSchema` object for the form
     * @param [formData] - The form data to use while checking for empty objects/arrays
     */
    no(this, "getFieldNames", (t, n) => {
      const r = (s, l) => typeof s != "object" || $r(s) || l && !$r(s), a = (s, l = [], c = [[]]) => {
        const d = Object.keys(s);
        return d.forEach((f) => {
          const m = s[f];
          if (typeof m == "object") {
            const h = c.map((v) => [...v, f]);
            m[Mj] && m[V_] !== "" ? l.push(m[V_]) : a(m, l, h);
          } else f === V_ && m !== "" && c.forEach((h) => {
            const v = Re(n, h), g = d.length === 1;
            (r(v, g) || Array.isArray(v) && v.every((b) => r(b, g))) && l.push(h);
          });
        }), l;
      };
      return a(t);
    });
    /** Returns the `formData` after filtering to remove any extra data not in a form field
     *
     * @param formData - The data for the `Form`
     * @returns The `formData` after omitting extra data
     */
    no(this, "omitExtraData", (t) => {
      const { schema: n, schemaUtils: r } = this.state, a = r.retrieveSchema(n, t), s = r.toPathSchema(a, "", t), l = this.getFieldNames(s, t);
      return this.getUsedFormData(t, l);
    });
    /** Allows a user to set a value for the provided `fieldPath`, which must be either a dotted path to the field OR a
     * `FieldPathList`. To set the root element, used either `''` or `[]` for the path. Passing undefined will clear the
     * value in the field.
     *
     * @param fieldPath - Either a dotted path to the field or the `FieldPathList` to the field
     * @param [newValue] - The new value for the field
     */
    no(this, "setFieldValue", (t, n) => {
      const { registry: r } = this.state, a = Array.isArray(t) ? t : t.split("."), s = Yi("", r.globalFormOptions, a);
      this.onChange(n, a, void 0, s[Ln]);
    });
    /** Pushes the given change information into the `pendingChanges` array and then calls `processPendingChanges()` if
     * the array only contains a single pending change.
     *
     * @param newValue - The new form data from a change to a field
     * @param path - The path to the change into which to set the formData
     * @param [newErrorSchema] - The new `ErrorSchema` based on the field change
     * @param [id] - The id of the field that caused the change
     */
    no(this, "onChange", (t, n, r, a) => {
      this.pendingChanges.push({ newValue: t, path: n, newErrorSchema: r, id: a }), this.pendingChanges.length === 1 && this.processPendingChange();
    });
    /**
     * Callback function to handle reset form data.
     * - Reset all fields with default values.
     * - Reset validations and errors
     *
     */
    no(this, "reset", () => {
      const { formData: t, initialFormData: n = t9, onChange: r } = this.props, a = {
        formData: this.getStateFromProps(this.props, t ?? n, void 0, void 0, void 0, !0).formData,
        errorSchema: {},
        errors: [],
        schemaValidationErrors: [],
        schemaValidationErrorSchema: {},
        initialDefaultsGenerated: !1,
        customErrors: void 0
      };
      this.setState(a, () => r && r(Nh({ ...this.state, ...a })));
    });
    /** Callback function to handle when a field on the form is blurred. Calls the `onBlur` callback for the `Form` if it
     * was provided. Also runs any live validation and/or live omit operations if the flags indicate they should happen
     * during `onBlur`.
     *
     * @param id - The unique `id` of the field that was blurred
     * @param data - The data associated with the field that was blurred
     */
    no(this, "onBlur", (t, n) => {
      const { onBlur: r, omitExtraData: a, liveOmit: s, liveValidate: l } = this.props;
      if (r && r(t, n), a === !0 && s === "onBlur" || l === "onBlur") {
        const { onChange: c, extraErrors: d } = this.props, { formData: f } = this.state;
        let m = f, h = { formData: m };
        if (a === !0 && s === "onBlur" && (m = this.omitExtraData(f), h = { formData: m }), l === "onBlur") {
          const { schema: g, schemaUtils: b, errorSchema: x, customErrors: w, retrievedSchema: k } = this.state, E = this.liveValidate(g, b, x, m, d, w, k);
          h = { formData: m, ...E, customErrors: w };
        }
        const v = Object.keys(h).filter((g) => !g.startsWith("schemaValidation")).some((g) => {
          const b = Re(this.state, g), x = Re(h, g);
          return !er(b, x);
        });
        this.setState(h, () => {
          c && v && c(Nh({ ...this.state, ...h }), t);
        });
      }
    });
    /** Callback function to handle when a field on the form is focused. Calls the `onFocus` callback for the `Form` if it
     * was provided.
     *
     * @param id - The unique `id` of the field that was focused
     * @param data - The data associated with the field that was focused
     */
    no(this, "onFocus", (t, n) => {
      const { onFocus: r } = this.props;
      r && r(t, n);
    });
    /** Callback function to handle when the form is submitted. First, it prevents the default event behavior. Nothing
     * happens if the target and currentTarget of the event are not the same. It will omit any extra data in the
     * `formData` in the state if `omitExtraData` is true. It will validate the resulting `formData`, reporting errors
     * via the `onError()` callback unless validation is disabled. Finally, it will add in any `extraErrors` and then call
     * back the `onSubmit` callback if it was provided.
     *
     * @param event - The submit HTML form event
     */
    no(this, "onSubmit", (t) => {
      if (t.preventDefault(), t.target !== t.currentTarget)
        return;
      t.persist();
      const { omitExtraData: n, extraErrors: r, noValidate: a, onSubmit: s } = this.props;
      let { formData: l } = this.state;
      if (n === !0 && (l = this.omitExtraData(l)), a || this.validateFormWithFormData(l)) {
        const c = r || {}, d = r ? aP(r) : [];
        this.setState({
          formData: l,
          errors: d,
          errorSchema: c,
          schemaValidationErrors: [],
          schemaValidationErrorSchema: {}
        }, () => {
          s && s(Nh({ ...this.state, formData: l }, "submitted"), t);
        });
      }
    });
    /** Provides a function that can be used to programmatically submit the `Form` */
    no(this, "submit", () => {
      if (this.formElement.current) {
        const t = new CustomEvent("submit", {
          cancelable: !0
        });
        t.preventDefault(), this.formElement.current.dispatchEvent(t), this.formElement.current.requestSubmit();
      }
    });
    /** Validates the form using the given `formData`. For use on form submission or on programmatic validation.
     * If `onError` is provided, then it will be called with the list of errors.
     *
     * @param formData - The form data to validate
     * @returns - True if the form is valid, false otherwise.
     */
    no(this, "validateFormWithFormData", (t) => {
      const { extraErrors: n, extraErrorsBlockSubmit: r, focusOnFirstError: a, onError: s } = this.props, { errors: l } = this.state, c = this.validate(t);
      let d = c.errors, f = c.errorSchema;
      const m = d, h = f, v = d.length > 0 || n && r;
      if (v) {
        if (n) {
          const g = K_(c, n);
          f = g.errorSchema, d = g.errors;
        }
        a && (typeof a == "function" ? a(d[0]) : this.focusOnError(d[0])), this.setState({
          errors: d,
          errorSchema: f,
          schemaValidationErrors: m,
          schemaValidationErrorSchema: h
        }, () => {
          s ? s(d) : console.error("Form validation failed", d);
        });
      } else l.length > 0 && this.setState({
        errors: [],
        errorSchema: {},
        schemaValidationErrors: [],
        schemaValidationErrorSchema: {}
      });
      return !v;
    });
    if (!t.validator)
      throw new Error("A validator is required for Form functionality to work");
    const { formData: n, initialFormData: r, onChange: a } = t, s = n ?? r;
    this.state = this.getStateFromProps(t, s, void 0, void 0, void 0, !0), a && !er(this.state.formData, s) && a(Nh(this.state)), this.formElement = M.createRef();
  }
  /**
   * `getSnapshotBeforeUpdate` is a React lifecycle method that is invoked right before the most recently rendered
   * output is committed to the DOM. It enables your component to capture current values (e.g., scroll position) before
   * they are potentially changed.
   *
   * In this case, it checks if the props have changed since the last render. If they have, it computes the next state
   * of the component using `getStateFromProps` method and returns it along with a `shouldUpdate` flag set to `true` IF
   * the `nextState` and `prevState` are different, otherwise `false`. This ensures that we have the most up-to-date
   * state ready to be applied in `componentDidUpdate`.
   *
   * If `formData` hasn't changed, it simply returns an object with `shouldUpdate` set to `false`, indicating that a
   * state update is not necessary.
   *
   * @param prevProps - The previous set of props before the update.
   * @param prevState - The previous state before the update.
   * @returns Either an object containing the next state and a flag indicating that an update should occur, or an object
   *        with a flag indicating that an update is not necessary.
   */
  getSnapshotBeforeUpdate(t, n) {
    if (!er(this.props, t)) {
      const r = Yz(this.props.formData, t.formData), a = Yz(this.props.formData, this.state.formData), s = !er(t.schema, this.props.schema), l = r.length > 0 || !er(t.formData, this.props.formData), c = a.length > 0 || !er(this.state.formData, this.props.formData), d = this.getStateFromProps(
        this.props,
        this.props.formData,
        // If the `schema` has changed, we need to update the retrieved schema.
        // Or if the `formData` changes, for example in the case of a schema with dependencies that need to
        //  match one of the subSchemas, the retrieved schema must be updated.
        s || l ? void 0 : this.state.retrievedSchema,
        s,
        r,
        // Skip live validation for this request if no form data has changed from the last state
        !c
      ), f = !er(d, n);
      return { nextState: d, shouldUpdate: f };
    }
    return { shouldUpdate: !1 };
  }
  /**
   * `componentDidUpdate` is a React lifecycle method that is invoked immediately after updating occurs. This method is
   * not called for the initial render.
   *
   * Here, it checks if an update is necessary based on the `shouldUpdate` flag received from `getSnapshotBeforeUpdate`.
   * If an update is required, it applies the next state and, if needed, triggers the `onChange` handler to inform about
   * changes.
   *
   * @param _ - The previous set of props.
   * @param prevState - The previous state of the component before the update.
   * @param snapshot - The value returned from `getSnapshotBeforeUpdate`.
   */
  componentDidUpdate(t, n, r) {
    if (r.shouldUpdate) {
      const { nextState: a } = r;
      !er(a.formData, this.props.formData) && !er(a.formData, n.formData) && this.props.onChange && this.props.onChange(Nh(a)), this.setState(a);
    }
  }
  /** Extracts the updated state from the given `props` and `inputFormData`. As part of this process, the
   * `inputFormData` is first processed to add any missing required defaults. After that, the data is run through the
   * validation process IF required by the `props`.
   *
   * @param props - The props passed to the `Form`
   * @param inputFormData - The new or current data for the `Form`
   * @param retrievedSchema - An expanded schema, if not provided, it will be retrieved from the `schema` and `formData`.
   * @param isSchemaChanged - A flag indicating whether the schema has changed.
   * @param formDataChangedFields - The changed fields of `formData`
   * @param skipLiveValidate - Optional flag, if true, means that we are not running live validation
   * @returns - The new state for the `Form`
   */
  getStateFromProps(t, n, r, a = !1, s = [], l = !1) {
    const c = this.state || {}, d = "schema" in t ? t.schema : this.props.schema, f = "validator" in t ? t.validator : this.props.validator, m = ("uiSchema" in t ? t.uiSchema : this.props.uiSchema) || {}, h = t.formData === void 0 && this.props.formData === void 0, v = typeof n < "u", g = "liveValidate" in t ? t.liveValidate : this.props.liveValidate, b = v && !t.noValidate && g, x = "experimental_defaultFormStateBehavior" in t ? t.experimental_defaultFormStateBehavior : this.props.experimental_defaultFormStateBehavior, w = "experimental_customMergeAllOf" in t ? t.experimental_customMergeAllOf : this.props.experimental_customMergeAllOf;
    let k = c.schemaUtils;
    (!k || k.doesSchemaUtilsDiffer(f, d, x, w)) && (k = g5e(f, d, x, w));
    const E = k.getRootSchema();
    let _ = n;
    n === t9 ? _ = void 0 : n === void 0 && h && (_ = c.formData);
    const O = k.getDefaultFormState(E, _, !1, c.initialDefaultsGenerated), N = this.updateRetrievedSchema(r ?? k.retrieveSchema(E, O)), A = () => t.noValidate || a ? { errors: [], errorSchema: {} } : t.liveValidate ? {
      errors: c.errors || [],
      errorSchema: c.errorSchema || {}
    } : {
      errors: c.schemaValidationErrors || [],
      errorSchema: c.schemaValidationErrorSchema || {}
    };
    let R, D, I = c.schemaValidationErrors, z = c.schemaValidationErrorSchema;
    if (b && !l) {
      const L = this.liveValidate(
        E,
        k,
        c.errorSchema,
        O,
        void 0,
        c.customErrors,
        r,
        // If retrievedSchema is undefined which means the schema or formData has changed, we do not merge state.
        // Else in the case where it hasn't changed,
        r !== void 0
      );
      R = L.errors, D = L.errorSchema, I = L.schemaValidationErrors, z = L.schemaValidationErrorSchema;
    } else {
      const L = A();
      if (R = L.errors, D = L.errorSchema, s.length > 0 && !b) {
        const $ = s.reduce((K, q) => (K[q] = void 0, K), {});
        D = z = NS(L.errorSchema, $, "preventDuplicates");
      }
      const G = this.mergeErrors({ errorSchema: D, errors: R }, t.extraErrors, c.customErrors);
      R = G.errors, D = G.errorSchema;
    }
    const B = this.getRegistry(t, E, k), P = er(c.registry, B) ? c.registry : B, H = c.fieldPathId && c.fieldPathId?.[Ln] === P.globalFormOptions.idPrefix ? c.fieldPathId : Yi("", P.globalFormOptions);
    return {
      schemaUtils: k,
      schema: E,
      uiSchema: m,
      fieldPathId: H,
      formData: O,
      edit: v,
      errors: R,
      errorSchema: D,
      schemaValidationErrors: I,
      schemaValidationErrorSchema: z,
      retrievedSchema: N,
      initialDefaultsGenerated: !0,
      registry: P
    };
  }
  /** React lifecycle method that is used to determine whether component should be updated.
   *
   * @param nextProps - The next version of the props
   * @param nextState - The next version of the state
   * @returns - True if the component should be updated, false otherwise
   */
  shouldComponentUpdate(t, n) {
    const { experimental_componentUpdateStrategy: r = "customDeep" } = this.props;
    return SK(this, t, n, r);
  }
  /** Validates the `formData` against the `schema` using the `altSchemaUtils` (if provided otherwise it uses the
   * `schemaUtils` in the state), returning the results.
   *
   * @param formData - The new form data to validate
   * @param schema - The schema used to validate against
   * @param [altSchemaUtils] - The alternate schemaUtils to use for validation
   * @param [retrievedSchema] - An optionally retrieved schema for per
   */
  validate(t, n = this.state.schema, r, a) {
    const s = r || this.state.schemaUtils, { customValidate: l, transformErrors: c, uiSchema: d } = this.props, f = a ?? s.retrieveSchema(n, t);
    return s.getValidator().validateFormData(t, f, l, c, d);
  }
  /** Renders any errors contained in the `state` in using the `ErrorList`, if not disabled by `showErrorList`. */
  renderErrors(t) {
    const { errors: n, errorSchema: r, schema: a, uiSchema: s } = this.state, l = vt(s), c = xt("ErrorListTemplate", t, l);
    return n && n.length ? C.jsx(c, { errors: n, errorSchema: r || {}, schema: a, uiSchema: s, registry: t }) : null;
  }
  /** Merges any `extraErrors` or `customErrors` into the given `schemaValidation` object, returning the result
   *
   * @param schemaValidation - The `ValidationData` object into which additional errors are merged
   * @param [extraErrors] - The extra errors from the props
   * @param [customErrors] - The customErrors from custom components
   * @return - The `extraErrors` and `customErrors` merged into the `schemaValidation`
   * @private
   */
  mergeErrors(t, n, r) {
    let a = t.errorSchema, s = t.errors;
    if (n) {
      const l = K_(t, n);
      a = l.errorSchema, s = l.errors;
    }
    if (r) {
      const l = K_(t, r.ErrorSchema, !0);
      a = l.errorSchema, s = l.errors;
    }
    return { errors: s, errorSchema: a };
  }
  /** Performs live validation and then updates and returns the errors and error schemas by potentially merging in
   * `extraErrors` and `customErrors`.
   *
   * @param rootSchema - The `rootSchema` from the state
   * @param schemaUtils - The `SchemaUtilsType` from the state
   * @param originalErrorSchema - The original `ErrorSchema` from the state
   * @param [formData] - The new form data to validate
   * @param [extraErrors] - The extra errors from the props
   * @param [customErrors] - The customErrors from custom components
   * @param [retrievedSchema] - An expanded schema, if not provided, it will be retrieved from the `schema` and `formData`
   * @param [mergeIntoOriginalErrorSchema=false] - Optional flag indicating whether we merge into original schema
   * @returns - An object containing `errorSchema`, `errors`, `schemaValidationErrors` and `schemaValidationErrorSchema`
   * @private
   */
  liveValidate(t, n, r, a, s, l, c, d = !1) {
    const f = this.validate(a, t, n, c), m = f.errors;
    let h = f.errorSchema;
    d && (h = NS(r, f.errorSchema, "preventDuplicates"));
    const v = m, g = h;
    return { ...this.mergeErrors({ errorSchema: h, errors: m }, s, l), schemaValidationErrors: v, schemaValidationErrorSchema: g };
  }
  /** Function to handle changes made to a field in the `Form`. This handler gets the first change from the
   * `pendingChanges` list, containing the `newValue` for the `formData` and the `path` at which the `newValue` is to be
   * updated, along with a new, optional `ErrorSchema` for that same `path` and potentially the `id` of the field being
   * changed. It will first update the `formData` with any missing default fields and then, if `omitExtraData` and
   * `liveOmit` are turned on, the `formData` will be filtered to remove any extra data not in a form field. Then, the
   * resulting `formData` will be validated if required. The state will be updated with the new updated (potentially
   * filtered) `formData`, any errors that resulted from validation. Finally the `onChange` callback will be called, if
   * specified, with the updated state and the `processPendingChange()` function is called again.
   */
  processPendingChange() {
    if (this.pendingChanges.length === 0)
      return;
    const { newValue: t, path: n, id: r } = this.pendingChanges[0], { newErrorSchema: a } = this.pendingChanges[0], { extraErrors: s, omitExtraData: l, liveOmit: c, noValidate: d, liveValidate: f, onChange: m } = this.props, { formData: h, schemaUtils: v, schema: g, fieldPathId: b, schemaValidationErrorSchema: x, errors: w } = this.state;
    let { customErrors: k, errorSchema: E } = this.state;
    const _ = b.path[0] || "", O = !n || n.length === 0 || n.length === 1 && n[0] === _;
    let N = this.state.retrievedSchema, A = O ? t : eP(h);
    if (un(A) || Array.isArray(A)) {
      t === qK ? w3e(A, n) : O || zn(A, n, t);
      const z = this.getStateFromProps(this.props, A, void 0, void 0, void 0, !0);
      A = z.formData, N = z.retrievedSchema;
    }
    const R = !d && (f === !0 || f === "onChange");
    let D = { formData: A, schema: g }, I = A;
    if (l === !0 && (c === !0 || c === "onChange") && (I = this.omitExtraData(A), D = {
      formData: I
    }), a) {
      const z = O ? x : Re(x, n);
      if (!$r(z))
        O ? E = a : zn(E, n, a);
      else if (k || (k = new gK()), O) {
        const B = Re(a, zo);
        B && k.setErrors(B);
      } else
        zn(k.ErrorSchema, n, a);
    } else k && Re(k.ErrorSchema, [...n, zo]) && k.clearErrors(n);
    if (R && this.pendingChanges.length === 1) {
      const z = this.liveValidate(g, v, E, I, s, k, N);
      D = { formData: I, ...z, customErrors: k };
    } else if (!d && a) {
      const z = this.mergeErrors({ errorSchema: E, errors: w }, s, k);
      D = {
        formData: I,
        ...z,
        customErrors: k
      };
    }
    this.setState(D, () => {
      m && m(Nh({ ...this.state, ...D }), r), this.pendingChanges.shift(), this.processPendingChange();
    });
  }
  /**
   * If the retrievedSchema has changed the new retrievedSchema is returned.
   * Otherwise, the old retrievedSchema is returned to persist reference.
   * -  This ensures that AJV retrieves the schema from the cache when it has not changed,
   *    avoiding the performance cost of recompiling the schema.
   *
   * @param retrievedSchema The new retrieved schema.
   * @returns The new retrieved schema if it has changed, else the old retrieved schema.
   */
  updateRetrievedSchema(t) {
    return er(t, this.state?.retrievedSchema) ? this.state.retrievedSchema : t;
  }
  /** Extracts the `GlobalFormOptions` from the given Form `props`
   *
   * @param props - The form props to extract the global form options from
   * @returns - The `GlobalFormOptions` from the props
   * @private
   */
  getGlobalFormOptions(t) {
    const { uiSchema: n = {}, experimental_componentUpdateStrategy: r, idSeparator: a = tG, idPrefix: s = eG, nameGenerator: l, useFallbackUiForUnsupportedType: c = !1 } = t;
    return {
      idPrefix: n["ui:rootFieldId"] || s,
      idSeparator: a,
      useFallbackUiForUnsupportedType: c,
      ...r !== void 0 && { experimental_componentUpdateStrategy: r },
      ...l !== void 0 && { nameGenerator: l }
    };
  }
  /** Computed the registry for the form using the given `props`, `schema` and `schemaUtils` */
  getRegistry(t, n, r) {
    const { translateString: a, uiSchema: s = {} } = t, { fields: l, templates: c, widgets: d, formContext: f, translateString: m } = bje();
    return {
      fields: { ...l, ...t.fields },
      templates: {
        ...c,
        ...t.templates,
        ButtonTemplates: {
          ...c.ButtonTemplates,
          ...t.templates?.ButtonTemplates
        }
      },
      widgets: { ...d, ...t.widgets },
      rootSchema: n,
      formContext: t.formContext || f,
      schemaUtils: r,
      translateString: a || m,
      globalUiOptions: s[$3],
      globalFormOptions: this.getGlobalFormOptions(t)
    };
  }
  /** Attempts to focus on the field associated with the `error`. Uses the `property` field to compute path of the error
   * field, then, using the `idPrefix` and `idSeparator` converts that path into an id. Then the input element with that
   * id is attempted to be found using the `formElement` ref. If it is located, then it is focused.
   *
   * @param error - The error on which to focus
   */
  focusOnError(t) {
    const { idPrefix: n = "root", idSeparator: r = "_" } = this.props, { property: a } = t, s = kK(a);
    s[0] === "" ? s[0] = n : s.unshift(n);
    const l = s.join(r);
    let c = this.formElement.current.elements[l];
    c || (c = this.formElement.current.querySelector(`input[id^="${l}"`)), c && c.length && (c = c[0]), c && c.focus();
  }
  /** Programmatically validate the form.  If `omitExtraData` is true, the `formData` will first be filtered to remove
   * any extra data not in a form field. If `onError` is provided, then it will be called with the list of errors the
   * same way as would happen on form submission.
   *
   * @returns - True if the form is valid, false otherwise.
   */
  validateForm() {
    const { omitExtraData: t } = this.props;
    let { formData: n } = this.state;
    return t === !0 && (n = this.omitExtraData(n)), this.validateFormWithFormData(n);
  }
  /** Renders the `Form` fields inside the <form> | `tagName` or `_internalFormWrapper`, rendering any errors if
   * needed along with the submit button or any children of the form.
   */
  render() {
    const { children: t, id: n, className: r = "", tagName: a, name: s, method: l, target: c, action: d, autoComplete: f, enctype: m, acceptCharset: h, noHtml5Validate: v = !1, disabled: g, readonly: b, showErrorList: x = "top", _internalFormWrapper: w } = this.props, { schema: k, uiSchema: E, formData: _, errorSchema: O, fieldPathId: N, registry: A } = this.state, { SchemaField: R } = A.fields, { SubmitButton: D } = A.templates.ButtonTemplates, I = w ? a : void 0, z = w || a || "form";
    let { [L2]: B = {} } = vt(E);
    g && (B = { ...B, props: { ...B.props, disabled: !0 } });
    const P = { [wd]: { [L2]: B } };
    return C.jsxs(z, { className: r || "rjsf", id: n, name: s, method: l, target: c, action: d, autoComplete: f, encType: m, acceptCharset: h, noValidate: v, onSubmit: this.onSubmit, as: I, ref: this.formElement, children: [x === "top" && this.renderErrors(A), C.jsx(R, { name: "", schema: k, uiSchema: E, errorSchema: O, fieldPathId: N, formData: _, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, registry: A, disabled: g, readonly: b }), t || C.jsx(D, { uiSchema: P, registry: A }), x === "bottom" && this.renderErrors(A)] });
  }
};
function JK(e) {
  return M.forwardRef(({ fields: t, widgets: n, templates: r, ...a }, s) => (t = { ...e?.fields, ...t }, n = { ...e?.widgets, ...n }, r = {
    ...e?.templates,
    ...r,
    ButtonTemplates: {
      ...e?.templates?.ButtonTemplates,
      ...r?.ButtonTemplates
    }
  }, C.jsx(wje, { ...e, ...a, fields: t, widgets: n, templates: r, ref: s })));
}
function J3(...e) {
  return e.reduce((t, n) => n == null ? t : function(...r) {
    t.apply(this, r), n.apply(this, r);
  }, () => {
  });
}
function QK(e, t = 166) {
  let n;
  function r(...a) {
    const s = () => {
      e.apply(this, a);
    };
    clearTimeout(n), n = setTimeout(s, t);
  }
  return r.clear = () => {
    clearTimeout(n);
  }, r;
}
function Ca(e) {
  return e && e.ownerDocument || document;
}
function Hc(e) {
  return Ca(e).defaultView || window;
}
function n9(e, t) {
  typeof e == "function" ? e(t) : e && (e.current = t);
}
function RS(e) {
  const {
    controlled: t,
    default: n,
    name: r,
    state: a = "value"
  } = e, {
    current: s
  } = M.useRef(t !== void 0), [l, c] = M.useState(n), d = s ? t : l, f = M.useCallback((m) => {
    s || c(m);
  }, []);
  return [d, f];
}
function xje(e, t) {
  const n = e.charCodeAt(2);
  return e[0] === "o" && e[1] === "n" && n >= 65 && n <= 90 && typeof t == "function";
}
function ZK(e, t) {
  if (!e)
    return t;
  function n(l, c) {
    const d = {};
    return Object.keys(c).forEach((f) => {
      xje(f, c[f]) && typeof l[f] == "function" && (d[f] = (...m) => {
        l[f](...m), c[f](...m);
      });
    }), d;
  }
  if (typeof e == "function" || typeof t == "function")
    return (l) => {
      const c = typeof t == "function" ? t(l) : t, d = typeof e == "function" ? e({
        ...l,
        ...c
      }) : e, f = Ye(l?.className, c?.className, d?.className), m = n(d, c);
      return {
        ...c,
        ...d,
        ...m,
        ...!!f && {
          className: f
        },
        ...c?.style && d?.style && {
          style: {
            ...c.style,
            ...d.style
          }
        },
        ...c?.sx && d?.sx && {
          sx: [...Array.isArray(c.sx) ? c.sx : [c.sx], ...Array.isArray(d.sx) ? d.sx : [d.sx]]
        }
      };
    };
  const r = t, a = n(e, r), s = Ye(r?.className, e?.className);
  return {
    ...t,
    ...e,
    ...a,
    ...!!s && {
      className: s
    },
    ...r?.style && e?.style && {
      style: {
        ...r.style,
        ...e.style
      }
    },
    ...r?.sx && e?.sx && {
      sx: [...Array.isArray(r.sx) ? r.sx : [r.sx], ...Array.isArray(e.sx) ? e.sx : [e.sx]]
    }
  };
}
const eY = Ni(/* @__PURE__ */ C.jsx("path", {
  d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z"
}));
function Sje(e) {
  return typeof e.main == "string";
}
function kje(e, t = []) {
  if (!Sje(e))
    return !1;
  for (const n of t)
    if (!e.hasOwnProperty(n) || typeof e[n] != "string")
      return !1;
  return !0;
}
function Zo(e = []) {
  return ([, t]) => t && kje(t, e);
}
function _je(e) {
  return Ct("MuiCircularProgress", e);
}
St("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "track", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
const Us = 44, Q3 = $g`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`, Z3 = $g`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`, Eje = typeof Q3 != "string" ? YS`
        animation: ${Q3} 1.4s linear infinite;
      ` : null, Cje = typeof Z3 != "string" ? YS`
        animation: ${Z3} 1.4s ease-in-out infinite;
      ` : null, Oje = (e) => {
  const {
    classes: t,
    variant: n,
    color: r,
    disableShrink: a
  } = e, s = {
    root: ["root", n, `color${qe(r)}`],
    svg: ["svg"],
    track: ["track"],
    circle: ["circle", `circle${qe(n)}`, a && "circleDisableShrink"]
  };
  return Et(s, _je, t);
}, Mje = $e("span", {
  name: "MuiCircularProgress",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], t[`color${qe(n.color)}`]];
  }
})(Mt(({
  theme: e
}) => ({
  display: "inline-block",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: e.transitions.create("transform")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: Eje || {
      animation: `${Q3} 1.4s linear infinite`
    }
  }, ...Object.entries(e.palette).filter(Zo()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      color: (e.vars || e).palette[t].main
    }
  }))]
}))), Nje = $e("svg", {
  name: "MuiCircularProgress",
  slot: "Svg"
})({
  display: "block"
  // Keeps the progress centered
}), Aje = $e("circle", {
  name: "MuiCircularProgress",
  slot: "Circle",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.circle, t[`circle${qe(n.variant)}`], n.disableShrink && t.circleDisableShrink];
  }
})(Mt(({
  theme: e
}) => ({
  stroke: "currentColor",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: e.transitions.create("stroke-dashoffset")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: {
      // Some default value that looks fine waiting for the animation to kicks in.
      strokeDasharray: "80px, 200px",
      strokeDashoffset: 0
      // Add the unit to fix a Edge 16 and below bug.
    }
  }, {
    props: ({
      ownerState: t
    }) => t.variant === "indeterminate" && !t.disableShrink,
    style: Cje || {
      // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
      animation: `${Z3} 1.4s ease-in-out infinite`
    }
  }]
}))), Rje = $e("circle", {
  name: "MuiCircularProgress",
  slot: "Track"
})(Mt(({
  theme: e
}) => ({
  stroke: "currentColor",
  opacity: (e.vars || e).palette.action.activatedOpacity
}))), tY = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiCircularProgress"
  }), {
    className: r,
    color: a = "primary",
    disableShrink: s = !1,
    enableTrackSlot: l = !1,
    size: c = 40,
    style: d,
    thickness: f = 3.6,
    value: m = 0,
    variant: h = "indeterminate",
    ...v
  } = n, g = {
    ...n,
    color: a,
    disableShrink: s,
    size: c,
    thickness: f,
    value: m,
    variant: h,
    enableTrackSlot: l
  }, b = Oje(g), x = {}, w = {}, k = {};
  if (h === "determinate") {
    const E = 2 * Math.PI * ((Us - f) / 2);
    x.strokeDasharray = E.toFixed(3), k["aria-valuenow"] = Math.round(m), x.strokeDashoffset = `${((100 - m) / 100 * E).toFixed(3)}px`, w.transform = "rotate(-90deg)";
  }
  return /* @__PURE__ */ C.jsx(Mje, {
    className: Ye(b.root, r),
    style: {
      width: c,
      height: c,
      ...w,
      ...d
    },
    ownerState: g,
    ref: t,
    role: "progressbar",
    ...k,
    ...v,
    children: /* @__PURE__ */ C.jsxs(Nje, {
      className: b.svg,
      ownerState: g,
      viewBox: `${Us / 2} ${Us / 2} ${Us} ${Us}`,
      children: [l ? /* @__PURE__ */ C.jsx(Rje, {
        className: b.track,
        ownerState: g,
        cx: Us,
        cy: Us,
        r: (Us - f) / 2,
        fill: "none",
        strokeWidth: f,
        "aria-hidden": "true"
      }) : null, /* @__PURE__ */ C.jsx(Aje, {
        className: b.circle,
        style: x,
        ownerState: g,
        cx: Us,
        cy: Us,
        r: (Us - f) / 2,
        fill: "none",
        strokeWidth: f
      })]
    })
  });
});
function jje(e) {
  return Ct("MuiIconButton", e);
}
const r9 = St("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge", "loading", "loadingIndicator", "loadingWrapper"]), Pje = (e) => {
  const {
    classes: t,
    disabled: n,
    color: r,
    edge: a,
    size: s,
    loading: l
  } = e, c = {
    root: ["root", l && "loading", n && "disabled", r !== "default" && `color${qe(r)}`, a && `edge${qe(a)}`, `size${qe(s)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  };
  return Et(c, jje, t);
}, Dje = $e(JS, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.loading && t.loading, n.color !== "default" && t[`color${qe(n.color)}`], n.edge && t[`edge${qe(n.edge)}`], t[`size${qe(n.size)}`]];
  }
})(Mt(({
  theme: e
}) => ({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: e.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  color: (e.vars || e).palette.action.active,
  transition: e.transitions.create("background-color", {
    duration: e.transitions.duration.shortest
  }),
  variants: [{
    props: (t) => !t.disableRipple,
    style: {
      "--IconButton-hoverBg": e.alpha((e.vars || e).palette.action.active, (e.vars || e).palette.action.hoverOpacity),
      "&:hover": {
        backgroundColor: "var(--IconButton-hoverBg)",
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }, {
    props: {
      edge: "start"
    },
    style: {
      marginLeft: -12
    }
  }, {
    props: {
      edge: "start",
      size: "small"
    },
    style: {
      marginLeft: -3
    }
  }, {
    props: {
      edge: "end"
    },
    style: {
      marginRight: -12
    }
  }, {
    props: {
      edge: "end",
      size: "small"
    },
    style: {
      marginRight: -3
    }
  }]
})), Mt(({
  theme: e
}) => ({
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      color: "inherit"
    }
  }, ...Object.entries(e.palette).filter(Zo()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      color: (e.vars || e).palette[t].main
    }
  })), ...Object.entries(e.palette).filter(Zo()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      "--IconButton-hoverBg": e.alpha((e.vars || e).palette[t].main, (e.vars || e).palette.action.hoverOpacity)
    }
  })), {
    props: {
      size: "small"
    },
    style: {
      padding: 5,
      fontSize: e.typography.pxToRem(18)
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      padding: 12,
      fontSize: e.typography.pxToRem(28)
    }
  }],
  [`&.${r9.disabled}`]: {
    backgroundColor: "transparent",
    color: (e.vars || e).palette.action.disabled
  },
  [`&.${r9.loading}`]: {
    color: "transparent"
  }
}))), Ije = $e("span", {
  name: "MuiIconButton",
  slot: "LoadingIndicator"
})(({
  theme: e
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  color: (e.vars || e).palette.action.disabled,
  variants: [{
    props: {
      loading: !0
    },
    style: {
      display: "flex"
    }
  }]
})), nY = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiIconButton"
  }), {
    edge: r = !1,
    children: a,
    className: s,
    color: l = "default",
    disabled: c = !1,
    disableFocusRipple: d = !1,
    size: f = "medium",
    id: m,
    loading: h = null,
    loadingIndicator: v,
    ...g
  } = n, b = zg(m), x = v ?? /* @__PURE__ */ C.jsx(tY, {
    "aria-labelledby": b,
    color: "inherit",
    size: 16
  }), w = {
    ...n,
    edge: r,
    color: l,
    disabled: c,
    disableFocusRipple: d,
    loading: h,
    loadingIndicator: x,
    size: f
  }, k = Pje(w);
  return /* @__PURE__ */ C.jsxs(Dje, {
    id: h ? b : m,
    className: Ye(k.root, s),
    centerRipple: !0,
    focusRipple: !d,
    disabled: c || h,
    ref: t,
    ...g,
    ownerState: w,
    children: [typeof h == "boolean" && // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ C.jsx("span", {
      className: k.loadingWrapper,
      style: {
        display: "contents"
      },
      children: /* @__PURE__ */ C.jsx(Ije, {
        className: k.loadingIndicator,
        ownerState: w,
        children: h && x
      })
    }), a]
  });
});
function $je({ uiSchema: e, registry: t, ...n }) {
  const { translateString: r } = t;
  return C.jsx(nY, { title: r(Jt.AddItemButton), ...n, color: "primary", children: C.jsx(eY, {}) });
}
function zje({
  theme: e,
  ...t
}) {
  const n = zl in e ? e[zl] : void 0;
  return /* @__PURE__ */ C.jsx(N7, {
    ...t,
    themeId: n ? zl : void 0,
    theme: n || e
  });
}
const r_ = {
  colorSchemeStorageKey: "mui-color-scheme",
  defaultLightColorScheme: "light",
  defaultDarkColorScheme: "dark",
  modeStorageKey: "mui-mode"
}, {
  CssVarsProvider: Tje
} = One({
  themeId: zl,
  // @ts-ignore ignore module augmentation tests
  theme: () => kE({
    cssVariables: !0
  }),
  colorSchemeStorageKey: r_.colorSchemeStorageKey,
  modeStorageKey: r_.modeStorageKey,
  defaultColorScheme: {
    light: r_.defaultLightColorScheme,
    dark: r_.defaultDarkColorScheme
  },
  resolveTheme: (e) => {
    const t = {
      ...e,
      typography: D7(e.palette, e.typography)
    };
    return t.unstable_sx = function(n) {
      return Cd({
        sx: n,
        theme: this
      });
    }, t;
  }
}), Lje = Tje;
function Fje({
  theme: e,
  ...t
}) {
  const n = M.useMemo(() => {
    if (typeof e == "function")
      return e;
    const r = zl in e ? e[zl] : e;
    return "colorSchemes" in r ? null : "vars" in r ? e : {
      ...e,
      vars: null
    };
  }, [e]);
  return n ? /* @__PURE__ */ C.jsx(zje, {
    theme: n,
    ...t
  }) : /* @__PURE__ */ C.jsx(Lje, {
    theme: e,
    ...t
  });
}
const Bje = St("MuiBox", ["root"]), Uje = kE(), zd = qte({
  themeId: zl,
  defaultTheme: Uje,
  defaultClassName: Bje.root,
  generateClassName: w7.generate
}), To = Kne({
  createStyledComponent: $e("div", {
    name: "MuiGrid",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.container && t.container];
    }
  }),
  componentName: "MuiGrid",
  useThemeProps: (e) => Dt({
    props: e,
    name: "MuiGrid"
  }),
  useTheme: _E
});
function o9() {
  return null;
}
o9.isRequired = o9;
function Vje(e) {
  return Ct("MuiPaper", e);
}
St("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const Hje = (e) => {
  const {
    square: t,
    elevation: n,
    variant: r,
    classes: a
  } = e, s = {
    root: ["root", r, !t && "rounded", r === "elevation" && `elevation${n}`]
  };
  return Et(s, Vje, a);
}, Wje = $e("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], !n.square && t.rounded, n.variant === "elevation" && t[`elevation${n.elevation}`]];
  }
})(Mt(({
  theme: e
}) => ({
  backgroundColor: (e.vars || e).palette.background.paper,
  color: (e.vars || e).palette.text.primary,
  transition: e.transitions.create("box-shadow"),
  variants: [{
    props: ({
      ownerState: t
    }) => !t.square,
    style: {
      borderRadius: e.shape.borderRadius
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      border: `1px solid ${(e.vars || e).palette.divider}`
    }
  }, {
    props: {
      variant: "elevation"
    },
    style: {
      boxShadow: "var(--Paper-shadow)",
      backgroundImage: "var(--Paper-overlay)"
    }
  }]
}))), IC = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiPaper"
  }), r = _E(), {
    className: a,
    component: s = "div",
    elevation: l = 1,
    square: c = !1,
    variant: d = "elevation",
    ...f
  } = n, m = {
    ...n,
    component: s,
    elevation: l,
    square: c,
    variant: d
  }, h = Hje(m);
  return /* @__PURE__ */ C.jsx(Wje, {
    as: s,
    ownerState: m,
    className: Ye(h.root, a),
    ref: t,
    ...f,
    style: {
      ...d === "elevation" && {
        "--Paper-shadow": (r.vars || r).shadows[l],
        ...r.vars && {
          "--Paper-overlay": r.vars.overlays?.[l]
        },
        ...!r.vars && r.palette.mode === "dark" && {
          "--Paper-overlay": `linear-gradient(${r2("#fff", zA(l))}, ${r2("#fff", zA(l))})`
        }
      },
      ...f.style
    }
  });
});
function qje(e) {
  const { children: t, buttonsProps: n, hasDescription: r, hasToolbar: a, uiSchema: s, registry: l } = e, c = vt(s), d = xt("ArrayFieldItemButtonsTemplate", l, c), f = {
    flex: 1,
    paddingLeft: 6,
    paddingRight: 6,
    fontWeight: "bold",
    minWidth: 0
  };
  return C.jsxs(To, { container: !0, alignItems: "center", children: [C.jsx(To, { size: { xs: 8, sm: 9, md: 10, lg: 11, xl: 11.25 }, style: { overflow: "auto" }, children: C.jsx(zd, { mb: 2, children: C.jsx(IC, { elevation: 2, children: C.jsx(zd, { p: 2, children: t }) }) }) }), a && C.jsx(To, { sx: { mt: r ? -5 : -1.5 }, children: C.jsx(d, { ...n, style: f }) })] });
}
function Gje(e) {
  const { canAdd: t, disabled: n, fieldPathId: r, uiSchema: a, items: s, optionalDataControl: l, onAddClick: c, readonly: d, registry: f, required: m, schema: h, title: v } = e, g = vt(a), b = xt("ArrayFieldDescriptionTemplate", f, g), x = xt("ArrayFieldTitleTemplate", f, g), w = !d && !n, { ButtonTemplates: { AddButton: k } } = f.templates;
  return C.jsx(IC, { elevation: 2, children: C.jsxs(zd, { p: 2, children: [C.jsx(x, { fieldPathId: r, title: g.title || v, schema: h, uiSchema: a, required: m, registry: f, optionalDataControl: w ? l : void 0 }), C.jsx(b, { fieldPathId: r, description: g.description || h.description, schema: h, uiSchema: a, registry: f }), w ? void 0 : l, s, t && C.jsx(To, { container: !0, justifyContent: "flex-end", children: C.jsx(To, { children: C.jsx(zd, { mt: 2, children: C.jsx(k, { id: jl(r, "add"), className: "rjsf-array-item-add", onClick: c, disabled: n || d, uiSchema: a, registry: f }) }) }) })] }) });
}
function o_(e) {
  return parseInt(e, 10) || 0;
}
const Kje = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function Yje(e) {
  for (const t in e)
    return !1;
  return !0;
}
function a9(e) {
  return Yje(e) || e.outerHeightStyle === 0 && !e.overflowing;
}
const Xje = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const {
    onChange: n,
    maxRows: r,
    minRows: a = 1,
    style: s,
    value: l,
    ...c
  } = e, {
    current: d
  } = M.useRef(l != null), f = M.useRef(null), m = io(t, f), h = M.useRef(null), v = M.useRef(null), g = M.useCallback(() => {
    const E = f.current, _ = v.current;
    if (!E || !_)
      return;
    const O = Hc(E).getComputedStyle(E);
    if (O.width === "0px")
      return {
        outerHeightStyle: 0,
        overflowing: !1
      };
    _.style.width = O.width, _.value = E.value || e.placeholder || "x", _.value.slice(-1) === `
` && (_.value += " ");
    const N = O.boxSizing, A = o_(O.paddingBottom) + o_(O.paddingTop), R = o_(O.borderBottomWidth) + o_(O.borderTopWidth), D = _.scrollHeight;
    _.value = "x";
    const I = _.scrollHeight;
    let z = D;
    a && (z = Math.max(Number(a) * I, z)), r && (z = Math.min(Number(r) * I, z)), z = Math.max(z, I);
    const B = z + (N === "border-box" ? A + R : 0), P = Math.abs(z - D) <= 1;
    return {
      outerHeightStyle: B,
      overflowing: P
    };
  }, [r, a, e.placeholder]), b = Tl(() => {
    const E = f.current, _ = g();
    if (!E || !_ || a9(_))
      return !1;
    const O = _.outerHeightStyle;
    return h.current != null && h.current !== O;
  }), x = M.useCallback(() => {
    const E = f.current, _ = g();
    if (!E || !_ || a9(_))
      return;
    const O = _.outerHeightStyle;
    h.current !== O && (h.current = O, E.style.height = `${O}px`), E.style.overflow = _.overflowing ? "hidden" : "";
  }, [g]), w = M.useRef(-1);
  Zs(() => {
    const E = QK(x), _ = f?.current;
    if (!_)
      return;
    const O = Hc(_);
    O.addEventListener("resize", E);
    let N;
    return typeof ResizeObserver < "u" && (N = new ResizeObserver(() => {
      b() && (N.unobserve(_), cancelAnimationFrame(w.current), x(), w.current = requestAnimationFrame(() => {
        N.observe(_);
      }));
    }), N.observe(_)), () => {
      E.clear(), cancelAnimationFrame(w.current), O.removeEventListener("resize", E), N && N.disconnect();
    };
  }, [g, x, b]), Zs(() => {
    x();
  });
  const k = (E) => {
    d || x();
    const _ = E.target, O = _.value.length, N = _.value.endsWith(`
`), A = _.selectionStart === O;
    N && A && _.setSelectionRange(O, O), n && n(E);
  };
  return /* @__PURE__ */ C.jsxs(M.Fragment, {
    children: [/* @__PURE__ */ C.jsx("textarea", {
      value: l,
      onChange: k,
      ref: m,
      rows: a,
      style: s,
      ...c
    }), /* @__PURE__ */ C.jsx("textarea", {
      "aria-hidden": !0,
      className: e.className,
      readOnly: !0,
      ref: v,
      tabIndex: -1,
      style: {
        ...Kje.shadow,
        ...s,
        paddingTop: 0,
        paddingBottom: 0
      }
    })]
  });
});
function Hd({
  props: e,
  states: t,
  muiFormControl: n
}) {
  return t.reduce((r, a) => (r[a] = e[a], n && typeof e[a] > "u" && (r[a] = n[a]), r), {});
}
const gP = /* @__PURE__ */ M.createContext(void 0);
function Zl() {
  return M.useContext(gP);
}
function i9(e) {
  return e != null && !(Array.isArray(e) && e.length === 0);
}
function q2(e, t = !1) {
  return e && (i9(e.value) && e.value !== "" || t && i9(e.defaultValue) && e.defaultValue !== "");
}
function Jje(e) {
  return e.startAdornment;
}
function Qje(e) {
  return Ct("MuiInputBase", e);
}
const Rg = St("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
var s9;
const $C = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, n.formControl && t.formControl, n.startAdornment && t.adornedStart, n.endAdornment && t.adornedEnd, n.error && t.error, n.size === "small" && t.sizeSmall, n.multiline && t.multiline, n.color && t[`color${qe(n.color)}`], n.fullWidth && t.fullWidth, n.hiddenLabel && t.hiddenLabel];
}, zC = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.input, n.size === "small" && t.inputSizeSmall, n.multiline && t.inputMultiline, n.type === "search" && t.inputTypeSearch, n.startAdornment && t.inputAdornedStart, n.endAdornment && t.inputAdornedEnd, n.hiddenLabel && t.inputHiddenLabel];
}, Zje = (e) => {
  const {
    classes: t,
    color: n,
    disabled: r,
    error: a,
    endAdornment: s,
    focused: l,
    formControl: c,
    fullWidth: d,
    hiddenLabel: f,
    multiline: m,
    readOnly: h,
    size: v,
    startAdornment: g,
    type: b
  } = e, x = {
    root: ["root", `color${qe(n)}`, r && "disabled", a && "error", d && "fullWidth", l && "focused", c && "formControl", v && v !== "medium" && `size${qe(v)}`, m && "multiline", g && "adornedStart", s && "adornedEnd", f && "hiddenLabel", h && "readOnly"],
    input: ["input", r && "disabled", b === "search" && "inputTypeSearch", m && "inputMultiline", v === "small" && "inputSizeSmall", f && "inputHiddenLabel", g && "inputAdornedStart", s && "inputAdornedEnd", h && "readOnly"]
  };
  return Et(x, Qje, t);
}, TC = $e("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: $C
})(Mt(({
  theme: e
}) => ({
  ...e.typography.body1,
  color: (e.vars || e).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${Rg.disabled}`]: {
    color: (e.vars || e).palette.text.disabled,
    cursor: "default"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      padding: "4px 0 5px"
    }
  }, {
    props: ({
      ownerState: t,
      size: n
    }) => t.multiline && n === "small",
    style: {
      paddingTop: 1
    }
  }, {
    props: ({
      ownerState: t
    }) => t.fullWidth,
    style: {
      width: "100%"
    }
  }]
}))), LC = $e("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: zC
})(Mt(({
  theme: e
}) => {
  const t = e.palette.mode === "light", n = {
    color: "currentColor",
    ...e.vars ? {
      opacity: e.vars.opacity.inputPlaceholder
    } : {
      opacity: t ? 0.42 : 0.5
    },
    transition: e.transitions.create("opacity", {
      duration: e.transitions.duration.shorter
    })
  }, r = {
    opacity: "0 !important"
  }, a = e.vars ? {
    opacity: e.vars.opacity.inputPlaceholder
  } : {
    opacity: t ? 0.42 : 0.5
  };
  return {
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    "&::-webkit-input-placeholder": n,
    "&::-moz-placeholder": n,
    // Firefox 19+
    "&::-ms-input-placeholder": n,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${Rg.formControl} &`]: {
      "&::-webkit-input-placeholder": r,
      "&::-moz-placeholder": r,
      // Firefox 19+
      "&::-ms-input-placeholder": r,
      // Edge
      "&:focus::-webkit-input-placeholder": a,
      "&:focus::-moz-placeholder": a,
      // Firefox 19+
      "&:focus::-ms-input-placeholder": a
      // Edge
    },
    [`&.${Rg.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (e.vars || e).palette.text.disabled
      // Fix opacity Safari bug
    },
    variants: [{
      props: ({
        ownerState: s
      }) => !s.disableInjectingGlobalStyles,
      style: {
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&:-webkit-autofill": {
          animationDuration: "5000s",
          animationName: "mui-auto-fill"
        }
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        paddingTop: 1
      }
    }, {
      props: ({
        ownerState: s
      }) => s.multiline,
      style: {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0
      }
    }, {
      props: {
        type: "search"
      },
      style: {
        MozAppearance: "textfield"
        // Improve type search style.
      }
    }]
  };
})), l9 = Mre({
  "@keyframes mui-auto-fill": {
    from: {
      display: "block"
    }
  },
  "@keyframes mui-auto-fill-cancel": {
    from: {
      display: "block"
    }
  }
}), vP = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiInputBase"
  }), {
    "aria-describedby": r,
    autoComplete: a,
    autoFocus: s,
    className: l,
    color: c,
    components: d = {},
    componentsProps: f = {},
    defaultValue: m,
    disabled: h,
    disableInjectingGlobalStyles: v,
    endAdornment: g,
    error: b,
    fullWidth: x = !1,
    id: w,
    inputComponent: k = "input",
    inputProps: E = {},
    inputRef: _,
    margin: O,
    maxRows: N,
    minRows: A,
    multiline: R = !1,
    name: D,
    onBlur: I,
    onChange: z,
    onClick: B,
    onFocus: P,
    onKeyDown: H,
    onKeyUp: L,
    placeholder: G,
    readOnly: $,
    renderSuffix: K,
    rows: q,
    size: Z,
    slotProps: V = {},
    slots: F = {},
    startAdornment: Y,
    type: U = "text",
    value: W,
    ...J
  } = n, oe = E.value != null ? E.value : W, {
    current: fe
  } = M.useRef(oe != null), ie = M.useRef(), ce = M.useCallback((Fe) => {
  }, []), ge = io(ie, _, E.ref, ce), [re, le] = M.useState(!1), me = Zl(), ve = Hd({
    props: n,
    muiFormControl: me,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  ve.focused = me ? me.focused : re, M.useEffect(() => {
    !me && h && re && (le(!1), I && I());
  }, [me, h, re, I]);
  const xe = me && me.onFilled, _e = me && me.onEmpty, Ge = M.useCallback((Fe) => {
    q2(Fe) ? xe && xe() : _e && _e();
  }, [xe, _e]);
  Zs(() => {
    fe && Ge({
      value: oe
    });
  }, [oe, Ge, fe]);
  const Xe = (Fe) => {
    P && P(Fe), E.onFocus && E.onFocus(Fe), me && me.onFocus ? me.onFocus(Fe) : le(!0);
  }, tt = (Fe) => {
    I && I(Fe), E.onBlur && E.onBlur(Fe), me && me.onBlur ? me.onBlur(Fe) : le(!1);
  }, nt = (Fe, ...Ut) => {
    if (!fe) {
      const Vt = Fe.target || ie.current;
      if (Vt == null)
        throw new Error(Ic(1));
      Ge({
        value: Vt.value
      });
    }
    E.onChange && E.onChange(Fe, ...Ut), z && z(Fe, ...Ut);
  };
  M.useEffect(() => {
    Ge(ie.current);
  }, []);
  const je = (Fe) => {
    ie.current && Fe.currentTarget === Fe.target && ie.current.focus(), B && B(Fe);
  };
  let cn = k, pt = E;
  R && cn === "input" && (q ? pt = {
    type: void 0,
    minRows: q,
    maxRows: q,
    ...pt
  } : pt = {
    type: void 0,
    maxRows: N,
    minRows: A,
    ...pt
  }, cn = Xje);
  const Ce = (Fe) => {
    Ge(Fe.animationName === "mui-auto-fill-cancel" ? ie.current : {
      value: "x"
    });
  };
  M.useEffect(() => {
    me && me.setAdornedStart(!!Y);
  }, [me, Y]);
  const Me = {
    ...n,
    color: ve.color || "primary",
    disabled: ve.disabled,
    endAdornment: g,
    error: ve.error,
    focused: ve.focused,
    formControl: me,
    fullWidth: x,
    hiddenLabel: ve.hiddenLabel,
    multiline: R,
    size: ve.size,
    startAdornment: Y,
    type: U
  }, he = Zje(Me), ye = F.root || d.Root || TC, Ee = V.root || f.root || {}, Te = F.input || d.Input || LC;
  return pt = {
    ...pt,
    ...V.input ?? f.input
  }, /* @__PURE__ */ C.jsxs(M.Fragment, {
    children: [!v && typeof l9 == "function" && // For Emotion/Styled-components, InputGlobalStyles will be a function
    // For Pigment CSS, this has no effect because the InputGlobalStyles will be null.
    (s9 || (s9 = /* @__PURE__ */ C.jsx(l9, {}))), /* @__PURE__ */ C.jsxs(ye, {
      ...Ee,
      ref: t,
      onClick: je,
      ...J,
      ...!Ll(ye) && {
        ownerState: {
          ...Me,
          ...Ee.ownerState
        }
      },
      className: Ye(he.root, Ee.className, l, $ && "MuiInputBase-readOnly"),
      children: [Y, /* @__PURE__ */ C.jsx(gP.Provider, {
        value: null,
        children: /* @__PURE__ */ C.jsx(Te, {
          "aria-invalid": ve.error,
          "aria-describedby": r,
          autoComplete: a,
          autoFocus: s,
          defaultValue: m,
          disabled: ve.disabled,
          id: w,
          onAnimationStart: Ce,
          name: D,
          placeholder: G,
          readOnly: $,
          required: ve.required,
          rows: q,
          value: oe,
          onKeyDown: H,
          onKeyUp: L,
          type: U,
          ...pt,
          ...!Ll(Te) && {
            as: cn,
            ownerState: {
              ...Me,
              ...pt.ownerState
            }
          },
          ref: ge,
          className: Ye(he.input, pt.className, $ && "MuiInputBase-readOnly"),
          onBlur: tt,
          onChange: nt,
          onFocus: Xe
        })
      }), g, K ? K({
        ...ve,
        startAdornment: Y
      }) : null]
    })]
  });
});
function ePe(e) {
  return Ct("MuiInput", e);
}
const ax = {
  ...Rg,
  ...St("MuiInput", ["root", "underline", "input"])
}, tPe = (e) => {
  const {
    classes: t,
    disableUnderline: n
  } = e, r = Et({
    root: ["root", !n && "underline"],
    input: ["input"]
  }, ePe, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...r
  };
}, nPe = $e(TC, {
  shouldForwardProp: (e) => ea(e) || e === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [...$C(e, t), !n.disableUnderline && t.underline];
  }
})(Mt(({
  theme: e
}) => {
  let t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  return e.vars && (t = e.alpha(e.vars.palette.common.onBackground, e.vars.opacity.inputUnderline)), {
    position: "relative",
    variants: [{
      props: ({
        ownerState: n
      }) => n.formControl,
      style: {
        "label + &": {
          marginTop: 16
        }
      }
    }, {
      props: ({
        ownerState: n
      }) => !n.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: e.transitions.create("transform", {
            duration: e.transitions.duration.shorter,
            easing: e.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${ax.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${ax.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (e.vars || e).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${t}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: e.transitions.create("border-bottom-color", {
            duration: e.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${ax.disabled}, .${ax.error}):before`]: {
          borderBottom: `2px solid ${(e.vars || e).palette.text.primary}`,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            borderBottom: `1px solid ${t}`
          }
        },
        [`&.${ax.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(e.palette).filter(Zo()).map(([n]) => ({
      props: {
        color: n,
        disableUnderline: !1
      },
      style: {
        "&::after": {
          borderBottom: `2px solid ${(e.vars || e).palette[n].main}`
        }
      }
    }))]
  };
})), rPe = $e(LC, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: zC
})({}), yP = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiInput"
  }), {
    disableUnderline: r = !1,
    components: a = {},
    componentsProps: s,
    fullWidth: l = !1,
    inputComponent: c = "input",
    multiline: d = !1,
    slotProps: f,
    slots: m = {},
    type: h = "text",
    ...v
  } = n, g = tPe(n), b = {
    root: {
      ownerState: {
        disableUnderline: r
      }
    }
  }, x = f ?? s ? Qo(f ?? s, b) : b, w = m.root ?? a.Root ?? nPe, k = m.input ?? a.Input ?? rPe;
  return /* @__PURE__ */ C.jsx(vP, {
    slots: {
      root: w,
      input: k
    },
    slotProps: x,
    fullWidth: l,
    inputComponent: c,
    multiline: d,
    ref: t,
    type: h,
    ...v,
    classes: g
  });
});
yP.muiName = "Input";
function oPe(e) {
  return Ct("MuiFilledInput", e);
}
const hm = {
  ...Rg,
  ...St("MuiFilledInput", ["root", "underline", "input", "adornedStart", "adornedEnd", "sizeSmall", "multiline", "hiddenLabel"])
}, aPe = (e) => {
  const {
    classes: t,
    disableUnderline: n,
    startAdornment: r,
    endAdornment: a,
    size: s,
    hiddenLabel: l,
    multiline: c
  } = e, d = {
    root: ["root", !n && "underline", r && "adornedStart", a && "adornedEnd", s === "small" && `size${qe(s)}`, l && "hiddenLabel", c && "multiline"],
    input: ["input"]
  }, f = Et(d, oPe, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...f
  };
}, iPe = $e(TC, {
  shouldForwardProp: (e) => ea(e) || e === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [...$C(e, t), !n.disableUnderline && t.underline];
  }
})(Mt(({
  theme: e
}) => {
  const t = e.palette.mode === "light", n = t ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)", r = t ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)", a = t ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)", s = t ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return {
    position: "relative",
    backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r,
    borderTopLeftRadius: (e.vars || e).shape.borderRadius,
    borderTopRightRadius: (e.vars || e).shape.borderRadius,
    transition: e.transitions.create("background-color", {
      duration: e.transitions.duration.shorter,
      easing: e.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.hoverBg : a,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
      }
    },
    [`&.${hm.focused}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
    },
    [`&.${hm.disabled}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.disabledBg : s
    },
    variants: [{
      props: ({
        ownerState: l
      }) => !l.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: e.transitions.create("transform", {
            duration: e.transitions.duration.shorter,
            easing: e.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${hm.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${hm.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (e.vars || e).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${e.vars ? e.alpha(e.vars.palette.common.onBackground, e.vars.opacity.inputUnderline) : n}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: e.transitions.create("border-bottom-color", {
            duration: e.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${hm.disabled}, .${hm.error}):before`]: {
          borderBottom: `1px solid ${(e.vars || e).palette.text.primary}`
        },
        [`&.${hm.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(e.palette).filter(Zo()).map(([l]) => ({
      props: {
        disableUnderline: !1,
        color: l
      },
      style: {
        "&::after": {
          borderBottom: `2px solid ${(e.vars || e).palette[l]?.main}`
        }
      }
    })), {
      props: ({
        ownerState: l
      }) => l.startAdornment,
      style: {
        paddingLeft: 12
      }
    }, {
      props: ({
        ownerState: l
      }) => l.endAdornment,
      style: {
        paddingRight: 12
      }
    }, {
      props: ({
        ownerState: l
      }) => l.multiline,
      style: {
        padding: "25px 12px 8px"
      }
    }, {
      props: ({
        ownerState: l,
        size: c
      }) => l.multiline && c === "small",
      style: {
        paddingTop: 21,
        paddingBottom: 4
      }
    }, {
      props: ({
        ownerState: l
      }) => l.multiline && l.hiddenLabel,
      style: {
        paddingTop: 16,
        paddingBottom: 17
      }
    }, {
      props: ({
        ownerState: l
      }) => l.multiline && l.hiddenLabel && l.size === "small",
      style: {
        paddingTop: 8,
        paddingBottom: 9
      }
    }]
  };
})), sPe = $e(LC, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: zC
})(Mt(({
  theme: e
}) => ({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12,
  ...!e.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
      caretColor: e.palette.mode === "light" ? null : "#fff",
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    }
  },
  ...e.vars && {
    "&:-webkit-autofill": {
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    },
    [e.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      paddingTop: 21,
      paddingBottom: 4
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hiddenLabel,
    style: {
      paddingTop: 16,
      paddingBottom: 17
    }
  }, {
    props: ({
      ownerState: t
    }) => t.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.endAdornment,
    style: {
      paddingRight: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hiddenLabel && t.size === "small",
    style: {
      paddingTop: 8,
      paddingBottom: 9
    }
  }, {
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      paddingTop: 0,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0
    }
  }]
}))), bP = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiFilledInput"
  }), {
    disableUnderline: r = !1,
    components: a = {},
    componentsProps: s,
    fullWidth: l = !1,
    hiddenLabel: c,
    // declare here to prevent spreading to DOM
    inputComponent: d = "input",
    multiline: f = !1,
    slotProps: m,
    slots: h = {},
    type: v = "text",
    ...g
  } = n, b = {
    ...n,
    disableUnderline: r,
    fullWidth: l,
    inputComponent: d,
    multiline: f,
    type: v
  }, x = aPe(n), w = {
    root: {
      ownerState: b
    },
    input: {
      ownerState: b
    }
  }, k = m ?? s ? Qo(w, m ?? s) : w, E = h.root ?? a.Root ?? iPe, _ = h.input ?? a.Input ?? sPe;
  return /* @__PURE__ */ C.jsx(vP, {
    slots: {
      root: E,
      input: _
    },
    slotProps: k,
    fullWidth: l,
    inputComponent: d,
    multiline: f,
    ref: t,
    type: v,
    ...g,
    classes: x
  });
});
bP.muiName = "Input";
var u9;
const lPe = $e("fieldset", {
  name: "MuiNotchedOutlined",
  shouldForwardProp: ea
})({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
}), uPe = $e("legend", {
  name: "MuiNotchedOutlined",
  shouldForwardProp: ea
})(Mt(({
  theme: e
}) => ({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden",
  // Fix Horizontal scroll when label too long
  variants: [{
    props: ({
      ownerState: t
    }) => !t.withLabel,
    style: {
      padding: 0,
      lineHeight: "11px",
      // sync with `height` in `legend` styles
      transition: e.transitions.create("width", {
        duration: 150,
        easing: e.transitions.easing.easeOut
      })
    }
  }, {
    props: ({
      ownerState: t
    }) => t.withLabel,
    style: {
      display: "block",
      // Fix conflict with normalize.css and sanitize.css
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: "0.75em",
      visibility: "hidden",
      maxWidth: 0.01,
      transition: e.transitions.create("max-width", {
        duration: 50,
        easing: e.transitions.easing.easeOut
      }),
      whiteSpace: "nowrap",
      "& > span": {
        paddingLeft: 5,
        paddingRight: 5,
        display: "inline-block",
        opacity: 0,
        visibility: "visible"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.withLabel && t.notched,
    style: {
      maxWidth: "100%",
      transition: e.transitions.create("max-width", {
        duration: 100,
        easing: e.transitions.easing.easeOut,
        delay: 50
      })
    }
  }]
})));
function cPe(e) {
  const {
    children: t,
    classes: n,
    className: r,
    label: a,
    notched: s,
    ...l
  } = e, c = a != null && a !== "", d = {
    ...e,
    notched: s,
    withLabel: c
  };
  return /* @__PURE__ */ C.jsx(lPe, {
    "aria-hidden": !0,
    className: r,
    ownerState: d,
    ...l,
    children: /* @__PURE__ */ C.jsx(uPe, {
      ownerState: d,
      children: c ? /* @__PURE__ */ C.jsx("span", {
        children: a
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        u9 || (u9 = /* @__PURE__ */ C.jsx("span", {
          className: "notranslate",
          "aria-hidden": !0,
          children: ""
        }))
      )
    })
  });
}
function dPe(e) {
  return Ct("MuiOutlinedInput", e);
}
const hl = {
  ...Rg,
  ...St("MuiOutlinedInput", ["root", "notchedOutline", "input"])
}, fPe = (e) => {
  const {
    classes: t
  } = e, n = Et({
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  }, dPe, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...n
  };
}, pPe = $e(TC, {
  shouldForwardProp: (e) => ea(e) || e === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: $C
})(Mt(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    position: "relative",
    borderRadius: (e.vars || e).shape.borderRadius,
    [`&:hover .${hl.notchedOutline}`]: {
      borderColor: (e.vars || e).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${hl.notchedOutline}`]: {
        borderColor: e.vars ? e.alpha(e.vars.palette.common.onBackground, 0.23) : t
      }
    },
    [`&.${hl.focused} .${hl.notchedOutline}`]: {
      borderWidth: 2
    },
    variants: [...Object.entries(e.palette).filter(Zo()).map(([n]) => ({
      props: {
        color: n
      },
      style: {
        [`&.${hl.focused} .${hl.notchedOutline}`]: {
          borderColor: (e.vars || e).palette[n].main
        }
      }
    })), {
      props: {},
      // to override the above style
      style: {
        [`&.${hl.error} .${hl.notchedOutline}`]: {
          borderColor: (e.vars || e).palette.error.main
        },
        [`&.${hl.disabled} .${hl.notchedOutline}`]: {
          borderColor: (e.vars || e).palette.action.disabled
        }
      }
    }, {
      props: ({
        ownerState: n
      }) => n.startAdornment,
      style: {
        paddingLeft: 14
      }
    }, {
      props: ({
        ownerState: n
      }) => n.endAdornment,
      style: {
        paddingRight: 14
      }
    }, {
      props: ({
        ownerState: n
      }) => n.multiline,
      style: {
        padding: "16.5px 14px"
      }
    }, {
      props: ({
        ownerState: n,
        size: r
      }) => n.multiline && r === "small",
      style: {
        padding: "8.5px 14px"
      }
    }]
  };
})), mPe = $e(cPe, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline"
})(Mt(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: e.vars ? e.alpha(e.vars.palette.common.onBackground, 0.23) : t
  };
})), hPe = $e(LC, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: zC
})(Mt(({
  theme: e
}) => ({
  padding: "16.5px 14px",
  ...!e.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
      caretColor: e.palette.mode === "light" ? null : "#fff",
      borderRadius: "inherit"
    }
  },
  ...e.vars && {
    "&:-webkit-autofill": {
      borderRadius: "inherit"
    },
    [e.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      padding: "8.5px 14px"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      padding: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.endAdornment,
    style: {
      paddingRight: 0
    }
  }]
}))), wP = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiOutlinedInput"
  }), {
    components: r = {},
    fullWidth: a = !1,
    inputComponent: s = "input",
    label: l,
    multiline: c = !1,
    notched: d,
    slots: f = {},
    slotProps: m = {},
    type: h = "text",
    ...v
  } = n, g = fPe(n), b = Zl(), x = Hd({
    props: n,
    muiFormControl: b,
    states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
  }), w = {
    ...n,
    color: x.color || "primary",
    disabled: x.disabled,
    error: x.error,
    focused: x.focused,
    formControl: b,
    fullWidth: a,
    hiddenLabel: x.hiddenLabel,
    multiline: c,
    size: x.size,
    type: h
  }, k = f.root ?? r.Root ?? pPe, E = f.input ?? r.Input ?? hPe, [_, O] = Kn("notchedOutline", {
    elementType: mPe,
    className: g.notchedOutline,
    shouldForwardComponentProp: !0,
    ownerState: w,
    externalForwardedProps: {
      slots: f,
      slotProps: m
    },
    additionalProps: {
      label: l != null && l !== "" && x.required ? /* @__PURE__ */ C.jsxs(M.Fragment, {
        children: [l, "", "*"]
      }) : l
    }
  });
  return /* @__PURE__ */ C.jsx(vP, {
    slots: {
      root: k,
      input: E
    },
    slotProps: m,
    renderSuffix: (N) => /* @__PURE__ */ C.jsx(_, {
      ...O,
      notched: typeof d < "u" ? d : !!(N.startAdornment || N.filled || N.focused)
    }),
    fullWidth: a,
    inputComponent: s,
    multiline: c,
    ref: t,
    type: h,
    ...v,
    classes: {
      ...g,
      notchedOutline: null
    }
  });
});
wP.muiName = "Input";
function gPe(e) {
  return Ct("MuiFormLabel", e);
}
const Ux = St("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]), vPe = (e) => {
  const {
    classes: t,
    color: n,
    focused: r,
    disabled: a,
    error: s,
    filled: l,
    required: c
  } = e, d = {
    root: ["root", `color${qe(n)}`, a && "disabled", s && "error", l && "filled", r && "focused", c && "required"],
    asterisk: ["asterisk", s && "error"]
  };
  return Et(d, gPe, t);
}, yPe = $e("label", {
  name: "MuiFormLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color === "secondary" && t.colorSecondary, n.filled && t.filled];
  }
})(Mt(({
  theme: e
}) => ({
  color: (e.vars || e).palette.text.secondary,
  ...e.typography.body1,
  lineHeight: "1.4375em",
  padding: 0,
  position: "relative",
  variants: [...Object.entries(e.palette).filter(Zo()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      [`&.${Ux.focused}`]: {
        color: (e.vars || e).palette[t].main
      }
    }
  })), {
    props: {},
    style: {
      [`&.${Ux.disabled}`]: {
        color: (e.vars || e).palette.text.disabled
      },
      [`&.${Ux.error}`]: {
        color: (e.vars || e).palette.error.main
      }
    }
  }]
}))), bPe = $e("span", {
  name: "MuiFormLabel",
  slot: "Asterisk"
})(Mt(({
  theme: e
}) => ({
  [`&.${Ux.error}`]: {
    color: (e.vars || e).palette.error.main
  }
}))), FC = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiFormLabel"
  }), {
    children: r,
    className: a,
    color: s,
    component: l = "label",
    disabled: c,
    error: d,
    filled: f,
    focused: m,
    required: h,
    ...v
  } = n, g = Zl(), b = Hd({
    props: n,
    muiFormControl: g,
    states: ["color", "required", "focused", "disabled", "error", "filled"]
  }), x = {
    ...n,
    color: b.color || "primary",
    component: l,
    disabled: b.disabled,
    error: b.error,
    filled: b.filled,
    focused: b.focused,
    required: b.required
  }, w = vPe(x);
  return /* @__PURE__ */ C.jsxs(yPe, {
    as: l,
    ownerState: x,
    className: Ye(w.root, a),
    ref: t,
    ...v,
    children: [r, b.required && /* @__PURE__ */ C.jsxs(bPe, {
      ownerState: x,
      "aria-hidden": !0,
      className: w.asterisk,
      children: ["", "*"]
    })]
  });
});
function wPe(e) {
  return Ct("MuiInputLabel", e);
}
St("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const xPe = (e) => {
  const {
    classes: t,
    formControl: n,
    size: r,
    shrink: a,
    disableAnimation: s,
    variant: l,
    required: c
  } = e, d = {
    root: ["root", n && "formControl", !s && "animated", a && "shrink", r && r !== "medium" && `size${qe(r)}`, l],
    asterisk: [c && "asterisk"]
  }, f = Et(d, wPe, t);
  return {
    ...t,
    // forward the focused, disabled, etc. classes to the FormLabel
    ...f
  };
}, SPe = $e(FC, {
  shouldForwardProp: (e) => ea(e) || e === "classes",
  name: "MuiInputLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [{
      [`& .${Ux.asterisk}`]: t.asterisk
    }, t.root, n.formControl && t.formControl, n.size === "small" && t.sizeSmall, n.shrink && t.shrink, !n.disableAnimation && t.animated, n.focused && t.focused, t[n.variant]];
  }
})(Mt(({
  theme: e
}) => ({
  display: "block",
  transformOrigin: "top left",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  maxWidth: "100%",
  variants: [{
    props: ({
      ownerState: t
    }) => t.formControl,
    style: {
      position: "absolute",
      left: 0,
      top: 0,
      // slight alteration to spec spacing to match visual spec result
      transform: "translate(0, 20px) scale(1)"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      // Compensation for the `Input.inputSizeSmall` style.
      transform: "translate(0, 17px) scale(1)"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.shrink,
    style: {
      transform: "translate(0, -1.5px) scale(0.75)",
      transformOrigin: "top left",
      maxWidth: "133%"
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.disableAnimation,
    style: {
      transition: e.transitions.create(["color", "transform", "max-width"], {
        duration: e.transitions.duration.shorter,
        easing: e.transitions.easing.easeOut
      })
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      // Chrome's autofill feature gives the input field a yellow background.
      // Since the input field is behind the label in the HTML tree,
      // the input field is drawn last and hides the label with an opaque background color.
      // zIndex: 1 will raise the label above opaque background-colors of input.
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(12px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "filled",
      size: "small"
    },
    style: {
      transform: "translate(12px, 13px) scale(1)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: n
    }) => t === "filled" && n.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      transform: "translate(12px, 7px) scale(0.75)",
      maxWidth: "calc(133% - 24px)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: n,
      size: r
    }) => t === "filled" && n.shrink && r === "small",
    style: {
      transform: "translate(12px, 4px) scale(0.75)"
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      // see comment above on filled.zIndex
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(14px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "outlined",
      size: "small"
    },
    style: {
      transform: "translate(14px, 9px) scale(1)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: n
    }) => t === "outlined" && n.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      // Theoretically, we should have (8+5)*2/0.75 = 34px
      // but it feels a better when it bleeds a bit on the left, so 32px.
      maxWidth: "calc(133% - 32px)",
      transform: "translate(14px, -9px) scale(0.75)"
    }
  }]
}))), kPe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    name: "MuiInputLabel",
    props: e
  }), {
    disableAnimation: r = !1,
    margin: a,
    shrink: s,
    variant: l,
    className: c,
    ...d
  } = n, f = Zl();
  let m = s;
  typeof m > "u" && f && (m = f.filled || f.focused || f.adornedStart);
  const h = Hd({
    props: n,
    muiFormControl: f,
    states: ["size", "variant", "required", "focused"]
  }), v = {
    ...n,
    disableAnimation: r,
    formControl: f,
    shrink: m,
    size: h.size,
    variant: h.variant,
    required: h.required,
    focused: h.focused
  }, g = xPe(v);
  return /* @__PURE__ */ C.jsx(SPe, {
    "data-shrink": m,
    ref: t,
    className: Ye(g.root, c),
    ...d,
    ownerState: v,
    classes: g
  });
});
function _Pe(e) {
  return Ct("MuiFormControl", e);
}
St("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const EPe = (e) => {
  const {
    classes: t,
    margin: n,
    fullWidth: r
  } = e, a = {
    root: ["root", n !== "none" && `margin${qe(n)}`, r && "fullWidth"]
  };
  return Et(a, _Pe, t);
}, CPe = $e("div", {
  name: "MuiFormControl",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[`margin${qe(n.margin)}`], n.fullWidth && t.fullWidth];
  }
})({
  display: "inline-flex",
  flexDirection: "column",
  position: "relative",
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: "top",
  // Fix alignment issue on Safari.
  variants: [{
    props: {
      margin: "normal"
    },
    style: {
      marginTop: 16,
      marginBottom: 8
    }
  }, {
    props: {
      margin: "dense"
    },
    style: {
      marginTop: 8,
      marginBottom: 4
    }
  }, {
    props: {
      fullWidth: !0
    },
    style: {
      width: "100%"
    }
  }]
}), xP = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiFormControl"
  }), {
    children: r,
    className: a,
    color: s = "primary",
    component: l = "div",
    disabled: c = !1,
    error: d = !1,
    focused: f,
    fullWidth: m = !1,
    hiddenLabel: h = !1,
    margin: v = "none",
    required: g = !1,
    size: b = "medium",
    variant: x = "outlined",
    ...w
  } = n, k = {
    ...n,
    color: s,
    component: l,
    disabled: c,
    error: d,
    fullWidth: m,
    hiddenLabel: h,
    margin: v,
    required: g,
    size: b,
    variant: x
  }, E = EPe(k), [_, O] = M.useState(() => {
    let L = !1;
    return r && M.Children.forEach(r, (G) => {
      if (!Ax(G, ["Input", "Select"]))
        return;
      const $ = Ax(G, ["Select"]) ? G.props.input : G;
      $ && Jje($.props) && (L = !0);
    }), L;
  }), [N, A] = M.useState(() => {
    let L = !1;
    return r && M.Children.forEach(r, (G) => {
      Ax(G, ["Input", "Select"]) && (q2(G.props, !0) || q2(G.props.inputProps, !0)) && (L = !0);
    }), L;
  }), [R, D] = M.useState(!1);
  c && R && D(!1);
  const I = f !== void 0 && !c ? f : R;
  let z;
  M.useRef(!1);
  const B = M.useCallback(() => {
    A(!0);
  }, []), P = M.useCallback(() => {
    A(!1);
  }, []), H = M.useMemo(() => ({
    adornedStart: _,
    setAdornedStart: O,
    color: s,
    disabled: c,
    error: d,
    filled: N,
    focused: I,
    fullWidth: m,
    hiddenLabel: h,
    size: b,
    onBlur: () => {
      D(!1);
    },
    onFocus: () => {
      D(!0);
    },
    onEmpty: P,
    onFilled: B,
    registerEffect: z,
    required: g,
    variant: x
  }), [_, s, c, d, N, I, m, h, z, P, B, g, b, x]);
  return /* @__PURE__ */ C.jsx(gP.Provider, {
    value: H,
    children: /* @__PURE__ */ C.jsx(CPe, {
      as: l,
      ownerState: k,
      className: Ye(E.root, a),
      ref: t,
      ...w,
      children: r
    })
  });
});
function OPe(e) {
  return Ct("MuiFormHelperText", e);
}
const c9 = St("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
var d9;
const MPe = (e) => {
  const {
    classes: t,
    contained: n,
    size: r,
    disabled: a,
    error: s,
    filled: l,
    focused: c,
    required: d
  } = e, f = {
    root: ["root", a && "disabled", s && "error", r && `size${qe(r)}`, n && "contained", c && "focused", l && "filled", d && "required"]
  };
  return Et(f, OPe, t);
}, NPe = $e("p", {
  name: "MuiFormHelperText",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.size && t[`size${qe(n.size)}`], n.contained && t.contained, n.filled && t.filled];
  }
})(Mt(({
  theme: e
}) => ({
  color: (e.vars || e).palette.text.secondary,
  ...e.typography.caption,
  textAlign: "left",
  marginTop: 3,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  [`&.${c9.disabled}`]: {
    color: (e.vars || e).palette.text.disabled
  },
  [`&.${c9.error}`]: {
    color: (e.vars || e).palette.error.main
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginTop: 4
    }
  }, {
    props: ({
      ownerState: t
    }) => t.contained,
    style: {
      marginLeft: 14,
      marginRight: 14
    }
  }]
}))), SP = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiFormHelperText"
  }), {
    children: r,
    className: a,
    component: s = "p",
    disabled: l,
    error: c,
    filled: d,
    focused: f,
    margin: m,
    required: h,
    variant: v,
    ...g
  } = n, b = Zl(), x = Hd({
    props: n,
    muiFormControl: b,
    states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
  }), w = {
    ...n,
    component: s,
    contained: x.variant === "filled" || x.variant === "outlined",
    variant: x.variant,
    size: x.size,
    disabled: x.disabled,
    error: x.error,
    filled: x.filled,
    focused: x.focused,
    required: x.required
  };
  delete w.ownerState;
  const k = MPe(w);
  return /* @__PURE__ */ C.jsx(NPe, {
    as: s,
    className: Ye(k.root, a),
    ref: t,
    ...g,
    ownerState: w,
    children: r === " " ? (
      // notranslate needed while Google Translate will not fix zero-width space issue
      d9 || (d9 = /* @__PURE__ */ C.jsx("span", {
        className: "notranslate",
        "aria-hidden": !0,
        children: ""
      }))
    ) : r
  });
});
function Ok(e) {
  return parseInt(M.version, 10) >= 19 ? e?.props?.ref || null : e?.ref || null;
}
function Cc(e) {
  const {
    elementType: t,
    externalSlotProps: n,
    ownerState: r,
    skipResolvingSlotProps: a = !1,
    ...s
  } = e, l = a ? {} : U7(n, r), {
    props: c,
    internalRef: d
  } = V7({
    ...s,
    externalSlotProps: l
  }), f = io(d, l?.ref, e.additionalProps?.ref);
  return B7(t, {
    ...c,
    ref: f
  }, r);
}
const Dc = /* @__PURE__ */ M.createContext({});
function APe(e) {
  return Ct("MuiList", e);
}
St("MuiList", ["root", "padding", "dense", "subheader"]);
const RPe = (e) => {
  const {
    classes: t,
    disablePadding: n,
    dense: r,
    subheader: a
  } = e;
  return Et({
    root: ["root", !n && "padding", r && "dense", a && "subheader"]
  }, APe, t);
}, jPe = $e("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, !n.disablePadding && t.padding, n.dense && t.dense, n.subheader && t.subheader];
  }
})({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative",
  variants: [{
    props: ({
      ownerState: e
    }) => !e.disablePadding,
    style: {
      paddingTop: 8,
      paddingBottom: 8
    }
  }, {
    props: ({
      ownerState: e
    }) => e.subheader,
    style: {
      paddingTop: 0
    }
  }]
}), kP = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiList"
  }), {
    children: r,
    className: a,
    component: s = "ul",
    dense: l = !1,
    disablePadding: c = !1,
    subheader: d,
    ...f
  } = n, m = M.useMemo(() => ({
    dense: l
  }), [l]), h = {
    ...n,
    component: s,
    dense: l,
    disablePadding: c
  }, v = RPe(h);
  return /* @__PURE__ */ C.jsx(Dc.Provider, {
    value: m,
    children: /* @__PURE__ */ C.jsxs(jPe, {
      as: s,
      className: Ye(v.root, a),
      ref: t,
      ownerState: h,
      ...f,
      children: [d, r]
    })
  });
});
function _x(e) {
  let t = e.activeElement;
  for (; t?.shadowRoot?.activeElement != null; )
    t = t.shadowRoot.activeElement;
  return t;
}
function rY(e = window) {
  const t = e.document.documentElement.clientWidth;
  return e.innerWidth - t;
}
function U5(e, t, n) {
  return e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : n ? null : e.firstChild;
}
function f9(e, t, n) {
  return e === t ? n ? e.firstChild : e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : n ? null : e.lastChild;
}
function oY(e, t) {
  if (t === void 0)
    return !0;
  let n = e.innerText;
  return n === void 0 && (n = e.textContent), n = n.trim().toLowerCase(), n.length === 0 ? !1 : t.repeating ? n[0] === t.keys[0] : n.startsWith(t.keys.join(""));
}
function ix(e, t, n, r, a, s) {
  let l = !1, c = a(e, t, t ? n : !1);
  for (; c; ) {
    if (c === e.firstChild) {
      if (l)
        return !1;
      l = !0;
    }
    const d = r ? !1 : c.disabled || c.getAttribute("aria-disabled") === "true";
    if (!c.hasAttribute("tabindex") || !oY(c, s) || d)
      c = a(e, c, n);
    else
      return c.focus(), !0;
  }
  return !1;
}
const PPe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions: n,
    autoFocus: r = !1,
    autoFocusItem: a = !1,
    children: s,
    className: l,
    disabledItemsFocusable: c = !1,
    disableListWrap: d = !1,
    onKeyDown: f,
    variant: m = "selectedMenu",
    ...h
  } = e, v = M.useRef(null), g = M.useRef({
    keys: [],
    repeating: !0,
    previousKeyMatched: !0,
    lastTime: null
  });
  Zs(() => {
    r && v.current.focus();
  }, [r]), M.useImperativeHandle(n, () => ({
    adjustStyleForScrollbar: (E, {
      direction: _
    }) => {
      const O = !v.current.style.width;
      if (E.clientHeight < v.current.clientHeight && O) {
        const N = `${rY(Hc(E))}px`;
        v.current.style[_ === "rtl" ? "paddingLeft" : "paddingRight"] = N, v.current.style.width = `calc(100% + ${N})`;
      }
      return v.current;
    }
  }), []);
  const b = (E) => {
    const _ = v.current, O = E.key;
    if (E.ctrlKey || E.metaKey || E.altKey) {
      f && f(E);
      return;
    }
    const N = _x(Ca(_));
    if (O === "ArrowDown")
      E.preventDefault(), ix(_, N, d, c, U5);
    else if (O === "ArrowUp")
      E.preventDefault(), ix(_, N, d, c, f9);
    else if (O === "Home")
      E.preventDefault(), ix(_, null, d, c, U5);
    else if (O === "End")
      E.preventDefault(), ix(_, null, d, c, f9);
    else if (O.length === 1) {
      const A = g.current, R = O.toLowerCase(), D = performance.now();
      A.keys.length > 0 && (D - A.lastTime > 500 ? (A.keys = [], A.repeating = !0, A.previousKeyMatched = !0) : A.repeating && R !== A.keys[0] && (A.repeating = !1)), A.lastTime = D, A.keys.push(R);
      const I = N && !A.repeating && oY(N, A);
      A.previousKeyMatched && (I || ix(_, N, !1, c, U5, A)) ? E.preventDefault() : A.previousKeyMatched = !1;
    }
    f && f(E);
  }, x = io(v, t);
  let w = -1;
  M.Children.forEach(s, (E, _) => {
    if (!/* @__PURE__ */ M.isValidElement(E)) {
      w === _ && (w += 1, w >= s.length && (w = -1));
      return;
    }
    E.props.disabled || (m === "selectedMenu" && E.props.selected || w === -1) && (w = _), w === _ && (E.props.disabled || E.props.muiSkipListHighlight || E.type.muiSkipListHighlight) && (w += 1, w >= s.length && (w = -1));
  });
  const k = M.Children.map(s, (E, _) => {
    if (_ === w) {
      const O = {};
      return a && (O.autoFocus = !0), E.props.tabIndex === void 0 && m === "selectedMenu" && (O.tabIndex = 0), /* @__PURE__ */ M.cloneElement(E, O);
    }
    return E;
  });
  return /* @__PURE__ */ C.jsx(kP, {
    role: "menu",
    ref: x,
    className: l,
    onKeyDown: b,
    tabIndex: r ? 0 : -1,
    ...h,
    children: k
  });
}), DPe = a4(Xh.element);
DPe.isRequired = a4(Xh.element.isRequired);
const aY = (e) => e.scrollTop;
function G2(e, t) {
  const {
    timeout: n,
    easing: r,
    style: a = {}
  } = e;
  return {
    duration: a.transitionDuration ?? (typeof n == "number" ? n : n[t.mode] || 0),
    easing: a.transitionTimingFunction ?? (typeof r == "object" ? r[t.mode] : r),
    delay: a.transitionDelay
  };
}
function eR(e) {
  return `scale(${e}, ${e ** 2})`;
}
const IPe = {
  entering: {
    opacity: 1,
    transform: eR(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
}, V5 = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), tR = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const {
    addEndListener: n,
    appear: r = !0,
    children: a,
    easing: s,
    in: l,
    onEnter: c,
    onEntered: d,
    onEntering: f,
    onExit: m,
    onExited: h,
    onExiting: v,
    style: g,
    timeout: b = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent: x = Gl,
    ...w
  } = e, k = F7(), E = M.useRef(), _ = _E(), O = M.useRef(null), N = io(O, Ok(a), t), A = (L) => (G) => {
    if (L) {
      const $ = O.current;
      G === void 0 ? L($) : L($, G);
    }
  }, R = A(f), D = A((L, G) => {
    aY(L);
    const {
      duration: $,
      delay: K,
      easing: q
    } = G2({
      style: g,
      timeout: b,
      easing: s
    }, {
      mode: "enter"
    });
    let Z;
    b === "auto" ? (Z = _.transitions.getAutoHeightDuration(L.clientHeight), E.current = Z) : Z = $, L.style.transition = [_.transitions.create("opacity", {
      duration: Z,
      delay: K
    }), _.transitions.create("transform", {
      duration: V5 ? Z : Z * 0.666,
      delay: K,
      easing: q
    })].join(","), c && c(L, G);
  }), I = A(d), z = A(v), B = A((L) => {
    const {
      duration: G,
      delay: $,
      easing: K
    } = G2({
      style: g,
      timeout: b,
      easing: s
    }, {
      mode: "exit"
    });
    let q;
    b === "auto" ? (q = _.transitions.getAutoHeightDuration(L.clientHeight), E.current = q) : q = G, L.style.transition = [_.transitions.create("opacity", {
      duration: q,
      delay: $
    }), _.transitions.create("transform", {
      duration: V5 ? q : q * 0.666,
      delay: V5 ? $ : $ || q * 0.333,
      easing: K
    })].join(","), L.style.opacity = 0, L.style.transform = eR(0.75), m && m(L);
  }), P = A(h), H = (L) => {
    b === "auto" && k.start(E.current || 0, L), n && n(O.current, L);
  };
  return /* @__PURE__ */ C.jsx(x, {
    appear: r,
    in: l,
    nodeRef: O,
    onEnter: D,
    onEntered: I,
    onEntering: R,
    onExit: B,
    onExited: P,
    onExiting: z,
    addEndListener: H,
    timeout: b === "auto" ? null : b,
    ...w,
    children: (L, {
      ownerState: G,
      ...$
    }) => /* @__PURE__ */ M.cloneElement(a, {
      style: {
        opacity: 0,
        transform: eR(0.75),
        visibility: L === "exited" && !l ? "hidden" : void 0,
        ...IPe[L],
        ...g,
        ...a.props.style
      },
      ref: N,
      ...$
    })
  });
});
tR && (tR.muiSupportAuto = !0);
function $Pe(e) {
  const t = Ca(e);
  return t.body === e ? Hc(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight;
}
function Vx(e, t) {
  t ? e.setAttribute("aria-hidden", "true") : e.removeAttribute("aria-hidden");
}
function p9(e) {
  return parseInt(Hc(e).getComputedStyle(e).paddingRight, 10) || 0;
}
function zPe(e) {
  const t = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].includes(e.tagName), n = e.tagName === "INPUT" && e.getAttribute("type") === "hidden";
  return t || n;
}
function m9(e, t, n, r, a) {
  const s = [t, n, ...r];
  [].forEach.call(e.children, (l) => {
    const c = !s.includes(l), d = !zPe(l);
    c && d && Vx(l, a);
  });
}
function H5(e, t) {
  let n = -1;
  return e.some((r, a) => t(r) ? (n = a, !0) : !1), n;
}
function TPe(e, t) {
  const n = [], r = e.container;
  if (!t.disableScrollLock) {
    if ($Pe(r)) {
      const s = rY(Hc(r));
      n.push({
        value: r.style.paddingRight,
        property: "padding-right",
        el: r
      }), r.style.paddingRight = `${p9(r) + s}px`;
      const l = Ca(r).querySelectorAll(".mui-fixed");
      [].forEach.call(l, (c) => {
        n.push({
          value: c.style.paddingRight,
          property: "padding-right",
          el: c
        }), c.style.paddingRight = `${p9(c) + s}px`;
      });
    }
    let a;
    if (r.parentNode instanceof DocumentFragment)
      a = Ca(r).body;
    else {
      const s = r.parentElement, l = Hc(r);
      a = s?.nodeName === "HTML" && l.getComputedStyle(s).overflowY === "scroll" ? s : r;
    }
    n.push({
      value: a.style.overflow,
      property: "overflow",
      el: a
    }, {
      value: a.style.overflowX,
      property: "overflow-x",
      el: a
    }, {
      value: a.style.overflowY,
      property: "overflow-y",
      el: a
    }), a.style.overflow = "hidden";
  }
  return () => {
    n.forEach(({
      value: a,
      el: s,
      property: l
    }) => {
      a ? s.style.setProperty(l, a) : s.style.removeProperty(l);
    });
  };
}
function LPe(e) {
  const t = [];
  return [].forEach.call(e.children, (n) => {
    n.getAttribute("aria-hidden") === "true" && t.push(n);
  }), t;
}
class FPe {
  constructor() {
    this.modals = [], this.containers = [];
  }
  add(t, n) {
    let r = this.modals.indexOf(t);
    if (r !== -1)
      return r;
    r = this.modals.length, this.modals.push(t), t.modalRef && Vx(t.modalRef, !1);
    const a = LPe(n);
    m9(n, t.mount, t.modalRef, a, !0);
    const s = H5(this.containers, (l) => l.container === n);
    return s !== -1 ? (this.containers[s].modals.push(t), r) : (this.containers.push({
      modals: [t],
      container: n,
      restore: null,
      hiddenSiblings: a
    }), r);
  }
  mount(t, n) {
    const r = H5(this.containers, (s) => s.modals.includes(t)), a = this.containers[r];
    a.restore || (a.restore = TPe(a, n));
  }
  remove(t, n = !0) {
    const r = this.modals.indexOf(t);
    if (r === -1)
      return r;
    const a = H5(this.containers, (l) => l.modals.includes(t)), s = this.containers[a];
    if (s.modals.splice(s.modals.indexOf(t), 1), this.modals.splice(r, 1), s.modals.length === 0)
      s.restore && s.restore(), t.modalRef && Vx(t.modalRef, n), m9(s.container, t.mount, t.modalRef, s.hiddenSiblings, !1), this.containers.splice(a, 1);
    else {
      const l = s.modals[s.modals.length - 1];
      l.modalRef && Vx(l.modalRef, !1);
    }
    return r;
  }
  isTopModal(t) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === t;
  }
}
const BPe = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function UPe(e) {
  const t = parseInt(e.getAttribute("tabindex") || "", 10);
  return Number.isNaN(t) ? e.contentEditable === "true" || (e.nodeName === "AUDIO" || e.nodeName === "VIDEO" || e.nodeName === "DETAILS") && e.getAttribute("tabindex") === null ? 0 : e.tabIndex : t;
}
function VPe(e) {
  if (e.tagName !== "INPUT" || e.type !== "radio" || !e.name)
    return !1;
  const t = (r) => e.ownerDocument.querySelector(`input[type="radio"]${r}`);
  let n = t(`[name="${e.name}"]:checked`);
  return n || (n = t(`[name="${e.name}"]`)), n !== e;
}
function HPe(e) {
  return !(e.disabled || e.tagName === "INPUT" && e.type === "hidden" || VPe(e));
}
function WPe(e) {
  const t = [], n = [];
  return Array.from(e.querySelectorAll(BPe)).forEach((r, a) => {
    const s = UPe(r);
    s === -1 || !HPe(r) || (s === 0 ? t.push(r) : n.push({
      documentOrder: a,
      tabIndex: s,
      node: r
    }));
  }), n.sort((r, a) => r.tabIndex === a.tabIndex ? r.documentOrder - a.documentOrder : r.tabIndex - a.tabIndex).map((r) => r.node).concat(t);
}
function qPe() {
  return !0;
}
function GPe(e) {
  const {
    children: t,
    disableAutoFocus: n = !1,
    disableEnforceFocus: r = !1,
    disableRestoreFocus: a = !1,
    getTabbable: s = WPe,
    isEnabled: l = qPe,
    open: c
  } = e, d = M.useRef(!1), f = M.useRef(null), m = M.useRef(null), h = M.useRef(null), v = M.useRef(null), g = M.useRef(!1), b = M.useRef(null), x = io(Ok(t), b), w = M.useRef(null);
  M.useEffect(() => {
    !c || !b.current || (g.current = !n);
  }, [n, c]), M.useEffect(() => {
    if (!c || !b.current)
      return;
    const _ = Ca(b.current), O = _x(_);
    return b.current.contains(O) || (b.current.hasAttribute("tabIndex") || b.current.setAttribute("tabIndex", "-1"), g.current && b.current.focus()), () => {
      a || (h.current && h.current.focus && (d.current = !0, h.current.focus()), h.current = null);
    };
  }, [c]), M.useEffect(() => {
    if (!c || !b.current)
      return;
    const _ = Ca(b.current), O = _x(_), N = (D) => {
      w.current = D, !(r || !l() || D.key !== "Tab") && O === b.current && D.shiftKey && (d.current = !0, m.current && m.current.focus());
    }, A = () => {
      const D = b.current;
      if (D === null)
        return;
      const I = _x(_);
      if (!_.hasFocus() || !l() || d.current) {
        d.current = !1;
        return;
      }
      if (D.contains(I) || r && I !== f.current && I !== m.current)
        return;
      if (I !== v.current)
        v.current = null;
      else if (v.current !== null)
        return;
      if (!g.current)
        return;
      let z = [];
      if ((I === f.current || I === m.current) && (z = s(b.current)), z.length > 0) {
        const B = !!(w.current?.shiftKey && w.current?.key === "Tab"), P = z[0], H = z[z.length - 1];
        typeof P != "string" && typeof H != "string" && (B ? H.focus() : P.focus());
      } else
        D.focus();
    };
    _.addEventListener("focusin", A), _.addEventListener("keydown", N, !0);
    const R = setInterval(() => {
      const D = _x(_);
      D && D.tagName === "BODY" && A();
    }, 50);
    return () => {
      clearInterval(R), _.removeEventListener("focusin", A), _.removeEventListener("keydown", N, !0);
    };
  }, [n, r, a, l, c, s]);
  const k = (_) => {
    h.current === null && (h.current = _.relatedTarget), g.current = !0, v.current = _.target;
    const O = t.props.onFocus;
    O && O(_);
  }, E = (_) => {
    h.current === null && (h.current = _.relatedTarget), g.current = !0;
  };
  return /* @__PURE__ */ C.jsxs(M.Fragment, {
    children: [/* @__PURE__ */ C.jsx("div", {
      tabIndex: c ? 0 : -1,
      onFocus: E,
      ref: f,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ M.cloneElement(t, {
      ref: x,
      onFocus: k
    }), /* @__PURE__ */ C.jsx("div", {
      tabIndex: c ? 0 : -1,
      onFocus: E,
      ref: m,
      "data-testid": "sentinelEnd"
    })]
  });
}
function KPe(e) {
  return typeof e == "function" ? e() : e;
}
const YPe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const {
    children: n,
    container: r,
    disablePortal: a = !1
  } = e, [s, l] = M.useState(null), c = io(/* @__PURE__ */ M.isValidElement(n) ? Ok(n) : null, t);
  if (Zs(() => {
    a || l(KPe(r) || document.body);
  }, [r, a]), Zs(() => {
    if (s && !a)
      return n9(t, s), () => {
        n9(t, null);
      };
  }, [t, s, a]), a) {
    if (/* @__PURE__ */ M.isValidElement(n)) {
      const d = {
        ref: c
      };
      return /* @__PURE__ */ M.cloneElement(n, d);
    }
    return n;
  }
  return s && /* @__PURE__ */ Xm.createPortal(n, s);
}), XPe = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
}, JPe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = _E(), r = {
    enter: n.transitions.duration.enteringScreen,
    exit: n.transitions.duration.leavingScreen
  }, {
    addEndListener: a,
    appear: s = !0,
    children: l,
    easing: c,
    in: d,
    onEnter: f,
    onEntered: m,
    onEntering: h,
    onExit: v,
    onExited: g,
    onExiting: b,
    style: x,
    timeout: w = r,
    // eslint-disable-next-line react/prop-types
    TransitionComponent: k = Gl,
    ...E
  } = e, _ = M.useRef(null), O = io(_, Ok(l), t), N = (H) => (L) => {
    if (H) {
      const G = _.current;
      L === void 0 ? H(G) : H(G, L);
    }
  }, A = N(h), R = N((H, L) => {
    aY(H);
    const G = G2({
      style: x,
      timeout: w,
      easing: c
    }, {
      mode: "enter"
    });
    H.style.webkitTransition = n.transitions.create("opacity", G), H.style.transition = n.transitions.create("opacity", G), f && f(H, L);
  }), D = N(m), I = N(b), z = N((H) => {
    const L = G2({
      style: x,
      timeout: w,
      easing: c
    }, {
      mode: "exit"
    });
    H.style.webkitTransition = n.transitions.create("opacity", L), H.style.transition = n.transitions.create("opacity", L), v && v(H);
  }), B = N(g), P = (H) => {
    a && a(_.current, H);
  };
  return /* @__PURE__ */ C.jsx(k, {
    appear: s,
    in: d,
    nodeRef: _,
    onEnter: R,
    onEntered: D,
    onEntering: A,
    onExit: z,
    onExited: B,
    onExiting: I,
    addEndListener: P,
    timeout: w,
    ...E,
    children: (H, {
      ownerState: L,
      ...G
    }) => /* @__PURE__ */ M.cloneElement(l, {
      style: {
        opacity: 0,
        visibility: H === "exited" && !d ? "hidden" : void 0,
        ...XPe[H],
        ...x,
        ...l.props.style
      },
      ref: O,
      ...G
    })
  });
});
function QPe(e) {
  return Ct("MuiBackdrop", e);
}
St("MuiBackdrop", ["root", "invisible"]);
const ZPe = (e) => {
  const {
    classes: t,
    invisible: n
  } = e;
  return Et({
    root: ["root", n && "invisible"]
  }, QPe, t);
}, e1e = $e("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.invisible && t.invisible];
  }
})({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent",
  variants: [{
    props: {
      invisible: !0
    },
    style: {
      backgroundColor: "transparent"
    }
  }]
}), t1e = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiBackdrop"
  }), {
    children: r,
    className: a,
    component: s = "div",
    invisible: l = !1,
    open: c,
    components: d = {},
    componentsProps: f = {},
    slotProps: m = {},
    slots: h = {},
    TransitionComponent: v,
    transitionDuration: g,
    ...b
  } = n, x = {
    ...n,
    component: s,
    invisible: l
  }, w = ZPe(x), k = {
    transition: v,
    root: d.Root,
    ...h
  }, E = {
    ...f,
    ...m
  }, _ = {
    component: s,
    slots: k,
    slotProps: E
  }, [O, N] = Kn("root", {
    elementType: e1e,
    externalForwardedProps: _,
    className: Ye(w.root, a),
    ownerState: x
  }), [A, R] = Kn("transition", {
    elementType: JPe,
    externalForwardedProps: _,
    ownerState: x
  });
  return /* @__PURE__ */ C.jsx(A, {
    in: c,
    timeout: g,
    ...b,
    ...R,
    children: /* @__PURE__ */ C.jsx(O, {
      "aria-hidden": !0,
      ...N,
      classes: w,
      ref: t,
      children: r
    })
  });
});
function n1e(e) {
  return typeof e == "function" ? e() : e;
}
function r1e(e) {
  return e ? e.props.hasOwnProperty("in") : !1;
}
const h9 = () => {
}, a_ = new FPe();
function o1e(e) {
  const {
    container: t,
    disableEscapeKeyDown: n = !1,
    disableScrollLock: r = !1,
    closeAfterTransition: a = !1,
    onTransitionEnter: s,
    onTransitionExited: l,
    children: c,
    onClose: d,
    open: f,
    rootRef: m
  } = e, h = M.useRef({}), v = M.useRef(null), g = M.useRef(null), b = io(g, m), [x, w] = M.useState(!f), k = r1e(c);
  let E = !0;
  (e["aria-hidden"] === "false" || e["aria-hidden"] === !1) && (E = !1);
  const _ = () => Ca(v.current), O = () => (h.current.modalRef = g.current, h.current.mount = v.current, h.current), N = () => {
    a_.mount(O(), {
      disableScrollLock: r
    }), g.current && (g.current.scrollTop = 0);
  }, A = Tl(() => {
    const P = n1e(t) || _().body;
    a_.add(O(), P), g.current && N();
  }), R = () => a_.isTopModal(O()), D = Tl((P) => {
    v.current = P, P && (f && R() ? N() : g.current && Vx(g.current, E));
  }), I = M.useCallback(() => {
    a_.remove(O(), E);
  }, [E]);
  M.useEffect(() => () => {
    I();
  }, [I]), M.useEffect(() => {
    f ? A() : (!k || !a) && I();
  }, [f, I, k, a, A]);
  const z = (P) => (H) => {
    P.onKeyDown?.(H), !(H.key !== "Escape" || H.which === 229 || // Wait until IME is settled.
    !R()) && (n || (H.stopPropagation(), d && d(H, "escapeKeyDown")));
  }, B = (P) => (H) => {
    P.onClick?.(H), H.target === H.currentTarget && d && d(H, "backdropClick");
  };
  return {
    getRootProps: (P = {}) => {
      const H = Rx(e);
      delete H.onTransitionEnter, delete H.onTransitionExited;
      const L = {
        ...H,
        ...P
      };
      return {
        /*
         * Marking an element with the role presentation indicates to assistive technology
         * that this element should be ignored; it exists to support the web application and
         * is not meant for humans to interact with directly.
         * https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md
         */
        role: "presentation",
        ...L,
        onKeyDown: z(L),
        ref: b
      };
    },
    getBackdropProps: (P = {}) => {
      const H = P;
      return {
        "aria-hidden": !0,
        ...H,
        onClick: B(H),
        open: f
      };
    },
    getTransitionProps: () => {
      const P = () => {
        w(!1), s && s();
      }, H = () => {
        w(!0), l && l(), a && I();
      };
      return {
        onEnter: J3(P, c?.props.onEnter ?? h9),
        onExited: J3(H, c?.props.onExited ?? h9)
      };
    },
    rootRef: b,
    portalRef: D,
    isTopModal: R,
    exited: x,
    hasTransition: k
  };
}
function a1e(e) {
  return Ct("MuiModal", e);
}
St("MuiModal", ["root", "hidden", "backdrop"]);
const i1e = (e) => {
  const {
    open: t,
    exited: n,
    classes: r
  } = e;
  return Et({
    root: ["root", !t && n && "hidden"],
    backdrop: ["backdrop"]
  }, a1e, r);
}, s1e = $e("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, !n.open && n.exited && t.hidden];
  }
})(Mt(({
  theme: e
}) => ({
  position: "fixed",
  zIndex: (e.vars || e).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  variants: [{
    props: ({
      ownerState: t
    }) => !t.open && t.exited,
    style: {
      visibility: "hidden"
    }
  }]
}))), l1e = $e(t1e, {
  name: "MuiModal",
  slot: "Backdrop"
})({
  zIndex: -1
}), u1e = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    name: "MuiModal",
    props: e
  }), {
    BackdropComponent: r = l1e,
    BackdropProps: a,
    classes: s,
    className: l,
    closeAfterTransition: c = !1,
    children: d,
    container: f,
    component: m,
    components: h = {},
    componentsProps: v = {},
    disableAutoFocus: g = !1,
    disableEnforceFocus: b = !1,
    disableEscapeKeyDown: x = !1,
    disablePortal: w = !1,
    disableRestoreFocus: k = !1,
    disableScrollLock: E = !1,
    hideBackdrop: _ = !1,
    keepMounted: O = !1,
    onClose: N,
    onTransitionEnter: A,
    onTransitionExited: R,
    open: D,
    slotProps: I = {},
    slots: z = {},
    // eslint-disable-next-line react/prop-types
    theme: B,
    ...P
  } = n, H = {
    ...n,
    closeAfterTransition: c,
    disableAutoFocus: g,
    disableEnforceFocus: b,
    disableEscapeKeyDown: x,
    disablePortal: w,
    disableRestoreFocus: k,
    disableScrollLock: E,
    hideBackdrop: _,
    keepMounted: O
  }, {
    getRootProps: L,
    getBackdropProps: G,
    getTransitionProps: $,
    portalRef: K,
    isTopModal: q,
    exited: Z,
    hasTransition: V
  } = o1e({
    ...H,
    rootRef: t
  }), F = {
    ...H,
    exited: Z
  }, Y = i1e(F), U = {};
  if (d.props.tabIndex === void 0 && (U.tabIndex = "-1"), V) {
    const {
      onEnter: ce,
      onExited: ge
    } = $();
    U.onEnter = ce, U.onExited = ge;
  }
  const W = {
    slots: {
      root: h.Root,
      backdrop: h.Backdrop,
      ...z
    },
    slotProps: {
      ...v,
      ...I
    }
  }, [J, oe] = Kn("root", {
    ref: t,
    elementType: s1e,
    externalForwardedProps: {
      ...W,
      ...P,
      component: m
    },
    getSlotProps: L,
    ownerState: F,
    className: Ye(l, Y?.root, !F.open && F.exited && Y?.hidden)
  }), [fe, ie] = Kn("backdrop", {
    ref: a?.ref,
    elementType: r,
    externalForwardedProps: W,
    shouldForwardComponentProp: !0,
    additionalProps: a,
    getSlotProps: (ce) => G({
      ...ce,
      onClick: (ge) => {
        ce?.onClick && ce.onClick(ge);
      }
    }),
    className: Ye(a?.className, Y?.backdrop),
    ownerState: F
  });
  return !O && !D && (!V || Z) ? null : /* @__PURE__ */ C.jsx(YPe, {
    ref: K,
    container: f,
    disablePortal: w,
    children: /* @__PURE__ */ C.jsxs(J, {
      ...oe,
      children: [!_ && r ? /* @__PURE__ */ C.jsx(fe, {
        ...ie
      }) : null, /* @__PURE__ */ C.jsx(GPe, {
        disableEnforceFocus: b,
        disableAutoFocus: g,
        disableRestoreFocus: k,
        isEnabled: q,
        open: D,
        children: /* @__PURE__ */ M.cloneElement(d, U)
      })]
    })
  });
});
function c1e(e) {
  return Ct("MuiPopover", e);
}
St("MuiPopover", ["root", "paper"]);
function g9(e, t) {
  let n = 0;
  return typeof t == "number" ? n = t : t === "center" ? n = e.height / 2 : t === "bottom" && (n = e.height), n;
}
function v9(e, t) {
  let n = 0;
  return typeof t == "number" ? n = t : t === "center" ? n = e.width / 2 : t === "right" && (n = e.width), n;
}
function y9(e) {
  return [e.horizontal, e.vertical].map((t) => typeof t == "number" ? `${t}px` : t).join(" ");
}
function i_(e) {
  return typeof e == "function" ? e() : e;
}
const d1e = (e) => {
  const {
    classes: t
  } = e;
  return Et({
    root: ["root"],
    paper: ["paper"]
  }, c1e, t);
}, f1e = $e(u1e, {
  name: "MuiPopover",
  slot: "Root"
})({}), iY = $e(IC, {
  name: "MuiPopover",
  slot: "Paper"
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), p1e = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiPopover"
  }), {
    action: r,
    anchorEl: a,
    anchorOrigin: s = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition: l,
    anchorReference: c = "anchorEl",
    children: d,
    className: f,
    container: m,
    elevation: h = 8,
    marginThreshold: v = 16,
    open: g,
    PaperProps: b = {},
    // TODO: remove in v7
    slots: x = {},
    slotProps: w = {},
    transformOrigin: k = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent: E,
    // TODO: remove in v7
    transitionDuration: _ = "auto",
    TransitionProps: O = {},
    // TODO: remove in v7
    disableScrollLock: N = !1,
    ...A
  } = n, R = M.useRef(), D = {
    ...n,
    anchorOrigin: s,
    anchorReference: c,
    elevation: h,
    marginThreshold: v,
    transformOrigin: k,
    TransitionComponent: E,
    transitionDuration: _,
    TransitionProps: O
  }, I = d1e(D), z = M.useCallback(() => {
    if (c === "anchorPosition")
      return l;
    const ce = i_(a), ge = ce && ce.nodeType === 1 ? ce : Ca(R.current).body, re = ge.getBoundingClientRect();
    return {
      top: re.top + g9(re, s.vertical),
      left: re.left + v9(re, s.horizontal)
    };
  }, [a, s.horizontal, s.vertical, l, c]), B = M.useCallback((ce) => ({
    vertical: g9(ce, k.vertical),
    horizontal: v9(ce, k.horizontal)
  }), [k.horizontal, k.vertical]), P = M.useCallback((ce) => {
    const ge = {
      width: ce.offsetWidth,
      height: ce.offsetHeight
    }, re = B(ge);
    if (c === "none")
      return {
        top: null,
        left: null,
        transformOrigin: y9(re)
      };
    const le = z();
    let me = le.top - re.vertical, ve = le.left - re.horizontal;
    const xe = me + ge.height, _e = ve + ge.width, Ge = Hc(i_(a)), Xe = Ge.innerHeight - v, tt = Ge.innerWidth - v;
    if (v !== null && me < v) {
      const nt = me - v;
      me -= nt, re.vertical += nt;
    } else if (v !== null && xe > Xe) {
      const nt = xe - Xe;
      me -= nt, re.vertical += nt;
    }
    if (v !== null && ve < v) {
      const nt = ve - v;
      ve -= nt, re.horizontal += nt;
    } else if (_e > tt) {
      const nt = _e - tt;
      ve -= nt, re.horizontal += nt;
    }
    return {
      top: `${Math.round(me)}px`,
      left: `${Math.round(ve)}px`,
      transformOrigin: y9(re)
    };
  }, [a, c, z, B, v]), [H, L] = M.useState(g), G = M.useCallback(() => {
    const ce = R.current;
    if (!ce)
      return;
    const ge = P(ce);
    ge.top !== null && ce.style.setProperty("top", ge.top), ge.left !== null && (ce.style.left = ge.left), ce.style.transformOrigin = ge.transformOrigin, L(!0);
  }, [P]);
  M.useEffect(() => (N && window.addEventListener("scroll", G), () => window.removeEventListener("scroll", G)), [a, N, G]);
  const $ = () => {
    G();
  }, K = () => {
    L(!1);
  };
  M.useEffect(() => {
    g && G();
  }), M.useImperativeHandle(r, () => g ? {
    updatePosition: () => {
      G();
    }
  } : null, [g, G]), M.useEffect(() => {
    if (!g)
      return;
    const ce = QK(() => {
      G();
    }), ge = Hc(i_(a));
    return ge.addEventListener("resize", ce), () => {
      ce.clear(), ge.removeEventListener("resize", ce);
    };
  }, [a, g, G]);
  let q = _;
  const Z = {
    slots: {
      transition: E,
      ...x
    },
    slotProps: {
      transition: O,
      paper: b,
      ...w
    }
  }, [V, F] = Kn("transition", {
    elementType: tR,
    externalForwardedProps: Z,
    ownerState: D,
    getSlotProps: (ce) => ({
      ...ce,
      onEntering: (ge, re) => {
        ce.onEntering?.(ge, re), $();
      },
      onExited: (ge) => {
        ce.onExited?.(ge), K();
      }
    }),
    additionalProps: {
      appear: !0,
      in: g
    }
  });
  _ === "auto" && !V.muiSupportAuto && (q = void 0);
  const Y = m || (a ? Ca(i_(a)).body : void 0), [U, {
    slots: W,
    slotProps: J,
    ...oe
  }] = Kn("root", {
    ref: t,
    elementType: f1e,
    externalForwardedProps: {
      ...Z,
      ...A
    },
    shouldForwardComponentProp: !0,
    additionalProps: {
      slots: {
        backdrop: x.backdrop
      },
      slotProps: {
        backdrop: ZK(typeof w.backdrop == "function" ? w.backdrop(D) : w.backdrop, {
          invisible: !0
        })
      },
      container: Y,
      open: g
    },
    ownerState: D,
    className: Ye(I.root, f)
  }), [fe, ie] = Kn("paper", {
    ref: R,
    className: I.paper,
    elementType: iY,
    externalForwardedProps: Z,
    shouldForwardComponentProp: !0,
    additionalProps: {
      elevation: h,
      style: H ? void 0 : {
        opacity: 0
      }
    },
    ownerState: D
  });
  return /* @__PURE__ */ C.jsx(U, {
    ...oe,
    ...!Ll(U) && {
      slots: W,
      slotProps: J,
      disableScrollLock: N
    },
    children: /* @__PURE__ */ C.jsx(V, {
      ...F,
      timeout: q,
      children: /* @__PURE__ */ C.jsx(fe, {
        ...ie,
        children: d
      })
    })
  });
});
function m1e(e) {
  return Ct("MuiMenu", e);
}
St("MuiMenu", ["root", "paper", "list"]);
const h1e = {
  vertical: "top",
  horizontal: "right"
}, g1e = {
  vertical: "top",
  horizontal: "left"
}, v1e = (e) => {
  const {
    classes: t
  } = e;
  return Et({
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  }, m1e, t);
}, y1e = $e(p1e, {
  shouldForwardProp: (e) => ea(e) || e === "classes",
  name: "MuiMenu",
  slot: "Root"
})({}), b1e = $e(iY, {
  name: "MuiMenu",
  slot: "Paper"
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
}), w1e = $e(PPe, {
  name: "MuiMenu",
  slot: "List"
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), x1e = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiMenu"
  }), {
    autoFocus: r = !0,
    children: a,
    className: s,
    disableAutoFocusItem: l = !1,
    MenuListProps: c = {},
    onClose: d,
    open: f,
    PaperProps: m = {},
    PopoverClasses: h,
    transitionDuration: v = "auto",
    TransitionProps: {
      onEntering: g,
      ...b
    } = {},
    variant: x = "selectedMenu",
    slots: w = {},
    slotProps: k = {},
    ...E
  } = n, _ = O7(), O = {
    ...n,
    autoFocus: r,
    disableAutoFocusItem: l,
    MenuListProps: c,
    onEntering: g,
    PaperProps: m,
    transitionDuration: v,
    TransitionProps: b,
    variant: x
  }, N = v1e(O), A = r && !l && f, R = M.useRef(null), D = (q, Z) => {
    R.current && R.current.adjustStyleForScrollbar(q, {
      direction: _ ? "rtl" : "ltr"
    }), g && g(q, Z);
  }, I = (q) => {
    q.key === "Tab" && (q.preventDefault(), d && d(q, "tabKeyDown"));
  };
  let z = -1;
  M.Children.map(a, (q, Z) => {
    /* @__PURE__ */ M.isValidElement(q) && (q.props.disabled || (x === "selectedMenu" && q.props.selected || z === -1) && (z = Z));
  });
  const B = {
    slots: w,
    slotProps: {
      list: c,
      transition: b,
      paper: m,
      ...k
    }
  }, P = Cc({
    elementType: w.root,
    externalSlotProps: k.root,
    ownerState: O,
    className: [N.root, s]
  }), [H, L] = Kn("paper", {
    className: N.paper,
    elementType: b1e,
    externalForwardedProps: B,
    shouldForwardComponentProp: !0,
    ownerState: O
  }), [G, $] = Kn("list", {
    className: Ye(N.list, c.className),
    elementType: w1e,
    shouldForwardComponentProp: !0,
    externalForwardedProps: B,
    getSlotProps: (q) => ({
      ...q,
      onKeyDown: (Z) => {
        I(Z), q.onKeyDown?.(Z);
      }
    }),
    ownerState: O
  }), K = typeof B.slotProps.transition == "function" ? B.slotProps.transition(O) : B.slotProps.transition;
  return /* @__PURE__ */ C.jsx(y1e, {
    onClose: d,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: _ ? "right" : "left"
    },
    transformOrigin: _ ? h1e : g1e,
    slots: {
      root: w.root,
      paper: H,
      backdrop: w.backdrop,
      ...w.transition && {
        // TODO: pass `slots.transition` directly once `TransitionComponent` is removed from Popover
        transition: w.transition
      }
    },
    slotProps: {
      root: P,
      paper: L,
      backdrop: typeof k.backdrop == "function" ? k.backdrop(O) : k.backdrop,
      transition: {
        ...K,
        onEntering: (...q) => {
          D(...q), K?.onEntering?.(...q);
        }
      }
    },
    open: f,
    ref: t,
    transitionDuration: v,
    ownerState: O,
    ...E,
    classes: h,
    children: /* @__PURE__ */ C.jsx(G, {
      actions: R,
      autoFocus: r && (z === -1 || l),
      autoFocusItem: A,
      variant: x,
      ...$,
      children: a
    })
  });
});
function S1e(e) {
  return Ct("MuiNativeSelect", e);
}
const _P = St("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]), k1e = (e) => {
  const {
    classes: t,
    variant: n,
    disabled: r,
    multiple: a,
    open: s,
    error: l
  } = e, c = {
    select: ["select", n, r && "disabled", a && "multiple", l && "error"],
    icon: ["icon", `icon${qe(n)}`, s && "iconOpen", r && "disabled"]
  };
  return Et(c, S1e, t);
}, sY = $e("select", {
  name: "MuiNativeSelect"
})(({
  theme: e
}) => ({
  // Reset
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  // Reset
  borderRadius: 0,
  cursor: "pointer",
  "&:focus": {
    // Reset Chrome style
    borderRadius: 0
  },
  [`&.${_P.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (e.vars || e).palette.background.paper
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.variant !== "filled" && t.variant !== "outlined",
    style: {
      // Bump specificity to allow extending custom inputs
      "&&&": {
        paddingRight: 24,
        minWidth: 16
        // So it doesn't collapse.
      }
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      "&&&": {
        paddingRight: 32
      }
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      borderRadius: (e.vars || e).shape.borderRadius,
      "&:focus": {
        borderRadius: (e.vars || e).shape.borderRadius
        // Reset the reset for Chrome style
      },
      "&&&": {
        paddingRight: 32
      }
    }
  }]
})), _1e = $e(sY, {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: ea,
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.select, t[n.variant], n.error && t.error, {
      [`&.${_P.multiple}`]: t.multiple
    }];
  }
})({}), lY = $e("svg", {
  name: "MuiNativeSelect"
})(({
  theme: e
}) => ({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  // Center vertically, height is 1em
  top: "calc(50% - .5em)",
  // Don't block pointer events on the select under the icon.
  pointerEvents: "none",
  color: (e.vars || e).palette.action.active,
  [`&.${_P.disabled}`]: {
    color: (e.vars || e).palette.action.disabled
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.open,
    style: {
      transform: "rotate(180deg)"
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      right: 7
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      right: 7
    }
  }]
})), E1e = $e(lY, {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, n.variant && t[`icon${qe(n.variant)}`], n.open && t.iconOpen];
  }
})({}), C1e = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const {
    className: n,
    disabled: r,
    error: a,
    IconComponent: s,
    inputRef: l,
    variant: c = "standard",
    ...d
  } = e, f = {
    ...e,
    disabled: r,
    variant: c,
    error: a
  }, m = k1e(f);
  return /* @__PURE__ */ C.jsxs(M.Fragment, {
    children: [/* @__PURE__ */ C.jsx(_1e, {
      ownerState: f,
      className: Ye(m.select, n),
      disabled: r,
      ref: l || t,
      ...d
    }), e.multiple ? null : /* @__PURE__ */ C.jsx(E1e, {
      as: s,
      ownerState: f,
      className: m.icon
    })]
  });
});
function uY(e) {
  return Ct("MuiSelect", e);
}
const sx = St("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
var b9;
const O1e = $e(sY, {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [
      // Win specificity over the input base
      {
        [`&.${sx.select}`]: t.select
      },
      {
        [`&.${sx.select}`]: t[n.variant]
      },
      {
        [`&.${sx.error}`]: t.error
      },
      {
        [`&.${sx.multiple}`]: t.multiple
      }
    ];
  }
})({
  // Win specificity over the input base
  [`&.${sx.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
}), M1e = $e(lY, {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, n.variant && t[`icon${qe(n.variant)}`], n.open && t.iconOpen];
  }
})({}), N1e = $e("input", {
  shouldForwardProp: (e) => EE(e) && e !== "classes",
  name: "MuiSelect",
  slot: "NativeInput"
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function w9(e, t) {
  return typeof t == "object" && t !== null ? e === t : String(e) === String(t);
}
function A1e(e) {
  return e == null || typeof e == "string" && !e.trim();
}
const R1e = (e) => {
  const {
    classes: t,
    variant: n,
    disabled: r,
    multiple: a,
    open: s,
    error: l
  } = e, c = {
    select: ["select", n, r && "disabled", a && "multiple", l && "error"],
    icon: ["icon", `icon${qe(n)}`, s && "iconOpen", r && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return Et(c, uY, t);
}, j1e = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const {
    "aria-describedby": n,
    "aria-label": r,
    autoFocus: a,
    autoWidth: s,
    children: l,
    className: c,
    defaultOpen: d,
    defaultValue: f,
    disabled: m,
    displayEmpty: h,
    error: v = !1,
    IconComponent: g,
    inputRef: b,
    labelId: x,
    MenuProps: w = {},
    multiple: k,
    name: E,
    onBlur: _,
    onChange: O,
    onClose: N,
    onFocus: A,
    // eslint-disable-next-line react/prop-types
    onKeyDown: R,
    // eslint-disable-next-line react/prop-types
    onMouseDown: D,
    onOpen: I,
    open: z,
    readOnly: B,
    renderValue: P,
    required: H,
    SelectDisplayProps: L = {},
    tabIndex: G,
    // catching `type` from Input which makes no sense for SelectInput
    type: $,
    value: K,
    variant: q = "standard",
    ...Z
  } = e, [V, F] = RS({
    controlled: K,
    default: f,
    name: "Select"
  }), [Y, U] = RS({
    controlled: z,
    default: d,
    name: "Select"
  }), W = M.useRef(null), J = M.useRef(null), [oe, fe] = M.useState(null), {
    current: ie
  } = M.useRef(z != null), [ce, ge] = M.useState(), re = io(t, b), le = M.useCallback((Ae) => {
    J.current = Ae, Ae && fe(Ae);
  }, []), me = oe?.parentNode;
  M.useImperativeHandle(re, () => ({
    focus: () => {
      J.current.focus();
    },
    node: W.current,
    value: V
  }), [V]), M.useEffect(() => {
    d && Y && oe && !ie && (ge(s ? null : me.clientWidth), J.current.focus());
  }, [oe, s]), M.useEffect(() => {
    a && J.current.focus();
  }, [a]), M.useEffect(() => {
    if (!x)
      return;
    const Ae = Ca(J.current).getElementById(x);
    if (Ae) {
      const Ht = () => {
        getSelection().isCollapsed && J.current.focus();
      };
      return Ae.addEventListener("click", Ht), () => {
        Ae.removeEventListener("click", Ht);
      };
    }
  }, [x]);
  const ve = (Ae, Ht) => {
    Ae ? I && I(Ht) : N && N(Ht), ie || (ge(s ? null : me.clientWidth), U(Ae));
  }, xe = (Ae) => {
    D?.(Ae), Ae.button === 0 && (Ae.preventDefault(), J.current.focus(), ve(!0, Ae));
  }, _e = (Ae) => {
    ve(!1, Ae);
  }, Ge = M.Children.toArray(l), Xe = (Ae) => {
    const Ht = Ge.find((Zt) => Zt.props.value === Ae.target.value);
    Ht !== void 0 && (F(Ht.props.value), O && O(Ae, Ht));
  }, tt = (Ae) => (Ht) => {
    let Zt;
    if (Ht.currentTarget.hasAttribute("tabindex")) {
      if (k) {
        Zt = Array.isArray(V) ? V.slice() : [];
        const Bo = V.indexOf(Ae.props.value);
        Bo === -1 ? Zt.push(Ae.props.value) : Zt.splice(Bo, 1);
      } else
        Zt = Ae.props.value;
      if (Ae.props.onClick && Ae.props.onClick(Ht), V !== Zt && (F(Zt), O)) {
        const Bo = Ht.nativeEvent || Ht, Uo = new Bo.constructor(Bo.type, Bo);
        Object.defineProperty(Uo, "target", {
          writable: !0,
          value: {
            value: Zt,
            name: E
          }
        }), O(Uo, Ae);
      }
      k || ve(!1, Ht);
    }
  }, nt = (Ae) => {
    B || ([
      " ",
      "ArrowUp",
      "ArrowDown",
      // The native select doesn't respond to enter on macOS, but it's recommended by
      // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
      "Enter"
    ].includes(Ae.key) && (Ae.preventDefault(), ve(!0, Ae)), R?.(Ae));
  }, je = oe !== null && Y, cn = (Ae) => {
    !je && _ && (Object.defineProperty(Ae, "target", {
      writable: !0,
      value: {
        value: V,
        name: E
      }
    }), _(Ae));
  };
  delete Z["aria-invalid"];
  let pt, Ce;
  const Me = [];
  let he = !1;
  (q2({
    value: V
  }) || h) && (P ? pt = P(V) : he = !0);
  const ye = Ge.map((Ae) => {
    if (!/* @__PURE__ */ M.isValidElement(Ae))
      return null;
    let Ht;
    if (k) {
      if (!Array.isArray(V))
        throw new Error(Ic(2));
      Ht = V.some((Zt) => w9(Zt, Ae.props.value)), Ht && he && Me.push(Ae.props.children);
    } else
      Ht = w9(V, Ae.props.value), Ht && he && (Ce = Ae.props.children);
    return /* @__PURE__ */ M.cloneElement(Ae, {
      "aria-selected": Ht ? "true" : "false",
      onClick: tt(Ae),
      onKeyUp: (Zt) => {
        Zt.key === " " && Zt.preventDefault(), Ae.props.onKeyUp && Ae.props.onKeyUp(Zt);
      },
      role: "option",
      selected: Ht,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": Ae.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  he && (k ? Me.length === 0 ? pt = null : pt = Me.reduce((Ae, Ht, Zt) => (Ae.push(Ht), Zt < Me.length - 1 && Ae.push(", "), Ae), []) : pt = Ce);
  let Ee = ce;
  !s && ie && oe && (Ee = me.clientWidth);
  let Te;
  typeof G < "u" ? Te = G : Te = m ? null : 0;
  const Fe = L.id || (E ? `mui-component-select-${E}` : void 0), Ut = {
    ...e,
    variant: q,
    value: V,
    open: je,
    error: v
  }, Vt = R1e(Ut), Xt = {
    ...w.PaperProps,
    ...typeof w.slotProps?.paper == "function" ? w.slotProps.paper(Ut) : w.slotProps?.paper
  }, Nt = {
    ...w.MenuListProps,
    ...typeof w.slotProps?.list == "function" ? w.slotProps.list(Ut) : w.slotProps?.list
  }, kn = zg();
  return /* @__PURE__ */ C.jsxs(M.Fragment, {
    children: [/* @__PURE__ */ C.jsx(O1e, {
      as: "div",
      ref: le,
      tabIndex: Te,
      role: "combobox",
      "aria-controls": je ? kn : void 0,
      "aria-disabled": m ? "true" : void 0,
      "aria-expanded": je ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": r,
      "aria-labelledby": [x, Fe].filter(Boolean).join(" ") || void 0,
      "aria-describedby": n,
      "aria-required": H ? "true" : void 0,
      "aria-invalid": v ? "true" : void 0,
      onKeyDown: nt,
      onMouseDown: m || B ? null : xe,
      onBlur: cn,
      onFocus: A,
      ...L,
      ownerState: Ut,
      className: Ye(L.className, Vt.select, c),
      id: Fe,
      children: A1e(pt) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        b9 || (b9 = /* @__PURE__ */ C.jsx("span", {
          className: "notranslate",
          "aria-hidden": !0,
          children: ""
        }))
      ) : pt
    }), /* @__PURE__ */ C.jsx(N1e, {
      "aria-invalid": v,
      value: Array.isArray(V) ? V.join(",") : V,
      name: E,
      ref: W,
      "aria-hidden": !0,
      onChange: Xe,
      tabIndex: -1,
      disabled: m,
      className: Vt.nativeInput,
      autoFocus: a,
      required: H,
      ...Z,
      ownerState: Ut
    }), /* @__PURE__ */ C.jsx(M1e, {
      as: g,
      className: Vt.icon,
      ownerState: Ut
    }), /* @__PURE__ */ C.jsx(x1e, {
      id: `menu-${E || ""}`,
      anchorEl: me,
      open: je,
      onClose: _e,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      },
      ...w,
      slotProps: {
        ...w.slotProps,
        list: {
          "aria-labelledby": x,
          role: "listbox",
          "aria-multiselectable": k ? "true" : void 0,
          disableListWrap: !0,
          id: kn,
          ...Nt
        },
        paper: {
          ...Xt,
          style: {
            minWidth: Ee,
            ...Xt != null ? Xt.style : null
          }
        }
      },
      children: ye
    })]
  });
}), P1e = Ni(/* @__PURE__ */ C.jsx("path", {
  d: "M7 10l5 5 5-5z"
})), D1e = (e) => {
  const {
    classes: t
  } = e, n = Et({
    root: ["root"]
  }, uY, t);
  return {
    ...t,
    ...n
  };
}, EP = {
  name: "MuiSelect",
  slot: "Root",
  shouldForwardProp: (e) => ea(e) && e !== "variant"
}, I1e = $e(yP, EP)(""), $1e = $e(wP, EP)(""), z1e = $e(bP, EP)(""), cY = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    name: "MuiSelect",
    props: e
  }), {
    autoWidth: r = !1,
    children: a,
    classes: s = {},
    className: l,
    defaultOpen: c = !1,
    displayEmpty: d = !1,
    IconComponent: f = P1e,
    id: m,
    input: h,
    inputProps: v,
    label: g,
    labelId: b,
    MenuProps: x,
    multiple: w = !1,
    native: k = !1,
    onClose: E,
    onOpen: _,
    open: O,
    renderValue: N,
    SelectDisplayProps: A,
    variant: R = "outlined",
    ...D
  } = n, I = k ? C1e : j1e, z = Zl(), B = Hd({
    props: n,
    muiFormControl: z,
    states: ["variant", "error"]
  }), P = B.variant || R, H = {
    ...n,
    variant: P,
    classes: s
  }, L = D1e(H), {
    root: G,
    ...$
  } = L, K = h || {
    standard: /* @__PURE__ */ C.jsx(I1e, {
      ownerState: H
    }),
    outlined: /* @__PURE__ */ C.jsx($1e, {
      label: g,
      ownerState: H
    }),
    filled: /* @__PURE__ */ C.jsx(z1e, {
      ownerState: H
    })
  }[P], q = io(t, Ok(K));
  return /* @__PURE__ */ C.jsx(M.Fragment, {
    children: /* @__PURE__ */ M.cloneElement(K, {
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent: I,
      inputProps: {
        children: a,
        error: B.error,
        IconComponent: f,
        variant: P,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple: w,
        ...k ? {
          id: m
        } : {
          autoWidth: r,
          defaultOpen: c,
          displayEmpty: d,
          labelId: b,
          MenuProps: x,
          onClose: E,
          onOpen: _,
          open: O,
          renderValue: N,
          SelectDisplayProps: {
            id: m,
            ...A
          }
        },
        ...v,
        classes: v ? Qo($, v.classes) : $,
        ...h ? h.props.inputProps : {}
      },
      ...(w && k || d) && P === "outlined" ? {
        notched: !0
      } : {},
      ref: q,
      className: Ye(K.props.className, l, L.root),
      // If a custom input is provided via 'input' prop, do not allow 'variant' to be propagated to it's root element. See https://github.com/mui/material-ui/issues/33894.
      ...!h && {
        variant: P
      },
      ...D
    })
  });
});
cY.muiName = "Select";
function T1e(e) {
  return Ct("MuiTextField", e);
}
St("MuiTextField", ["root"]);
const L1e = {
  standard: yP,
  filled: bP,
  outlined: wP
}, F1e = (e) => {
  const {
    classes: t
  } = e;
  return Et({
    root: ["root"]
  }, T1e, t);
}, B1e = $e(xP, {
  name: "MuiTextField",
  slot: "Root"
})({}), CP = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiTextField"
  }), {
    autoComplete: r,
    autoFocus: a = !1,
    children: s,
    className: l,
    color: c = "primary",
    defaultValue: d,
    disabled: f = !1,
    error: m = !1,
    FormHelperTextProps: h,
    fullWidth: v = !1,
    helperText: g,
    id: b,
    InputLabelProps: x,
    inputProps: w,
    InputProps: k,
    inputRef: E,
    label: _,
    maxRows: O,
    minRows: N,
    multiline: A = !1,
    name: R,
    onBlur: D,
    onChange: I,
    onFocus: z,
    placeholder: B,
    required: P = !1,
    rows: H,
    select: L = !1,
    SelectProps: G,
    slots: $ = {},
    slotProps: K = {},
    type: q,
    value: Z,
    variant: V = "outlined",
    ...F
  } = n, Y = {
    ...n,
    autoFocus: a,
    color: c,
    disabled: f,
    error: m,
    fullWidth: v,
    multiline: A,
    required: P,
    select: L,
    variant: V
  }, U = F1e(Y), W = zg(b), J = g && W ? `${W}-helper-text` : void 0, oe = _ && W ? `${W}-label` : void 0, fe = L1e[V], ie = {
    slots: $,
    slotProps: {
      input: k,
      inputLabel: x,
      htmlInput: w,
      formHelperText: h,
      select: G,
      ...K
    }
  }, ce = {}, ge = ie.slotProps.inputLabel;
  V === "outlined" && (ge && typeof ge.shrink < "u" && (ce.notched = ge.shrink), ce.label = _), L && ((!G || !G.native) && (ce.id = void 0), ce["aria-describedby"] = void 0);
  const [re, le] = Kn("root", {
    elementType: B1e,
    shouldForwardComponentProp: !0,
    externalForwardedProps: {
      ...ie,
      ...F
    },
    ownerState: Y,
    className: Ye(U.root, l),
    ref: t,
    additionalProps: {
      disabled: f,
      error: m,
      fullWidth: v,
      required: P,
      color: c,
      variant: V
    }
  }), [me, ve] = Kn("input", {
    elementType: fe,
    externalForwardedProps: ie,
    additionalProps: ce,
    ownerState: Y
  }), [xe, _e] = Kn("inputLabel", {
    elementType: kPe,
    externalForwardedProps: ie,
    ownerState: Y
  }), [Ge, Xe] = Kn("htmlInput", {
    elementType: "input",
    externalForwardedProps: ie,
    ownerState: Y
  }), [tt, nt] = Kn("formHelperText", {
    elementType: SP,
    externalForwardedProps: ie,
    ownerState: Y
  }), [je, cn] = Kn("select", {
    elementType: cY,
    externalForwardedProps: ie,
    ownerState: Y
  }), pt = /* @__PURE__ */ C.jsx(me, {
    "aria-describedby": J,
    autoComplete: r,
    autoFocus: a,
    defaultValue: d,
    fullWidth: v,
    multiline: A,
    name: R,
    rows: H,
    maxRows: O,
    minRows: N,
    type: q,
    value: Z,
    id: W,
    inputRef: E,
    onBlur: D,
    onChange: I,
    onFocus: z,
    placeholder: B,
    inputProps: Xe,
    slots: {
      input: $.htmlInput ? Ge : void 0
    },
    ...ve
  });
  return /* @__PURE__ */ C.jsxs(re, {
    ...le,
    children: [_ != null && _ !== "" && /* @__PURE__ */ C.jsx(xe, {
      htmlFor: W,
      id: oe,
      ..._e,
      children: _
    }), L ? /* @__PURE__ */ C.jsx(je, {
      "aria-describedby": J,
      id: W,
      labelId: oe,
      value: Z,
      input: pt,
      ...cn,
      children: s
    }) : pt, g && /* @__PURE__ */ C.jsx(tt, {
      id: J,
      ...nt,
      children: g
    })]
  });
}), U1e = ["date", "datetime-local", "file", "time"];
function V1e(e) {
  const {
    id: t,
    name: n,
    // remove this from textFieldProps
    htmlName: r,
    placeholder: a,
    required: s,
    readonly: l,
    disabled: c,
    type: d,
    label: f,
    hideLabel: m,
    hideError: h,
    value: v,
    onChange: g,
    onChangeOverride: b,
    onBlur: x,
    onFocus: w,
    autofocus: k,
    options: E,
    schema: _,
    uiSchema: O,
    rawErrors: N = [],
    errorSchema: A,
    registry: R,
    InputLabelProps: D,
    ...I
  } = e, z = bK(_, d, E), { step: B, min: P, max: H, accept: L, ...G } = z, $ = { step: B, min: P, max: H, accept: L, ..._.examples ? { list: AS(t) } : void 0 }, K = ({ target: { value: F } }) => g(F === "" ? E.emptyValue : F), q = ({ target: F }) => x(t, F && F.value), Z = ({ target: F }) => w(t, F && F.value), V = U1e.includes(d) ? {
    ...D,
    shrink: !0
  } : D;
  return C.jsxs(C.Fragment, { children: [C.jsx(CP, { id: t, name: r || t, placeholder: a, label: ih(f || void 0, m, void 0), autoFocus: k, required: s, disabled: c || l, slotProps: { htmlInput: $, inputLabel: V }, ...G, value: v || v === 0 ? v : "", error: N.length > 0, onChange: b || K, onBlur: q, onFocus: Z, ...I, "aria-describedby": ji(t, !!_.examples) }), Array.isArray(_.examples) && C.jsx("datalist", { id: AS(t), children: _.examples.concat(_.default && !_.examples.includes(_.default) ? [_.default] : []).map((F) => C.jsx("option", { value: F }, F)) })] });
}
function H1e(e) {
  return Ct("MuiTypography", e);
}
const x9 = St("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]), W1e = {
  primary: !0,
  secondary: !0,
  error: !0,
  info: !0,
  success: !0,
  warning: !0,
  textPrimary: !0,
  textSecondary: !0,
  textDisabled: !0
}, q1e = Nre(), G1e = (e) => {
  const {
    align: t,
    gutterBottom: n,
    noWrap: r,
    paragraph: a,
    variant: s,
    classes: l
  } = e, c = {
    root: ["root", s, e.align !== "inherit" && `align${qe(t)}`, n && "gutterBottom", r && "noWrap", a && "paragraph"]
  };
  return Et(c, H1e, l);
}, K1e = $e("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.variant && t[n.variant], n.align !== "inherit" && t[`align${qe(n.align)}`], n.noWrap && t.noWrap, n.gutterBottom && t.gutterBottom, n.paragraph && t.paragraph];
  }
})(Mt(({
  theme: e
}) => ({
  margin: 0,
  variants: [{
    props: {
      variant: "inherit"
    },
    style: {
      // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
      font: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  }, ...Object.entries(e.typography).filter(([t, n]) => t !== "inherit" && n && typeof n == "object").map(([t, n]) => ({
    props: {
      variant: t
    },
    style: n
  })), ...Object.entries(e.palette).filter(Zo()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      color: (e.vars || e).palette[t].main
    }
  })), ...Object.entries(e.palette?.text || {}).filter(([, t]) => typeof t == "string").map(([t]) => ({
    props: {
      color: `text${qe(t)}`
    },
    style: {
      color: (e.vars || e).palette.text[t]
    }
  })), {
    props: ({
      ownerState: t
    }) => t.align !== "inherit",
    style: {
      textAlign: "var(--Typography-textAlign)"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.noWrap,
    style: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.gutterBottom,
    style: {
      marginBottom: "0.35em"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.paragraph,
    style: {
      marginBottom: 16
    }
  }]
}))), S9 = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
}, Dl = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const {
    color: n,
    ...r
  } = Dt({
    props: e,
    name: "MuiTypography"
  }), a = !W1e[n], s = q1e({
    ...r,
    ...a && {
      color: n
    }
  }), {
    align: l = "inherit",
    className: c,
    component: d,
    gutterBottom: f = !1,
    noWrap: m = !1,
    paragraph: h = !1,
    variant: v = "body1",
    variantMapping: g = S9,
    ...b
  } = s, x = {
    ...s,
    align: l,
    color: n,
    className: c,
    component: d,
    gutterBottom: f,
    noWrap: m,
    paragraph: h,
    variant: v,
    variantMapping: g
  }, w = d || (h ? "p" : g[v] || S9[v]) || "span", k = G1e(x);
  return /* @__PURE__ */ C.jsx(K1e, {
    as: w,
    ref: t,
    className: Ye(k.root, c),
    ...b,
    ownerState: x,
    style: {
      ...l !== "inherit" && {
        "--Typography-textAlign": l
      },
      ...b.style
    }
  });
});
function Y1e(e) {
  const { id: t, description: n, registry: r, uiSchema: a } = e;
  return n ? C.jsx(Dl, { id: t, variant: "subtitle2", style: { marginTop: "5px" }, children: C.jsx(mP, { description: n, registry: r, uiSchema: a }) }) : null;
}
const X1e = Ni(/* @__PURE__ */ C.jsx("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m1 15h-2v-2h2zm0-4h-2V7h2z"
}));
function J1e(e) {
  return Ct("MuiListItem", e);
}
St("MuiListItem", ["root", "container", "dense", "alignItemsFlexStart", "divider", "gutters", "padding", "secondaryAction"]);
const Q1e = St("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]);
function Z1e(e) {
  return Ct("MuiListItemSecondaryAction", e);
}
St("MuiListItemSecondaryAction", ["root", "disableGutters"]);
const eDe = (e) => {
  const {
    disableGutters: t,
    classes: n
  } = e;
  return Et({
    root: ["root", t && "disableGutters"]
  }, Z1e, n);
}, tDe = $e("div", {
  name: "MuiListItemSecondaryAction",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.disableGutters && t.disableGutters];
  }
})({
  position: "absolute",
  right: 16,
  top: "50%",
  transform: "translateY(-50%)",
  variants: [{
    props: ({
      ownerState: e
    }) => e.disableGutters,
    style: {
      right: 0
    }
  }]
}), dY = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiListItemSecondaryAction"
  }), {
    className: r,
    ...a
  } = n, s = M.useContext(Dc), l = {
    ...n,
    disableGutters: s.disableGutters
  }, c = eDe(l);
  return /* @__PURE__ */ C.jsx(tDe, {
    className: Ye(c.root, r),
    ownerState: l,
    ref: t,
    ...a
  });
});
dY.muiName = "ListItemSecondaryAction";
const nDe = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, n.dense && t.dense, n.alignItems === "flex-start" && t.alignItemsFlexStart, n.divider && t.divider, !n.disableGutters && t.gutters, !n.disablePadding && t.padding, n.hasSecondaryAction && t.secondaryAction];
}, rDe = (e) => {
  const {
    alignItems: t,
    classes: n,
    dense: r,
    disableGutters: a,
    disablePadding: s,
    divider: l,
    hasSecondaryAction: c
  } = e;
  return Et({
    root: ["root", r && "dense", !a && "gutters", !s && "padding", l && "divider", t === "flex-start" && "alignItemsFlexStart", c && "secondaryAction"],
    container: ["container"],
    secondaryAction: ["secondaryAction"]
  }, J1e, n);
}, oDe = $e("div", {
  name: "MuiListItem",
  slot: "Root",
  overridesResolver: nDe
})(Mt(({
  theme: e
}) => ({
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  width: "100%",
  boxSizing: "border-box",
  textAlign: "left",
  variants: [{
    props: ({
      ownerState: t
    }) => !t.disablePadding,
    style: {
      paddingTop: 8,
      paddingBottom: 8
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.disablePadding && t.dense,
    style: {
      paddingTop: 4,
      paddingBottom: 4
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.disablePadding && !t.disableGutters,
    style: {
      paddingLeft: 16,
      paddingRight: 16
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.disablePadding && !!t.secondaryAction,
    style: {
      // Add some space to avoid collision as `ListItemSecondaryAction`
      // is absolutely positioned.
      paddingRight: 48
    }
  }, {
    props: ({
      ownerState: t
    }) => !!t.secondaryAction,
    style: {
      [`& > .${Q1e.root}`]: {
        paddingRight: 48
      }
    }
  }, {
    props: {
      alignItems: "flex-start"
    },
    style: {
      alignItems: "flex-start"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.divider,
    style: {
      borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
      backgroundClip: "padding-box"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.button,
    style: {
      transition: e.transitions.create("background-color", {
        duration: e.transitions.duration.shortest
      }),
      "&:hover": {
        textDecoration: "none",
        backgroundColor: (e.vars || e).palette.action.hover,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hasSecondaryAction,
    style: {
      // Add some space to avoid collision as `ListItemSecondaryAction`
      // is absolutely positioned.
      paddingRight: 48
    }
  }]
}))), aDe = $e("li", {
  name: "MuiListItem",
  slot: "Container"
})({
  position: "relative"
}), fY = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiListItem"
  }), {
    alignItems: r = "center",
    children: a,
    className: s,
    component: l,
    components: c = {},
    componentsProps: d = {},
    ContainerComponent: f = "li",
    ContainerProps: {
      className: m,
      ...h
    } = {},
    dense: v = !1,
    disableGutters: g = !1,
    disablePadding: b = !1,
    divider: x = !1,
    secondaryAction: w,
    slotProps: k = {},
    slots: E = {},
    ..._
  } = n, O = M.useContext(Dc), N = M.useMemo(() => ({
    dense: v || O.dense || !1,
    alignItems: r,
    disableGutters: g
  }), [r, O.dense, v, g]), A = M.useRef(null), R = M.Children.toArray(a), D = R.length && Ax(R[R.length - 1], ["ListItemSecondaryAction"]), I = {
    ...n,
    alignItems: r,
    dense: N.dense,
    disableGutters: g,
    disablePadding: b,
    divider: x,
    hasSecondaryAction: D
  }, z = rDe(I), B = io(A, t), P = {
    slots: E,
    slotProps: k
  }, [H, L] = Kn("secondaryAction", {
    elementType: dY,
    externalForwardedProps: P,
    ownerState: I,
    className: z.secondaryAction
  }), G = E.root || c.Root || oDe, $ = k.root || d.root || {}, K = {
    className: Ye(z.root, $.className, s),
    ..._
  };
  let q = l || "li";
  return D ? (q = !K.component && !l ? "div" : q, f === "li" && (q === "li" ? q = "div" : K.component === "li" && (K.component = "div")), /* @__PURE__ */ C.jsx(Dc.Provider, {
    value: N,
    children: /* @__PURE__ */ C.jsxs(aDe, {
      as: f,
      className: Ye(z.container, m),
      ref: B,
      ownerState: I,
      ...h,
      children: [/* @__PURE__ */ C.jsx(G, {
        ...$,
        ...!Ll(G) && {
          as: q,
          ownerState: {
            ...I,
            ...$.ownerState
          }
        },
        ...K,
        children: R
      }), R.pop()]
    })
  })) : /* @__PURE__ */ C.jsx(Dc.Provider, {
    value: N,
    children: /* @__PURE__ */ C.jsxs(G, {
      ...$,
      as: q,
      ref: B,
      ...!Ll(G) && {
        ownerState: {
          ...I,
          ...$.ownerState
        }
      },
      ...K,
      children: [R, w && /* @__PURE__ */ C.jsx(H, {
        ...L,
        children: w
      })]
    })
  });
});
function iDe(e) {
  return Ct("MuiListItemIcon", e);
}
const k9 = St("MuiListItemIcon", ["root", "alignItemsFlexStart"]), sDe = (e) => {
  const {
    alignItems: t,
    classes: n
  } = e;
  return Et({
    root: ["root", t === "flex-start" && "alignItemsFlexStart"]
  }, iDe, n);
}, lDe = $e("div", {
  name: "MuiListItemIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.alignItems === "flex-start" && t.alignItemsFlexStart];
  }
})(Mt(({
  theme: e
}) => ({
  minWidth: 56,
  color: (e.vars || e).palette.action.active,
  flexShrink: 0,
  display: "inline-flex",
  variants: [{
    props: {
      alignItems: "flex-start"
    },
    style: {
      marginTop: 8
    }
  }]
}))), uDe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiListItemIcon"
  }), {
    className: r,
    ...a
  } = n, s = M.useContext(Dc), l = {
    ...n,
    alignItems: s.alignItems
  }, c = sDe(l);
  return /* @__PURE__ */ C.jsx(lDe, {
    className: Ye(c.root, r),
    ownerState: l,
    ref: t,
    ...a
  });
});
function cDe(e) {
  return Ct("MuiListItemText", e);
}
const Gh = St("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]), dDe = (e) => {
  const {
    classes: t,
    inset: n,
    primary: r,
    secondary: a,
    dense: s
  } = e;
  return Et({
    root: ["root", n && "inset", s && "dense", r && a && "multiline"],
    primary: ["primary"],
    secondary: ["secondary"]
  }, cDe, t);
}, fDe = $e("div", {
  name: "MuiListItemText",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [{
      [`& .${Gh.primary}`]: t.primary
    }, {
      [`& .${Gh.secondary}`]: t.secondary
    }, t.root, n.inset && t.inset, n.primary && n.secondary && t.multiline, n.dense && t.dense];
  }
})({
  flex: "1 1 auto",
  minWidth: 0,
  marginTop: 4,
  marginBottom: 4,
  [`.${x9.root}:where(& .${Gh.primary})`]: {
    display: "block"
  },
  [`.${x9.root}:where(& .${Gh.secondary})`]: {
    display: "block"
  },
  variants: [{
    props: ({
      ownerState: e
    }) => e.primary && e.secondary,
    style: {
      marginTop: 6,
      marginBottom: 6
    }
  }, {
    props: ({
      ownerState: e
    }) => e.inset,
    style: {
      paddingLeft: 56
    }
  }]
}), pDe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiListItemText"
  }), {
    children: r,
    className: a,
    disableTypography: s = !1,
    inset: l = !1,
    primary: c,
    primaryTypographyProps: d,
    secondary: f,
    secondaryTypographyProps: m,
    slots: h = {},
    slotProps: v = {},
    ...g
  } = n, {
    dense: b
  } = M.useContext(Dc);
  let x = c ?? r, w = f;
  const k = {
    ...n,
    disableTypography: s,
    inset: l,
    primary: !!x,
    secondary: !!w,
    dense: b
  }, E = dDe(k), _ = {
    slots: h,
    slotProps: {
      primary: d,
      secondary: m,
      ...v
    }
  }, [O, N] = Kn("root", {
    className: Ye(E.root, a),
    elementType: fDe,
    externalForwardedProps: {
      ..._,
      ...g
    },
    ownerState: k,
    ref: t
  }), [A, R] = Kn("primary", {
    className: E.primary,
    elementType: Dl,
    externalForwardedProps: _,
    ownerState: k
  }), [D, I] = Kn("secondary", {
    className: E.secondary,
    elementType: Dl,
    externalForwardedProps: _,
    ownerState: k
  });
  return x != null && x.type !== Dl && !s && (x = /* @__PURE__ */ C.jsx(A, {
    variant: b ? "body2" : "body1",
    component: R?.variant ? void 0 : "span",
    ...R,
    children: x
  })), w != null && w.type !== Dl && !s && (w = /* @__PURE__ */ C.jsx(D, {
    variant: "body2",
    color: "textSecondary",
    ...I,
    children: w
  })), /* @__PURE__ */ C.jsxs(O, {
    ...N,
    children: [x, w]
  });
});
function mDe({ errors: e, registry: t }) {
  const { translateString: n } = t;
  return C.jsx(IC, { elevation: 2, children: C.jsxs(zd, { mb: 2, p: 2, children: [C.jsx(Dl, { variant: "h6", children: n(Jt.ErrorsLabel) }), C.jsx(kP, { dense: !0, children: e.map((r, a) => C.jsxs(fY, { children: [C.jsx(uDe, { children: C.jsx(X1e, { color: "error" }) }), C.jsx(pDe, { primary: r.stack })] }, a)) })] }) });
}
const hDe = Ni(/* @__PURE__ */ C.jsx("path", {
  d: "m20 12-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8z"
})), gDe = Ni(/* @__PURE__ */ C.jsx("path", {
  d: "m4 12 1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8z"
})), vDe = Ni(/* @__PURE__ */ C.jsx("path", {
  d: "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"
})), yDe = Ni(/* @__PURE__ */ C.jsx("path", {
  d: "M19 13H5v-2h14z"
}));
function Mk(e) {
  const { icon: t, color: n, uiSchema: r, registry: a, ...s } = e;
  return C.jsx(nY, { ...s, size: "small", color: n, children: t });
}
function bDe(e) {
  const { registry: { translateString: t } } = e;
  return C.jsx(Mk, { title: t(Jt.CopyButton), ...e, icon: C.jsx(vDe, { fontSize: "small" }) });
}
function wDe(e) {
  const { registry: { translateString: t } } = e;
  return C.jsx(Mk, { title: t(Jt.MoveDownButton), ...e, icon: C.jsx(hDe, { fontSize: "small" }) });
}
function xDe(e) {
  const { registry: { translateString: t } } = e;
  return C.jsx(Mk, { title: t(Jt.MoveUpButton), ...e, icon: C.jsx(gDe, { fontSize: "small" }) });
}
function pY(e) {
  const { iconType: t, ...n } = e, { registry: { translateString: r } } = n;
  return C.jsx(Mk, { title: r(Jt.RemoveButton), ...n, color: "error", icon: C.jsx(yDe, { fontSize: t === "default" ? void 0 : "small" }) });
}
function SDe(e) {
  const { errors: t = [], fieldPathId: n } = e;
  if (t.length === 0)
    return null;
  const r = nP(n);
  return C.jsx(kP, { id: r, dense: !0, disablePadding: !0, children: t.map((a, s) => C.jsx(fY, { disableGutters: !0, children: C.jsx(SP, { component: "div", id: `${r}-${s}`, children: a }) }, s)) });
}
function kDe(e) {
  const { fieldPathId: t, help: n, uiSchema: r, registry: a } = e;
  return n ? C.jsx(SP, { component: "div", id: rP(t), style: { marginTop: "5px" }, children: C.jsx(hP, { help: n, registry: a, uiSchema: r }) }) : null;
}
function _De(e) {
  const { id: t, children: n, classNames: r, style: a, disabled: s, displayLabel: l, hidden: c, label: d, onKeyRename: f, onKeyRenameBlur: m, onRemoveProperty: h, readonly: v, required: g, rawErrors: b = [], errors: x, help: w, description: k, rawDescription: E, schema: _, uiSchema: O, registry: N } = e, A = vt(O), R = xt("WrapIfAdditionalTemplate", N, A);
  if (c)
    return C.jsx("div", { style: { display: "none" }, children: n });
  const D = A.widget === "checkbox";
  return C.jsx(R, { classNames: r, style: a, disabled: s, id: t, label: d, displayLabel: l, rawDescription: E, onKeyRename: f, onKeyRenameBlur: m, onRemoveProperty: h, readonly: v, required: g, schema: _, uiSchema: O, registry: N, children: C.jsxs(xP, { fullWidth: !0, error: !!b.length, required: g, children: [n, l && !D && E ? C.jsx(Dl, { variant: "caption", color: "textSecondary", children: k }) : null, x, w] }) });
}
function EDe(e) {
  const { children: t, column: n, ...r } = e;
  return C.jsx(To, { container: !n, ...r, children: t });
}
function CDe(e) {
  const { optionSchemaField: t, selector: n } = e;
  return C.jsxs(zd, { sx: { mb: 2 }, children: [C.jsx(xP, { fullWidth: !0, sx: { mb: 2 }, children: n }), t] });
}
function ODe(e) {
  const { description: t, title: n, properties: r, required: a, disabled: s, readonly: l, uiSchema: c, fieldPathId: d, schema: f, formData: m, optionalDataControl: h, onAddProperty: v, registry: g } = e, b = vt(c), x = xt("TitleFieldTemplate", g, b), w = xt("DescriptionFieldTemplate", g, b), k = !l && !s, { ButtonTemplates: { AddButton: E } } = g.templates;
  return C.jsxs(C.Fragment, { children: [n && C.jsx(x, { id: OC(d), title: n, required: a, schema: f, uiSchema: c, registry: g, optionalDataControl: k ? h : void 0 }), t && C.jsx(w, { id: ah(d), description: t, schema: f, uiSchema: c, registry: g }), C.jsxs(To, { container: !0, spacing: 2, style: { marginTop: "10px" }, children: [k ? void 0 : h, r.map((_, O) => (
    // Remove the <Grid> if the inner element is hidden as the <Grid>
    // itself would otherwise still take up space.
    _.hidden ? _.content : C.jsx(To, { size: { xs: 12 }, style: { marginBottom: "10px" }, children: _.content }, O)
  ))] }), rG(f, c, m) && C.jsx(To, { container: !0, justifyContent: "flex-end", children: C.jsx(To, { children: C.jsx(E, { id: jl(d, "add"), className: "rjsf-object-property-expand", onClick: v, disabled: s || l, uiSchema: c, registry: g }) }) })] });
}
function MDe(e) {
  const { id: t, registry: n, label: r, onAddClick: a, onRemoveClick: s } = e;
  return a ? C.jsx(Mk, { id: t, registry: n, className: "rjsf-add-optional-data", onClick: a, title: r, icon: C.jsx(eY, { fontSize: "small" }) }) : s ? C.jsx(pY, { id: t, registry: n, className: "rjsf-remove-optional-data", onClick: s, title: r }) : C.jsx("em", { id: t, children: r });
}
function NDe(e) {
  return Ct("MuiButton", e);
}
const gm = St("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge", "loading", "loadingWrapper", "loadingIconPlaceholder", "loadingIndicator", "loadingPositionCenter", "loadingPositionStart", "loadingPositionEnd"]), ADe = /* @__PURE__ */ M.createContext({}), RDe = /* @__PURE__ */ M.createContext(void 0), jDe = (e) => {
  const {
    color: t,
    disableElevation: n,
    fullWidth: r,
    size: a,
    variant: s,
    loading: l,
    loadingPosition: c,
    classes: d
  } = e, f = {
    root: ["root", l && "loading", s, `${s}${qe(t)}`, `size${qe(a)}`, `${s}Size${qe(a)}`, `color${qe(t)}`, n && "disableElevation", r && "fullWidth", l && `loadingPosition${qe(c)}`],
    startIcon: ["icon", "startIcon", `iconSize${qe(a)}`],
    endIcon: ["icon", "endIcon", `iconSize${qe(a)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  }, m = Et(f, NDe, d);
  return {
    ...d,
    // forward the focused, disabled, etc. classes to the ButtonBase
    ...m
  };
}, mY = [{
  props: {
    size: "small"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 18
    }
  }
}, {
  props: {
    size: "medium"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 20
    }
  }
}, {
  props: {
    size: "large"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 22
    }
  }
}], PDe = $e(JS, {
  shouldForwardProp: (e) => ea(e) || e === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], t[`${n.variant}${qe(n.color)}`], t[`size${qe(n.size)}`], t[`${n.variant}Size${qe(n.size)}`], n.color === "inherit" && t.colorInherit, n.disableElevation && t.disableElevation, n.fullWidth && t.fullWidth, n.loading && t.loading];
  }
})(Mt(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800], n = e.palette.mode === "light" ? e.palette.grey.A100 : e.palette.grey[700];
  return {
    ...e.typography.button,
    minWidth: 64,
    padding: "6px 16px",
    border: 0,
    borderRadius: (e.vars || e).shape.borderRadius,
    transition: e.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: e.transitions.duration.short
    }),
    "&:hover": {
      textDecoration: "none"
    },
    [`&.${gm.disabled}`]: {
      color: (e.vars || e).palette.action.disabled
    },
    variants: [{
      props: {
        variant: "contained"
      },
      style: {
        color: "var(--variant-containedColor)",
        backgroundColor: "var(--variant-containedBg)",
        boxShadow: (e.vars || e).shadows[2],
        "&:hover": {
          boxShadow: (e.vars || e).shadows[4],
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            boxShadow: (e.vars || e).shadows[2]
          }
        },
        "&:active": {
          boxShadow: (e.vars || e).shadows[8]
        },
        [`&.${gm.focusVisible}`]: {
          boxShadow: (e.vars || e).shadows[6]
        },
        [`&.${gm.disabled}`]: {
          color: (e.vars || e).palette.action.disabled,
          boxShadow: (e.vars || e).shadows[0],
          backgroundColor: (e.vars || e).palette.action.disabledBackground
        }
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        padding: "5px 15px",
        border: "1px solid currentColor",
        borderColor: "var(--variant-outlinedBorder, currentColor)",
        backgroundColor: "var(--variant-outlinedBg)",
        color: "var(--variant-outlinedColor)",
        [`&.${gm.disabled}`]: {
          border: `1px solid ${(e.vars || e).palette.action.disabledBackground}`
        }
      }
    }, {
      props: {
        variant: "text"
      },
      style: {
        padding: "6px 8px",
        color: "var(--variant-textColor)",
        backgroundColor: "var(--variant-textBg)"
      }
    }, ...Object.entries(e.palette).filter(Zo()).map(([r]) => ({
      props: {
        color: r
      },
      style: {
        "--variant-textColor": (e.vars || e).palette[r].main,
        "--variant-outlinedColor": (e.vars || e).palette[r].main,
        "--variant-outlinedBorder": e.alpha((e.vars || e).palette[r].main, 0.5),
        "--variant-containedColor": (e.vars || e).palette[r].contrastText,
        "--variant-containedBg": (e.vars || e).palette[r].main,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": (e.vars || e).palette[r].dark,
            "--variant-textBg": e.alpha((e.vars || e).palette[r].main, (e.vars || e).palette.action.hoverOpacity),
            "--variant-outlinedBorder": (e.vars || e).palette[r].main,
            "--variant-outlinedBg": e.alpha((e.vars || e).palette[r].main, (e.vars || e).palette.action.hoverOpacity)
          }
        }
      }
    })), {
      props: {
        color: "inherit"
      },
      style: {
        color: "inherit",
        borderColor: "currentColor",
        "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedBg : t,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedHoverBg : n,
            "--variant-textBg": e.alpha((e.vars || e).palette.text.primary, (e.vars || e).palette.action.hoverOpacity),
            "--variant-outlinedBg": e.alpha((e.vars || e).palette.text.primary, (e.vars || e).palette.action.hoverOpacity)
          }
        }
      }
    }, {
      props: {
        size: "small",
        variant: "text"
      },
      style: {
        padding: "4px 5px",
        fontSize: e.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "text"
      },
      style: {
        padding: "8px 11px",
        fontSize: e.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "outlined"
      },
      style: {
        padding: "3px 9px",
        fontSize: e.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "outlined"
      },
      style: {
        padding: "7px 21px",
        fontSize: e.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "contained"
      },
      style: {
        padding: "4px 10px",
        fontSize: e.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "contained"
      },
      style: {
        padding: "8px 22px",
        fontSize: e.typography.pxToRem(15)
      }
    }, {
      props: {
        disableElevation: !0
      },
      style: {
        boxShadow: "none",
        "&:hover": {
          boxShadow: "none"
        },
        [`&.${gm.focusVisible}`]: {
          boxShadow: "none"
        },
        "&:active": {
          boxShadow: "none"
        },
        [`&.${gm.disabled}`]: {
          boxShadow: "none"
        }
      }
    }, {
      props: {
        fullWidth: !0
      },
      style: {
        width: "100%"
      }
    }, {
      props: {
        loadingPosition: "center"
      },
      style: {
        transition: e.transitions.create(["background-color", "box-shadow", "border-color"], {
          duration: e.transitions.duration.short
        }),
        [`&.${gm.loading}`]: {
          color: "transparent"
        }
      }
    }]
  };
})), DDe = $e("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.startIcon, n.loading && t.startIconLoadingStart, t[`iconSize${qe(n.size)}`]];
  }
})(({
  theme: e
}) => ({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginLeft: -2
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: !0
    },
    style: {
      transition: e.transitions.create(["opacity"], {
        duration: e.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: !0,
      fullWidth: !0
    },
    style: {
      marginRight: -8
    }
  }, ...mY]
})), IDe = $e("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.endIcon, n.loading && t.endIconLoadingEnd, t[`iconSize${qe(n.size)}`]];
  }
})(({
  theme: e
}) => ({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginRight: -2
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: !0
    },
    style: {
      transition: e.transitions.create(["opacity"], {
        duration: e.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: !0,
      fullWidth: !0
    },
    style: {
      marginLeft: -8
    }
  }, ...mY]
})), $De = $e("span", {
  name: "MuiButton",
  slot: "LoadingIndicator"
})(({
  theme: e
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  variants: [{
    props: {
      loading: !0
    },
    style: {
      display: "flex"
    }
  }, {
    props: {
      loadingPosition: "start"
    },
    style: {
      left: 14
    }
  }, {
    props: {
      loadingPosition: "start",
      size: "small"
    },
    style: {
      left: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "start"
    },
    style: {
      left: 6
    }
  }, {
    props: {
      loadingPosition: "center"
    },
    style: {
      left: "50%",
      transform: "translate(-50%)",
      color: (e.vars || e).palette.action.disabled
    }
  }, {
    props: {
      loadingPosition: "end"
    },
    style: {
      right: 14
    }
  }, {
    props: {
      loadingPosition: "end",
      size: "small"
    },
    style: {
      right: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "end"
    },
    style: {
      right: 6
    }
  }, {
    props: {
      loadingPosition: "start",
      fullWidth: !0
    },
    style: {
      position: "relative",
      left: -10
    }
  }, {
    props: {
      loadingPosition: "end",
      fullWidth: !0
    },
    style: {
      position: "relative",
      right: -10
    }
  }]
})), _9 = $e("span", {
  name: "MuiButton",
  slot: "LoadingIconPlaceholder"
})({
  display: "inline-block",
  width: "1em",
  height: "1em"
}), zDe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = M.useContext(ADe), r = M.useContext(RDe), a = nS(n, e), s = Dt({
    props: a,
    name: "MuiButton"
  }), {
    children: l,
    color: c = "primary",
    component: d = "button",
    className: f,
    disabled: m = !1,
    disableElevation: h = !1,
    disableFocusRipple: v = !1,
    endIcon: g,
    focusVisibleClassName: b,
    fullWidth: x = !1,
    id: w,
    loading: k = null,
    loadingIndicator: E,
    loadingPosition: _ = "center",
    size: O = "medium",
    startIcon: N,
    type: A,
    variant: R = "text",
    ...D
  } = s, I = zg(w), z = E ?? /* @__PURE__ */ C.jsx(tY, {
    "aria-labelledby": I,
    color: "inherit",
    size: 16
  }), B = {
    ...s,
    color: c,
    component: d,
    disabled: m,
    disableElevation: h,
    disableFocusRipple: v,
    fullWidth: x,
    loading: k,
    loadingIndicator: z,
    loadingPosition: _,
    size: O,
    type: A,
    variant: R
  }, P = jDe(B), H = (N || k && _ === "start") && /* @__PURE__ */ C.jsx(DDe, {
    className: P.startIcon,
    ownerState: B,
    children: N || /* @__PURE__ */ C.jsx(_9, {
      className: P.loadingIconPlaceholder,
      ownerState: B
    })
  }), L = (g || k && _ === "end") && /* @__PURE__ */ C.jsx(IDe, {
    className: P.endIcon,
    ownerState: B,
    children: g || /* @__PURE__ */ C.jsx(_9, {
      className: P.loadingIconPlaceholder,
      ownerState: B
    })
  }), G = r || "", $ = typeof k == "boolean" ? (
    // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ C.jsx("span", {
      className: P.loadingWrapper,
      style: {
        display: "contents"
      },
      children: k && /* @__PURE__ */ C.jsx($De, {
        className: P.loadingIndicator,
        ownerState: B,
        children: z
      })
    })
  ) : null;
  return /* @__PURE__ */ C.jsxs(PDe, {
    ownerState: B,
    className: Ye(n.className, P.root, f, G),
    component: d,
    disabled: m || k,
    focusRipple: !v,
    focusVisibleClassName: Ye(P.focusVisible, b),
    ref: t,
    type: A,
    id: k ? I : w,
    ...D,
    classes: P,
    children: [H, _ !== "end" && $, l, _ === "end" && $, L]
  });
});
function TDe({ uiSchema: e }) {
  const { submitText: t, norender: n, props: r = {} } = wK(e);
  return n ? null : C.jsx(zd, { marginTop: 3, children: C.jsx(zDe, { type: "submit", variant: "contained", color: "primary", ...r, children: t }) });
}
function LDe(e) {
  return Ct("MuiDivider", e);
}
const E9 = St("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]), FDe = (e) => {
  const {
    absolute: t,
    children: n,
    classes: r,
    flexItem: a,
    light: s,
    orientation: l,
    textAlign: c,
    variant: d
  } = e;
  return Et({
    root: ["root", t && "absolute", d, s && "light", l === "vertical" && "vertical", a && "flexItem", n && "withChildren", n && l === "vertical" && "withChildrenVertical", c === "right" && l !== "vertical" && "textAlignRight", c === "left" && l !== "vertical" && "textAlignLeft"],
    wrapper: ["wrapper", l === "vertical" && "wrapperVertical"]
  }, LDe, r);
}, BDe = $e("div", {
  name: "MuiDivider",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.absolute && t.absolute, t[n.variant], n.light && t.light, n.orientation === "vertical" && t.vertical, n.flexItem && t.flexItem, n.children && t.withChildren, n.children && n.orientation === "vertical" && t.withChildrenVertical, n.textAlign === "right" && n.orientation !== "vertical" && t.textAlignRight, n.textAlign === "left" && n.orientation !== "vertical" && t.textAlignLeft];
  }
})(Mt(({
  theme: e
}) => ({
  margin: 0,
  // Reset browser default style.
  flexShrink: 0,
  borderWidth: 0,
  borderStyle: "solid",
  borderColor: (e.vars || e).palette.divider,
  borderBottomWidth: "thin",
  variants: [{
    props: {
      absolute: !0
    },
    style: {
      position: "absolute",
      bottom: 0,
      left: 0,
      width: "100%"
    }
  }, {
    props: {
      light: !0
    },
    style: {
      borderColor: e.alpha((e.vars || e).palette.divider, 0.08)
    }
  }, {
    props: {
      variant: "inset"
    },
    style: {
      marginLeft: 72
    }
  }, {
    props: {
      variant: "middle",
      orientation: "horizontal"
    },
    style: {
      marginLeft: e.spacing(2),
      marginRight: e.spacing(2)
    }
  }, {
    props: {
      variant: "middle",
      orientation: "vertical"
    },
    style: {
      marginTop: e.spacing(1),
      marginBottom: e.spacing(1)
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      borderBottomWidth: 0,
      borderRightWidth: "thin"
    }
  }, {
    props: {
      flexItem: !0
    },
    style: {
      alignSelf: "stretch",
      height: "auto"
    }
  }, {
    props: ({
      ownerState: t
    }) => !!t.children,
    style: {
      display: "flex",
      textAlign: "center",
      border: 0,
      borderTopStyle: "solid",
      borderLeftStyle: "solid",
      "&::before, &::after": {
        content: '""',
        alignSelf: "center"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.children && t.orientation !== "vertical",
    style: {
      "&::before, &::after": {
        width: "100%",
        borderTop: `thin solid ${(e.vars || e).palette.divider}`,
        borderTopStyle: "inherit"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.orientation === "vertical" && t.children,
    style: {
      flexDirection: "column",
      "&::before, &::after": {
        height: "100%",
        borderLeft: `thin solid ${(e.vars || e).palette.divider}`,
        borderLeftStyle: "inherit"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.textAlign === "right" && t.orientation !== "vertical",
    style: {
      "&::before": {
        width: "90%"
      },
      "&::after": {
        width: "10%"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.textAlign === "left" && t.orientation !== "vertical",
    style: {
      "&::before": {
        width: "10%"
      },
      "&::after": {
        width: "90%"
      }
    }
  }]
}))), UDe = $e("span", {
  name: "MuiDivider",
  slot: "Wrapper",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.wrapper, n.orientation === "vertical" && t.wrapperVertical];
  }
})(Mt(({
  theme: e
}) => ({
  display: "inline-block",
  paddingLeft: `calc(${e.spacing(1)} * 1.2)`,
  paddingRight: `calc(${e.spacing(1)} * 1.2)`,
  whiteSpace: "nowrap",
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      paddingTop: `calc(${e.spacing(1)} * 1.2)`,
      paddingBottom: `calc(${e.spacing(1)} * 1.2)`
    }
  }]
}))), nR = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiDivider"
  }), {
    absolute: r = !1,
    children: a,
    className: s,
    orientation: l = "horizontal",
    component: c = a || l === "vertical" ? "div" : "hr",
    flexItem: d = !1,
    light: f = !1,
    role: m = c !== "hr" ? "separator" : void 0,
    textAlign: h = "center",
    variant: v = "fullWidth",
    ...g
  } = n, b = {
    ...n,
    absolute: r,
    component: c,
    flexItem: d,
    light: f,
    orientation: l,
    role: m,
    textAlign: h,
    variant: v
  }, x = FDe(b);
  return /* @__PURE__ */ C.jsx(BDe, {
    as: c,
    className: Ye(x.root, s),
    role: m,
    ref: t,
    ownerState: b,
    "aria-orientation": m === "separator" && (c !== "hr" || l === "vertical") ? l : void 0,
    ...g,
    children: a ? /* @__PURE__ */ C.jsx(UDe, {
      className: x.wrapper,
      ownerState: b,
      children: a
    }) : null
  });
});
nR && (nR.muiSkipListHighlight = !0);
function VDe({ id: e, title: t, optionalDataControl: n }) {
  let r = C.jsx(Dl, { variant: "h5", children: t });
  return n && (r = C.jsxs(To, { container: !0, spacing: 0, children: [C.jsx(To, { size: "grow", children: r }), C.jsx(To, { justifyContent: "flex-end", children: n })] })), C.jsxs(zd, { id: e, mb: 1, mt: 1, children: [r, C.jsx(nR, {})] });
}
function HDe(e) {
  const { children: t, classNames: n, style: r, disabled: a, id: s, label: l, displayLabel: c, onKeyRenameBlur: d, onRemoveProperty: f, readonly: m, required: h, schema: v, uiSchema: g, registry: b } = e, { templates: x, translateString: w } = b, { RemoveButton: k } = x.ButtonTemplates, E = w(Jt.KeyLabel, [l]), _ = Pc in v, O = {
    flex: 1,
    paddingLeft: 6,
    paddingRight: 6,
    fontWeight: "bold"
  };
  return _ ? C.jsxs(To, { container: !0, alignItems: "flex-start", spacing: 2, className: n, style: r, children: [C.jsx(To, { size: 5.5, children: C.jsx(CP, { fullWidth: !0, required: h, label: c ? E : void 0, defaultValue: l, disabled: a || m, id: `${s}-key`, name: `${s}-key`, onBlur: m ? void 0 : d, type: "text" }) }), C.jsx(To, { size: 5.5, children: t }), C.jsx(To, { sx: { mt: 1.5 }, children: C.jsx(k, { id: jl(s, "remove"), className: "rjsf-object-property-remove", iconType: "default", style: O, disabled: a || m, onClick: f, uiSchema: g, registry: b }) })] }, `${s}-key`) : C.jsx("div", { className: n, style: r, children: t });
}
function WDe() {
  return {
    ArrayFieldItemTemplate: qje,
    ArrayFieldTemplate: Gje,
    BaseInputTemplate: V1e,
    ButtonTemplates: {
      AddButton: $je,
      CopyButton: bDe,
      MoveDownButton: wDe,
      MoveUpButton: xDe,
      RemoveButton: pY,
      SubmitButton: TDe
    },
    DescriptionFieldTemplate: Y1e,
    ErrorListTemplate: mDe,
    FieldErrorTemplate: SDe,
    FieldHelpTemplate: kDe,
    FieldTemplate: _De,
    GridTemplate: EDe,
    MultiSchemaFieldTemplate: CDe,
    ObjectFieldTemplate: ODe,
    OptionalDataControlsTemplate: MDe,
    TitleFieldTemplate: VDe,
    WrapIfAdditionalTemplate: HDe
  };
}
function qDe(e) {
  return Ct("PrivateSwitchBase", e);
}
St("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
const GDe = (e) => {
  const {
    classes: t,
    checked: n,
    disabled: r,
    edge: a
  } = e, s = {
    root: ["root", n && "checked", r && "disabled", a && `edge${qe(a)}`],
    input: ["input"]
  };
  return Et(s, qDe, t);
}, KDe = $e(JS, {
  name: "MuiSwitchBase"
})({
  padding: 9,
  borderRadius: "50%",
  variants: [{
    props: {
      edge: "start",
      size: "small"
    },
    style: {
      marginLeft: -3
    }
  }, {
    props: ({
      edge: e,
      ownerState: t
    }) => e === "start" && t.size !== "small",
    style: {
      marginLeft: -12
    }
  }, {
    props: {
      edge: "end",
      size: "small"
    },
    style: {
      marginRight: -3
    }
  }, {
    props: ({
      edge: e,
      ownerState: t
    }) => e === "end" && t.size !== "small",
    style: {
      marginRight: -12
    }
  }]
}), YDe = $e("input", {
  name: "MuiSwitchBase",
  shouldForwardProp: ea
})({
  cursor: "inherit",
  position: "absolute",
  opacity: 0,
  width: "100%",
  height: "100%",
  top: 0,
  left: 0,
  margin: 0,
  padding: 0,
  zIndex: 1
}), hY = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const {
    autoFocus: n,
    checked: r,
    checkedIcon: a,
    defaultChecked: s,
    disabled: l,
    disableFocusRipple: c = !1,
    edge: d = !1,
    icon: f,
    id: m,
    inputProps: h,
    inputRef: v,
    name: g,
    onBlur: b,
    onChange: x,
    onFocus: w,
    readOnly: k,
    required: E = !1,
    tabIndex: _,
    type: O,
    value: N,
    slots: A = {},
    slotProps: R = {},
    ...D
  } = e, [I, z] = RS({
    controlled: r,
    default: !!s,
    name: "SwitchBase",
    state: "checked"
  }), B = Zl(), P = (W) => {
    w && w(W), B && B.onFocus && B.onFocus(W);
  }, H = (W) => {
    b && b(W), B && B.onBlur && B.onBlur(W);
  }, L = (W) => {
    if (W.nativeEvent.defaultPrevented)
      return;
    const J = W.target.checked;
    z(J), x && x(W, J);
  };
  let G = l;
  B && typeof G > "u" && (G = B.disabled);
  const $ = O === "checkbox" || O === "radio", K = {
    ...e,
    checked: I,
    disabled: G,
    disableFocusRipple: c,
    edge: d
  }, q = GDe(K), Z = {
    slots: A,
    slotProps: {
      input: h,
      ...R
    }
  }, [V, F] = Kn("root", {
    ref: t,
    elementType: KDe,
    className: q.root,
    shouldForwardComponentProp: !0,
    externalForwardedProps: {
      ...Z,
      component: "span",
      ...D
    },
    getSlotProps: (W) => ({
      ...W,
      onFocus: (J) => {
        W.onFocus?.(J), P(J);
      },
      onBlur: (J) => {
        W.onBlur?.(J), H(J);
      }
    }),
    ownerState: K,
    additionalProps: {
      centerRipple: !0,
      focusRipple: !c,
      disabled: G,
      role: void 0,
      tabIndex: null
    }
  }), [Y, U] = Kn("input", {
    ref: v,
    elementType: YDe,
    className: q.input,
    externalForwardedProps: Z,
    getSlotProps: (W) => ({
      ...W,
      onChange: (J) => {
        W.onChange?.(J), L(J);
      }
    }),
    ownerState: K,
    additionalProps: {
      autoFocus: n,
      checked: r,
      defaultChecked: s,
      disabled: G,
      id: $ ? m : void 0,
      name: g,
      readOnly: k,
      required: E,
      tabIndex: _,
      type: O,
      ...O === "checkbox" && N === void 0 ? {} : {
        value: N
      }
    }
  });
  return /* @__PURE__ */ C.jsxs(V, {
    ...F,
    children: [/* @__PURE__ */ C.jsx(Y, {
      ...U
    }), I ? a : f]
  });
}), XDe = Ni(/* @__PURE__ */ C.jsx("path", {
  d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
})), JDe = Ni(/* @__PURE__ */ C.jsx("path", {
  d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
})), QDe = Ni(/* @__PURE__ */ C.jsx("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
}));
function ZDe(e) {
  return Ct("MuiCheckbox", e);
}
const W5 = St("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium"]), eIe = (e) => {
  const {
    classes: t,
    indeterminate: n,
    color: r,
    size: a
  } = e, s = {
    root: ["root", n && "indeterminate", `color${qe(r)}`, `size${qe(a)}`]
  }, l = Et(s, ZDe, t);
  return {
    ...t,
    // forward the disabled and checked classes to the SwitchBase
    ...l
  };
}, tIe = $e(hY, {
  shouldForwardProp: (e) => ea(e) || e === "classes",
  name: "MuiCheckbox",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.indeterminate && t.indeterminate, t[`size${qe(n.size)}`], n.color !== "default" && t[`color${qe(n.color)}`]];
  }
})(Mt(({
  theme: e
}) => ({
  color: (e.vars || e).palette.text.secondary,
  variants: [{
    props: {
      color: "default",
      disableRipple: !1
    },
    style: {
      "&:hover": {
        backgroundColor: e.alpha((e.vars || e).palette.action.active, (e.vars || e).palette.action.hoverOpacity)
      }
    }
  }, ...Object.entries(e.palette).filter(Zo()).map(([t]) => ({
    props: {
      color: t,
      disableRipple: !1
    },
    style: {
      "&:hover": {
        backgroundColor: e.alpha((e.vars || e).palette[t].main, (e.vars || e).palette.action.hoverOpacity)
      }
    }
  })), ...Object.entries(e.palette).filter(Zo()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      [`&.${W5.checked}, &.${W5.indeterminate}`]: {
        color: (e.vars || e).palette[t].main
      },
      [`&.${W5.disabled}`]: {
        color: (e.vars || e).palette.action.disabled
      }
    }
  })), {
    // Should be last to override other colors
    props: {
      disableRipple: !1
    },
    style: {
      // Reset on touch devices, it doesn't add specificity
      "&:hover": {
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }]
}))), nIe = /* @__PURE__ */ C.jsx(JDe, {}), rIe = /* @__PURE__ */ C.jsx(XDe, {}), oIe = /* @__PURE__ */ C.jsx(QDe, {}), gY = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiCheckbox"
  }), {
    checkedIcon: r = nIe,
    color: a = "primary",
    icon: s = rIe,
    indeterminate: l = !1,
    indeterminateIcon: c = oIe,
    inputProps: d,
    size: f = "medium",
    disableRipple: m = !1,
    className: h,
    slots: v = {},
    slotProps: g = {},
    ...b
  } = n, x = l ? c : s, w = l ? c : r, k = {
    ...n,
    disableRipple: m,
    color: a,
    indeterminate: l,
    size: f
  }, E = eIe(k), _ = g.input ?? d, [O, N] = Kn("root", {
    ref: t,
    elementType: tIe,
    className: Ye(E.root, h),
    shouldForwardComponentProp: !0,
    externalForwardedProps: {
      slots: v,
      slotProps: g,
      ...b
    },
    ownerState: k,
    additionalProps: {
      type: "checkbox",
      icon: /* @__PURE__ */ M.cloneElement(x, {
        fontSize: x.props.fontSize ?? f
      }),
      checkedIcon: /* @__PURE__ */ M.cloneElement(w, {
        fontSize: w.props.fontSize ?? f
      }),
      disableRipple: m,
      slots: v,
      slotProps: {
        input: ZK(typeof _ == "function" ? _(k) : _, {
          "data-indeterminate": l
        })
      }
    }
  });
  return /* @__PURE__ */ C.jsx(O, {
    ...N,
    classes: E
  });
});
function aIe(e) {
  return Ct("MuiFormControlLabel", e);
}
const Ex = St("MuiFormControlLabel", ["root", "labelPlacementStart", "labelPlacementTop", "labelPlacementBottom", "disabled", "label", "error", "required", "asterisk"]), iIe = (e) => {
  const {
    classes: t,
    disabled: n,
    labelPlacement: r,
    error: a,
    required: s
  } = e, l = {
    root: ["root", n && "disabled", `labelPlacement${qe(r)}`, a && "error", s && "required"],
    label: ["label", n && "disabled"],
    asterisk: ["asterisk", a && "error"]
  };
  return Et(l, aIe, t);
}, sIe = $e("label", {
  name: "MuiFormControlLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [{
      [`& .${Ex.label}`]: t.label
    }, t.root, t[`labelPlacement${qe(n.labelPlacement)}`]];
  }
})(Mt(({
  theme: e
}) => ({
  display: "inline-flex",
  alignItems: "center",
  cursor: "pointer",
  // For correct alignment with the text.
  verticalAlign: "middle",
  WebkitTapHighlightColor: "transparent",
  marginLeft: -11,
  marginRight: 16,
  // used for row presentation of radio/checkbox
  [`&.${Ex.disabled}`]: {
    cursor: "default"
  },
  [`& .${Ex.label}`]: {
    [`&.${Ex.disabled}`]: {
      color: (e.vars || e).palette.text.disabled
    }
  },
  variants: [{
    props: {
      labelPlacement: "start"
    },
    style: {
      flexDirection: "row-reverse",
      marginRight: -11
    }
  }, {
    props: {
      labelPlacement: "top"
    },
    style: {
      flexDirection: "column-reverse"
    }
  }, {
    props: {
      labelPlacement: "bottom"
    },
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      labelPlacement: t
    }) => t === "start" || t === "top" || t === "bottom",
    style: {
      marginLeft: 16
      // used for row presentation of radio/checkbox
    }
  }]
}))), lIe = $e("span", {
  name: "MuiFormControlLabel",
  slot: "Asterisk"
})(Mt(({
  theme: e
}) => ({
  [`&.${Ex.error}`]: {
    color: (e.vars || e).palette.error.main
  }
}))), OP = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiFormControlLabel"
  }), {
    checked: r,
    className: a,
    componentsProps: s = {},
    control: l,
    disabled: c,
    disableTypography: d,
    inputRef: f,
    label: m,
    labelPlacement: h = "end",
    name: v,
    onChange: g,
    required: b,
    slots: x = {},
    slotProps: w = {},
    value: k,
    ...E
  } = n, _ = Zl(), O = c ?? l.props.disabled ?? _?.disabled, N = b ?? l.props.required, A = {
    disabled: O,
    required: N
  };
  ["checked", "name", "onChange", "value", "inputRef"].forEach((L) => {
    typeof l.props[L] > "u" && typeof n[L] < "u" && (A[L] = n[L]);
  });
  const R = Hd({
    props: n,
    muiFormControl: _,
    states: ["error"]
  }), D = {
    ...n,
    disabled: O,
    labelPlacement: h,
    required: N,
    error: R.error
  }, I = iIe(D), z = {
    slots: x,
    slotProps: {
      ...s,
      ...w
    }
  }, [B, P] = Kn("typography", {
    elementType: Dl,
    externalForwardedProps: z,
    ownerState: D
  });
  let H = m;
  return H != null && H.type !== Dl && !d && (H = /* @__PURE__ */ C.jsx(B, {
    component: "span",
    ...P,
    className: Ye(I.label, P?.className),
    children: H
  })), /* @__PURE__ */ C.jsxs(sIe, {
    className: Ye(I.root, a),
    ownerState: D,
    ref: t,
    ...E,
    children: [/* @__PURE__ */ M.cloneElement(l, A), N ? /* @__PURE__ */ C.jsxs("div", {
      children: [H, /* @__PURE__ */ C.jsxs(lIe, {
        ownerState: D,
        "aria-hidden": !0,
        className: I.asterisk,
        children: ["", "*"]
      })]
    }) : H]
  });
});
function uIe(e) {
  var t;
  const { schema: n, id: r, htmlName: a, value: s, disabled: l, readonly: c, label: d = "", hideLabel: f, autofocus: m, onChange: h, onBlur: v, onFocus: g, registry: b, options: x, uiSchema: w } = e, k = xt("DescriptionFieldTemplate", b, x), E = Lx(n), _ = (R, D) => h(D), O = () => v(r, s), N = () => g(r, s), A = (t = x.description) !== null && t !== void 0 ? t : n.description;
  return C.jsxs(C.Fragment, { children: [!f && A && C.jsx(k, { id: ah(r), description: A, schema: n, uiSchema: w, registry: b }), C.jsx(OP, { control: C.jsx(gY, { id: r, name: a || r, checked: typeof s > "u" ? !1 : !!s, required: E, disabled: l || c, autoFocus: m, onChange: _, onBlur: O, onFocus: N, "aria-describedby": ji(r) }), label: ih(d, f, !1) })] });
}
function cIe(e) {
  return Ct("MuiFormGroup", e);
}
St("MuiFormGroup", ["root", "row", "error"]);
const dIe = (e) => {
  const {
    classes: t,
    row: n,
    error: r
  } = e;
  return Et({
    root: ["root", n && "row", r && "error"]
  }, cIe, t);
}, fIe = $e("div", {
  name: "MuiFormGroup",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.row && t.row];
  }
})({
  display: "flex",
  flexDirection: "column",
  flexWrap: "wrap",
  variants: [{
    props: {
      row: !0
    },
    style: {
      flexDirection: "row"
    }
  }]
}), vY = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiFormGroup"
  }), {
    className: r,
    row: a = !1,
    ...s
  } = n, l = Zl(), c = Hd({
    props: n,
    muiFormControl: l,
    states: ["error"]
  }), d = {
    ...n,
    row: a,
    error: c.error
  }, f = dIe(d);
  return /* @__PURE__ */ C.jsx(fIe, {
    className: Ye(f.root, r),
    ownerState: d,
    ref: t,
    ...s
  });
});
function pIe({ label: e, hideLabel: t, id: n, htmlName: r, disabled: a, options: s, value: l, autofocus: c, readonly: d, required: f, onChange: m, onBlur: h, onFocus: v }) {
  const { enumOptions: g, enumDisabled: b, inline: x, emptyValue: w } = s, k = Array.isArray(l) ? l : [l], E = (N) => ({ target: { checked: A } }) => {
    m(A ? hK(N, k, g) : mK(N, k, g));
  }, _ = ({ target: N }) => h(n, ao(N && N.value, g, w)), O = ({ target: N }) => v(n, ao(N && N.value, g, w));
  return C.jsxs(C.Fragment, { children: [ih(C.jsx(FC, { required: f, htmlFor: n, children: e || void 0 }), t), C.jsx(vY, { id: n, row: !!x, children: Array.isArray(g) && g.map((N, A) => {
    const R = CC(N.value, k), D = Array.isArray(b) && b.indexOf(N.value) !== -1, I = C.jsx(gY, { id: MC(n, A), name: r || n, checked: R, disabled: a || D || d, autoFocus: c && A === 0, onChange: E(A), onBlur: _, onFocus: O, "aria-describedby": ji(n) });
    return C.jsx(OP, { control: I, label: N.label }, A);
  }) })] });
}
const mIe = Ni(/* @__PURE__ */ C.jsx("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
})), hIe = Ni(/* @__PURE__ */ C.jsx("path", {
  d: "M8.465 8.465C9.37 7.56 10.62 7 12 7C14.76 7 17 9.24 17 12C17 13.38 16.44 14.63 15.535 15.535C14.63 16.44 13.38 17 12 17C9.24 17 7 14.76 7 12C7 10.62 7.56 9.37 8.465 8.465Z"
})), gIe = $e("span", {
  name: "MuiRadioButtonIcon",
  shouldForwardProp: ea
})({
  position: "relative",
  display: "flex"
}), vIe = $e(mIe, {
  name: "MuiRadioButtonIcon"
})({
  // Scale applied to prevent dot misalignment in Safari
  transform: "scale(1)"
}), yIe = $e(hIe, {
  name: "MuiRadioButtonIcon"
})(Mt(({
  theme: e
}) => ({
  left: 0,
  position: "absolute",
  transform: "scale(0)",
  transition: e.transitions.create("transform", {
    easing: e.transitions.easing.easeIn,
    duration: e.transitions.duration.shortest
  }),
  variants: [{
    props: {
      checked: !0
    },
    style: {
      transform: "scale(1)",
      transition: e.transitions.create("transform", {
        easing: e.transitions.easing.easeOut,
        duration: e.transitions.duration.shortest
      })
    }
  }]
})));
function yY(e) {
  const {
    checked: t = !1,
    classes: n = {},
    fontSize: r
  } = e, a = {
    ...e,
    checked: t
  };
  return /* @__PURE__ */ C.jsxs(gIe, {
    className: n.root,
    ownerState: a,
    children: [/* @__PURE__ */ C.jsx(vIe, {
      fontSize: r,
      className: n.background,
      ownerState: a
    }), /* @__PURE__ */ C.jsx(yIe, {
      fontSize: r,
      className: n.dot,
      ownerState: a
    })]
  });
}
const bY = /* @__PURE__ */ M.createContext(void 0);
function bIe() {
  return M.useContext(bY);
}
function wIe(e) {
  return Ct("MuiRadio", e);
}
const C9 = St("MuiRadio", ["root", "checked", "disabled", "colorPrimary", "colorSecondary", "sizeSmall"]), xIe = (e) => {
  const {
    classes: t,
    color: n,
    size: r
  } = e, a = {
    root: ["root", `color${qe(n)}`, r !== "medium" && `size${qe(r)}`]
  };
  return {
    ...t,
    ...Et(a, wIe, t)
  };
}, SIe = $e(hY, {
  shouldForwardProp: (e) => ea(e) || e === "classes",
  name: "MuiRadio",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.size !== "medium" && t[`size${qe(n.size)}`], t[`color${qe(n.color)}`]];
  }
})(Mt(({
  theme: e
}) => ({
  color: (e.vars || e).palette.text.secondary,
  [`&.${C9.disabled}`]: {
    color: (e.vars || e).palette.action.disabled
  },
  variants: [{
    props: {
      color: "default",
      disabled: !1,
      disableRipple: !1
    },
    style: {
      "&:hover": {
        backgroundColor: e.alpha((e.vars || e).palette.action.active, (e.vars || e).palette.action.hoverOpacity)
      }
    }
  }, ...Object.entries(e.palette).filter(Zo()).map(([t]) => ({
    props: {
      color: t,
      disabled: !1,
      disableRipple: !1
    },
    style: {
      "&:hover": {
        backgroundColor: e.alpha((e.vars || e).palette[t].main, (e.vars || e).palette.action.hoverOpacity)
      }
    }
  })), ...Object.entries(e.palette).filter(Zo()).map(([t]) => ({
    props: {
      color: t,
      disabled: !1
    },
    style: {
      [`&.${C9.checked}`]: {
        color: (e.vars || e).palette[t].main
      }
    }
  })), {
    // Should be last to override other colors
    props: {
      disableRipple: !1
    },
    style: {
      // Reset on touch devices, it doesn't add specificity
      "&:hover": {
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }]
})));
function kIe(e, t) {
  return typeof t == "object" && t !== null ? e === t : String(e) === String(t);
}
const _Ie = /* @__PURE__ */ C.jsx(yY, {
  checked: !0
}), EIe = /* @__PURE__ */ C.jsx(yY, {}), CIe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiRadio"
  }), {
    checked: r,
    checkedIcon: a = _Ie,
    color: s = "primary",
    icon: l = EIe,
    name: c,
    onChange: d,
    size: f = "medium",
    className: m,
    disabled: h,
    disableRipple: v = !1,
    slots: g = {},
    slotProps: b = {},
    inputProps: x,
    ...w
  } = n, k = Zl();
  let E = h;
  k && typeof E > "u" && (E = k.disabled), E ?? (E = !1);
  const _ = {
    ...n,
    disabled: E,
    disableRipple: v,
    color: s,
    size: f
  }, O = xIe(_), N = bIe();
  let A = r;
  const R = J3(d, N && N.onChange);
  let D = c;
  N && (typeof A > "u" && (A = kIe(N.value, n.value)), typeof D > "u" && (D = N.name));
  const I = b.input ?? x, [z, B] = Kn("root", {
    ref: t,
    elementType: SIe,
    className: Ye(O.root, m),
    shouldForwardComponentProp: !0,
    externalForwardedProps: {
      slots: g,
      slotProps: b,
      ...w
    },
    getSlotProps: (P) => ({
      ...P,
      onChange: (H, ...L) => {
        P.onChange?.(H, ...L), R(H, ...L);
      }
    }),
    ownerState: _,
    additionalProps: {
      type: "radio",
      icon: /* @__PURE__ */ M.cloneElement(l, {
        fontSize: l.props.fontSize ?? f
      }),
      checkedIcon: /* @__PURE__ */ M.cloneElement(a, {
        fontSize: a.props.fontSize ?? f
      }),
      disabled: E,
      name: D,
      checked: A,
      slots: g,
      slotProps: {
        // Do not forward `slotProps.root` again because it's already handled by the `RootSlot` in this file.
        input: typeof I == "function" ? I(_) : I
      }
    }
  });
  return /* @__PURE__ */ C.jsx(z, {
    ...B,
    classes: O
  });
});
function OIe(e) {
  return Ct("MuiRadioGroup", e);
}
St("MuiRadioGroup", ["root", "row", "error"]);
const MIe = (e) => {
  const {
    classes: t,
    row: n,
    error: r
  } = e;
  return Et({
    root: ["root", n && "row", r && "error"]
  }, OIe, t);
}, NIe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions: n,
    children: r,
    className: a,
    defaultValue: s,
    name: l,
    onChange: c,
    value: d,
    ...f
  } = e, m = M.useRef(null), h = MIe(e), [v, g] = RS({
    controlled: d,
    default: s,
    name: "RadioGroup"
  });
  M.useImperativeHandle(n, () => ({
    focus: () => {
      let k = m.current.querySelector("input:not(:disabled):checked");
      k || (k = m.current.querySelector("input:not(:disabled)")), k && k.focus();
    }
  }), []);
  const b = io(t, m), x = zg(l), w = M.useMemo(() => ({
    name: x,
    onChange(k) {
      g(k.target.value), c && c(k, k.target.value);
    },
    value: v
  }), [x, c, g, v]);
  return /* @__PURE__ */ C.jsx(bY.Provider, {
    value: w,
    children: /* @__PURE__ */ C.jsx(vY, {
      role: "radiogroup",
      ref: b,
      className: Ye(h.root, a),
      ...f,
      children: r
    })
  });
});
function AIe({ id: e, htmlName: t, options: n, value: r, required: a, disabled: s, readonly: l, label: c, hideLabel: d, onChange: f, onBlur: m, onFocus: h }) {
  var v;
  const { enumOptions: g, enumDisabled: b, emptyValue: x } = n, w = (N, A) => f(ao(A, g, x)), k = ({ target: N }) => m(e, ao(N && N.value, g, x)), E = ({ target: N }) => h(e, ao(N && N.value, g, x)), _ = n ? n.inline : !1, O = (v = Zj(r, g)) !== null && v !== void 0 ? v : null;
  return C.jsxs(C.Fragment, { children: [ih(C.jsx(FC, { required: a, htmlFor: e, children: c || void 0 }), d), C.jsx(NIe, { id: e, name: t || e, value: O, row: _, onChange: w, onBlur: k, onFocus: E, "aria-describedby": ji(e), children: Array.isArray(g) && g.map((N, A) => {
    const R = Array.isArray(b) && b.indexOf(N.value) !== -1;
    return C.jsx(OP, { control: C.jsx(CIe, { name: t || e, id: MC(e, A), color: "primary" }), label: N.label, value: String(A), disabled: s || R || l }, A);
  }) })] });
}
const RIe = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  whiteSpace: "nowrap",
  width: "1px"
};
function jIe(e, t, n = (r, a) => r === a) {
  return e.length === t.length && e.every((r, a) => n(r, t[a]));
}
const PIe = 2;
function Ah(e, t, n, r, a) {
  return n === 1 ? Math.min(e + t, a) : Math.max(e - t, r);
}
function wY(e, t) {
  return e - t;
}
function O9(e, t) {
  const {
    index: n
  } = e.reduce((r, a, s) => {
    const l = Math.abs(t - a);
    return r === null || l < r.distance || l === r.distance ? {
      distance: l,
      index: s
    } : r;
  }, null) ?? {};
  return n;
}
function s_(e, t) {
  if (t.current !== void 0 && e.changedTouches) {
    const n = e;
    for (let r = 0; r < n.changedTouches.length; r += 1) {
      const a = n.changedTouches[r];
      if (a.identifier === t.current)
        return {
          x: a.clientX,
          y: a.clientY
        };
    }
    return !1;
  }
  return {
    x: e.clientX,
    y: e.clientY
  };
}
function K2(e, t, n) {
  return (e - t) * 100 / (n - t);
}
function DIe(e, t, n) {
  return (n - t) * e + t;
}
function IIe(e) {
  if (Math.abs(e) < 1) {
    const n = e.toExponential().split("e-"), r = n[0].split(".")[1];
    return (r ? r.length : 0) + parseInt(n[1], 10);
  }
  const t = e.toString().split(".")[1];
  return t ? t.length : 0;
}
function $Ie(e, t, n) {
  const r = Math.round((e - n) / t) * t + n;
  return Number(r.toFixed(IIe(t)));
}
function M9({
  values: e,
  newValue: t,
  index: n
}) {
  const r = e.slice();
  return r[n] = t, r.sort(wY);
}
function l_({
  sliderRef: e,
  activeIndex: t,
  setActive: n
}) {
  const r = Ca(e.current);
  (!e.current?.contains(r.activeElement) || Number(r?.activeElement?.getAttribute("data-index")) !== t) && e.current?.querySelector(`[type="range"][data-index="${t}"]`).focus(), n && n(t);
}
function u_(e, t) {
  return typeof e == "number" && typeof t == "number" ? e === t : typeof e == "object" && typeof t == "object" ? jIe(e, t) : !1;
}
const zIe = {
  horizontal: {
    offset: (e) => ({
      left: `${e}%`
    }),
    leap: (e) => ({
      width: `${e}%`
    })
  },
  "horizontal-reverse": {
    offset: (e) => ({
      right: `${e}%`
    }),
    leap: (e) => ({
      width: `${e}%`
    })
  },
  vertical: {
    offset: (e) => ({
      bottom: `${e}%`
    }),
    leap: (e) => ({
      height: `${e}%`
    })
  }
}, TIe = (e) => e;
let c_;
function N9() {
  return c_ === void 0 && (typeof CSS < "u" && typeof CSS.supports == "function" ? c_ = CSS.supports("touch-action", "none") : c_ = !0), c_;
}
function LIe(e) {
  const {
    "aria-labelledby": t,
    defaultValue: n,
    disabled: r = !1,
    disableSwap: a = !1,
    isRtl: s = !1,
    marks: l = !1,
    max: c = 100,
    min: d = 0,
    name: f,
    onChange: m,
    onChangeCommitted: h,
    orientation: v = "horizontal",
    rootRef: g,
    scale: b = TIe,
    step: x = 1,
    shiftStep: w = 10,
    tabIndex: k,
    value: E
  } = e, _ = M.useRef(void 0), [O, N] = M.useState(-1), [A, R] = M.useState(-1), [D, I] = M.useState(!1), z = M.useRef(0), B = M.useRef(null), [P, H] = RS({
    controlled: E,
    default: n ?? d,
    name: "Slider"
  }), L = m && ((Ce, Me, he) => {
    const ye = Ce.nativeEvent || Ce, Ee = new ye.constructor(ye.type, ye);
    Object.defineProperty(Ee, "target", {
      writable: !0,
      value: {
        value: Me,
        name: f
      }
    }), B.current = Me, m(Ee, Me, he);
  }), G = Array.isArray(P);
  let $ = G ? P.slice().sort(wY) : [P];
  $ = $.map((Ce) => Ce == null ? d : $h(Ce, d, c));
  const K = l === !0 && x !== null ? [...Array(Math.floor((c - d) / x) + 1)].map((Ce, Me) => ({
    value: d + x * Me
  })) : l || [], q = K.map((Ce) => Ce.value), [Z, V] = M.useState(-1), F = M.useRef(null), Y = io(g, F), U = (Ce) => (Me) => {
    const he = Number(Me.currentTarget.getAttribute("data-index"));
    a2(Me.target) && V(he), R(he), Ce?.onFocus?.(Me);
  }, W = (Ce) => (Me) => {
    a2(Me.target) || V(-1), R(-1), Ce?.onBlur?.(Me);
  }, J = (Ce, Me) => {
    const he = Number(Ce.currentTarget.getAttribute("data-index")), ye = $[he], Ee = q.indexOf(ye);
    let Te = Me;
    if (K && x == null) {
      const Fe = q[q.length - 1];
      Te >= Fe ? Te = Fe : Te <= q[0] ? Te = q[0] : Te = Te < ye ? q[Ee - 1] : q[Ee + 1];
    }
    if (Te = $h(Te, d, c), G) {
      a && (Te = $h(Te, $[he - 1] || -1 / 0, $[he + 1] || 1 / 0));
      const Fe = Te;
      Te = M9({
        values: $,
        newValue: Te,
        index: he
      });
      let Ut = he;
      a || (Ut = Te.indexOf(Fe)), l_({
        sliderRef: F,
        activeIndex: Ut
      });
    }
    H(Te), V(he), L && !u_(Te, P) && L(Ce, Te, he), h && h(Ce, B.current ?? Te);
  }, oe = (Ce) => (Me) => {
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "PageUp", "PageDown", "Home", "End"].includes(Me.key)) {
      Me.preventDefault();
      const he = Number(Me.currentTarget.getAttribute("data-index")), ye = $[he];
      let Ee = null;
      if (x != null) {
        const Te = Me.shiftKey ? w : x;
        switch (Me.key) {
          case "ArrowUp":
            Ee = Ah(ye, Te, 1, d, c);
            break;
          case "ArrowRight":
            Ee = Ah(ye, Te, s ? -1 : 1, d, c);
            break;
          case "ArrowDown":
            Ee = Ah(ye, Te, -1, d, c);
            break;
          case "ArrowLeft":
            Ee = Ah(ye, Te, s ? 1 : -1, d, c);
            break;
          case "PageUp":
            Ee = Ah(ye, w, 1, d, c);
            break;
          case "PageDown":
            Ee = Ah(ye, w, -1, d, c);
            break;
          case "Home":
            Ee = d;
            break;
          case "End":
            Ee = c;
            break;
        }
      } else if (K) {
        const Te = q[q.length - 1], Fe = q.indexOf(ye), Ut = [s ? "ArrowRight" : "ArrowLeft", "ArrowDown", "PageDown", "Home"], Vt = [s ? "ArrowLeft" : "ArrowRight", "ArrowUp", "PageUp", "End"];
        Ut.includes(Me.key) ? Fe === 0 ? Ee = q[0] : Ee = q[Fe - 1] : Vt.includes(Me.key) && (Fe === q.length - 1 ? Ee = Te : Ee = q[Fe + 1]);
      }
      Ee != null && J(Me, Ee);
    }
    Ce?.onKeyDown?.(Me);
  };
  Zs(() => {
    r && F.current.contains(document.activeElement) && document.activeElement?.blur();
  }, [r]), r && O !== -1 && N(-1), r && Z !== -1 && V(-1);
  const fe = (Ce) => (Me) => {
    Ce.onChange?.(Me), J(Me, Me.target.valueAsNumber);
  }, ie = M.useRef(void 0);
  let ce = v;
  s && v === "horizontal" && (ce += "-reverse");
  const ge = ({
    finger: Ce,
    move: Me = !1
  }) => {
    const {
      current: he
    } = F, {
      width: ye,
      height: Ee,
      bottom: Te,
      left: Fe
    } = he.getBoundingClientRect();
    let Ut;
    ce.startsWith("vertical") ? Ut = (Te - Ce.y) / Ee : Ut = (Ce.x - Fe) / ye, ce.includes("-reverse") && (Ut = 1 - Ut);
    let Vt;
    if (Vt = DIe(Ut, d, c), x)
      Vt = $Ie(Vt, x, d);
    else {
      const Nt = O9(q, Vt);
      Vt = q[Nt];
    }
    Vt = $h(Vt, d, c);
    let Xt = 0;
    if (G) {
      Me ? Xt = ie.current : Xt = O9($, Vt), a && (Vt = $h(Vt, $[Xt - 1] || -1 / 0, $[Xt + 1] || 1 / 0));
      const Nt = Vt;
      Vt = M9({
        values: $,
        newValue: Vt,
        index: Xt
      }), a && Me || (Xt = Vt.indexOf(Nt), ie.current = Xt);
    }
    return {
      newValue: Vt,
      activeIndex: Xt
    };
  }, re = Tl((Ce) => {
    const Me = s_(Ce, _);
    if (!Me)
      return;
    if (z.current += 1, Ce.type === "mousemove" && Ce.buttons === 0) {
      le(Ce);
      return;
    }
    const {
      newValue: he,
      activeIndex: ye
    } = ge({
      finger: Me,
      move: !0
    });
    l_({
      sliderRef: F,
      activeIndex: ye,
      setActive: N
    }), H(he), !D && z.current > PIe && I(!0), L && !u_(he, P) && L(Ce, he, ye);
  }), le = Tl((Ce) => {
    const Me = s_(Ce, _);
    if (I(!1), !Me)
      return;
    const {
      newValue: he
    } = ge({
      finger: Me,
      move: !0
    });
    N(-1), Ce.type === "touchend" && R(-1), h && h(Ce, B.current ?? he), _.current = void 0, ve();
  }), me = Tl((Ce) => {
    if (r)
      return;
    N9() || Ce.preventDefault();
    const Me = Ce.changedTouches[0];
    Me != null && (_.current = Me.identifier);
    const he = s_(Ce, _);
    if (he !== !1) {
      const {
        newValue: Ee,
        activeIndex: Te
      } = ge({
        finger: he
      });
      l_({
        sliderRef: F,
        activeIndex: Te,
        setActive: N
      }), H(Ee), L && !u_(Ee, P) && L(Ce, Ee, Te);
    }
    z.current = 0;
    const ye = Ca(F.current);
    ye.addEventListener("touchmove", re, {
      passive: !0
    }), ye.addEventListener("touchend", le, {
      passive: !0
    });
  }), ve = M.useCallback(() => {
    const Ce = Ca(F.current);
    Ce.removeEventListener("mousemove", re), Ce.removeEventListener("mouseup", le), Ce.removeEventListener("touchmove", re), Ce.removeEventListener("touchend", le);
  }, [le, re]);
  M.useEffect(() => {
    const {
      current: Ce
    } = F;
    return Ce.addEventListener("touchstart", me, {
      passive: N9()
    }), () => {
      Ce.removeEventListener("touchstart", me), ve();
    };
  }, [ve, me]), M.useEffect(() => {
    r && ve();
  }, [r, ve]);
  const xe = (Ce) => (Me) => {
    if (Ce.onMouseDown?.(Me), r || Me.defaultPrevented || Me.button !== 0)
      return;
    Me.preventDefault();
    const he = s_(Me, _);
    if (he !== !1) {
      const {
        newValue: Ee,
        activeIndex: Te
      } = ge({
        finger: he
      });
      l_({
        sliderRef: F,
        activeIndex: Te,
        setActive: N
      }), H(Ee), L && !u_(Ee, P) && L(Me, Ee, Te);
    }
    z.current = 0;
    const ye = Ca(F.current);
    ye.addEventListener("mousemove", re, {
      passive: !0
    }), ye.addEventListener("mouseup", le);
  }, _e = K2(G ? $[0] : d, d, c), Ge = K2($[$.length - 1], d, c) - _e, Xe = (Ce = {}) => {
    const Me = Rx(Ce), he = {
      onMouseDown: xe(Me || {})
    }, ye = {
      ...Me,
      ...he
    };
    return {
      ...Ce,
      ref: Y,
      ...ye
    };
  }, tt = (Ce) => (Me) => {
    Ce.onMouseOver?.(Me);
    const he = Number(Me.currentTarget.getAttribute("data-index"));
    R(he);
  }, nt = (Ce) => (Me) => {
    Ce.onMouseLeave?.(Me), R(-1);
  }, je = (Ce = {}) => {
    const Me = Rx(Ce), he = {
      onMouseOver: tt(Me || {}),
      onMouseLeave: nt(Me || {})
    };
    return {
      ...Ce,
      ...Me,
      ...he
    };
  }, cn = (Ce) => ({
    // So the non active thumb doesn't show its label on hover.
    pointerEvents: O !== -1 && O !== Ce ? "none" : void 0
  });
  let pt;
  return v === "vertical" && (pt = s ? "vertical-rl" : "vertical-lr"), {
    active: O,
    axis: ce,
    axisProps: zIe,
    dragging: D,
    focusedThumbIndex: Z,
    getHiddenInputProps: (Ce = {}) => {
      const Me = Rx(Ce), he = {
        onChange: fe(Me || {}),
        onFocus: U(Me || {}),
        onBlur: W(Me || {}),
        onKeyDown: oe(Me || {})
      }, ye = {
        ...Me,
        ...he
      };
      return {
        tabIndex: k,
        "aria-labelledby": t,
        "aria-orientation": v,
        "aria-valuemax": b(c),
        "aria-valuemin": b(d),
        name: f,
        type: "range",
        min: e.min,
        max: e.max,
        step: e.step === null && e.marks ? "any" : e.step ?? void 0,
        disabled: r,
        ...Ce,
        ...ye,
        style: {
          ...RIe,
          direction: s ? "rtl" : "ltr",
          // So that VoiceOver's focus indicator matches the thumb's dimensions
          width: "100%",
          height: "100%",
          writingMode: pt
        }
      };
    },
    getRootProps: Xe,
    getThumbProps: je,
    marks: K,
    open: A,
    range: G,
    rootRef: Y,
    trackLeap: Ge,
    trackOffset: _e,
    values: $,
    getThumbStyle: cn
  };
}
const FIe = (e) => !e || !Ll(e);
function BIe(e) {
  return Ct("MuiSlider", e);
}
const Vi = St("MuiSlider", ["root", "active", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "disabled", "dragging", "focusVisible", "mark", "markActive", "marked", "markLabel", "markLabelActive", "rail", "sizeSmall", "thumb", "thumbColorPrimary", "thumbColorSecondary", "thumbColorError", "thumbColorSuccess", "thumbColorInfo", "thumbColorWarning", "track", "trackInverted", "trackFalse", "thumbSizeSmall", "valueLabel", "valueLabelOpen", "valueLabelCircle", "valueLabelLabel", "vertical"]), UIe = (e) => {
  const {
    open: t
  } = e;
  return {
    offset: Ye(t && Vi.valueLabelOpen),
    circle: Vi.valueLabelCircle,
    label: Vi.valueLabelLabel
  };
};
function VIe(e) {
  const {
    children: t,
    className: n,
    value: r
  } = e, a = UIe(e);
  return t ? /* @__PURE__ */ M.cloneElement(t, {
    className: t.props.className
  }, /* @__PURE__ */ C.jsxs(M.Fragment, {
    children: [t.props.children, /* @__PURE__ */ C.jsx("span", {
      className: Ye(a.offset, n),
      "aria-hidden": !0,
      children: /* @__PURE__ */ C.jsx("span", {
        className: a.circle,
        children: /* @__PURE__ */ C.jsx("span", {
          className: a.label,
          children: r
        })
      })
    })]
  })) : null;
}
function A9(e) {
  return e;
}
const HIe = $e("span", {
  name: "MuiSlider",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[`color${qe(n.color)}`], n.size !== "medium" && t[`size${qe(n.size)}`], n.marked && t.marked, n.orientation === "vertical" && t.vertical, n.track === "inverted" && t.trackInverted, n.track === !1 && t.trackFalse];
  }
})(Mt(({
  theme: e
}) => ({
  borderRadius: 12,
  boxSizing: "content-box",
  display: "inline-block",
  position: "relative",
  cursor: "pointer",
  touchAction: "none",
  WebkitTapHighlightColor: "transparent",
  "@media print": {
    colorAdjust: "exact"
  },
  [`&.${Vi.disabled}`]: {
    pointerEvents: "none",
    cursor: "default",
    color: (e.vars || e).palette.grey[400]
  },
  [`&.${Vi.dragging}`]: {
    [`& .${Vi.thumb}, & .${Vi.track}`]: {
      transition: "none"
    }
  },
  variants: [...Object.entries(e.palette).filter(Zo()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      color: (e.vars || e).palette[t].main
    }
  })), {
    props: {
      orientation: "horizontal"
    },
    style: {
      height: 4,
      width: "100%",
      padding: "13px 0",
      // The primary input mechanism of the device includes a pointing device of limited accuracy.
      "@media (pointer: coarse)": {
        // Reach 42px touch target, about ~8mm on screen.
        padding: "20px 0"
      }
    }
  }, {
    props: {
      orientation: "horizontal",
      size: "small"
    },
    style: {
      height: 2
    }
  }, {
    props: {
      orientation: "horizontal",
      marked: !0
    },
    style: {
      marginBottom: 20
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      width: 4,
      padding: "0 13px",
      // The primary input mechanism of the device includes a pointing device of limited accuracy.
      "@media (pointer: coarse)": {
        // Reach 42px touch target, about ~8mm on screen.
        padding: "0 20px"
      }
    }
  }, {
    props: {
      orientation: "vertical",
      size: "small"
    },
    style: {
      width: 2
    }
  }, {
    props: {
      orientation: "vertical",
      marked: !0
    },
    style: {
      marginRight: 44
    }
  }]
}))), WIe = $e("span", {
  name: "MuiSlider",
  slot: "Rail"
})({
  display: "block",
  position: "absolute",
  borderRadius: "inherit",
  backgroundColor: "currentColor",
  opacity: 0.38,
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      width: "100%",
      height: "inherit",
      top: "50%",
      transform: "translateY(-50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      width: "inherit",
      left: "50%",
      transform: "translateX(-50%)"
    }
  }, {
    props: {
      track: "inverted"
    },
    style: {
      opacity: 1
    }
  }]
}), qIe = $e("span", {
  name: "MuiSlider",
  slot: "Track"
})(Mt(({
  theme: e
}) => ({
  display: "block",
  position: "absolute",
  borderRadius: "inherit",
  border: "1px solid currentColor",
  backgroundColor: "currentColor",
  transition: e.transitions.create(["left", "width", "bottom", "height"], {
    duration: e.transitions.duration.shortest
  }),
  variants: [{
    props: {
      size: "small"
    },
    style: {
      border: "none"
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      height: "inherit",
      top: "50%",
      transform: "translateY(-50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      width: "inherit",
      left: "50%",
      transform: "translateX(-50%)"
    }
  }, {
    props: {
      track: !1
    },
    style: {
      display: "none"
    }
  }, ...Object.entries(e.palette).filter(Zo()).map(([t]) => ({
    props: {
      color: t,
      track: "inverted"
    },
    style: {
      ...e.vars ? {
        backgroundColor: e.vars.palette.Slider[`${t}Track`],
        borderColor: e.vars.palette.Slider[`${t}Track`]
      } : {
        backgroundColor: e.lighten(e.palette[t].main, 0.62),
        borderColor: e.lighten(e.palette[t].main, 0.62),
        ...e.applyStyles("dark", {
          backgroundColor: e.darken(e.palette[t].main, 0.5)
        }),
        ...e.applyStyles("dark", {
          borderColor: e.darken(e.palette[t].main, 0.5)
        })
      }
    }
  }))]
}))), GIe = $e("span", {
  name: "MuiSlider",
  slot: "Thumb",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.thumb, t[`thumbColor${qe(n.color)}`], n.size !== "medium" && t[`thumbSize${qe(n.size)}`]];
  }
})(Mt(({
  theme: e
}) => ({
  position: "absolute",
  width: 20,
  height: 20,
  boxSizing: "border-box",
  borderRadius: "50%",
  outline: 0,
  backgroundColor: "currentColor",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  transition: e.transitions.create(["box-shadow", "left", "bottom"], {
    duration: e.transitions.duration.shortest
  }),
  "&::before": {
    position: "absolute",
    content: '""',
    borderRadius: "inherit",
    width: "100%",
    height: "100%",
    boxShadow: (e.vars || e).shadows[2]
  },
  "&::after": {
    position: "absolute",
    content: '""',
    borderRadius: "50%",
    // 42px is the hit target
    width: 42,
    height: 42,
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)"
  },
  [`&.${Vi.disabled}`]: {
    "&:hover": {
      boxShadow: "none"
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      width: 12,
      height: 12,
      "&::before": {
        boxShadow: "none"
      }
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      top: "50%",
      transform: "translate(-50%, -50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: "50%",
      transform: "translate(-50%, 50%)"
    }
  }, ...Object.entries(e.palette).filter(Zo()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      [`&:hover, &.${Vi.focusVisible}`]: {
        boxShadow: `0px 0px 0px 8px ${e.alpha((e.vars || e).palette[t].main, 0.16)}`,
        "@media (hover: none)": {
          boxShadow: "none"
        }
      },
      [`&.${Vi.active}`]: {
        boxShadow: `0px 0px 0px 14px ${e.alpha((e.vars || e).palette[t].main, 0.16)}`
      }
    }
  }))]
}))), KIe = $e(VIe, {
  name: "MuiSlider",
  slot: "ValueLabel"
})(Mt(({
  theme: e
}) => ({
  zIndex: 1,
  whiteSpace: "nowrap",
  ...e.typography.body2,
  fontWeight: 500,
  transition: e.transitions.create(["transform"], {
    duration: e.transitions.duration.shortest
  }),
  position: "absolute",
  backgroundColor: (e.vars || e).palette.grey[600],
  borderRadius: 2,
  color: (e.vars || e).palette.common.white,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  padding: "0.25rem 0.75rem",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      transform: "translateY(-100%) scale(0)",
      top: "-10px",
      transformOrigin: "bottom center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, 50%) rotate(45deg)",
        backgroundColor: "inherit",
        bottom: 0,
        left: "50%"
      },
      [`&.${Vi.valueLabelOpen}`]: {
        transform: "translateY(-100%) scale(1)"
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      transform: "translateY(-50%) scale(0)",
      right: "30px",
      top: "50%",
      transformOrigin: "right center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, -50%) rotate(45deg)",
        backgroundColor: "inherit",
        right: -8,
        top: "50%"
      },
      [`&.${Vi.valueLabelOpen}`]: {
        transform: "translateY(-50%) scale(1)"
      }
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      fontSize: e.typography.pxToRem(12),
      padding: "0.25rem 0.5rem"
    }
  }, {
    props: {
      orientation: "vertical",
      size: "small"
    },
    style: {
      right: "20px"
    }
  }]
}))), YIe = $e("span", {
  name: "MuiSlider",
  slot: "Mark",
  shouldForwardProp: (e) => EE(e) && e !== "markActive",
  overridesResolver: (e, t) => {
    const {
      markActive: n
    } = e;
    return [t.mark, n && t.markActive];
  }
})(Mt(({
  theme: e
}) => ({
  position: "absolute",
  width: 2,
  height: 2,
  borderRadius: 1,
  backgroundColor: "currentColor",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: "50%",
      transform: "translate(-1px, -50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: "50%",
      transform: "translate(-50%, 1px)"
    }
  }, {
    props: {
      markActive: !0
    },
    style: {
      backgroundColor: (e.vars || e).palette.background.paper,
      opacity: 0.8
    }
  }]
}))), XIe = $e("span", {
  name: "MuiSlider",
  slot: "MarkLabel",
  shouldForwardProp: (e) => EE(e) && e !== "markLabelActive"
})(Mt(({
  theme: e
}) => ({
  ...e.typography.body2,
  color: (e.vars || e).palette.text.secondary,
  position: "absolute",
  whiteSpace: "nowrap",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: 30,
      transform: "translateX(-50%)",
      "@media (pointer: coarse)": {
        top: 40
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: 36,
      transform: "translateY(50%)",
      "@media (pointer: coarse)": {
        left: 44
      }
    }
  }, {
    props: {
      markLabelActive: !0
    },
    style: {
      color: (e.vars || e).palette.text.primary
    }
  }]
}))), JIe = (e) => {
  const {
    disabled: t,
    dragging: n,
    marked: r,
    orientation: a,
    track: s,
    classes: l,
    color: c,
    size: d
  } = e, f = {
    root: ["root", t && "disabled", n && "dragging", r && "marked", a === "vertical" && "vertical", s === "inverted" && "trackInverted", s === !1 && "trackFalse", c && `color${qe(c)}`, d && `size${qe(d)}`],
    rail: ["rail"],
    track: ["track"],
    mark: ["mark"],
    markActive: ["markActive"],
    markLabel: ["markLabel"],
    markLabelActive: ["markLabelActive"],
    valueLabel: ["valueLabel"],
    thumb: ["thumb", t && "disabled", d && `thumbSize${qe(d)}`, c && `thumbColor${qe(c)}`],
    active: ["active"],
    disabled: ["disabled"],
    focusVisible: ["focusVisible"]
  };
  return Et(f, BIe, l);
}, QIe = ({
  children: e
}) => e, ZIe = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiSlider"
  }), r = O7(), {
    "aria-label": a,
    "aria-valuetext": s,
    "aria-labelledby": l,
    // eslint-disable-next-line react/prop-types
    component: c = "span",
    components: d = {},
    componentsProps: f = {},
    color: m = "primary",
    classes: h,
    className: v,
    disableSwap: g = !1,
    disabled: b = !1,
    getAriaLabel: x,
    getAriaValueText: w,
    marks: k = !1,
    max: E = 100,
    min: _ = 0,
    name: O,
    onChange: N,
    onChangeCommitted: A,
    orientation: R = "horizontal",
    shiftStep: D = 10,
    size: I = "medium",
    step: z = 1,
    scale: B = A9,
    slotProps: P,
    slots: H,
    tabIndex: L,
    track: G = "normal",
    value: $,
    valueLabelDisplay: K = "off",
    valueLabelFormat: q = A9,
    ...Z
  } = n, V = {
    ...n,
    isRtl: r,
    max: E,
    min: _,
    classes: h,
    disabled: b,
    disableSwap: g,
    orientation: R,
    marks: k,
    color: m,
    size: I,
    step: z,
    shiftStep: D,
    scale: B,
    track: G,
    valueLabelDisplay: K,
    valueLabelFormat: q
  }, {
    axisProps: F,
    getRootProps: Y,
    getHiddenInputProps: U,
    getThumbProps: W,
    open: J,
    active: oe,
    axis: fe,
    focusedThumbIndex: ie,
    range: ce,
    dragging: ge,
    marks: re,
    values: le,
    trackOffset: me,
    trackLeap: ve,
    getThumbStyle: xe
  } = LIe({
    ...V,
    rootRef: t
  });
  V.marked = re.length > 0 && re.some((hn) => hn.label), V.dragging = ge, V.focusedThumbIndex = ie;
  const _e = JIe(V), Ge = H?.root ?? d.Root ?? HIe, Xe = H?.rail ?? d.Rail ?? WIe, tt = H?.track ?? d.Track ?? qIe, nt = H?.thumb ?? d.Thumb ?? GIe, je = H?.valueLabel ?? d.ValueLabel ?? KIe, cn = H?.mark ?? d.Mark ?? YIe, pt = H?.markLabel ?? d.MarkLabel ?? XIe, Ce = H?.input ?? d.Input ?? "input", Me = P?.root ?? f.root, he = P?.rail ?? f.rail, ye = P?.track ?? f.track, Ee = P?.thumb ?? f.thumb, Te = P?.valueLabel ?? f.valueLabel, Fe = P?.mark ?? f.mark, Ut = P?.markLabel ?? f.markLabel, Vt = P?.input ?? f.input, Xt = Cc({
    elementType: Ge,
    getSlotProps: Y,
    externalSlotProps: Me,
    externalForwardedProps: Z,
    additionalProps: {
      ...FIe(Ge) && {
        as: c
      }
    },
    ownerState: {
      ...V,
      ...Me?.ownerState
    },
    className: [_e.root, v]
  }), Nt = Cc({
    elementType: Xe,
    externalSlotProps: he,
    ownerState: V,
    className: _e.rail
  }), kn = Cc({
    elementType: tt,
    externalSlotProps: ye,
    additionalProps: {
      style: {
        ...F[fe].offset(me),
        ...F[fe].leap(ve)
      }
    },
    ownerState: {
      ...V,
      ...ye?.ownerState
    },
    className: _e.track
  }), Ae = Cc({
    elementType: nt,
    getSlotProps: W,
    externalSlotProps: Ee,
    ownerState: {
      ...V,
      ...Ee?.ownerState
    },
    className: _e.thumb
  }), Ht = Cc({
    elementType: je,
    externalSlotProps: Te,
    ownerState: {
      ...V,
      ...Te?.ownerState
    },
    className: _e.valueLabel
  }), Zt = Cc({
    elementType: cn,
    externalSlotProps: Fe,
    ownerState: V,
    className: _e.mark
  }), Bo = Cc({
    elementType: pt,
    externalSlotProps: Ut,
    ownerState: V,
    className: _e.markLabel
  }), Uo = Cc({
    elementType: Ce,
    getSlotProps: U,
    externalSlotProps: Vt,
    ownerState: V
  });
  return /* @__PURE__ */ C.jsxs(Ge, {
    ...Xt,
    children: [/* @__PURE__ */ C.jsx(Xe, {
      ...Nt
    }), /* @__PURE__ */ C.jsx(tt, {
      ...kn
    }), re.filter((hn) => hn.value >= _ && hn.value <= E).map((hn, On) => {
      const _r = K2(hn.value, _, E), Vo = F[fe].offset(_r);
      let vr;
      return G === !1 ? vr = le.includes(hn.value) : vr = G === "normal" && (ce ? hn.value >= le[0] && hn.value <= le[le.length - 1] : hn.value <= le[0]) || G === "inverted" && (ce ? hn.value <= le[0] || hn.value >= le[le.length - 1] : hn.value >= le[0]), /* @__PURE__ */ C.jsxs(M.Fragment, {
        children: [/* @__PURE__ */ C.jsx(cn, {
          "data-index": On,
          ...Zt,
          ...!Ll(cn) && {
            markActive: vr
          },
          style: {
            ...Vo,
            ...Zt.style
          },
          className: Ye(Zt.className, vr && _e.markActive)
        }), hn.label != null ? /* @__PURE__ */ C.jsx(pt, {
          "aria-hidden": !0,
          "data-index": On,
          ...Bo,
          ...!Ll(pt) && {
            markLabelActive: vr
          },
          style: {
            ...Vo,
            ...Bo.style
          },
          className: Ye(_e.markLabel, Bo.className, vr && _e.markLabelActive),
          children: hn.label
        }) : null]
      }, On);
    }), le.map((hn, On) => {
      const _r = K2(hn, _, E), Vo = F[fe].offset(_r), vr = K === "off" ? QIe : je;
      return (
        /* TODO v6: Change component structure. It will help in avoiding the complicated React.cloneElement API added in SliderValueLabel component. Should be: Thumb -> Input, ValueLabel. Follow Joy UI's Slider structure. */
        /* @__PURE__ */ C.jsx(vr, {
          ...!Ll(vr) && {
            valueLabelFormat: q,
            valueLabelDisplay: K,
            value: typeof q == "function" ? q(B(hn), On) : q,
            index: On,
            open: J === On || oe === On || K === "on",
            disabled: b
          },
          ...Ht,
          children: /* @__PURE__ */ C.jsx(nt, {
            "data-index": On,
            ...Ae,
            className: Ye(_e.thumb, Ae.className, oe === On && _e.active, ie === On && _e.focusVisible),
            style: {
              ...Vo,
              ...xe(On),
              ...Ae.style
            },
            children: /* @__PURE__ */ C.jsx(Ce, {
              "data-index": On,
              "aria-label": x ? x(On) : a,
              "aria-valuenow": B(hn),
              "aria-labelledby": l,
              "aria-valuetext": w ? w(B(hn), On) : s,
              value: le[On],
              ...Uo
            })
          })
        }, On)
      );
    })]
  });
});
function e$e(e) {
  const { value: t, readonly: n, disabled: r, onBlur: a, onFocus: s, options: l, schema: c, onChange: d, required: f, label: m, hideLabel: h, id: v } = e, g = { value: t, label: m, id: v, name: v, ...yK(c) }, b = (k, E) => {
    d(E ?? l.emptyValue);
  }, x = ({ target: k }) => a(v, k && k.value), w = ({ target: k }) => s(v, k && k.value);
  return C.jsxs(C.Fragment, { children: [ih(C.jsx(FC, { required: f, htmlFor: v, children: m || void 0 }), h), C.jsx(ZIe, { disabled: r || n, onChange: b, onBlur: x, onFocus: w, valueLabelDisplay: "auto", ...g, "aria-describedby": ji(v) })] });
}
function t$e(e) {
  return Ct("MuiMenuItem", e);
}
const lx = St("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]), n$e = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, n.dense && t.dense, n.divider && t.divider, !n.disableGutters && t.gutters];
}, r$e = (e) => {
  const {
    disabled: t,
    dense: n,
    divider: r,
    disableGutters: a,
    selected: s,
    classes: l
  } = e, c = Et({
    root: ["root", n && "dense", t && "disabled", !a && "gutters", r && "divider", s && "selected"]
  }, t$e, l);
  return {
    ...l,
    ...c
  };
}, o$e = $e(JS, {
  shouldForwardProp: (e) => ea(e) || e === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver: n$e
})(Mt(({
  theme: e
}) => ({
  ...e.typography.body1,
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap",
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (e.vars || e).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${lx.selected}`]: {
    backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity),
    [`&.${lx.focusVisible}`]: {
      backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.focusOpacity}`)
    }
  },
  [`&.${lx.selected}:hover`]: {
    backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.hoverOpacity}`),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity)
    }
  },
  [`&.${lx.focusVisible}`]: {
    backgroundColor: (e.vars || e).palette.action.focus
  },
  [`&.${lx.disabled}`]: {
    opacity: (e.vars || e).palette.action.disabledOpacity
  },
  [`& + .${E9.root}`]: {
    marginTop: e.spacing(1),
    marginBottom: e.spacing(1)
  },
  [`& + .${E9.inset}`]: {
    marginLeft: 52
  },
  [`& .${Gh.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${Gh.inset}`]: {
    paddingLeft: 36
  },
  [`& .${k9.root}`]: {
    minWidth: 36
  },
  variants: [{
    props: ({
      ownerState: t
    }) => !t.disableGutters,
    style: {
      paddingLeft: 16,
      paddingRight: 16
    }
  }, {
    props: ({
      ownerState: t
    }) => t.divider,
    style: {
      borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
      backgroundClip: "padding-box"
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.dense,
    style: {
      [e.breakpoints.up("sm")]: {
        minHeight: "auto"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.dense,
    style: {
      minHeight: 32,
      // https://m2.material.io/components/menus#specs > Dense
      paddingTop: 4,
      paddingBottom: 4,
      ...e.typography.body2,
      [`& .${k9.root} svg`]: {
        fontSize: "1.25rem"
      }
    }
  }]
}))), R9 = /* @__PURE__ */ M.forwardRef(function(e, t) {
  const n = Dt({
    props: e,
    name: "MuiMenuItem"
  }), {
    autoFocus: r = !1,
    component: a = "li",
    dense: s = !1,
    divider: l = !1,
    disableGutters: c = !1,
    focusVisibleClassName: d,
    role: f = "menuitem",
    tabIndex: m,
    className: h,
    ...v
  } = n, g = M.useContext(Dc), b = M.useMemo(() => ({
    dense: s || g.dense || !1,
    disableGutters: c
  }), [g.dense, s, c]), x = M.useRef(null);
  Zs(() => {
    r && (x.current && x.current.focus());
  }, [r]);
  const w = {
    ...n,
    dense: b.dense,
    divider: l,
    disableGutters: c
  }, k = r$e(n), E = io(x, t);
  let _;
  return n.disabled || (_ = m !== void 0 ? m : -1), /* @__PURE__ */ C.jsx(Dc.Provider, {
    value: b,
    children: /* @__PURE__ */ C.jsx(o$e, {
      ref: E,
      role: f,
      tabIndex: _,
      component: a,
      focusVisibleClassName: Ye(k.focusVisible, d),
      className: Ye(k.root, h),
      ...v,
      ownerState: w,
      classes: k
    })
  });
});
function a$e({
  schema: e,
  id: t,
  name: n,
  // remove this from textFieldProps
  htmlName: r,
  options: a,
  label: s,
  hideLabel: l,
  required: c,
  disabled: d,
  placeholder: f,
  readonly: m,
  value: h,
  multiple: v,
  autofocus: g,
  onChange: b,
  onBlur: x,
  onFocus: w,
  errorSchema: k,
  rawErrors: E = [],
  registry: _,
  uiSchema: O,
  hideError: N,
  ...A
}) {
  const { enumOptions: R, enumDisabled: D, emptyValue: I } = a;
  v = typeof v > "u" ? !1 : !!v;
  const z = v ? [] : "", B = typeof h > "u" || v && h.length < 1 || !v && h === z, P = ({ target: { value: F } }) => b(ao(F, R, I)), H = ({ target: F }) => x(t, ao(F && F.value, R, I)), L = ({ target: F }) => w(t, ao(F && F.value, R, I)), G = Zj(h, R, v), { InputLabelProps: $, SelectProps: K, autocomplete: q, ...Z } = A, V = !v && e.default === void 0;
  return C.jsxs(CP, { id: t, name: r || t, label: ih(s || void 0, l, void 0), value: !B && typeof G < "u" ? G : z, required: c, disabled: d || m, autoFocus: g, autoComplete: q, placeholder: f, error: E.length > 0, onChange: P, onBlur: H, onFocus: L, ...Z, select: !0, InputLabelProps: {
    ...$,
    shrink: !B
  }, SelectProps: {
    ...K,
    multiple: v
  }, "aria-describedby": ji(t), children: [V && C.jsx(R9, { value: "", children: f }), Array.isArray(R) && R.map(({ value: F, label: Y }, U) => {
    const W = Array.isArray(D) && D.indexOf(F) !== -1;
    return C.jsx(R9, { value: String(U), disabled: W, children: Y }, U);
  })] });
}
function i$e(e) {
  const { options: t, registry: n } = e, r = xt("BaseInputTemplate", n, t);
  let a = 5;
  return (typeof t.rows == "string" || typeof t.rows == "number") && (a = t.rows), C.jsx(r, { ...e, multiline: !0, rows: a });
}
function s$e() {
  return {
    CheckboxWidget: uIe,
    CheckboxesWidget: pIe,
    RadioWidget: AIe,
    RangeWidget: e$e,
    SelectWidget: a$e,
    TextareaWidget: i$e
  };
}
function xY() {
  return {
    templates: WDe(),
    widgets: s$e()
  };
}
const l$e = xY();
function u$e() {
  return JK(xY());
}
u$e();
const c$e = JK(l$e), d$e = kE({
  cssVariables: { nativeColor: !0 },
  palette: {
    primary: {
      main: "var(--fn-primary-color)",
      contrastText: "var(--fn-app-background)"
    },
    text: {
      primary: "var(--fn-text-color-neutral)",
      secondary: "var(--fn-text-color-neutral)",
      disabled: "var(--fn-text-color-neutral)",
      primaryChannel: "var(--fn-text-color-neutral-channel)",
      secondaryChannel: "var(--fn-text-color-neutral-channel)"
    },
    common: {
      black: "var(--fn-primary-color)",
      white: "var(--fn-app-background)"
    },
    background: {
      default: "var(--fn-app-background)",
      paper: "var(--fn-app-background)",
      defaultChannel: "var(--fn-app-background-channel)",
      paperChannel: "var(--fn-app-background-channel)"
    }
  },
  shape: {
    borderRadius: "var(--fn-border-radius-s)"
  }
}), SY = ({
  getter: e,
  setter: t,
  setter_calls_getter: n = !1,
  disabled: r = !1,
  readonly: a = !1
}) => {
  const [s, l] = M.useState(null), [c, d] = M.useState(void 0), [f, m] = M.useState(void 0), h = M.useCallback(async () => {
    const g = await e();
    l(g.jsonSchema), d(g.uiSchema), m(g.formData);
  }, [e]), v = M.useCallback(
    async (g) => {
      await t(g), n && await h();
    },
    [t, n, h]
  );
  return M.useEffect(() => {
    h();
  }, [h]), s ? /* @__PURE__ */ C.jsx(Fje, { theme: d$e, children: /* @__PURE__ */ C.jsx(
    c$e,
    {
      schema: s,
      uiSchema: c || void 0,
      formData: f || void 0,
      validator: y3e,
      liveValidate: "onChange",
      onChange: ({ formData: g }) => m(g),
      onSubmit: ({ formData: g }) => v(g),
      disabled: r,
      readonly: a
    }
  ) }) : /* @__PURE__ */ C.jsx("div", { children: "Loading" });
}, f$e = ({
  jsonSchema: e,
  uiSchema: t,
  full: n,
  readonly: r
}) => {
  const a = {
    jsonSchema: e,
    uiSchema: t,
    formData: {}
  };
  r && (a.uiSchema = {
    ...a.uiSchema,
    "ui:readonly": !0,
    "ui:disabled": !0,
    "ui:submitButtonOptions": {
      norender: !0,
      props: {
        disabled: r,
        className: "btn btn-info"
      }
    }
  });
  const s = n?.value;
  return s && (typeof s == "object" && s !== null && "schema" in s && "data" in s ? (a.jsonSchema = s.schema, a.formData = s.data ?? {}) : a.formData = s), a;
}, p$e = ({ inputconverter: e }) => {
  const t = hr(), { preview: n, full: r } = t.valuestore(), a = t.use(), [s, l] = M.useState(!1), c = vk(), d = Zm(a), f = a.render_options.schema, m = a.render_options.uiSchema, h = M.useMemo(() => {
    if (!f)
      throw new Error("No jsonSchema provided");
    return f$e({
      jsonSchema: f,
      uiSchema: m,
      full: r,
      readonly: a.connected
    });
  }, [f, m, r, n, a.connected]), v = M.useCallback(
    async () => h,
    [h]
  ), g = M.useCallback(
    async (b) => {
      d(b), l(!1);
    },
    [d]
  );
  return /* @__PURE__ */ C.jsx(
    Yl,
    {
      title: a.name,
      description: "Edit " + a.name,
      open: s,
      setOpen: l,
      trigger: /* @__PURE__ */ C.jsx("button", { className: "nodedatainput styledinput", children: "Edit" }),
      onOpenChange: (b) => {
        b && !r && c?.();
      },
      children: /* @__PURE__ */ C.jsx(
        SY,
        {
          getter: v,
          setter: g,
          setter_calls_getter: !1,
          disabled: a.connected,
          readonly: a.connected
        }
      )
    }
  );
}, m$e = {
  float: U_e,
  int: V_e,
  bool: y_e,
  string: Z6,
  str: Z6,
  color: b_e,
  select: bS,
  enum: bS,
  json_schema: p$e,
  bytes: Iq(kj, "")
}, h$e = {}, g$e = {}, vl = {
  Inputrenderer: m$e,
  Outputrenderer: h_e,
  HandlePreviewRenderer: p_e,
  DataOverlayRenderer: f_e,
  DataPreviewViewRenderer: $q,
  DataViewRenderer: _j,
  InLineRenderer: d_e,
  NodeRenderer: h$e,
  NodeHooks: g$e
}, v$e = (e, t) => {
  const n = t.options || {}, r = n.overwrite === void 0 ? !0 : n.overwrite;
  switch (t.type) {
    case "EXTEND_INPUT_RENDER":
      return !r && e.Inputrenderer[t.payload.type] ? e : {
        ...e,
        Inputrenderer: {
          ...e.Inputrenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_FROM_PLUGIN": {
      let s = !1;
      const l = [
        [t.payload.plugin.input_renderers || {}, e.Inputrenderer],
        [t.payload.plugin.output_renderers || {}, e.Outputrenderer],
        [
          t.payload.plugin.handle_preview_renderers || {},
          e.HandlePreviewRenderer
        ],
        [
          t.payload.plugin.data_overlay_renderers || {},
          e.DataOverlayRenderer
        ],
        [
          t.payload.plugin.data_preview_renderers || {},
          e.DataPreviewViewRenderer
        ],
        [
          t.payload.plugin.data_view_renderers || {},
          e.DataViewRenderer
        ],
        [t.payload.plugin.node_renderers || {}, e.NodeRenderer],
        [t.payload.plugin.node_hooks || {}, e.NodeHooks]
      ];
      for (const [d, f] of l) {
        if (Object.keys(d).length > 0) {
          if (r)
            s = !0;
          else
            for (const m in d)
              if (!f[m]) {
                s = !0;
                break;
              }
        }
        if (s) break;
      }
      if (!s)
        return e;
      const c = { ...e };
      return l.forEach(([d, f]) => {
        Object.assign(f, d);
      }), c;
    }
    default:
      const a = {
        EXTEND_OUTPUT_RENDER: "Outputrenderer",
        EXTEND_HANDLE_PREVIEW_RENDER: "HandlePreviewRenderer",
        EXTEND_DATA_OVERLAY_RENDER: "DataOverlayRenderer",
        EXTEND_DATA_PREVIEW_RENDER: "DataPreviewViewRenderer",
        EXTEND_DATA_VIEW_RENDER: "DataViewRenderer",
        EXTEND_NODE_CONTEXT_EXTENDER: "NodeContextExtenders",
        EXTEND_NODE_RENDERER: "NodeRenderer",
        EXTEND_NODE_HOOKS: "NodeHooks"
      }[t.type];
      if (a) {
        const s = e[a];
        return !r && s[t.payload.type] ? e : {
          ...e,
          [a]: {
            ...s,
            [t.payload.type]: t.payload.component
          }
        };
      }
      return e;
  }
}, y$e = ({
  children: e,
  plugins: t,
  fnrf_zst: n
}) => {
  const [r, a] = M.useReducer(
    v$e,
    vl
  ), s = M.useCallback(
    (b, x, w) => {
      a({
        type: "EXTEND_INPUT_RENDER",
        payload: { type: b, component: x },
        options: w
      });
    },
    []
  ), l = M.useCallback(
    (b, x, w) => {
      a({
        type: "EXTEND_OUTPUT_RENDER",
        payload: { type: b, component: x },
        options: w
      });
    },
    []
  ), c = M.useCallback(
    (b, x, w) => {
      a({
        type: "EXTEND_HANDLE_PREVIEW_RENDER",
        payload: { type: b, component: x },
        options: w
      });
    },
    []
  ), d = M.useCallback(
    (b, x, w) => {
      a({
        type: "EXTEND_DATA_OVERLAY_RENDER",
        payload: { type: b, component: x },
        options: w
      });
    },
    []
  ), f = M.useCallback(
    (b, x, w) => {
      a({
        type: "EXTEND_DATA_PREVIEW_RENDER",
        payload: { type: b, component: x },
        options: w
      });
    },
    []
  ), m = M.useCallback(
    (b, x, w) => {
      a({
        type: "EXTEND_DATA_VIEW_RENDER",
        payload: { type: b, component: x },
        options: w
      });
    },
    []
  ), h = M.useCallback(
    (b, x, w) => {
      a({
        type: "EXTEND_NODE_RENDERER",
        payload: { type: b, component: x },
        options: w
      });
    },
    []
  ), v = M.useCallback(
    (b, x, w) => {
      a({
        type: "EXTEND_NODE_HOOKS",
        payload: { type: b, component: x },
        options: w
      });
    },
    []
  ), g = M.useCallback(
    (b, x) => {
      a({
        type: "EXTEND_FROM_PLUGIN",
        payload: { plugin: b },
        options: x
      });
    },
    []
  );
  return M.useEffect(() => {
    for (const b in t) {
      const x = t[b];
      if (!x) continue;
      const w = x.renderpluginfactory;
      w && g(w({ React: BS, fnrf_zst: n, NodeContext: fC }));
    }
  }, [t, g, n]), /* @__PURE__ */ C.jsx(
    td.Provider,
    {
      value: {
        Inputrenderer: r.Inputrenderer,
        Outputrenderer: r.Outputrenderer,
        HandlePreviewRenderer: r.HandlePreviewRenderer,
        DataOverlayRenderer: r.DataOverlayRenderer,
        DataPreviewViewRenderer: r.DataPreviewViewRenderer,
        DataViewRenderer: r.DataViewRenderer,
        InLineRenderer: r.InLineRenderer,
        NodeRenderer: r.NodeRenderer,
        NodeHooks: r.NodeHooks,
        extendNodeRenderer: h,
        extendInputRenderMapping: s,
        extendOutputRenderMapping: l,
        extendHandlePreviewRenderMapping: c,
        extendDataOverlayRenderMapping: d,
        extendDataPreviewRenderMapping: f,
        extendDataViewRenderMapping: m,
        extendNodeHooks: v,
        extendFromPlugin: g
      },
      children: e
    }
  );
}, td = M.createContext({
  Inputrenderer: vl.Inputrenderer,
  Outputrenderer: vl.Outputrenderer,
  HandlePreviewRenderer: vl.HandlePreviewRenderer,
  DataOverlayRenderer: vl.DataOverlayRenderer,
  DataPreviewViewRenderer: vl.DataPreviewViewRenderer,
  DataViewRenderer: vl.DataViewRenderer,
  InLineRenderer: vl.InLineRenderer,
  NodeRenderer: vl.NodeRenderer,
  NodeHooks: vl.NodeHooks,
  extendInputRenderMapping: (e, t, n) => {
  },
  extendOutputRenderMapping: (e, t, n) => {
  },
  extendHandlePreviewRenderMapping: (e, t, n) => {
  },
  extendDataOverlayRenderMapping: (e, t, n) => {
  },
  extendDataPreviewRenderMapping: (e, t, n) => {
  },
  extendDataViewRenderMapping: (e, t, n) => {
  },
  extendNodeRenderer: (e, t, n) => {
  },
  extendNodeHooks: (e, t, n) => {
  },
  extendFromPlugin: (e, t) => {
  }
}), kY = (e) => {
  const t = Sn(), { DataOverlayRenderer: n, DataViewRenderer: r } = M.useContext(td);
  if (e === void 0) return;
  const a = t.render_options(), [s] = Qm(e, a.typemap || {});
  return s ? n[s] ? n[s] : r[s] ? pC(r[s]) : Q6 : Q6;
}, b$e = (e) => {
  const t = Sn(), n = kY(e), { DataPreviewViewRenderer: r, DataViewRenderer: a } = M.useContext(td), s = t.render_options();
  if (e === void 0) return [void 0, n];
  const [l] = Qm(e, s.typemap || {});
  return l ? r[l] ? [r[l], n] : a[l] ? [
    Ra(a[l]),
    n
  ] : [
    Ra(z2),
    n
  ] : [
    Ra(z2),
    n
  ];
}, w$e = (e) => {
  const t = Sn().render_options(), { HandlePreviewRenderer: n, DataPreviewViewRenderer: r } = M.useContext(td), a = kY(e);
  let s;
  if (e) {
    const [l] = Qm(e, t.typemap || {});
    l ? n[l] ? s = n[l] : r[l] ? s = r[l] : s = Ra(
      z2
    ) : s = Ra(
      z2
    );
  }
  return [s, a];
}, x$e = (e) => {
  const [t, n] = M.useState(!1), r = e.use((a) => a.in_trigger);
  return M.useEffect(() => {
    let a;
    return r && !t ? n(!0) : t && (a = setTimeout(() => n(!1), 200)), () => clearTimeout(a);
  }, [r, t]), { visualTrigger: t, nodestore: e };
}, _Y = ({
  iostore: e,
  Component: t
}) => {
  const [n, r] = M.useState(void 0), [a, s] = M.useState(void 0), { full: l } = e.valuestore(), c = vk();
  M.useEffect(() => {
    l === void 0 ? c?.() : s(l.value);
  }, [l, c]);
  const d = () => {
    a !== void 0 && r(a);
  };
  return /* @__PURE__ */ C.jsx(
    t,
    {
      value: a,
      preValue: n,
      onLoaded: d
    }
  );
}, EY = ({
  Component: e
}) => /* @__PURE__ */ C.jsx(e, {}), rR = ({
  typestring: e,
  preview: t,
  ...n
}) => {
  const [r, a] = M.useState(!1), [s, l] = M.useState(!1), c = Sn(), d = hr(), f = d.use(), m = vk(), [h, v] = w$e(f), g = c.local_state(() => c.reactflowRef);
  return (
    // <Tooltip.Provider>
    /* @__PURE__ */ C.jsxs(mV, { open: r || s, onOpenChange: l, children: [
      /* @__PURE__ */ C.jsx(hV, { asChild: !0, children: /* @__PURE__ */ C.jsx(yS, { id: f.id, "data-type": e, ...n }) }),
      /* @__PURE__ */ C.jsx(gV, { container: g, children: /* @__PURE__ */ C.jsxs(
        vV,
        {
          className: "iotooltipcontent",
          sideOffset: 5,
          avoidCollisions: !0,
          collisionBoundary: g,
          collisionPadding: 10,
          onOpenAutoFocus: (b) => b.preventDefault(),
          onCloseAutoFocus: (b) => b.preventDefault(),
          children: [
            /* @__PURE__ */ C.jsxs("div", { className: "iotooltip_container", children: [
              /* @__PURE__ */ C.jsxs("div", { className: "iotooltip_header", children: [
                f.name,
                r ? /* @__PURE__ */ C.jsx(vce, { onClick: () => a(!1) }) : /* @__PURE__ */ C.jsx(gce, { onClick: () => a(!0) }),
                v && /* @__PURE__ */ C.jsx(
                  Yl,
                  {
                    title: f.full_id,
                    trigger: /* @__PURE__ */ C.jsx(CU, {}),
                    onOpenChange: (b) => {
                      b && m?.(), a(b);
                    },
                    children: /* @__PURE__ */ C.jsx(
                      _Y,
                      {
                        Component: v,
                        iostore: d
                      }
                    )
                  }
                )
              ] }),
              h ? /* @__PURE__ */ C.jsx(EY, { Component: h }) : `no preview available for "${e}"`
            ] }),
            /* @__PURE__ */ C.jsx(Qde, { className: "iotooltipcontentarrow" })
          ]
        }
      ) })
    ] })
  );
}, jg = {
  "": [(e) => e, (e) => e],
  str_to_json: [
    (e) => JSON.parse(e),
    (e) => typeof e == "string" ? e : JSON.stringify(e)
  ],
  str_to_list: [
    (e) => {
      try {
        const t = JSON.parse(e);
        return Array.isArray(t) ? t : [t];
      } catch {
        try {
          return JSON.parse("[" + e + "]");
        } catch {
        }
      }
      throw new Error("Invalid list");
    },
    (e) => JSON.stringify(e)
  ]
}, S$e = ({
  setNodeSettingsPath: e,
  setShowSettings: t
}) => {
  const n = Sn().render_options(), r = hr().use(), [a, s] = Qm(r, n.typemap || {}), { Inputrenderer: l } = M.useContext(td), c = a ? r.value_options?.options ? bS : l[a] : void 0, d = jg[(s && n.inputconverter?.[s]) ?? ""] || jg[""], { keys: f } = N4(), m = (h) => {
    f.has("s") && (e && e("inputs/" + r.id), t && t(!0), h.stopPropagation());
  };
  return r.hidden ? null : /* @__PURE__ */ C.jsxs(
    "div",
    {
      className: "nodeinput",
      "data-type": a,
      onClick: m,
      children: [
        /* @__PURE__ */ C.jsx(
          rR,
          {
            typestring: a,
            position: lt.Left,
            type: "target"
          }
        ),
        /* @__PURE__ */ C.jsxs("div", { className: "inner_nodeio", children: [
          c && /* @__PURE__ */ C.jsx("div", { className: "iovaluefield nodrag", "data-type": a, children: /* @__PURE__ */ C.jsx(c, { inputconverter: d }) }),
          /* @__PURE__ */ C.jsx("div", { className: "ioname", children: r.name })
        ] }),
        /* @__PURE__ */ C.jsx(
          rR,
          {
            typestring: a,
            position: lt.Right,
            type: "source"
          }
        )
      ]
    }
  );
}, k$e = ({
  setNodeSettingsPath: e,
  setShowSettings: t
}) => {
  const n = Sn().render_options(), r = hr().use(), [a] = Qm(r, n.typemap || {}), { Outputrenderer: s } = M.useContext(td), { keys: l } = N4(), c = a ? s[a] : void 0, d = (f) => {
    l.has("s") && (e && e("outputs/" + r.id), t && t(!0), f.stopPropagation());
  };
  return r.hidden ? null : /* @__PURE__ */ C.jsxs(
    "div",
    {
      className: "nodeoutput",
      "data-type": a,
      onClick: d,
      children: [
        /* @__PURE__ */ C.jsx(
          rR,
          {
            typestring: a,
            position: lt.Right,
            type: "source"
          }
        ),
        /* @__PURE__ */ C.jsxs("div", { className: "inner_nodeio", children: [
          /* @__PURE__ */ C.jsx("div", { className: "ioname", children: r.name }),
          c ? /* @__PURE__ */ C.jsx("div", { className: "iovaluefield nodrag", children: /* @__PURE__ */ C.jsx(c, {}) }) : /* @__PURE__ */ C.jsx("div", { className: "iovaluefield", children: /* @__PURE__ */ C.jsx(m_e, {}) })
        ] })
      ]
    }
  );
}, _$e = () => {
  const e = Sn().render_options(), t = hr().use(), n = Ej(), [r, a] = Qm(t, e.typemap || {}), { Inputrenderer: s } = M.useContext(td), l = r ? t.value_options?.options ? bS : s[r] : void 0, c = jg[(a && e.inputconverter?.[a]) ?? ""] || jg[""];
  return /* @__PURE__ */ C.jsxs("div", { className: "nodesettings_component", children: [
    /* @__PURE__ */ C.jsx("div", { children: t.name }),
    l && /* @__PURE__ */ C.jsx(l, { inputconverter: c }),
    /* @__PURE__ */ C.jsx("div", { children: /* @__PURE__ */ C.jsxs("label", { children: [
      "hidden:",
      /* @__PURE__ */ C.jsx(
        "input",
        {
          className: "styledcheckbox",
          type: "checkbox",
          disabled: t.connected,
          onChange: (d) => {
            n?.(d.target.checked);
          },
          checked: t.hidden
        }
      )
    ] }) })
  ] });
}, E$e = () => {
  const e = hr().use(), t = Ej();
  return /* @__PURE__ */ C.jsxs("div", { className: "nodesettings_component", children: [
    /* @__PURE__ */ C.jsx("div", { children: e.name }),
    /* @__PURE__ */ C.jsx("div", { children: /* @__PURE__ */ C.jsxs("label", { children: [
      "hidden:",
      /* @__PURE__ */ C.jsx(
        "input",
        {
          className: "styledcheckbox",
          type: "checkbox",
          disabled: e.connected,
          onChange: (n) => {
            t?.(n.target.checked);
          },
          checked: e.hidden
        }
      )
    ] }) })
  ] });
}, CY = ({}) => {
  const e = Sn(), { node: t } = Oa(), n = hr().use(), r = e.render_options(), a = Ej(), [s, l] = M.useState(n.name);
  M.useEffect(() => l(n.name), [n.name]);
  const c = M.useCallback(
    (b) => l(b.target.value),
    []
  ), d = M.useCallback(() => {
    s !== n.name && t?.update_io_options({
      nid: n.node,
      ioid: n.id,
      options: { name: s }
    });
  }, [n, t, s]), [f, m] = Qm(
    n,
    r.typemap || {}
  ), h = jg[(m && r.inputconverter?.[m]) ?? ""] || jg[""], { Inputrenderer: v } = M.useContext(td), g = f ? n.value_options?.options ? bS : v[f] : void 0;
  return /* @__PURE__ */ C.jsxs("div", { className: "nodesettings-io-entry funcnodes-control-group", children: [
    /* @__PURE__ */ C.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ C.jsx("label", { htmlFor: `io-name-${n.id}`, children: "Name:" }),
      /* @__PURE__ */ C.jsx(
        "input",
        {
          id: `io-name-${n.id}`,
          type: "text",
          value: s,
          onChange: c,
          onBlur: d,
          className: "styledinput"
        }
      )
    ] }),
    /* @__PURE__ */ C.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ C.jsx("label", { children: "ID:" }),
      /* @__PURE__ */ C.jsx("span", { children: n.id })
    ] }),
    /* @__PURE__ */ C.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ C.jsx("label", { children: "Value:" }),
      g && /* @__PURE__ */ C.jsx(g, { inputconverter: h })
    ] }),
    /* @__PURE__ */ C.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ C.jsx("label", { children: "Type:" }),
      /* @__PURE__ */ C.jsx("pre", { children: JSON.stringify(n.type, null, 2) })
    ] }),
    /* @__PURE__ */ C.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ C.jsx("label", { htmlFor: `io-hidden-${n.id}`, children: "Hidden:" }),
      /* @__PURE__ */ C.jsx(
        "input",
        {
          id: `io-hidden-${n.id}`,
          type: "checkbox",
          checked: n.hidden,
          onChange: (b) => a?.(b.target.checked),
          className: "styledcheckbox",
          disabled: n.connected && n.is_input
        }
      )
    ] }),
    /* @__PURE__ */ C.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ C.jsx("label", { children: "Value Options:" }),
      /* @__PURE__ */ C.jsx("pre", { children: JSON.stringify(n.value_options, null, 2) })
    ] }),
    /* @__PURE__ */ C.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ C.jsx("label", { children: "Render Options:" }),
      /* @__PURE__ */ C.jsx("pre", { className: "code-display", children: JSON.stringify(n.render_options, null, 2) })
    ] }),
    n.is_input && /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
      /* @__PURE__ */ C.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ C.jsx("label", { children: "Does Trigger:" }),
        /* @__PURE__ */ C.jsx("span", { children: String(n.does_trigger) })
      ] }),
      /* @__PURE__ */ C.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ C.jsx("label", { children: "Required:" }),
        /* @__PURE__ */ C.jsx("span", { children: String(n.required) })
      ] })
    ] }),
    /* @__PURE__ */ C.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ C.jsx("label", { children: "Emit Value Set:" }),
      /* @__PURE__ */ C.jsx("span", { children: String(n.emit_value_set) })
    ] }),
    /* @__PURE__ */ C.jsx("hr", {})
  ] });
}, oR = {
  xxs: 0,
  xs: 320,
  s: 480,
  m: 768,
  l: 960,
  xl: 1280,
  xxl: 1920
}, C$e = Object.entries(oR).sort(
  ([, e], [, t]) => t - e
), OY = M.createContext(void 0), O$e = (e, t) => {
  let n;
  return ((...r) => {
    clearTimeout(n), n = setTimeout(() => e(...r), t);
  });
}, M$e = (e) => {
  for (const [t, n] of C$e)
    if (e >= n)
      return t;
  return "xxs";
}, MY = M.memo(
  M.forwardRef(
    (e, t) => {
      const { className: n, children: r, ...a } = e, [s, l] = M.useState(
        {
          wKey: "m",
          w: 0,
          h: 0
        }
      ), c = M.useRef(null);
      M.useImperativeHandle(
        t,
        () => c.current,
        []
      );
      const d = M.useCallback((m) => {
        const h = m.width, v = m.height, g = M$e(h);
        l((b) => b.wKey === g && b.w === h && b.h === v ? b : { wKey: g, w: h, h: v });
      }, []), f = M.useMemo(
        () => O$e(d, 16),
        [d]
      );
      return M.useEffect(() => {
        const m = c.current;
        if (!m)
          return;
        const h = new ResizeObserver((v) => {
          const g = v[0];
          g && f(g.contentRect);
        });
        return d(m.getBoundingClientRect()), h.observe(m), () => {
          h.disconnect();
        };
      }, [d, f]), /* @__PURE__ */ C.jsx(OY.Provider, { value: s, children: /* @__PURE__ */ C.jsx(
        "div",
        {
          ref: c,
          className: `size-context w-${s.wKey} ${n || ""}`.trim(),
          ...a,
          children: r
        }
      ) });
    }
  )
);
MY.displayName = "SizeContextContainer";
const N$e = () => {
  const e = M.useContext(OY);
  if (!e)
    throw new Error(
      "useSizeContext must be used within a SizeContextContainerContext"
    );
  return e;
}, A$e = (e, t) => e === t ? !1 : e === "" ? !0 : oR[e] < oR[t], R$e = (e) => {
  const { wKey: t } = N$e();
  return A$e(t, e);
}, j9 = (e, t, n = "", r = "") => {
  const a = [];
  return typeof e == "string" ? a.push(`${t}-${e}`) : typeof e == "boolean" ? a.push(e ? n : r) : e && typeof e == "object" && Object.entries(e).forEach(([s, l]) => {
    if (typeof l == "string")
      a.push(
        s === "" ? `${t}-${l}` : `${s}-${t}-${l}`
      );
    else if (typeof l == "boolean") {
      const c = l ? n : r;
      c && a.push(s === "" ? c : `${s}-${c}`);
    }
  }), a.filter(Boolean).join(" ");
}, kd = M.memo(
  ({
    direction: e,
    className: t = "",
    children: n,
    wrap: r = !1,
    grow: a = !1,
    ...s
  }) => {
    const l = "float-container", c = j9(e, "direction"), d = j9(a, "", "grow", "no-grow"), f = [
      l,
      c,
      d,
      typeof r == "boolean" && r ? "flex-wrap" : "",
      t
    ].filter(Boolean).join(" ");
    return /* @__PURE__ */ C.jsx("div", { className: f, ...s, children: n });
  }
);
kd.displayName = "FloatContainer";
const j$e = {
  up: (e) => /* @__PURE__ */ C.jsx(C.Fragment, { children: "" }),
  down: (e) => /* @__PURE__ */ C.jsx(C.Fragment, { children: "" }),
  left: (e) => /* @__PURE__ */ C.jsx(C.Fragment, { children: "" }),
  right: (e) => /* @__PURE__ */ C.jsx(C.Fragment, { children: "" })
}, P$e = {
  up: (e) => /* @__PURE__ */ C.jsx(C.Fragment, { children: "" }),
  down: (e) => /* @__PURE__ */ C.jsx(C.Fragment, { children: "" }),
  left: (e) => /* @__PURE__ */ C.jsx(C.Fragment, { children: "" }),
  right: (e) => /* @__PURE__ */ C.jsx(C.Fragment, { children: "" })
}, MP = M.memo(
  ({
    direction: e,
    expanded: t = !0,
    children: n,
    className: r,
    maxSize: a = "18.75rem",
    expanderSize: s = "2rem",
    containerStyle: l,
    style: c,
    containerClassName: d,
    expandIcons: f,
    collapseIcons: m,
    onExpandChange: h,
    ...v
  }) => {
    const [g, b] = M.useState(t);
    M.useEffect(() => {
      b(t);
    }, [t]);
    const x = M.useCallback(() => {
      b((z) => {
        const B = !z;
        return h?.(B), B;
      });
    }, [h]), w = M.useCallback(
      (z) => {
        (z.key === "Enter" || z.key === " ") && (z.preventDefault(), x());
      },
      [x]
    ), k = e === "right" || e === "left", E = e === "left" || e === "up", _ = g ? m?.[e] || P$e[e] : f?.[e] || j$e[e], O = `${e} ${g ? "expanded" : "collapsed"}`, N = M.useMemo(
      () => ({
        [k ? "width" : "height"]: g ? a : s
      }),
      [k, g, a, s]
    ), A = M.useMemo(
      () => ({
        [k ? "width" : "height"]: g ? a : 0
      }),
      [k, g, a]
    ), R = M.useMemo(
      () => ({
        [k ? "width" : "height"]: s
      }),
      [k, s]
    ), D = /* @__PURE__ */ C.jsx(
      "div",
      {
        className: `expanding_container_content ${O} ${r || ""}`.trim(),
        style: { ...c, ...A },
        ...v,
        children: n
      }
    ), I = /* @__PURE__ */ C.jsx(
      "div",
      {
        className: `expanding_container_expander ${O}`,
        onClick: x,
        onKeyDown: w,
        style: R,
        role: "button",
        tabIndex: 0,
        "aria-label": `${g ? "Collapse" : "Expand"} ${e}`,
        children: /* @__PURE__ */ C.jsx(_, {})
      }
    );
    return /* @__PURE__ */ C.jsxs(
      "div",
      {
        className: `expanding_container ${O} ${d || ""}`,
        style: { ...l, ...N },
        children: [
          E ? I : D,
          E ? D : I
        ]
      }
    );
  }
);
MP.displayName = "ExpandingContainer";
const D$e = ({ nodestore: e }) => {
  const t = e.use();
  return /* @__PURE__ */ C.jsx(fC.Provider, { value: e, children: /* @__PURE__ */ C.jsxs("div", { className: "nodesettings_content", children: [
    /* @__PURE__ */ C.jsx("div", { className: "nodesettings_section", children: /* @__PURE__ */ C.jsxs("div", { className: "nodesettings_component", children: [
      /* @__PURE__ */ C.jsx("div", { children: "Name" }),
      /* @__PURE__ */ C.jsx("div", { children: /* @__PURE__ */ C.jsx(jP, {}) })
    ] }) }),
    /* @__PURE__ */ C.jsxs("div", { className: "nodesettings_section", children: [
      /* @__PURE__ */ C.jsx("div", { children: "Inputs" }),
      t.inputs.map((n) => {
        const r = e.io_stores.get(n);
        if (r)
          return /* @__PURE__ */ C.jsx(Pd.Provider, { value: r, children: /* @__PURE__ */ C.jsx(_$e, {}) }, n);
      })
    ] }),
    /* @__PURE__ */ C.jsxs("div", { className: "nodesettings_section", children: [
      /* @__PURE__ */ C.jsx("div", { children: "Outputs" }),
      t.outputs.map((n) => {
        const r = e.io_stores.get(n);
        if (r)
          return /* @__PURE__ */ C.jsx(Pd.Provider, { value: r, children: /* @__PURE__ */ C.jsx(E$e, {}) }, n);
      })
    ] })
  ] }) });
}, I$e = () => {
  const e = Sn(), t = e.local_state((r) => r.selected_nodes);
  if (t.length === 0)
    return /* @__PURE__ */ C.jsx("div", { children: "Node Settings" });
  if (t.length > 1)
    return /* @__PURE__ */ C.jsx("div", { children: "Multiple Nodes Selected" });
  const n = e.nodespace.get_node(t[0]);
  return n ? /* @__PURE__ */ C.jsx(D$e, { nodestore: n }) : /* @__PURE__ */ C.jsx("div", { children: "Node not found" });
}, $$e = () => {
  const e = Sn(), t = e.local_settings(
    (r) => r.view_settings.expand_node_props
  ), n = (r) => {
    e.update_view_settings({ expand_node_props: r });
  };
  return /* @__PURE__ */ C.jsx(
    MP,
    {
      direction: "left",
      expanded: t === void 0 ? !1 : t,
      containerClassName: "pos-right pos-top bg1 h-12",
      className: "nodesettings_content",
      onExpandChange: n,
      collapseIcons: {
        up: m2,
        down: iS,
        left: aS,
        right: p2
      },
      expandIcons: {
        up: iS,
        down: m2,
        left: p2,
        right: aS
      },
      children: /* @__PURE__ */ C.jsx(I$e, {})
    }
  );
};
var q5 = "rovingFocusGroup.onEntryFocus", z$e = { bubbles: !1, cancelable: !0 }, Nk = "RovingFocusGroup", [aR, NY, T$e] = qE(Nk), [L$e, BC] = Kl(
  Nk,
  [T$e]
), [F$e, B$e] = L$e(Nk), AY = M.forwardRef(
  (e, t) => /* @__PURE__ */ C.jsx(aR.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ C.jsx(aR.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ C.jsx(U$e, { ...e, ref: t }) }) })
);
AY.displayName = Nk;
var U$e = M.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: a = !1,
    dir: s,
    currentTabStopId: l,
    defaultCurrentTabStopId: c,
    onCurrentTabStopIdChange: d,
    onEntryFocus: f,
    preventScrollOnEntryFocus: m = !1,
    ...h
  } = e, v = M.useRef(null), g = Xn(t, v), b = mC(s), [x, w] = Bd({
    prop: l,
    defaultProp: c ?? null,
    onChange: d,
    caller: Nk
  }), [k, E] = M.useState(!1), _ = $a(f), O = NY(n), N = M.useRef(!1), [A, R] = M.useState(0);
  return M.useEffect(() => {
    const D = v.current;
    if (D)
      return D.addEventListener(q5, _), () => D.removeEventListener(q5, _);
  }, [_]), /* @__PURE__ */ C.jsx(
    F$e,
    {
      scope: n,
      orientation: r,
      dir: b,
      loop: a,
      currentTabStopId: x,
      onItemFocus: M.useCallback(
        (D) => w(D),
        [w]
      ),
      onItemShiftTab: M.useCallback(() => E(!0), []),
      onFocusableItemAdd: M.useCallback(
        () => R((D) => D + 1),
        []
      ),
      onFocusableItemRemove: M.useCallback(
        () => R((D) => D - 1),
        []
      ),
      children: /* @__PURE__ */ C.jsx(
        Qt.div,
        {
          tabIndex: k || A === 0 ? -1 : 0,
          "data-orientation": r,
          ...h,
          ref: g,
          style: { outline: "none", ...e.style },
          onMouseDown: et(e.onMouseDown, () => {
            N.current = !0;
          }),
          onFocus: et(e.onFocus, (D) => {
            const I = !N.current;
            if (D.target === D.currentTarget && I && !k) {
              const z = new CustomEvent(q5, z$e);
              if (D.currentTarget.dispatchEvent(z), !z.defaultPrevented) {
                const B = O().filter((G) => G.focusable), P = B.find((G) => G.active), H = B.find((G) => G.id === x), L = [P, H, ...B].filter(
                  Boolean
                ).map((G) => G.ref.current);
                PY(L, m);
              }
            }
            N.current = !1;
          }),
          onBlur: et(e.onBlur, () => E(!1))
        }
      )
    }
  );
}), RY = "RovingFocusGroupItem", jY = M.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: a = !1,
      tabStopId: s,
      children: l,
      ...c
    } = e, d = Fl(), f = s || d, m = B$e(RY, n), h = m.currentTabStopId === f, v = NY(n), { onFocusableItemAdd: g, onFocusableItemRemove: b, currentTabStopId: x } = m;
    return M.useEffect(() => {
      if (r)
        return g(), () => b();
    }, [r, g, b]), /* @__PURE__ */ C.jsx(
      aR.ItemSlot,
      {
        scope: n,
        id: f,
        focusable: r,
        active: a,
        children: /* @__PURE__ */ C.jsx(
          Qt.span,
          {
            tabIndex: h ? 0 : -1,
            "data-orientation": m.orientation,
            ...c,
            ref: t,
            onMouseDown: et(e.onMouseDown, (w) => {
              r ? m.onItemFocus(f) : w.preventDefault();
            }),
            onFocus: et(e.onFocus, () => m.onItemFocus(f)),
            onKeyDown: et(e.onKeyDown, (w) => {
              if (w.key === "Tab" && w.shiftKey) {
                m.onItemShiftTab();
                return;
              }
              if (w.target !== w.currentTarget) return;
              const k = W$e(w, m.orientation, m.dir);
              if (k !== void 0) {
                if (w.metaKey || w.ctrlKey || w.altKey || w.shiftKey) return;
                w.preventDefault();
                let E = v().filter((_) => _.focusable).map((_) => _.ref.current);
                if (k === "last") E.reverse();
                else if (k === "prev" || k === "next") {
                  k === "prev" && E.reverse();
                  const _ = E.indexOf(w.currentTarget);
                  E = m.loop ? q$e(E, _ + 1) : E.slice(_ + 1);
                }
                setTimeout(() => PY(E));
              }
            }),
            children: typeof l == "function" ? l({ isCurrentTabStop: h, hasTabStop: x != null }) : l
          }
        )
      }
    );
  }
);
jY.displayName = RY;
var V$e = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function H$e(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function W$e(e, t, n) {
  const r = H$e(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return V$e[r];
}
function PY(e, t = !1) {
  const n = document.activeElement;
  for (const r of e)
    if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return;
}
function q$e(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var DY = AY, IY = jY, UC = "Tabs", [G$e] = Kl(UC, [
  BC
]), $Y = BC(), [K$e, NP] = G$e(UC), zY = M.forwardRef(
  (e, t) => {
    const {
      __scopeTabs: n,
      value: r,
      onValueChange: a,
      defaultValue: s,
      orientation: l = "horizontal",
      dir: c,
      activationMode: d = "automatic",
      ...f
    } = e, m = mC(c), [h, v] = Bd({
      prop: r,
      onChange: a,
      defaultProp: s ?? "",
      caller: UC
    });
    return /* @__PURE__ */ C.jsx(
      K$e,
      {
        scope: n,
        baseId: Fl(),
        value: h,
        onValueChange: v,
        orientation: l,
        dir: m,
        activationMode: d,
        children: /* @__PURE__ */ C.jsx(
          Qt.div,
          {
            dir: m,
            "data-orientation": l,
            ...f,
            ref: t
          }
        )
      }
    );
  }
);
zY.displayName = UC;
var TY = "TabsList", LY = M.forwardRef(
  (e, t) => {
    const { __scopeTabs: n, loop: r = !0, ...a } = e, s = NP(TY, n), l = $Y(n);
    return /* @__PURE__ */ C.jsx(
      DY,
      {
        asChild: !0,
        ...l,
        orientation: s.orientation,
        dir: s.dir,
        loop: r,
        children: /* @__PURE__ */ C.jsx(
          Qt.div,
          {
            role: "tablist",
            "aria-orientation": s.orientation,
            ...a,
            ref: t
          }
        )
      }
    );
  }
);
LY.displayName = TY;
var FY = "TabsTrigger", BY = M.forwardRef(
  (e, t) => {
    const { __scopeTabs: n, value: r, disabled: a = !1, ...s } = e, l = NP(FY, n), c = $Y(n), d = HY(l.baseId, r), f = WY(l.baseId, r), m = r === l.value;
    return /* @__PURE__ */ C.jsx(
      IY,
      {
        asChild: !0,
        ...c,
        focusable: !a,
        active: m,
        children: /* @__PURE__ */ C.jsx(
          Qt.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": m,
            "aria-controls": f,
            "data-state": m ? "active" : "inactive",
            "data-disabled": a ? "" : void 0,
            disabled: a,
            id: d,
            ...s,
            ref: t,
            onMouseDown: et(e.onMouseDown, (h) => {
              !a && h.button === 0 && h.ctrlKey === !1 ? l.onValueChange(r) : h.preventDefault();
            }),
            onKeyDown: et(e.onKeyDown, (h) => {
              [" ", "Enter"].includes(h.key) && l.onValueChange(r);
            }),
            onFocus: et(e.onFocus, () => {
              const h = l.activationMode !== "manual";
              !m && !a && h && l.onValueChange(r);
            })
          }
        )
      }
    );
  }
);
BY.displayName = FY;
var UY = "TabsContent", VY = M.forwardRef(
  (e, t) => {
    const { __scopeTabs: n, value: r, forceMount: a, children: s, ...l } = e, c = NP(UY, n), d = HY(c.baseId, r), f = WY(c.baseId, r), m = r === c.value, h = M.useRef(m);
    return M.useEffect(() => {
      const v = requestAnimationFrame(() => h.current = !1);
      return () => cancelAnimationFrame(v);
    }, []), /* @__PURE__ */ C.jsx(al, { present: a || m, children: ({ present: v }) => /* @__PURE__ */ C.jsx(
      Qt.div,
      {
        "data-state": m ? "active" : "inactive",
        "data-orientation": c.orientation,
        role: "tabpanel",
        "aria-labelledby": d,
        hidden: !v,
        id: f,
        tabIndex: 0,
        ...l,
        ref: t,
        style: {
          ...e.style,
          animationDuration: h.current ? "0s" : void 0
        },
        children: v && s
      }
    ) });
  }
);
VY.displayName = UY;
function HY(e, t) {
  return `${e}-trigger-${t}`;
}
function WY(e, t) {
  return `${e}-content-${t}`;
}
var AP = zY, RP = LY, Hx = BY, Wx = VY;
const Y$e = ({}) => {
  const e = Sn(), t = Ri(), { description: n, id: r, node_id: a, node_name: s, reset_inputs_on_trigger: l } = t.useShallow((h) => ({
    description: h.description,
    id: h.id,
    node_id: h.node_id,
    node_name: h.node_name,
    reset_inputs_on_trigger: h.reset_inputs_on_trigger
  })), [c, d] = M.useState(
    n || ""
  );
  M.useEffect(() => d(n || ""), [n]);
  const f = (h) => d(h.target.value), m = () => {
    c !== (n || "") && e.on_node_action({
      type: "update",
      from_remote: !1,
      id: r,
      node: { description: c }
    });
  };
  return /* @__PURE__ */ C.jsxs("div", { className: "nodesettings-section funcnodes-control-group", children: [
    /* @__PURE__ */ C.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ C.jsx("label", { htmlFor: `node-name-${r}`, children: "Name:" }),
      /* @__PURE__ */ C.jsx(jP, {})
    ] }),
    /* @__PURE__ */ C.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ C.jsx("label", { children: "Instance ID:" }),
      /* @__PURE__ */ C.jsx("span", { children: r })
    ] }),
    /* @__PURE__ */ C.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ C.jsx("label", { children: "Node Type ID:" }),
      /* @__PURE__ */ C.jsx("span", { children: a })
    ] }),
    /* @__PURE__ */ C.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ C.jsx("label", { children: "Node Type Name:" }),
      /* @__PURE__ */ C.jsx("span", { children: s })
    ] }),
    /* @__PURE__ */ C.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ C.jsx("label", { htmlFor: `node-desc-${r}`, children: "Description:" }),
      /* @__PURE__ */ C.jsx(
        "textarea",
        {
          id: `node-desc-${r}`,
          value: c,
          onChange: f,
          onBlur: m,
          className: "styledinput",
          rows: 3
        }
      )
    ] }),
    /* @__PURE__ */ C.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ C.jsx("label", { children: "Reset Inputs on Trigger:" }),
      /* @__PURE__ */ C.jsx(
        "input",
        {
          type: "checkbox",
          checked: l,
          onChange: (h) => {
            e.on_node_action({
              type: "update",
              from_remote: !1,
              id: r,
              node: { reset_inputs_on_trigger: h.target.checked }
            });
          },
          className: "styledcheckbox"
        }
      )
    ] })
  ] });
}, X$e = ({ splitnodesettingsPath: e = [] }) => {
  const t = Ri(), n = t.use((r) => r.inputs);
  return /* @__PURE__ */ C.jsxs(
    AP,
    {
      defaultValue: e[0] || n[0],
      className: "nodesettings-tabs funcnodes-control-root",
      children: [
        /* @__PURE__ */ C.jsx(
          RP,
          {
            className: "nodesettings-tabs-list",
            "aria-label": "Manage node inputs",
            children: n.map((r) => /* @__PURE__ */ C.jsx(
              Hx,
              {
                value: r,
                className: "nodesettings-tabs-trigger",
                children: r
              },
              r
            ))
          }
        ),
        n.map((r) => {
          const a = t.io_stores.get(r);
          return /* @__PURE__ */ C.jsx(
            Wx,
            {
              value: r,
              className: "nodesettings-tabs-content nodesettings-io-list",
              children: a && /* @__PURE__ */ C.jsx(Pd.Provider, { value: a, children: /* @__PURE__ */ C.jsx(CY, {}) })
            },
            r
          );
        })
      ]
    }
  );
}, J$e = ({ splitnodesettingsPath: e = [] }) => {
  const t = Ri(), n = t.use((r) => r.outputs);
  return /* @__PURE__ */ C.jsxs(
    AP,
    {
      defaultValue: e[0] || n[0],
      className: "nodesettings-tabs funcnodes-control-root",
      children: [
        /* @__PURE__ */ C.jsx(
          RP,
          {
            className: "nodesettings-tabs-list",
            "aria-label": "Manage node outputs",
            children: n.map((r) => /* @__PURE__ */ C.jsx(
              Hx,
              {
                value: r,
                className: "nodesettings-tabs-trigger",
                children: r
              },
              r
            ))
          }
        ),
        n.map((r) => {
          const a = t.io_stores.get(r);
          return /* @__PURE__ */ C.jsx(
            Wx,
            {
              value: r,
              className: "nodesettings-tabs-content nodesettings-io-list",
              children: a && /* @__PURE__ */ C.jsx(Pd.Provider, { value: a, children: /* @__PURE__ */ C.jsx(CY, {}) })
            },
            r
          );
        })
      ]
    }
  );
}, Q$e = ({
  nodeSettingsPath: e
}) => {
  const t = e.split("/") || ["general"];
  return /* @__PURE__ */ C.jsxs(
    AP,
    {
      defaultValue: t[0] || "general",
      className: "nodesettings-tabs funcnodes-control-root",
      children: [
        /* @__PURE__ */ C.jsxs(
          RP,
          {
            className: "nodesettings-tabs-list",
            "aria-label": "Manage node settings",
            children: [
              /* @__PURE__ */ C.jsx(Hx, { value: "general", className: "nodesettings-tabs-trigger", children: "General" }),
              /* @__PURE__ */ C.jsx(Hx, { value: "inputs", className: "nodesettings-tabs-trigger", children: "Inputs" }),
              /* @__PURE__ */ C.jsx(Hx, { value: "outputs", className: "nodesettings-tabs-trigger", children: "Outputs" })
            ]
          }
        ),
        /* @__PURE__ */ C.jsx(Wx, { value: "general", className: "nodesettings-tabs-content", children: /* @__PURE__ */ C.jsx(Y$e, {}) }),
        /* @__PURE__ */ C.jsx(
          Wx,
          {
            value: "inputs",
            className: "nodesettings-tabs-content nodesettings-io-list",
            children: /* @__PURE__ */ C.jsx(
              X$e,
              {
                splitnodesettingsPath: (
                  // all but first element
                  t.slice(1)
                )
              }
            )
          }
        ),
        /* @__PURE__ */ C.jsx(
          Wx,
          {
            value: "outputs",
            className: "nodesettings-tabs-content nodesettings-io-list",
            children: /* @__PURE__ */ C.jsx(
              J$e,
              {
                splitnodesettingsPath: (
                  // all but first element
                  t.slice(1)
                )
              }
            )
          }
        )
      ]
    }
  );
}, Z$e = M.memo(
  ({ isOpen: e, onOpenChange: t, nodeSettingsPath: n }) => {
    const r = Ri().use((a) => a.id);
    return /* @__PURE__ */ C.jsx(
      Yl,
      {
        title: `Node Settings: ${r}`,
        open: e,
        onOpenChange: t,
        dialogClassName: "nodesettings-dialog",
        children: /* @__PURE__ */ C.jsx(Q$e, { nodeSettingsPath: n })
      }
    );
  }
), e6e = M.memo(({ toogleShowSettings: e }) => {
  const t = Sn(), { node: n } = Oa(), r = Ri(), { id: a, description: s, node_name: l } = r.useShallow((d) => ({
    id: d.id,
    description: d.description,
    node_name: d.node_name
  })), c = M.useCallback(() => {
    t.on_node_action({
      type: "trigger",
      from_remote: !1,
      id: a
    });
  }, [t, a]);
  return /* @__PURE__ */ C.jsxs("div", { className: "nodeheader", title: s || l, children: [
    /* @__PURE__ */ C.jsxs("div", { className: "nodeheader_element", children: [
      /* @__PURE__ */ C.jsx(
        bce,
        {
          fontSize: "inherit",
          className: "triggerbutton nodeheaderbutton ",
          onClick: c
        }
      ),
      /* @__PURE__ */ C.jsx(
        yce,
        {
          fontSize: "inherit",
          className: "nodestatusbutton nodeheaderbutton",
          onClick: async () => {
            n && console.log("nodestatus", await n.get_node_status(a));
          }
        }
      ),
      /* @__PURE__ */ C.jsx(
        xce,
        {
          fontSize: "inherit",
          className: "nodesettingsbutton nodeheaderbutton",
          onClick: () => {
            e?.();
          }
        }
      )
    ] }),
    /* @__PURE__ */ C.jsx("div", { className: "nodeheader_element nodeheader_title", children: /* @__PURE__ */ C.jsx("div", { className: "nodeheader_title_text", children: l }) }),
    /* @__PURE__ */ C.jsx("div", { className: "nodeheader_element", children: /* @__PURE__ */ C.jsx(nk, { fontSize: "inherit" }) })
  ] });
}), t6e = M.memo(({ iostore: e }) => {
  const t = e.use(), n = Ri().use((l) => l.render_options), r = vk(t.id), [a, s] = b$e(t);
  return /* @__PURE__ */ C.jsx(
    "div",
    {
      className: "nodrag nodedatabody",
      "data-src": n?.data?.src || "",
      children: a && t && /* @__PURE__ */ C.jsx(Pd.Provider, { value: e, children: /* @__PURE__ */ C.jsx(
        Yl,
        {
          title: t.full_id,
          trigger: /* @__PURE__ */ C.jsx("div", { className: "nodedatabutton", children: /* @__PURE__ */ C.jsx(EY, { Component: a }) }),
          onOpenChange: (l) => {
            l && r?.();
          },
          children: s && /* @__PURE__ */ C.jsx(_Y, { Component: s, iostore: e })
        }
      ) })
    }
  );
}), n6e = M.memo(
  ({ setShowSettings: e, setNodeSettingsPath: t }) => {
    const n = Ri(), { render_options: r, outputs: a, inputs: s } = n.useShallow(
      (c) => ({
        render_options: c.render_options,
        outputs: c.outputs,
        inputs: c.inputs
      })
    ), l = r?.data?.src ? n.io_stores.get(r?.data?.src) : void 0;
    return /* @__PURE__ */ C.jsxs("div", { className: "nodebody nowheel ", children: [
      a.map((c) => {
        const d = n.io_stores.get(c);
        if (d)
          return /* @__PURE__ */ C.jsx(Pd.Provider, { value: d, children: /* @__PURE__ */ C.jsx(
            k$e,
            {
              setNodeSettingsPath: t,
              setShowSettings: e
            }
          ) }, c);
      }),
      l && /* @__PURE__ */ C.jsx(t6e, { iostore: l }),
      s.map((c) => {
        const d = n.io_stores.get(c);
        if (d)
          return /* @__PURE__ */ C.jsx(Pd.Provider, { value: d, children: /* @__PURE__ */ C.jsx(
            S$e,
            {
              setNodeSettingsPath: t,
              setShowSettings: e
            }
          ) }, c);
      })
    ] });
  }
), jP = () => {
  const e = Ri(), { original_name: t, id: n } = e.useShallow((d) => ({
    original_name: d.name,
    id: d.id
  })), [r, a] = M.useState(t);
  M.useEffect(() => {
    a(t);
  }, [t]);
  const s = Sn(), l = (d) => {
    a(d.target.value);
  }, c = (d) => {
    const f = d.target.value;
    f !== t && s.on_node_action({
      type: "update",
      from_remote: !1,
      id: n,
      node: { name: f }
    });
  };
  return /* @__PURE__ */ C.jsx(
    "input",
    {
      className: "nodename_input",
      value: r,
      onChange: l,
      onBlur: c
    }
  );
}, r6e = () => {
  const e = Ri().use((t) => t.progress);
  return e ? /* @__PURE__ */ C.jsx(
    uhe,
    {
      state: e,
      className: "nodeprogress"
    }
  ) : null;
}, o6e = M.memo(() => {
  const e = Ri().use((t) => t.error);
  return /* @__PURE__ */ C.jsxs("div", { className: "nodefooter", children: [
    e && /* @__PURE__ */ C.jsx("div", { className: "nodeerror", children: e }),
    /* @__PURE__ */ C.jsx(r6e, {})
  ] });
}), a6e = () => {
  const e = Ri(), { collapsed: t, error: n, node_id: r } = e.useShallow((g) => ({
    collapsed: g.properties["frontend:collapsed"] || !1,
    error: g.error,
    node_id: g.node_id
  })), { visualTrigger: a } = x$e(e), [s, l] = M.useState(!1), [c, d] = M.useState(""), { keys: f } = N4(), m = M.useContext(td).NodeHooks[r] ?? [], h = M.useCallback(() => {
    l((g) => !g);
  }, []), v = (g) => {
    f.has("s") && !s && (d(""), l(!0), g.stopPropagation());
  };
  return /* @__PURE__ */ C.jsxs(
    "div",
    {
      className: "innernode" + (a ? " intrigger" : "") + (n ? " error" : ""),
      onClick: v,
      children: [
        /* @__PURE__ */ C.jsx(e6e, { toogleShowSettings: h }),
        /* @__PURE__ */ C.jsx(jP, {}),
        t ? null : /* @__PURE__ */ C.jsx(
          n6e,
          {
            setNodeSettingsPath: d,
            setShowSettings: l
          }
        ),
        /* @__PURE__ */ C.jsx(o6e, {}),
        /* @__PURE__ */ C.jsx(
          Z$e,
          {
            isOpen: s,
            onOpenChange: l,
            nodeSettingsPath: c
          }
        ),
        m.map((g, b) => /* @__PURE__ */ C.jsx(M.Fragment, { children: /* @__PURE__ */ C.jsx(g, {}) }, b))
      ]
    }
  );
}, i6e = M.memo(
  ({ data: e }) => /* @__PURE__ */ C.jsx(fC.Provider, { value: e.nodestore, children: /* @__PURE__ */ C.jsx(a6e, {}) }),
  (e, t) => e.data.nodestore === t.data.nodestore
), s6e = ({
  id: e,
  sourceX: t,
  sourceY: n,
  targetX: r,
  targetY: a,
  sourcePosition: s,
  targetPosition: l,
  data: c,
  ...d
}) => {
  const [f] = mj({
    sourceX: t,
    sourceY: n,
    sourcePosition: s,
    targetX: r,
    targetY: a,
    targetPosition: l
  });
  return /* @__PURE__ */ C.jsx(C.Fragment, { children: /* @__PURE__ */ C.jsx(gk, { id: e, path: f, ...d }) });
}, l6e = {
  default: i6e,
  group: l_e
}, u6e = {
  default: s6e
}, c6e = (e) => ({
  nodes: e.getNodes(),
  edges: e.getEdges(),
  onNodesChange: e.onNodesChange,
  onEdgesChange: e.onEdgesChange,
  onConnect: e.onConnect
}), PP = (e) => {
  const t = /* @__PURE__ */ new Set(), n = e.filter(
    (a) => a.type === "group"
  );
  n.forEach((a) => {
    t.add(a.id);
  });
  const r = e.filter(
    (a) => !t.has(a.id)
  );
  return { group_nodes: n, default_nodes: r };
};
function DP(e) {
  const t = new Map(e.map((l) => [l.id, l])), n = /* @__PURE__ */ new Map(), r = [];
  for (const l of e)
    if (n.has(l.id) || n.set(l.id, []), l.parentId && t.has(l.parentId)) {
      const c = t.get(l.parentId);
      if (c) {
        const d = n.get(c.id) || [];
        d.push(l), n.set(c.id, d);
      } else
        r.push(l);
    } else
      r.push(l);
  const a = [];
  function s(l) {
    a.push(l);
    const c = n.get(l.id) || [];
    for (const d of c)
      s(d);
  }
  for (const l of r)
    s(l);
  if (a.length !== e.length) {
    console.warn(
      "Sorting mismatch: Not all nodes could be placed. Check for circular dependencies or missing parents."
    );
    const l = new Set(a.map((c) => c.id));
    e.forEach((c) => {
      l.has(c.id) || a.push(c);
    });
  }
  return a;
}
const qY = () => {
  const { getNodes: e } = Jm();
  return {
    getNodes: e,
    getSelectedNodes: (t) => (t === void 0 && (t = e()), t.filter((n) => n.selected)),
    getSplitNodes: (t) => {
      t === void 0 && (t = e());
      const { group_nodes: n, default_nodes: r } = PP(t);
      return { group_nodes: n, default_nodes: r };
    },
    getSortedNodes: (t) => (t === void 0 && (t = e()), DP(t))
  };
}, GY = (e, t) => {
  const n = e.getState(), { new_obj: r, change: a } = Ed(n, t);
  a && e.setState(r);
}, KY = (e) => Hi(e);
function P9(e) {
  return e != null && typeof e == "object" && "id" in e && typeof e.id == "string";
}
const YY = (e) => {
  let t = e.io ?? {}, n = e.io_order, r = [];
  const a = {};
  if (n === void 0)
    if (Array.isArray(t)) {
      const s = t.filter(P9);
      r = s.map((l) => l.id);
      for (const l of s)
        a[l.id] = l;
    } else {
      r = Object.keys(t);
      for (const s in t)
        t[s] !== void 0 && (a[s] = t[s]);
    }
  else if (r = n, Array.isArray(t)) {
    const s = t.filter(P9);
    for (const l of s)
      a[l.id] = l, r.includes(l.id) || r.push(l.id);
  } else
    for (const s in t)
      t[s] !== void 0 && (a[s] = t[s]), r.includes(s) || r.push(s);
  return { ...e, io_order: r, io: a };
}, d6e = {
  id: "dummy",
  node_id: "dummy",
  node_name: "dummy",
  properties: {
    "frontend:size": [200, 100],
    "frontend:pos": [NaN, NaN],
    "frontend:collapsed": !1
  },
  io: {},
  io_order: [],
  name: "dummy",
  in_trigger: !1,
  reset_inputs_on_trigger: !1,
  progress: {
    ascii: !1,
    elapsed: 0,
    initial: 0,
    n: 0,
    prefix: "idle",
    unit: "it",
    unit_divisor: 1e3,
    unit_scale: !1
  }
}, f6e = {
  id: "dummy",
  name: "dummy",
  node: "dummy",
  full_id: "dummy",
  type: "any",
  value: void 0,
  is_input: !1,
  connected: !1,
  does_trigger: !0,
  fullvalue: void 0,
  render_options: {
    set_default: !0,
    type: "any"
  },
  hidden: !1,
  emit_value_set: !0,
  required: !1
}, p6e = US(d6e), m6e = US(f6e), h6e = (e) => {
  const t = e.io_order;
  if (t === void 0)
    throw new Error("Node must have io_order");
  return {
    ...e,
    inputs: Object.keys(e.io).filter((n) => e.io[n].is_input),
    outputs: Object.keys(e.io).filter((n) => !e.io[n].is_input),
    io_order: t
  };
}, g6e = (e) => (e.value === "<NoValue>" && (e.value = void 0), e.fullvalue === "<NoValue>" && (e.fullvalue = void 0), e.hidden === void 0 && (e.hidden = !1), [{
  ...e
}, e.value, e.fullvalue]), v6e = (e) => {
  if (!e.id)
    throw new Error("Node must have an id");
  const t = p6e(e);
  return h6e(t);
}, y6e = (e, t) => {
  const n = e.getState(), r = {}, a = YY(t), s = Object.keys(a);
  for (const l of s)
    switch (l) {
      case "id": {
        const [c, d] = Ti(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      case "node_id": {
        const [c, d] = Ti(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      case "node_name": {
        const [c, d] = Ti(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      case "name": {
        const [c, d] = Ti(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      case "in_trigger": {
        const [c, d] = Ti(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      case "error": {
        a[l] !== n[l] && (r[l] = a[l]);
        break;
      }
      case "render_options": {
        const [c, d] = Uh(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      case "io_order": {
        const [c, d] = ((f, m) => m === void 0 ? [f, !1] : [m, !TR(f, m)])(n[l], a[l]);
        d && (r[l] = c.filter((f) => f !== void 0));
        break;
      }
      case "io": {
        const c = a[l];
        if (c === void 0) break;
        for (const d in c) {
          const f = e.io_stores.get(d);
          if (!f) {
            console.error("io key not found in oldvalue:", d);
            continue;
          }
          f.update(c[d]);
        }
        break;
      }
      case "progress": {
        const [c, d] = Uh(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      case "description": {
        r[l] = a[l];
        break;
      }
      case "properties": {
        const [c, d] = Uh(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      case "status": {
        const [c, d] = Uh(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      case "reset_inputs_on_trigger": {
        const [c, d] = Ti(
          n[l],
          a[l]
        );
        d && (r[l] = c);
        break;
      }
      default:
        try {
          J8(l, a[l]);
        } catch (c) {
          console.error(c);
        }
    }
  Object.keys(r).length > 0 && e.setState(r);
}, b6e = (e, t) => {
  const n = e.getState(), r = {}, a = {}, s = Object.keys(t);
  for (const l of s)
    switch (l) {
      case "name": {
        const [c, d] = Ti(
          n[l],
          t[l]
        );
        d && (r[l] = c);
        break;
      }
      case "id": {
        const [c, d] = Ti(
          n[l],
          t[l]
        );
        d && (r[l] = c);
        break;
      }
      case "connected": {
        const [c, d] = Ti(
          n[l],
          t[l]
        );
        d && (r[l] = c);
        break;
      }
      case "does_trigger": {
        const [c, d] = Ti(
          n[l],
          t[l]
        );
        d && (r[l] = c);
        break;
      }
      case "hidden": {
        const [c, d] = Ti(
          n[l],
          t[l]
        );
        d && (r[l] = c);
        break;
      }
      case "full_id": {
        const [c, d] = Ti(
          n[l],
          t[l]
        );
        d && (r[l] = c);
        break;
      }
      case "is_input":
        break;
      case "node":
        break;
      case "type":
        break;
      case "value": {
        a.preview = t[l];
        break;
      }
      case "fullvalue": {
        a.full = t[l];
        break;
      }
      case "render_options": {
        const [c, d] = Uh(
          n[l],
          t[l]
        );
        d && (r[l] = c);
        break;
      }
      case "value_options": {
        const [c, d] = Uh(
          n[l],
          t[l]
        );
        d && (r[l] = c);
        break;
      }
      case "valuepreview_type": {
        r[l] = t[l];
        break;
      }
      case "emit_value_set": {
        r[l] = t[l];
        break;
      }
      case "default": {
        r[l] = t[l];
        break;
      }
      case "required": {
        r[l] = t[l];
        break;
      }
      default:
        try {
          J8(l, t[l]);
        } catch (c) {
          console.error(c);
        }
    }
  Object.keys(a).length > 0 && e.updateValueStore(a), Object.keys(r).length > 0 && e.setState(r);
}, w6e = (e) => {
  if (!e.id)
    throw new Error(
      "IO must have an id but is missing for " + JSON.stringify(e)
    );
  e.name === void 0 && (e.name = e.id);
  const t = m6e(e);
  return (t.render_options.type === "any" || t.render_options.type === void 0) && (t.render_options.type = t.type), g6e(t);
}, x6e = (e, t) => {
  let n;
  const [r, a, s] = w6e(t);
  return n = {
    io_state: KY((l, c) => r),
    use: (l) => l ? n.io_state(l) : n.io_state(),
    useShallow: (l) => n.io_state(Sj(l)),
    getState: () => n.io_state.getState(),
    setState: (l) => {
      n.io_state.setState(l);
    },
    update: (l) => {
      b6e(n, l);
    },
    valuestore: Hi((l, c) => {
      let d = a;
      d === "<NoValue>" && (d = void 0), !(d instanceof Nl) && d !== void 0 && (d = vd.fromObject(d));
      let f = s;
      return f === "<NoValue>" && (f = void 0), !(f instanceof Nl) && f !== void 0 && (f = vd.fromObject(f)), {
        preview: d,
        full: f
      };
    }),
    updateValueStore: (l) => {
      n.valuestore.setState((c) => (c.preview && typeof c.preview.dispose == "function" && c.preview.dispose(), c.full && typeof c.full.dispose == "function" && c.full.dispose(), l.preview !== void 0 && l.full === void 0 && (l.full = void 0, c.full = void 0), l.preview !== void 0 && !(l.preview instanceof Nl) && (l.preview = vd.fromObject(l.preview)), l.full !== void 0 && !(l.full instanceof Nl) && (l.full = vd.fromObject(l.full)), { ...c, ...l }));
    },
    node: e,
    serialize: () => {
      const l = n.io_state.getState(), c = n.valuestore.getState();
      return {
        ...l,
        value: c.preview,
        fullvalue: c.full,
        render_options: l.render_options,
        valuepreview_type: l.valuepreview_type,
        emit_value_set: l.emit_value_set
      };
    }
  }, n;
}, S6e = (e) => {
  const t = {
    use: (s) => s ? r.node_state(s) : r.node_state(),
    useShallow: (s) => r.node_state(Sj(s)),
    io_stores: /* @__PURE__ */ new Map(),
    getState: () => r.node_state.getState(),
    setState: (s) => {
      r.node_state.setState(s);
    },
    update: (s) => {
      y6e(r, s);
    },
    serialize: () => ({
      ...r.node_state.getState(),
      io: Object.fromEntries(
        Array.from(r.io_stores.entries()).map(([s, l]) => [
          s,
          l.serialize()
        ])
      )
    })
  }, n = YY(e), r = {
    ...t,
    node_state: KY((s, l) => v6e(n))
  }, a = n.io;
  return Object.entries(a).forEach(([s, l]) => {
    l !== void 0 && r.io_stores.set(s, x6e(n.id, l));
  }), r;
}, k6e = () => {
  const e = Sn();
  return {
    onSelectionChange: M.useCallback(
      ({ nodes: t, edges: n }) => {
        const { group_nodes: r, default_nodes: a } = PP(t), s = e.local_state.getState();
        e.local_state.setState({
          ...s,
          selected_nodes: a.map((l) => l.id),
          selected_edges: n.map((l) => l.id),
          selected_groups: r.map((l) => l.id)
        });
      },
      [e]
    )
  };
}, _6e = () => {
  const e = Jm(), t = Sn();
  return t.rf_instance = e, /* @__PURE__ */ C.jsx(C.Fragment, {});
}, E6e = () => {
  const e = Sn(), { getEdges: t } = Jm(), { getSelectedNodes: n } = qY();
  return {
    copySelectedNodes: M.useCallback(() => {
      const r = t(), a = n();
      if (a.length === 0) return;
      const s = { nodes: [], edges: [] };
      for (const d of a) {
        const f = e.nodespace.get_node(d.id, !1);
        f && s.nodes.push(f.serialize());
      }
      const l = new Set(a.map((d) => d.id)), c = r.filter(
        (d) => l.has(d.source) && l.has(d.target)
      );
      for (const d of c)
        !d.sourceHandle || !d.targetHandle || s.edges.push({
          src_nid: d.source,
          src_ioid: d.sourceHandle,
          trg_nid: d.target,
          trg_ioid: d.targetHandle
        });
      navigator.clipboard.writeText(JSON.stringify(s));
    }, [n, t, e])
  };
}, C6e = () => {
  const e = Ac("Delete"), t = Ac(["Meta+c", "Control+c", "Strg+c"]), n = Ac(["Control+g", "Meta+g"]), r = Ac(["Control+Alt+g", "Meta+Alt+g"]), a = i_e(), { getEdges: s } = Jm(), { getNodes: l, getSelectedNodes: c, getSplitNodes: d } = qY(), { copySelectedNodes: f } = E6e(), { node: m, group: h, edge: v } = Oa();
  return M.useEffect(() => {
    if (e) {
      const g = s().filter((k) => k.selected);
      for (const k of g)
        !k.source || !k.target || !k.sourceHandle || !k.targetHandle || v?.remove_edge({
          src_nid: k.source,
          src_ioid: k.sourceHandle,
          trg_nid: k.target,
          trg_ioid: k.targetHandle
        });
      const b = c(), { group_nodes: x, default_nodes: w } = d(b);
      for (const k of w)
        m?.remove_node(k.id);
      for (const k of x)
        h?.remove_group(k.id);
    }
  }, [e, l, s, m, h, v]), M.useEffect(() => {
    t && f();
  }, [t, f]), M.useEffect(() => {
    if (n) {
      const g = c(), { group_nodes: b, default_nodes: x } = d(g);
      g.length > 0 && a(
        x.map((w) => w.id),
        b.map((w) => w.id)
      );
    }
  }, [n, l]), M.useEffect(() => {
    if (r) {
      const g = c(), { group_nodes: b } = d(g);
      b.forEach((x) => {
        h?.remove_group(x.id);
      });
    }
  }, [r, l]), /* @__PURE__ */ C.jsx(C.Fragment, {});
}, O6e = () => {
  const { node: e, edge: t } = Oa(), n = Sn();
  return M.useCallback(
    async (r, a) => {
      try {
        if (!r || !e || !t) return;
        const s = JSON.parse(r);
        if (!s || !n.worker || !s.nodes) return;
        const l = [0, 0];
        for (const d of s.nodes)
          l[0] += d.properties["frontend:pos"][0], l[1] += d.properties["frontend:pos"][1];
        l[0] /= s.nodes.length, l[1] /= s.nodes.length;
        const c = [];
        for (const d of s.nodes) {
          const f = {
            id: d.node_id,
            src_id: d.id,
            position: [
              d.properties["frontend:pos"][0] - l[0],
              d.properties["frontend:pos"][1] - l[1]
            ]
          };
          c.push(f);
        }
        for (const d of c) {
          const f = await e.add_node(d.id);
          !f || !n.nodespace.get_node(f.id, !1) || (d.new_id = f.id, a([
            {
              id: f.id,
              type: "position",
              position: {
                x: d.position[0] + f.properties["frontend:pos"][0],
                y: d.position[1] + f.properties["frontend:pos"][1]
              }
            }
          ]));
        }
        for (const d of s.edges) {
          const f = c.find(
            (h) => h.src_id === d.src_nid
          ), m = c.find(
            (h) => h.src_id === d.trg_nid
          );
          !f || !m || !f.new_id || !m.new_id || t.add_edge({
            src_nid: f.new_id,
            src_ioid: d.src_ioid,
            trg_nid: m.new_id,
            trg_ioid: d.trg_ioid
          });
        }
      } catch (s) {
        console.error("Failed to process pasted data:", s);
      }
    },
    [e, t, n]
  );
}, M6e = (e, t) => {
  const n = e.properties || {};
  n["frontend:size"] || (n["frontend:size"] = [200, 100]);
  const r = n["frontend:pos"];
  if (!r || r.length !== 2 || isNaN(r[0]) || r[0] === null || isNaN(r[1]) || r[1] === null)
    if (!t || !t.rf_instance || t.reactflowRef === null)
      n["frontend:pos"] = [0, 0];
    else {
      const a = t.reactflowRef.getBoundingClientRect(), s = a.left + a.width / 2, l = a.top + a.height / 2, c = t.rf_instance.screenToFlowPosition({
        x: s,
        y: l
      });
      n["frontend:pos"] = [
        c.x - n["frontend:size"][0] / 2,
        c.y - n["frontend:size"][0] / 2
      ];
    }
  n["frontend:collapsed"] || (n["frontend:collapsed"] = !1), e.properties = n;
}, N6e = (e, t) => {
  const n = e.getState();
  if (M6e(n, t), n.id === void 0)
    throw new Error("Node must have an id");
  const r = {
    nodestore: e
  };
  return {
    position: {
      x: n.properties["frontend:pos"][0],
      y: n.properties["frontend:pos"][1]
    },
    data: r,
    type: "default",
    zIndex: 1003,
    // expandParent: true,
    ...n
  };
}, D9 = {
  default: _a.Dots,
  metal: _a.Cross,
  light: _a.Dots,
  solarized: _a.Dots,
  midnight: _a.Dots,
  forest: _a.Dots,
  scientific: _a.Lines
}, A6e = (e) => {
  const t = Sn(), n = M.useRef(null), { colorTheme: r } = AU(), { onSelectionChange: a } = k6e(), s = oge();
  M.useEffect(() => {
    t.getStateManager().toaster = s;
  }, []), M.useEffect(() => {
    t.reactflowRef = n.current;
  }, [n]);
  const { nodes: l, edges: c, onNodesChange: d, onEdgesChange: f, onConnect: m } = t.useReactFlowStore(Sj(c6e)), h = O6e(), v = M.useCallback(
    (g) => {
      const b = n.current;
      if (!b) return;
      let x = g.target, w = 0;
      for (; x && x.parentElement && x !== b; )
        w++, x = x.parentElement;
      t.logger.debug(`onPasteCapture: ${w} steps to reactflow`), w <= 2 && h(
        g.clipboardData.getData("text/plain"),
        d
      );
    },
    [h, d, t.logger]
  );
  return /* @__PURE__ */ C.jsx("div", { className: "reactflowlayer", children: /* @__PURE__ */ C.jsxs(
    A0e,
    {
      onPasteCapture: v,
      nodes: l,
      edges: c,
      onNodesChange: d,
      onEdgesChange: f,
      onConnect: m,
      nodeTypes: l6e,
      edgeTypes: u6e,
      minZoom: e.minZoom,
      maxZoom: e.maxZoom,
      fitView: !0,
      onSelectionChange: a,
      ref: n,
      panOnDrag: !e.static,
      children: [
        /* @__PURE__ */ C.jsx(_6e, {}),
        /* @__PURE__ */ C.jsx(C6e, {}),
        /* @__PURE__ */ C.jsx(
          I0e,
          {
            color: "#888",
            gap: 24,
            size: 2,
            variant: D9[r] || D9.default,
            patternClassName: "fn-background-pattern"
          }
        ),
        e.minimap && /* @__PURE__ */ C.jsx(
          e_e,
          {
            nodeStrokeWidth: 3,
            pannable: !e.static,
            zoomable: !e.static,
            zoomStep: 3
          }
        )
      ]
    }
  ) });
}, R6e = ({
  on_node_change: e,
  on_edge_change: t,
  on_connect: n
}) => {
  const r = e || ((l) => {
  }), a = t || ((l) => {
  }), s = n || ((l) => {
  });
  return Hi((l, c) => ({
    _nodes: [],
    _edges: [],
    _nodes_map: /* @__PURE__ */ new Map(),
    update_nodes: (d) => {
      d = DP(d), l({
        _nodes: d,
        _nodes_map: new Map(d.map((f) => [f.id, f]))
      });
    },
    partial_update_nodes: (d) => {
      const f = c(), m = f._nodes, h = new Map(
        m.map((v) => [v.id, v])
      );
      for (const v of d)
        h.set(v.id, v);
      f.update_nodes(Array.from(h.values()));
    },
    update_edges: (d) => {
      l({
        _edges: d
      });
    },
    onNodesChange: (d) => {
      const f = c();
      f.update_nodes(wj(d, f._nodes)), r(d);
    },
    onEdgesChange: (d) => {
      l({
        _edges: nq(d, c()._edges)
      }), a(d);
    },
    onConnect: (d) => {
      d.source == null || d.target == null || s(d);
    },
    getNode: (d) => c()._nodes_map.get(d),
    getNodes: () => c()._nodes,
    getEdges: () => c()._edges
  }));
}, j6e = () => {
  const e = Sn().progress_state();
  return /* @__PURE__ */ C.jsxs("div", { className: "statusbar", children: [
    /* @__PURE__ */ C.jsx(
      "span",
      {
        className: "statusbar-progressbar",
        style: { width: Math.min(100, 100 * e.progress) + "%" }
      }
    ),
    /* @__PURE__ */ C.jsx("span", { className: "statusbar-message", children: e.message })
  ] });
}, jS = () => window?._FUNCNODES_DEV ?? !1;
var iR = ["Enter", " "], P6e = ["ArrowDown", "PageUp", "Home"], XY = ["ArrowUp", "PageDown", "End"], D6e = [...P6e, ...XY], I6e = {
  ltr: [...iR, "ArrowRight"],
  rtl: [...iR, "ArrowLeft"]
}, $6e = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, Ak = "Menu", [PS, z6e, T6e] = qE(Ak), [lh, JY] = Kl(Ak, [
  T6e,
  VE,
  BC
]), Rk = VE(), QY = BC(), [ZY, uh] = lh(Ak), [L6e, jk] = lh(Ak), eX = (e) => {
  const { __scopeMenu: t, open: n = !1, children: r, dir: a, onOpenChange: s, modal: l = !0 } = e, c = Rk(t), [d, f] = M.useState(null), m = M.useRef(!1), h = $a(s), v = mC(a);
  return M.useEffect(() => {
    const g = () => {
      m.current = !0, document.addEventListener("pointerdown", b, { capture: !0, once: !0 }), document.addEventListener("pointermove", b, { capture: !0, once: !0 });
    }, b = () => m.current = !1;
    return document.addEventListener("keydown", g, { capture: !0 }), () => {
      document.removeEventListener("keydown", g, { capture: !0 }), document.removeEventListener("pointerdown", b, { capture: !0 }), document.removeEventListener("pointermove", b, { capture: !0 });
    };
  }, []), /* @__PURE__ */ C.jsx(L4, { ...c, children: /* @__PURE__ */ C.jsx(
    ZY,
    {
      scope: t,
      open: n,
      onOpenChange: h,
      content: d,
      onContentChange: f,
      children: /* @__PURE__ */ C.jsx(
        L6e,
        {
          scope: t,
          onClose: M.useCallback(() => h(!1), [h]),
          isUsingKeyboardRef: m,
          dir: v,
          modal: l,
          children: r
        }
      )
    }
  ) });
};
eX.displayName = Ak;
var F6e = "MenuAnchor", IP = M.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, a = Rk(n);
    return /* @__PURE__ */ C.jsx(F4, { ...a, ...r, ref: t });
  }
);
IP.displayName = F6e;
var B6e = "MenuPortal", [lKe, tX] = lh(B6e, {
  forceMount: void 0
}), Wi = "MenuContent", [U6e, $P] = lh(Wi), nX = M.forwardRef(
  (e, t) => {
    const n = tX(Wi, e.__scopeMenu), { forceMount: r = n.forceMount, ...a } = e, s = uh(Wi, e.__scopeMenu), l = jk(Wi, e.__scopeMenu);
    return /* @__PURE__ */ C.jsx(PS.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ C.jsx(al, { present: r || s.open, children: /* @__PURE__ */ C.jsx(PS.Slot, { scope: e.__scopeMenu, children: l.modal ? /* @__PURE__ */ C.jsx(V6e, { ...a, ref: t }) : /* @__PURE__ */ C.jsx(H6e, { ...a, ref: t }) }) }) });
  }
), V6e = M.forwardRef(
  (e, t) => {
    const n = uh(Wi, e.__scopeMenu), r = M.useRef(null), a = Xn(t, r);
    return M.useEffect(() => {
      const s = r.current;
      if (s) return f4(s);
    }, []), /* @__PURE__ */ C.jsx(
      zP,
      {
        ...e,
        ref: a,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: et(
          e.onFocusOutside,
          (s) => s.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), H6e = M.forwardRef((e, t) => {
  const n = uh(Wi, e.__scopeMenu);
  return /* @__PURE__ */ C.jsx(
    zP,
    {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), W6e = /* @__PURE__ */ pg("MenuContent.ScrollLock"), zP = M.forwardRef(
  (e, t) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: a,
      onOpenAutoFocus: s,
      onCloseAutoFocus: l,
      disableOutsidePointerEvents: c,
      onEntryFocus: d,
      onEscapeKeyDown: f,
      onPointerDownOutside: m,
      onFocusOutside: h,
      onInteractOutside: v,
      onDismiss: g,
      disableOutsideScroll: b,
      ...x
    } = e, w = uh(Wi, n), k = jk(Wi, n), E = Rk(n), _ = QY(n), O = z6e(n), [N, A] = M.useState(null), R = M.useRef(null), D = Xn(t, R, w.onContentChange), I = M.useRef(0), z = M.useRef(""), B = M.useRef(0), P = M.useRef(null), H = M.useRef("right"), L = M.useRef(0), G = b ? jE : M.Fragment, $ = b ? { as: W6e, allowPinchZoom: !0 } : void 0, K = (Z) => {
      const V = z.current + Z, F = O().filter((fe) => !fe.disabled), Y = document.activeElement, U = F.find((fe) => fe.ref.current === Y)?.textValue, W = F.map((fe) => fe.textValue), J = rze(W, V, U), oe = F.find((fe) => fe.textValue === J)?.ref.current;
      (function fe(ie) {
        z.current = ie, window.clearTimeout(I.current), ie !== "" && (I.current = window.setTimeout(() => fe(""), 1e3));
      })(V), oe && setTimeout(() => oe.focus());
    };
    M.useEffect(() => () => window.clearTimeout(I.current), []), d4();
    const q = M.useCallback((Z) => H.current === P.current?.side && aze(Z, P.current?.area), []);
    return /* @__PURE__ */ C.jsx(
      U6e,
      {
        scope: n,
        searchRef: z,
        onItemEnter: M.useCallback(
          (Z) => {
            q(Z) && Z.preventDefault();
          },
          [q]
        ),
        onItemLeave: M.useCallback(
          (Z) => {
            q(Z) || (R.current?.focus(), A(null));
          },
          [q]
        ),
        onTriggerLeave: M.useCallback(
          (Z) => {
            q(Z) && Z.preventDefault();
          },
          [q]
        ),
        pointerGraceTimerRef: B,
        onPointerGraceIntentChange: M.useCallback((Z) => {
          P.current = Z;
        }, []),
        children: /* @__PURE__ */ C.jsx(G, { ...$, children: /* @__PURE__ */ C.jsx(
          NE,
          {
            asChild: !0,
            trapped: a,
            onMountAutoFocus: et(s, (Z) => {
              Z.preventDefault(), R.current?.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: l,
            children: /* @__PURE__ */ C.jsx(
              QS,
              {
                asChild: !0,
                disableOutsidePointerEvents: c,
                onEscapeKeyDown: f,
                onPointerDownOutside: m,
                onFocusOutside: h,
                onInteractOutside: v,
                onDismiss: g,
                children: /* @__PURE__ */ C.jsx(
                  DY,
                  {
                    asChild: !0,
                    ..._,
                    dir: k.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: N,
                    onCurrentTabStopIdChange: A,
                    onEntryFocus: et(d, (Z) => {
                      k.isUsingKeyboardRef.current || Z.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ C.jsx(
                      tV,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": bX(w.open),
                        "data-radix-menu-content": "",
                        dir: k.dir,
                        ...E,
                        ...x,
                        ref: D,
                        style: { outline: "none", ...x.style },
                        onKeyDown: et(x.onKeyDown, (Z) => {
                          const V = Z.target.closest("[data-radix-menu-content]") === Z.currentTarget, F = Z.ctrlKey || Z.altKey || Z.metaKey, Y = Z.key.length === 1;
                          V && (Z.key === "Tab" && Z.preventDefault(), !F && Y && K(Z.key));
                          const U = R.current;
                          if (Z.target !== U || !D6e.includes(Z.key)) return;
                          Z.preventDefault();
                          const W = O().filter((J) => !J.disabled).map((J) => J.ref.current);
                          XY.includes(Z.key) && W.reverse(), tze(W);
                        }),
                        onBlur: et(e.onBlur, (Z) => {
                          Z.currentTarget.contains(Z.target) || (window.clearTimeout(I.current), z.current = "");
                        }),
                        onPointerMove: et(
                          e.onPointerMove,
                          DS((Z) => {
                            const V = Z.target, F = L.current !== Z.clientX;
                            if (Z.currentTarget.contains(V) && F) {
                              const Y = Z.clientX > L.current ? "right" : "left";
                              H.current = Y, L.current = Z.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
nX.displayName = Wi;
var q6e = "MenuGroup", TP = M.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ C.jsx(Qt.div, { role: "group", ...r, ref: t });
  }
);
TP.displayName = q6e;
var G6e = "MenuLabel", rX = M.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ C.jsx(Qt.div, { ...r, ref: t });
  }
);
rX.displayName = G6e;
var Y2 = "MenuItem", I9 = "menu.itemSelect", VC = M.forwardRef(
  (e, t) => {
    const { disabled: n = !1, onSelect: r, ...a } = e, s = M.useRef(null), l = jk(Y2, e.__scopeMenu), c = $P(Y2, e.__scopeMenu), d = Xn(t, s), f = M.useRef(!1), m = () => {
      const h = s.current;
      if (!n && h) {
        const v = new CustomEvent(I9, { bubbles: !0, cancelable: !0 });
        h.addEventListener(I9, (g) => r?.(g), { once: !0 }), c4(h, v), v.defaultPrevented ? f.current = !1 : l.onClose();
      }
    };
    return /* @__PURE__ */ C.jsx(
      oX,
      {
        ...a,
        ref: d,
        disabled: n,
        onClick: et(e.onClick, m),
        onPointerDown: (h) => {
          e.onPointerDown?.(h), f.current = !0;
        },
        onPointerUp: et(e.onPointerUp, (h) => {
          f.current || h.currentTarget?.click();
        }),
        onKeyDown: et(e.onKeyDown, (h) => {
          const v = c.searchRef.current !== "";
          n || v && h.key === " " || iR.includes(h.key) && (h.currentTarget.click(), h.preventDefault());
        })
      }
    );
  }
);
VC.displayName = Y2;
var oX = M.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: a, ...s } = e, l = $P(Y2, n), c = QY(n), d = M.useRef(null), f = Xn(t, d), [m, h] = M.useState(!1), [v, g] = M.useState("");
    return M.useEffect(() => {
      const b = d.current;
      b && g((b.textContent ?? "").trim());
    }, [s.children]), /* @__PURE__ */ C.jsx(
      PS.ItemSlot,
      {
        scope: n,
        disabled: r,
        textValue: a ?? v,
        children: /* @__PURE__ */ C.jsx(IY, { asChild: !0, ...c, focusable: !r, children: /* @__PURE__ */ C.jsx(
          Qt.div,
          {
            role: "menuitem",
            "data-highlighted": m ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...s,
            ref: f,
            onPointerMove: et(
              e.onPointerMove,
              DS((b) => {
                r ? l.onItemLeave(b) : (l.onItemEnter(b), b.defaultPrevented || b.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: et(
              e.onPointerLeave,
              DS((b) => l.onItemLeave(b))
            ),
            onFocus: et(e.onFocus, () => h(!0)),
            onBlur: et(e.onBlur, () => h(!1))
          }
        ) })
      }
    );
  }
), K6e = "MenuCheckboxItem", aX = M.forwardRef(
  (e, t) => {
    const { checked: n = !1, onCheckedChange: r, ...a } = e;
    return /* @__PURE__ */ C.jsx(cX, { scope: e.__scopeMenu, checked: n, children: /* @__PURE__ */ C.jsx(
      VC,
      {
        role: "menuitemcheckbox",
        "aria-checked": X2(n) ? "mixed" : n,
        ...a,
        ref: t,
        "data-state": BP(n),
        onSelect: et(
          a.onSelect,
          () => r?.(X2(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
aX.displayName = K6e;
var iX = "MenuRadioGroup", [Y6e, X6e] = lh(
  iX,
  { value: void 0, onValueChange: () => {
  } }
), sX = M.forwardRef(
  (e, t) => {
    const { value: n, onValueChange: r, ...a } = e, s = $a(r);
    return /* @__PURE__ */ C.jsx(Y6e, { scope: e.__scopeMenu, value: n, onValueChange: s, children: /* @__PURE__ */ C.jsx(TP, { ...a, ref: t }) });
  }
);
sX.displayName = iX;
var lX = "MenuRadioItem", uX = M.forwardRef(
  (e, t) => {
    const { value: n, ...r } = e, a = X6e(lX, e.__scopeMenu), s = n === a.value;
    return /* @__PURE__ */ C.jsx(cX, { scope: e.__scopeMenu, checked: s, children: /* @__PURE__ */ C.jsx(
      VC,
      {
        role: "menuitemradio",
        "aria-checked": s,
        ...r,
        ref: t,
        "data-state": BP(s),
        onSelect: et(
          r.onSelect,
          () => a.onValueChange?.(n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
uX.displayName = lX;
var LP = "MenuItemIndicator", [cX, J6e] = lh(
  LP,
  { checked: !1 }
), dX = M.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, forceMount: r, ...a } = e, s = J6e(LP, n);
    return /* @__PURE__ */ C.jsx(
      al,
      {
        present: r || X2(s.checked) || s.checked === !0,
        children: /* @__PURE__ */ C.jsx(
          Qt.span,
          {
            ...a,
            ref: t,
            "data-state": BP(s.checked)
          }
        )
      }
    );
  }
);
dX.displayName = LP;
var Q6e = "MenuSeparator", fX = M.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ C.jsx(
      Qt.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: t
      }
    );
  }
);
fX.displayName = Q6e;
var Z6e = "MenuArrow", pX = M.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, a = Rk(n);
    return /* @__PURE__ */ C.jsx(nV, { ...a, ...r, ref: t });
  }
);
pX.displayName = Z6e;
var FP = "MenuSub", [eze, mX] = lh(FP), hX = (e) => {
  const { __scopeMenu: t, children: n, open: r = !1, onOpenChange: a } = e, s = uh(FP, t), l = Rk(t), [c, d] = M.useState(null), [f, m] = M.useState(null), h = $a(a);
  return M.useEffect(() => (s.open === !1 && h(!1), () => h(!1)), [s.open, h]), /* @__PURE__ */ C.jsx(L4, { ...l, children: /* @__PURE__ */ C.jsx(
    ZY,
    {
      scope: t,
      open: r,
      onOpenChange: h,
      content: f,
      onContentChange: m,
      children: /* @__PURE__ */ C.jsx(
        eze,
        {
          scope: t,
          contentId: Fl(),
          triggerId: Fl(),
          trigger: c,
          onTriggerChange: d,
          children: n
        }
      )
    }
  ) });
};
hX.displayName = FP;
var Cx = "MenuSubTrigger", gX = M.forwardRef(
  (e, t) => {
    const n = uh(Cx, e.__scopeMenu), r = jk(Cx, e.__scopeMenu), a = mX(Cx, e.__scopeMenu), s = $P(Cx, e.__scopeMenu), l = M.useRef(null), { pointerGraceTimerRef: c, onPointerGraceIntentChange: d } = s, f = { __scopeMenu: e.__scopeMenu }, m = M.useCallback(() => {
      l.current && window.clearTimeout(l.current), l.current = null;
    }, []);
    return M.useEffect(() => m, [m]), M.useEffect(() => {
      const h = c.current;
      return () => {
        window.clearTimeout(h), d(null);
      };
    }, [c, d]), /* @__PURE__ */ C.jsx(IP, { asChild: !0, ...f, children: /* @__PURE__ */ C.jsx(
      oX,
      {
        id: a.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": a.contentId,
        "data-state": bX(n.open),
        ...e,
        ref: ME(t, a.onTriggerChange),
        onClick: (h) => {
          e.onClick?.(h), !(e.disabled || h.defaultPrevented) && (h.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: et(
          e.onPointerMove,
          DS((h) => {
            s.onItemEnter(h), !h.defaultPrevented && !e.disabled && !n.open && !l.current && (s.onPointerGraceIntentChange(null), l.current = window.setTimeout(() => {
              n.onOpenChange(!0), m();
            }, 100));
          })
        ),
        onPointerLeave: et(
          e.onPointerLeave,
          DS((h) => {
            m();
            const v = n.content?.getBoundingClientRect();
            if (v) {
              const g = n.content?.dataset.side, b = g === "right", x = b ? -5 : 5, w = v[b ? "left" : "right"], k = v[b ? "right" : "left"];
              s.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: h.clientX + x, y: h.clientY },
                  { x: w, y: v.top },
                  { x: k, y: v.top },
                  { x: k, y: v.bottom },
                  { x: w, y: v.bottom }
                ],
                side: g
              }), window.clearTimeout(c.current), c.current = window.setTimeout(
                () => s.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (s.onTriggerLeave(h), h.defaultPrevented) return;
              s.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: et(e.onKeyDown, (h) => {
          const v = s.searchRef.current !== "";
          e.disabled || v && h.key === " " || I6e[r.dir].includes(h.key) && (n.onOpenChange(!0), n.content?.focus(), h.preventDefault());
        })
      }
    ) });
  }
);
gX.displayName = Cx;
var vX = "MenuSubContent", yX = M.forwardRef(
  (e, t) => {
    const n = tX(Wi, e.__scopeMenu), { forceMount: r = n.forceMount, ...a } = e, s = uh(Wi, e.__scopeMenu), l = jk(Wi, e.__scopeMenu), c = mX(vX, e.__scopeMenu), d = M.useRef(null), f = Xn(t, d);
    return /* @__PURE__ */ C.jsx(PS.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ C.jsx(al, { present: r || s.open, children: /* @__PURE__ */ C.jsx(PS.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ C.jsx(
      zP,
      {
        id: c.contentId,
        "aria-labelledby": c.triggerId,
        ...a,
        ref: f,
        align: "start",
        side: l.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (m) => {
          l.isUsingKeyboardRef.current && d.current?.focus(), m.preventDefault();
        },
        onCloseAutoFocus: (m) => m.preventDefault(),
        onFocusOutside: et(e.onFocusOutside, (m) => {
          m.target !== c.trigger && s.onOpenChange(!1);
        }),
        onEscapeKeyDown: et(e.onEscapeKeyDown, (m) => {
          l.onClose(), m.preventDefault();
        }),
        onKeyDown: et(e.onKeyDown, (m) => {
          const h = m.currentTarget.contains(m.target), v = $6e[l.dir].includes(m.key);
          h && v && (s.onOpenChange(!1), c.trigger?.focus(), m.preventDefault());
        })
      }
    ) }) }) });
  }
);
yX.displayName = vX;
function bX(e) {
  return e ? "open" : "closed";
}
function X2(e) {
  return e === "indeterminate";
}
function BP(e) {
  return X2(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function tze(e) {
  const t = document.activeElement;
  for (const n of e)
    if (n === t || (n.focus(), document.activeElement !== t)) return;
}
function nze(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
function rze(e, t, n) {
  const r = t.length > 1 && Array.from(t).every((c) => c === t[0]) ? t[0] : t, a = n ? e.indexOf(n) : -1;
  let s = nze(e, Math.max(a, 0));
  r.length === 1 && (s = s.filter((c) => c !== n));
  const l = s.find(
    (c) => c.toLowerCase().startsWith(r.toLowerCase())
  );
  return l !== n ? l : void 0;
}
function oze(e, t) {
  const { x: n, y: r } = e;
  let a = !1;
  for (let s = 0, l = t.length - 1; s < t.length; l = s++) {
    const c = t[s], d = t[l], f = c.x, m = c.y, h = d.x, v = d.y;
    m > r != v > r && n < (h - f) * (r - m) / (v - m) + f && (a = !a);
  }
  return a;
}
function aze(e, t) {
  if (!t) return !1;
  const n = { x: e.clientX, y: e.clientY };
  return oze(n, t);
}
function DS(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
var ize = eX, sze = IP, lze = nX, uze = TP, cze = rX, dze = VC, fze = aX, pze = sX, mze = uX, hze = dX, gze = fX, vze = pX, yze = hX, bze = gX, wze = yX, HC = "DropdownMenu", [xze] = Kl(
  HC,
  [JY]
), Ma = JY(), [Sze, wX] = xze(HC), xX = (e) => {
  const {
    __scopeDropdownMenu: t,
    children: n,
    dir: r,
    open: a,
    defaultOpen: s,
    onOpenChange: l,
    modal: c = !0
  } = e, d = Ma(t), f = M.useRef(null), [m, h] = Bd({
    prop: a,
    defaultProp: s ?? !1,
    onChange: l,
    caller: HC
  });
  return /* @__PURE__ */ C.jsx(
    Sze,
    {
      scope: t,
      triggerId: Fl(),
      triggerRef: f,
      contentId: Fl(),
      open: m,
      onOpenChange: h,
      onOpenToggle: M.useCallback(() => h((v) => !v), [h]),
      modal: c,
      children: /* @__PURE__ */ C.jsx(ize, { ...d, open: m, onOpenChange: h, dir: r, modal: c, children: n })
    }
  );
};
xX.displayName = HC;
var SX = "DropdownMenuTrigger", kX = M.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...a } = e, s = wX(SX, n), l = Ma(n);
    return /* @__PURE__ */ C.jsx(sze, { asChild: !0, ...l, children: /* @__PURE__ */ C.jsx(
      Qt.button,
      {
        type: "button",
        id: s.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": s.open,
        "aria-controls": s.open ? s.contentId : void 0,
        "data-state": s.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...a,
        ref: ME(t, s.triggerRef),
        onPointerDown: et(e.onPointerDown, (c) => {
          !r && c.button === 0 && c.ctrlKey === !1 && (s.onOpenToggle(), s.open || c.preventDefault());
        }),
        onKeyDown: et(e.onKeyDown, (c) => {
          r || (["Enter", " "].includes(c.key) && s.onOpenToggle(), c.key === "ArrowDown" && s.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(c.key) && c.preventDefault());
        })
      }
    ) });
  }
);
kX.displayName = SX;
var _X = "DropdownMenuContent", EX = M.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, a = wX(_X, n), s = Ma(n), l = M.useRef(!1);
    return /* @__PURE__ */ C.jsx(
      lze,
      {
        id: a.contentId,
        "aria-labelledby": a.triggerId,
        ...s,
        ...r,
        ref: t,
        onCloseAutoFocus: et(e.onCloseAutoFocus, (c) => {
          l.current || a.triggerRef.current?.focus(), l.current = !1, c.preventDefault();
        }),
        onInteractOutside: et(e.onInteractOutside, (c) => {
          const d = c.detail.originalEvent, f = d.button === 0 && d.ctrlKey === !0, m = d.button === 2 || f;
          (!a.modal || m) && (l.current = !0);
        }),
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
EX.displayName = _X;
var kze = "DropdownMenuGroup", CX = M.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, a = Ma(n);
    return /* @__PURE__ */ C.jsx(uze, { ...a, ...r, ref: t });
  }
);
CX.displayName = kze;
var _ze = "DropdownMenuLabel", Eze = M.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, a = Ma(n);
    return /* @__PURE__ */ C.jsx(cze, { ...a, ...r, ref: t });
  }
);
Eze.displayName = _ze;
var Cze = "DropdownMenuItem", OX = M.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, a = Ma(n);
    return /* @__PURE__ */ C.jsx(dze, { ...a, ...r, ref: t });
  }
);
OX.displayName = Cze;
var Oze = "DropdownMenuCheckboxItem", Mze = M.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, a = Ma(n);
  return /* @__PURE__ */ C.jsx(fze, { ...a, ...r, ref: t });
});
Mze.displayName = Oze;
var Nze = "DropdownMenuRadioGroup", MX = M.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, a = Ma(n);
  return /* @__PURE__ */ C.jsx(pze, { ...a, ...r, ref: t });
});
MX.displayName = Nze;
var Aze = "DropdownMenuRadioItem", NX = M.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, a = Ma(n);
  return /* @__PURE__ */ C.jsx(mze, { ...a, ...r, ref: t });
});
NX.displayName = Aze;
var Rze = "DropdownMenuItemIndicator", jze = M.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, a = Ma(n);
  return /* @__PURE__ */ C.jsx(hze, { ...a, ...r, ref: t });
});
jze.displayName = Rze;
var Pze = "DropdownMenuSeparator", Dze = M.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, a = Ma(n);
  return /* @__PURE__ */ C.jsx(gze, { ...a, ...r, ref: t });
});
Dze.displayName = Pze;
var Ize = "DropdownMenuArrow", $ze = M.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, a = Ma(n);
    return /* @__PURE__ */ C.jsx(vze, { ...a, ...r, ref: t });
  }
);
$ze.displayName = Ize;
var zze = (e) => {
  const { __scopeDropdownMenu: t, children: n, open: r, onOpenChange: a, defaultOpen: s } = e, l = Ma(t), [c, d] = Bd({
    prop: r,
    defaultProp: s ?? !1,
    onChange: a,
    caller: "DropdownMenuSub"
  });
  return /* @__PURE__ */ C.jsx(yze, { ...l, open: c, onOpenChange: d, children: n });
}, Tze = "DropdownMenuSubTrigger", AX = M.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, a = Ma(n);
  return /* @__PURE__ */ C.jsx(bze, { ...a, ...r, ref: t });
});
AX.displayName = Tze;
var Lze = "DropdownMenuSubContent", RX = M.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, a = Ma(n);
  return /* @__PURE__ */ C.jsx(
    wze,
    {
      ...a,
      ...r,
      ref: t,
      style: {
        ...e.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
RX.displayName = Lze;
var UP = xX, VP = kX, HP = EX, WP = CX, Mc = OX, Fze = MX, Bze = NX, Uze = zze, Vze = AX, Hze = RX;
const Wze = ({
  trigger: e,
  setOpen: t,
  open: n
}) => {
  const [r, a] = M.useState(""), [s, l] = M.useState(!0), c = Sn();
  return c.options.useWorkerManager ? /* @__PURE__ */ C.jsxs(
    Yl,
    {
      setOpen: t,
      open: n,
      trigger: e,
      title: "New Worker",
      description: "Create a new worker",
      children: [
        /* @__PURE__ */ C.jsxs("div", { children: [
          "Name:",
          /* @__PURE__ */ C.jsx("br", {}),
          /* @__PURE__ */ C.jsx(
            "input",
            {
              className: "styledinput",
              onChange: (d) => {
                a(d.currentTarget.value);
              },
              value: r
            }
          ),
          /* @__PURE__ */ C.jsxs("div", { style: { marginTop: 8 }, children: [
            /* @__PURE__ */ C.jsx(
              "input",
              {
                type: "checkbox",
                id: "inVenvCheckbox",
                checked: s,
                onChange: (d) => l(d.currentTarget.checked)
              }
            ),
            /* @__PURE__ */ C.jsx("label", { htmlFor: "inVenvCheckbox", style: { marginLeft: 4 }, children: "Create in new virtual environment" })
          ] })
        ] }),
        /* @__PURE__ */ C.jsx("div", { children: r && /* @__PURE__ */ C.jsx("div", { children: /* @__PURE__ */ C.jsx(
          "button",
          {
            className: "styledbtn",
            onClick: () => {
              c.workermanager?.new_worker({
                name: r,
                in_venv: s
                // reference: reference.uuid,
                // copyLib,
                // copyNS,
              }), t(!1);
            },
            children: "Create"
          }
        ) }) })
      ]
    }
  ) : null;
}, qze = ({
  trigger: e,
  setOpen: t,
  open: n
}) => {
  const r = Sn(), [a, s] = M.useState(!1), l = r.workers(), c = r.worker?.uuid, d = (c ? l[c]?.name : void 0) || c || "worker", f = async () => {
    if (!r.worker) return;
    const m = await r.worker.export({ withFiles: a });
    TZ(m, d + ".fnw", "application/zip"), t(!1);
  };
  return /* @__PURE__ */ C.jsx(
    Yl,
    {
      setOpen: t,
      open: n,
      trigger: e,
      title: "Export Worker",
      description: "Export the worker as a .fnw file",
      children: /* @__PURE__ */ C.jsxs("div", { children: [
        /* @__PURE__ */ C.jsxs("div", { children: [
          /* @__PURE__ */ C.jsx(
            "input",
            {
              type: "checkbox",
              className: "styledcheckbox",
              checked: a,
              onChange: (m) => {
                s(m.currentTarget.checked);
              }
            }
          ),
          "Include Files"
        ] }),
        /* @__PURE__ */ C.jsx("button", { className: "styledbtn", onClick: f, children: "Export" })
      ] })
    }
  );
}, Gze = () => {
  const e = Sn(), t = e.workers(), [n, r] = M.useState(!1), [a, s] = M.useState(!1), l = (v) => {
    v !== "__select__" && e.workers && e.workermanager && t[v] && (!t[v].active && !window.confirm(
      "this is an inactive worker, selecting it will start it, continue?"
    ) || e.workermanager.set_active(v));
  }, c = async () => {
    if (!e.worker || !window.confirm(
      "Updateing the worker might replace the current nodespace, continue?"
    )) return;
    const v = await BZ(".fnw");
    e.worker.update_from_export(v);
  }, d = e.options.useWorkerManager && e.workermanager && e.workermanager.open || jS(), f = d && Object.keys(t).length > 0, m = e.worker && e.worker.is_open, h = m && d;
  return d || m ? /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
    /* @__PURE__ */ C.jsxs(UP, { children: [
      /* @__PURE__ */ C.jsx(VP, { asChild: !0, children: /* @__PURE__ */ C.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ C.jsxs(kd, { direction: "row", children: [
        "Worker ",
        /* @__PURE__ */ C.jsx(M4, { className: "m-x-s" })
      ] }) }) }),
      /* @__PURE__ */ C.jsx(HP, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ C.jsxs(WP, { children: [
        f && /* @__PURE__ */ C.jsxs(Uze, { children: [
          /* @__PURE__ */ C.jsx(Vze, { className: "headermenuitem submenuitem", children: /* @__PURE__ */ C.jsxs(kd, { direction: "row", children: [
            "Select",
            /* @__PURE__ */ C.jsx(aS, {})
          ] }) }),
          /* @__PURE__ */ C.jsx(
            Hze,
            {
              className: "headermenucontent funcnodescontainer",
              sideOffset: 2,
              alignOffset: -5,
              children: /* @__PURE__ */ C.jsx(
                Fze,
                {
                  value: e.worker?.uuid,
                  onValueChange: (v) => {
                    l(v);
                  },
                  children: Object.keys(t).sort((v, g) => {
                    if (t[v].active && !t[g].active)
                      return -1;
                    if (!t[v].active && t[g].active)
                      return 1;
                    const b = t[v].name || v, x = t[g].name || g;
                    return b.localeCompare(x);
                  }).map((v) => /* @__PURE__ */ C.jsx(
                    Bze,
                    {
                      className: "headermenuitem workerselectoption" + (t[v]?.active ? " active" : " inactive") + " headermenuitem",
                      value: v,
                      disabled: v === e.worker?.uuid,
                      children: t[v]?.name || v
                    },
                    v
                  ))
                }
              )
            }
          )
        ] }),
        m && /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
          h && /* @__PURE__ */ C.jsx(
            Mc,
            {
              className: "headermenuitem",
              onClick: () => {
                if (e.worker) {
                  if (!e.workermanager)
                    return e.logger.error("no workermanager");
                  e.workermanager?.restart_worker(
                    e.worker.uuid
                  );
                }
              },
              children: "Restart"
            }
          ),
          /* @__PURE__ */ C.jsx(
            Mc,
            {
              className: "headermenuitem",
              onClick: () => {
                e.worker && e.worker.stop();
              },
              children: "Stop"
            }
          ),
          /* @__PURE__ */ C.jsx(
            Mc,
            {
              className: "headermenuitem",
              onClick: () => s(!0),
              children: "Export"
            }
          ),
          /* @__PURE__ */ C.jsx(
            Mc,
            {
              className: "headermenuitem",
              onClick: c,
              children: "Update"
            }
          )
        ] }),
        d && /* @__PURE__ */ C.jsx(C.Fragment, { children: /* @__PURE__ */ C.jsx(
          Mc,
          {
            className: "headermenuitem",
            onClick: () => r(!0),
            children: "New"
          }
        ) })
      ] }) })
    ] }),
    /* @__PURE__ */ C.jsx(
      Wze,
      {
        open: n,
        setOpen: r
      }
    ),
    /* @__PURE__ */ C.jsx(
      qze,
      {
        open: a,
        setOpen: s
      }
    )
  ] }) : null;
}, Kze = () => {
  const e = Sn(), t = () => {
    window.confirm("Are you sure you want to start a new flow?") && e.worker?.clear();
  }, n = async () => {
    const a = await e.worker?.save();
    if (!a) return;
    const s = new Blob([JSON.stringify(a)], {
      type: "application/json"
    }), l = URL.createObjectURL(s), c = document.createElement("a");
    c.href = l, c.download = "flow.json", c.click(), URL.revokeObjectURL(l), c.remove();
  }, r = async () => {
    const a = document.createElement("input");
    a.type = "file", a.accept = ".json", a.onchange = async (s) => {
      const l = s.target.files?.[0];
      if (!l) return;
      const c = new FileReader();
      c.onload = async (d) => {
        const f = d.target?.result;
        if (!f) return;
        const m = JSON.parse(f);
        await e.worker?.load(m);
      }, c.readAsText(l);
    }, a.click();
  };
  return /* @__PURE__ */ C.jsx(C.Fragment, { children: /* @__PURE__ */ C.jsxs(UP, { children: [
    /* @__PURE__ */ C.jsx(VP, { asChild: !0, children: /* @__PURE__ */ C.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ C.jsxs(kd, { direction: "row", children: [
      "Nodespace ",
      /* @__PURE__ */ C.jsx(M4, { className: "m-x-s" })
    ] }) }) }),
    /* @__PURE__ */ C.jsx(HP, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ C.jsxs(WP, { children: [
      /* @__PURE__ */ C.jsx(Mc, { className: "headermenuitem", onClick: t, children: "New" }),
      /* @__PURE__ */ C.jsx(Mc, { className: "headermenuitem", onClick: n, children: "Save" }),
      /* @__PURE__ */ C.jsx(Mc, { className: "headermenuitem", onClick: r, children: "Load" })
    ] }) })
  ] }) });
}, Yze = ({ theme: e, selected: t }) => /* @__PURE__ */ C.jsxs(
  "div",
  {
    style: {
      width: 80,
      height: 54,
      borderRadius: "var(--fn-border-radius-s, 8px)",
      border: t ? "2.5px solid #1976d2" : "1.5px solid #bbb",
      boxShadow: t ? "0 0 0 2px #1976d2" : "0 1px 4px #0002",
      background: "var(--fn-app-background)",
      display: "flex",
      flexDirection: "column",
      alignItems: "stretch",
      justifyContent: "flex-start",
      position: "relative",
      overflow: "hidden",
      transition: "border 0.2s, box-shadow 0.2s"
    },
    "fn-data-color-theme": e,
    children: [
      /* @__PURE__ */ C.jsx(
        "div",
        {
          style: {
            height: 10,
            background: "var(--fn-primary-color)",
            borderBottom: "1px solid var(--fn-neutral-element-border)"
          }
        }
      ),
      /* @__PURE__ */ C.jsxs("div", { style: { display: "flex", flex: 1 }, children: [
        /* @__PURE__ */ C.jsx(
          "div",
          {
            style: {
              width: 12,
              background: "var(--fn-surface-elevation-low, var(--fn-container-background))",
              borderRight: "1px solid var(--fn-neutral-element-border)"
            }
          }
        ),
        /* @__PURE__ */ C.jsx(
          "div",
          {
            style: {
              flex: 1,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              background: "var(--fn-container-background)"
            },
            children: /* @__PURE__ */ C.jsxs(
              "div",
              {
                style: {
                  width: 22,
                  height: 14,
                  borderRadius: "var(--fn-border-radius-xs, 4px)",
                  background: "var(--fn-node-background)",
                  border: "1px solid var(--fn-node-header-color)",
                  boxShadow: "0 1px 2px #0002",
                  display: "flex",
                  flexDirection: "column"
                },
                children: [
                  /* @__PURE__ */ C.jsx(
                    "div",
                    {
                      style: {
                        height: 5,
                        background: "var(--fn-node-header-color)",
                        borderTopLeftRadius: "var(--fn-border-radius-xs, 4px)",
                        borderTopRightRadius: "var(--fn-border-radius-xs, 4px)"
                      }
                    }
                  ),
                  /* @__PURE__ */ C.jsx(
                    "div",
                    {
                      style: {
                        flex: 1,
                        background: "transparent"
                      }
                    }
                  )
                ]
              }
            )
          }
        )
      ] }),
      /* @__PURE__ */ C.jsx(
        "span",
        {
          style: {
            position: "absolute",
            bottom: 2,
            right: 4,
            fontSize: 9,
            color: "var(--fn-text-color-neutral)",
            opacity: 0.7,
            textTransform: "capitalize",
            fontWeight: 600,
            pointerEvents: "none"
          },
          children: e
        }
      ),
      t && /* @__PURE__ */ C.jsx(
        "span",
        {
          style: {
            position: "absolute",
            top: 2,
            left: 6,
            fontSize: 14,
            color: "#1976d2",
            fontWeight: 900,
            pointerEvents: "none"
          },
          "aria-label": "Selected",
          children: ""
        }
      )
    ]
  }
), Xze = () => {
  const { colorTheme: e, setColorTheme: t } = AU(), [n, r] = M.useState(null), [a, s] = M.useState(null), l = (d) => {
    d !== e && (s(e), t(d), r(d));
  }, c = (d) => {
    n === d && a && a !== d && t(a), r(null), s(null);
  };
  return /* @__PURE__ */ C.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "1em" }, children: [
    /* @__PURE__ */ C.jsx("div", { style: { marginBottom: 8, fontWeight: 500 }, children: "Theme:" }),
    /* @__PURE__ */ C.jsx("div", { style: {
      display: "grid",
      gridTemplateColumns: "repeat(auto-fill, minmax(80px, 1fr))",
      gap: 16,
      justifyItems: "center"
    }, children: HH.map((d) => /* @__PURE__ */ C.jsx(
      "button",
      {
        onClick: () => {
          t(d), r(null), s(null);
        },
        onMouseEnter: () => l(d),
        onMouseLeave: () => c(d),
        style: {
          background: "none",
          border: "none",
          padding: 0,
          cursor: "pointer",
          outline: "none",
          borderRadius: 8
        },
        "aria-label": `Select ${d} theme`,
        children: /* @__PURE__ */ C.jsx(
          Yze,
          {
            theme: d,
            selected: e === d
          }
        )
      },
      d
    )) })
  ] });
}, Jze = () => {
  const [e, t] = M.useState(!1), n = () => {
    t(!0);
  };
  return /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
    /* @__PURE__ */ C.jsxs(UP, { children: [
      /* @__PURE__ */ C.jsx(VP, { asChild: !0, children: /* @__PURE__ */ C.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ C.jsxs(kd, { direction: "row", children: [
        "Settings ",
        /* @__PURE__ */ C.jsx(M4, { className: "m-x-s" })
      ] }) }) }),
      /* @__PURE__ */ C.jsx(HP, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ C.jsx(WP, { children: /* @__PURE__ */ C.jsx(
        Mc,
        {
          className: "headermenuitem",
          onClick: n,
          children: "Appearance"
        }
      ) }) })
    ] }),
    /* @__PURE__ */ C.jsx(
      Yl,
      {
        open: e,
        setOpen: t,
        title: "Appearance",
        description: "Change the color theme.",
        closebutton: !0,
        children: /* @__PURE__ */ C.jsx(Xze, {})
      }
    )
  ] });
}, Qze = ({
  ...e
}) => {
  const t = Sn(), n = t.workerstate();
  return Object.keys(e).length > 0 && t.logger.debug("headerprops", e), /* @__PURE__ */ C.jsxs(kd, { className: "funcnodesreactflowheader", direction: "row", wrap: !0, children: [
    /* @__PURE__ */ C.jsx(
      kd,
      {
        className: "headerelement m-w-6",
        grow: {
          "": !0,
          m: !1
        },
        children: /* @__PURE__ */ C.jsx(j6e, {})
      }
    ),
    (e.showmenu || jS()) && /* @__PURE__ */ C.jsxs(kd, { direction: "row", wrap: !0, children: [
      /* @__PURE__ */ C.jsx("div", { className: "headerelement", children: /* @__PURE__ */ C.jsx(Gze, {}) }),
      (t.worker && n.is_open || jS()) && /* @__PURE__ */ C.jsx("div", { className: "headerelement", children: /* @__PURE__ */ C.jsx(Kze, {}) }),
      /* @__PURE__ */ C.jsx("div", { className: "headerelement", children: /* @__PURE__ */ C.jsx(Jze, {}) })
    ] })
  ] });
}, jX = ({ item: e }) => {
  const { node: t } = Oa(), n = M.useCallback(() => {
    t?.add_node(e.node_id);
  }, [e.node_id, t]), r = M.useCallback(
    (a) => {
      a.detail === 2 && n();
    },
    [n]
  );
  return /* @__PURE__ */ C.jsx("div", { className: "libnodeentry", onClick: r, title: e.description, children: e.node_name || e.node_id });
}, PX = (e, t) => {
  const n = e.nodes?.some(
    (a) => a.node_id.toLowerCase().includes(t.toLowerCase())
  ) ?? !1, r = e.subshelves?.some((a) => PX(a, t)) ?? !1;
  return n || r;
}, qP = ({
  item: e,
  filter: t,
  parentkey: n
}) => {
  const [r, a] = M.useState(!1), s = () => a(!r), l = e.nodes?.filter(
    (d) => d.node_id.toLowerCase().includes(t.toLowerCase())
  ), c = r || t.length > 0;
  return PX(e, t) ? /* @__PURE__ */ C.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ C.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: s,
        style: { cursor: "pointer" },
        title: e.description,
        children: [
          /* @__PURE__ */ C.jsx("div", { className: "shelftitle_text", children: e.name }),
          /* @__PURE__ */ C.jsx("div", { className: "expandicon " + (c ? "open" : "close"), children: /* @__PURE__ */ C.jsx(nk, {}) })
        ]
      }
    ),
    /* @__PURE__ */ C.jsx("div", { className: "libnodecontainer " + (c ? "open" : "close"), children: /* @__PURE__ */ C.jsxs("div", { className: "libnodecontainer_inner", children: [
      l && /* @__PURE__ */ C.jsx(C.Fragment, { children: l.map((d) => /* @__PURE__ */ C.jsx(jX, { item: d }, d.node_id)) }),
      e.subshelves && /* @__PURE__ */ C.jsx(C.Fragment, { children: e.subshelves.map((d) => /* @__PURE__ */ C.jsx(
        qP,
        {
          item: d,
          filter: t,
          parentkey: n + d.name
        },
        n + d.name
      )) })
    ] }) }),
    /* @__PURE__ */ C.jsx("hr", {})
  ] }) : /* @__PURE__ */ C.jsx(C.Fragment, {});
}, Zze = ({
  filter: e,
  setFilter: t
}) => /* @__PURE__ */ C.jsxs("div", { className: "libfilter", children: [
  /* @__PURE__ */ C.jsx(wce, { fontSize: "inherit" }),
  /* @__PURE__ */ C.jsx(
    "input",
    {
      type: "text",
      placeholder: "Filter",
      value: e,
      onChange: (n) => {
        t(n.target.value);
      }
    }
  ),
  e && /* @__PURE__ */ C.jsx(
    LE,
    {
      fontSize: "inherit",
      onClick: () => {
        t("");
      }
    }
  )
] }), eTe = ({
  children: e
}) => {
  const [t, n] = M.useState(""), r = Sn(), [a, s] = M.useState(!0), [l, c] = M.useState(!0), [d, f] = M.useState(!0), [m, h] = M.useState({
    installed: [],
    available: [],
    active: []
  }), [v, g] = M.useState(!1), { lib: b } = Oa(), x = (D) => {
    D && (r.worker === void 0 || !r.worker.is_open || b?.get_available_modules({
      on_load: (I) => {
        h(I);
      }
    }).then((I) => {
      h(I);
    }));
  };
  if (!r.worker)
    return /* @__PURE__ */ C.jsx(C.Fragment, {});
  const w = M.useCallback(
    (D, I) => {
      g(!1), b?.add_lib(D.name, I);
    },
    [b]
  ), k = M.useCallback(
    (D, I) => {
      g(!1), b?.add_lib(D.name, I);
    },
    [b]
  ), E = M.useCallback(
    (D) => {
      g(!1), b?.remove_lib(D.name);
    },
    [b]
  ), _ = M.useCallback(
    (D, I) => {
      g(!1), b?.add_lib(D.name, I);
    },
    [b]
  ), O = M.useCallback(
    (D) => D.filter(
      (I) => I.name.toLowerCase().includes(t.toLowerCase()) || I.description.toLowerCase().includes(t.toLowerCase())
    ),
    [t]
  ), N = O(m.available), A = O(m.installed), R = O(m.active);
  return /* @__PURE__ */ C.jsxs(
    Yl,
    {
      title: "Manage Library",
      trigger: e,
      description: "Add or remove libraries to the current worker.",
      onOpenChange: x,
      open: v,
      setOpen: g,
      children: [
        /* @__PURE__ */ C.jsx(
          "input",
          {
            className: "filter-input styledinput",
            type: "text",
            placeholder: "Filter modules...",
            value: t,
            onChange: (D) => n(D.target.value)
          }
        ),
        /* @__PURE__ */ C.jsxs(
          "div",
          {
            className: "packagelist",
            style: { maxHeight: "70%", overflow: "auto" },
            children: [
              A.length > 0 && /* @__PURE__ */ C.jsx(
                "h3",
                {
                  onClick: () => {
                    f(!d);
                  },
                  children: "Installed"
                }
              ),
              d && A.map((D) => /* @__PURE__ */ C.jsx(
                CBe,
                {
                  availableModule: D,
                  on_add: w
                },
                D.name + D.source
              )),
              N.length > 0 && /* @__PURE__ */ C.jsx(
                "h3",
                {
                  onClick: () => {
                    c(!l);
                  },
                  children: "Available"
                }
              ),
              l && N.map((D) => /* @__PURE__ */ C.jsx(
                OBe,
                {
                  availableModule: D,
                  on_add: k
                },
                D.name + D.source
              )),
              R.length > 0 && /* @__PURE__ */ C.jsx(
                "h3",
                {
                  onClick: () => {
                    s(!a);
                  },
                  children: "Active"
                }
              ),
              a && R.map((D) => /* @__PURE__ */ C.jsx(
                EBe,
                {
                  availableModule: D,
                  on_remove: E,
                  on_update: _
                },
                D.name + D.source
              ))
            ]
          }
        )
      ]
    }
  );
}, GP = ({
  availableModule: e
}) => /* @__PURE__ */ C.jsxs("div", { className: "module-links", children: [
  e.homepage && /* @__PURE__ */ C.jsx(C.Fragment, { children: /* @__PURE__ */ C.jsx(
    "a",
    {
      href: e.homepage,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Homepage"
    }
  ) }),
  e.source && e.homepage && " | ",
  e.source && /* @__PURE__ */ C.jsx(C.Fragment, { children: /* @__PURE__ */ C.jsx(
    "a",
    {
      href: e.source,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Source"
    }
  ) })
] });
function tTe(e, t) {
  const n = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const nTe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, rTe = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, oTe = {};
function $9(e, t) {
  return (oTe.jsx ? rTe : nTe).test(e);
}
const aTe = /[ \t\n\f\r]/g;
function iTe(e) {
  return typeof e == "object" ? e.type === "text" ? z9(e.value) : !1 : z9(e);
}
function z9(e) {
  return e.replace(aTe, "") === "";
}
class Pk {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, n, r) {
    this.normal = n, this.property = t, r && (this.space = r);
  }
}
Pk.prototype.normal = {};
Pk.prototype.property = {};
Pk.prototype.space = void 0;
function DX(e, t) {
  const n = {}, r = {};
  for (const a of e)
    Object.assign(n, a.property), Object.assign(r, a.normal);
  return new Pk(n, r, t);
}
function sR(e) {
  return e.toLowerCase();
}
class za {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(t, n) {
    this.attribute = n, this.property = t;
  }
}
za.prototype.attribute = "";
za.prototype.booleanish = !1;
za.prototype.boolean = !1;
za.prototype.commaOrSpaceSeparated = !1;
za.prototype.commaSeparated = !1;
za.prototype.defined = !1;
za.prototype.mustUseProperty = !1;
za.prototype.number = !1;
za.prototype.overloadedBoolean = !1;
za.prototype.property = "";
za.prototype.spaceSeparated = !1;
za.prototype.space = void 0;
let sTe = 0;
const Lt = ch(), Dr = ch(), lR = ch(), Pe = ch(), Zn = ch(), ug = ch(), bi = ch();
function ch() {
  return 2 ** ++sTe;
}
const uR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Lt,
  booleanish: Dr,
  commaOrSpaceSeparated: bi,
  commaSeparated: ug,
  number: Pe,
  overloadedBoolean: lR,
  spaceSeparated: Zn
}, Symbol.toStringTag, { value: "Module" })), G5 = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(uR)
);
class KP extends za {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(t, n, r, a) {
    let s = -1;
    if (super(t, n), T9(this, "space", a), typeof r == "number")
      for (; ++s < G5.length; ) {
        const l = G5[s];
        T9(this, G5[s], (r & uR[l]) === uR[l]);
      }
  }
}
KP.prototype.defined = !0;
function T9(e, t, n) {
  n && (e[t] = n);
}
function Yg(e) {
  const t = {}, n = {};
  for (const [r, a] of Object.entries(e.properties)) {
    const s = new KP(
      r,
      e.transform(e.attributes || {}, r),
      a,
      e.space
    );
    e.mustUseProperty && e.mustUseProperty.includes(r) && (s.mustUseProperty = !0), t[r] = s, n[sR(r)] = r, n[sR(s.attribute)] = r;
  }
  return new Pk(t, n, e.space);
}
const IX = Yg({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: Dr,
    ariaAutoComplete: null,
    ariaBusy: Dr,
    ariaChecked: Dr,
    ariaColCount: Pe,
    ariaColIndex: Pe,
    ariaColSpan: Pe,
    ariaControls: Zn,
    ariaCurrent: null,
    ariaDescribedBy: Zn,
    ariaDetails: null,
    ariaDisabled: Dr,
    ariaDropEffect: Zn,
    ariaErrorMessage: null,
    ariaExpanded: Dr,
    ariaFlowTo: Zn,
    ariaGrabbed: Dr,
    ariaHasPopup: null,
    ariaHidden: Dr,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Zn,
    ariaLevel: Pe,
    ariaLive: null,
    ariaModal: Dr,
    ariaMultiLine: Dr,
    ariaMultiSelectable: Dr,
    ariaOrientation: null,
    ariaOwns: Zn,
    ariaPlaceholder: null,
    ariaPosInSet: Pe,
    ariaPressed: Dr,
    ariaReadOnly: Dr,
    ariaRelevant: null,
    ariaRequired: Dr,
    ariaRoleDescription: Zn,
    ariaRowCount: Pe,
    ariaRowIndex: Pe,
    ariaRowSpan: Pe,
    ariaSelected: Dr,
    ariaSetSize: Pe,
    ariaSort: null,
    ariaValueMax: Pe,
    ariaValueMin: Pe,
    ariaValueNow: Pe,
    ariaValueText: null,
    role: null
  },
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  }
});
function $X(e, t) {
  return t in e ? e[t] : t;
}
function zX(e, t) {
  return $X(e, t.toLowerCase());
}
const lTe = Yg({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: ug,
    acceptCharset: Zn,
    accessKey: Zn,
    action: null,
    allow: null,
    allowFullScreen: Lt,
    allowPaymentRequest: Lt,
    allowUserMedia: Lt,
    alt: null,
    as: null,
    async: Lt,
    autoCapitalize: null,
    autoComplete: Zn,
    autoFocus: Lt,
    autoPlay: Lt,
    blocking: Zn,
    capture: null,
    charSet: null,
    checked: Lt,
    cite: null,
    className: Zn,
    cols: Pe,
    colSpan: null,
    content: null,
    contentEditable: Dr,
    controls: Lt,
    controlsList: Zn,
    coords: Pe | ug,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Lt,
    defer: Lt,
    dir: null,
    dirName: null,
    disabled: Lt,
    download: lR,
    draggable: Dr,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Lt,
    formTarget: null,
    headers: Zn,
    height: Pe,
    hidden: lR,
    high: Pe,
    href: null,
    hrefLang: null,
    htmlFor: Zn,
    httpEquiv: Zn,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Lt,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Lt,
    itemId: null,
    itemProp: Zn,
    itemRef: Zn,
    itemScope: Lt,
    itemType: Zn,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Lt,
    low: Pe,
    manifest: null,
    max: null,
    maxLength: Pe,
    media: null,
    method: null,
    min: null,
    minLength: Pe,
    multiple: Lt,
    muted: Lt,
    name: null,
    nonce: null,
    noModule: Lt,
    noValidate: Lt,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Lt,
    optimum: Pe,
    pattern: null,
    ping: Zn,
    placeholder: null,
    playsInline: Lt,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Lt,
    referrerPolicy: null,
    rel: Zn,
    required: Lt,
    reversed: Lt,
    rows: Pe,
    rowSpan: Pe,
    sandbox: Zn,
    scope: null,
    scoped: Lt,
    seamless: Lt,
    selected: Lt,
    shadowRootClonable: Lt,
    shadowRootDelegatesFocus: Lt,
    shadowRootMode: null,
    shape: null,
    size: Pe,
    sizes: null,
    slot: null,
    span: Pe,
    spellCheck: Dr,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: Pe,
    step: null,
    style: null,
    tabIndex: Pe,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Lt,
    useMap: null,
    value: Dr,
    width: Pe,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Zn,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: Pe,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: Pe,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Lt,
    // Lists. Use CSS to reduce space between items instead
    declare: Lt,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: Pe,
    // `<img>` and `<object>`
    leftMargin: Pe,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: Pe,
    // `<body>`
    marginWidth: Pe,
    // `<body>`
    noResize: Lt,
    // `<frame>`
    noHref: Lt,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Lt,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Lt,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: Pe,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: Dr,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: Pe,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: Pe,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Lt,
    disableRemotePlayback: Lt,
    prefix: null,
    property: null,
    results: Pe,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: zX
}), uTe = Yg({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: bi,
    accentHeight: Pe,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: Pe,
    amplitude: Pe,
    arabicForm: null,
    ascent: Pe,
    attributeName: null,
    attributeType: null,
    azimuth: Pe,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: Pe,
    by: null,
    calcMode: null,
    capHeight: Pe,
    className: Zn,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: Pe,
    diffuseConstant: Pe,
    direction: null,
    display: null,
    dur: null,
    divisor: Pe,
    dominantBaseline: null,
    download: Lt,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: Pe,
    enableBackground: null,
    end: null,
    event: null,
    exponent: Pe,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: Pe,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: ug,
    g2: ug,
    glyphName: ug,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: Pe,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: Pe,
    horizOriginX: Pe,
    horizOriginY: Pe,
    id: null,
    ideographic: Pe,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: Pe,
    k: Pe,
    k1: Pe,
    k2: Pe,
    k3: Pe,
    k4: Pe,
    kernelMatrix: bi,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: Pe,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: Pe,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: Pe,
    overlineThickness: Pe,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: Pe,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Zn,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: Pe,
    pointsAtY: Pe,
    pointsAtZ: Pe,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: bi,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: bi,
    rev: bi,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: bi,
    requiredFeatures: bi,
    requiredFonts: bi,
    requiredFormats: bi,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: Pe,
    specularExponent: Pe,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: Pe,
    strikethroughThickness: Pe,
    string: null,
    stroke: null,
    strokeDashArray: bi,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: Pe,
    strokeOpacity: Pe,
    strokeWidth: null,
    style: null,
    surfaceScale: Pe,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: bi,
    tabIndex: Pe,
    tableValues: null,
    target: null,
    targetX: Pe,
    targetY: Pe,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: bi,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: Pe,
    underlineThickness: Pe,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: Pe,
    values: null,
    vAlphabetic: Pe,
    vMathematical: Pe,
    vectorEffect: null,
    vHanging: Pe,
    vIdeographic: Pe,
    version: null,
    vertAdvY: Pe,
    vertOriginX: Pe,
    vertOriginY: Pe,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: Pe,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: $X
}), TX = Yg({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  }
}), LX = Yg({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: zX
}), FX = Yg({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  }
}), cTe = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, dTe = /[A-Z]/g, L9 = /-[a-z]/g, fTe = /^data[-\w.:]+$/i;
function pTe(e, t) {
  const n = sR(t);
  let r = t, a = za;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && fTe.test(t)) {
    if (t.charAt(4) === "-") {
      const s = t.slice(5).replace(L9, hTe);
      r = "data" + s.charAt(0).toUpperCase() + s.slice(1);
    } else {
      const s = t.slice(4);
      if (!L9.test(s)) {
        let l = s.replace(dTe, mTe);
        l.charAt(0) !== "-" && (l = "-" + l), t = "data" + l;
      }
    }
    a = KP;
  }
  return new a(r, t);
}
function mTe(e) {
  return "-" + e.toLowerCase();
}
function hTe(e) {
  return e.charAt(1).toUpperCase();
}
const gTe = DX([IX, lTe, TX, LX, FX], "html"), YP = DX([IX, uTe, TX, LX, FX], "svg");
function vTe(e) {
  return e.join(" ").trim();
}
var Rh = {}, K5, F9;
function yTe() {
  if (F9) return K5;
  F9 = 1;
  var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, n = /^\s*/, r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, a = /^:\s*/, s = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, l = /^[;\s]*/, c = /^\s+|\s+$/g, d = `
`, f = "/", m = "*", h = "", v = "comment", g = "declaration";
  K5 = function(x, w) {
    if (typeof x != "string")
      throw new TypeError("First argument must be a string");
    if (!x) return [];
    w = w || {};
    var k = 1, E = 1;
    function _(H) {
      var L = H.match(t);
      L && (k += L.length);
      var G = H.lastIndexOf(d);
      E = ~G ? H.length - G : E + H.length;
    }
    function O() {
      var H = { line: k, column: E };
      return function(L) {
        return L.position = new N(H), D(), L;
      };
    }
    function N(H) {
      this.start = H, this.end = { line: k, column: E }, this.source = w.source;
    }
    N.prototype.content = x;
    function A(H) {
      var L = new Error(
        w.source + ":" + k + ":" + E + ": " + H
      );
      if (L.reason = H, L.filename = w.source, L.line = k, L.column = E, L.source = x, !w.silent) throw L;
    }
    function R(H) {
      var L = H.exec(x);
      if (L) {
        var G = L[0];
        return _(G), x = x.slice(G.length), L;
      }
    }
    function D() {
      R(n);
    }
    function I(H) {
      var L;
      for (H = H || []; L = z(); )
        L !== !1 && H.push(L);
      return H;
    }
    function z() {
      var H = O();
      if (!(f != x.charAt(0) || m != x.charAt(1))) {
        for (var L = 2; h != x.charAt(L) && (m != x.charAt(L) || f != x.charAt(L + 1)); )
          ++L;
        if (L += 2, h === x.charAt(L - 1))
          return A("End of comment missing");
        var G = x.slice(2, L - 2);
        return E += 2, _(G), x = x.slice(L), E += 2, H({
          type: v,
          comment: G
        });
      }
    }
    function B() {
      var H = O(), L = R(r);
      if (L) {
        if (z(), !R(a)) return A("property missing ':'");
        var G = R(s), $ = H({
          type: g,
          property: b(L[0].replace(e, h)),
          value: G ? b(G[0].replace(e, h)) : h
        });
        return R(l), $;
      }
    }
    function P() {
      var H = [];
      I(H);
      for (var L; L = B(); )
        L !== !1 && (H.push(L), I(H));
      return H;
    }
    return D(), P();
  };
  function b(x) {
    return x ? x.replace(c, h) : h;
  }
  return K5;
}
var B9;
function bTe() {
  if (B9) return Rh;
  B9 = 1;
  var e = Rh && Rh.__importDefault || function(r) {
    return r && r.__esModule ? r : { default: r };
  };
  Object.defineProperty(Rh, "__esModule", { value: !0 }), Rh.default = n;
  var t = e(yTe());
  function n(r, a) {
    var s = null;
    if (!r || typeof r != "string")
      return s;
    var l = (0, t.default)(r), c = typeof a == "function";
    return l.forEach(function(d) {
      if (d.type === "declaration") {
        var f = d.property, m = d.value;
        c ? a(f, m, d) : m && (s = s || {}, s[f] = m);
      }
    }), s;
  }
  return Rh;
}
var ux = {}, U9;
function wTe() {
  if (U9) return ux;
  U9 = 1, Object.defineProperty(ux, "__esModule", { value: !0 }), ux.camelCase = void 0;
  var e = /^--[a-zA-Z0-9_-]+$/, t = /-([a-z])/g, n = /^[^-]+$/, r = /^-(webkit|moz|ms|o|khtml)-/, a = /^-(ms)-/, s = function(f) {
    return !f || n.test(f) || e.test(f);
  }, l = function(f, m) {
    return m.toUpperCase();
  }, c = function(f, m) {
    return "".concat(m, "-");
  }, d = function(f, m) {
    return m === void 0 && (m = {}), s(f) ? f : (f = f.toLowerCase(), m.reactCompat ? f = f.replace(a, c) : f = f.replace(r, c), f.replace(t, l));
  };
  return ux.camelCase = d, ux;
}
var cx, V9;
function xTe() {
  if (V9) return cx;
  V9 = 1;
  var e = cx && cx.__importDefault || function(a) {
    return a && a.__esModule ? a : { default: a };
  }, t = e(bTe()), n = wTe();
  function r(a, s) {
    var l = {};
    return !a || typeof a != "string" || (0, t.default)(a, function(c, d) {
      c && d && (l[(0, n.camelCase)(c, s)] = d);
    }), l;
  }
  return r.default = r, cx = r, cx;
}
var STe = xTe();
const kTe = /* @__PURE__ */ Gc(STe), BX = UX("end"), XP = UX("start");
function UX(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function _Te(e) {
  const t = XP(e), n = BX(e);
  if (t && n)
    return { start: t, end: n };
}
function qx(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? H9(e.position) : "start" in e || "end" in e ? H9(e) : "line" in e || "column" in e ? cR(e) : "";
}
function cR(e) {
  return W9(e && e.line) + ":" + W9(e && e.column);
}
function H9(e) {
  return cR(e && e.start) + "-" + cR(e && e.end);
}
function W9(e) {
  return e && typeof e == "number" ? e : 1;
}
class ta extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let a = "", s = {}, l = !1;
    if (n && ("line" in n && "column" in n ? s = { place: n } : "start" in n && "end" in n ? s = { place: n } : "type" in n ? s = {
      ancestors: [n],
      place: n.position
    } : s = { ...n }), typeof t == "string" ? a = t : !s.cause && t && (l = !0, a = t.message, s.cause = t), !s.ruleId && !s.source && typeof r == "string") {
      const d = r.indexOf(":");
      d === -1 ? s.ruleId = r : (s.source = r.slice(0, d), s.ruleId = r.slice(d + 1));
    }
    if (!s.place && s.ancestors && s.ancestors) {
      const d = s.ancestors[s.ancestors.length - 1];
      d && (s.place = d.position);
    }
    const c = s.place && "start" in s.place ? s.place.start : s.place;
    this.ancestors = s.ancestors || void 0, this.cause = s.cause || void 0, this.column = c ? c.column : void 0, this.fatal = void 0, this.file, this.message = a, this.line = c ? c.line : void 0, this.name = qx(s.place) || "1:1", this.place = s.place || void 0, this.reason = this.message, this.ruleId = s.ruleId || void 0, this.source = s.source || void 0, this.stack = l && s.cause && typeof s.cause.stack == "string" ? s.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
ta.prototype.file = "";
ta.prototype.name = "";
ta.prototype.reason = "";
ta.prototype.message = "";
ta.prototype.stack = "";
ta.prototype.column = void 0;
ta.prototype.line = void 0;
ta.prototype.ancestors = void 0;
ta.prototype.cause = void 0;
ta.prototype.fatal = void 0;
ta.prototype.place = void 0;
ta.prototype.ruleId = void 0;
ta.prototype.source = void 0;
const JP = {}.hasOwnProperty, ETe = /* @__PURE__ */ new Map(), CTe = /[A-Z]/g, OTe = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), MTe = /* @__PURE__ */ new Set(["td", "th"]), VX = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function NTe(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = zTe(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = $Te(n, t.jsx, t.jsxs);
  }
  const a = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? YP : gTe,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, s = HX(a, e, void 0);
  return s && typeof s != "string" ? s : a.create(
    e,
    a.Fragment,
    { children: s || void 0 },
    void 0
  );
}
function HX(e, t, n) {
  if (t.type === "element")
    return ATe(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return RTe(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return PTe(e, t, n);
  if (t.type === "mdxjsEsm")
    return jTe(e, t);
  if (t.type === "root")
    return DTe(e, t, n);
  if (t.type === "text")
    return ITe(e, t);
}
function ATe(e, t, n) {
  const r = e.schema;
  let a = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (a = YP, e.schema = a), e.ancestors.push(t);
  const s = qX(e, t.tagName, !1), l = TTe(e, t);
  let c = ZP(e, t);
  return OTe.has(t.tagName) && (c = c.filter(function(d) {
    return typeof d == "string" ? !iTe(d) : !0;
  })), WX(e, l, s, t), QP(l, c), e.ancestors.pop(), e.schema = r, e.create(t, s, l, n);
}
function RTe(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const n = t.data.estree.body[0];
    return n.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(n.expression);
  }
  IS(e, t.position);
}
function jTe(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  IS(e, t.position);
}
function PTe(e, t, n) {
  const r = e.schema;
  let a = r;
  t.name === "svg" && r.space === "html" && (a = YP, e.schema = a), e.ancestors.push(t);
  const s = t.name === null ? e.Fragment : qX(e, t.name, !0), l = LTe(e, t), c = ZP(e, t);
  return WX(e, l, s, t), QP(l, c), e.ancestors.pop(), e.schema = r, e.create(t, s, l, n);
}
function DTe(e, t, n) {
  const r = {};
  return QP(r, ZP(e, t)), e.create(t, e.Fragment, r, n);
}
function ITe(e, t) {
  return t.value;
}
function WX(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function QP(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function $Te(e, t, n) {
  return r;
  function r(a, s, l, c) {
    const d = Array.isArray(l.children) ? n : t;
    return c ? d(s, l, c) : d(s, l);
  }
}
function zTe(e, t) {
  return n;
  function n(r, a, s, l) {
    const c = Array.isArray(s.children), d = XP(r);
    return t(
      a,
      s,
      l,
      c,
      {
        columnNumber: d ? d.column - 1 : void 0,
        fileName: e,
        lineNumber: d ? d.line : void 0
      },
      void 0
    );
  }
}
function TTe(e, t) {
  const n = {};
  let r, a;
  for (a in t.properties)
    if (a !== "children" && JP.call(t.properties, a)) {
      const s = FTe(e, a, t.properties[a]);
      if (s) {
        const [l, c] = s;
        e.tableCellAlignToStyle && l === "align" && typeof c == "string" && MTe.has(t.tagName) ? r = c : n[l] = c;
      }
    }
  if (r) {
    const s = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    s[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function LTe(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const a = r.data.estree.body[0];
        a.type;
        const s = a.expression;
        s.type;
        const l = s.properties[0];
        l.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(l.argument)
        );
      } else
        IS(e, t.position);
    else {
      const a = r.name;
      let s;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const l = r.value.data.estree.body[0];
          l.type, s = e.evaluater.evaluateExpression(l.expression);
        } else
          IS(e, t.position);
      else
        s = r.value === null ? !0 : r.value;
      n[a] = /** @type {Props[keyof Props]} */
      s;
    }
  return n;
}
function ZP(e, t) {
  const n = [];
  let r = -1;
  const a = e.passKeys ? /* @__PURE__ */ new Map() : ETe;
  for (; ++r < t.children.length; ) {
    const s = t.children[r];
    let l;
    if (e.passKeys) {
      const d = s.type === "element" ? s.tagName : s.type === "mdxJsxFlowElement" || s.type === "mdxJsxTextElement" ? s.name : void 0;
      if (d) {
        const f = a.get(d) || 0;
        l = d + "-" + f, a.set(d, f + 1);
      }
    }
    const c = HX(e, s, l);
    c !== void 0 && n.push(c);
  }
  return n;
}
function FTe(e, t, n) {
  const r = pTe(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? tTe(n) : vTe(n)), r.property === "style") {
      let a = typeof n == "object" ? n : BTe(e, String(n));
      return e.stylePropertyNameCase === "css" && (a = UTe(a)), ["style", a];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? cTe[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function BTe(e, t) {
  try {
    return kTe(t, { reactCompat: !0 });
  } catch (n) {
    if (e.ignoreInvalidStyle)
      return {};
    const r = (
      /** @type {Error} */
      n
    ), a = new ta("Cannot parse `style` attribute", {
      ancestors: e.ancestors,
      cause: r,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    throw a.file = e.filePath || void 0, a.url = VX + "#cannot-parse-style-attribute", a;
  }
}
function qX(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const a = t.split(".");
    let s = -1, l;
    for (; ++s < a.length; ) {
      const c = $9(a[s]) ? { type: "Identifier", name: a[s] } : { type: "Literal", value: a[s] };
      l = l ? {
        type: "MemberExpression",
        object: l,
        property: c,
        computed: !!(s && c.type === "Literal"),
        optional: !1
      } : c;
    }
    r = l;
  } else
    r = $9(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const a = (
      /** @type {string | number} */
      r.value
    );
    return JP.call(e.components, a) ? e.components[a] : a;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  IS(e);
}
function IS(e, t) {
  const n = new ta(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = VX + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function UTe(e) {
  const t = {};
  let n;
  for (n in e)
    JP.call(e, n) && (t[VTe(n)] = e[n]);
  return t;
}
function VTe(e) {
  let t = e.replace(CTe, HTe);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function HTe(e) {
  return "-" + e.toLowerCase();
}
const Y5 = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, WTe = {};
function e1(e, t) {
  const n = WTe, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, a = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return GX(e, r, a);
}
function GX(e, t, n) {
  if (qTe(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return q9(e.children, t, n);
  }
  return Array.isArray(e) ? q9(e, t, n) : "";
}
function q9(e, t, n) {
  const r = [];
  let a = -1;
  for (; ++a < e.length; )
    r[a] = GX(e[a], t, n);
  return r.join("");
}
function qTe(e) {
  return !!(e && typeof e == "object");
}
const G9 = document.createElement("i");
function t1(e) {
  const t = "&" + e + ";";
  G9.innerHTML = t;
  const n = G9.textContent;
  return (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n
  );
}
function Oi(e, t, n, r) {
  const a = e.length;
  let s = 0, l;
  if (t < 0 ? t = -t > a ? 0 : a + t : t = t > a ? a : t, n = n > 0 ? n : 0, r.length < 1e4)
    l = Array.from(r), l.unshift(t, n), e.splice(...l);
  else
    for (n && e.splice(t, n); s < r.length; )
      l = r.slice(s, s + 1e4), l.unshift(t, 0), e.splice(...l), s += 1e4, t += 1e4;
}
function Bi(e, t) {
  return e.length > 0 ? (Oi(e, e.length, 0, t), e) : t;
}
const K9 = {}.hasOwnProperty;
function KX(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    GTe(t, e[n]);
  return t;
}
function GTe(e, t) {
  let n;
  for (n in t) {
    const r = (K9.call(e, n) ? e[n] : void 0) || (e[n] = {}), a = t[n];
    let s;
    if (a)
      for (s in a) {
        K9.call(r, s) || (r[s] = []);
        const l = a[s];
        KTe(
          // @ts-expect-error Looks like a list.
          r[s],
          Array.isArray(l) ? l : l ? [l] : []
        );
      }
  }
}
function KTe(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  Oi(e, 0, 0, r);
}
function YX(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function Qs(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const Ea = Wd(/[A-Za-z]/), Jo = Wd(/[\dA-Za-z]/), YTe = Wd(/[#-'*+\--9=?A-Z^-~]/);
function J2(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const dR = Wd(/\d/), XTe = Wd(/[\dA-Fa-f]/), JTe = Wd(/[!-/:-@[-`{-~]/);
function gt(e) {
  return e !== null && e < -2;
}
function Yn(e) {
  return e !== null && (e < 0 || e === 32);
}
function nn(e) {
  return e === -2 || e === -1 || e === 32;
}
const WC = Wd(new RegExp("\\p{P}|\\p{S}", "u")), Gm = Wd(/\s/);
function Wd(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function Xg(e) {
  const t = [];
  let n = -1, r = 0, a = 0;
  for (; ++n < e.length; ) {
    const s = e.charCodeAt(n);
    let l = "";
    if (s === 37 && Jo(e.charCodeAt(n + 1)) && Jo(e.charCodeAt(n + 2)))
      a = 2;
    else if (s < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(s)) || (l = String.fromCharCode(s));
    else if (s > 55295 && s < 57344) {
      const c = e.charCodeAt(n + 1);
      s < 56320 && c > 56319 && c < 57344 ? (l = String.fromCharCode(s, c), a = 1) : l = "";
    } else
      l = String.fromCharCode(s);
    l && (t.push(e.slice(r, n), encodeURIComponent(l)), r = n + a + 1, l = ""), a && (n += a, a = 0);
  }
  return t.join("") + e.slice(r);
}
function fn(e, t, n, r) {
  const a = r ? r - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return l;
  function l(d) {
    return nn(d) ? (e.enter(n), c(d)) : t(d);
  }
  function c(d) {
    return nn(d) && s++ < a ? (e.consume(d), c) : (e.exit(n), t(d));
  }
}
const QTe = {
  tokenize: ZTe
};
function ZTe(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, r, a);
  let n;
  return t;
  function r(c) {
    if (c === null) {
      e.consume(c);
      return;
    }
    return e.enter("lineEnding"), e.consume(c), e.exit("lineEnding"), fn(e, t, "linePrefix");
  }
  function a(c) {
    return e.enter("paragraph"), s(c);
  }
  function s(c) {
    const d = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = d), n = d, l(c);
  }
  function l(c) {
    if (c === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(c);
      return;
    }
    return gt(c) ? (e.consume(c), e.exit("chunkText"), s) : (e.consume(c), l);
  }
}
const eLe = {
  tokenize: tLe
}, Y9 = {
  tokenize: nLe
};
function tLe(e) {
  const t = this, n = [];
  let r = 0, a, s, l;
  return c;
  function c(_) {
    if (r < n.length) {
      const O = n[r];
      return t.containerState = O[1], e.attempt(O[0].continuation, d, f)(_);
    }
    return f(_);
  }
  function d(_) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, a && E();
      const O = t.events.length;
      let N = O, A;
      for (; N--; )
        if (t.events[N][0] === "exit" && t.events[N][1].type === "chunkFlow") {
          A = t.events[N][1].end;
          break;
        }
      k(r);
      let R = O;
      for (; R < t.events.length; )
        t.events[R][1].end = {
          ...A
        }, R++;
      return Oi(t.events, N + 1, 0, t.events.slice(O)), t.events.length = R, f(_);
    }
    return c(_);
  }
  function f(_) {
    if (r === n.length) {
      if (!a)
        return v(_);
      if (a.currentConstruct && a.currentConstruct.concrete)
        return b(_);
      t.interrupt = !!(a.currentConstruct && !a._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(Y9, m, h)(_);
  }
  function m(_) {
    return a && E(), k(r), v(_);
  }
  function h(_) {
    return t.parser.lazy[t.now().line] = r !== n.length, l = t.now().offset, b(_);
  }
  function v(_) {
    return t.containerState = {}, e.attempt(Y9, g, b)(_);
  }
  function g(_) {
    return r++, n.push([t.currentConstruct, t.containerState]), v(_);
  }
  function b(_) {
    if (_ === null) {
      a && E(), k(0), e.consume(_);
      return;
    }
    return a = a || t.parser.flow(t.now()), e.enter("chunkFlow", {
      _tokenizer: a,
      contentType: "flow",
      previous: s
    }), x(_);
  }
  function x(_) {
    if (_ === null) {
      w(e.exit("chunkFlow"), !0), k(0), e.consume(_);
      return;
    }
    return gt(_) ? (e.consume(_), w(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, c) : (e.consume(_), x);
  }
  function w(_, O) {
    const N = t.sliceStream(_);
    if (O && N.push(null), _.previous = s, s && (s.next = _), s = _, a.defineSkip(_.start), a.write(N), t.parser.lazy[_.start.line]) {
      let A = a.events.length;
      for (; A--; )
        if (
          // The token starts before the line ending
          a.events[A][1].start.offset < l && // and either is not ended yet
          (!a.events[A][1].end || // or ends after it.
          a.events[A][1].end.offset > l)
        )
          return;
      const R = t.events.length;
      let D = R, I, z;
      for (; D--; )
        if (t.events[D][0] === "exit" && t.events[D][1].type === "chunkFlow") {
          if (I) {
            z = t.events[D][1].end;
            break;
          }
          I = !0;
        }
      for (k(r), A = R; A < t.events.length; )
        t.events[A][1].end = {
          ...z
        }, A++;
      Oi(t.events, D + 1, 0, t.events.slice(R)), t.events.length = A;
    }
  }
  function k(_) {
    let O = n.length;
    for (; O-- > _; ) {
      const N = n[O];
      t.containerState = N[1], N[0].exit.call(t, e);
    }
    n.length = _;
  }
  function E() {
    a.write([null]), s = void 0, a = void 0, t.containerState._closeFlow = void 0;
  }
}
function nLe(e, t, n) {
  return fn(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function Pg(e) {
  if (e === null || Yn(e) || Gm(e))
    return 1;
  if (WC(e))
    return 2;
}
function qC(e, t, n) {
  const r = [];
  let a = -1;
  for (; ++a < e.length; ) {
    const s = e[a].resolveAll;
    s && !r.includes(s) && (t = s(t, n), r.push(s));
  }
  return t;
}
const fR = {
  name: "attention",
  resolveAll: rLe,
  tokenize: oLe
};
function rLe(e, t) {
  let n = -1, r, a, s, l, c, d, f, m;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          d = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const h = {
            ...e[r][1].end
          }, v = {
            ...e[n][1].start
          };
          X9(h, -d), X9(v, d), l = {
            type: d > 1 ? "strongSequence" : "emphasisSequence",
            start: h,
            end: {
              ...e[r][1].end
            }
          }, c = {
            type: d > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...e[n][1].start
            },
            end: v
          }, s = {
            type: d > 1 ? "strongText" : "emphasisText",
            start: {
              ...e[r][1].end
            },
            end: {
              ...e[n][1].start
            }
          }, a = {
            type: d > 1 ? "strong" : "emphasis",
            start: {
              ...l.start
            },
            end: {
              ...c.end
            }
          }, e[r][1].end = {
            ...l.start
          }, e[n][1].start = {
            ...c.end
          }, f = [], e[r][1].end.offset - e[r][1].start.offset && (f = Bi(f, [["enter", e[r][1], t], ["exit", e[r][1], t]])), f = Bi(f, [["enter", a, t], ["enter", l, t], ["exit", l, t], ["enter", s, t]]), f = Bi(f, qC(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), f = Bi(f, [["exit", s, t], ["enter", c, t], ["exit", c, t], ["exit", a, t]]), e[n][1].end.offset - e[n][1].start.offset ? (m = 2, f = Bi(f, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : m = 0, Oi(e, r - 1, n - r + 3, f), n = r + f.length - m - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function oLe(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, a = Pg(r);
  let s;
  return l;
  function l(d) {
    return s = d, e.enter("attentionSequence"), c(d);
  }
  function c(d) {
    if (d === s)
      return e.consume(d), c;
    const f = e.exit("attentionSequence"), m = Pg(d), h = !m || m === 2 && a || n.includes(d), v = !a || a === 2 && m || n.includes(r);
    return f._open = !!(s === 42 ? h : h && (a || !v)), f._close = !!(s === 42 ? v : v && (m || !h)), t(d);
  }
}
function X9(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const aLe = {
  name: "autolink",
  tokenize: iLe
};
function iLe(e, t, n) {
  let r = 0;
  return a;
  function a(g) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(g), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), s;
  }
  function s(g) {
    return Ea(g) ? (e.consume(g), l) : g === 64 ? n(g) : f(g);
  }
  function l(g) {
    return g === 43 || g === 45 || g === 46 || Jo(g) ? (r = 1, c(g)) : f(g);
  }
  function c(g) {
    return g === 58 ? (e.consume(g), r = 0, d) : (g === 43 || g === 45 || g === 46 || Jo(g)) && r++ < 32 ? (e.consume(g), c) : (r = 0, f(g));
  }
  function d(g) {
    return g === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(g), e.exit("autolinkMarker"), e.exit("autolink"), t) : g === null || g === 32 || g === 60 || J2(g) ? n(g) : (e.consume(g), d);
  }
  function f(g) {
    return g === 64 ? (e.consume(g), m) : YTe(g) ? (e.consume(g), f) : n(g);
  }
  function m(g) {
    return Jo(g) ? h(g) : n(g);
  }
  function h(g) {
    return g === 46 ? (e.consume(g), r = 0, m) : g === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(g), e.exit("autolinkMarker"), e.exit("autolink"), t) : v(g);
  }
  function v(g) {
    if ((g === 45 || Jo(g)) && r++ < 63) {
      const b = g === 45 ? v : h;
      return e.consume(g), b;
    }
    return n(g);
  }
}
const Dk = {
  partial: !0,
  tokenize: sLe
};
function sLe(e, t, n) {
  return r;
  function r(s) {
    return nn(s) ? fn(e, a, "linePrefix")(s) : a(s);
  }
  function a(s) {
    return s === null || gt(s) ? t(s) : n(s);
  }
}
const XX = {
  continuation: {
    tokenize: uLe
  },
  exit: cLe,
  name: "blockQuote",
  tokenize: lLe
};
function lLe(e, t, n) {
  const r = this;
  return a;
  function a(l) {
    if (l === 62) {
      const c = r.containerState;
      return c.open || (e.enter("blockQuote", {
        _container: !0
      }), c.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(l), e.exit("blockQuoteMarker"), s;
    }
    return n(l);
  }
  function s(l) {
    return nn(l) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(l), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(l));
  }
}
function uLe(e, t, n) {
  const r = this;
  return a;
  function a(l) {
    return nn(l) ? fn(e, s, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(l) : s(l);
  }
  function s(l) {
    return e.attempt(XX, t, n)(l);
  }
}
function cLe(e) {
  e.exit("blockQuote");
}
const JX = {
  name: "characterEscape",
  tokenize: dLe
};
function dLe(e, t, n) {
  return r;
  function r(s) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(s), e.exit("escapeMarker"), a;
  }
  function a(s) {
    return JTe(s) ? (e.enter("characterEscapeValue"), e.consume(s), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(s);
  }
}
const QX = {
  name: "characterReference",
  tokenize: fLe
};
function fLe(e, t, n) {
  const r = this;
  let a = 0, s, l;
  return c;
  function c(h) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(h), e.exit("characterReferenceMarker"), d;
  }
  function d(h) {
    return h === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(h), e.exit("characterReferenceMarkerNumeric"), f) : (e.enter("characterReferenceValue"), s = 31, l = Jo, m(h));
  }
  function f(h) {
    return h === 88 || h === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(h), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), s = 6, l = XTe, m) : (e.enter("characterReferenceValue"), s = 7, l = dR, m(h));
  }
  function m(h) {
    if (h === 59 && a) {
      const v = e.exit("characterReferenceValue");
      return l === Jo && !t1(r.sliceSerialize(v)) ? n(h) : (e.enter("characterReferenceMarker"), e.consume(h), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return l(h) && a++ < s ? (e.consume(h), m) : n(h);
  }
}
const J9 = {
  partial: !0,
  tokenize: mLe
}, Q9 = {
  concrete: !0,
  name: "codeFenced",
  tokenize: pLe
};
function pLe(e, t, n) {
  const r = this, a = {
    partial: !0,
    tokenize: N
  };
  let s = 0, l = 0, c;
  return d;
  function d(A) {
    return f(A);
  }
  function f(A) {
    const R = r.events[r.events.length - 1];
    return s = R && R[1].type === "linePrefix" ? R[2].sliceSerialize(R[1], !0).length : 0, c = A, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), m(A);
  }
  function m(A) {
    return A === c ? (l++, e.consume(A), m) : l < 3 ? n(A) : (e.exit("codeFencedFenceSequence"), nn(A) ? fn(e, h, "whitespace")(A) : h(A));
  }
  function h(A) {
    return A === null || gt(A) ? (e.exit("codeFencedFence"), r.interrupt ? t(A) : e.check(J9, x, O)(A)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), v(A));
  }
  function v(A) {
    return A === null || gt(A) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), h(A)) : nn(A) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), fn(e, g, "whitespace")(A)) : A === 96 && A === c ? n(A) : (e.consume(A), v);
  }
  function g(A) {
    return A === null || gt(A) ? h(A) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), b(A));
  }
  function b(A) {
    return A === null || gt(A) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), h(A)) : A === 96 && A === c ? n(A) : (e.consume(A), b);
  }
  function x(A) {
    return e.attempt(a, O, w)(A);
  }
  function w(A) {
    return e.enter("lineEnding"), e.consume(A), e.exit("lineEnding"), k;
  }
  function k(A) {
    return s > 0 && nn(A) ? fn(e, E, "linePrefix", s + 1)(A) : E(A);
  }
  function E(A) {
    return A === null || gt(A) ? e.check(J9, x, O)(A) : (e.enter("codeFlowValue"), _(A));
  }
  function _(A) {
    return A === null || gt(A) ? (e.exit("codeFlowValue"), E(A)) : (e.consume(A), _);
  }
  function O(A) {
    return e.exit("codeFenced"), t(A);
  }
  function N(A, R, D) {
    let I = 0;
    return z;
    function z(G) {
      return A.enter("lineEnding"), A.consume(G), A.exit("lineEnding"), B;
    }
    function B(G) {
      return A.enter("codeFencedFence"), nn(G) ? fn(A, P, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(G) : P(G);
    }
    function P(G) {
      return G === c ? (A.enter("codeFencedFenceSequence"), H(G)) : D(G);
    }
    function H(G) {
      return G === c ? (I++, A.consume(G), H) : I >= l ? (A.exit("codeFencedFenceSequence"), nn(G) ? fn(A, L, "whitespace")(G) : L(G)) : D(G);
    }
    function L(G) {
      return G === null || gt(G) ? (A.exit("codeFencedFence"), R(G)) : D(G);
    }
  }
}
function mLe(e, t, n) {
  const r = this;
  return a;
  function a(l) {
    return l === null ? n(l) : (e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), s);
  }
  function s(l) {
    return r.parser.lazy[r.now().line] ? n(l) : t(l);
  }
}
const X5 = {
  name: "codeIndented",
  tokenize: gLe
}, hLe = {
  partial: !0,
  tokenize: vLe
};
function gLe(e, t, n) {
  const r = this;
  return a;
  function a(f) {
    return e.enter("codeIndented"), fn(e, s, "linePrefix", 5)(f);
  }
  function s(f) {
    const m = r.events[r.events.length - 1];
    return m && m[1].type === "linePrefix" && m[2].sliceSerialize(m[1], !0).length >= 4 ? l(f) : n(f);
  }
  function l(f) {
    return f === null ? d(f) : gt(f) ? e.attempt(hLe, l, d)(f) : (e.enter("codeFlowValue"), c(f));
  }
  function c(f) {
    return f === null || gt(f) ? (e.exit("codeFlowValue"), l(f)) : (e.consume(f), c);
  }
  function d(f) {
    return e.exit("codeIndented"), t(f);
  }
}
function vLe(e, t, n) {
  const r = this;
  return a;
  function a(l) {
    return r.parser.lazy[r.now().line] ? n(l) : gt(l) ? (e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), a) : fn(e, s, "linePrefix", 5)(l);
  }
  function s(l) {
    const c = r.events[r.events.length - 1];
    return c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? t(l) : gt(l) ? a(l) : n(l);
  }
}
const yLe = {
  name: "codeText",
  previous: wLe,
  resolve: bLe,
  tokenize: xLe
};
function bLe(e) {
  let t = e.length - 4, n = 3, r, a;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    a === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (a = r) : (r === t || e[r][1].type === "lineEnding") && (e[a][1].type = "codeTextData", r !== a + 2 && (e[a][1].end = e[r - 1][1].end, e.splice(a + 2, r - a - 2), t -= r - a - 2, r = a + 2), a = void 0);
  return e;
}
function wLe(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function xLe(e, t, n) {
  let r = 0, a, s;
  return l;
  function l(h) {
    return e.enter("codeText"), e.enter("codeTextSequence"), c(h);
  }
  function c(h) {
    return h === 96 ? (e.consume(h), r++, c) : (e.exit("codeTextSequence"), d(h));
  }
  function d(h) {
    return h === null ? n(h) : h === 32 ? (e.enter("space"), e.consume(h), e.exit("space"), d) : h === 96 ? (s = e.enter("codeTextSequence"), a = 0, m(h)) : gt(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), d) : (e.enter("codeTextData"), f(h));
  }
  function f(h) {
    return h === null || h === 32 || h === 96 || gt(h) ? (e.exit("codeTextData"), d(h)) : (e.consume(h), f);
  }
  function m(h) {
    return h === 96 ? (e.consume(h), a++, m) : a === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(h)) : (s.type = "codeTextData", f(h));
  }
}
class SLe {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, r) {
    const a = n || 0;
    this.setCursor(Math.trunc(t));
    const s = this.right.splice(this.right.length - a, Number.POSITIVE_INFINITY);
    return r && dx(this.left, r), s.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), dx(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), dx(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        dx(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        dx(this.left, n.reverse());
      }
  }
}
function dx(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function ZX(e) {
  const t = {};
  let n = -1, r, a, s, l, c, d, f;
  const m = new SLe(e);
  for (; ++n < m.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = m.get(n), n && r[1].type === "chunkFlow" && m.get(n - 1)[1].type === "listItemPrefix" && (d = r[1]._tokenizer.events, s = 0, s < d.length && d[s][1].type === "lineEndingBlank" && (s += 2), s < d.length && d[s][1].type === "content"))
      for (; ++s < d.length && d[s][1].type !== "content"; )
        d[s][1].type === "chunkText" && (d[s][1]._isInFirstContentOfListItem = !0, s++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, kLe(m, n)), n = t[n], f = !0);
    else if (r[1]._container) {
      for (s = n, a = void 0; s--; )
        if (l = m.get(s), l[1].type === "lineEnding" || l[1].type === "lineEndingBlank")
          l[0] === "enter" && (a && (m.get(a)[1].type = "lineEndingBlank"), l[1].type = "lineEnding", a = s);
        else if (!(l[1].type === "linePrefix" || l[1].type === "listItemIndent")) break;
      a && (r[1].end = {
        ...m.get(a)[1].start
      }, c = m.slice(a, n), c.unshift(r), m.splice(a, n - a + 1, c));
    }
  }
  return Oi(e, 0, Number.POSITIVE_INFINITY, m.slice(0)), !f;
}
function kLe(e, t) {
  const n = e.get(t)[1], r = e.get(t)[2];
  let a = t - 1;
  const s = [];
  let l = n._tokenizer;
  l || (l = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (l._contentTypeTextTrailing = !0));
  const c = l.events, d = [], f = {};
  let m, h, v = -1, g = n, b = 0, x = 0;
  const w = [x];
  for (; g; ) {
    for (; e.get(++a)[1] !== g; )
      ;
    s.push(a), g._tokenizer || (m = r.sliceStream(g), g.next || m.push(null), h && l.defineSkip(g.start), g._isInFirstContentOfListItem && (l._gfmTasklistFirstContentOfListItem = !0), l.write(m), g._isInFirstContentOfListItem && (l._gfmTasklistFirstContentOfListItem = void 0)), h = g, g = g.next;
  }
  for (g = n; ++v < c.length; )
    c[v][0] === "exit" && c[v - 1][0] === "enter" && c[v][1].type === c[v - 1][1].type && c[v][1].start.line !== c[v][1].end.line && (x = v + 1, w.push(x), g._tokenizer = void 0, g.previous = void 0, g = g.next);
  for (l.events = [], g ? (g._tokenizer = void 0, g.previous = void 0) : w.pop(), v = w.length; v--; ) {
    const k = c.slice(w[v], w[v + 1]), E = s.pop();
    d.push([E, E + k.length - 1]), e.splice(E, 2, k);
  }
  for (d.reverse(), v = -1; ++v < d.length; )
    f[b + d[v][0]] = b + d[v][1], b += d[v][1] - d[v][0] - 1;
  return f;
}
const _Le = {
  resolve: CLe,
  tokenize: OLe
}, ELe = {
  partial: !0,
  tokenize: MLe
};
function CLe(e) {
  return ZX(e), e;
}
function OLe(e, t) {
  let n;
  return r;
  function r(c) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), a(c);
  }
  function a(c) {
    return c === null ? s(c) : gt(c) ? e.check(ELe, l, s)(c) : (e.consume(c), a);
  }
  function s(c) {
    return e.exit("chunkContent"), e.exit("content"), t(c);
  }
  function l(c) {
    return e.consume(c), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, a;
  }
}
function MLe(e, t, n) {
  const r = this;
  return a;
  function a(l) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), fn(e, s, "linePrefix");
  }
  function s(l) {
    if (l === null || gt(l))
      return n(l);
    const c = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? t(l) : e.interrupt(r.parser.constructs.flow, n, t)(l);
  }
}
function eJ(e, t, n, r, a, s, l, c, d) {
  const f = d || Number.POSITIVE_INFINITY;
  let m = 0;
  return h;
  function h(k) {
    return k === 60 ? (e.enter(r), e.enter(a), e.enter(s), e.consume(k), e.exit(s), v) : k === null || k === 32 || k === 41 || J2(k) ? n(k) : (e.enter(r), e.enter(l), e.enter(c), e.enter("chunkString", {
      contentType: "string"
    }), x(k));
  }
  function v(k) {
    return k === 62 ? (e.enter(s), e.consume(k), e.exit(s), e.exit(a), e.exit(r), t) : (e.enter(c), e.enter("chunkString", {
      contentType: "string"
    }), g(k));
  }
  function g(k) {
    return k === 62 ? (e.exit("chunkString"), e.exit(c), v(k)) : k === null || k === 60 || gt(k) ? n(k) : (e.consume(k), k === 92 ? b : g);
  }
  function b(k) {
    return k === 60 || k === 62 || k === 92 ? (e.consume(k), g) : g(k);
  }
  function x(k) {
    return !m && (k === null || k === 41 || Yn(k)) ? (e.exit("chunkString"), e.exit(c), e.exit(l), e.exit(r), t(k)) : m < f && k === 40 ? (e.consume(k), m++, x) : k === 41 ? (e.consume(k), m--, x) : k === null || k === 32 || k === 40 || J2(k) ? n(k) : (e.consume(k), k === 92 ? w : x);
  }
  function w(k) {
    return k === 40 || k === 41 || k === 92 ? (e.consume(k), x) : x(k);
  }
}
function tJ(e, t, n, r, a, s) {
  const l = this;
  let c = 0, d;
  return f;
  function f(g) {
    return e.enter(r), e.enter(a), e.consume(g), e.exit(a), e.enter(s), m;
  }
  function m(g) {
    return c > 999 || g === null || g === 91 || g === 93 && !d || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    g === 94 && !c && "_hiddenFootnoteSupport" in l.parser.constructs ? n(g) : g === 93 ? (e.exit(s), e.enter(a), e.consume(g), e.exit(a), e.exit(r), t) : gt(g) ? (e.enter("lineEnding"), e.consume(g), e.exit("lineEnding"), m) : (e.enter("chunkString", {
      contentType: "string"
    }), h(g));
  }
  function h(g) {
    return g === null || g === 91 || g === 93 || gt(g) || c++ > 999 ? (e.exit("chunkString"), m(g)) : (e.consume(g), d || (d = !nn(g)), g === 92 ? v : h);
  }
  function v(g) {
    return g === 91 || g === 92 || g === 93 ? (e.consume(g), c++, h) : h(g);
  }
}
function nJ(e, t, n, r, a, s) {
  let l;
  return c;
  function c(v) {
    return v === 34 || v === 39 || v === 40 ? (e.enter(r), e.enter(a), e.consume(v), e.exit(a), l = v === 40 ? 41 : v, d) : n(v);
  }
  function d(v) {
    return v === l ? (e.enter(a), e.consume(v), e.exit(a), e.exit(r), t) : (e.enter(s), f(v));
  }
  function f(v) {
    return v === l ? (e.exit(s), d(l)) : v === null ? n(v) : gt(v) ? (e.enter("lineEnding"), e.consume(v), e.exit("lineEnding"), fn(e, f, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), m(v));
  }
  function m(v) {
    return v === l || v === null || gt(v) ? (e.exit("chunkString"), f(v)) : (e.consume(v), v === 92 ? h : m);
  }
  function h(v) {
    return v === l || v === 92 ? (e.consume(v), m) : m(v);
  }
}
function Gx(e, t) {
  let n;
  return r;
  function r(a) {
    return gt(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), n = !0, r) : nn(a) ? fn(e, r, n ? "linePrefix" : "lineSuffix")(a) : t(a);
  }
}
const NLe = {
  name: "definition",
  tokenize: RLe
}, ALe = {
  partial: !0,
  tokenize: jLe
};
function RLe(e, t, n) {
  const r = this;
  let a;
  return s;
  function s(g) {
    return e.enter("definition"), l(g);
  }
  function l(g) {
    return tJ.call(
      r,
      e,
      c,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(g);
  }
  function c(g) {
    return a = Qs(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), g === 58 ? (e.enter("definitionMarker"), e.consume(g), e.exit("definitionMarker"), d) : n(g);
  }
  function d(g) {
    return Yn(g) ? Gx(e, f)(g) : f(g);
  }
  function f(g) {
    return eJ(
      e,
      m,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(g);
  }
  function m(g) {
    return e.attempt(ALe, h, h)(g);
  }
  function h(g) {
    return nn(g) ? fn(e, v, "whitespace")(g) : v(g);
  }
  function v(g) {
    return g === null || gt(g) ? (e.exit("definition"), r.parser.defined.push(a), t(g)) : n(g);
  }
}
function jLe(e, t, n) {
  return r;
  function r(c) {
    return Yn(c) ? Gx(e, a)(c) : n(c);
  }
  function a(c) {
    return nJ(e, s, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(c);
  }
  function s(c) {
    return nn(c) ? fn(e, l, "whitespace")(c) : l(c);
  }
  function l(c) {
    return c === null || gt(c) ? t(c) : n(c);
  }
}
const PLe = {
  name: "hardBreakEscape",
  tokenize: DLe
};
function DLe(e, t, n) {
  return r;
  function r(s) {
    return e.enter("hardBreakEscape"), e.consume(s), a;
  }
  function a(s) {
    return gt(s) ? (e.exit("hardBreakEscape"), t(s)) : n(s);
  }
}
const ILe = {
  name: "headingAtx",
  resolve: $Le,
  tokenize: zLe
};
function $Le(e, t) {
  let n = e.length - 2, r = 3, a, s;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (a = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, s = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, Oi(e, r, n - r + 1, [["enter", a, t], ["enter", s, t], ["exit", s, t], ["exit", a, t]])), e;
}
function zLe(e, t, n) {
  let r = 0;
  return a;
  function a(m) {
    return e.enter("atxHeading"), s(m);
  }
  function s(m) {
    return e.enter("atxHeadingSequence"), l(m);
  }
  function l(m) {
    return m === 35 && r++ < 6 ? (e.consume(m), l) : m === null || Yn(m) ? (e.exit("atxHeadingSequence"), c(m)) : n(m);
  }
  function c(m) {
    return m === 35 ? (e.enter("atxHeadingSequence"), d(m)) : m === null || gt(m) ? (e.exit("atxHeading"), t(m)) : nn(m) ? fn(e, c, "whitespace")(m) : (e.enter("atxHeadingText"), f(m));
  }
  function d(m) {
    return m === 35 ? (e.consume(m), d) : (e.exit("atxHeadingSequence"), c(m));
  }
  function f(m) {
    return m === null || m === 35 || Yn(m) ? (e.exit("atxHeadingText"), c(m)) : (e.consume(m), f);
  }
}
const TLe = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Z9 = ["pre", "script", "style", "textarea"], LLe = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: ULe,
  tokenize: VLe
}, FLe = {
  partial: !0,
  tokenize: WLe
}, BLe = {
  partial: !0,
  tokenize: HLe
};
function ULe(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function VLe(e, t, n) {
  const r = this;
  let a, s, l, c, d;
  return f;
  function f(U) {
    return m(U);
  }
  function m(U) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(U), h;
  }
  function h(U) {
    return U === 33 ? (e.consume(U), v) : U === 47 ? (e.consume(U), s = !0, x) : U === 63 ? (e.consume(U), a = 3, r.interrupt ? t : V) : Ea(U) ? (e.consume(U), l = String.fromCharCode(U), w) : n(U);
  }
  function v(U) {
    return U === 45 ? (e.consume(U), a = 2, g) : U === 91 ? (e.consume(U), a = 5, c = 0, b) : Ea(U) ? (e.consume(U), a = 4, r.interrupt ? t : V) : n(U);
  }
  function g(U) {
    return U === 45 ? (e.consume(U), r.interrupt ? t : V) : n(U);
  }
  function b(U) {
    const W = "CDATA[";
    return U === W.charCodeAt(c++) ? (e.consume(U), c === W.length ? r.interrupt ? t : P : b) : n(U);
  }
  function x(U) {
    return Ea(U) ? (e.consume(U), l = String.fromCharCode(U), w) : n(U);
  }
  function w(U) {
    if (U === null || U === 47 || U === 62 || Yn(U)) {
      const W = U === 47, J = l.toLowerCase();
      return !W && !s && Z9.includes(J) ? (a = 1, r.interrupt ? t(U) : P(U)) : TLe.includes(l.toLowerCase()) ? (a = 6, W ? (e.consume(U), k) : r.interrupt ? t(U) : P(U)) : (a = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(U) : s ? E(U) : _(U));
    }
    return U === 45 || Jo(U) ? (e.consume(U), l += String.fromCharCode(U), w) : n(U);
  }
  function k(U) {
    return U === 62 ? (e.consume(U), r.interrupt ? t : P) : n(U);
  }
  function E(U) {
    return nn(U) ? (e.consume(U), E) : z(U);
  }
  function _(U) {
    return U === 47 ? (e.consume(U), z) : U === 58 || U === 95 || Ea(U) ? (e.consume(U), O) : nn(U) ? (e.consume(U), _) : z(U);
  }
  function O(U) {
    return U === 45 || U === 46 || U === 58 || U === 95 || Jo(U) ? (e.consume(U), O) : N(U);
  }
  function N(U) {
    return U === 61 ? (e.consume(U), A) : nn(U) ? (e.consume(U), N) : _(U);
  }
  function A(U) {
    return U === null || U === 60 || U === 61 || U === 62 || U === 96 ? n(U) : U === 34 || U === 39 ? (e.consume(U), d = U, R) : nn(U) ? (e.consume(U), A) : D(U);
  }
  function R(U) {
    return U === d ? (e.consume(U), d = null, I) : U === null || gt(U) ? n(U) : (e.consume(U), R);
  }
  function D(U) {
    return U === null || U === 34 || U === 39 || U === 47 || U === 60 || U === 61 || U === 62 || U === 96 || Yn(U) ? N(U) : (e.consume(U), D);
  }
  function I(U) {
    return U === 47 || U === 62 || nn(U) ? _(U) : n(U);
  }
  function z(U) {
    return U === 62 ? (e.consume(U), B) : n(U);
  }
  function B(U) {
    return U === null || gt(U) ? P(U) : nn(U) ? (e.consume(U), B) : n(U);
  }
  function P(U) {
    return U === 45 && a === 2 ? (e.consume(U), $) : U === 60 && a === 1 ? (e.consume(U), K) : U === 62 && a === 4 ? (e.consume(U), F) : U === 63 && a === 3 ? (e.consume(U), V) : U === 93 && a === 5 ? (e.consume(U), Z) : gt(U) && (a === 6 || a === 7) ? (e.exit("htmlFlowData"), e.check(FLe, Y, H)(U)) : U === null || gt(U) ? (e.exit("htmlFlowData"), H(U)) : (e.consume(U), P);
  }
  function H(U) {
    return e.check(BLe, L, Y)(U);
  }
  function L(U) {
    return e.enter("lineEnding"), e.consume(U), e.exit("lineEnding"), G;
  }
  function G(U) {
    return U === null || gt(U) ? H(U) : (e.enter("htmlFlowData"), P(U));
  }
  function $(U) {
    return U === 45 ? (e.consume(U), V) : P(U);
  }
  function K(U) {
    return U === 47 ? (e.consume(U), l = "", q) : P(U);
  }
  function q(U) {
    if (U === 62) {
      const W = l.toLowerCase();
      return Z9.includes(W) ? (e.consume(U), F) : P(U);
    }
    return Ea(U) && l.length < 8 ? (e.consume(U), l += String.fromCharCode(U), q) : P(U);
  }
  function Z(U) {
    return U === 93 ? (e.consume(U), V) : P(U);
  }
  function V(U) {
    return U === 62 ? (e.consume(U), F) : U === 45 && a === 2 ? (e.consume(U), V) : P(U);
  }
  function F(U) {
    return U === null || gt(U) ? (e.exit("htmlFlowData"), Y(U)) : (e.consume(U), F);
  }
  function Y(U) {
    return e.exit("htmlFlow"), t(U);
  }
}
function HLe(e, t, n) {
  const r = this;
  return a;
  function a(l) {
    return gt(l) ? (e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), s) : n(l);
  }
  function s(l) {
    return r.parser.lazy[r.now().line] ? n(l) : t(l);
  }
}
function WLe(e, t, n) {
  return r;
  function r(a) {
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), e.attempt(Dk, t, n);
  }
}
const qLe = {
  name: "htmlText",
  tokenize: GLe
};
function GLe(e, t, n) {
  const r = this;
  let a, s, l;
  return c;
  function c(V) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(V), d;
  }
  function d(V) {
    return V === 33 ? (e.consume(V), f) : V === 47 ? (e.consume(V), N) : V === 63 ? (e.consume(V), _) : Ea(V) ? (e.consume(V), D) : n(V);
  }
  function f(V) {
    return V === 45 ? (e.consume(V), m) : V === 91 ? (e.consume(V), s = 0, b) : Ea(V) ? (e.consume(V), E) : n(V);
  }
  function m(V) {
    return V === 45 ? (e.consume(V), g) : n(V);
  }
  function h(V) {
    return V === null ? n(V) : V === 45 ? (e.consume(V), v) : gt(V) ? (l = h, K(V)) : (e.consume(V), h);
  }
  function v(V) {
    return V === 45 ? (e.consume(V), g) : h(V);
  }
  function g(V) {
    return V === 62 ? $(V) : V === 45 ? v(V) : h(V);
  }
  function b(V) {
    const F = "CDATA[";
    return V === F.charCodeAt(s++) ? (e.consume(V), s === F.length ? x : b) : n(V);
  }
  function x(V) {
    return V === null ? n(V) : V === 93 ? (e.consume(V), w) : gt(V) ? (l = x, K(V)) : (e.consume(V), x);
  }
  function w(V) {
    return V === 93 ? (e.consume(V), k) : x(V);
  }
  function k(V) {
    return V === 62 ? $(V) : V === 93 ? (e.consume(V), k) : x(V);
  }
  function E(V) {
    return V === null || V === 62 ? $(V) : gt(V) ? (l = E, K(V)) : (e.consume(V), E);
  }
  function _(V) {
    return V === null ? n(V) : V === 63 ? (e.consume(V), O) : gt(V) ? (l = _, K(V)) : (e.consume(V), _);
  }
  function O(V) {
    return V === 62 ? $(V) : _(V);
  }
  function N(V) {
    return Ea(V) ? (e.consume(V), A) : n(V);
  }
  function A(V) {
    return V === 45 || Jo(V) ? (e.consume(V), A) : R(V);
  }
  function R(V) {
    return gt(V) ? (l = R, K(V)) : nn(V) ? (e.consume(V), R) : $(V);
  }
  function D(V) {
    return V === 45 || Jo(V) ? (e.consume(V), D) : V === 47 || V === 62 || Yn(V) ? I(V) : n(V);
  }
  function I(V) {
    return V === 47 ? (e.consume(V), $) : V === 58 || V === 95 || Ea(V) ? (e.consume(V), z) : gt(V) ? (l = I, K(V)) : nn(V) ? (e.consume(V), I) : $(V);
  }
  function z(V) {
    return V === 45 || V === 46 || V === 58 || V === 95 || Jo(V) ? (e.consume(V), z) : B(V);
  }
  function B(V) {
    return V === 61 ? (e.consume(V), P) : gt(V) ? (l = B, K(V)) : nn(V) ? (e.consume(V), B) : I(V);
  }
  function P(V) {
    return V === null || V === 60 || V === 61 || V === 62 || V === 96 ? n(V) : V === 34 || V === 39 ? (e.consume(V), a = V, H) : gt(V) ? (l = P, K(V)) : nn(V) ? (e.consume(V), P) : (e.consume(V), L);
  }
  function H(V) {
    return V === a ? (e.consume(V), a = void 0, G) : V === null ? n(V) : gt(V) ? (l = H, K(V)) : (e.consume(V), H);
  }
  function L(V) {
    return V === null || V === 34 || V === 39 || V === 60 || V === 61 || V === 96 ? n(V) : V === 47 || V === 62 || Yn(V) ? I(V) : (e.consume(V), L);
  }
  function G(V) {
    return V === 47 || V === 62 || Yn(V) ? I(V) : n(V);
  }
  function $(V) {
    return V === 62 ? (e.consume(V), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(V);
  }
  function K(V) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(V), e.exit("lineEnding"), q;
  }
  function q(V) {
    return nn(V) ? fn(e, Z, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(V) : Z(V);
  }
  function Z(V) {
    return e.enter("htmlTextData"), l(V);
  }
}
const n1 = {
  name: "labelEnd",
  resolveAll: JLe,
  resolveTo: QLe,
  tokenize: ZLe
}, KLe = {
  tokenize: e9e
}, YLe = {
  tokenize: t9e
}, XLe = {
  tokenize: n9e
};
function JLe(e) {
  let t = -1;
  const n = [];
  for (; ++t < e.length; ) {
    const r = e[t][1];
    if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const a = r.type === "labelImage" ? 4 : 2;
      r.type = "data", t += a;
    }
  }
  return e.length !== n.length && Oi(e, 0, e.length, n), e;
}
function QLe(e, t) {
  let n = e.length, r = 0, a, s, l, c;
  for (; n--; )
    if (a = e[n][1], s) {
      if (a.type === "link" || a.type === "labelLink" && a._inactive)
        break;
      e[n][0] === "enter" && a.type === "labelLink" && (a._inactive = !0);
    } else if (l) {
      if (e[n][0] === "enter" && (a.type === "labelImage" || a.type === "labelLink") && !a._balanced && (s = n, a.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else a.type === "labelEnd" && (l = n);
  const d = {
    type: e[s][1].type === "labelLink" ? "link" : "image",
    start: {
      ...e[s][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  }, f = {
    type: "label",
    start: {
      ...e[s][1].start
    },
    end: {
      ...e[l][1].end
    }
  }, m = {
    type: "labelText",
    start: {
      ...e[s + r + 2][1].end
    },
    end: {
      ...e[l - 2][1].start
    }
  };
  return c = [["enter", d, t], ["enter", f, t]], c = Bi(c, e.slice(s + 1, s + r + 3)), c = Bi(c, [["enter", m, t]]), c = Bi(c, qC(t.parser.constructs.insideSpan.null, e.slice(s + r + 4, l - 3), t)), c = Bi(c, [["exit", m, t], e[l - 2], e[l - 1], ["exit", f, t]]), c = Bi(c, e.slice(l + 1)), c = Bi(c, [["exit", d, t]]), Oi(e, s, e.length, c), e;
}
function ZLe(e, t, n) {
  const r = this;
  let a = r.events.length, s, l;
  for (; a--; )
    if ((r.events[a][1].type === "labelImage" || r.events[a][1].type === "labelLink") && !r.events[a][1]._balanced) {
      s = r.events[a][1];
      break;
    }
  return c;
  function c(v) {
    return s ? s._inactive ? h(v) : (l = r.parser.defined.includes(Qs(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(v), e.exit("labelMarker"), e.exit("labelEnd"), d) : n(v);
  }
  function d(v) {
    return v === 40 ? e.attempt(KLe, m, l ? m : h)(v) : v === 91 ? e.attempt(YLe, m, l ? f : h)(v) : l ? m(v) : h(v);
  }
  function f(v) {
    return e.attempt(XLe, m, h)(v);
  }
  function m(v) {
    return t(v);
  }
  function h(v) {
    return s._balanced = !0, n(v);
  }
}
function e9e(e, t, n) {
  return r;
  function r(h) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(h), e.exit("resourceMarker"), a;
  }
  function a(h) {
    return Yn(h) ? Gx(e, s)(h) : s(h);
  }
  function s(h) {
    return h === 41 ? m(h) : eJ(e, l, c, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(h);
  }
  function l(h) {
    return Yn(h) ? Gx(e, d)(h) : m(h);
  }
  function c(h) {
    return n(h);
  }
  function d(h) {
    return h === 34 || h === 39 || h === 40 ? nJ(e, f, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(h) : m(h);
  }
  function f(h) {
    return Yn(h) ? Gx(e, m)(h) : m(h);
  }
  function m(h) {
    return h === 41 ? (e.enter("resourceMarker"), e.consume(h), e.exit("resourceMarker"), e.exit("resource"), t) : n(h);
  }
}
function t9e(e, t, n) {
  const r = this;
  return a;
  function a(c) {
    return tJ.call(r, e, s, l, "reference", "referenceMarker", "referenceString")(c);
  }
  function s(c) {
    return r.parser.defined.includes(Qs(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(c) : n(c);
  }
  function l(c) {
    return n(c);
  }
}
function n9e(e, t, n) {
  return r;
  function r(s) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(s), e.exit("referenceMarker"), a;
  }
  function a(s) {
    return s === 93 ? (e.enter("referenceMarker"), e.consume(s), e.exit("referenceMarker"), e.exit("reference"), t) : n(s);
  }
}
const r9e = {
  name: "labelStartImage",
  resolveAll: n1.resolveAll,
  tokenize: o9e
};
function o9e(e, t, n) {
  const r = this;
  return a;
  function a(c) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(c), e.exit("labelImageMarker"), s;
  }
  function s(c) {
    return c === 91 ? (e.enter("labelMarker"), e.consume(c), e.exit("labelMarker"), e.exit("labelImage"), l) : n(c);
  }
  function l(c) {
    return c === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(c) : t(c);
  }
}
const a9e = {
  name: "labelStartLink",
  resolveAll: n1.resolveAll,
  tokenize: i9e
};
function i9e(e, t, n) {
  const r = this;
  return a;
  function a(l) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(l), e.exit("labelMarker"), e.exit("labelLink"), s;
  }
  function s(l) {
    return l === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(l) : t(l);
  }
}
const J5 = {
  name: "lineEnding",
  tokenize: s9e
};
function s9e(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), fn(e, t, "linePrefix");
  }
}
const X_ = {
  name: "thematicBreak",
  tokenize: l9e
};
function l9e(e, t, n) {
  let r = 0, a;
  return s;
  function s(f) {
    return e.enter("thematicBreak"), l(f);
  }
  function l(f) {
    return a = f, c(f);
  }
  function c(f) {
    return f === a ? (e.enter("thematicBreakSequence"), d(f)) : r >= 3 && (f === null || gt(f)) ? (e.exit("thematicBreak"), t(f)) : n(f);
  }
  function d(f) {
    return f === a ? (e.consume(f), r++, d) : (e.exit("thematicBreakSequence"), nn(f) ? fn(e, c, "whitespace")(f) : c(f));
  }
}
const Aa = {
  continuation: {
    tokenize: f9e
  },
  exit: m9e,
  name: "list",
  tokenize: d9e
}, u9e = {
  partial: !0,
  tokenize: h9e
}, c9e = {
  partial: !0,
  tokenize: p9e
};
function d9e(e, t, n) {
  const r = this, a = r.events[r.events.length - 1];
  let s = a && a[1].type === "linePrefix" ? a[2].sliceSerialize(a[1], !0).length : 0, l = 0;
  return c;
  function c(g) {
    const b = r.containerState.type || (g === 42 || g === 43 || g === 45 ? "listUnordered" : "listOrdered");
    if (b === "listUnordered" ? !r.containerState.marker || g === r.containerState.marker : dR(g)) {
      if (r.containerState.type || (r.containerState.type = b, e.enter(b, {
        _container: !0
      })), b === "listUnordered")
        return e.enter("listItemPrefix"), g === 42 || g === 45 ? e.check(X_, n, f)(g) : f(g);
      if (!r.interrupt || g === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), d(g);
    }
    return n(g);
  }
  function d(g) {
    return dR(g) && ++l < 10 ? (e.consume(g), d) : (!r.interrupt || l < 2) && (r.containerState.marker ? g === r.containerState.marker : g === 41 || g === 46) ? (e.exit("listItemValue"), f(g)) : n(g);
  }
  function f(g) {
    return e.enter("listItemMarker"), e.consume(g), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || g, e.check(
      Dk,
      // Cant be empty when interrupting.
      r.interrupt ? n : m,
      e.attempt(u9e, v, h)
    );
  }
  function m(g) {
    return r.containerState.initialBlankLine = !0, s++, v(g);
  }
  function h(g) {
    return nn(g) ? (e.enter("listItemPrefixWhitespace"), e.consume(g), e.exit("listItemPrefixWhitespace"), v) : n(g);
  }
  function v(g) {
    return r.containerState.size = s + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(g);
  }
}
function f9e(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(Dk, a, s);
  function a(c) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, fn(e, t, "listItemIndent", r.containerState.size + 1)(c);
  }
  function s(c) {
    return r.containerState.furtherBlankLines || !nn(c) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, l(c)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(c9e, t, l)(c));
  }
  function l(c) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, fn(e, e.attempt(Aa, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(c);
  }
}
function p9e(e, t, n) {
  const r = this;
  return fn(e, a, "listItemIndent", r.containerState.size + 1);
  function a(s) {
    const l = r.events[r.events.length - 1];
    return l && l[1].type === "listItemIndent" && l[2].sliceSerialize(l[1], !0).length === r.containerState.size ? t(s) : n(s);
  }
}
function m9e(e) {
  e.exit(this.containerState.type);
}
function h9e(e, t, n) {
  const r = this;
  return fn(e, a, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function a(s) {
    const l = r.events[r.events.length - 1];
    return !nn(s) && l && l[1].type === "listItemPrefixWhitespace" ? t(s) : n(s);
  }
}
const eF = {
  name: "setextUnderline",
  resolveTo: g9e,
  tokenize: v9e
};
function g9e(e, t) {
  let n = e.length, r, a, s;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (a = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !s && e[n][1].type === "definition" && (s = n);
  const l = {
    type: "setextHeading",
    start: {
      ...e[r][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  };
  return e[a][1].type = "setextHeadingText", s ? (e.splice(a, 0, ["enter", l, t]), e.splice(s + 1, 0, ["exit", e[r][1], t]), e[r][1].end = {
    ...e[s][1].end
  }) : e[r][1] = l, e.push(["exit", l, t]), e;
}
function v9e(e, t, n) {
  const r = this;
  let a;
  return s;
  function s(f) {
    let m = r.events.length, h;
    for (; m--; )
      if (r.events[m][1].type !== "lineEnding" && r.events[m][1].type !== "linePrefix" && r.events[m][1].type !== "content") {
        h = r.events[m][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || h) ? (e.enter("setextHeadingLine"), a = f, l(f)) : n(f);
  }
  function l(f) {
    return e.enter("setextHeadingLineSequence"), c(f);
  }
  function c(f) {
    return f === a ? (e.consume(f), c) : (e.exit("setextHeadingLineSequence"), nn(f) ? fn(e, d, "lineSuffix")(f) : d(f));
  }
  function d(f) {
    return f === null || gt(f) ? (e.exit("setextHeadingLine"), t(f)) : n(f);
  }
}
const y9e = {
  tokenize: b9e
};
function b9e(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    Dk,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(this.parser.constructs.flowInitial, a, fn(e, e.attempt(this.parser.constructs.flow, a, e.attempt(_Le, a)), "linePrefix"))
  );
  return n;
  function r(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(s), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function a(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const w9e = {
  resolveAll: oJ()
}, x9e = rJ("string"), S9e = rJ("text");
function rJ(e) {
  return {
    resolveAll: oJ(e === "text" ? k9e : void 0),
    tokenize: t
  };
  function t(n) {
    const r = this, a = this.parser.constructs[e], s = n.attempt(a, l, c);
    return l;
    function l(m) {
      return f(m) ? s(m) : c(m);
    }
    function c(m) {
      if (m === null) {
        n.consume(m);
        return;
      }
      return n.enter("data"), n.consume(m), d;
    }
    function d(m) {
      return f(m) ? (n.exit("data"), s(m)) : (n.consume(m), d);
    }
    function f(m) {
      if (m === null)
        return !0;
      const h = a[m];
      let v = -1;
      if (h)
        for (; ++v < h.length; ) {
          const g = h[v];
          if (!g.previous || g.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function oJ(e) {
  return t;
  function t(n, r) {
    let a = -1, s;
    for (; ++a <= n.length; )
      s === void 0 ? n[a] && n[a][1].type === "data" && (s = a, a++) : (!n[a] || n[a][1].type !== "data") && (a !== s + 2 && (n[s][1].end = n[a - 1][1].end, n.splice(s + 2, a - s - 2), a = s + 2), s = void 0);
    return e ? e(n, r) : n;
  }
}
function k9e(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], a = t.sliceStream(r);
      let s = a.length, l = -1, c = 0, d;
      for (; s--; ) {
        const f = a[s];
        if (typeof f == "string") {
          for (l = f.length; f.charCodeAt(l - 1) === 32; )
            c++, l--;
          if (l) break;
          l = -1;
        } else if (f === -2)
          d = !0, c++;
        else if (f !== -1) {
          s++;
          break;
        }
      }
      if (t._contentTypeTextTrailing && n === e.length && (c = 0), c) {
        const f = {
          type: n === e.length || d || c < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: s ? l : r.start._bufferIndex + l,
            _index: r.start._index + s,
            line: r.end.line,
            column: r.end.column - c,
            offset: r.end.offset - c
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...f.start
        }, r.start.offset === r.end.offset ? Object.assign(r, f) : (e.splice(n, 0, ["enter", f, t], ["exit", f, t]), n += 2);
      }
      n++;
    }
  return e;
}
const _9e = {
  42: Aa,
  43: Aa,
  45: Aa,
  48: Aa,
  49: Aa,
  50: Aa,
  51: Aa,
  52: Aa,
  53: Aa,
  54: Aa,
  55: Aa,
  56: Aa,
  57: Aa,
  62: XX
}, E9e = {
  91: NLe
}, C9e = {
  [-2]: X5,
  [-1]: X5,
  32: X5
}, O9e = {
  35: ILe,
  42: X_,
  45: [eF, X_],
  60: LLe,
  61: eF,
  95: X_,
  96: Q9,
  126: Q9
}, M9e = {
  38: QX,
  92: JX
}, N9e = {
  [-5]: J5,
  [-4]: J5,
  [-3]: J5,
  33: r9e,
  38: QX,
  42: fR,
  60: [aLe, qLe],
  91: a9e,
  92: [PLe, JX],
  93: n1,
  95: fR,
  96: yLe
}, A9e = {
  null: [fR, w9e]
}, R9e = {
  null: [42, 95]
}, j9e = {
  null: []
}, P9e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: R9e,
  contentInitial: E9e,
  disable: j9e,
  document: _9e,
  flow: O9e,
  flowInitial: C9e,
  insideSpan: A9e,
  string: M9e,
  text: N9e
}, Symbol.toStringTag, { value: "Module" }));
function D9e(e, t, n) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: n && n.line || 1,
    column: n && n.column || 1,
    offset: n && n.offset || 0
  };
  const a = {}, s = [];
  let l = [], c = [];
  const d = {
    attempt: R(N),
    check: R(A),
    consume: E,
    enter: _,
    exit: O,
    interrupt: R(A, {
      interrupt: !0
    })
  }, f = {
    code: null,
    containerState: {},
    defineSkip: x,
    events: [],
    now: b,
    parser: e,
    previous: null,
    sliceSerialize: v,
    sliceStream: g,
    write: h
  };
  let m = t.tokenize.call(f, d);
  return t.resolveAll && s.push(t), f;
  function h(B) {
    return l = Bi(l, B), w(), l[l.length - 1] !== null ? [] : (D(t, 0), f.events = qC(s, f.events, f), f.events);
  }
  function v(B, P) {
    return $9e(g(B), P);
  }
  function g(B) {
    return I9e(l, B);
  }
  function b() {
    const {
      _bufferIndex: B,
      _index: P,
      line: H,
      column: L,
      offset: G
    } = r;
    return {
      _bufferIndex: B,
      _index: P,
      line: H,
      column: L,
      offset: G
    };
  }
  function x(B) {
    a[B.line] = B.column, z();
  }
  function w() {
    let B;
    for (; r._index < l.length; ) {
      const P = l[r._index];
      if (typeof P == "string")
        for (B = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === B && r._bufferIndex < P.length; )
          k(P.charCodeAt(r._bufferIndex));
      else
        k(P);
    }
  }
  function k(B) {
    m = m(B);
  }
  function E(B) {
    gt(B) ? (r.line++, r.column = 1, r.offset += B === -3 ? 2 : 1, z()) : B !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    l[r._index].length && (r._bufferIndex = -1, r._index++)), f.previous = B;
  }
  function _(B, P) {
    const H = P || {};
    return H.type = B, H.start = b(), f.events.push(["enter", H, f]), c.push(H), H;
  }
  function O(B) {
    const P = c.pop();
    return P.end = b(), f.events.push(["exit", P, f]), P;
  }
  function N(B, P) {
    D(B, P.from);
  }
  function A(B, P) {
    P.restore();
  }
  function R(B, P) {
    return H;
    function H(L, G, $) {
      let K, q, Z, V;
      return Array.isArray(L) ? (
        /* c8 ignore next 1 */
        Y(L)
      ) : "tokenize" in L ? (
        // Looks like a construct.
        Y([
          /** @type {Construct} */
          L
        ])
      ) : F(L);
      function F(oe) {
        return fe;
        function fe(ie) {
          const ce = ie !== null && oe[ie], ge = ie !== null && oe.null, re = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(ce) ? ce : ce ? [ce] : [],
            ...Array.isArray(ge) ? ge : ge ? [ge] : []
          ];
          return Y(re)(ie);
        }
      }
      function Y(oe) {
        return K = oe, q = 0, oe.length === 0 ? $ : U(oe[q]);
      }
      function U(oe) {
        return fe;
        function fe(ie) {
          return V = I(), Z = oe, oe.partial || (f.currentConstruct = oe), oe.name && f.parser.constructs.disable.null.includes(oe.name) ? J() : oe.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            P ? Object.assign(Object.create(f), P) : f,
            d,
            W,
            J
          )(ie);
        }
      }
      function W(oe) {
        return B(Z, V), G;
      }
      function J(oe) {
        return V.restore(), ++q < K.length ? U(K[q]) : $;
      }
    }
  }
  function D(B, P) {
    B.resolveAll && !s.includes(B) && s.push(B), B.resolve && Oi(f.events, P, f.events.length - P, B.resolve(f.events.slice(P), f)), B.resolveTo && (f.events = B.resolveTo(f.events, f));
  }
  function I() {
    const B = b(), P = f.previous, H = f.currentConstruct, L = f.events.length, G = Array.from(c);
    return {
      from: L,
      restore: $
    };
    function $() {
      r = B, f.previous = P, f.currentConstruct = H, f.events.length = L, c = G, z();
    }
  }
  function z() {
    r.line in a && r.column < 2 && (r.column = a[r.line], r.offset += a[r.line] - 1);
  }
}
function I9e(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, a = t.end._index, s = t.end._bufferIndex;
  let l;
  if (n === a)
    l = [e[n].slice(r, s)];
  else {
    if (l = e.slice(n, a), r > -1) {
      const c = l[0];
      typeof c == "string" ? l[0] = c.slice(r) : l.shift();
    }
    s > 0 && l.push(e[a].slice(0, s));
  }
  return l;
}
function $9e(e, t) {
  let n = -1;
  const r = [];
  let a;
  for (; ++n < e.length; ) {
    const s = e[n];
    let l;
    if (typeof s == "string")
      l = s;
    else switch (s) {
      case -5: {
        l = "\r";
        break;
      }
      case -4: {
        l = `
`;
        break;
      }
      case -3: {
        l = `\r
`;
        break;
      }
      case -2: {
        l = t ? " " : "	";
        break;
      }
      case -1: {
        if (!t && a) continue;
        l = " ";
        break;
      }
      default:
        l = String.fromCharCode(s);
    }
    a = s === -2, r.push(l);
  }
  return r.join("");
}
function z9e(e) {
  const t = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      KX([P9e, ...(e || {}).extensions || []])
    ),
    content: n(QTe),
    defined: [],
    document: n(eLe),
    flow: n(y9e),
    lazy: {},
    string: n(x9e),
    text: n(S9e)
  };
  return t;
  function n(r) {
    return a;
    function a(s) {
      return D9e(t, r, s);
    }
  }
}
function T9e(e) {
  for (; !ZX(e); )
    ;
  return e;
}
const tF = /[\0\t\n\r]/g;
function L9e() {
  let e = 1, t = "", n = !0, r;
  return a;
  function a(s, l, c) {
    const d = [];
    let f, m, h, v, g;
    for (s = t + (typeof s == "string" ? s.toString() : new TextDecoder(l || void 0).decode(s)), h = 0, t = "", n && (s.charCodeAt(0) === 65279 && h++, n = void 0); h < s.length; ) {
      if (tF.lastIndex = h, f = tF.exec(s), v = f && f.index !== void 0 ? f.index : s.length, g = s.charCodeAt(v), !f) {
        t = s.slice(h);
        break;
      }
      if (g === 10 && h === v && r)
        d.push(-3), r = void 0;
      else
        switch (r && (d.push(-5), r = void 0), h < v && (d.push(s.slice(h, v)), e += v - h), g) {
          case 0: {
            d.push(65533), e++;
            break;
          }
          case 9: {
            for (m = Math.ceil(e / 4) * 4, d.push(-2); e++ < m; ) d.push(-1);
            break;
          }
          case 10: {
            d.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      h = v + 1;
    }
    return c && (r && d.push(-5), t && d.push(t), d.push(null)), d;
  }
}
const F9e = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function B9e(e) {
  return e.replace(F9e, U9e);
}
function U9e(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const r = n.charCodeAt(1), a = r === 120 || r === 88;
    return YX(n.slice(a ? 2 : 1), a ? 16 : 10);
  }
  return t1(n) || e;
}
const aJ = {}.hasOwnProperty;
function V9e(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), H9e(n)(T9e(z9e(n).document().write(L9e()(e, t, !0))));
}
function H9e(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: s(tt),
      autolinkProtocol: I,
      autolinkEmail: I,
      atxHeading: s(xe),
      blockQuote: s(ge),
      characterEscape: I,
      characterReference: I,
      codeFenced: s(re),
      codeFencedFenceInfo: l,
      codeFencedFenceMeta: l,
      codeIndented: s(re, l),
      codeText: s(le, l),
      codeTextData: I,
      data: I,
      codeFlowValue: I,
      definition: s(me),
      definitionDestinationString: l,
      definitionLabelString: l,
      definitionTitleString: l,
      emphasis: s(ve),
      hardBreakEscape: s(_e),
      hardBreakTrailing: s(_e),
      htmlFlow: s(Ge, l),
      htmlFlowData: I,
      htmlText: s(Ge, l),
      htmlTextData: I,
      image: s(Xe),
      label: l,
      link: s(tt),
      listItem: s(je),
      listItemValue: v,
      listOrdered: s(nt, h),
      listUnordered: s(nt),
      paragraph: s(cn),
      reference: U,
      referenceString: l,
      resourceDestinationString: l,
      resourceTitleString: l,
      setextHeading: s(xe),
      strong: s(pt),
      thematicBreak: s(Me)
    },
    exit: {
      atxHeading: d(),
      atxHeadingSequence: N,
      autolink: d(),
      autolinkEmail: ce,
      autolinkProtocol: ie,
      blockQuote: d(),
      characterEscapeValue: z,
      characterReferenceMarkerHexadecimal: J,
      characterReferenceMarkerNumeric: J,
      characterReferenceValue: oe,
      characterReference: fe,
      codeFenced: d(w),
      codeFencedFence: x,
      codeFencedFenceInfo: g,
      codeFencedFenceMeta: b,
      codeFlowValue: z,
      codeIndented: d(k),
      codeText: d(G),
      codeTextData: z,
      data: z,
      definition: d(),
      definitionDestinationString: O,
      definitionLabelString: E,
      definitionTitleString: _,
      emphasis: d(),
      hardBreakEscape: d(P),
      hardBreakTrailing: d(P),
      htmlFlow: d(H),
      htmlFlowData: z,
      htmlText: d(L),
      htmlTextData: z,
      image: d(K),
      label: Z,
      labelText: q,
      lineEnding: B,
      link: d($),
      listItem: d(),
      listOrdered: d(),
      listUnordered: d(),
      paragraph: d(),
      referenceString: W,
      resourceDestinationString: V,
      resourceTitleString: F,
      resource: Y,
      setextHeading: d(D),
      setextHeadingLineSequence: R,
      setextHeadingText: A,
      strong: d(),
      thematicBreak: d()
    }
  };
  iJ(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(he) {
    let ye = {
      type: "root",
      children: []
    };
    const Ee = {
      stack: [ye],
      tokenStack: [],
      config: t,
      enter: c,
      exit: f,
      buffer: l,
      resume: m,
      data: n
    }, Te = [];
    let Fe = -1;
    for (; ++Fe < he.length; )
      if (he[Fe][1].type === "listOrdered" || he[Fe][1].type === "listUnordered")
        if (he[Fe][0] === "enter")
          Te.push(Fe);
        else {
          const Ut = Te.pop();
          Fe = a(he, Ut, Fe);
        }
    for (Fe = -1; ++Fe < he.length; ) {
      const Ut = t[he[Fe][0]];
      aJ.call(Ut, he[Fe][1].type) && Ut[he[Fe][1].type].call(Object.assign({
        sliceSerialize: he[Fe][2].sliceSerialize
      }, Ee), he[Fe][1]);
    }
    if (Ee.tokenStack.length > 0) {
      const Ut = Ee.tokenStack[Ee.tokenStack.length - 1];
      (Ut[1] || nF).call(Ee, void 0, Ut[0]);
    }
    for (ye.position = {
      start: ud(he.length > 0 ? he[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: ud(he.length > 0 ? he[he.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, Fe = -1; ++Fe < t.transforms.length; )
      ye = t.transforms[Fe](ye) || ye;
    return ye;
  }
  function a(he, ye, Ee) {
    let Te = ye - 1, Fe = -1, Ut = !1, Vt, Xt, Nt, kn;
    for (; ++Te <= Ee; ) {
      const Ae = he[Te];
      switch (Ae[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Ae[0] === "enter" ? Fe++ : Fe--, kn = void 0;
          break;
        }
        case "lineEndingBlank": {
          Ae[0] === "enter" && (Vt && !kn && !Fe && !Nt && (Nt = Te), kn = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          kn = void 0;
      }
      if (!Fe && Ae[0] === "enter" && Ae[1].type === "listItemPrefix" || Fe === -1 && Ae[0] === "exit" && (Ae[1].type === "listUnordered" || Ae[1].type === "listOrdered")) {
        if (Vt) {
          let Ht = Te;
          for (Xt = void 0; Ht--; ) {
            const Zt = he[Ht];
            if (Zt[1].type === "lineEnding" || Zt[1].type === "lineEndingBlank") {
              if (Zt[0] === "exit") continue;
              Xt && (he[Xt][1].type = "lineEndingBlank", Ut = !0), Zt[1].type = "lineEnding", Xt = Ht;
            } else if (!(Zt[1].type === "linePrefix" || Zt[1].type === "blockQuotePrefix" || Zt[1].type === "blockQuotePrefixWhitespace" || Zt[1].type === "blockQuoteMarker" || Zt[1].type === "listItemIndent")) break;
          }
          Nt && (!Xt || Nt < Xt) && (Vt._spread = !0), Vt.end = Object.assign({}, Xt ? he[Xt][1].start : Ae[1].end), he.splice(Xt || Te, 0, ["exit", Vt, Ae[2]]), Te++, Ee++;
        }
        if (Ae[1].type === "listItemPrefix") {
          const Ht = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Ae[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          Vt = Ht, he.splice(Te, 0, ["enter", Ht, Ae[2]]), Te++, Ee++, Nt = void 0, kn = !0;
        }
      }
    }
    return he[ye][1]._spread = Ut, Ee;
  }
  function s(he, ye) {
    return Ee;
    function Ee(Te) {
      c.call(this, he(Te), Te), ye && ye.call(this, Te);
    }
  }
  function l() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function c(he, ye, Ee) {
    this.stack[this.stack.length - 1].children.push(he), this.stack.push(he), this.tokenStack.push([ye, Ee || void 0]), he.position = {
      start: ud(ye.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function d(he) {
    return ye;
    function ye(Ee) {
      he && he.call(this, Ee), f.call(this, Ee);
    }
  }
  function f(he, ye) {
    const Ee = this.stack.pop(), Te = this.tokenStack.pop();
    if (Te)
      Te[0].type !== he.type && (ye ? ye.call(this, he, Te[0]) : (Te[1] || nF).call(this, he, Te[0]));
    else throw new Error("Cannot close `" + he.type + "` (" + qx({
      start: he.start,
      end: he.end
    }) + "): its not open");
    Ee.position.end = ud(he.end);
  }
  function m() {
    return e1(this.stack.pop());
  }
  function h() {
    this.data.expectingFirstListItemValue = !0;
  }
  function v(he) {
    if (this.data.expectingFirstListItemValue) {
      const ye = this.stack[this.stack.length - 2];
      ye.start = Number.parseInt(this.sliceSerialize(he), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function g() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.lang = he;
  }
  function b() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.meta = he;
  }
  function x() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function w() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = he.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function k() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = he.replace(/(\r?\n|\r)$/g, "");
  }
  function E(he) {
    const ye = this.resume(), Ee = this.stack[this.stack.length - 1];
    Ee.label = ye, Ee.identifier = Qs(this.sliceSerialize(he)).toLowerCase();
  }
  function _() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.title = he;
  }
  function O() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.url = he;
  }
  function N(he) {
    const ye = this.stack[this.stack.length - 1];
    if (!ye.depth) {
      const Ee = this.sliceSerialize(he).length;
      ye.depth = Ee;
    }
  }
  function A() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function R(he) {
    const ye = this.stack[this.stack.length - 1];
    ye.depth = this.sliceSerialize(he).codePointAt(0) === 61 ? 1 : 2;
  }
  function D() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function I(he) {
    const ye = this.stack[this.stack.length - 1].children;
    let Ee = ye[ye.length - 1];
    (!Ee || Ee.type !== "text") && (Ee = Ce(), Ee.position = {
      start: ud(he.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, ye.push(Ee)), this.stack.push(Ee);
  }
  function z(he) {
    const ye = this.stack.pop();
    ye.value += this.sliceSerialize(he), ye.position.end = ud(he.end);
  }
  function B(he) {
    const ye = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const Ee = ye.children[ye.children.length - 1];
      Ee.position.end = ud(he.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(ye.type) && (I.call(this, he), z.call(this, he));
  }
  function P() {
    this.data.atHardBreak = !0;
  }
  function H() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = he;
  }
  function L() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = he;
  }
  function G() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = he;
  }
  function $() {
    const he = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const ye = this.data.referenceType || "shortcut";
      he.type += "Reference", he.referenceType = ye, delete he.url, delete he.title;
    } else
      delete he.identifier, delete he.label;
    this.data.referenceType = void 0;
  }
  function K() {
    const he = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const ye = this.data.referenceType || "shortcut";
      he.type += "Reference", he.referenceType = ye, delete he.url, delete he.title;
    } else
      delete he.identifier, delete he.label;
    this.data.referenceType = void 0;
  }
  function q(he) {
    const ye = this.sliceSerialize(he), Ee = this.stack[this.stack.length - 2];
    Ee.label = B9e(ye), Ee.identifier = Qs(ye).toLowerCase();
  }
  function Z() {
    const he = this.stack[this.stack.length - 1], ye = this.resume(), Ee = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, Ee.type === "link") {
      const Te = he.children;
      Ee.children = Te;
    } else
      Ee.alt = ye;
  }
  function V() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.url = he;
  }
  function F() {
    const he = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.title = he;
  }
  function Y() {
    this.data.inReference = void 0;
  }
  function U() {
    this.data.referenceType = "collapsed";
  }
  function W(he) {
    const ye = this.resume(), Ee = this.stack[this.stack.length - 1];
    Ee.label = ye, Ee.identifier = Qs(this.sliceSerialize(he)).toLowerCase(), this.data.referenceType = "full";
  }
  function J(he) {
    this.data.characterReferenceType = he.type;
  }
  function oe(he) {
    const ye = this.sliceSerialize(he), Ee = this.data.characterReferenceType;
    let Te;
    Ee ? (Te = YX(ye, Ee === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Te = t1(ye);
    const Fe = this.stack[this.stack.length - 1];
    Fe.value += Te;
  }
  function fe(he) {
    const ye = this.stack.pop();
    ye.position.end = ud(he.end);
  }
  function ie(he) {
    z.call(this, he);
    const ye = this.stack[this.stack.length - 1];
    ye.url = this.sliceSerialize(he);
  }
  function ce(he) {
    z.call(this, he);
    const ye = this.stack[this.stack.length - 1];
    ye.url = "mailto:" + this.sliceSerialize(he);
  }
  function ge() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function re() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function le() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function me() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function ve() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function xe() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function _e() {
    return {
      type: "break"
    };
  }
  function Ge() {
    return {
      type: "html",
      value: ""
    };
  }
  function Xe() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function tt() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function nt(he) {
    return {
      type: "list",
      ordered: he.type === "listOrdered",
      start: null,
      spread: he._spread,
      children: []
    };
  }
  function je(he) {
    return {
      type: "listItem",
      spread: he._spread,
      checked: null,
      children: []
    };
  }
  function cn() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function pt() {
    return {
      type: "strong",
      children: []
    };
  }
  function Ce() {
    return {
      type: "text",
      value: ""
    };
  }
  function Me() {
    return {
      type: "thematicBreak"
    };
  }
}
function ud(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function iJ(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? iJ(e, r) : W9e(e, r);
  }
}
function W9e(e, t) {
  let n;
  for (n in t)
    if (aJ.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function nF(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + qx({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + qx({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + qx({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function q9e(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return V9e(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function G9e(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function K9e(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function Y9e(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let a = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (a.data = { meta: t.meta }), e.patch(t, a), a = e.applyData(t, a), a = { type: "element", tagName: "pre", properties: {}, children: [a] }, e.patch(t, a), a;
}
function X9e(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function J9e(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Q9e(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), a = Xg(r.toLowerCase()), s = e.footnoteOrder.indexOf(r);
  let l, c = e.footnoteCounts.get(r);
  c === void 0 ? (c = 0, e.footnoteOrder.push(r), l = e.footnoteOrder.length) : l = s + 1, c += 1, e.footnoteCounts.set(r, c);
  const d = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + a,
      id: n + "fnref-" + a + (c > 1 ? "-" + c : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(l) }]
  };
  e.patch(t, d);
  const f = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [d]
  };
  return e.patch(t, f), e.applyData(t, f);
}
function Z9e(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function eFe(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function sJ(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const a = e.all(t), s = a[0];
  s && s.type === "text" ? s.value = "[" + s.value : a.unshift({ type: "text", value: "[" });
  const l = a[a.length - 1];
  return l && l.type === "text" ? l.value += r : a.push({ type: "text", value: r }), a;
}
function tFe(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return sJ(e, t);
  const a = { src: Xg(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (a.title = r.title);
  const s = { type: "element", tagName: "img", properties: a, children: [] };
  return e.patch(t, s), e.applyData(t, s);
}
function nFe(e, t) {
  const n = { src: Xg(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function rFe(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function oFe(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return sJ(e, t);
  const a = { href: Xg(r.url || "") };
  r.title !== null && r.title !== void 0 && (a.title = r.title);
  const s = {
    type: "element",
    tagName: "a",
    properties: a,
    children: e.all(t)
  };
  return e.patch(t, s), e.applyData(t, s);
}
function aFe(e, t) {
  const n = { href: Xg(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function iFe(e, t, n) {
  const r = e.all(t), a = n ? sFe(n) : lJ(t), s = {}, l = [];
  if (typeof t.checked == "boolean") {
    const m = r[0];
    let h;
    m && m.type === "element" && m.tagName === "p" ? h = m : (h = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(h)), h.children.length > 0 && h.children.unshift({ type: "text", value: " " }), h.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), s.className = ["task-list-item"];
  }
  let c = -1;
  for (; ++c < r.length; ) {
    const m = r[c];
    (a || c !== 0 || m.type !== "element" || m.tagName !== "p") && l.push({ type: "text", value: `
` }), m.type === "element" && m.tagName === "p" && !a ? l.push(...m.children) : l.push(m);
  }
  const d = r[r.length - 1];
  d && (a || d.type !== "element" || d.tagName !== "p") && l.push({ type: "text", value: `
` });
  const f = { type: "element", tagName: "li", properties: s, children: l };
  return e.patch(t, f), e.applyData(t, f);
}
function sFe(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = lJ(n[r]);
  }
  return t;
}
function lJ(e) {
  return e.spread ?? e.children.length > 1;
}
function lFe(e, t) {
  const n = {}, r = e.all(t);
  let a = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++a < r.length; ) {
    const l = r[a];
    if (l.type === "element" && l.tagName === "li" && l.properties && Array.isArray(l.properties.className) && l.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const s = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, s), e.applyData(t, s);
}
function uFe(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function cFe(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function dFe(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function fFe(e, t) {
  const n = e.all(t), r = n.shift(), a = [];
  if (r) {
    const l = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], l), a.push(l);
  }
  if (n.length > 0) {
    const l = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, c = XP(t.children[1]), d = BX(t.children[t.children.length - 1]);
    c && d && (l.position = { start: c, end: d }), a.push(l);
  }
  const s = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(a, !0)
  };
  return e.patch(t, s), e.applyData(t, s);
}
function pFe(e, t, n) {
  const r = n ? n.children : void 0, a = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", s = n && n.type === "table" ? n.align : void 0, l = s ? s.length : t.children.length;
  let c = -1;
  const d = [];
  for (; ++c < l; ) {
    const m = t.children[c], h = {}, v = s ? s[c] : void 0;
    v && (h.align = v);
    let g = { type: "element", tagName: a, properties: h, children: [] };
    m && (g.children = e.all(m), e.patch(m, g), g = e.applyData(m, g)), d.push(g);
  }
  const f = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(d, !0)
  };
  return e.patch(t, f), e.applyData(t, f);
}
function mFe(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const rF = 9, oF = 32;
function hFe(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), a = 0;
  const s = [];
  for (; r; )
    s.push(
      aF(t.slice(a, r.index), a > 0, !0),
      r[0]
    ), a = r.index + r[0].length, r = n.exec(t);
  return s.push(aF(t.slice(a), a > 0, !1)), s.join("");
}
function aF(e, t, n) {
  let r = 0, a = e.length;
  if (t) {
    let s = e.codePointAt(r);
    for (; s === rF || s === oF; )
      r++, s = e.codePointAt(r);
  }
  if (n) {
    let s = e.codePointAt(a - 1);
    for (; s === rF || s === oF; )
      a--, s = e.codePointAt(a - 1);
  }
  return a > r ? e.slice(r, a) : "";
}
function gFe(e, t) {
  const n = { type: "text", value: hFe(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function vFe(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const yFe = {
  blockquote: G9e,
  break: K9e,
  code: Y9e,
  delete: X9e,
  emphasis: J9e,
  footnoteReference: Q9e,
  heading: Z9e,
  html: eFe,
  imageReference: tFe,
  image: nFe,
  inlineCode: rFe,
  linkReference: oFe,
  link: aFe,
  listItem: iFe,
  list: lFe,
  paragraph: uFe,
  // @ts-expect-error: root is different, but hard to type.
  root: cFe,
  strong: dFe,
  table: fFe,
  tableCell: mFe,
  tableRow: pFe,
  text: gFe,
  thematicBreak: vFe,
  toml: d_,
  yaml: d_,
  definition: d_,
  footnoteDefinition: d_
};
function d_() {
}
const uJ = -1, GC = 0, Kx = 1, Q2 = 2, r1 = 3, o1 = 4, a1 = 5, i1 = 6, cJ = 7, dJ = 8, iF = typeof self == "object" ? self : globalThis, bFe = (e, t) => {
  const n = (a, s) => (e.set(s, a), a), r = (a) => {
    if (e.has(a))
      return e.get(a);
    const [s, l] = t[a];
    switch (s) {
      case GC:
      case uJ:
        return n(l, a);
      case Kx: {
        const c = n([], a);
        for (const d of l)
          c.push(r(d));
        return c;
      }
      case Q2: {
        const c = n({}, a);
        for (const [d, f] of l)
          c[r(d)] = r(f);
        return c;
      }
      case r1:
        return n(new Date(l), a);
      case o1: {
        const { source: c, flags: d } = l;
        return n(new RegExp(c, d), a);
      }
      case a1: {
        const c = n(/* @__PURE__ */ new Map(), a);
        for (const [d, f] of l)
          c.set(r(d), r(f));
        return c;
      }
      case i1: {
        const c = n(/* @__PURE__ */ new Set(), a);
        for (const d of l)
          c.add(r(d));
        return c;
      }
      case cJ: {
        const { name: c, message: d } = l;
        return n(new iF[c](d), a);
      }
      case dJ:
        return n(BigInt(l), a);
      case "BigInt":
        return n(Object(BigInt(l)), a);
      case "ArrayBuffer":
        return n(new Uint8Array(l).buffer, l);
      case "DataView": {
        const { buffer: c } = new Uint8Array(l);
        return n(new DataView(c), l);
      }
    }
    return n(new iF[s](l), a);
  };
  return r;
}, sF = (e) => bFe(/* @__PURE__ */ new Map(), e)(0), jh = "", { toString: wFe } = {}, { keys: xFe } = Object, fx = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [GC, t];
  const n = wFe.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [Kx, jh];
    case "Object":
      return [Q2, jh];
    case "Date":
      return [r1, jh];
    case "RegExp":
      return [o1, jh];
    case "Map":
      return [a1, jh];
    case "Set":
      return [i1, jh];
    case "DataView":
      return [Kx, n];
  }
  return n.includes("Array") ? [Kx, n] : n.includes("Error") ? [cJ, n] : [Q2, n];
}, f_ = ([e, t]) => e === GC && (t === "function" || t === "symbol"), SFe = (e, t, n, r) => {
  const a = (l, c) => {
    const d = r.push(l) - 1;
    return n.set(c, d), d;
  }, s = (l) => {
    if (n.has(l))
      return n.get(l);
    let [c, d] = fx(l);
    switch (c) {
      case GC: {
        let m = l;
        switch (d) {
          case "bigint":
            c = dJ, m = l.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + d);
            m = null;
            break;
          case "undefined":
            return a([uJ], l);
        }
        return a([c, m], l);
      }
      case Kx: {
        if (d) {
          let v = l;
          return d === "DataView" ? v = new Uint8Array(l.buffer) : d === "ArrayBuffer" && (v = new Uint8Array(l)), a([d, [...v]], l);
        }
        const m = [], h = a([c, m], l);
        for (const v of l)
          m.push(s(v));
        return h;
      }
      case Q2: {
        if (d)
          switch (d) {
            case "BigInt":
              return a([d, l.toString()], l);
            case "Boolean":
            case "Number":
            case "String":
              return a([d, l.valueOf()], l);
          }
        if (t && "toJSON" in l)
          return s(l.toJSON());
        const m = [], h = a([c, m], l);
        for (const v of xFe(l))
          (e || !f_(fx(l[v]))) && m.push([s(v), s(l[v])]);
        return h;
      }
      case r1:
        return a([c, l.toISOString()], l);
      case o1: {
        const { source: m, flags: h } = l;
        return a([c, { source: m, flags: h }], l);
      }
      case a1: {
        const m = [], h = a([c, m], l);
        for (const [v, g] of l)
          (e || !(f_(fx(v)) || f_(fx(g)))) && m.push([s(v), s(g)]);
        return h;
      }
      case i1: {
        const m = [], h = a([c, m], l);
        for (const v of l)
          (e || !f_(fx(v))) && m.push(s(v));
        return h;
      }
    }
    const { message: f } = l;
    return a([c, { name: d, message: f }], l);
  };
  return s;
}, lF = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return SFe(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, Z2 = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  ((e, t) => t && ("json" in t || "lossy" in t) ? sF(lF(e, t)) : structuredClone(e))
) : (e, t) => sF(lF(e, t));
function kFe(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function _Fe(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function EFe(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || kFe, r = e.options.footnoteBackLabel || _Fe, a = e.options.footnoteLabel || "Footnotes", s = e.options.footnoteLabelTagName || "h2", l = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, c = [];
  let d = -1;
  for (; ++d < e.footnoteOrder.length; ) {
    const f = e.footnoteById.get(
      e.footnoteOrder[d]
    );
    if (!f)
      continue;
    const m = e.all(f), h = String(f.identifier).toUpperCase(), v = Xg(h.toLowerCase());
    let g = 0;
    const b = [], x = e.footnoteCounts.get(h);
    for (; x !== void 0 && ++g <= x; ) {
      b.length > 0 && b.push({ type: "text", value: " " });
      let E = typeof n == "string" ? n : n(d, g);
      typeof E == "string" && (E = { type: "text", value: E }), b.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + v + (g > 1 ? "-" + g : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(d, g),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(E) ? E : [E]
      });
    }
    const w = m[m.length - 1];
    if (w && w.type === "element" && w.tagName === "p") {
      const E = w.children[w.children.length - 1];
      E && E.type === "text" ? E.value += " " : w.children.push({ type: "text", value: " " }), w.children.push(...b);
    } else
      m.push(...b);
    const k = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + v },
      children: e.wrap(m, !0)
    };
    e.patch(f, k), c.push(k);
  }
  if (c.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: s,
          properties: {
            ...Z2(l),
            id: "footnote-label"
          },
          children: [{ type: "text", value: a }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(c, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const KC = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  (function(e) {
    if (e == null)
      return NFe;
    if (typeof e == "function")
      return YC(e);
    if (typeof e == "object")
      return Array.isArray(e) ? CFe(e) : OFe(e);
    if (typeof e == "string")
      return MFe(e);
    throw new Error("Expected function, string, or object as test");
  })
);
function CFe(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = KC(e[n]);
  return YC(r);
  function r(...a) {
    let s = -1;
    for (; ++s < t.length; )
      if (t[s].apply(this, a)) return !0;
    return !1;
  }
}
function OFe(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return YC(n);
  function n(r) {
    const a = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let s;
    for (s in e)
      if (a[s] !== t[s]) return !1;
    return !0;
  }
}
function MFe(e) {
  return YC(t);
  function t(n) {
    return n && n.type === e;
  }
}
function YC(e) {
  return t;
  function t(n, r, a) {
    return !!(AFe(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      a || void 0
    ));
  }
}
function NFe() {
  return !0;
}
function AFe(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const fJ = [], RFe = !0, pR = !1, jFe = "skip";
function pJ(e, t, n, r) {
  let a;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : a = t;
  const s = KC(a), l = r ? -1 : 1;
  c(e, void 0, [])();
  function c(d, f, m) {
    const h = (
      /** @type {Record<string, unknown>} */
      d && typeof d == "object" ? d : {}
    );
    if (typeof h.type == "string") {
      const g = (
        // `hast`
        typeof h.tagName == "string" ? h.tagName : (
          // `xast`
          typeof h.name == "string" ? h.name : void 0
        )
      );
      Object.defineProperty(v, "name", {
        value: "node (" + (d.type + (g ? "<" + g + ">" : "")) + ")"
      });
    }
    return v;
    function v() {
      let g = fJ, b, x, w;
      if ((!t || s(d, f, m[m.length - 1] || void 0)) && (g = PFe(n(d, m)), g[0] === pR))
        return g;
      if ("children" in d && d.children) {
        const k = (
          /** @type {UnistParent} */
          d
        );
        if (k.children && g[0] !== jFe)
          for (x = (r ? k.children.length : -1) + l, w = m.concat(k); x > -1 && x < k.children.length; ) {
            const E = k.children[x];
            if (b = c(E, x, w)(), b[0] === pR)
              return b;
            x = typeof b[1] == "number" ? b[1] : x + l;
          }
      }
      return g;
    }
  }
}
function PFe(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [RFe, e] : e == null ? fJ : [e];
}
function s1(e, t, n, r) {
  let a, s, l;
  typeof t == "function" && typeof n != "function" ? (s = void 0, l = t, a = n) : (s = t, l = n, a = r), pJ(e, s, c, a);
  function c(d, f) {
    const m = f[f.length - 1], h = m ? m.children.indexOf(d) : void 0;
    return l(d, h, m);
  }
}
const mR = {}.hasOwnProperty, DFe = {};
function IFe(e, t) {
  const n = t || DFe, r = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), l = { ...yFe, ...n.handlers }, c = {
    all: f,
    applyData: zFe,
    definitionById: r,
    footnoteById: a,
    footnoteCounts: s,
    footnoteOrder: [],
    handlers: l,
    one: d,
    options: n,
    patch: $Fe,
    wrap: LFe
  };
  return s1(e, function(m) {
    if (m.type === "definition" || m.type === "footnoteDefinition") {
      const h = m.type === "definition" ? r : a, v = String(m.identifier).toUpperCase();
      h.has(v) || h.set(v, m);
    }
  }), c;
  function d(m, h) {
    const v = m.type, g = c.handlers[v];
    if (mR.call(c.handlers, v) && g)
      return g(c, m, h);
    if (c.options.passThrough && c.options.passThrough.includes(v)) {
      if ("children" in m) {
        const { children: b, ...x } = m, w = Z2(x);
        return w.children = c.all(m), w;
      }
      return Z2(m);
    }
    return (c.options.unknownHandler || TFe)(c, m, h);
  }
  function f(m) {
    const h = [];
    if ("children" in m) {
      const v = m.children;
      let g = -1;
      for (; ++g < v.length; ) {
        const b = c.one(v[g], m);
        if (b) {
          if (g && v[g - 1].type === "break" && (!Array.isArray(b) && b.type === "text" && (b.value = uF(b.value)), !Array.isArray(b) && b.type === "element")) {
            const x = b.children[0];
            x && x.type === "text" && (x.value = uF(x.value));
          }
          Array.isArray(b) ? h.push(...b) : h.push(b);
        }
      }
    }
    return h;
  }
}
function $Fe(e, t) {
  e.position && (t.position = _Te(e));
}
function zFe(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, a = e.data.hChildren, s = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const l = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: l };
      }
    n.type === "element" && s && Object.assign(n.properties, Z2(s)), "children" in n && n.children && a !== null && a !== void 0 && (n.children = a);
  }
  return n;
}
function TFe(e, t) {
  const n = t.data || {}, r = "value" in t && !(mR.call(n, "hProperties") || mR.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function LFe(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function uF(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function cF(e, t) {
  const n = IFe(e, t), r = n.one(e, void 0), a = EFe(n), s = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return a && s.children.push({ type: "text", value: `
` }, a), s;
}
function FFe(e, t) {
  return e && "run" in e ? async function(n, r) {
    const a = (
      /** @type {HastRoot} */
      cF(n, { file: r, ...t })
    );
    await e.run(a, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      cF(n, { file: r, ...e || t })
    );
  };
}
function dF(e) {
  if (e)
    throw e;
}
var Q5, fF;
function BFe() {
  if (fF) return Q5;
  fF = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, a = function(d) {
    return typeof Array.isArray == "function" ? Array.isArray(d) : t.call(d) === "[object Array]";
  }, s = function(d) {
    if (!d || t.call(d) !== "[object Object]")
      return !1;
    var f = e.call(d, "constructor"), m = d.constructor && d.constructor.prototype && e.call(d.constructor.prototype, "isPrototypeOf");
    if (d.constructor && !f && !m)
      return !1;
    var h;
    for (h in d)
      ;
    return typeof h > "u" || e.call(d, h);
  }, l = function(d, f) {
    n && f.name === "__proto__" ? n(d, f.name, {
      enumerable: !0,
      configurable: !0,
      value: f.newValue,
      writable: !0
    }) : d[f.name] = f.newValue;
  }, c = function(d, f) {
    if (f === "__proto__")
      if (e.call(d, f)) {
        if (r)
          return r(d, f).value;
      } else return;
    return d[f];
  };
  return Q5 = function d() {
    var f, m, h, v, g, b, x = arguments[0], w = 1, k = arguments.length, E = !1;
    for (typeof x == "boolean" && (E = x, x = arguments[1] || {}, w = 2), (x == null || typeof x != "object" && typeof x != "function") && (x = {}); w < k; ++w)
      if (f = arguments[w], f != null)
        for (m in f)
          h = c(x, m), v = c(f, m), x !== v && (E && v && (s(v) || (g = a(v))) ? (g ? (g = !1, b = h && a(h) ? h : []) : b = h && s(h) ? h : {}, l(x, { name: m, newValue: d(E, b, v) })) : typeof v < "u" && l(x, { name: m, newValue: v }));
    return x;
  }, Q5;
}
var UFe = BFe();
const Z5 = /* @__PURE__ */ Gc(UFe);
function hR(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function VFe() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...a) {
    let s = -1;
    const l = a.pop();
    if (typeof l != "function")
      throw new TypeError("Expected function as last argument, not " + l);
    c(null, ...a);
    function c(d, ...f) {
      const m = e[++s];
      let h = -1;
      if (d) {
        l(d);
        return;
      }
      for (; ++h < a.length; )
        (f[h] === null || f[h] === void 0) && (f[h] = a[h]);
      a = f, m ? HFe(m, c)(...f) : l(null, ...f);
    }
  }
  function r(a) {
    if (typeof a != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + a
      );
    return e.push(a), t;
  }
}
function HFe(e, t) {
  let n;
  return r;
  function r(...l) {
    const c = e.length > l.length;
    let d;
    c && l.push(a);
    try {
      d = e.apply(this, l);
    } catch (f) {
      const m = (
        /** @type {Error} */
        f
      );
      if (c && n)
        throw m;
      return a(m);
    }
    c || (d && d.then && typeof d.then == "function" ? d.then(s, a) : d instanceof Error ? a(d) : s(d));
  }
  function a(l, ...c) {
    n || (n = !0, t(l, ...c));
  }
  function s(l) {
    a(null, l);
  }
}
const bl = { basename: WFe, dirname: qFe, extname: GFe, join: KFe, sep: "/" };
function WFe(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  Ik(e);
  let n = 0, r = -1, a = e.length, s;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; a--; )
      if (e.codePointAt(a) === 47) {
        if (s) {
          n = a + 1;
          break;
        }
      } else r < 0 && (s = !0, r = a + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let l = -1, c = t.length - 1;
  for (; a--; )
    if (e.codePointAt(a) === 47) {
      if (s) {
        n = a + 1;
        break;
      }
    } else
      l < 0 && (s = !0, l = a + 1), c > -1 && (e.codePointAt(a) === t.codePointAt(c--) ? c < 0 && (r = a) : (c = -1, r = l));
  return n === r ? r = l : r < 0 && (r = e.length), e.slice(n, r);
}
function qFe(e) {
  if (Ik(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function GFe(e) {
  Ik(e);
  let t = e.length, n = -1, r = 0, a = -1, s = 0, l;
  for (; t--; ) {
    const c = e.codePointAt(t);
    if (c === 47) {
      if (l) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (l = !0, n = t + 1), c === 46 ? a < 0 ? a = t : s !== 1 && (s = 1) : a > -1 && (s = -1);
  }
  return a < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  s === 0 || // The (right-most) trimmed path component is exactly `..`.
  s === 1 && a === n - 1 && a === r + 1 ? "" : e.slice(a, n);
}
function KFe(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    Ik(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : YFe(n);
}
function YFe(e) {
  Ik(e);
  const t = e.codePointAt(0) === 47;
  let n = XFe(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function XFe(e, t) {
  let n = "", r = 0, a = -1, s = 0, l = -1, c, d;
  for (; ++l <= e.length; ) {
    if (l < e.length)
      c = e.codePointAt(l);
    else {
      if (c === 47)
        break;
      c = 47;
    }
    if (c === 47) {
      if (!(a === l - 1 || s === 1)) if (a !== l - 1 && s === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (d = n.lastIndexOf("/"), d !== n.length - 1) {
              d < 0 ? (n = "", r = 0) : (n = n.slice(0, d), r = n.length - 1 - n.lastIndexOf("/")), a = l, s = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, a = l, s = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(a + 1, l) : n = e.slice(a + 1, l), r = l - a - 1;
      a = l, s = 0;
    } else c === 46 && s > -1 ? s++ : s = -1;
  }
  return n;
}
function Ik(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const JFe = { cwd: QFe };
function QFe() {
  return "/";
}
function gR(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function ZFe(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!gR(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return e8e(e);
}
function e8e(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const a = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw a.code = "ERR_INVALID_FILE_URL_PATH", a;
      }
    }
  return decodeURIComponent(t);
}
const eA = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class mJ {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? gR(t) ? n = { path: t } : typeof t == "string" || t8e(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : JFe.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < eA.length; ) {
      const s = eA[r];
      s in n && n[s] !== void 0 && n[s] !== null && (this[s] = s === "history" ? [...n[s]] : n[s]);
    }
    let a;
    for (a in n)
      eA.includes(a) || (this[a] = n[a]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? bl.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    nA(t, "basename"), tA(t, "basename"), this.path = bl.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? bl.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    pF(this.basename, "dirname"), this.path = bl.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? bl.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (tA(t, "extname"), pF(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = bl.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    gR(t) && (t = ZFe(t)), nA(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? bl.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    nA(t, "stem"), tA(t, "stem"), this.path = bl.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const a = this.message(t, n, r);
    throw a.fatal = !0, a;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const a = this.message(t, n, r);
    return a.fatal = void 0, a;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const a = new ta(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (a.name = this.path + ":" + a.name, a.file = this.path), a.fatal = !1, this.messages.push(a), a;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function tA(e, t) {
  if (e && e.includes(bl.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + bl.sep + "`"
    );
}
function nA(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function pF(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function t8e(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const n8e = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  (function(e) {
    const t = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), n = t[e], r = function() {
      return n.apply(r, arguments);
    };
    return Object.setPrototypeOf(r, t), r;
  })
), r8e = {}.hasOwnProperty;
class l1 extends n8e {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = VFe();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new l1()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(Z5(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (aA("data", this.frozen), this.namespace[t] = n, this) : r8e.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (aA("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const a = n.call(t, ...r);
      typeof a == "function" && this.transformers.use(a);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = p_(t), r = this.parser || this.Parser;
    return rA("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), rA("process", this.parser || this.Parser), oA("process", this.compiler || this.Compiler), n ? a(void 0, n) : new Promise(a);
    function a(s, l) {
      const c = p_(t), d = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(c)
      );
      r.run(d, c, function(m, h, v) {
        if (m || !h || !v)
          return f(m);
        const g = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          h
        ), b = r.stringify(g, v);
        i8e(b) ? v.value = b : v.result = b, f(
          m,
          /** @type {VFileWithOutput<CompileResult>} */
          v
        );
      });
      function f(m, h) {
        m || !h ? l(m) : s ? s(h) : n(void 0, h);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), rA("processSync", this.parser || this.Parser), oA("processSync", this.compiler || this.Compiler), this.process(t, a), hF("processSync", "process", n), r;
    function a(s, l) {
      n = !0, dF(s), r = l;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    mF(t), this.freeze();
    const a = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? s(void 0, r) : new Promise(s);
    function s(l, c) {
      const d = p_(n);
      a.run(t, d, f);
      function f(m, h, v) {
        const g = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          h || t
        );
        m ? c(m) : l ? l(g) : r(void 0, g, v);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, a;
    return this.run(t, n, s), hF("runSync", "run", r), a;
    function s(l, c) {
      dF(l), a = c, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = p_(n), a = this.compiler || this.Compiler;
    return oA("stringify", a), mF(t), a(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, a = this.namespace;
    if (aA("use", this.frozen), t != null) if (typeof t == "function")
      d(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? c(t) : l(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function s(f) {
      if (typeof f == "function")
        d(f, []);
      else if (typeof f == "object")
        if (Array.isArray(f)) {
          const [m, ...h] = (
            /** @type {PluginTuple<Array<unknown>>} */
            f
          );
          d(m, h);
        } else
          l(f);
      else
        throw new TypeError("Expected usable value, not `" + f + "`");
    }
    function l(f) {
      if (!("plugins" in f) && !("settings" in f))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      c(f.plugins), f.settings && (a.settings = Z5(!0, a.settings, f.settings));
    }
    function c(f) {
      let m = -1;
      if (f != null) if (Array.isArray(f))
        for (; ++m < f.length; ) {
          const h = f[m];
          s(h);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + f + "`");
    }
    function d(f, m) {
      let h = -1, v = -1;
      for (; ++h < r.length; )
        if (r[h][0] === f) {
          v = h;
          break;
        }
      if (v === -1)
        r.push([f, ...m]);
      else if (m.length > 0) {
        let [g, ...b] = m;
        const x = r[v][1];
        hR(x) && hR(g) && (g = Z5(!0, x, g)), r[v] = [f, g, ...b];
      }
    }
  }
}
const o8e = new l1().freeze();
function rA(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function oA(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function aA(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function mF(e) {
  if (!hR(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function hF(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function p_(e) {
  return a8e(e) ? e : new mJ(e);
}
function a8e(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function i8e(e) {
  return typeof e == "string" || s8e(e);
}
function s8e(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const l8e = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", gF = [], vF = { allowDangerousHtml: !0 }, u8e = /^(https?|ircs?|mailto|xmpp)$/i, c8e = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  { from: "className", id: "remove-classname" },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function d8e(e) {
  const t = f8e(e), n = p8e(e);
  return m8e(t.runSync(t.parse(n), n), e);
}
function f8e(e) {
  const t = e.rehypePlugins || gF, n = e.remarkPlugins || gF, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...vF } : vF;
  return o8e().use(q9e).use(n).use(FFe, r).use(t);
}
function p8e(e) {
  const t = e.children || "", n = new mJ();
  return typeof t == "string" && (n.value = t), n;
}
function m8e(e, t) {
  const n = t.allowedElements, r = t.allowElement, a = t.components, s = t.disallowedElements, l = t.skipHtml, c = t.unwrapDisallowed, d = t.urlTransform || h8e;
  for (const m of c8e)
    Object.hasOwn(t, m.from) && "" + m.from + (m.to ? "use `" + m.to + "` instead" : "remove it") + l8e + m.id;
  return s1(e, f), NTe(e, {
    Fragment: C.Fragment,
    components: a,
    ignoreInvalidStyle: !0,
    jsx: C.jsx,
    jsxs: C.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function f(m, h, v) {
    if (m.type === "raw" && v && typeof h == "number")
      return l ? v.children.splice(h, 1) : v.children[h] = { type: "text", value: m.value }, h;
    if (m.type === "element") {
      let g;
      for (g in Y5)
        if (Object.hasOwn(Y5, g) && Object.hasOwn(m.properties, g)) {
          const b = m.properties[g], x = Y5[g];
          (x === null || x.includes(m.tagName)) && (m.properties[g] = d(String(b || ""), g, m));
        }
    }
    if (m.type === "element") {
      let g = n ? !n.includes(m.tagName) : s ? s.includes(m.tagName) : !1;
      if (!g && r && typeof h == "number" && (g = !r(m, h, v)), g && v && typeof h == "number")
        return c && m.children ? v.children.splice(h, 1, ...m.children) : v.children.splice(h, 1), h;
    }
  }
}
function h8e(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), a = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    a !== -1 && t > a || n !== -1 && t > n || r !== -1 && t > r || // It is a protocol, it should be allowed.
    u8e.test(e.slice(0, t)) ? e : ""
  );
}
function yF(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, a = n.indexOf(t);
  for (; a !== -1; )
    r++, a = n.indexOf(t, a + t.length);
  return r;
}
function g8e(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function v8e(e, t, n) {
  const r = KC((n || {}).ignore || []), a = y8e(t);
  let s = -1;
  for (; ++s < a.length; )
    pJ(e, "text", l);
  function l(d, f) {
    let m = -1, h;
    for (; ++m < f.length; ) {
      const v = f[m], g = h ? h.children : void 0;
      if (r(
        v,
        g ? g.indexOf(v) : void 0,
        h
      ))
        return;
      h = v;
    }
    if (h)
      return c(d, f);
  }
  function c(d, f) {
    const m = f[f.length - 1], h = a[s][0], v = a[s][1];
    let g = 0;
    const b = m.children.indexOf(d);
    let x = !1, w = [];
    h.lastIndex = 0;
    let k = h.exec(d.value);
    for (; k; ) {
      const E = k.index, _ = {
        index: k.index,
        input: k.input,
        stack: [...f, d]
      };
      let O = v(...k, _);
      if (typeof O == "string" && (O = O.length > 0 ? { type: "text", value: O } : void 0), O === !1 ? h.lastIndex = E + 1 : (g !== E && w.push({
        type: "text",
        value: d.value.slice(g, E)
      }), Array.isArray(O) ? w.push(...O) : O && w.push(O), g = E + k[0].length, x = !0), !h.global)
        break;
      k = h.exec(d.value);
    }
    return x ? (g < d.value.length && w.push({ type: "text", value: d.value.slice(g) }), m.children.splice(b, 1, ...w)) : w = [d], b + w.length;
  }
}
function y8e(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const a = n[r];
    t.push([b8e(a[0]), w8e(a[1])]);
  }
  return t;
}
function b8e(e) {
  return typeof e == "string" ? new RegExp(g8e(e), "g") : e;
}
function w8e(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const iA = "phrasing", sA = ["autolink", "link", "image", "label"];
function x8e() {
  return {
    transforms: [M8e],
    enter: {
      literalAutolink: k8e,
      literalAutolinkEmail: lA,
      literalAutolinkHttp: lA,
      literalAutolinkWww: lA
    },
    exit: {
      literalAutolink: O8e,
      literalAutolinkEmail: C8e,
      literalAutolinkHttp: _8e,
      literalAutolinkWww: E8e
    }
  };
}
function S8e() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: iA,
        notInConstruct: sA
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: iA,
        notInConstruct: sA
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: iA,
        notInConstruct: sA
      }
    ]
  };
}
function k8e(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function lA(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function _8e(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function E8e(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function C8e(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function O8e(e) {
  this.exit(e);
}
function M8e(e) {
  v8e(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, N8e],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), A8e]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function N8e(e, t, n, r, a) {
  let s = "";
  if (!hJ(a) || (/^w/i.test(t) && (n = t + n, t = "", s = "http://"), !R8e(n)))
    return !1;
  const l = j8e(n + r);
  if (!l[0]) return !1;
  const c = {
    type: "link",
    title: null,
    url: s + t + l[0],
    children: [{ type: "text", value: t + l[0] }]
  };
  return l[1] ? [c, { type: "text", value: l[1] }] : c;
}
function A8e(e, t, n, r) {
  return (
    // Not an expected previous character.
    !hJ(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function R8e(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function j8e(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const a = yF(e, "(");
  let s = yF(e, ")");
  for (; r !== -1 && a > s; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), s++;
  return [e, n];
}
function hJ(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || Gm(n) || WC(n)) && // If its an email, the previous character should not be a slash.
  (!t || n !== 47);
}
gJ.peek = B8e;
function P8e() {
  this.buffer();
}
function D8e(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function I8e() {
  this.buffer();
}
function $8e(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function z8e(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = Qs(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function T8e(e) {
  this.exit(e);
}
function L8e(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = Qs(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function F8e(e) {
  this.exit(e);
}
function B8e() {
  return "[";
}
function gJ(e, t, n, r) {
  const a = n.createTracker(r);
  let s = a.move("[^");
  const l = n.enter("footnoteReference"), c = n.enter("reference");
  return s += a.move(
    n.safe(n.associationId(e), { after: "]", before: s })
  ), c(), l(), s += a.move("]"), s;
}
function U8e() {
  return {
    enter: {
      gfmFootnoteCallString: P8e,
      gfmFootnoteCall: D8e,
      gfmFootnoteDefinitionLabelString: I8e,
      gfmFootnoteDefinition: $8e
    },
    exit: {
      gfmFootnoteCallString: z8e,
      gfmFootnoteCall: T8e,
      gfmFootnoteDefinitionLabelString: L8e,
      gfmFootnoteDefinition: F8e
    }
  };
}
function V8e(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: n, footnoteReference: gJ },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function n(r, a, s, l) {
    const c = s.createTracker(l);
    let d = c.move("[^");
    const f = s.enter("footnoteDefinition"), m = s.enter("label");
    return d += c.move(
      s.safe(s.associationId(r), { before: d, after: "]" })
    ), m(), d += c.move("]:"), r.children && r.children.length > 0 && (c.shift(4), d += c.move(
      (t ? `
` : " ") + s.indentLines(
        s.containerFlow(r, c.current()),
        t ? vJ : H8e
      )
    )), f(), d;
  }
}
function H8e(e, t, n) {
  return t === 0 ? e : vJ(e, t, n);
}
function vJ(e, t, n) {
  return (n ? "" : "    ") + e;
}
const W8e = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
yJ.peek = X8e;
function q8e() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: K8e },
    exit: { strikethrough: Y8e }
  };
}
function G8e() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: W8e
      }
    ],
    handlers: { delete: yJ }
  };
}
function K8e(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function Y8e(e) {
  this.exit(e);
}
function yJ(e, t, n, r) {
  const a = n.createTracker(r), s = n.enter("strikethrough");
  let l = a.move("~~");
  return l += n.containerPhrasing(e, {
    ...a.current(),
    before: l,
    after: "~"
  }), l += a.move("~~"), s(), l;
}
function X8e() {
  return "~";
}
function J8e(e) {
  return e.length;
}
function Q8e(e, t) {
  const n = t || {}, r = (n.align || []).concat(), a = n.stringLength || J8e, s = [], l = [], c = [], d = [];
  let f = 0, m = -1;
  for (; ++m < e.length; ) {
    const x = [], w = [];
    let k = -1;
    for (e[m].length > f && (f = e[m].length); ++k < e[m].length; ) {
      const E = Z8e(e[m][k]);
      if (n.alignDelimiters !== !1) {
        const _ = a(E);
        w[k] = _, (d[k] === void 0 || _ > d[k]) && (d[k] = _);
      }
      x.push(E);
    }
    l[m] = x, c[m] = w;
  }
  let h = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++h < f; )
      s[h] = bF(r[h]);
  else {
    const x = bF(r);
    for (; ++h < f; )
      s[h] = x;
  }
  h = -1;
  const v = [], g = [];
  for (; ++h < f; ) {
    const x = s[h];
    let w = "", k = "";
    x === 99 ? (w = ":", k = ":") : x === 108 ? w = ":" : x === 114 && (k = ":");
    let E = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      d[h] - w.length - k.length
    );
    const _ = w + "-".repeat(E) + k;
    n.alignDelimiters !== !1 && (E = w.length + E + k.length, E > d[h] && (d[h] = E), g[h] = E), v[h] = _;
  }
  l.splice(1, 0, v), c.splice(1, 0, g), m = -1;
  const b = [];
  for (; ++m < l.length; ) {
    const x = l[m], w = c[m];
    h = -1;
    const k = [];
    for (; ++h < f; ) {
      const E = x[h] || "";
      let _ = "", O = "";
      if (n.alignDelimiters !== !1) {
        const N = d[h] - (w[h] || 0), A = s[h];
        A === 114 ? _ = " ".repeat(N) : A === 99 ? N % 2 ? (_ = " ".repeat(N / 2 + 0.5), O = " ".repeat(N / 2 - 0.5)) : (_ = " ".repeat(N / 2), O = _) : O = " ".repeat(N);
      }
      n.delimiterStart !== !1 && !h && k.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && E === "") && (n.delimiterStart !== !1 || h) && k.push(" "), n.alignDelimiters !== !1 && k.push(_), k.push(E), n.alignDelimiters !== !1 && k.push(O), n.padding !== !1 && k.push(" "), (n.delimiterEnd !== !1 || h !== f - 1) && k.push("|");
    }
    b.push(
      n.delimiterEnd === !1 ? k.join("").replace(/ +$/, "") : k.join("")
    );
  }
  return b.join(`
`);
}
function Z8e(e) {
  return e == null ? "" : String(e);
}
function bF(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function e7e(e, t, n, r) {
  const a = n.enter("blockquote"), s = n.createTracker(r);
  s.move("> "), s.shift(2);
  const l = n.indentLines(
    n.containerFlow(e, s.current()),
    t7e
  );
  return a(), l;
}
function t7e(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function n7e(e, t) {
  return wF(e, t.inConstruct, !0) && !wF(e, t.notInConstruct, !1);
}
function wF(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function xF(e, t, n, r) {
  let a = -1;
  for (; ++a < n.unsafe.length; )
    if (n.unsafe[a].character === `
` && n7e(n.stack, n.unsafe[a]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function r7e(e, t) {
  const n = String(e);
  let r = n.indexOf(t), a = r, s = 0, l = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === a ? ++s > l && (l = s) : s = 1, a = r + t.length, r = n.indexOf(t, a);
  return l;
}
function o7e(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function a7e(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function i7e(e, t, n, r) {
  const a = a7e(n), s = e.value || "", l = a === "`" ? "GraveAccent" : "Tilde";
  if (o7e(e, n)) {
    const h = n.enter("codeIndented"), v = n.indentLines(s, s7e);
    return h(), v;
  }
  const c = n.createTracker(r), d = a.repeat(Math.max(r7e(s, a) + 1, 3)), f = n.enter("codeFenced");
  let m = c.move(d);
  if (e.lang) {
    const h = n.enter(`codeFencedLang${l}`);
    m += c.move(
      n.safe(e.lang, {
        before: m,
        after: " ",
        encode: ["`"],
        ...c.current()
      })
    ), h();
  }
  if (e.lang && e.meta) {
    const h = n.enter(`codeFencedMeta${l}`);
    m += c.move(" "), m += c.move(
      n.safe(e.meta, {
        before: m,
        after: `
`,
        encode: ["`"],
        ...c.current()
      })
    ), h();
  }
  return m += c.move(`
`), s && (m += c.move(s + `
`)), m += c.move(d), f(), m;
}
function s7e(e, t, n) {
  return (n ? "" : "    ") + e;
}
function u1(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function l7e(e, t, n, r) {
  const a = u1(n), s = a === '"' ? "Quote" : "Apostrophe", l = n.enter("definition");
  let c = n.enter("label");
  const d = n.createTracker(r);
  let f = d.move("[");
  return f += d.move(
    n.safe(n.associationId(e), {
      before: f,
      after: "]",
      ...d.current()
    })
  ), f += d.move("]: "), c(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (c = n.enter("destinationLiteral"), f += d.move("<"), f += d.move(
    n.safe(e.url, { before: f, after: ">", ...d.current() })
  ), f += d.move(">")) : (c = n.enter("destinationRaw"), f += d.move(
    n.safe(e.url, {
      before: f,
      after: e.title ? " " : `
`,
      ...d.current()
    })
  )), c(), e.title && (c = n.enter(`title${s}`), f += d.move(" " + a), f += d.move(
    n.safe(e.title, {
      before: f,
      after: a,
      ...d.current()
    })
  ), f += d.move(a), c()), l(), f;
}
function u7e(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function $S(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function eE(e, t, n) {
  const r = Pg(e), a = Pg(t);
  return r === void 0 ? a === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : a === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? a === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : a === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : a === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : a === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
bJ.peek = c7e;
function bJ(e, t, n, r) {
  const a = u7e(n), s = n.enter("emphasis"), l = n.createTracker(r), c = l.move(a);
  let d = l.move(
    n.containerPhrasing(e, {
      after: a,
      before: c,
      ...l.current()
    })
  );
  const f = d.charCodeAt(0), m = eE(
    r.before.charCodeAt(r.before.length - 1),
    f,
    a
  );
  m.inside && (d = $S(f) + d.slice(1));
  const h = d.charCodeAt(d.length - 1), v = eE(r.after.charCodeAt(0), h, a);
  v.inside && (d = d.slice(0, -1) + $S(h));
  const g = l.move(a);
  return s(), n.attentionEncodeSurroundingInfo = {
    after: v.outside,
    before: m.outside
  }, c + d + g;
}
function c7e(e, t, n) {
  return n.options.emphasis || "*";
}
function d7e(e, t) {
  let n = !1;
  return s1(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, pR;
  }), !!((!e.depth || e.depth < 3) && e1(e) && (t.options.setext || n));
}
function f7e(e, t, n, r) {
  const a = Math.max(Math.min(6, e.depth || 1), 1), s = n.createTracker(r);
  if (d7e(e, n)) {
    const m = n.enter("headingSetext"), h = n.enter("phrasing"), v = n.containerPhrasing(e, {
      ...s.current(),
      before: `
`,
      after: `
`
    });
    return h(), m(), v + `
` + (a === 1 ? "=" : "-").repeat(
      // The whole size
      v.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(v.lastIndexOf("\r"), v.lastIndexOf(`
`)) + 1)
    );
  }
  const l = "#".repeat(a), c = n.enter("headingAtx"), d = n.enter("phrasing");
  s.move(l + " ");
  let f = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...s.current()
  });
  return /^[\t ]/.test(f) && (f = $S(f.charCodeAt(0)) + f.slice(1)), f = f ? l + " " + f : l, n.options.closeAtx && (f += " " + l), d(), c(), f;
}
wJ.peek = p7e;
function wJ(e) {
  return e.value || "";
}
function p7e() {
  return "<";
}
xJ.peek = m7e;
function xJ(e, t, n, r) {
  const a = u1(n), s = a === '"' ? "Quote" : "Apostrophe", l = n.enter("image");
  let c = n.enter("label");
  const d = n.createTracker(r);
  let f = d.move("![");
  return f += d.move(
    n.safe(e.alt, { before: f, after: "]", ...d.current() })
  ), f += d.move("]("), c(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (c = n.enter("destinationLiteral"), f += d.move("<"), f += d.move(
    n.safe(e.url, { before: f, after: ">", ...d.current() })
  ), f += d.move(">")) : (c = n.enter("destinationRaw"), f += d.move(
    n.safe(e.url, {
      before: f,
      after: e.title ? " " : ")",
      ...d.current()
    })
  )), c(), e.title && (c = n.enter(`title${s}`), f += d.move(" " + a), f += d.move(
    n.safe(e.title, {
      before: f,
      after: a,
      ...d.current()
    })
  ), f += d.move(a), c()), f += d.move(")"), l(), f;
}
function m7e() {
  return "!";
}
SJ.peek = h7e;
function SJ(e, t, n, r) {
  const a = e.referenceType, s = n.enter("imageReference");
  let l = n.enter("label");
  const c = n.createTracker(r);
  let d = c.move("![");
  const f = n.safe(e.alt, {
    before: d,
    after: "]",
    ...c.current()
  });
  d += c.move(f + "]["), l();
  const m = n.stack;
  n.stack = [], l = n.enter("reference");
  const h = n.safe(n.associationId(e), {
    before: d,
    after: "]",
    ...c.current()
  });
  return l(), n.stack = m, s(), a === "full" || !f || f !== h ? d += c.move(h + "]") : a === "shortcut" ? d = d.slice(0, -1) : d += c.move("]"), d;
}
function h7e() {
  return "!";
}
kJ.peek = g7e;
function kJ(e, t, n) {
  let r = e.value || "", a = "`", s = -1;
  for (; new RegExp("(^|[^`])" + a + "([^`]|$)").test(r); )
    a += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++s < n.unsafe.length; ) {
    const l = n.unsafe[s], c = n.compilePattern(l);
    let d;
    if (l.atBreak)
      for (; d = c.exec(r); ) {
        let f = d.index;
        r.charCodeAt(f) === 10 && r.charCodeAt(f - 1) === 13 && f--, r = r.slice(0, f) + " " + r.slice(d.index + 1);
      }
  }
  return a + r + a;
}
function g7e() {
  return "`";
}
function _J(e, t) {
  const n = e1(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
EJ.peek = v7e;
function EJ(e, t, n, r) {
  const a = u1(n), s = a === '"' ? "Quote" : "Apostrophe", l = n.createTracker(r);
  let c, d;
  if (_J(e, n)) {
    const m = n.stack;
    n.stack = [], c = n.enter("autolink");
    let h = l.move("<");
    return h += l.move(
      n.containerPhrasing(e, {
        before: h,
        after: ">",
        ...l.current()
      })
    ), h += l.move(">"), c(), n.stack = m, h;
  }
  c = n.enter("link"), d = n.enter("label");
  let f = l.move("[");
  return f += l.move(
    n.containerPhrasing(e, {
      before: f,
      after: "](",
      ...l.current()
    })
  ), f += l.move("]("), d(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (d = n.enter("destinationLiteral"), f += l.move("<"), f += l.move(
    n.safe(e.url, { before: f, after: ">", ...l.current() })
  ), f += l.move(">")) : (d = n.enter("destinationRaw"), f += l.move(
    n.safe(e.url, {
      before: f,
      after: e.title ? " " : ")",
      ...l.current()
    })
  )), d(), e.title && (d = n.enter(`title${s}`), f += l.move(" " + a), f += l.move(
    n.safe(e.title, {
      before: f,
      after: a,
      ...l.current()
    })
  ), f += l.move(a), d()), f += l.move(")"), c(), f;
}
function v7e(e, t, n) {
  return _J(e, n) ? "<" : "[";
}
CJ.peek = y7e;
function CJ(e, t, n, r) {
  const a = e.referenceType, s = n.enter("linkReference");
  let l = n.enter("label");
  const c = n.createTracker(r);
  let d = c.move("[");
  const f = n.containerPhrasing(e, {
    before: d,
    after: "]",
    ...c.current()
  });
  d += c.move(f + "]["), l();
  const m = n.stack;
  n.stack = [], l = n.enter("reference");
  const h = n.safe(n.associationId(e), {
    before: d,
    after: "]",
    ...c.current()
  });
  return l(), n.stack = m, s(), a === "full" || !f || f !== h ? d += c.move(h + "]") : a === "shortcut" ? d = d.slice(0, -1) : d += c.move("]"), d;
}
function y7e() {
  return "[";
}
function c1(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function b7e(e) {
  const t = c1(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function w7e(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function OJ(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function x7e(e, t, n, r) {
  const a = n.enter("list"), s = n.bulletCurrent;
  let l = e.ordered ? w7e(n) : c1(n);
  const c = e.ordered ? l === "." ? ")" : "." : b7e(n);
  let d = t && n.bulletLastUsed ? l === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const m = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (l === "*" || l === "-") && // Empty first list item:
      m && (!m.children || !m.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (d = !0), OJ(n) === l && m
    ) {
      let h = -1;
      for (; ++h < e.children.length; ) {
        const v = e.children[h];
        if (v && v.type === "listItem" && v.children && v.children[0] && v.children[0].type === "thematicBreak") {
          d = !0;
          break;
        }
      }
    }
  }
  d && (l = c), n.bulletCurrent = l;
  const f = n.containerFlow(e, r);
  return n.bulletLastUsed = l, n.bulletCurrent = s, a(), f;
}
function S7e(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function k7e(e, t, n, r) {
  const a = S7e(n);
  let s = n.bulletCurrent || c1(n);
  t && t.type === "list" && t.ordered && (s = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + s);
  let l = s.length + 1;
  (a === "tab" || a === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (l = Math.ceil(l / 4) * 4);
  const c = n.createTracker(r);
  c.move(s + " ".repeat(l - s.length)), c.shift(l);
  const d = n.enter("listItem"), f = n.indentLines(
    n.containerFlow(e, c.current()),
    m
  );
  return d(), f;
  function m(h, v, g) {
    return v ? (g ? "" : " ".repeat(l)) + h : (g ? s : s + " ".repeat(l - s.length)) + h;
  }
}
function _7e(e, t, n, r) {
  const a = n.enter("paragraph"), s = n.enter("phrasing"), l = n.containerPhrasing(e, r);
  return s(), a(), l;
}
const E7e = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  KC([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function C7e(e, t, n, r) {
  return (e.children.some(function(a) {
    return E7e(a);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function O7e(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
MJ.peek = M7e;
function MJ(e, t, n, r) {
  const a = O7e(n), s = n.enter("strong"), l = n.createTracker(r), c = l.move(a + a);
  let d = l.move(
    n.containerPhrasing(e, {
      after: a,
      before: c,
      ...l.current()
    })
  );
  const f = d.charCodeAt(0), m = eE(
    r.before.charCodeAt(r.before.length - 1),
    f,
    a
  );
  m.inside && (d = $S(f) + d.slice(1));
  const h = d.charCodeAt(d.length - 1), v = eE(r.after.charCodeAt(0), h, a);
  v.inside && (d = d.slice(0, -1) + $S(h));
  const g = l.move(a + a);
  return s(), n.attentionEncodeSurroundingInfo = {
    after: v.outside,
    before: m.outside
  }, c + d + g;
}
function M7e(e, t, n) {
  return n.options.strong || "*";
}
function N7e(e, t, n, r) {
  return n.safe(e.value, r);
}
function A7e(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function R7e(e, t, n) {
  const r = (OJ(n) + (n.options.ruleSpaces ? " " : "")).repeat(A7e(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const NJ = {
  blockquote: e7e,
  break: xF,
  code: i7e,
  definition: l7e,
  emphasis: bJ,
  hardBreak: xF,
  heading: f7e,
  html: wJ,
  image: xJ,
  imageReference: SJ,
  inlineCode: kJ,
  link: EJ,
  linkReference: CJ,
  list: x7e,
  listItem: k7e,
  paragraph: _7e,
  root: C7e,
  strong: MJ,
  text: N7e,
  thematicBreak: R7e
};
function j7e() {
  return {
    enter: {
      table: P7e,
      tableData: SF,
      tableHeader: SF,
      tableRow: I7e
    },
    exit: {
      codeText: $7e,
      table: D7e,
      tableData: uA,
      tableHeader: uA,
      tableRow: uA
    }
  };
}
function P7e(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function D7e(e) {
  this.exit(e), this.data.inTable = void 0;
}
function I7e(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function uA(e) {
  this.exit(e);
}
function SF(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function $7e(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, z7e));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function z7e(e, t) {
  return t === "|" ? t : e;
}
function T7e(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, a = t.stringLength, s = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: v,
      table: l,
      tableCell: d,
      tableRow: c
    }
  };
  function l(g, b, x, w) {
    return f(m(g, x, w), g.align);
  }
  function c(g, b, x, w) {
    const k = h(g, x, w), E = f([k]);
    return E.slice(0, E.indexOf(`
`));
  }
  function d(g, b, x, w) {
    const k = x.enter("tableCell"), E = x.enter("phrasing"), _ = x.containerPhrasing(g, {
      ...w,
      before: s,
      after: s
    });
    return E(), k(), _;
  }
  function f(g, b) {
    return Q8e(g, {
      align: b,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: a
    });
  }
  function m(g, b, x) {
    const w = g.children;
    let k = -1;
    const E = [], _ = b.enter("table");
    for (; ++k < w.length; )
      E[k] = h(w[k], b, x);
    return _(), E;
  }
  function h(g, b, x) {
    const w = g.children;
    let k = -1;
    const E = [], _ = b.enter("tableRow");
    for (; ++k < w.length; )
      E[k] = d(w[k], g, b, x);
    return _(), E;
  }
  function v(g, b, x) {
    let w = NJ.inlineCode(g, b, x);
    return x.stack.includes("tableCell") && (w = w.replace(/\|/g, "\\$&")), w;
  }
}
function L7e() {
  return {
    exit: {
      taskListCheckValueChecked: kF,
      taskListCheckValueUnchecked: kF,
      paragraph: B7e
    }
  };
}
function F7e() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: U7e }
  };
}
function kF(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function B7e(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const a = t.children;
      let s = -1, l;
      for (; ++s < a.length; ) {
        const c = a[s];
        if (c.type === "paragraph") {
          l = c;
          break;
        }
      }
      l === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function U7e(e, t, n, r) {
  const a = e.children[0], s = typeof e.checked == "boolean" && a && a.type === "paragraph", l = "[" + (e.checked ? "x" : " ") + "] ", c = n.createTracker(r);
  s && c.move(l);
  let d = NJ.listItem(e, t, n, {
    ...r,
    ...c.current()
  });
  return s && (d = d.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, f)), d;
  function f(m) {
    return m + l;
  }
}
function V7e() {
  return [
    x8e(),
    U8e(),
    q8e(),
    j7e(),
    L7e()
  ];
}
function H7e(e) {
  return {
    extensions: [
      S8e(),
      V8e(e),
      G8e(),
      T7e(e),
      F7e()
    ]
  };
}
const W7e = {
  tokenize: J7e,
  partial: !0
}, AJ = {
  tokenize: Q7e,
  partial: !0
}, RJ = {
  tokenize: Z7e,
  partial: !0
}, jJ = {
  tokenize: eBe,
  partial: !0
}, q7e = {
  tokenize: tBe,
  partial: !0
}, PJ = {
  name: "wwwAutolink",
  tokenize: Y7e,
  previous: IJ
}, DJ = {
  name: "protocolAutolink",
  tokenize: X7e,
  previous: $J
}, nd = {
  name: "emailAutolink",
  tokenize: K7e,
  previous: zJ
}, eu = {};
function G7e() {
  return {
    text: eu
  };
}
let vm = 48;
for (; vm < 123; )
  eu[vm] = nd, vm++, vm === 58 ? vm = 65 : vm === 91 && (vm = 97);
eu[43] = nd;
eu[45] = nd;
eu[46] = nd;
eu[95] = nd;
eu[72] = [nd, DJ];
eu[104] = [nd, DJ];
eu[87] = [nd, PJ];
eu[119] = [nd, PJ];
function K7e(e, t, n) {
  const r = this;
  let a, s;
  return l;
  function l(h) {
    return !vR(h) || !zJ.call(r, r.previous) || d1(r.events) ? n(h) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), c(h));
  }
  function c(h) {
    return vR(h) ? (e.consume(h), c) : h === 64 ? (e.consume(h), d) : n(h);
  }
  function d(h) {
    return h === 46 ? e.check(q7e, m, f)(h) : h === 45 || h === 95 || Jo(h) ? (s = !0, e.consume(h), d) : m(h);
  }
  function f(h) {
    return e.consume(h), a = !0, d;
  }
  function m(h) {
    return s && a && Ea(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(h)) : n(h);
  }
}
function Y7e(e, t, n) {
  const r = this;
  return a;
  function a(l) {
    return l !== 87 && l !== 119 || !IJ.call(r, r.previous) || d1(r.events) ? n(l) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(W7e, e.attempt(AJ, e.attempt(RJ, s), n), n)(l));
  }
  function s(l) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(l);
  }
}
function X7e(e, t, n) {
  const r = this;
  let a = "", s = !1;
  return l;
  function l(h) {
    return (h === 72 || h === 104) && $J.call(r, r.previous) && !d1(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), a += String.fromCodePoint(h), e.consume(h), c) : n(h);
  }
  function c(h) {
    if (Ea(h) && a.length < 5)
      return a += String.fromCodePoint(h), e.consume(h), c;
    if (h === 58) {
      const v = a.toLowerCase();
      if (v === "http" || v === "https")
        return e.consume(h), d;
    }
    return n(h);
  }
  function d(h) {
    return h === 47 ? (e.consume(h), s ? f : (s = !0, d)) : n(h);
  }
  function f(h) {
    return h === null || J2(h) || Yn(h) || Gm(h) || WC(h) ? n(h) : e.attempt(AJ, e.attempt(RJ, m), n)(h);
  }
  function m(h) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(h);
  }
}
function J7e(e, t, n) {
  let r = 0;
  return a;
  function a(l) {
    return (l === 87 || l === 119) && r < 3 ? (r++, e.consume(l), a) : l === 46 && r === 3 ? (e.consume(l), s) : n(l);
  }
  function s(l) {
    return l === null ? n(l) : t(l);
  }
}
function Q7e(e, t, n) {
  let r, a, s;
  return l;
  function l(f) {
    return f === 46 || f === 95 ? e.check(jJ, d, c)(f) : f === null || Yn(f) || Gm(f) || f !== 45 && WC(f) ? d(f) : (s = !0, e.consume(f), l);
  }
  function c(f) {
    return f === 95 ? r = !0 : (a = r, r = void 0), e.consume(f), l;
  }
  function d(f) {
    return a || r || !s ? n(f) : t(f);
  }
}
function Z7e(e, t) {
  let n = 0, r = 0;
  return a;
  function a(l) {
    return l === 40 ? (n++, e.consume(l), a) : l === 41 && r < n ? s(l) : l === 33 || l === 34 || l === 38 || l === 39 || l === 41 || l === 42 || l === 44 || l === 46 || l === 58 || l === 59 || l === 60 || l === 63 || l === 93 || l === 95 || l === 126 ? e.check(jJ, t, s)(l) : l === null || Yn(l) || Gm(l) ? t(l) : (e.consume(l), a);
  }
  function s(l) {
    return l === 41 && r++, e.consume(l), a;
  }
}
function eBe(e, t, n) {
  return r;
  function r(c) {
    return c === 33 || c === 34 || c === 39 || c === 41 || c === 42 || c === 44 || c === 46 || c === 58 || c === 59 || c === 63 || c === 95 || c === 126 ? (e.consume(c), r) : c === 38 ? (e.consume(c), s) : c === 93 ? (e.consume(c), a) : (
      // `<` is an end.
      c === 60 || // So is whitespace.
      c === null || Yn(c) || Gm(c) ? t(c) : n(c)
    );
  }
  function a(c) {
    return c === null || c === 40 || c === 91 || Yn(c) || Gm(c) ? t(c) : r(c);
  }
  function s(c) {
    return Ea(c) ? l(c) : n(c);
  }
  function l(c) {
    return c === 59 ? (e.consume(c), r) : Ea(c) ? (e.consume(c), l) : n(c);
  }
}
function tBe(e, t, n) {
  return r;
  function r(s) {
    return e.consume(s), a;
  }
  function a(s) {
    return Jo(s) ? n(s) : t(s);
  }
}
function IJ(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || Yn(e);
}
function $J(e) {
  return !Ea(e);
}
function zJ(e) {
  return !(e === 47 || vR(e));
}
function vR(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || Jo(e);
}
function d1(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const nBe = {
  tokenize: cBe,
  partial: !0
};
function rBe() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: sBe,
        continuation: {
          tokenize: lBe
        },
        exit: uBe
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: iBe
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: oBe,
        resolveTo: aBe
      }
    }
  };
}
function oBe(e, t, n) {
  const r = this;
  let a = r.events.length;
  const s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let l;
  for (; a--; ) {
    const d = r.events[a][1];
    if (d.type === "labelImage") {
      l = d;
      break;
    }
    if (d.type === "gfmFootnoteCall" || d.type === "labelLink" || d.type === "label" || d.type === "image" || d.type === "link")
      break;
  }
  return c;
  function c(d) {
    if (!l || !l._balanced)
      return n(d);
    const f = Qs(r.sliceSerialize({
      start: l.end,
      end: r.now()
    }));
    return f.codePointAt(0) !== 94 || !s.includes(f.slice(1)) ? n(d) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), t(d));
  }
}
function aBe(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, a = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  a.end.column++, a.end.offset++, a.end._bufferIndex++;
  const s = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, a.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, l = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, s.start),
    end: Object.assign({}, s.end)
  }, c = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", a, t],
    ["exit", a, t],
    // Everything in between.
    ["enter", s, t],
    ["enter", l, t],
    ["exit", l, t],
    ["exit", s, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...c), e;
}
function iBe(e, t, n) {
  const r = this, a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s = 0, l;
  return c;
  function c(h) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(h), e.exit("gfmFootnoteCallLabelMarker"), d;
  }
  function d(h) {
    return h !== 94 ? n(h) : (e.enter("gfmFootnoteCallMarker"), e.consume(h), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", f);
  }
  function f(h) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      h === 93 && !l || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || Yn(h)
    )
      return n(h);
    if (h === 93) {
      e.exit("chunkString");
      const v = e.exit("gfmFootnoteCallString");
      return a.includes(Qs(r.sliceSerialize(v))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(h), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(h);
    }
    return Yn(h) || (l = !0), s++, e.consume(h), h === 92 ? m : f;
  }
  function m(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), s++, f) : f(h);
  }
}
function sBe(e, t, n) {
  const r = this, a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s, l = 0, c;
  return d;
  function d(b) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionLabelMarker"), f;
  }
  function f(b) {
    return b === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", m) : n(b);
  }
  function m(b) {
    if (
      // Too long.
      l > 999 || // Closing brace with nothing.
      b === 93 && !c || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      b === null || b === 91 || Yn(b)
    )
      return n(b);
    if (b === 93) {
      e.exit("chunkString");
      const x = e.exit("gfmFootnoteDefinitionLabelString");
      return s = Qs(r.sliceSerialize(x)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), v;
    }
    return Yn(b) || (c = !0), l++, e.consume(b), b === 92 ? h : m;
  }
  function h(b) {
    return b === 91 || b === 92 || b === 93 ? (e.consume(b), l++, m) : m(b);
  }
  function v(b) {
    return b === 58 ? (e.enter("definitionMarker"), e.consume(b), e.exit("definitionMarker"), a.includes(s) || a.push(s), fn(e, g, "gfmFootnoteDefinitionWhitespace")) : n(b);
  }
  function g(b) {
    return t(b);
  }
}
function lBe(e, t, n) {
  return e.check(Dk, t, e.attempt(nBe, t, n));
}
function uBe(e) {
  e.exit("gfmFootnoteDefinition");
}
function cBe(e, t, n) {
  const r = this;
  return fn(e, a, "gfmFootnoteDefinitionIndent", 5);
  function a(s) {
    const l = r.events[r.events.length - 1];
    return l && l[1].type === "gfmFootnoteDefinitionIndent" && l[2].sliceSerialize(l[1], !0).length === 4 ? t(s) : n(s);
  }
}
function dBe(e) {
  let t = (e || {}).singleTilde;
  const n = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: r
  };
  return t == null && (t = !0), {
    text: {
      126: n
    },
    insideSpan: {
      null: [n]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function r(s, l) {
    let c = -1;
    for (; ++c < s.length; )
      if (s[c][0] === "enter" && s[c][1].type === "strikethroughSequenceTemporary" && s[c][1]._close) {
        let d = c;
        for (; d--; )
          if (s[d][0] === "exit" && s[d][1].type === "strikethroughSequenceTemporary" && s[d][1]._open && // If the sizes are the same:
          s[c][1].end.offset - s[c][1].start.offset === s[d][1].end.offset - s[d][1].start.offset) {
            s[c][1].type = "strikethroughSequence", s[d][1].type = "strikethroughSequence";
            const f = {
              type: "strikethrough",
              start: Object.assign({}, s[d][1].start),
              end: Object.assign({}, s[c][1].end)
            }, m = {
              type: "strikethroughText",
              start: Object.assign({}, s[d][1].end),
              end: Object.assign({}, s[c][1].start)
            }, h = [["enter", f, l], ["enter", s[d][1], l], ["exit", s[d][1], l], ["enter", m, l]], v = l.parser.constructs.insideSpan.null;
            v && Oi(h, h.length, 0, qC(v, s.slice(d + 1, c), l)), Oi(h, h.length, 0, [["exit", m, l], ["enter", s[c][1], l], ["exit", s[c][1], l], ["exit", f, l]]), Oi(s, d - 1, c - d + 3, h), c = d + h.length - 2;
            break;
          }
      }
    for (c = -1; ++c < s.length; )
      s[c][1].type === "strikethroughSequenceTemporary" && (s[c][1].type = "data");
    return s;
  }
  function a(s, l, c) {
    const d = this.previous, f = this.events;
    let m = 0;
    return h;
    function h(g) {
      return d === 126 && f[f.length - 1][1].type !== "characterEscape" ? c(g) : (s.enter("strikethroughSequenceTemporary"), v(g));
    }
    function v(g) {
      const b = Pg(d);
      if (g === 126)
        return m > 1 ? c(g) : (s.consume(g), m++, v);
      if (m < 2 && !t) return c(g);
      const x = s.exit("strikethroughSequenceTemporary"), w = Pg(g);
      return x._open = !w || w === 2 && !!b, x._close = !b || b === 2 && !!w, l(g);
    }
  }
}
class fBe {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    pBe(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(s, l) {
      return s[0] - l[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push(t.slice()), t.length = 0;
    let a = r.pop();
    for (; a; ) {
      for (const s of a)
        t.push(s);
      a = r.pop();
    }
    this.map.length = 0;
  }
}
function pBe(e, t, n, r) {
  let a = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; a < e.map.length; ) {
      if (e.map[a][0] === t) {
        e.map[a][1] += n, e.map[a][2].push(...r);
        return;
      }
      a += 1;
    }
    e.map.push([t, n, r]);
  }
}
function mBe(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const a = e[t];
    if (n) {
      if (a[0] === "enter")
        a[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (a[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const s = r.length - 1;
          r[s] = r[s] === "left" ? "center" : "right";
        }
      } else if (a[1].type === "tableDelimiterRow")
        break;
    } else a[0] === "enter" && a[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function hBe() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: gBe,
        resolveAll: vBe
      }
    }
  };
}
function gBe(e, t, n) {
  const r = this;
  let a = 0, s = 0, l;
  return c;
  function c(z) {
    let B = r.events.length - 1;
    for (; B > -1; ) {
      const L = r.events[B][1].type;
      if (L === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      L === "linePrefix") B--;
      else break;
    }
    const P = B > -1 ? r.events[B][1].type : null, H = P === "tableHead" || P === "tableRow" ? A : d;
    return H === A && r.parser.lazy[r.now().line] ? n(z) : H(z);
  }
  function d(z) {
    return e.enter("tableHead"), e.enter("tableRow"), f(z);
  }
  function f(z) {
    return z === 124 || (l = !0, s += 1), m(z);
  }
  function m(z) {
    return z === null ? n(z) : gt(z) ? s > 1 ? (s = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(z), e.exit("lineEnding"), g) : n(z) : nn(z) ? fn(e, m, "whitespace")(z) : (s += 1, l && (l = !1, a += 1), z === 124 ? (e.enter("tableCellDivider"), e.consume(z), e.exit("tableCellDivider"), l = !0, m) : (e.enter("data"), h(z)));
  }
  function h(z) {
    return z === null || z === 124 || Yn(z) ? (e.exit("data"), m(z)) : (e.consume(z), z === 92 ? v : h);
  }
  function v(z) {
    return z === 92 || z === 124 ? (e.consume(z), h) : h(z);
  }
  function g(z) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(z) : (e.enter("tableDelimiterRow"), l = !1, nn(z) ? fn(e, b, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(z) : b(z));
  }
  function b(z) {
    return z === 45 || z === 58 ? w(z) : z === 124 ? (l = !0, e.enter("tableCellDivider"), e.consume(z), e.exit("tableCellDivider"), x) : N(z);
  }
  function x(z) {
    return nn(z) ? fn(e, w, "whitespace")(z) : w(z);
  }
  function w(z) {
    return z === 58 ? (s += 1, l = !0, e.enter("tableDelimiterMarker"), e.consume(z), e.exit("tableDelimiterMarker"), k) : z === 45 ? (s += 1, k(z)) : z === null || gt(z) ? O(z) : N(z);
  }
  function k(z) {
    return z === 45 ? (e.enter("tableDelimiterFiller"), E(z)) : N(z);
  }
  function E(z) {
    return z === 45 ? (e.consume(z), E) : z === 58 ? (l = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(z), e.exit("tableDelimiterMarker"), _) : (e.exit("tableDelimiterFiller"), _(z));
  }
  function _(z) {
    return nn(z) ? fn(e, O, "whitespace")(z) : O(z);
  }
  function O(z) {
    return z === 124 ? b(z) : z === null || gt(z) ? !l || a !== s ? N(z) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(z)) : N(z);
  }
  function N(z) {
    return n(z);
  }
  function A(z) {
    return e.enter("tableRow"), R(z);
  }
  function R(z) {
    return z === 124 ? (e.enter("tableCellDivider"), e.consume(z), e.exit("tableCellDivider"), R) : z === null || gt(z) ? (e.exit("tableRow"), t(z)) : nn(z) ? fn(e, R, "whitespace")(z) : (e.enter("data"), D(z));
  }
  function D(z) {
    return z === null || z === 124 || Yn(z) ? (e.exit("data"), R(z)) : (e.consume(z), z === 92 ? I : D);
  }
  function I(z) {
    return z === 92 || z === 124 ? (e.consume(z), D) : D(z);
  }
}
function vBe(e, t) {
  let n = -1, r = !0, a = 0, s = [0, 0, 0, 0], l = [0, 0, 0, 0], c = !1, d = 0, f, m, h;
  const v = new fBe();
  for (; ++n < e.length; ) {
    const g = e[n], b = g[1];
    g[0] === "enter" ? b.type === "tableHead" ? (c = !1, d !== 0 && (_F(v, t, d, f, m), m = void 0, d = 0), f = {
      type: "table",
      start: Object.assign({}, b.start),
      // Note: correct end is set later.
      end: Object.assign({}, b.end)
    }, v.add(n, 0, [["enter", f, t]])) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (r = !0, h = void 0, s = [0, 0, 0, 0], l = [0, n + 1, 0, 0], c && (c = !1, m = {
      type: "tableBody",
      start: Object.assign({}, b.start),
      // Note: correct end is set later.
      end: Object.assign({}, b.end)
    }, v.add(n, 0, [["enter", m, t]])), a = b.type === "tableDelimiterRow" ? 2 : m ? 3 : 1) : a && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") ? (r = !1, l[2] === 0 && (s[1] !== 0 && (l[0] = l[1], h = m_(v, t, s, a, void 0, h), s = [0, 0, 0, 0]), l[2] = n)) : b.type === "tableCellDivider" && (r ? r = !1 : (s[1] !== 0 && (l[0] = l[1], h = m_(v, t, s, a, void 0, h)), s = l, l = [s[1], n, 0, 0])) : b.type === "tableHead" ? (c = !0, d = n) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (d = n, s[1] !== 0 ? (l[0] = l[1], h = m_(v, t, s, a, n, h)) : l[1] !== 0 && (h = m_(v, t, l, a, n, h)), a = 0) : a && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") && (l[3] = n);
  }
  for (d !== 0 && _F(v, t, d, f, m), v.consume(t.events), n = -1; ++n < t.events.length; ) {
    const g = t.events[n];
    g[0] === "enter" && g[1].type === "table" && (g[1]._align = mBe(t.events, n));
  }
  return e;
}
function m_(e, t, n, r, a, s) {
  const l = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", c = "tableContent";
  n[0] !== 0 && (s.end = Object.assign({}, Fh(t.events, n[0])), e.add(n[0], 0, [["exit", s, t]]));
  const d = Fh(t.events, n[1]);
  if (s = {
    type: l,
    start: Object.assign({}, d),
    // Note: correct end is set later.
    end: Object.assign({}, d)
  }, e.add(n[1], 0, [["enter", s, t]]), n[2] !== 0) {
    const f = Fh(t.events, n[2]), m = Fh(t.events, n[3]), h = {
      type: c,
      start: Object.assign({}, f),
      end: Object.assign({}, m)
    };
    if (e.add(n[2], 0, [["enter", h, t]]), r !== 2) {
      const v = t.events[n[2]], g = t.events[n[3]];
      if (v[1].end = Object.assign({}, g[1].end), v[1].type = "chunkText", v[1].contentType = "text", n[3] > n[2] + 1) {
        const b = n[2] + 1, x = n[3] - n[2] - 1;
        e.add(b, x, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", h, t]]);
  }
  return a !== void 0 && (s.end = Object.assign({}, Fh(t.events, a)), e.add(a, 0, [["exit", s, t]]), s = void 0), s;
}
function _F(e, t, n, r, a) {
  const s = [], l = Fh(t.events, n);
  a && (a.end = Object.assign({}, l), s.push(["exit", a, t])), r.end = Object.assign({}, l), s.push(["exit", r, t]), e.add(n + 1, 0, s);
}
function Fh(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const yBe = {
  name: "tasklistCheck",
  tokenize: wBe
};
function bBe() {
  return {
    text: {
      91: yBe
    }
  };
}
function wBe(e, t, n) {
  const r = this;
  return a;
  function a(d) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(d) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(d), e.exit("taskListCheckMarker"), s)
    );
  }
  function s(d) {
    return Yn(d) ? (e.enter("taskListCheckValueUnchecked"), e.consume(d), e.exit("taskListCheckValueUnchecked"), l) : d === 88 || d === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(d), e.exit("taskListCheckValueChecked"), l) : n(d);
  }
  function l(d) {
    return d === 93 ? (e.enter("taskListCheckMarker"), e.consume(d), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), c) : n(d);
  }
  function c(d) {
    return gt(d) ? t(d) : nn(d) ? e.check({
      tokenize: xBe
    }, t, n)(d) : n(d);
  }
}
function xBe(e, t, n) {
  return fn(e, r, "whitespace");
  function r(a) {
    return a === null ? n(a) : t(a);
  }
}
function SBe(e) {
  return KX([
    G7e(),
    rBe(),
    dBe(e),
    hBe(),
    bBe()
  ]);
}
const kBe = {};
function _Be(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), n = e || kBe, r = t.data(), a = r.micromarkExtensions || (r.micromarkExtensions = []), s = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), l = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  a.push(SBe(n)), s.push(V7e()), l.push(H7e(n));
}
const f1 = ({
  availableModule: e
}) => {
  const [t, n] = M.useState(!1), r = () => n(!t), a = 150, s = e.description.length > a ? e.description.substring(0, a) + "..." : e.description;
  return /* @__PURE__ */ C.jsxs("div", { className: "module-description", children: [
    /* @__PURE__ */ C.jsx(d8e, { remarkPlugins: [_Be], children: t ? e.description.replace(/\\n/g, `
`) : s.replace(/\\n/g, `
`) }),
    e.description.length > a && /* @__PURE__ */ C.jsx("button", { onClick: r, className: "toggle-description", children: t ? "Show less" : "Show more" })
  ] });
}, EF = [
  ">=",
  "==",
  "<=",
  "<",
  ">"
], XC = ">=", p1 = ({
  availableModule: e,
  on_change: t
}) => {
  const [n, r] = M.useState(
    e.version || "latest"
  ), [a, s] = M.useState(XC), l = (d) => {
    const f = d.target.value;
    r(f), t(f !== "latest" ? a + f : f);
  }, c = (d) => {
    d.target.value !== a && EF.includes(d.target.value) && (s(d.target.value), n !== "latest" && t(d.target.value + n));
  };
  return e.releases && !e.releases.includes(n) && e.releases.unshift(n), /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
    /* @__PURE__ */ C.jsx("select", { value: a, onChange: c, children: EF.map((d) => /* @__PURE__ */ C.jsx("option", { value: d, children: d }, d)) }),
    /* @__PURE__ */ C.jsx("select", { onChange: l, value: n, children: e.releases && e.releases.map((d) => /* @__PURE__ */ C.jsx("option", { value: d, children: d }, d)) })
  ] });
}, EBe = ({
  availableModule: e,
  on_remove: t,
  on_update: n
}) => {
  const [r, a] = M.useState(
    XC + e.version || "latest"
  );
  return /* @__PURE__ */ C.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ C.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
    /* @__PURE__ */ C.jsx(GP, { availableModule: e }),
    /* @__PURE__ */ C.jsx(f1, { availableModule: e }),
    /* @__PURE__ */ C.jsxs("div", { children: [
      /* @__PURE__ */ C.jsx(
        p1,
        {
          availableModule: e,
          on_change: a
        }
      ),
      /* @__PURE__ */ C.jsx(
        "button",
        {
          className: "update-button",
          disabled: r === e.version,
          onClick: () => {
            n(e, r);
          },
          children: "Update"
        }
      ),
      /* @__PURE__ */ C.jsx(
        "button",
        {
          className: "remove-button",
          onClick: () => {
            t(e);
          },
          children: "Remove"
        }
      )
    ] })
  ] });
}, CBe = ({
  availableModule: e,
  on_add: t
}) => {
  const [n, r] = M.useState(
    XC + e.version || "latest"
  );
  return /* @__PURE__ */ C.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ C.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
    /* @__PURE__ */ C.jsx(GP, { availableModule: e }),
    /* @__PURE__ */ C.jsx(f1, { availableModule: e }),
    /* @__PURE__ */ C.jsxs("div", { children: [
      /* @__PURE__ */ C.jsx(
        p1,
        {
          availableModule: e,
          on_change: r
        }
      ),
      /* @__PURE__ */ C.jsx(
        "button",
        {
          className: "add-button",
          onClick: () => {
            t(e, n);
          },
          children: "Add"
        }
      )
    ] })
  ] });
}, OBe = ({
  availableModule: e,
  on_add: t
}) => {
  const [n, r] = M.useState(
    XC + e.version || "latest"
  );
  return /* @__PURE__ */ C.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ C.jsx("div", { className: "module-name", children: e.name }),
    /* @__PURE__ */ C.jsx(GP, { availableModule: e }),
    /* @__PURE__ */ C.jsx(f1, { availableModule: e }),
    /* @__PURE__ */ C.jsxs("div", { children: [
      /* @__PURE__ */ C.jsx(
        p1,
        {
          availableModule: e,
          on_change: r
        }
      ),
      /* @__PURE__ */ C.jsx(
        "button",
        {
          className: "add-button",
          onClick: () => {
            t(e, n);
          },
          children: "Add"
        }
      )
    ] })
  ] });
}, MBe = ({
  ins: e
}) => {
  const [t, n] = M.useState(e.name), r = Sn(), { lib: a } = Oa(), s = () => {
    r.worker && a?.remove_external_worker(e.uuid, e.nodeclassid);
  }, l = () => {
    r.worker && (r.worker.update_external_worker(e.uuid, e.nodeclassid, {
      name: t
    }), e.name = t);
  };
  return /* @__PURE__ */ C.jsx(C.Fragment, { children: /* @__PURE__ */ C.jsx(
    Yl,
    {
      title: e.name,
      description: "Settings for " + e.name,
      trigger: /* @__PURE__ */ C.jsx("div", { children: "Settings" }),
      buttons: [
        {
          text: "Save",
          onClick: l,
          close: !0
        },
        {
          text: "Delete",
          onClick: s,
          close: !0
        }
      ],
      children: /* @__PURE__ */ C.jsxs("div", { children: [
        /* @__PURE__ */ C.jsxs("div", { children: [
          /* @__PURE__ */ C.jsx("label", { htmlFor: "name", children: "Name: " }),
          /* @__PURE__ */ C.jsx(
            "input",
            {
              type: "text",
              name: "name",
              value: t,
              onChange: (c) => n(c.target.value),
              className: "styledinput"
            }
          )
        ] }),
        a && /* @__PURE__ */ C.jsx(
          SY,
          {
            getter: () => a.get_external_worker_config(e.uuid, e.nodeclassid),
            setter: async (c) => {
              if (r.worker)
                return await r.worker.update_external_worker(
                  e.uuid,
                  e.nodeclassid,
                  {
                    name: t,
                    config: c
                  }
                );
            },
            setter_calls_getter: !0
          }
        )
      ] })
    }
  ) });
}, NBe = ({
  ins: e,
  lib: t,
  filter: n = "",
  parentkey: r
}) => {
  const [a, s] = M.useState(!1), l = () => s(!a), c = t?.nodes?.filter(
    (d) => d.node_id.toLowerCase().includes(n.toLowerCase())
  );
  return /* @__PURE__ */ C.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ C.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: l,
        style: { cursor: "pointer" },
        title: e.name,
        children: [
          /* @__PURE__ */ C.jsx("div", { className: "shelftitle_text", children: e.name }),
          /* @__PURE__ */ C.jsx("div", { className: "expandicon " + (a ? "open" : "close"), children: /* @__PURE__ */ C.jsx(nk, {}) })
        ]
      }
    ),
    /* @__PURE__ */ C.jsx("div", { className: "libnodecontainer " + (a ? "open" : "close"), children: /* @__PURE__ */ C.jsx("div", { className: "libnodecontainer_inner", children: a && /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
      /* @__PURE__ */ C.jsx("div", { className: "libnodeentry", title: e.uuid, children: /* @__PURE__ */ C.jsx(MBe, { ins: e }) }),
      t && /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
        c && /* @__PURE__ */ C.jsx(C.Fragment, { children: c.map((d) => /* @__PURE__ */ C.jsx(
          jX,
          {
            item: d
          },
          r + d.node_id
        )) }),
        t.subshelves.map((d) => /* @__PURE__ */ C.jsx(
          qP,
          {
            item: d,
            filter: n,
            parentkey: r + d.name
          },
          r + d.name
        ))
      ] })
    ] }) }) })
  ] });
}, ABe = ({
  item: e,
  mod: t,
  lib: n
}) => {
  const { lib: r } = Oa(), [a, s] = M.useState(!1), l = () => s(!a), c = M.useCallback(() => {
    r?.add_external_worker({
      module: t,
      cls_module: e.module,
      cls_name: e.class_name
    });
  }, [r, t, e]), d = (m) => {
    m.detail === 2 && c();
  }, f = e.name || e.module + "." + e.class_name;
  return /* @__PURE__ */ C.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ C.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: l,
        style: { cursor: "pointer" },
        title: f,
        children: [
          /* @__PURE__ */ C.jsx("div", { className: "shelftitle_text", children: f }),
          /* @__PURE__ */ C.jsx("div", { className: "expandicon " + (a ? "open" : "close"), children: /* @__PURE__ */ C.jsx(nk, {}) })
        ]
      }
    ),
    /* @__PURE__ */ C.jsx("div", { className: "libnodecontainer " + (a ? "open" : "close"), children: /* @__PURE__ */ C.jsx("div", { className: "libnodecontainer_inner", children: a && /* @__PURE__ */ C.jsxs(C.Fragment, { children: [
      /* @__PURE__ */ C.jsx(
        "div",
        {
          className: "libnodeentry",
          onClick: d,
          title: e.name,
          children: "New Instance"
        }
      ),
      e.instances.map((m) => /* @__PURE__ */ C.jsx(
        NBe,
        {
          ins: m,
          lib: n?.subshelves.find(
            (h) => h.name === m.uuid
          ),
          parentkey: m.uuid
        },
        m.uuid
      ))
    ] }) }) })
  ] });
}, RBe = ({
  externalworkermod: e,
  lib: t
}) => {
  const [n, r] = M.useState(!1), a = () => r(!n), s = n;
  return /* @__PURE__ */ C.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ C.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: a,
        style: { cursor: "pointer" },
        title: e.module,
        children: [
          /* @__PURE__ */ C.jsx("div", { className: "shelftitle_text", children: e.module }),
          /* @__PURE__ */ C.jsx("div", { className: "expandicon " + (s ? "open" : "close"), children: /* @__PURE__ */ C.jsx(nk, {}) })
        ]
      }
    ),
    /* @__PURE__ */ C.jsx("div", { className: "libnodecontainer " + (s ? "open" : "close"), children: /* @__PURE__ */ C.jsx("div", { className: "libnodecontainer_inner", children: e.worker_classes.map((l) => /* @__PURE__ */ C.jsx(
      ABe,
      {
        item: l,
        mod: e.module,
        lib: t
      },
      l.module + l.class_name
    )) }) }),
    /* @__PURE__ */ C.jsx("hr", {})
  ] });
}, jBe = () => {
  const e = Sn(), t = e.lib.libstate(), n = e.local_settings(
    (d) => d.view_settings.expand_lib
  ), r = (d) => {
    e.update_view_settings({ expand_lib: d });
  }, a = R$e("m"), [s, l] = M.useState(""), c = e.workerstate((d) => d.is_open);
  return /* @__PURE__ */ C.jsx(
    MP,
    {
      maxSize: a ? "100%" : "18.75rem",
      direction: a ? "down" : "right",
      containerClassName: "pos-left pos-top bg1 h-12",
      onExpandChange: r,
      expanded: n === void 0 ? !0 : n,
      collapseIcons: {
        up: m2,
        down: iS,
        left: aS,
        right: p2
      },
      expandIcons: {
        up: iS,
        down: m2,
        left: p2,
        right: aS
      },
      children: /* @__PURE__ */ C.jsxs("div", { className: "libcontainer", children: [
        /* @__PURE__ */ C.jsxs("div", { className: "library", children: [
          /* @__PURE__ */ C.jsx("div", { className: "libtitle", children: "Lib" }),
          /* @__PURE__ */ C.jsx("hr", { className: "hr_prominent" }),
          /* @__PURE__ */ C.jsx(Zze, { filter: s, setFilter: l }),
          /* @__PURE__ */ C.jsx("div", { className: "vscrollcontainer", children: t.lib.shelves.filter((d) => d.name !== "_external_worker").map((d) => /* @__PURE__ */ C.jsx(
            qP,
            {
              item: d,
              filter: s,
              parentkey: d.name
            },
            d.name
          )) }),
          /* @__PURE__ */ C.jsx("hr", {}),
          /* @__PURE__ */ C.jsx("div", { className: "libtitle", children: "External Worker" }),
          /* @__PURE__ */ C.jsx("hr", { className: "hr_prominent" }),
          /* @__PURE__ */ C.jsx("div", { className: "vscrollcontainer", children: t.external_worker?.map((d) => /* @__PURE__ */ C.jsx(
            RBe,
            {
              externalworkermod: d,
              lib: t.lib.shelves.find(
                (f) => f.name === "_external_worker"
              )
            },
            d.module
          )) }),
          /* @__PURE__ */ C.jsx("hr", {})
        ] }),
        c && /* @__PURE__ */ C.jsx("div", { className: "addlib", children: /* @__PURE__ */ C.jsx(eTe, { children: /* @__PURE__ */ C.jsx("button", { children: "Manage Libraries" }) }) })
      ] })
    }
  );
}, PBe = ({
  fnrf_zst: e,
  header: t,
  flow: n,
  library: r
}) => {
  const [a, s] = M.useState(
    e.options.worker || e.getWorkerManager().worker
  ), l = M.useRef(null);
  e.workermanager && (e.workermanager.on_setWorker = s), M.useEffect(() => {
    e.auto_progress();
  }, []), M.useEffect(() => {
    e.local_state.setState({ funcnodescontainerRef: l.current });
  }, [l]);
  const c = e.plugins();
  return /* @__PURE__ */ C.jsx(y$e, { plugins: c, fnrf_zst: e, children: /* @__PURE__ */ C.jsx(_ce, { children: /* @__PURE__ */ C.jsx(OU.Provider, { value: e, children: /* @__PURE__ */ C.jsx(gd, { asChild: !0, children: /* @__PURE__ */ C.jsx(Oc, { asChild: !0, children: /* @__PURE__ */ C.jsx(
    MY,
    {
      style: {
        height: "100%",
        width: "100%",
        display: "flex",
        flexDirection: "column",
        flex: 1
      },
      children: /* @__PURE__ */ C.jsxs(
        "div",
        {
          ref: l,
          className: "funcnodesreactflowcontainer funcnodescontainer",
          children: [
            t.show && /* @__PURE__ */ C.jsx(Qze, { ...t }),
            /* @__PURE__ */ C.jsxs("div", { className: "funcnodesreactflowbody", children: [
              /* @__PURE__ */ C.jsx(A6e, { ...n }),
              a && r.show && /* @__PURE__ */ C.jsx(jBe, {}),
              a && n.showNodeSettings && /* @__PURE__ */ C.jsx($$e, {})
            ] }),
            /* @__PURE__ */ C.jsxs("div", { className: "funcnodesflaotingmenu", children: [
              /* @__PURE__ */ C.jsx(Oc.OutFullScreen, { children: n.allowExpand && /* @__PURE__ */ C.jsxs(gd.Trigger, { children: [
                /* @__PURE__ */ C.jsx(gd.Expanded, { children: /* @__PURE__ */ C.jsx(
                  mce,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) }),
                /* @__PURE__ */ C.jsx(gd.Collapsed, { children: /* @__PURE__ */ C.jsx(
                  hce,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) })
              ] }) }),
              n.allowFullScreen && /* @__PURE__ */ C.jsxs(Oc.Trigger, { children: [
                /* @__PURE__ */ C.jsx(Oc.OutFullScreen, { children: /* @__PURE__ */ C.jsx(
                  CU,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) }),
                /* @__PURE__ */ C.jsx(Oc.InFullScreen, { children: /* @__PURE__ */ C.jsx(
                  pce,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) })
              ] })
            ] })
          ]
        }
      )
    }
  ) }) }) }) }) });
};
class Jg {
  constructor(t) {
    this.context = t;
  }
  get nodespaceManager() {
    return this.context.rf.getNodespaceManager();
  }
  get libManager() {
    return this.context.rf.getLibManager();
  }
  get workerManager() {
    return this.context.rf.getWorkerManager();
  }
  get stateManager() {
    return this.context.rf.getStateManager();
  }
  get pluginManager() {
    return this.context.rf.getPluginManager();
  }
  get reactFlowManager() {
    return this.context.rf.getReactFlowManager();
  }
}
const CF = ({
  src_nid: e,
  src_ioid: t,
  trg_nid: n,
  trg_ioid: r
}) => [`${e}:${t}`, `${n}:${r}`].sort().join("--"), DBe = ({}) => {
  const e = /* @__PURE__ */ new Map();
  return {
    nodesstates: e,
    get_node: (t, n = !0) => {
      const r = e.get(t);
      if (!r && n) {
        const a = e.keys();
        throw new Error(
          `Node ${t} not found, available nodes: ${Array.from(a)}`
        );
      }
      return r;
    }
  };
};
class IBe extends Jg {
  constructor(t) {
    super(t), this.on_node_action = (n) => {
      switch (n.type) {
        case "add":
          return this._add_node(n);
        case "update":
          return this._update_node(n);
        case "delete":
          return this._delete_node(n);
        case "error":
          return this._error_action(n);
        case "trigger":
          return this._trigger_action(n);
        default:
          this.context.rf.logger.error("Unknown node action", n);
          return;
      }
    }, this.on_edge_action = (n) => {
      const r = this.reactFlowManager.useReactFlowStore.getState();
      switch (n.type) {
        case "add":
          if (n.from_remote) {
            const a = r.getEdges(), s = CF(n);
            if (a.some((c) => c.id === s))
              return;
            const l = {
              id: s,
              source: n.src_nid,
              target: n.trg_nid,
              sourceHandle: n.src_ioid,
              targetHandle: n.trg_ioid,
              className: "funcnodes-edge animated",
              zIndex: 1003
              // just above elevated groups
            };
            this.context.rf.logger.info("Adding edge", l), r.update_edges([...a, l]), this.workerManager.worker?.api.node.get_remote_node_state(
              n.src_nid
            ), this.workerManager.worker?.api.node.get_remote_node_state(
              n.trg_nid
            );
          }
          break;
        case "delete":
          if (n.from_remote) {
            const a = r.getEdges(), s = CF(n);
            this.context.rf.logger.info("Deleting edge", s);
            const l = a.filter((c) => c.id !== s);
            r.update_edges(l), this.workerManager.worker?.api.node.get_remote_node_state(
              n.src_nid
            ), this.workerManager.worker?.api.node.get_remote_node_state(
              n.trg_nid
            );
          }
          break;
        default:
          this.context.rf.logger.error("Unknown edge action", n);
      }
    }, this.on_group_action = (n) => {
      switch (n.type) {
        case "set":
          return this._set_groups(n.groups);
        case "update":
          return this._update_group(n);
        default:
          this.context.rf.logger.error("Unknown group action", n);
      }
    }, this.clear_all = () => {
      this.context.rf.logger.debug("Clearing all nodespace"), this.workerManager.worker?.disconnect(), this.workerManager.set_worker(void 0), this.workerManager.workermanager?.setWorker(void 0), this.libManager.lib.libstate.getState().set({ lib: { shelves: [] }, external_worker: [] }), this.nodespace.nodesstates.clear(), this.reactFlowManager.useReactFlowStore.getState().update_nodes([]), this.reactFlowManager.useReactFlowStore.getState().update_edges([]), this.stateManager.auto_progress();
    }, this.center_node = (n) => {
      if (!this.reactFlowManager.rf_instance)
        return;
      n = Array.isArray(n) ? n : [n];
      const r = this.reactFlowManager.useReactFlowStore.getState().getNodes().filter((a) => n.includes(a.id));
      r.length > 0 && this.reactFlowManager.rf_instance?.fitView({ padding: 0.2, nodes: r });
    }, this.auto_resize_group = (n) => {
      const r = this.reactFlowManager.useReactFlowStore.getState(), a = r.getNode(n);
      if (a === void 0 || a.type !== "group")
        return;
      const s = a.data.group.node_ids.map((m) => r.getNode(m)).filter((m) => m !== void 0), l = a.data.group.child_groups.map((m) => r.getNode(m)).filter((m) => m !== void 0), c = [...s, ...l], d = this.reactFlowManager.rf_instance?.getNodesBounds(c);
      if (d === void 0)
        return;
      const f = {
        ...a,
        position: {
          x: d.x,
          y: d.y
        },
        height: d.height,
        width: d.width
      };
      f.data.group.position = [d.x, d.y], r.partial_update_nodes([f]);
    }, this.change_group_position = (n) => {
      if (n.position === void 0)
        return;
      const r = this.reactFlowManager.useReactFlowStore.getState(), a = r.getNode(n.id);
      if (a === void 0 || a.type !== "group")
        return;
      const s = [
        ...a.data.group.node_ids,
        ...a.data.group.child_groups
      ], l = this.reactFlowManager.rf_instance?.getNodesBounds(s);
      if (l === void 0)
        return;
      const c = n.position.x - l?.x, d = n.position.y - l?.y, f = [];
      for (const m of s) {
        const h = r.getNode(m);
        h !== void 0 && f.push({
          id: m,
          type: "position",
          position: {
            x: h.position.x + c,
            y: h.position.y + d
          }
        });
      }
      r.onNodesChange(f);
    }, this.change_fn_node_position = (n) => {
      n.position !== void 0 && this.on_node_action({
        type: "update",
        id: n.id,
        node: {
          properties: {
            "frontend:pos": [n.position.x, n.position.y]
          }
        },
        from_remote: !1
      });
    }, this.change_group_dimensions = (n) => {
      if (n.dimensions === void 0)
        return;
      const r = this.reactFlowManager.useReactFlowStore.getState().getNode(n.id);
      r !== void 0 && this.reactFlowManager.useReactFlowStore.getState().partial_update_nodes(wj([n], [r]));
    }, this.change_fn_node_dimensions = (n) => {
      n.dimensions !== void 0 && this.on_node_action({
        type: "update",
        id: n.id,
        node: {
          properties: {
            "frontend:size": [n.dimensions.width, n.dimensions.height]
          }
        },
        from_remote: !1
      });
    }, this._update_group = (n) => {
      if (n.from_remote) {
        const r = this.reactFlowManager.useReactFlowStore.getState(), a = r.getNode(n.id);
        if (a === void 0 || a.type !== "group")
          return;
        const { new_obj: s, change: l } = Ed(a.data.group, n.group);
        l && (a.data.group = s), r.partial_update_nodes([a]);
      } else
        this.workerManager.worker && this.workerManager.worker.api.group.locally_update_group(n);
    }, this._set_groups = (n) => {
      const r = this.reactFlowManager.useReactFlowStore.getState(), { default_nodes: a } = PP(r.getNodes()), s = [...a], l = {};
      for (const d in n) {
        const f = n[d];
        for (const h of f.node_ids)
          l[h] = d;
        for (const h of f.child_groups)
          l[h] = d;
        f.position === void 0 && (f.position = [0, 0]);
        const m = {
          id: d,
          type: "group",
          data: { group: n[d], id: d },
          position: { x: f.position[0], y: f.position[1] },
          zIndex: 2
        };
        f.parent_group && (m.data.groupID = f.parent_group), s.push(m);
      }
      for (const d of s)
        d.id in l ? d.data.groupID = l[d.id] : d.data.groupID = void 0;
      const c = DP(s);
      r.update_nodes(c);
      for (const d of c.reverse())
        d.type === "group" && this.auto_resize_group(d.id);
    }, this._add_node = (n) => {
      this.context.rf.logger.info("add node", n);
      const r = this.reactFlowManager.useReactFlowStore.getState();
      if (n.from_remote) {
        let a = this.nodespace.get_node(n.node.id, !1);
        if (a)
          return;
        if (!a)
          try {
            a = S6e(n.node), this.nodespace.nodesstates.set(n.node.id, a);
          } catch (d) {
            this.context.rf.logger.error(`Failed to create node store ${d}`);
            return;
          }
        const s = a.getState();
        this.context.rf.logger.info("Add node", s.id, s.name);
        const l = N6e(a, this.context.rf), c = [...r.getNodes(), l];
        this.reactFlowManager.useReactFlowStore.getState().update_nodes(c);
        for (const d of l.io_order)
          this.workerManager.worker?.api.node.get_io_value({
            nid: l.id,
            ioid: d
          });
        return setTimeout(() => {
          this.workerManager.worker?.api.hooks.call_hooks("node_added", {
            node: s.id
          });
        }, 0), s;
      }
    }, this._update_node = (n) => {
      if (Object.keys(n.node).length === 0) {
        this.context.rf.logger.error(
          "Node update is empty",
          new Error(JSON.stringify(n))
        );
        return;
      }
      if (n.node.in_trigger && (n.node.error = void 0), n.from_remote) {
        const r = this.nodespace.get_node(n.id, !1);
        if (!r) {
          console.error("Node not found to update", n.id);
          return;
        }
        return r.update(n.node), r.getState();
      } else
        this.workerManager.worker && this.workerManager.worker.api.node.locally_update_node(n);
    }, this._sync_nodes = () => {
      const n = this.reactFlowManager.useReactFlowStore.getState().getNodes(), r = this.nodespace.nodesstates;
      for (const a of r.keys())
        n.some((s) => s.id === a) || r.delete(a);
    }, this._delete_node = (n) => {
      this.context.rf.logger.info("Deleting node", n.id), n.from_remote ? (this.reactFlowManager.useReactFlowStore.getState().onNodesChange([
        {
          type: "remove",
          id: n.id
        }
      ]), this._sync_nodes()) : this.workerManager.worker?.api.node.remove_node(n.id);
    }, this._error_action = (n) => (this.context.rf.logger.error("Error", new Error(JSON.stringify(n))), this.on_node_action({
      type: "update",
      id: n.id,
      node: {
        in_trigger: !1,
        error: n.error
      },
      from_remote: !0
    })), this._trigger_action = (n) => {
      if (n.from_remote)
        return this.on_node_action({
          type: "update",
          id: n.id,
          node: {
            in_trigger: !0,
            error: void 0
          },
          from_remote: !0
        });
      this.workerManager.worker?.api.node.trigger_node(n.id);
    }, this.nodespace = DBe({});
  }
  center_all() {
    this.reactFlowManager.rf_instance?.fitView({ padding: 0.2 });
  }
}
const $Be = () => ({
  libstate: Hi((e, t) => ({
    lib: {
      shelves: []
    },
    external_worker: [],
    set: (n) => e((r) => ({ ...r, ...n })),
    get_lib: () => t().lib,
    get_external_worker: () => t().external_worker
  }))
});
class zBe extends Jg {
  constructor(t) {
    super(t), this.lib = $Be();
  }
}
class TBe extends Jg {
  constructor(t) {
    super(t), t.rf.logger.debug("Initializing worker manager handler"), this.workers = Hi((n, r) => ({})), this.workerstate = Hi((n, r) => ({
      is_open: !1
    }));
  }
  set_worker(t) {
    t !== this.worker && (this._unsubscribeFromWorker && (this._unsubscribeFromWorker(), this._unsubscribeFromWorker = void 0), t ? (this.context.rf.logger.debug("Setting worker in worker manager"), this._unsubscribeFromWorker = t.state.subscribe((n) => {
      this.workerstate.setState(n);
    }), this.workerstate.setState(t.state.getState())) : this.context.rf.logger.debug("Removing worker in worker manager"), this.worker = t, t?.set_zustand(this.context.rf));
  }
}
class LBe extends Jg {
  constructor(t) {
    super(t), this.progress_state = Hi((n, r) => ({
      message: "please select worker",
      status: "info",
      progress: 0,
      blocking: !1
    })), this.local_settings = Hi(
      (n, r) => ({
        view_settings: {
          expand_node_props: !1,
          expand_lib: !1
        }
      })
    ), this.local_state = Hi((n, r) => ({
      selected_nodes: [],
      selected_edges: [],
      selected_groups: [],
      funcnodescontainerRef: null
    }));
  }
  set_progress(t) {
    if (t.message === "")
      return this.auto_progress();
    const n = this.progress_state.getState(), { new_obj: r, change: a } = Ed(n, t);
    a && this.progress_state.setState(r);
  }
  auto_progress() {
    const t = this.workerManager.workermanager, n = this.workerManager.worker;
    if (t !== void 0 && !t.open)
      return this.set_progress({
        progress: 0,
        message: "connecting to worker manager",
        status: "error",
        blocking: !1
      });
    if (n === void 0)
      return this.set_progress({
        progress: 0,
        message: "please select worker",
        status: "error",
        blocking: !1
      });
    if (!n.is_open)
      return this.set_progress({
        progress: 0,
        message: "connecting to worker",
        status: "info",
        blocking: !0
      });
    this.set_progress({
      progress: 1,
      message: "running",
      status: "info",
      blocking: !1
    });
  }
  update_view_settings(t) {
    GY(this.local_settings, { view_settings: t });
  }
}
const TJ = "1.0.0", FBe = ["1"], BBe = (e) => {
  if (!e.v.toString().includes(".") || // old polugin version without "."
  !FBe.includes(e.v.toString().split(".")[0]))
    throw new Error(`Unsupported version: ${e.v}`);
  return { ...e, v: TJ };
};
class UBe extends Jg {
  constructor(t) {
    super(t), this.plugins = Hi((n, r) => ({})), this.render_options = Hi((n, r) => ({}));
  }
  add_plugin(t, n) {
    if (n !== void 0)
      try {
        const r = BBe(n);
        this.plugins.setState((a) => ({ ...a, [t]: r }));
      } catch (r) {
        r instanceof Error ? this.context.rf.logger.error(`Error loading plugin ${t}`, r) : this.context.rf.logger.error(
          `Error loading plugin ${t}`,
          new Error(String(r))
        ), this.stateManager.toaster?.error({
          title: "Error",
          description: `Error loading plugin ${t}: ${r instanceof Error ? r.message : String(r)}`,
          duration: 5e3
        });
      }
  }
  update_render_options(t) {
    GY(this.render_options, t);
  }
  async add_packed_plugin(t, n) {
    if (n.js)
      for (const r of n.js) {
        const a = document.createElement("script");
        a.text = atob(r), document.body.appendChild(a);
      }
    if (n.css)
      for (const r of n.css) {
        const a = document.createElement("style");
        a.innerHTML = atob(r), document.head.appendChild(a);
      }
    if (n.module !== void 0) {
      const r = atob(n.module);
      try {
        const a = await new Function(
          "React",
          "FuncNodesReactFlow",
          `
          return (async () => {
            ${r}
            return FuncNodesPlugin;
          })();
        `
        )(BS, kZ);
        this.add_plugin(t, a);
      } catch (a) {
        a instanceof Error ? this.context.rf.logger.error(`Error building plugin ${t}`, a) : this.context.rf.logger.error(
          `Error building plugin ${t}`,
          new Error(String(a))
        ), this.stateManager.toaster?.error({
          title: "Error",
          description: `Error building plugin ${t}: ${a}`,
          duration: 5e3
        });
      }
    }
  }
}
class VBe extends Jg {
  constructor(t) {
    super(t), this.on_rf_node_change = (n) => {
      const r = this.useReactFlowStore.getState();
      for (const a of n)
        switch (a.type) {
          case "position":
            if (a.position) {
              const s = r.getNode(a.id);
              if (s === void 0)
                continue;
              s.type === "group" ? this.nodespaceManager.change_group_position(a) : this.nodespaceManager.change_fn_node_position(a), s.data.groupID && this.nodespaceManager.auto_resize_group(s.data.groupID);
            }
            break;
          case "dimensions":
            if (a.dimensions) {
              const s = r.getNode(a.id);
              if (s === void 0)
                continue;
              s.type === "group" ? this.nodespaceManager.change_group_dimensions(a) : this.nodespaceManager.change_fn_node_dimensions(a), s.data.groupID && this.nodespaceManager.auto_resize_group(
                s.data.groupID
              );
            }
            break;
        }
    }, this.on_rf_edge_change = (n) => {
    }, this.on_connect = (n) => {
      n.source === null || n.target === null || n.sourceHandle === null || n.targetHandle === null || !this.workerManager.worker || this.workerManager.worker.api.edge.add_edge({
        src_nid: n.source,
        src_ioid: n.sourceHandle,
        trg_nid: n.target,
        trg_ioid: n.targetHandle,
        replace: !0
      });
    }, this.useReactFlowStore = R6e({
      on_node_change: this.on_rf_node_change.bind(this),
      on_edge_change: this.on_rf_edge_change.bind(this),
      on_connect: this.on_connect.bind(this)
    });
  }
}
let HBe = class {
  constructor(e) {
    this.reactflowRef = null, this.dev_settings = {
      debug: jS()
    }, this.options = e, this.logger = e.logger ?? new zR("fn", jS() ? Y8 : X8);
    const t = { rf: this };
    this._nodespaceManager = new IBe(t), this._libManager = new zBe(t), this._workerManager = new TBe(t), this._stateManager = new LBe(t), this._pluginManager = new UBe(t), this._reactFlowManager = new VBe(t);
  }
  // #region handlers
  getNodespaceManager() {
    return this._nodespaceManager;
  }
  getLibManager() {
    return this._libManager;
  }
  getWorkerManager() {
    return this._workerManager;
  }
  getStateManager() {
    return this._stateManager;
  }
  getPluginManager() {
    return this._pluginManager;
  }
  getReactFlowManager() {
    return this._reactFlowManager;
  }
  // #endregion handlers
  // #region nodespace manager
  get nodespace() {
    return this._nodespaceManager.nodespace;
  }
  get on_node_action() {
    return this._nodespaceManager.on_node_action.bind(this._nodespaceManager);
  }
  get on_edge_action() {
    return this._nodespaceManager.on_edge_action.bind(this._nodespaceManager);
  }
  get on_group_action() {
    return this._nodespaceManager.on_group_action.bind(this._nodespaceManager);
  }
  get clear_all() {
    return this._nodespaceManager.clear_all.bind(this._nodespaceManager);
  }
  get center_node() {
    return this._nodespaceManager.center_node.bind(this._nodespaceManager);
  }
  get center_all() {
    return this._nodespaceManager.center_all.bind(this._nodespaceManager);
  }
  // #endregion nodespace manager
  // #region lib manager
  get lib() {
    return this._libManager.lib;
  }
  // #endregion lib manager
  // #region worker manager
  get set_worker() {
    return this._workerManager.set_worker.bind(this._workerManager);
  }
  get workermanager() {
    return this._workerManager.workermanager;
  }
  set workermanager(e) {
    this._workerManager.workermanager = e;
  }
  get worker() {
    return this._workerManager.worker;
  }
  get workers() {
    return this._workerManager.workers;
  }
  get workerstate() {
    return this._workerManager.workerstate;
  }
  get _unsubscribeFromWorker() {
    return this._workerManager._unsubscribeFromWorker?.bind(
      this._workerManager
    );
  }
  // #endregion worker manager
  // #region statemanager
  get set_progress() {
    return this._stateManager.set_progress.bind(this._stateManager);
  }
  get auto_progress() {
    return this._stateManager.auto_progress.bind(this._stateManager);
  }
  get progress_state() {
    return this._stateManager.progress_state;
  }
  get local_settings() {
    return this._stateManager.local_settings;
  }
  get local_state() {
    return this._stateManager.local_state;
  }
  update_view_settings(e) {
    this._stateManager.update_view_settings(e);
  }
  // #endregion statemanager
  // #region plugis
  get plugins() {
    return this._pluginManager.plugins.bind(this._pluginManager);
  }
  get add_plugin() {
    return this._pluginManager.add_plugin.bind(this._pluginManager);
  }
  get add_packed_plugin() {
    return this._pluginManager.add_packed_plugin.bind(this._pluginManager);
  }
  get render_options() {
    return this._pluginManager.render_options.bind(this._pluginManager);
  }
  get update_render_options() {
    return this._pluginManager.update_render_options.bind(this._pluginManager);
  }
  // #endregion plugis
  // #region reactflow
  get useReactFlowStore() {
    return this._reactFlowManager.useReactFlowStore.bind(
      this._reactFlowManager
    );
  }
  get rf_instance() {
    return this._reactFlowManager.rf_instance;
  }
  set rf_instance(e) {
    this._reactFlowManager.rf_instance = e;
  }
  // #endregion reactflow
};
const WBe = US(
  sye,
  (e) => (e.id = J4(), e)
), qBe = (e) => {
  if (!e.useWorkerManager && e.worker === void 0)
    throw new Error(
      "If you don't use a worker manager, you must provide a default worker."
    );
  if (e.useWorkerManager && e.workermanager_url === void 0)
    throw new Error(
      "Error: If you use a worker manager, you must provide a worker managerurl."
    );
}, yR = {};
window.fnrf_zst === void 0 && (window.fnrf_zst = yR);
const m1 = (e) => {
  const [t, n] = M.useState(void 0), [r, a] = M.useState(
    void 0
  ), [s, l] = M.useState(!1);
  if (M.useEffect(() => {
    const c = WBe(e);
    c.logger = c.logger || new zR("FuncNodes", c.debug ? "debug" : "info"), c.logger.debug("Initializing FuncNodes with props:", c), n(c), l(!1);
  }, [e]), M.useEffect(() => {
    if (!t) return;
    t.logger?.debug("Initializing/Getting Zustand store");
    const c = yR[t.id];
    if (c === void 0) {
      const d = new HBe(t);
      yR[t.id] = d, a(d);
    } else
      a(c), c.options.debug = t.debug;
  }, [t?.id, t?.debug]), M.useEffect(() => {
    if (!(!t || !r) && !(t.useWorkerManager || // a) a worker manager is used
    !t.worker_url && !t.worker))
      if (t.logger?.debug("Worker effect running"), !t.worker && t.worker_url) {
        t.logger?.debug("Creating WebSocket worker");
        const c = new VH({
          url: t.worker_url,
          uuid: t.id,
          on_sync_complete: t.on_sync_complete
        });
        return c.set_zustand(r), n(
          (d) => d && { ...d, worker: c, useWorkerManager: !1 }
        ), () => {
          t.logger?.debug("Disconnecting worker"), c.disconnect(), n((d) => d && { ...d, worker: void 0 });
        };
      } else {
        t.worker?.set_zustand(r);
        return;
      }
  }, [
    t?.worker_url,
    t?.id,
    t?.useWorkerManager,
    r,
    t?.on_sync_complete
  ]), M.useEffect(() => {
    if (!t?.fnw_url || !t.worker) return;
    t.logger?.debug("Loading fnw_url data");
    let c = !1;
    const d = t.worker.getSyncManager();
    let f;
    return (async () => {
      try {
        const m = await UZ(t.fnw_url);
        if (c) return;
        f = async (h) => {
          c || await h.update_from_export(m);
        }, d.add_after_next_sync(f);
      } catch (m) {
        m instanceof Error ? t.logger?.error("Failed to load fnw_url:", m) : t.logger?.error(
          "Failed to load fnw_url:",
          new Error(String(m))
        );
      }
    })(), () => {
      c = !0, f && d.remove_after_next_sync(f);
    };
  }, [t?.fnw_url, t?.worker]), M.useEffect(() => {
    if (!t || !r || !t.useWorkerManager) return;
    if (!t.workermanager_url)
      throw new Error(
        "Error: If you use a worker manager, you must provide a worker manager url."
      );
    r.logger.info("Worker manager effect running");
    const c = !r.workermanager, d = r.workermanager && r.workermanager.wsuri !== t.workermanager_url;
    if (c || d) {
      r.workermanager && (r.logger.info("Removing existing worker manager"), r.workermanager.remove(), r.workermanager = void 0), r.logger.info("Creating new worker manager");
      const f = new rye(
        t.workermanager_url,
        r
      );
      return r.workermanager = f, n((m) => m && { ...m, workermanager: f }), () => {
        r.logger.info("Worker manager cleanup running"), r.workermanager === f ? (r.logger.info("Removing worker manager instance"), f.remove(), r.workermanager = void 0) : r.logger.info(
          "Worker manager instance mismatch, skipping cleanup"
        );
      };
    } else {
      r.logger.info(
        "Worker manager already initialized with correct URL"
      );
      return;
    }
  }, [
    t?.useWorkerManager,
    t?.workermanager_url,
    t?.id,
    r
  ]), M.useEffect(() => {
    !t || !r || s || (t.useWorkerManager ? r.workermanager !== void 0 : t.worker !== void 0) && t.on_ready && typeof t.on_ready == "function" && (t.logger?.debug("Firing on_ready callback"), t.on_ready({ fnrf_zst: r }), l(!0));
  }, [
    t,
    r,
    s,
    t?.useWorkerManager,
    r?.workermanager,
    t?.worker
  ]), t === void 0 || r === void 0)
    return /* @__PURE__ */ C.jsx("div", { children: "Loading..." });
  try {
    qBe(t);
  } catch (c) {
    return /* @__PURE__ */ C.jsx(VZ, { error: c });
  }
  return /* @__PURE__ */ C.jsx("div", { className: "FuncnodesApp", children: /* @__PURE__ */ C.jsx(Ece, { available_themes: HH, children: /* @__PURE__ */ C.jsx(rge, { duration: 5e3, children: /* @__PURE__ */ C.jsx(
    PBe,
    {
      fnrf_zst: r,
      header: t.header,
      library: t.library,
      flow: t.flow
    }
  ) }) }) });
}, LJ = (e, t) => {
  t === void 0 && (t = {});
  const { element: n, eleid: r } = typeof e == "string" ? {
    element: document.getElementById(e),
    eleid: e
  } : { element: e, eleid: e.id };
  AZ.createRoot(n).render(
    /* @__PURE__ */ C.jsx(M.StrictMode, { children: /* @__PURE__ */ C.jsx(m1, { ...t, id: t.id || r }) })
  );
};
window.FuncNodes = LJ;
window.FuncNodes.version = "2.2.1";
window.FuncNodes.utils = {
  logger: {
    ConsoleLogger: zR,
    DivLogger: DZ,
    BaseLogger: $R,
    DEBUG: Y8,
    INFO: X8,
    WARN: RZ,
    ERROR: jZ
  }
};
const Io = [];
for (let e = 0; e < 256; ++e)
  Io.push((e + 256).toString(16).slice(1));
function GBe(e, t = 0) {
  return (Io[e[t + 0]] + Io[e[t + 1]] + Io[e[t + 2]] + Io[e[t + 3]] + "-" + Io[e[t + 4]] + Io[e[t + 5]] + "-" + Io[e[t + 6]] + Io[e[t + 7]] + "-" + Io[e[t + 8]] + Io[e[t + 9]] + "-" + Io[e[t + 10]] + Io[e[t + 11]] + Io[e[t + 12]] + Io[e[t + 13]] + Io[e[t + 14]] + Io[e[t + 15]]).toLowerCase();
}
let cA;
const KBe = new Uint8Array(16);
function YBe() {
  if (!cA) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    cA = crypto.getRandomValues.bind(crypto);
  }
  return cA(KBe);
}
const XBe = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), OF = { randomUUID: XBe };
function JBe(e, t, n) {
  e = e || {};
  const r = e.random ?? e.rng?.() ?? YBe();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, GBe(r);
}
function QBe(e, t, n) {
  return OF.randomUUID && !e ? OF.randomUUID() : JBe(e);
}
const MF = (e) => !!e && typeof e == "object" && "port" in e && !!e.port, NF = (e) => !!e && typeof e == "object" && typeof e.postMessage == "function" && typeof e.addEventListener == "function" && !("port" in e);
let ZBe = class {
  constructor(t, n = {}) {
    if (this._disposed = !1, this._intervals = [], this._worker = t, this._worker_id = n.worker_id, n.onMessage)
      if (this._onmessage_bound = n.onMessage, MF(t))
        this._port = t.port, this._port.start(), this._port.addEventListener("message", this._onmessage_bound);
      else if (NF(t))
        t.addEventListener("message", this._onmessage_bound);
      else
        throw new Error("worker must be a DedicatedWorkerLike or SharedWorkerLike");
    else if (MF(t))
      this._port = t.port, this._port.start();
    else if (!NF(t))
      throw new Error("worker must be a DedicatedWorkerLike or SharedWorkerLike");
  }
  get disposed() {
    return this._disposed;
  }
  get shared() {
    return !!this._port;
  }
  _decorate(t) {
    return this._worker_id === void 0 ? t : { ...t, worker_id: this._worker_id };
  }
  postMessage(t) {
    this._disposed || this._postRaw(t);
  }
  _postRaw(t) {
    const n = this._decorate(t);
    this._port ? this._port.postMessage(n) : this._worker.postMessage(n);
  }
  startStatePolling({ intervalMs: t = 400 } = {}) {
    if (this._disposed) return;
    const n = setInterval(() => {
      this.postMessage({ cmd: "state" });
    }, t);
    this._intervals.push(n);
  }
  stopPolling() {
    for (const t of this._intervals) clearInterval(t);
    this._intervals = [];
  }
  dispose() {
    if (!this._disposed) {
      if (this._port)
        try {
          this._postRaw({ cmd: "disconnect" });
        } catch {
        }
      this._disposed = !0, this.stopPolling();
      try {
        this._port && this._onmessage_bound ? this._port.removeEventListener("message", this._onmessage_bound) : this._onmessage_bound && this._worker.removeEventListener?.(
          "message",
          this._onmessage_bound
        );
      } catch {
      }
      if (this._port) {
        try {
          this._port.close();
        } catch {
        }
        this._port = void 0;
      } else
        try {
          this._worker.terminate?.();
        } catch {
        }
    }
  }
};
const eUe = ({
  pageOrigin: e,
  scriptUrl: t
}) => {
  if (!e || !t) return !1;
  try {
    return new URL(t).origin !== e;
  } catch {
    return !1;
  }
}, tUe = () => typeof URL < "u" && typeof URL.createObjectURL == "function" && typeof URL.revokeObjectURL == "function" && typeof Blob < "u", nUe = (e) => {
  if (!tUe()) return;
  const t = `await import(${JSON.stringify(e)});`, n = new Blob([t], { type: "text/javascript" });
  return URL.createObjectURL(n);
}, h_ = (e, t) => {
  try {
    return e(t);
  } catch (n) {
    const r = nUe(t);
    if (!r) throw n;
    try {
      return e(r);
    } finally {
      try {
        URL.revokeObjectURL(r);
      } catch {
      }
    }
  }
}, rUe = (e) => {
  if (e.worker) return e.worker;
  const t = e.uuid;
  if (e.shared_worker) {
    if (e.worker_url === void 0) {
      if (e.worker_classes?.Shared)
        return new e.worker_classes.Shared({ name: t });
      if (typeof SharedWorker > "u")
        throw new Error(
          "SharedWorker is not available; provide worker, worker_url or worker_classes.Shared"
        );
      try {
        return new SharedWorker(new URL(
          /* @vite-ignore */
          "" + new URL("assets/pyodideSharedWorker-B8dBCO6o-DmmUV1z3.js", import.meta.url).href,
          import.meta.url
        ), {
          name: t,
          type: "module"
        });
      } catch {
        return h_(
          (n) => new SharedWorker(n, { name: t, type: "module" }),
          new URL("data:video/mp2t;base64,aW1wb3J0IHsgaW5pdFNoYXJlZFdvcmtlciB9IGZyb20gIi4vcHlvZGlkZVdlYldvcmtlci5tanMiOwppbml0U2hhcmVkV29ya2VyKHt9KTsK", import.meta.url).href
        );
      }
    }
    if (e.worker_classes?.Shared, typeof SharedWorker > "u")
      throw new Error(
        "SharedWorker is not available; provide worker or set shared_worker=false"
      );
    return h_(
      (n) => new SharedWorker(n, { name: t, type: "module" }),
      e.worker_url
    );
  }
  if (e.worker_url === void 0) {
    if (e.worker_classes?.Dedicated)
      return new e.worker_classes.Dedicated({ name: t });
    if (typeof Worker > "u")
      throw new Error(
        "Worker is not available; provide worker, worker_url or worker_classes.Dedicated"
      );
    try {
      return new Worker(new URL(
        /* @vite-ignore */
        "" + new URL("assets/pyodideDedicatedWorker-Bge9R9PO-DxE397nO.js", import.meta.url).href,
        import.meta.url
      ), {
        name: t,
        type: "module"
      });
    } catch {
      return h_(
        (n) => new Worker(n, { name: t, type: "module" }),
        new URL("data:video/mp2t;base64,aW1wb3J0IHsgaW5pdERlZGljYXRlZFdvcmtlciB9IGZyb20gIi4vcHlvZGlkZVdlYldvcmtlci5tanMiOwppbml0RGVkaWNhdGVkV29ya2VyKHt9KTsK", import.meta.url).href
      );
    }
  }
  if (typeof Worker > "u")
    throw new Error(
      "Worker is not available; provide worker or set shared_worker=true"
    );
  return h_(
    (n) => new Worker(n, { name: t, type: "module" }),
    e.worker_url
  );
}, FJ = '(function(){"use strict";const w="https://cdn.jsdelivr.net/pyodide/v0.29.0/full/pyodide.mjs",e=self;e.workerState={pyodide:null,pyodide_url:w,packages:[],state:{msg:"loading",loaded:!1,progress:0},micropip:null,worker:{},pyodideReady:!1,pyodideReadyPromise:null,debug:!1,interruptBuffer:null,receivepy:(r,t)=>{},receivepy_bytes:(r,t)=>{},handel_register:{},post_pyodide_ready:void 0},e.reset=async()=>{for(const r in e.list_workers())try{const t=await e.get_worker(r);t.worker&&t.worker.stop(),t.reject_promise?.("Worker reset")}catch{}e.workerState.pyodide&&e.interrupt(),e.workerState.pyodide=null,e.workerState.micropip=null,e.workerState.worker={},e.workerState.pyodideReady=!1;try{e.workerState.interruptBuffer=new Uint8Array(new SharedArrayBuffer(1)),e.workerState.interruptBuffer[0]=0}catch{}},e.initializePyodide=async()=>{if(!e.workerState.pyodide){console.log("initializePyodide with: Debug:",e.workerState.debug,"Pyodide URL:",e.workerState.pyodide_url,"Packages:",e.workerState.packages),console.debug("Loading Pyodide..."),e.workerState.state.msg="Loading Pyodide...",e.workerState.state.progress=0,await e.reset(),console.debug("Loading Pyodide module..."),e.workerState.state.msg="Loading Pyodide module...",e.workerState.state.progress=.1;const t=await import(e.workerState.pyodide_url);console.debug("Loading Pyodide instance..."),e.workerState.state.msg="Loading Pyodide instance...",e.workerState.state.progress=.2;const o=t.loadPyodide,s=new URL(e.workerState.pyodide_url),a=new URL(".",s).toString();e.workerState.debug&&console.debug("Pyodide indexURL:",a),e.workerState.pyodide=await o({packages:["micropip"],indexURL:a}),e.workerState.interruptBuffer&&e.workerState.pyodide.setInterruptBuffer(e.workerState.interruptBuffer)}e.workerState.micropip||(console.debug("Importing micropip..."),e.workerState.state.msg="Importing micropip...",e.workerState.state.progress=.3,e.workerState.micropip=e.workerState.pyodide.pyimport("micropip")),console.debug("Pyodide ready. Installing funcnodes...");for(const t of e.workerState.packages)console.log("Installing package:",t),e.workerState.state.msg=`Installing package: ${t}`,await e.workerState.micropip.install(t);return e.workerState.state.msg="Installing funcnodes",e.workerState.state.progress=.8,await e.workerState.micropip.install("funcnodes"),e.workerState.state.msg="Installing funcnodes-worker",await e.workerState.micropip.install("funcnodes-worker"),e.workerState.packages.some(t=>t.toLowerCase().endsWith(".whl")&&t.includes("funcnodes_pyodide"))?e.workerState.debug&&console.debug("Skipping PyPI funcnodes-pyodide install (wheel provided in packages)"):(e.workerState.state.msg="Installing funcnodes-pyodide",await e.workerState.micropip.install("funcnodes-pyodide")),e.workerState.state.msg="Installing funcnodes-react-flow",await e.workerState.micropip.install("funcnodes-react-flow"),e.workerState.state.msg="Importing funcnodes",console.debug("Importing funcnodes..."),await e.workerState.pyodide.runPythonAsync("import funcnodes_pyodide"),console.debug("Running post_pyodide_ready..."),await e.workerState.post_pyodide_ready?.(e.workerState),console.debug("Pyodide ready"),e.workerState.state.msg="ready",e.workerState.state.progress=.1,e.workerState.pyodideReady=!0,{pyodide:e.workerState.pyodide,micropip:e.workerState.micropip}},e.interrupt=()=>{e.workerState.interruptBuffer&&(e.workerState.interruptBuffer[0]=1)},e.list_workers=()=>Object.keys(e.workerState.worker),e.get_worker=async r=>{if(!r)throw new Error("Worker id is required");if(!e.workerState.worker[r])throw new Error(`Worker with id ${r} not found`);return await e.workerState.worker[r].make_promise,e.workerState.worker[r]},e.has_worker=r=>{if(!r)throw new Error("Worker id is required");return!!e.workerState.worker[r]},e.get_or_create_worker=async r=>{if(!r)throw new Error("Worker id is required");return e.workerState.worker[r]||(console.log("Creating worker with id",r),await e.initializeFuncNodesWorker(r)),e.get_worker(r)},e.initializeFuncNodesWorker=async r=>{try{if(!e.workerState.pyodideReadyPromise)throw new Error("Pyodide newer initialized");const{pyodide:t}=await e.workerState.pyodideReadyPromise;if(!e.has_worker(r)){e.workerState.worker[r]={worker:null,make_promise:void 0};const o=new Promise(async(s,a)=>{e.workerState.worker[r].reject_promise=a,console.debug(`Creating worker (${r})...`);const i=await t.runPythonAsync(`funcnodes_pyodide.new_worker(debug=${e.workerState.debug?1:0}, uuid="${r}")`);if(console.debug("Worker created:",i),typeof i.set_receiver=="function")i.set_receiver(self);else throw new Error("Worker does not expose a \'set_receiver\' method.");e.workerState.worker[r].worker=i,console.debug("Worker ready"),s(i)});e.workerState.worker[r].make_promise=o}return e.get_worker(r)}catch(t){throw console.error("Error during worker initialization:",t),t}},e.receivepy=(r,t)=>{try{let o={};if(typeof r=="string"?o.msg=r:o=r,o.msg===void 0)return;typeof o.msg!="string"&&(o.msg=JSON.stringify(o.msg)),t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const s=o.worker_id;if(!s)throw new Error(`Worker id not provided in receivepy(${JSON.stringify(o)})`);if(!e.workerState.worker[s])throw new Error(`Worker with id ${s} not found in receivepy(${JSON.stringify(o)})`);e.workerState.receivepy(r,s)}catch(o){console.error("Error during receivepy:",o);return}},e.receivepy_bytes=(r,t)=>{let o=r;const s=r;if(s&&typeof s.toJs=="function")try{o=s.toJs({dict_converter:Object.fromEntries})}catch{o=s.toJs()}o instanceof Map&&(o=Object.fromEntries(o.entries()));try{let a={};if(o instanceof Uint8Array?a.msg=o:a=o,a.msg===void 0)return;let i=a.msg;const n=i;if(n&&typeof n.toJs=="function")try{i=n.toJs({dict_converter:Object.fromEntries})}catch{i=n.toJs()}if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),Array.isArray(i)&&(i=Uint8Array.from(i)),!(i instanceof Uint8Array))throw new Error(`receivepy_bytes expected Uint8Array payload, got ${typeof i}`);a.msg=i,t!==void 0&&(typeof t=="string"?a.worker_id||(a.worker_id=t):a={...t,...a});const d=a.worker_id;if(!d)throw new Error("Worker id not provided in receivepy_bytes");if(!e.workerState.worker[d])throw new Error(`Worker with id ${d} not found in receivepy_bytes`);e.workerState.receivepy_bytes(a.msg,d)}catch(a){console.error("Error during receivepy_bytes:",a);return}},e.startInitialization=({debug:r=!1,receivepy:t,receivepy_bytes:o,pyodide_url:s,post_pyodide_ready:a,packages:i})=>(e.workerState.debug=r,e.workerState.pyodide_url=s||w,e.workerState.packages=i,e.workerState.receivepy=t,e.workerState.receivepy_bytes=o,e.workerState.pyodideReadyPromise=null,e.workerState.post_pyodide_ready=a,e.workerState),e.register_cmd_message=(r,t)=>{if(e.workerState.handel_register[r])throw new Error(`Command ${r} already registered`);e.workerState.handel_register[r]=t},e.register_cmd_message("ping",async r=>"pong"),e.register_cmd_message("init",async r=>{if(e.workerState.pyodideReadyPromise)throw new Error("Pyodide is already initialized");r.data&&(r.data.pyodide_url&&(e.workerState.pyodide_url=r.data.pyodide_url),r.data.packages&&(e.workerState.packages=r.data.packages),r.data.debug&&(e.workerState.debug=r.data.debug)),e.workerState.pyodideReadyPromise=e.initializePyodide()}),e.register_cmd_message("_eval",async r=>{try{const t=await e.workerState.pyodide?.runPythonAsync(r.msg||"print(\'No code provided\')");return console.log("Eval result:",t),t}catch(t){console.error("Error during _eval:",t)}}),e.register_cmd_message("state",async r=>({state:{...e.workerState.state,loaded:e.workerState.pyodideReady}})),e.register_cmd_message("worker:state",async r=>({state:{loaded:!!(await e.get_or_create_worker(r.worker_id)).worker}})),e.register_cmd_message("worker:stop",async r=>{if(!e.has_worker(r.worker_id))return;const t=await e.get_or_create_worker(r.worker_id);return t.worker&&(t.worker.stop(),t.worker=null,t.reject_promise?.("Worker stopped")),delete e.workerState.worker[r.worker_id],{state:{loaded:!1}}}),e.register_cmd_message("worker:send",async r=>{const t=await e.get_or_create_worker(r.worker_id);if(!t.worker)throw new Error("Worker is not initialized");if(typeof t.worker.receivejs!="function")throw new Error(`Worker does not support receivejs: ${typeof t.worker.receivejs}`);t.worker.receivejs(r.msg)}),e.handleMessage=async r=>{const t={original:r};r.id&&(t.id=r.id),r.toJs===void 0&&(r.toJs=!0);try{if(r.cmd){const o=r;if(e.workerState.handel_register[o.cmd])t.result=await e.workerState.handel_register[o.cmd](o);else throw new Error("Unknown command: "+o.cmd)}else throw new Error("Unknown message format: "+JSON.stringify(r))}catch(o){t.error=o.message}return t},e.read_url_params=()=>{const r=new URLSearchParams(self.location.search),t=r.get("debug")?.toLowerCase()==="true",o=r.get("pyodide_url")||void 0,s=r.get("packages")?.split(",")||[];return{debug:t,pyodide_url:o,packages:s}};const k=r=>{const t=new Set;return{add:o=>{t.add(o)},disconnect:o=>{t.delete(o)&&t.size===0&&r()},forEach:o=>{t.forEach(o)},size:()=>t.size}},c=e;c.general_initalization=r=>{const t=c.read_url_params();c.startInitialization({...r,...t})};const l=c,p=c;p.init_dedicated_worker=r=>{const t=e;t.onmessage=async s=>{const a=s.data,i=await t.handleMessage(a);t.postMessage(i)};const o={...r,receivepy:(s,a)=>{t.postMessage({cmd:"receive",msg:s,worker_id:a})},receivepy_bytes(s,a){t.postMessage({cmd:"receive_bytes",msg:s,worker_id:a})}};t.general_initalization(o)},l.init_shared_worker=r=>{const t=e,o=k(()=>{try{t.close()}catch{}});t.connectedPorts=[],t.onconnect=a=>{const i=a.ports[0];t.connectedPorts.push(i),o.add(i),i.start(),console.debug("Port connected in shared worker"),i.onmessage=async n=>{const d=n.data;if(d?.cmd==="disconnect"){o.disconnect(i),t.connectedPorts=t.connectedPorts.filter(g=>g!==i);try{i.onmessage=null}catch{}try{i.close()}catch{}return}const y=await t.handleMessage(d);i.postMessage(y)}};const s={...r,receivepy:(a,i)=>{o.forEach(n=>{n.postMessage({cmd:"receive",msg:a,worker_id:i})})},receivepy_bytes(a,i){o.forEach(n=>{n.postMessage({cmd:"receive_bytes",msg:a,worker_id:i})})}};t.general_initalization(s)},(r=>{c.init_dedicated_worker(r)})({})})();\n', AF = typeof self < "u" && self.Blob && new Blob(["(self.URL || self.webkitURL).revokeObjectURL(self.location.href);", FJ], { type: "text/javascript;charset=utf-8" });
function RF(e) {
  let t;
  try {
    if (t = AF && (self.URL || self.webkitURL).createObjectURL(AF), !t) throw "";
    const n = new Worker(t, {
      name: e?.name
    });
    return n.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(t);
    }), n;
  } catch {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(FJ),
      {
        name: e?.name
      }
    );
  }
}
const oUe = '(function(){"use strict";const w="https://cdn.jsdelivr.net/pyodide/v0.29.0/full/pyodide.mjs",e=self;e.workerState={pyodide:null,pyodide_url:w,packages:[],state:{msg:"loading",loaded:!1,progress:0},micropip:null,worker:{},pyodideReady:!1,pyodideReadyPromise:null,debug:!1,interruptBuffer:null,receivepy:(r,t)=>{},receivepy_bytes:(r,t)=>{},handel_register:{},post_pyodide_ready:void 0},e.reset=async()=>{for(const r in e.list_workers())try{const t=await e.get_worker(r);t.worker&&t.worker.stop(),t.reject_promise?.("Worker reset")}catch{}e.workerState.pyodide&&e.interrupt(),e.workerState.pyodide=null,e.workerState.micropip=null,e.workerState.worker={},e.workerState.pyodideReady=!1;try{e.workerState.interruptBuffer=new Uint8Array(new SharedArrayBuffer(1)),e.workerState.interruptBuffer[0]=0}catch{}},e.initializePyodide=async()=>{if(!e.workerState.pyodide){console.log("initializePyodide with: Debug:",e.workerState.debug,"Pyodide URL:",e.workerState.pyodide_url,"Packages:",e.workerState.packages),console.debug("Loading Pyodide..."),e.workerState.state.msg="Loading Pyodide...",e.workerState.state.progress=0,await e.reset(),console.debug("Loading Pyodide module..."),e.workerState.state.msg="Loading Pyodide module...",e.workerState.state.progress=.1;const t=await import(e.workerState.pyodide_url);console.debug("Loading Pyodide instance..."),e.workerState.state.msg="Loading Pyodide instance...",e.workerState.state.progress=.2;const o=t.loadPyodide,s=new URL(e.workerState.pyodide_url),a=new URL(".",s).toString();e.workerState.debug&&console.debug("Pyodide indexURL:",a),e.workerState.pyodide=await o({packages:["micropip"],indexURL:a}),e.workerState.interruptBuffer&&e.workerState.pyodide.setInterruptBuffer(e.workerState.interruptBuffer)}e.workerState.micropip||(console.debug("Importing micropip..."),e.workerState.state.msg="Importing micropip...",e.workerState.state.progress=.3,e.workerState.micropip=e.workerState.pyodide.pyimport("micropip")),console.debug("Pyodide ready. Installing funcnodes...");for(const t of e.workerState.packages)console.log("Installing package:",t),e.workerState.state.msg=`Installing package: ${t}`,await e.workerState.micropip.install(t);return e.workerState.state.msg="Installing funcnodes",e.workerState.state.progress=.8,await e.workerState.micropip.install("funcnodes"),e.workerState.state.msg="Installing funcnodes-worker",await e.workerState.micropip.install("funcnodes-worker"),e.workerState.packages.some(t=>t.toLowerCase().endsWith(".whl")&&t.includes("funcnodes_pyodide"))?e.workerState.debug&&console.debug("Skipping PyPI funcnodes-pyodide install (wheel provided in packages)"):(e.workerState.state.msg="Installing funcnodes-pyodide",await e.workerState.micropip.install("funcnodes-pyodide")),e.workerState.state.msg="Installing funcnodes-react-flow",await e.workerState.micropip.install("funcnodes-react-flow"),e.workerState.state.msg="Importing funcnodes",console.debug("Importing funcnodes..."),await e.workerState.pyodide.runPythonAsync("import funcnodes_pyodide"),console.debug("Running post_pyodide_ready..."),await e.workerState.post_pyodide_ready?.(e.workerState),console.debug("Pyodide ready"),e.workerState.state.msg="ready",e.workerState.state.progress=.1,e.workerState.pyodideReady=!0,{pyodide:e.workerState.pyodide,micropip:e.workerState.micropip}},e.interrupt=()=>{e.workerState.interruptBuffer&&(e.workerState.interruptBuffer[0]=1)},e.list_workers=()=>Object.keys(e.workerState.worker),e.get_worker=async r=>{if(!r)throw new Error("Worker id is required");if(!e.workerState.worker[r])throw new Error(`Worker with id ${r} not found`);return await e.workerState.worker[r].make_promise,e.workerState.worker[r]},e.has_worker=r=>{if(!r)throw new Error("Worker id is required");return!!e.workerState.worker[r]},e.get_or_create_worker=async r=>{if(!r)throw new Error("Worker id is required");return e.workerState.worker[r]||(console.log("Creating worker with id",r),await e.initializeFuncNodesWorker(r)),e.get_worker(r)},e.initializeFuncNodesWorker=async r=>{try{if(!e.workerState.pyodideReadyPromise)throw new Error("Pyodide newer initialized");const{pyodide:t}=await e.workerState.pyodideReadyPromise;if(!e.has_worker(r)){e.workerState.worker[r]={worker:null,make_promise:void 0};const o=new Promise(async(s,a)=>{e.workerState.worker[r].reject_promise=a,console.debug(`Creating worker (${r})...`);const i=await t.runPythonAsync(`funcnodes_pyodide.new_worker(debug=${e.workerState.debug?1:0}, uuid="${r}")`);if(console.debug("Worker created:",i),typeof i.set_receiver=="function")i.set_receiver(self);else throw new Error("Worker does not expose a \'set_receiver\' method.");e.workerState.worker[r].worker=i,console.debug("Worker ready"),s(i)});e.workerState.worker[r].make_promise=o}return e.get_worker(r)}catch(t){throw console.error("Error during worker initialization:",t),t}},e.receivepy=(r,t)=>{try{let o={};if(typeof r=="string"?o.msg=r:o=r,o.msg===void 0)return;typeof o.msg!="string"&&(o.msg=JSON.stringify(o.msg)),t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const s=o.worker_id;if(!s)throw new Error(`Worker id not provided in receivepy(${JSON.stringify(o)})`);if(!e.workerState.worker[s])throw new Error(`Worker with id ${s} not found in receivepy(${JSON.stringify(o)})`);e.workerState.receivepy(r,s)}catch(o){console.error("Error during receivepy:",o);return}},e.receivepy_bytes=(r,t)=>{let o=r;const s=r;if(s&&typeof s.toJs=="function")try{o=s.toJs({dict_converter:Object.fromEntries})}catch{o=s.toJs()}o instanceof Map&&(o=Object.fromEntries(o.entries()));try{let a={};if(o instanceof Uint8Array?a.msg=o:a=o,a.msg===void 0)return;let i=a.msg;const n=i;if(n&&typeof n.toJs=="function")try{i=n.toJs({dict_converter:Object.fromEntries})}catch{i=n.toJs()}if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),Array.isArray(i)&&(i=Uint8Array.from(i)),!(i instanceof Uint8Array))throw new Error(`receivepy_bytes expected Uint8Array payload, got ${typeof i}`);a.msg=i,t!==void 0&&(typeof t=="string"?a.worker_id||(a.worker_id=t):a={...t,...a});const d=a.worker_id;if(!d)throw new Error("Worker id not provided in receivepy_bytes");if(!e.workerState.worker[d])throw new Error(`Worker with id ${d} not found in receivepy_bytes`);e.workerState.receivepy_bytes(a.msg,d)}catch(a){console.error("Error during receivepy_bytes:",a);return}},e.startInitialization=({debug:r=!1,receivepy:t,receivepy_bytes:o,pyodide_url:s,post_pyodide_ready:a,packages:i})=>(e.workerState.debug=r,e.workerState.pyodide_url=s||w,e.workerState.packages=i,e.workerState.receivepy=t,e.workerState.receivepy_bytes=o,e.workerState.pyodideReadyPromise=null,e.workerState.post_pyodide_ready=a,e.workerState),e.register_cmd_message=(r,t)=>{if(e.workerState.handel_register[r])throw new Error(`Command ${r} already registered`);e.workerState.handel_register[r]=t},e.register_cmd_message("ping",async r=>"pong"),e.register_cmd_message("init",async r=>{if(e.workerState.pyodideReadyPromise)throw new Error("Pyodide is already initialized");r.data&&(r.data.pyodide_url&&(e.workerState.pyodide_url=r.data.pyodide_url),r.data.packages&&(e.workerState.packages=r.data.packages),r.data.debug&&(e.workerState.debug=r.data.debug)),e.workerState.pyodideReadyPromise=e.initializePyodide()}),e.register_cmd_message("_eval",async r=>{try{const t=await e.workerState.pyodide?.runPythonAsync(r.msg||"print(\'No code provided\')");return console.log("Eval result:",t),t}catch(t){console.error("Error during _eval:",t)}}),e.register_cmd_message("state",async r=>({state:{...e.workerState.state,loaded:e.workerState.pyodideReady}})),e.register_cmd_message("worker:state",async r=>({state:{loaded:!!(await e.get_or_create_worker(r.worker_id)).worker}})),e.register_cmd_message("worker:stop",async r=>{if(!e.has_worker(r.worker_id))return;const t=await e.get_or_create_worker(r.worker_id);return t.worker&&(t.worker.stop(),t.worker=null,t.reject_promise?.("Worker stopped")),delete e.workerState.worker[r.worker_id],{state:{loaded:!1}}}),e.register_cmd_message("worker:send",async r=>{const t=await e.get_or_create_worker(r.worker_id);if(!t.worker)throw new Error("Worker is not initialized");if(typeof t.worker.receivejs!="function")throw new Error(`Worker does not support receivejs: ${typeof t.worker.receivejs}`);t.worker.receivejs(r.msg)}),e.handleMessage=async r=>{const t={original:r};r.id&&(t.id=r.id),r.toJs===void 0&&(r.toJs=!0);try{if(r.cmd){const o=r;if(e.workerState.handel_register[o.cmd])t.result=await e.workerState.handel_register[o.cmd](o);else throw new Error("Unknown command: "+o.cmd)}else throw new Error("Unknown message format: "+JSON.stringify(r))}catch(o){t.error=o.message}return t},e.read_url_params=()=>{const r=new URLSearchParams(self.location.search),t=r.get("debug")?.toLowerCase()==="true",o=r.get("pyodide_url")||void 0,s=r.get("packages")?.split(",")||[];return{debug:t,pyodide_url:o,packages:s}};const k=r=>{const t=new Set;return{add:o=>{t.add(o)},disconnect:o=>{t.delete(o)&&t.size===0&&r()},forEach:o=>{t.forEach(o)},size:()=>t.size}},c=e;c.general_initalization=r=>{const t=c.read_url_params();c.startInitialization({...r,...t})};const l=c,p=c;p.init_dedicated_worker=r=>{const t=e;t.onmessage=async s=>{const a=s.data,i=await t.handleMessage(a);t.postMessage(i)};const o={...r,receivepy:(s,a)=>{t.postMessage({cmd:"receive",msg:s,worker_id:a})},receivepy_bytes(s,a){t.postMessage({cmd:"receive_bytes",msg:s,worker_id:a})}};t.general_initalization(o)},l.init_shared_worker=r=>{const t=e,o=k(()=>{try{t.close()}catch{}});t.connectedPorts=[],t.onconnect=a=>{const i=a.ports[0];t.connectedPorts.push(i),o.add(i),i.start(),console.debug("Port connected in shared worker"),i.onmessage=async n=>{const d=n.data;if(d?.cmd==="disconnect"){o.disconnect(i),t.connectedPorts=t.connectedPorts.filter(g=>g!==i);try{i.onmessage=null}catch{}try{i.close()}catch{}return}const y=await t.handleMessage(d);i.postMessage(y)}};const s={...r,receivepy:(a,i)=>{o.forEach(n=>{n.postMessage({cmd:"receive",msg:a,worker_id:i})})},receivepy_bytes(a,i){o.forEach(n=>{n.postMessage({cmd:"receive_bytes",msg:a,worker_id:i})})}};t.general_initalization(s)},(r=>{c.init_shared_worker(r)})({})})();\n';
function jF(e) {
  return new SharedWorker(
    "data:text/javascript;charset=utf-8," + encodeURIComponent(oUe),
    {
      name: e?.name
    }
  );
}
const aUe = (e) => {
  if (e.worker) return e.worker;
  if (e.worker_url !== void 0 || e.worker_classes?.Dedicated || e.worker_classes?.Shared)
    return rUe(e);
  const t = e.uuid, n = !!e.shared_worker, r = eUe({
    pageOrigin: typeof window < "u" && window.location ? window.location.origin : void 0,
    scriptUrl: typeof import.meta < "u" ? import.meta.url : void 0
  });
  if (n) {
    if (typeof SharedWorker > "u")
      throw new Error(
        "SharedWorker is not available; provide worker, worker_url or worker_classes.Shared"
      );
    if (r) return new jF({ name: t });
    try {
      return new SharedWorker(
        new URL(
          /* @vite-ignore */
          "" + new URL("assets/pyodideSharedWorker-B8dBCO6o-DmmUV1z3.js", import.meta.url).href,
          import.meta.url
        ),
        { name: t, type: "module" }
      );
    } catch {
      return new jF({ name: t });
    }
  }
  if (typeof Worker > "u")
    throw new Error(
      "Worker is not available; provide worker, worker_url or worker_classes.Dedicated"
    );
  if (r) return new RF({ name: t });
  try {
    return new Worker(new URL(
      /* @vite-ignore */
      "" + new URL("assets/pyodideDedicatedWorker-Bge9R9PO-DxE397nO.js", import.meta.url).href,
      import.meta.url
    ), {
      name: t,
      type: "module"
    });
  } catch {
    return new RF({ name: t });
  }
}, iUe = (e, t) => {
  if (!e?.length) return e;
  const n = t ?? (typeof window < "u" && window.location ? window.location.href : void 0);
  return n ? e.map((r) => /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(r) ? r : r.startsWith("/") || r.startsWith("./") || r.startsWith("../") ? new URL(r, n).toString() : r) : e;
}, sUe = (e) => (e.worker = aUe({
  uuid: e.uuid,
  shared_worker: e.shared_worker,
  worker_url: e.worker_url,
  worker: e.worker,
  worker_classes: e.worker_classes
}), e.worker);
let h1 = class extends Q4 {
  constructor(t) {
    const n = {
      uuid: QBe(),
      ...t
    };
    super(n), this._message_hooks = [], this._disposed = !1, this._worker = sUe(n), this._lifecycle = new ZBe(this._worker, {
      worker_id: this.uuid,
      onMessage: this.onmessage.bind(this)
    }), this.postMessage({
      cmd: "init",
      data: {
        debug: n.debug,
        pyodide_url: n.pyodide_url,
        packages: iUe(n.packages, n.worker_baseurl)
      }
    }), this._lifecycle.startStatePolling(), this._workerstate = { loaded: !1, msg: "loading", progress: 0 }, this.initPromise = new Promise(async (r) => {
      for (; !this._workerstate.loaded && !this._disposed; )
        this._zustand?.set_progress({
          message: this._workerstate.msg,
          status: "info",
          progress: this._workerstate.progress,
          blocking: !0
        }), await new Promise((a) => setTimeout(a, 100));
      this._lifecycle.stopPolling(), this._disposed || (this.is_open = !0, this._zustand?.auto_progress()), r();
    }), this.initPromise.then(async () => {
      if (!this._disposed) {
        if (n.restore_worker_state_on_load) {
          const r = typeof n.restore_worker_state_on_load == "string" ? n.restore_worker_state_on_load : this._storage_key();
          await this.restore_worker_state(r);
        }
        await this.getSyncManager().stepwise_fullsync(), n.post_worker_initialized && await n.post_worker_initialized(this);
      }
    });
  }
  async send(t) {
    await this.initPromise, this.postMessage({
      cmd: "worker:send",
      msg: JSON.stringify(t),
      worker_id: this.uuid
    });
  }
  postMessage(t) {
    this._lifecycle.postMessage(t);
  }
  dispose() {
    this._disposed || (this._disposed = !0, this.is_open = !1, this._lifecycle.dispose());
  }
  registerMessageHook(t) {
    return this._message_hooks.push(t), () => {
      this._message_hooks = this._message_hooks.filter((n) => n !== t);
    };
  }
  onmessage(t) {
    if (!this._disposed) {
      for (const n of this._message_hooks)
        n(t.data);
      if (t.data.result)
        t.data.result.state && (this._workerstate = {
          ...this._workerstate,
          ...t.data.result.state
        }, t.data.result.state.msg && t.data.result.state.msg !== "ready" && this._zustand?.set_progress({
          message: this._workerstate.msg,
          status: "info",
          progress: this._workerstate.progress,
          blocking: !0
        }));
      else if (t.data.cmd) {
        if (t.data.cmd === "receive") {
          if (t.data.worker_id === void 0)
            throw new Error("worker_id is undefined");
          t.data.worker_id === this.uuid && this.getCommunicationManager().receive(JSON.parse(t.data.msg));
        } else if (t.data.cmd === "receive_bytes") {
          if (t.data.worker_id === void 0)
            throw new Error("worker_id is undefined");
          t.data.worker_id === this.uuid && this.getCommunicationManager().onbytes(t.data.msg);
        }
      }
    }
  }
  async upload_file({
    files: t,
    onProgressCallback: n,
    root: r
  }) {
    const a = [], s = t.length;
    let l = 0;
    if (t.length === 0)
      return "";
    for (let d = 0; d < t.length; d++) {
      const f = t[d], m = new FileReader(), h = new Promise((v, g) => {
        m.onload = async (b) => {
          try {
            const x = b.target.result?.replace(/^data:.+;base64,/, ""), w = f.webkitRelativePath || f.name, k = r ? `${r}/${w}` : w, E = await this._send_cmd({
              cmd: "upload",
              kwargs: { data: x, filename: k },
              wait_for_response: !0
            });
            l++, n && n(l, s), v(E);
          } catch (x) {
            g(x);
          }
        }, m.readAsDataURL(f);
      });
      a.push(h);
    }
    const c = await Promise.all(a);
    return c.reduce((d, f) => {
      const m = f.split("/"), h = d.split("/"), v = [];
      for (let g = 0; g < m.length && m[g] === h[g]; g++)
        v.push(m[g]);
      return v.join("/");
    }, c[0]);
  }
  get ready() {
    return this._workerstate.loaded;
  }
  _storage_key() {
    return `funcnodes_pyodide:worker_export:${this.uuid}`;
  }
  _has_local_storage() {
    try {
      return typeof globalThis < "u" && "localStorage" in globalThis;
    } catch {
      return !1;
    }
  }
  async save_worker_state({ withFiles: t = !0 } = {}) {
    const n = await this.export({ withFiles: t }), r = typeof n == "string" ? n : n?.data;
    if (typeof r != "string")
      throw new Error("export_worker did not return a string export");
    return this._has_local_storage() && globalThis.localStorage.setItem(this._storage_key(), r), r;
  }
  async restore_worker_state(t) {
    if (!this._has_local_storage()) return !1;
    const n = globalThis.localStorage.getItem(
      t || this._storage_key()
    );
    if (!n) return !1;
    try {
      return await this.update_from_export(n), !0;
    } catch (r) {
      return console.warn("Failed to restore worker state from storage", r), !1;
    }
  }
};
const lUe = {}, PF = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (m, h) => {
    const v = typeof m == "function" ? m(t) : m;
    if (!Object.is(v, t)) {
      const g = t;
      t = h ?? (typeof v != "object" || v === null) ? v : Object.assign({}, t, v), n.forEach((b) => b(t, g));
    }
  }, a = () => t, d = { setState: r, getState: a, getInitialState: () => f, subscribe: (m) => (n.add(m), () => n.delete(m)), destroy: () => {
    (lUe ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), n.clear();
  } }, f = t = e(r, a, d);
  return d;
}, uUe = (e) => e ? PF(e) : PF;
var dA = { exports: {} }, fA = {}, pA = { exports: {} }, mA = {};
var DF;
function cUe() {
  if (DF) return mA;
  DF = 1;
  var e = FS();
  function t(h, v) {
    return h === v && (h !== 0 || 1 / h === 1 / v) || h !== h && v !== v;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, a = e.useEffect, s = e.useLayoutEffect, l = e.useDebugValue;
  function c(h, v) {
    var g = v(), b = r({ inst: { value: g, getSnapshot: v } }), x = b[0].inst, w = b[1];
    return s(
      function() {
        x.value = g, x.getSnapshot = v, d(x) && w({ inst: x });
      },
      [h, g, v]
    ), a(
      function() {
        return d(x) && w({ inst: x }), h(function() {
          d(x) && w({ inst: x });
        });
      },
      [h]
    ), l(g), g;
  }
  function d(h) {
    var v = h.getSnapshot;
    h = h.value;
    try {
      var g = v();
      return !n(h, g);
    } catch {
      return !0;
    }
  }
  function f(h, v) {
    return v();
  }
  var m = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? f : c;
  return mA.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : m, mA;
}
var IF;
function dUe() {
  return IF || (IF = 1, pA.exports = cUe()), pA.exports;
}
var $F;
function fUe() {
  if ($F) return fA;
  $F = 1;
  var e = FS(), t = dUe();
  function n(f, m) {
    return f === m && (f !== 0 || 1 / f === 1 / m) || f !== f && m !== m;
  }
  var r = typeof Object.is == "function" ? Object.is : n, a = t.useSyncExternalStore, s = e.useRef, l = e.useEffect, c = e.useMemo, d = e.useDebugValue;
  return fA.useSyncExternalStoreWithSelector = function(f, m, h, v, g) {
    var b = s(null);
    if (b.current === null) {
      var x = { hasValue: !1, value: null };
      b.current = x;
    } else x = b.current;
    b = c(
      function() {
        function k(A) {
          if (!E) {
            if (E = !0, _ = A, A = v(A), g !== void 0 && x.hasValue) {
              var R = x.value;
              if (g(R, A))
                return O = R;
            }
            return O = A;
          }
          if (R = O, r(_, A)) return R;
          var D = v(A);
          return g !== void 0 && g(R, D) ? (_ = A, R) : (_ = A, O = D);
        }
        var E = !1, _, O, N = h === void 0 ? null : h;
        return [
          function() {
            return k(m());
          },
          N === null ? void 0 : function() {
            return k(N());
          }
        ];
      },
      [m, h, v, g]
    );
    var w = a(f, b[0], b[1]);
    return l(
      function() {
        x.hasValue = !0, x.value = w;
      },
      [w]
    ), d(w), w;
  }, fA;
}
var zF;
function pUe() {
  return zF || (zF = 1, dA.exports = fUe()), dA.exports;
}
var mUe = pUe();
const hUe = /* @__PURE__ */ IR(mUe), BJ = {}, { useDebugValue: gUe } = jt, { useSyncExternalStoreWithSelector: vUe } = hUe;
let TF = !1;
const yUe = (e) => e;
function bUe(e, t = yUe, n) {
  (BJ ? "production" : void 0) !== "production" && n && !TF && (console.warn(
    "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
  ), TF = !0);
  const r = vUe(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return gUe(r), r;
}
const LF = (e) => {
  (BJ ? "production" : void 0) !== "production" && typeof e != "function" && console.warn(
    "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
  );
  const t = typeof e == "function" ? uUe(e) : e, n = (r, a) => bUe(t, r, a);
  return Object.assign(n, t), n;
}, wUe = (e) => e ? LF(e) : LF, xUe = ({
  pageOrigin: e,
  scriptUrl: t
}) => {
  if (!e || !t) return !1;
  try {
    return new URL(t).origin !== e;
  } catch {
    return !1;
  }
}, UJ = '(function(){"use strict";const p="https://cdn.jsdelivr.net/pyodide/v0.29.0/full/pyodide.mjs",e=self;e.workerState={pyodide:null,pyodide_url:p,packages:[],state:{msg:"loading",loaded:!1,progress:0},micropip:null,worker:{},pyodideReady:!1,pyodideReadyPromise:null,debug:!1,interruptBuffer:null,receivepy:(r,t)=>{},receivepy_bytes:(r,t)=>{},handel_register:{},post_pyodide_ready:void 0},e.reset=async()=>{for(const r in e.list_workers())try{const t=await e.get_worker(r);t.worker&&t.worker.stop(),t.reject_promise?.("Worker reset")}catch{}e.workerState.pyodide&&e.interrupt(),e.workerState.pyodide=null,e.workerState.micropip=null,e.workerState.worker={},e.workerState.pyodideReady=!1;try{e.workerState.interruptBuffer=new Uint8Array(new SharedArrayBuffer(1)),e.workerState.interruptBuffer[0]=0}catch{}},e.initializePyodide=async()=>{if(!e.workerState.pyodide){console.log("initializePyodide with: Debug:",e.workerState.debug,"Pyodide URL:",e.workerState.pyodide_url,"Packages:",e.workerState.packages),console.debug("Loading Pyodide..."),e.workerState.state.msg="Loading Pyodide...",e.workerState.state.progress=0,await e.reset(),console.debug("Loading Pyodide module..."),e.workerState.state.msg="Loading Pyodide module...",e.workerState.state.progress=.1;const r=await import(e.workerState.pyodide_url);console.debug("Loading Pyodide instance..."),e.workerState.state.msg="Loading Pyodide instance...",e.workerState.state.progress=.2;const t=r.loadPyodide,o=new URL(e.workerState.pyodide_url),n=new URL(".",o).toString();e.workerState.debug&&console.debug("Pyodide indexURL:",n),e.workerState.pyodide=await t({packages:["micropip"],indexURL:n}),e.workerState.interruptBuffer&&e.workerState.pyodide.setInterruptBuffer(e.workerState.interruptBuffer)}e.workerState.micropip||(console.debug("Importing micropip..."),e.workerState.state.msg="Importing micropip...",e.workerState.state.progress=.3,e.workerState.micropip=e.workerState.pyodide.pyimport("micropip")),console.debug("Pyodide ready. Installing funcnodes...");for(const r of e.workerState.packages)console.log("Installing package:",r),e.workerState.state.msg=`Installing package: ${r}`,await e.workerState.micropip.install(r);return e.workerState.state.msg="Installing funcnodes",e.workerState.state.progress=.8,await e.workerState.micropip.install("funcnodes"),e.workerState.state.msg="Installing funcnodes-worker",await e.workerState.micropip.install("funcnodes-worker"),e.workerState.packages.some(r=>r.toLowerCase().endsWith(".whl")&&r.includes("funcnodes_pyodide"))?e.workerState.debug&&console.debug("Skipping PyPI funcnodes-pyodide install (wheel provided in packages)"):(e.workerState.state.msg="Installing funcnodes-pyodide",await e.workerState.micropip.install("funcnodes-pyodide")),e.workerState.state.msg="Installing funcnodes-react-flow",await e.workerState.micropip.install("funcnodes-react-flow"),e.workerState.state.msg="Importing funcnodes",console.debug("Importing funcnodes..."),await e.workerState.pyodide.runPythonAsync("import funcnodes_pyodide"),console.debug("Running post_pyodide_ready..."),await e.workerState.post_pyodide_ready?.(e.workerState),console.debug("Pyodide ready"),e.workerState.state.msg="ready",e.workerState.state.progress=.1,e.workerState.pyodideReady=!0,{pyodide:e.workerState.pyodide,micropip:e.workerState.micropip}},e.interrupt=()=>{e.workerState.interruptBuffer&&(e.workerState.interruptBuffer[0]=1)},e.list_workers=()=>Object.keys(e.workerState.worker),e.get_worker=async r=>{if(!r)throw new Error("Worker id is required");if(!e.workerState.worker[r])throw new Error(`Worker with id ${r} not found`);return await e.workerState.worker[r].make_promise,e.workerState.worker[r]},e.has_worker=r=>{if(!r)throw new Error("Worker id is required");return!!e.workerState.worker[r]},e.get_or_create_worker=async r=>{if(!r)throw new Error("Worker id is required");return e.workerState.worker[r]||(console.log("Creating worker with id",r),await e.initializeFuncNodesWorker(r)),e.get_worker(r)},e.initializeFuncNodesWorker=async r=>{try{if(!e.workerState.pyodideReadyPromise)throw new Error("Pyodide newer initialized");const{pyodide:t}=await e.workerState.pyodideReadyPromise;if(!e.has_worker(r)){e.workerState.worker[r]={worker:null,make_promise:void 0};const o=new Promise(async(n,s)=>{e.workerState.worker[r].reject_promise=s,console.debug(`Creating worker (${r})...`);const i=await t.runPythonAsync(`funcnodes_pyodide.new_worker(debug=${e.workerState.debug?1:0}, uuid="${r}")`);if(console.debug("Worker created:",i),typeof i.set_receiver=="function")i.set_receiver(self);else throw new Error("Worker does not expose a \'set_receiver\' method.");e.workerState.worker[r].worker=i,console.debug("Worker ready"),n(i)});e.workerState.worker[r].make_promise=o}return e.get_worker(r)}catch(t){throw console.error("Error during worker initialization:",t),t}},e.receivepy=(r,t)=>{try{let o={};if(typeof r=="string"?o.msg=r:o=r,o.msg===void 0)return;typeof o.msg!="string"&&(o.msg=JSON.stringify(o.msg)),t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const n=o.worker_id;if(!n)throw new Error(`Worker id not provided in receivepy(${JSON.stringify(o)})`);if(!e.workerState.worker[n])throw new Error(`Worker with id ${n} not found in receivepy(${JSON.stringify(o)})`);e.workerState.receivepy(r,n)}catch(o){console.error("Error during receivepy:",o);return}},e.receivepy_bytes=(r,t)=>{let o=r;const n=r;if(n&&typeof n.toJs=="function")try{o=n.toJs({dict_converter:Object.fromEntries})}catch{o=n.toJs()}o instanceof Map&&(o=Object.fromEntries(o.entries()));try{let s={};if(o instanceof Uint8Array?s.msg=o:s=o,s.msg===void 0)return;let i=s.msg;const a=i;if(a&&typeof a.toJs=="function")try{i=a.toJs({dict_converter:Object.fromEntries})}catch{i=a.toJs()}if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),Array.isArray(i)&&(i=Uint8Array.from(i)),!(i instanceof Uint8Array))throw new Error(`receivepy_bytes expected Uint8Array payload, got ${typeof i}`);s.msg=i,t!==void 0&&(typeof t=="string"?s.worker_id||(s.worker_id=t):s={...t,...s});const d=s.worker_id;if(!d)throw new Error("Worker id not provided in receivepy_bytes");if(!e.workerState.worker[d])throw new Error(`Worker with id ${d} not found in receivepy_bytes`);e.workerState.receivepy_bytes(s.msg,d)}catch(s){console.error("Error during receivepy_bytes:",s);return}},e.startInitialization=({debug:r=!1,receivepy:t,receivepy_bytes:o,pyodide_url:n,post_pyodide_ready:s,packages:i})=>(e.workerState.debug=r,e.workerState.pyodide_url=n||p,e.workerState.packages=i,e.workerState.receivepy=t,e.workerState.receivepy_bytes=o,e.workerState.pyodideReadyPromise=null,e.workerState.post_pyodide_ready=s,e.workerState),e.register_cmd_message=(r,t)=>{if(e.workerState.handel_register[r])throw new Error(`Command ${r} already registered`);e.workerState.handel_register[r]=t},e.register_cmd_message("ping",async r=>"pong"),e.register_cmd_message("init",async r=>{if(e.workerState.pyodideReadyPromise)throw new Error("Pyodide is already initialized");r.data&&(r.data.pyodide_url&&(e.workerState.pyodide_url=r.data.pyodide_url),r.data.packages&&(e.workerState.packages=r.data.packages),r.data.debug&&(e.workerState.debug=r.data.debug)),e.workerState.pyodideReadyPromise=e.initializePyodide()}),e.register_cmd_message("_eval",async r=>{try{const t=await e.workerState.pyodide?.runPythonAsync(r.msg||"print(\'No code provided\')");return console.log("Eval result:",t),t}catch(t){console.error("Error during _eval:",t)}}),e.register_cmd_message("state",async r=>({state:{...e.workerState.state,loaded:e.workerState.pyodideReady}})),e.register_cmd_message("worker:state",async r=>({state:{loaded:!!(await e.get_or_create_worker(r.worker_id)).worker}})),e.register_cmd_message("worker:stop",async r=>{if(!e.has_worker(r.worker_id))return;const t=await e.get_or_create_worker(r.worker_id);return t.worker&&(t.worker.stop(),t.worker=null,t.reject_promise?.("Worker stopped")),delete e.workerState.worker[r.worker_id],{state:{loaded:!1}}}),e.register_cmd_message("worker:send",async r=>{const t=await e.get_or_create_worker(r.worker_id);if(!t.worker)throw new Error("Worker is not initialized");if(typeof t.worker.receivejs!="function")throw new Error(`Worker does not support receivejs: ${typeof t.worker.receivejs}`);t.worker.receivejs(r.msg)}),e.handleMessage=async r=>{const t={original:r};r.id&&(t.id=r.id),r.toJs===void 0&&(r.toJs=!0);try{if(r.cmd){const o=r;if(e.workerState.handel_register[o.cmd])t.result=await e.workerState.handel_register[o.cmd](o);else throw new Error("Unknown command: "+o.cmd)}else throw new Error("Unknown message format: "+JSON.stringify(r))}catch(o){t.error=o.message}return t},e.read_url_params=()=>{const r=new URLSearchParams(self.location.search),t=r.get("debug")?.toLowerCase()==="true",o=r.get("pyodide_url")||void 0,n=r.get("packages")?.split(",")||[];return{debug:t,pyodide_url:o,packages:n}};const k=r=>{const t=new Set;return{add:o=>{t.add(o)},disconnect:o=>{t.delete(o)&&t.size===0&&r()},forEach:o=>{t.forEach(o)},size:()=>t.size}},w=e;w.general_initalization=r=>{const t=w.read_url_params();w.startInitialization({...r,...t})};const l=w,g=w;g.init_dedicated_worker=r=>{const t=e;t.onmessage=async n=>{const s=n.data,i=await t.handleMessage(s);t.postMessage(i)};const o={...r,receivepy:(n,s)=>{t.postMessage({cmd:"receive",msg:n,worker_id:s})},receivepy_bytes(n,s){t.postMessage({cmd:"receive_bytes",msg:n,worker_id:s})}};t.general_initalization(o)},l.init_shared_worker=r=>{const t=e,o=k(()=>{try{t.close()}catch{}});t.connectedPorts=[],t.onconnect=s=>{const i=s.ports[0];t.connectedPorts.push(i),o.add(i),i.start(),console.debug("Port connected in shared worker"),i.onmessage=async a=>{const d=a.data;if(d?.cmd==="disconnect"){o.disconnect(i),t.connectedPorts=t.connectedPorts.filter(m=>m!==i);try{i.onmessage=null}catch{}try{i.close()}catch{}return}const y=await t.handleMessage(d);i.postMessage(y)}};const n={...r,receivepy:(s,i)=>{o.forEach(a=>{a.postMessage({cmd:"receive",msg:s,worker_id:i})})},receivepy_bytes(s,i){o.forEach(a=>{a.postMessage({cmd:"receive_bytes",msg:s,worker_id:i})})}};t.general_initalization(n)};const u=r=>{w.init_dedicated_worker(r)};var _=`from __future__ import annotations\nimport funcnodes_core as fn\n\nfn.node.ALLOW_REGISTERED_NODES_OVERRIDE = True\n\n\ndef eval_node_code(code: str):\n    ns = {}  # dedicated namespace acting as globals\n    exec(code, ns)\n    _node = [\n        cls\n        for name, cls in ns.items()\n        if isinstance(cls, type) and issubclass(cls, fn.Node)\n    ][-1]\n    return _node\n`;function f(r){if(typeof r!="string"||!r.length)return[];const t=[],o=new Set,n=r.split(/\\r?\\n/);for(const s of n){const i=s.match(/^\\s*#\\s*requires\\b\\s*:?\\s*(.*)$/i);if(!i)continue;const a=(i[1]??"").trim();if(a)for(const d of a.split(/[,\\s]+/)){const y=d.trim();y&&(o.has(y)||(o.add(y),t.push(y)))}}return t}const c=w;c.nodebuilder_post_pyodide_ready=async r=>{await r.pyodide.runPythonAsync(_)},c.receivepy_bytes=(r,t)=>{let o=r;const n=r;if(n&&typeof n.toJs=="function")try{o=n.toJs({dict_converter:Object.fromEntries})}catch{o=n.toJs()}o instanceof Map&&(o=Object.fromEntries(o.entries()));try{let s={};if(o instanceof Uint8Array?s.msg=o:s=o,s.msg===void 0)return;let i=s.msg;const a=i;if(a&&typeof a.toJs=="function")try{i=a.toJs({dict_converter:Object.fromEntries})}catch{i=a.toJs()}if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),Array.isArray(i)&&(i=Uint8Array.from(i)),!(i instanceof Uint8Array))throw new Error(`receivepy_bytes expected Uint8Array payload, got ${typeof i}`);s.msg=i,t!==void 0&&(typeof t=="string"?s.worker_id||(s.worker_id=t):s={...t,...s});const d=s.worker_id;if(!d)throw new Error("Worker id not provided in receivepy_bytes");if(!c.workerState.worker[d])throw new Error(`Worker with id ${d} not found in receivepy_bytes`);c.workerState.receivepy_bytes(s.msg,d)}catch(s){console.error("Error during receivepy_bytes:",s)}},c.register_cmd_message("worker:evalnode",async r=>{const t=r.msg;console.log("evalnode",t);const o=f(t);console.log("requires",o);for(const i of o)await c.workerState.micropip.install(i);const n=await c.workerState.pyodide?.runPythonAsync(`eval_node_code(${JSON.stringify(t)})`);if(!n)return;const s=await c.get_or_create_worker(r.worker_id);s.worker.clear(),s.worker.nodespace.lib.add_node(n,"demo"),s.worker.add_node(n.node_id)}),u({post_pyodide_ready:c.nodebuilder_post_pyodide_ready})})();\n', FF = typeof self < "u" && self.Blob && new Blob(["(self.URL || self.webkitURL).revokeObjectURL(self.location.href);", UJ], { type: "text/javascript;charset=utf-8" });
function BF(e) {
  let t;
  try {
    if (t = FF && (self.URL || self.webkitURL).createObjectURL(FF), !t) throw "";
    const n = new Worker(t, {
      name: e?.name
    });
    return n.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(t);
    }), n;
  } catch {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(UJ),
      {
        name: e?.name
      }
    );
  }
}
const SUe = '(function(){"use strict";const p="https://cdn.jsdelivr.net/pyodide/v0.29.0/full/pyodide.mjs",e=self;e.workerState={pyodide:null,pyodide_url:p,packages:[],state:{msg:"loading",loaded:!1,progress:0},micropip:null,worker:{},pyodideReady:!1,pyodideReadyPromise:null,debug:!1,interruptBuffer:null,receivepy:(r,t)=>{},receivepy_bytes:(r,t)=>{},handel_register:{},post_pyodide_ready:void 0},e.reset=async()=>{for(const r in e.list_workers())try{const t=await e.get_worker(r);t.worker&&t.worker.stop(),t.reject_promise?.("Worker reset")}catch{}e.workerState.pyodide&&e.interrupt(),e.workerState.pyodide=null,e.workerState.micropip=null,e.workerState.worker={},e.workerState.pyodideReady=!1;try{e.workerState.interruptBuffer=new Uint8Array(new SharedArrayBuffer(1)),e.workerState.interruptBuffer[0]=0}catch{}},e.initializePyodide=async()=>{if(!e.workerState.pyodide){console.log("initializePyodide with: Debug:",e.workerState.debug,"Pyodide URL:",e.workerState.pyodide_url,"Packages:",e.workerState.packages),console.debug("Loading Pyodide..."),e.workerState.state.msg="Loading Pyodide...",e.workerState.state.progress=0,await e.reset(),console.debug("Loading Pyodide module..."),e.workerState.state.msg="Loading Pyodide module...",e.workerState.state.progress=.1;const r=await import(e.workerState.pyodide_url);console.debug("Loading Pyodide instance..."),e.workerState.state.msg="Loading Pyodide instance...",e.workerState.state.progress=.2;const t=r.loadPyodide,o=new URL(e.workerState.pyodide_url),n=new URL(".",o).toString();e.workerState.debug&&console.debug("Pyodide indexURL:",n),e.workerState.pyodide=await t({packages:["micropip"],indexURL:n}),e.workerState.interruptBuffer&&e.workerState.pyodide.setInterruptBuffer(e.workerState.interruptBuffer)}e.workerState.micropip||(console.debug("Importing micropip..."),e.workerState.state.msg="Importing micropip...",e.workerState.state.progress=.3,e.workerState.micropip=e.workerState.pyodide.pyimport("micropip")),console.debug("Pyodide ready. Installing funcnodes...");for(const r of e.workerState.packages)console.log("Installing package:",r),e.workerState.state.msg=`Installing package: ${r}`,await e.workerState.micropip.install(r);return e.workerState.state.msg="Installing funcnodes",e.workerState.state.progress=.8,await e.workerState.micropip.install("funcnodes"),e.workerState.state.msg="Installing funcnodes-worker",await e.workerState.micropip.install("funcnodes-worker"),e.workerState.packages.some(r=>r.toLowerCase().endsWith(".whl")&&r.includes("funcnodes_pyodide"))?e.workerState.debug&&console.debug("Skipping PyPI funcnodes-pyodide install (wheel provided in packages)"):(e.workerState.state.msg="Installing funcnodes-pyodide",await e.workerState.micropip.install("funcnodes-pyodide")),e.workerState.state.msg="Installing funcnodes-react-flow",await e.workerState.micropip.install("funcnodes-react-flow"),e.workerState.state.msg="Importing funcnodes",console.debug("Importing funcnodes..."),await e.workerState.pyodide.runPythonAsync("import funcnodes_pyodide"),console.debug("Running post_pyodide_ready..."),await e.workerState.post_pyodide_ready?.(e.workerState),console.debug("Pyodide ready"),e.workerState.state.msg="ready",e.workerState.state.progress=.1,e.workerState.pyodideReady=!0,{pyodide:e.workerState.pyodide,micropip:e.workerState.micropip}},e.interrupt=()=>{e.workerState.interruptBuffer&&(e.workerState.interruptBuffer[0]=1)},e.list_workers=()=>Object.keys(e.workerState.worker),e.get_worker=async r=>{if(!r)throw new Error("Worker id is required");if(!e.workerState.worker[r])throw new Error(`Worker with id ${r} not found`);return await e.workerState.worker[r].make_promise,e.workerState.worker[r]},e.has_worker=r=>{if(!r)throw new Error("Worker id is required");return!!e.workerState.worker[r]},e.get_or_create_worker=async r=>{if(!r)throw new Error("Worker id is required");return e.workerState.worker[r]||(console.log("Creating worker with id",r),await e.initializeFuncNodesWorker(r)),e.get_worker(r)},e.initializeFuncNodesWorker=async r=>{try{if(!e.workerState.pyodideReadyPromise)throw new Error("Pyodide newer initialized");const{pyodide:t}=await e.workerState.pyodideReadyPromise;if(!e.has_worker(r)){e.workerState.worker[r]={worker:null,make_promise:void 0};const o=new Promise(async(n,s)=>{e.workerState.worker[r].reject_promise=s,console.debug(`Creating worker (${r})...`);const i=await t.runPythonAsync(`funcnodes_pyodide.new_worker(debug=${e.workerState.debug?1:0}, uuid="${r}")`);if(console.debug("Worker created:",i),typeof i.set_receiver=="function")i.set_receiver(self);else throw new Error("Worker does not expose a \'set_receiver\' method.");e.workerState.worker[r].worker=i,console.debug("Worker ready"),n(i)});e.workerState.worker[r].make_promise=o}return e.get_worker(r)}catch(t){throw console.error("Error during worker initialization:",t),t}},e.receivepy=(r,t)=>{try{let o={};if(typeof r=="string"?o.msg=r:o=r,o.msg===void 0)return;typeof o.msg!="string"&&(o.msg=JSON.stringify(o.msg)),t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const n=o.worker_id;if(!n)throw new Error(`Worker id not provided in receivepy(${JSON.stringify(o)})`);if(!e.workerState.worker[n])throw new Error(`Worker with id ${n} not found in receivepy(${JSON.stringify(o)})`);e.workerState.receivepy(r,n)}catch(o){console.error("Error during receivepy:",o);return}},e.receivepy_bytes=(r,t)=>{let o=r;const n=r;if(n&&typeof n.toJs=="function")try{o=n.toJs({dict_converter:Object.fromEntries})}catch{o=n.toJs()}o instanceof Map&&(o=Object.fromEntries(o.entries()));try{let s={};if(o instanceof Uint8Array?s.msg=o:s=o,s.msg===void 0)return;let i=s.msg;const a=i;if(a&&typeof a.toJs=="function")try{i=a.toJs({dict_converter:Object.fromEntries})}catch{i=a.toJs()}if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),Array.isArray(i)&&(i=Uint8Array.from(i)),!(i instanceof Uint8Array))throw new Error(`receivepy_bytes expected Uint8Array payload, got ${typeof i}`);s.msg=i,t!==void 0&&(typeof t=="string"?s.worker_id||(s.worker_id=t):s={...t,...s});const d=s.worker_id;if(!d)throw new Error("Worker id not provided in receivepy_bytes");if(!e.workerState.worker[d])throw new Error(`Worker with id ${d} not found in receivepy_bytes`);e.workerState.receivepy_bytes(s.msg,d)}catch(s){console.error("Error during receivepy_bytes:",s);return}},e.startInitialization=({debug:r=!1,receivepy:t,receivepy_bytes:o,pyodide_url:n,post_pyodide_ready:s,packages:i})=>(e.workerState.debug=r,e.workerState.pyodide_url=n||p,e.workerState.packages=i,e.workerState.receivepy=t,e.workerState.receivepy_bytes=o,e.workerState.pyodideReadyPromise=null,e.workerState.post_pyodide_ready=s,e.workerState),e.register_cmd_message=(r,t)=>{if(e.workerState.handel_register[r])throw new Error(`Command ${r} already registered`);e.workerState.handel_register[r]=t},e.register_cmd_message("ping",async r=>"pong"),e.register_cmd_message("init",async r=>{if(e.workerState.pyodideReadyPromise)throw new Error("Pyodide is already initialized");r.data&&(r.data.pyodide_url&&(e.workerState.pyodide_url=r.data.pyodide_url),r.data.packages&&(e.workerState.packages=r.data.packages),r.data.debug&&(e.workerState.debug=r.data.debug)),e.workerState.pyodideReadyPromise=e.initializePyodide()}),e.register_cmd_message("_eval",async r=>{try{const t=await e.workerState.pyodide?.runPythonAsync(r.msg||"print(\'No code provided\')");return console.log("Eval result:",t),t}catch(t){console.error("Error during _eval:",t)}}),e.register_cmd_message("state",async r=>({state:{...e.workerState.state,loaded:e.workerState.pyodideReady}})),e.register_cmd_message("worker:state",async r=>({state:{loaded:!!(await e.get_or_create_worker(r.worker_id)).worker}})),e.register_cmd_message("worker:stop",async r=>{if(!e.has_worker(r.worker_id))return;const t=await e.get_or_create_worker(r.worker_id);return t.worker&&(t.worker.stop(),t.worker=null,t.reject_promise?.("Worker stopped")),delete e.workerState.worker[r.worker_id],{state:{loaded:!1}}}),e.register_cmd_message("worker:send",async r=>{const t=await e.get_or_create_worker(r.worker_id);if(!t.worker)throw new Error("Worker is not initialized");if(typeof t.worker.receivejs!="function")throw new Error(`Worker does not support receivejs: ${typeof t.worker.receivejs}`);t.worker.receivejs(r.msg)}),e.handleMessage=async r=>{const t={original:r};r.id&&(t.id=r.id),r.toJs===void 0&&(r.toJs=!0);try{if(r.cmd){const o=r;if(e.workerState.handel_register[o.cmd])t.result=await e.workerState.handel_register[o.cmd](o);else throw new Error("Unknown command: "+o.cmd)}else throw new Error("Unknown message format: "+JSON.stringify(r))}catch(o){t.error=o.message}return t},e.read_url_params=()=>{const r=new URLSearchParams(self.location.search),t=r.get("debug")?.toLowerCase()==="true",o=r.get("pyodide_url")||void 0,n=r.get("packages")?.split(",")||[];return{debug:t,pyodide_url:o,packages:n}};const k=r=>{const t=new Set;return{add:o=>{t.add(o)},disconnect:o=>{t.delete(o)&&t.size===0&&r()},forEach:o=>{t.forEach(o)},size:()=>t.size}},w=e;w.general_initalization=r=>{const t=w.read_url_params();w.startInitialization({...r,...t})};const l=w,g=w;g.init_dedicated_worker=r=>{const t=e;t.onmessage=async n=>{const s=n.data,i=await t.handleMessage(s);t.postMessage(i)};const o={...r,receivepy:(n,s)=>{t.postMessage({cmd:"receive",msg:n,worker_id:s})},receivepy_bytes(n,s){t.postMessage({cmd:"receive_bytes",msg:n,worker_id:s})}};t.general_initalization(o)},l.init_shared_worker=r=>{const t=e,o=k(()=>{try{t.close()}catch{}});t.connectedPorts=[],t.onconnect=s=>{const i=s.ports[0];t.connectedPorts.push(i),o.add(i),i.start(),console.debug("Port connected in shared worker"),i.onmessage=async a=>{const d=a.data;if(d?.cmd==="disconnect"){o.disconnect(i),t.connectedPorts=t.connectedPorts.filter(m=>m!==i);try{i.onmessage=null}catch{}try{i.close()}catch{}return}const y=await t.handleMessage(d);i.postMessage(y)}};const n={...r,receivepy:(s,i)=>{o.forEach(a=>{a.postMessage({cmd:"receive",msg:s,worker_id:i})})},receivepy_bytes(s,i){o.forEach(a=>{a.postMessage({cmd:"receive_bytes",msg:s,worker_id:i})})}};t.general_initalization(n)};const _=r=>{w.init_shared_worker(r)};var u=`from __future__ import annotations\nimport funcnodes_core as fn\n\nfn.node.ALLOW_REGISTERED_NODES_OVERRIDE = True\n\n\ndef eval_node_code(code: str):\n    ns = {}  # dedicated namespace acting as globals\n    exec(code, ns)\n    _node = [\n        cls\n        for name, cls in ns.items()\n        if isinstance(cls, type) and issubclass(cls, fn.Node)\n    ][-1]\n    return _node\n`;function f(r){if(typeof r!="string"||!r.length)return[];const t=[],o=new Set,n=r.split(/\\r?\\n/);for(const s of n){const i=s.match(/^\\s*#\\s*requires\\b\\s*:?\\s*(.*)$/i);if(!i)continue;const a=(i[1]??"").trim();if(a)for(const d of a.split(/[,\\s]+/)){const y=d.trim();y&&(o.has(y)||(o.add(y),t.push(y)))}}return t}const c=w;c.nodebuilder_post_pyodide_ready=async r=>{await r.pyodide.runPythonAsync(u)},c.receivepy_bytes=(r,t)=>{let o=r;const n=r;if(n&&typeof n.toJs=="function")try{o=n.toJs({dict_converter:Object.fromEntries})}catch{o=n.toJs()}o instanceof Map&&(o=Object.fromEntries(o.entries()));try{let s={};if(o instanceof Uint8Array?s.msg=o:s=o,s.msg===void 0)return;let i=s.msg;const a=i;if(a&&typeof a.toJs=="function")try{i=a.toJs({dict_converter:Object.fromEntries})}catch{i=a.toJs()}if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),Array.isArray(i)&&(i=Uint8Array.from(i)),!(i instanceof Uint8Array))throw new Error(`receivepy_bytes expected Uint8Array payload, got ${typeof i}`);s.msg=i,t!==void 0&&(typeof t=="string"?s.worker_id||(s.worker_id=t):s={...t,...s});const d=s.worker_id;if(!d)throw new Error("Worker id not provided in receivepy_bytes");if(!c.workerState.worker[d])throw new Error(`Worker with id ${d} not found in receivepy_bytes`);c.workerState.receivepy_bytes(s.msg,d)}catch(s){console.error("Error during receivepy_bytes:",s)}},c.register_cmd_message("worker:evalnode",async r=>{const t=r.msg;console.log("evalnode",t);const o=f(t);console.log("requires",o);for(const i of o)await c.workerState.micropip.install(i);const n=await c.workerState.pyodide?.runPythonAsync(`eval_node_code(${JSON.stringify(t)})`);if(!n)return;const s=await c.get_or_create_worker(r.worker_id);s.worker.clear(),s.worker.nodespace.lib.add_node(n,"demo"),s.worker.add_node(n.node_id)}),_({post_pyodide_ready:c.nodebuilder_post_pyodide_ready})})();\n';
function UF(e) {
  return new SharedWorker(
    "data:text/javascript;charset=utf-8," + encodeURIComponent(SUe),
    {
      name: e?.name
    }
  );
}
const VJ = (e) => {
  if (e.worker) return e.worker;
  const t = e.uuid, n = !!e.shared_worker, r = xUe({
    pageOrigin: typeof window < "u" && window.location ? window.location.origin : void 0,
    scriptUrl: typeof import.meta < "u" ? import.meta.url : void 0
  });
  if (n) {
    if (typeof SharedWorker > "u")
      throw new Error("SharedWorker is not available");
    if (r) return new UF({ name: t });
    try {
      return new SharedWorker(
        new URL(
          /* @vite-ignore */
          "" + new URL("assets/pyodideSharedWorker-CRuL6dYK.js", import.meta.url).href,
          import.meta.url
        ),
        { name: t, type: "module" }
      );
    } catch {
      return new UF({ name: t });
    }
  }
  if (typeof Worker > "u")
    throw new Error("Worker is not available");
  if (r) return new BF({ name: t });
  try {
    return new Worker(
      new URL(
        /* @vite-ignore */
        "" + new URL("assets/pyodideDedicatedWorker-Byca9g4Z.js", import.meta.url).href,
        import.meta.url
      ),
      {
        name: t,
        type: "module"
      }
    );
  } catch {
    return new BF({ name: t });
  }
};
function VF(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function kUe(e) {
  if (Array.isArray(e)) return e;
}
function _Ue(e, t, n) {
  return (t = RUe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function EUe(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, a, s, l, c = [], d = !0, f = !1;
    try {
      if (s = (n = n.call(e)).next, t !== 0) for (; !(d = (r = s.call(n)).done) && (c.push(r.value), c.length !== t); d = !0) ;
    } catch (m) {
      f = !0, a = m;
    } finally {
      try {
        if (!d && n.return != null && (l = n.return(), Object(l) !== l)) return;
      } finally {
        if (f) throw a;
      }
    }
    return c;
  }
}
function CUe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function HF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function WF(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HF(Object(n), !0).forEach(function(r) {
      _Ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function OUe(e, t) {
  if (e == null) return {};
  var n, r, a = MUe(e, t);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    for (r = 0; r < s.length; r++) n = s[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (a[n] = e[n]);
  }
  return a;
}
function MUe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function NUe(e, t) {
  return kUe(e) || EUe(e, t) || jUe(e, t) || CUe();
}
function AUe(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function RUe(e) {
  var t = AUe(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function jUe(e, t) {
  if (e) {
    if (typeof e == "string") return VF(e, t);
    var n = {}.toString.call(e).slice(8, -1);
    return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? VF(e, t) : void 0;
  }
}
function PUe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function qF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function GF(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qF(Object(n), !0).forEach(function(r) {
      PUe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function DUe() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return function(r) {
    return t.reduceRight(function(a, s) {
      return s(a);
    }, r);
  };
}
function Ox(e) {
  return function t() {
    for (var n = this, r = arguments.length, a = new Array(r), s = 0; s < r; s++)
      a[s] = arguments[s];
    return a.length >= e.length ? e.apply(this, a) : function() {
      for (var l = arguments.length, c = new Array(l), d = 0; d < l; d++)
        c[d] = arguments[d];
      return t.apply(n, [].concat(a, c));
    };
  };
}
function tE(e) {
  return {}.toString.call(e).includes("Object");
}
function IUe(e) {
  return !Object.keys(e).length;
}
function zS(e) {
  return typeof e == "function";
}
function $Ue(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function zUe(e, t) {
  return tE(t) || _d("changeType"), Object.keys(t).some(function(n) {
    return !$Ue(e, n);
  }) && _d("changeField"), t;
}
function TUe(e) {
  zS(e) || _d("selectorType");
}
function LUe(e) {
  zS(e) || tE(e) || _d("handlerType"), tE(e) && Object.values(e).some(function(t) {
    return !zS(t);
  }) && _d("handlersType");
}
function FUe(e) {
  e || _d("initialIsRequired"), tE(e) || _d("initialType"), IUe(e) && _d("initialContent");
}
function BUe(e, t) {
  throw new Error(e[t] || e.default);
}
var UUe = {
  initialIsRequired: "initial state is required",
  initialType: "initial state should be an object",
  initialContent: "initial state shouldn't be an empty object",
  handlerType: "handler should be an object or a function",
  handlersType: "all handlers should be a functions",
  selectorType: "selector should be a function",
  changeType: "provided value of changes should be an object",
  changeField: 'it seams you want to change a field in the state which is not specified in the "initial" state',
  default: "an unknown error accured in `state-local` package"
}, _d = Ox(BUe)(UUe), g_ = {
  changes: zUe,
  selector: TUe,
  handler: LUe,
  initial: FUe
};
function VUe(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  g_.initial(e), g_.handler(t);
  var n = {
    current: e
  }, r = Ox(qUe)(n, t), a = Ox(WUe)(n), s = Ox(g_.changes)(e), l = Ox(HUe)(n);
  function c() {
    var f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function(m) {
      return m;
    };
    return g_.selector(f), f(n.current);
  }
  function d(f) {
    DUe(r, a, s, l)(f);
  }
  return [c, d];
}
function HUe(e, t) {
  return zS(t) ? t(e.current) : t;
}
function WUe(e, t) {
  return e.current = GF(GF({}, e.current), t), t;
}
function qUe(e, t, n) {
  return zS(t) ? t(e.current) : Object.keys(n).forEach(function(r) {
    var a;
    return (a = t[r]) === null || a === void 0 ? void 0 : a.call(t, e.current[r]);
  }), n;
}
var GUe = {
  create: VUe
}, KUe = {
  paths: {
    vs: "https://cdn.jsdelivr.net/npm/monaco-editor@0.55.1/min/vs"
  }
};
function YUe(e) {
  return function t() {
    for (var n = this, r = arguments.length, a = new Array(r), s = 0; s < r; s++)
      a[s] = arguments[s];
    return a.length >= e.length ? e.apply(this, a) : function() {
      for (var l = arguments.length, c = new Array(l), d = 0; d < l; d++)
        c[d] = arguments[d];
      return t.apply(n, [].concat(a, c));
    };
  };
}
function XUe(e) {
  return {}.toString.call(e).includes("Object");
}
function JUe(e) {
  return e || KF("configIsRequired"), XUe(e) || KF("configType"), e.urls ? (QUe(), {
    paths: {
      vs: e.urls.monacoBase
    }
  }) : e;
}
function QUe() {
  console.warn(HJ.deprecation);
}
function ZUe(e, t) {
  throw new Error(e[t] || e.default);
}
var HJ = {
  configIsRequired: "the configuration object is required",
  configType: "the configuration object should be an object",
  default: "an unknown error accured in `@monaco-editor/loader` package",
  deprecation: `Deprecation warning!
    You are using deprecated way of configuration.

    Instead of using
      monaco.config({ urls: { monacoBase: '...' } })
    use
      monaco.config({ paths: { vs: '...' } })

    For more please check the link https://github.com/suren-atoyan/monaco-loader#config
  `
}, KF = YUe(ZUe)(HJ), eVe = {
  config: JUe
}, tVe = function() {
  for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
    n[r] = arguments[r];
  return function(a) {
    return n.reduceRight(function(s, l) {
      return l(s);
    }, a);
  };
};
function WJ(e, t) {
  return Object.keys(t).forEach(function(n) {
    t[n] instanceof Object && e[n] && Object.assign(t[n], WJ(e[n], t[n]));
  }), WF(WF({}, e), t);
}
var nVe = {
  type: "cancelation",
  msg: "operation is manually canceled"
};
function hA(e) {
  var t = !1, n = new Promise(function(r, a) {
    e.then(function(s) {
      return t ? a(nVe) : r(s);
    }), e.catch(a);
  });
  return n.cancel = function() {
    return t = !0;
  }, n;
}
var rVe = ["monaco"], oVe = GUe.create({
  config: KUe,
  isInitialized: !1,
  resolve: null,
  reject: null,
  monaco: null
}), qJ = NUe(oVe, 2), $k = qJ[0], JC = qJ[1];
function aVe(e) {
  var t = eVe.config(e), n = t.monaco, r = OUe(t, rVe);
  JC(function(a) {
    return {
      config: WJ(a.config, r),
      monaco: n
    };
  });
}
function iVe() {
  var e = $k(function(t) {
    var n = t.monaco, r = t.isInitialized, a = t.resolve;
    return {
      monaco: n,
      isInitialized: r,
      resolve: a
    };
  });
  if (!e.isInitialized) {
    if (JC({
      isInitialized: !0
    }), e.monaco)
      return e.resolve(e.monaco), hA(gA);
    if (window.monaco && window.monaco.editor)
      return GJ(window.monaco), e.resolve(window.monaco), hA(gA);
    tVe(sVe, uVe)(cVe);
  }
  return hA(gA);
}
function sVe(e) {
  return document.body.appendChild(e);
}
function lVe(e) {
  var t = document.createElement("script");
  return e && (t.src = e), t;
}
function uVe(e) {
  var t = $k(function(r) {
    var a = r.config, s = r.reject;
    return {
      config: a,
      reject: s
    };
  }), n = lVe("".concat(t.config.paths.vs, "/loader.js"));
  return n.onload = function() {
    return e();
  }, n.onerror = t.reject, n;
}
function cVe() {
  var e = $k(function(n) {
    var r = n.config, a = n.resolve, s = n.reject;
    return {
      config: r,
      resolve: a,
      reject: s
    };
  }), t = window.require;
  t.config(e.config), t(["vs/editor/editor.main"], function(n) {
    var r = n.m || n;
    GJ(r), e.resolve(r);
  }, function(n) {
    e.reject(n);
  });
}
function GJ(e) {
  $k().monaco || JC({
    monaco: e
  });
}
function dVe() {
  return $k(function(e) {
    var t = e.monaco;
    return t;
  });
}
var gA = new Promise(function(e, t) {
  return JC({
    resolve: e,
    reject: t
  });
}), KJ = {
  config: aVe,
  init: iVe,
  __getMonacoInstance: dVe
}, fVe = { wrapper: { display: "flex", position: "relative", textAlign: "initial" }, fullWidth: { width: "100%" }, hide: { display: "none" } }, vA = fVe, pVe = { container: { display: "flex", height: "100%", width: "100%", justifyContent: "center", alignItems: "center" } }, mVe = pVe;
function hVe({ children: e }) {
  return jt.createElement("div", { style: mVe.container }, e);
}
var gVe = hVe, vVe = gVe;
function yVe({ width: e, height: t, isEditorReady: n, loading: r, _ref: a, className: s, wrapperProps: l }) {
  return jt.createElement("section", { style: { ...vA.wrapper, width: e, height: t }, ...l }, !n && jt.createElement(vVe, null, r), jt.createElement("div", { ref: a, style: { ...vA.fullWidth, ...!n && vA.hide }, className: s }));
}
var bVe = yVe, YJ = M.memo(bVe);
function wVe(e) {
  M.useEffect(e, []);
}
var XJ = wVe;
function xVe(e, t, n = !0) {
  let r = M.useRef(!0);
  M.useEffect(r.current || !n ? () => {
    r.current = !1;
  } : e, t);
}
var wi = xVe;
function Yx() {
}
function Kh(e, t, n, r) {
  return SVe(e, r) || kVe(e, t, n, r);
}
function SVe(e, t) {
  return e.editor.getModel(JJ(e, t));
}
function kVe(e, t, n, r) {
  return e.editor.createModel(t, n, r ? JJ(e, r) : void 0);
}
function JJ(e, t) {
  return e.Uri.parse(t);
}
function _Ve({ original: e, modified: t, language: n, originalLanguage: r, modifiedLanguage: a, originalModelPath: s, modifiedModelPath: l, keepCurrentOriginalModel: c = !1, keepCurrentModifiedModel: d = !1, theme: f = "light", loading: m = "Loading...", options: h = {}, height: v = "100%", width: g = "100%", className: b, wrapperProps: x = {}, beforeMount: w = Yx, onMount: k = Yx }) {
  let [E, _] = M.useState(!1), [O, N] = M.useState(!0), A = M.useRef(null), R = M.useRef(null), D = M.useRef(null), I = M.useRef(k), z = M.useRef(w), B = M.useRef(!1);
  XJ(() => {
    let G = KJ.init();
    return G.then(($) => (R.current = $) && N(!1)).catch(($) => $?.type !== "cancelation" && console.error("Monaco initialization: error:", $)), () => A.current ? L() : G.cancel();
  }), wi(() => {
    if (A.current && R.current) {
      let G = A.current.getOriginalEditor(), $ = Kh(R.current, e || "", r || n || "text", s || "");
      $ !== G.getModel() && G.setModel($);
    }
  }, [s], E), wi(() => {
    if (A.current && R.current) {
      let G = A.current.getModifiedEditor(), $ = Kh(R.current, t || "", a || n || "text", l || "");
      $ !== G.getModel() && G.setModel($);
    }
  }, [l], E), wi(() => {
    let G = A.current.getModifiedEditor();
    G.getOption(R.current.editor.EditorOption.readOnly) ? G.setValue(t || "") : t !== G.getValue() && (G.executeEdits("", [{ range: G.getModel().getFullModelRange(), text: t || "", forceMoveMarkers: !0 }]), G.pushUndoStop());
  }, [t], E), wi(() => {
    A.current?.getModel()?.original.setValue(e || "");
  }, [e], E), wi(() => {
    let { original: G, modified: $ } = A.current.getModel();
    R.current.editor.setModelLanguage(G, r || n || "text"), R.current.editor.setModelLanguage($, a || n || "text");
  }, [n, r, a], E), wi(() => {
    R.current?.editor.setTheme(f);
  }, [f], E), wi(() => {
    A.current?.updateOptions(h);
  }, [h], E);
  let P = M.useCallback(() => {
    if (!R.current) return;
    z.current(R.current);
    let G = Kh(R.current, e || "", r || n || "text", s || ""), $ = Kh(R.current, t || "", a || n || "text", l || "");
    A.current?.setModel({ original: G, modified: $ });
  }, [n, t, a, e, r, s, l]), H = M.useCallback(() => {
    !B.current && D.current && (A.current = R.current.editor.createDiffEditor(D.current, { automaticLayout: !0, ...h }), P(), R.current?.editor.setTheme(f), _(!0), B.current = !0);
  }, [h, f, P]);
  M.useEffect(() => {
    E && I.current(A.current, R.current);
  }, [E]), M.useEffect(() => {
    !O && !E && H();
  }, [O, E, H]);
  function L() {
    let G = A.current?.getModel();
    c || G?.original?.dispose(), d || G?.modified?.dispose(), A.current?.dispose();
  }
  return jt.createElement(YJ, { width: g, height: v, isEditorReady: E, loading: m, _ref: D, className: b, wrapperProps: x });
}
var EVe = _Ve;
M.memo(EVe);
function CVe(e) {
  let t = M.useRef();
  return M.useEffect(() => {
    t.current = e;
  }, [e]), t.current;
}
var OVe = CVe, v_ = /* @__PURE__ */ new Map();
function MVe({ defaultValue: e, defaultLanguage: t, defaultPath: n, value: r, language: a, path: s, theme: l = "light", line: c, loading: d = "Loading...", options: f = {}, overrideServices: m = {}, saveViewState: h = !0, keepCurrentModel: v = !1, width: g = "100%", height: b = "100%", className: x, wrapperProps: w = {}, beforeMount: k = Yx, onMount: E = Yx, onChange: _, onValidate: O = Yx }) {
  let [N, A] = M.useState(!1), [R, D] = M.useState(!0), I = M.useRef(null), z = M.useRef(null), B = M.useRef(null), P = M.useRef(E), H = M.useRef(k), L = M.useRef(), G = M.useRef(r), $ = OVe(s), K = M.useRef(!1), q = M.useRef(!1);
  XJ(() => {
    let F = KJ.init();
    return F.then((Y) => (I.current = Y) && D(!1)).catch((Y) => Y?.type !== "cancelation" && console.error("Monaco initialization: error:", Y)), () => z.current ? V() : F.cancel();
  }), wi(() => {
    let F = Kh(I.current, e || r || "", t || a || "", s || n || "");
    F !== z.current?.getModel() && (h && v_.set($, z.current?.saveViewState()), z.current?.setModel(F), h && z.current?.restoreViewState(v_.get(s)));
  }, [s], N), wi(() => {
    z.current?.updateOptions(f);
  }, [f], N), wi(() => {
    !z.current || r === void 0 || (z.current.getOption(I.current.editor.EditorOption.readOnly) ? z.current.setValue(r) : r !== z.current.getValue() && (q.current = !0, z.current.executeEdits("", [{ range: z.current.getModel().getFullModelRange(), text: r, forceMoveMarkers: !0 }]), z.current.pushUndoStop(), q.current = !1));
  }, [r], N), wi(() => {
    let F = z.current?.getModel();
    F && a && I.current?.editor.setModelLanguage(F, a);
  }, [a], N), wi(() => {
    c !== void 0 && z.current?.revealLine(c);
  }, [c], N), wi(() => {
    I.current?.editor.setTheme(l);
  }, [l], N);
  let Z = M.useCallback(() => {
    if (!(!B.current || !I.current) && !K.current) {
      H.current(I.current);
      let F = s || n, Y = Kh(I.current, r || e || "", t || a || "", F || "");
      z.current = I.current?.editor.create(B.current, { model: Y, automaticLayout: !0, ...f }, m), h && z.current.restoreViewState(v_.get(F)), I.current.editor.setTheme(l), c !== void 0 && z.current.revealLine(c), A(!0), K.current = !0;
    }
  }, [e, t, n, r, a, s, f, m, h, l, c]);
  M.useEffect(() => {
    N && P.current(z.current, I.current);
  }, [N]), M.useEffect(() => {
    !R && !N && Z();
  }, [R, N, Z]), G.current = r, M.useEffect(() => {
    N && _ && (L.current?.dispose(), L.current = z.current?.onDidChangeModelContent((F) => {
      q.current || _(z.current.getValue(), F);
    }));
  }, [N, _]), M.useEffect(() => {
    if (N) {
      let F = I.current.editor.onDidChangeMarkers((Y) => {
        let U = z.current.getModel()?.uri;
        if (U && Y.find((W) => W.path === U.path)) {
          let W = I.current.editor.getModelMarkers({ resource: U });
          O?.(W);
        }
      });
      return () => {
        F?.dispose();
      };
    }
    return () => {
    };
  }, [N, O]);
  function V() {
    L.current?.dispose(), v ? h && v_.set(s, z.current.saveViewState()) : z.current.getModel()?.dispose(), z.current.dispose();
  }
  return jt.createElement(YJ, { width: g, height: b, isEditorReady: N, loading: d, _ref: B, className: x, wrapperProps: w });
}
var NVe = MVe, AVe = M.memo(NVe);
function cg() {
  return cg = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, cg.apply(null, arguments);
}
var y_ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof km < "u" ? km : typeof self < "u" ? self : {};
function zk(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var YF, XF = {
  exports: {}
};
var yA, JF, QF, RVe = (YF || (YF = 1, yA = XF, (function() {
  var e = {}.hasOwnProperty;
  function t() {
    for (var a = "", s = 0; s < arguments.length; s++) {
      var l = arguments[s];
      l && (a = r(a, n(l)));
    }
    return a;
  }
  function n(a) {
    if (typeof a == "string" || typeof a == "number") return a;
    if (typeof a != "object") return "";
    if (Array.isArray(a)) return t.apply(null, a);
    if (a.toString !== Object.prototype.toString && !a.toString.toString().includes("[native code]")) return a.toString();
    var s = "";
    for (var l in a) e.call(a, l) && a[l] && (s = r(s, l));
    return s;
  }
  function r(a, s) {
    return s ? a ? a + " " + s : a + s : a;
  }
  yA.exports ? (t.default = t, yA.exports = t) : window.classNames = t;
})()), XF.exports), bR = zk(RVe), ZF, e8, jVe = (QF || (QF = 1, JF = function e(t, n) {
  if (t === n) return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor) return !1;
    var r, a, s;
    if (Array.isArray(t)) {
      if ((r = t.length) != n.length) return !1;
      for (a = r; a-- !== 0; ) if (!e(t[a], n[a])) return !1;
      return !0;
    }
    if (t instanceof Map && n instanceof Map) {
      if (t.size !== n.size) return !1;
      for (a of t.entries()) if (!n.has(a[0])) return !1;
      for (a of t.entries()) if (!e(a[1], n.get(a[0]))) return !1;
      return !0;
    }
    if (t instanceof Set && n instanceof Set) {
      if (t.size !== n.size) return !1;
      for (a of t.entries()) if (!n.has(a[0])) return !1;
      return !0;
    }
    if (ArrayBuffer.isView(t) && ArrayBuffer.isView(n)) {
      if ((r = t.length) != n.length) return !1;
      for (a = r; a-- !== 0; ) if (t[a] !== n[a]) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
    if ((r = (s = Object.keys(t)).length) !== Object.keys(n).length) return !1;
    for (a = r; a-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, s[a])) return !1;
    for (a = r; a-- !== 0; ) {
      var l = s[a];
      if (!e(t[l], n[l])) return !1;
    }
    return !0;
  }
  return t != t && n != n;
}), JF), PVe = zk(jVe), t8, n8, Vs = zk((function() {
  if (e8) return ZF;
  e8 = 1;
  var e = /^\s+|\s+$/g, t = /^[-+]0x[0-9a-f]+$/i, n = /^0b[01]+$/i, r = /^0o[0-7]+$/i, a = parseInt, s = Object.prototype.toString;
  function l(d) {
    var f = typeof d;
    return !!d && (f == "object" || f == "function");
  }
  function c(d) {
    if (typeof d == "number") return d;
    if ((function(h) {
      return typeof h == "symbol" || /* @__PURE__ */ (function(v) {
        return !!v && typeof v == "object";
      })(h) && s.call(h) == "[object Symbol]";
    })(d)) return NaN;
    if (l(d)) {
      var f = typeof d.valueOf == "function" ? d.valueOf() : d;
      d = l(f) ? f + "" : f;
    }
    if (typeof d != "string") return d === 0 ? d : +d;
    d = d.replace(e, "");
    var m = n.test(d);
    return m || r.test(d) ? a(d.slice(2), m ? 2 : 8) : t.test(d) ? NaN : +d;
  }
  return ZF = function(d, f, m) {
    return m === void 0 && (m = f, f = void 0), m !== void 0 && (m = (m = c(m)) == m ? m : 0), f !== void 0 && (f = (f = c(f)) == f ? f : 0), (function(h, v, g) {
      return h == h && (g !== void 0 && (h = h <= g ? h : g), v !== void 0 && (h = h >= v ? h : v)), h;
    })(c(d), f, m);
  };
})()), DVe = zk((function() {
  if (n8) return t8;
  n8 = 1;
  var e = /^\s+|\s+$/g, t = /^[-+]0x[0-9a-f]+$/i, n = /^0b[01]+$/i, r = /^0o[0-7]+$/i, a = parseInt, s = typeof y_ == "object" && y_ && y_.Object === Object && y_, l = typeof self == "object" && self && self.Object === Object && self, c = s || l || Function("return this")(), d = Object.prototype.toString, f = Math.max, m = Math.min, h = function() {
    return c.Date.now();
  };
  function v(b) {
    var x = typeof b;
    return !!b && (x == "object" || x == "function");
  }
  function g(b) {
    if (typeof b == "number") return b;
    if ((function(k) {
      return typeof k == "symbol" || /* @__PURE__ */ (function(E) {
        return !!E && typeof E == "object";
      })(k) && d.call(k) == "[object Symbol]";
    })(b)) return NaN;
    if (v(b)) {
      var x = typeof b.valueOf == "function" ? b.valueOf() : b;
      b = v(x) ? x + "" : x;
    }
    if (typeof b != "string") return b === 0 ? b : +b;
    b = b.replace(e, "");
    var w = n.test(b);
    return w || r.test(b) ? a(b.slice(2), w ? 2 : 8) : t.test(b) ? NaN : +b;
  }
  return t8 = function(b, x, w) {
    var k, E, _, O, N, A, R = 0, D = !1, I = !1, z = !0;
    if (typeof b != "function") throw new TypeError("Expected a function");
    function B($) {
      var K = k, q = E;
      return k = E = void 0, R = $, O = b.apply(q, K);
    }
    function P($) {
      var K = $ - A;
      return A === void 0 || K >= x || K < 0 || I && $ - R >= _;
    }
    function H() {
      var $ = h();
      if (P($)) return L($);
      N = setTimeout(H, (function(K) {
        var q = x - (K - A);
        return I ? m(q, _ - (K - R)) : q;
      })($));
    }
    function L($) {
      return N = void 0, z && k ? B($) : (k = E = void 0, O);
    }
    function G() {
      var $ = h(), K = P($);
      if (k = arguments, E = this, A = $, K) {
        if (N === void 0) return (function(q) {
          return R = q, N = setTimeout(H, x), D ? B(q) : O;
        })(A);
        if (I) return N = setTimeout(H, x), B(A);
      }
      return N === void 0 && (N = setTimeout(H, x)), O;
    }
    return x = g(x) || 0, v(w) && (D = !!w.leading, _ = (I = "maxWait" in w) ? f(g(w.maxWait) || 0, x) : _, z = "trailing" in w ? !!w.trailing : z), G.cancel = function() {
      N !== void 0 && clearTimeout(N), R = 0, k = A = E = N = void 0;
    }, G.flush = function() {
      return N === void 0 ? O : L(h());
    }, G;
  };
})()), r8 = {
  width: void 0,
  height: void 0
};
function IVe(e) {
  const {
    ref: t,
    box: n = "content-box"
  } = e, [{
    width: r,
    height: a
  }, s] = M.useState(r8), l = (function() {
    const f = M.useRef(!1);
    return M.useEffect(() => (f.current = !0, () => {
      f.current = !1;
    }), []), M.useCallback(() => f.current, []);
  })(), c = M.useRef(cg({}, r8)), d = M.useRef(void 0);
  return d.current = e.onResize, M.useEffect(() => {
    if (!t.current || typeof window > "u" || !("ResizeObserver" in window)) return;
    const f = new ResizeObserver(([m]) => {
      const h = n === "border-box" ? "borderBoxSize" : n === "device-pixel-content-box" ? "devicePixelContentBoxSize" : "contentBoxSize", v = o8(m, h, "inlineSize"), g = o8(m, h, "blockSize");
      if (c.current.width !== v || c.current.height !== g) {
        const b = {
          width: v,
          height: g
        };
        c.current.width = v, c.current.height = g, d.current ? d.current(b) : l() && s(b);
      }
    });
    return f.observe(t.current, {
      box: n
    }), () => {
      f.disconnect();
    };
  }, [n, t, l]), {
    width: r,
    height: a
  };
}
function o8(e, t, n) {
  return e[t] ? Array.isArray(e[t]) ? e[t][0][n] : e[t][n] : t === "contentBoxSize" ? e.contentRect[n === "inlineSize" ? "width" : "height"] : void 0;
}
var $Ve = "allotment-module_splitView__L-yRc", zVe = "allotment-module_sashContainer__fzwJF", TVe = "allotment-module_splitViewContainer__rQnVa", QJ = "allotment-module_splitViewView__MGZ6O", LVe = "allotment-module_vertical__WSwwa", FVe = "allotment-module_horizontal__7doS8", BVe = "allotment-module_separatorBorder__x-rDS";
let px, ZJ = !1, eQ = !1;
typeof navigator == "object" && (px = navigator.userAgent, eQ = px.indexOf("Macintosh") >= 0, ZJ = (px.indexOf("Macintosh") >= 0 || px.indexOf("iPad") >= 0 || px.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
const tQ = ZJ, UVe = eQ, a8 = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? M.useLayoutEffect : M.useEffect;
class VVe {
  constructor() {
    this._size = void 0;
  }
  getSize() {
    return this._size;
  }
  setSize(t) {
    this._size = t;
  }
}
function b_(e, t) {
  const n = e.length, r = n - t.length;
  return r >= 0 && e.slice(r, n) === t;
}
var i8, s8 = {
  exports: {}
}, HVe = (i8 || (i8 = 1, (function(e) {
  var t = Object.prototype.hasOwnProperty, n = "~";
  function r() {
  }
  function a(d, f, m) {
    this.fn = d, this.context = f, this.once = m || !1;
  }
  function s(d, f, m, h, v) {
    if (typeof m != "function") throw new TypeError("The listener must be a function");
    var g = new a(m, h || d, v), b = n ? n + f : f;
    return d._events[b] ? d._events[b].fn ? d._events[b] = [d._events[b], g] : d._events[b].push(g) : (d._events[b] = g, d._eventsCount++), d;
  }
  function l(d, f) {
    --d._eventsCount === 0 ? d._events = new r() : delete d._events[f];
  }
  function c() {
    this._events = new r(), this._eventsCount = 0;
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (n = !1)), c.prototype.eventNames = function() {
    var d, f, m = [];
    if (this._eventsCount === 0) return m;
    for (f in d = this._events) t.call(d, f) && m.push(n ? f.slice(1) : f);
    return Object.getOwnPropertySymbols ? m.concat(Object.getOwnPropertySymbols(d)) : m;
  }, c.prototype.listeners = function(d) {
    var f = n ? n + d : d, m = this._events[f];
    if (!m) return [];
    if (m.fn) return [m.fn];
    for (var h = 0, v = m.length, g = new Array(v); h < v; h++) g[h] = m[h].fn;
    return g;
  }, c.prototype.listenerCount = function(d) {
    var f = n ? n + d : d, m = this._events[f];
    return m ? m.fn ? 1 : m.length : 0;
  }, c.prototype.emit = function(d, f, m, h, v, g) {
    var b = n ? n + d : d;
    if (!this._events[b]) return !1;
    var x, w, k = this._events[b], E = arguments.length;
    if (k.fn) {
      switch (k.once && this.removeListener(d, k.fn, void 0, !0), E) {
        case 1:
          return k.fn.call(k.context), !0;
        case 2:
          return k.fn.call(k.context, f), !0;
        case 3:
          return k.fn.call(k.context, f, m), !0;
        case 4:
          return k.fn.call(k.context, f, m, h), !0;
        case 5:
          return k.fn.call(k.context, f, m, h, v), !0;
        case 6:
          return k.fn.call(k.context, f, m, h, v, g), !0;
      }
      for (w = 1, x = new Array(E - 1); w < E; w++) x[w - 1] = arguments[w];
      k.fn.apply(k.context, x);
    } else {
      var _, O = k.length;
      for (w = 0; w < O; w++) switch (k[w].once && this.removeListener(d, k[w].fn, void 0, !0), E) {
        case 1:
          k[w].fn.call(k[w].context);
          break;
        case 2:
          k[w].fn.call(k[w].context, f);
          break;
        case 3:
          k[w].fn.call(k[w].context, f, m);
          break;
        case 4:
          k[w].fn.call(k[w].context, f, m, h);
          break;
        default:
          if (!x) for (_ = 1, x = new Array(E - 1); _ < E; _++) x[_ - 1] = arguments[_];
          k[w].fn.apply(k[w].context, x);
      }
    }
    return !0;
  }, c.prototype.on = function(d, f, m) {
    return s(this, d, f, m, !1);
  }, c.prototype.once = function(d, f, m) {
    return s(this, d, f, m, !0);
  }, c.prototype.removeListener = function(d, f, m, h) {
    var v = n ? n + d : d;
    if (!this._events[v]) return this;
    if (!f) return l(this, v), this;
    var g = this._events[v];
    if (g.fn) g.fn !== f || h && !g.once || m && g.context !== m || l(this, v);
    else {
      for (var b = 0, x = [], w = g.length; b < w; b++) (g[b].fn !== f || h && !g[b].once || m && g[b].context !== m) && x.push(g[b]);
      x.length ? this._events[v] = x.length === 1 ? x[0] : x : l(this, v);
    }
    return this;
  }, c.prototype.removeAllListeners = function(d) {
    var f;
    return d ? (f = n ? n + d : d, this._events[f] && l(this, f)) : (this._events = new r(), this._eventsCount = 0), this;
  }, c.prototype.off = c.prototype.removeListener, c.prototype.addListener = c.prototype.on, c.prefixed = n, c.EventEmitter = c, e.exports = c;
})(s8)), s8.exports), g1 = zk(HVe);
function l8(e, t) {
  const n = e.indexOf(t);
  n > -1 && (e.splice(n, 1), e.unshift(t));
}
function bA(e, t) {
  const n = e.indexOf(t);
  n > -1 && (e.splice(n, 1), e.push(t));
}
function Ii(e, t, n = 1) {
  const r = Math.max(0, Math.ceil((t - e) / n)), a = new Array(r);
  let s = -1;
  for (; ++s < r; ) a[s] = e + s * n;
  return a;
}
var WVe = "sash-module_sash__K-9lB", qVe = "sash-module_disabled__Hm-wx", GVe = "sash-module_mac__Jf6OJ", u8 = "sash-module_vertical__pB-rs", KVe = "sash-module_minimum__-UKxp", YVe = "sash-module_maximum__TCWxD", c8 = "sash-module_horizontal__kFbiw", wA = "sash-module_hover__80W6I", xA = "sash-module_active__bJspD";
let Ui = (function(e) {
  return e.Vertical = "VERTICAL", e.Horizontal = "HORIZONTAL", e;
})({}), xi = (function(e) {
  return e.Disabled = "DISABLED", e.Minimum = "MINIMUM", e.Maximum = "MAXIMUM", e.Enabled = "ENABLED", e;
})({}), nQ = tQ ? 20 : 8;
const rQ = new g1();
class d8 extends g1 {
  get state() {
    return this._state;
  }
  set state(t) {
    this._state !== t && (this.el.classList.toggle(qVe, t === xi.Disabled), this.el.classList.toggle("sash-disabled", t === xi.Disabled), this.el.classList.toggle(KVe, t === xi.Minimum), this.el.classList.toggle("sash-minimum", t === xi.Minimum), this.el.classList.toggle(YVe, t === xi.Maximum), this.el.classList.toggle("sash-maximum", t === xi.Maximum), this._state = t, this.emit("enablementChange", t));
  }
  constructor(t, n, r) {
    var a;
    super(), this.el = void 0, this.layoutProvider = void 0, this.orientation = void 0, this.size = void 0, this.hoverDelay = 300, this.hoverDelayer = DVe((s) => s.classList.add("sash-hover", wA), this.hoverDelay), this._state = xi.Enabled, this.onPointerStart = (s) => {
      const l = s.pageX, c = s.pageY, d = {
        startX: l,
        currentX: l,
        startY: c,
        currentY: c
      };
      this.el.classList.add("sash-active", xA), this.emit("start", d), this.el.setPointerCapture(s.pointerId);
      const f = (h) => {
        h.preventDefault();
        const v = {
          startX: l,
          currentX: h.pageX,
          startY: c,
          currentY: h.pageY
        };
        this.emit("change", v);
      }, m = (h) => {
        h.preventDefault(), this.el.classList.remove("sash-active", xA), this.hoverDelayer.cancel(), this.emit("end"), this.el.releasePointerCapture(h.pointerId), window.removeEventListener("pointermove", f), window.removeEventListener("pointerup", m);
      };
      window.addEventListener("pointermove", f), window.addEventListener("pointerup", m);
    }, this.onPointerDoublePress = () => {
      this.emit("reset");
    }, this.onMouseEnter = () => {
      this.el.classList.contains(xA) ? (this.hoverDelayer.cancel(), this.el.classList.add("sash-hover", wA)) : this.hoverDelayer(this.el);
    }, this.onMouseLeave = () => {
      this.hoverDelayer.cancel(), this.el.classList.remove("sash-hover", wA);
    }, this.el = document.createElement("div"), this.el.classList.add("sash", WVe), this.el.dataset.testid = "sash", t.append(this.el), UVe && this.el.classList.add("sash-mac", GVe), this.el.addEventListener("pointerdown", this.onPointerStart), this.el.addEventListener("dblclick", this.onPointerDoublePress), this.el.addEventListener("mouseenter", this.onMouseEnter), this.el.addEventListener("mouseleave", this.onMouseLeave), typeof r.size == "number" ? (this.size = r.size, r.orientation === Ui.Vertical ? this.el.style.width = `${this.size}px` : this.el.style.height = `${this.size}px`) : (this.size = nQ, rQ.on("onDidChangeGlobalSize", (s) => {
      this.size = s, this.layout();
    })), this.layoutProvider = n, this.orientation = (a = r.orientation) != null ? a : Ui.Vertical, this.orientation === Ui.Horizontal ? (this.el.classList.add("sash-horizontal", c8), this.el.classList.remove("sash-vertical", u8)) : (this.el.classList.remove("sash-horizontal", c8), this.el.classList.add("sash-vertical", u8)), this.layout();
  }
  layout() {
    if (this.orientation === Ui.Vertical) {
      const t = this.layoutProvider;
      this.el.style.left = t.getVerticalSashLeft(this) - this.size / 2 + "px", t.getVerticalSashTop && (this.el.style.top = t.getVerticalSashTop(this) + "px"), t.getVerticalSashHeight && (this.el.style.height = t.getVerticalSashHeight(this) + "px");
    } else {
      const t = this.layoutProvider;
      this.el.style.top = t.getHorizontalSashTop(this) - this.size / 2 + "px", t.getHorizontalSashLeft && (this.el.style.left = t.getHorizontalSashLeft(this) + "px"), t.getHorizontalSashWidth && (this.el.style.width = t.getHorizontalSashWidth(this) + "px");
    }
  }
  dispose() {
    this.el.removeEventListener("pointerdown", this.onPointerStart), this.el.removeEventListener("dblclick", this.onPointerDoublePress), this.el.removeEventListener("mouseenter", this.onMouseEnter), this.el.removeEventListener("mouseleave", () => this.onMouseLeave), this.el.remove();
  }
}
let nE;
var SA;
(SA = nE || (nE = {})).Distribute = {
  type: "distribute"
}, SA.Split = function(e) {
  return {
    type: "split",
    index: e
  };
}, SA.Invisible = function(e) {
  return {
    type: "invisible",
    cachedVisibleSize: e
  };
};
let $i = (function(e) {
  return e.Normal = "NORMAL", e.Low = "LOW", e.High = "HIGH", e;
})({});
class oQ {
  constructor(t, n, r) {
    this.container = void 0, this.view = void 0, this._size = void 0, this._cachedVisibleSize = void 0, this.container = t, this.view = n, this.container.classList.add("split-view-view", QJ), this.container.dataset.testid = "split-view-view", typeof r == "number" ? (this._size = r, this._cachedVisibleSize = void 0, t.classList.add("split-view-view-visible")) : (this._size = 0, this._cachedVisibleSize = r.cachedVisibleSize);
  }
  set size(t) {
    this._size = t;
  }
  get size() {
    return this._size;
  }
  get priority() {
    return this.view.priority;
  }
  get snap() {
    return !!this.view.snap;
  }
  get cachedVisibleSize() {
    return this._cachedVisibleSize;
  }
  get visible() {
    return this._cachedVisibleSize === void 0;
  }
  setVisible(t, n) {
    t !== this.visible && (t ? (this.size = Vs(this._cachedVisibleSize, this.viewMinimumSize, this.viewMaximumSize), this._cachedVisibleSize = void 0) : (this._cachedVisibleSize = typeof n == "number" ? n : this.size, this.size = 0), this.container.classList.toggle("split-view-view-visible", t), this.view.setVisible && this.view.setVisible(t));
  }
  get minimumSize() {
    return this.visible ? this.view.minimumSize : 0;
  }
  get viewMinimumSize() {
    return this.view.minimumSize;
  }
  get maximumSize() {
    return this.visible ? this.view.maximumSize : 0;
  }
  get viewMaximumSize() {
    return this.view.maximumSize;
  }
  set enabled(t) {
    this.container.style.pointerEvents = t ? "" : "none";
  }
  layout(t) {
    this.layoutContainer(t), this.view.layout(this.size, t);
  }
}
class XVe extends oQ {
  layoutContainer(t) {
    this.container.style.left = `${t}px`, this.container.style.width = `${this.size}px`;
  }
}
class JVe extends oQ {
  layoutContainer(t) {
    this.container.style.top = `${t}px`, this.container.style.height = `${this.size}px`;
  }
}
class QVe extends g1 {
  get startSnappingEnabled() {
    return this._startSnappingEnabled;
  }
  set startSnappingEnabled(t) {
    this._startSnappingEnabled !== t && (this._startSnappingEnabled = t, this.updateSashEnablement());
  }
  get endSnappingEnabled() {
    return this._endSnappingEnabled;
  }
  set endSnappingEnabled(t) {
    this._endSnappingEnabled !== t && (this._endSnappingEnabled = t, this.updateSashEnablement());
  }
  constructor(t, n = {}, r, a, s) {
    var l, c;
    if (super(), this.onDidChange = void 0, this.onDidDragStart = void 0, this.onDidDragEnd = void 0, this.orientation = void 0, this.sashContainer = void 0, this.size = 0, this.contentSize = 0, this.proportions = void 0, this.viewItems = [], this.sashItems = [], this.sashDragState = void 0, this.proportionalLayout = void 0, this.getSashOrthogonalSize = void 0, this._startSnappingEnabled = !0, this._endSnappingEnabled = !0, this.onSashEnd = (d) => {
      this.emit("sashchange", d), this.saveProportions();
      for (const f of this.viewItems) f.enabled = !0;
    }, this.orientation = (l = n.orientation) != null ? l : Ui.Vertical, this.proportionalLayout = (c = n.proportionalLayout) != null ? c : !0, this.getSashOrthogonalSize = n.getSashOrthogonalSize, r && (this.onDidChange = r), a && (this.onDidDragStart = a), s && (this.onDidDragEnd = s), this.sashContainer = document.createElement("div"), this.sashContainer.classList.add("sash-container", zVe), t.prepend(this.sashContainer), n.descriptor) {
      this.size = n.descriptor.size;
      for (const [d, f] of n.descriptor.views.entries()) {
        const m = f.size, h = f.container, v = f.view;
        this.addView(h, v, m, d, !0);
      }
      this.contentSize = this.viewItems.reduce((d, f) => d + f.size, 0), this.saveProportions();
    }
  }
  addView(t, n, r, a = this.viewItems.length, s) {
    let l;
    l = typeof r == "number" ? r : r.type === "split" ? this.getViewSize(r.index) / 2 : r.type === "invisible" ? {
      cachedVisibleSize: r.cachedVisibleSize
    } : n.minimumSize;
    const c = this.orientation === Ui.Vertical ? new JVe(t, n, l) : new XVe(t, n, l);
    if (this.viewItems.splice(a, 0, c), this.viewItems.length > 1) {
      const d = this.orientation === Ui.Vertical ? new d8(this.sashContainer, {
        getHorizontalSashTop: (h) => this.getSashPosition(h),
        getHorizontalSashWidth: this.getSashOrthogonalSize
      }, {
        orientation: Ui.Horizontal
      }) : new d8(this.sashContainer, {
        getVerticalSashLeft: (h) => this.getSashPosition(h),
        getVerticalSashHeight: this.getSashOrthogonalSize
      }, {
        orientation: Ui.Vertical
      }), f = this.orientation === Ui.Vertical ? (h) => ({
        sash: d,
        start: h.startY,
        current: h.currentY
      }) : (h) => ({
        sash: d,
        start: h.startX,
        current: h.currentX
      });
      d.on("start", (h) => {
        var v;
        this.emit("sashDragStart"), this.onSashStart(f(h));
        const g = this.viewItems.map((b) => b.size);
        (v = this.onDidDragStart) == null || v.call(this, g);
      }), d.on("change", (h) => this.onSashChange(f(h))), d.on("end", () => {
        var h;
        this.emit("sashDragEnd"), this.onSashEnd(this.sashItems.findIndex((g) => g.sash === d));
        const v = this.viewItems.map((g) => g.size);
        (h = this.onDidDragEnd) == null || h.call(this, v);
      }), d.on("reset", () => {
        const h = this.sashItems.findIndex((w) => w.sash === d), v = Ii(h, -1, -1), g = Ii(h + 1, this.viewItems.length), b = this.findFirstSnapIndex(v), x = this.findFirstSnapIndex(g);
        (typeof b != "number" || this.viewItems[b].visible) && (typeof x != "number" || this.viewItems[x].visible) && this.emit("sashreset", h);
      });
      const m = {
        sash: d
      };
      this.sashItems.splice(a - 1, 0, m);
    }
    s || this.relayout(), s || typeof r == "number" || r.type !== "distribute" || this.distributeViewSizes();
  }
  removeView(t, n) {
    if (t < 0 || t >= this.viewItems.length) throw new Error("Index out of bounds");
    const r = this.viewItems.splice(t, 1)[0].view;
    if (this.viewItems.length >= 1) {
      const a = Math.max(t - 1, 0);
      this.sashItems.splice(a, 1)[0].sash.dispose();
    }
    return this.relayout(), n && n.type === "distribute" && this.distributeViewSizes(), r;
  }
  moveView(t, n, r) {
    const a = this.getViewCachedVisibleSize(n), s = a === void 0 ? this.getViewSize(n) : nE.Invisible(a), l = this.removeView(n);
    this.addView(t, l, s, r);
  }
  getViewCachedVisibleSize(t) {
    if (t < 0 || t >= this.viewItems.length) throw new Error("Index out of bounds");
    return this.viewItems[t].cachedVisibleSize;
  }
  layout(t = this.size) {
    const n = Math.max(this.size, this.contentSize);
    if (this.size = t, this.proportions) for (let r = 0; r < this.viewItems.length; r++) {
      const a = this.viewItems[r];
      a.size = Vs(Math.round(this.proportions[r] * t), a.minimumSize, a.maximumSize);
    }
    else {
      const r = Ii(0, this.viewItems.length), a = r.filter((l) => this.viewItems[l].priority === $i.Low), s = r.filter((l) => this.viewItems[l].priority === $i.High);
      this.resize(this.viewItems.length - 1, t - n, void 0, a, s);
    }
    this.distributeEmptySpace(), this.layoutViews();
  }
  resizeView(t, n) {
    if (t < 0 || t >= this.viewItems.length) return;
    const r = Ii(0, this.viewItems.length).filter((c) => c !== t), a = [...r.filter((c) => this.viewItems[c].priority === $i.Low), t], s = r.filter((c) => this.viewItems[c].priority === $i.High), l = this.viewItems[t];
    n = Math.round(n), n = Vs(n, l.minimumSize, Math.min(l.maximumSize, this.size)), l.size = n, this.relayout(a, s);
  }
  resizeViews(t) {
    for (let n = 0; n < t.length; n++) {
      const r = this.viewItems[n];
      let a = t[n];
      a = Math.round(a), a = Vs(a, r.minimumSize, Math.min(r.maximumSize, this.size)), r.size = a;
    }
    this.contentSize = this.viewItems.reduce((n, r) => n + r.size, 0), this.saveProportions(), this.layout(this.size);
  }
  getViewSize(t) {
    return t < 0 || t >= this.viewItems.length ? -1 : this.viewItems[t].size;
  }
  isViewVisible(t) {
    if (t < 0 || t >= this.viewItems.length) throw new Error("Index out of bounds");
    return this.viewItems[t].visible;
  }
  setViewVisible(t, n) {
    if (t < 0 || t >= this.viewItems.length) throw new Error("Index out of bounds");
    this.viewItems[t].setVisible(n), this.distributeEmptySpace(t), this.layoutViews(), this.saveProportions();
  }
  distributeViewSizes() {
    const t = [];
    let n = 0;
    for (const c of this.viewItems) c.maximumSize - c.minimumSize > 0 && (t.push(c), n += c.size);
    const r = Math.floor(n / t.length);
    for (const c of t) c.size = Vs(r, c.minimumSize, c.maximumSize);
    const a = Ii(0, this.viewItems.length), s = a.filter((c) => this.viewItems[c].priority === $i.Low), l = a.filter((c) => this.viewItems[c].priority === $i.High);
    this.relayout(s, l);
  }
  dispose() {
    this.sashItems.forEach((t) => t.sash.dispose()), this.sashItems = [], this.sashContainer.remove();
  }
  relayout(t, n) {
    const r = this.viewItems.reduce((a, s) => a + s.size, 0);
    this.resize(this.viewItems.length - 1, this.size - r, void 0, t, n), this.distributeEmptySpace(), this.layoutViews(), this.saveProportions();
  }
  onSashStart({
    sash: t,
    start: n
  }) {
    const r = this.sashItems.findIndex((a) => a.sash === t);
    ((a) => {
      const s = this.viewItems.map((E) => E.size);
      let l, c, d = Number.NEGATIVE_INFINITY, f = Number.POSITIVE_INFINITY;
      const m = Ii(r, -1, -1), h = Ii(r + 1, this.viewItems.length), v = m.reduce((E, _) => E + (this.viewItems[_].minimumSize - s[_]), 0), g = m.reduce((E, _) => E + (this.viewItems[_].viewMaximumSize - s[_]), 0), b = h.length === 0 ? Number.POSITIVE_INFINITY : h.reduce((E, _) => E + (s[_] - this.viewItems[_].minimumSize), 0), x = h.length === 0 ? Number.NEGATIVE_INFINITY : h.reduce((E, _) => E + (s[_] - this.viewItems[_].viewMaximumSize), 0);
      d = Math.max(v, x), f = Math.min(b, g);
      const w = this.findFirstSnapIndex(m), k = this.findFirstSnapIndex(h);
      if (typeof w == "number") {
        const E = this.viewItems[w], _ = Math.floor(E.viewMinimumSize / 2);
        l = {
          index: w,
          limitDelta: E.visible ? d - _ : d + _,
          size: E.size
        };
      }
      if (typeof k == "number") {
        const E = this.viewItems[k], _ = Math.floor(E.viewMinimumSize / 2);
        c = {
          index: k,
          limitDelta: E.visible ? f + _ : f - _,
          size: E.size
        };
      }
      this.sashDragState = {
        start: a,
        current: a,
        index: r,
        sizes: s,
        minDelta: d,
        maxDelta: f,
        snapBefore: l,
        snapAfter: c
      };
    })(n);
  }
  onSashChange({
    current: t
  }) {
    const {
      index: n,
      start: r,
      sizes: a,
      minDelta: s,
      maxDelta: l,
      snapBefore: c,
      snapAfter: d
    } = this.sashDragState;
    this.sashDragState.current = t;
    const f = t - r;
    this.resize(n, f, a, void 0, void 0, s, l, c, d), this.distributeEmptySpace(), this.layoutViews();
  }
  getSashPosition(t) {
    let n = 0;
    for (let r = 0; r < this.sashItems.length; r++) if (n += this.viewItems[r].size, this.sashItems[r].sash === t) return n;
    return 0;
  }
  resize(t, n, r = this.viewItems.map((m) => m.size), a, s, l = Number.NEGATIVE_INFINITY, c = Number.POSITIVE_INFINITY, d, f) {
    if (t < 0 || t >= this.viewItems.length) return 0;
    const m = Ii(t, -1, -1), h = Ii(t + 1, this.viewItems.length);
    if (s) for (const R of s) l8(m, R), l8(h, R);
    if (a) for (const R of a) bA(m, R), bA(h, R);
    const v = m.map((R) => this.viewItems[R]), g = m.map((R) => r[R]), b = h.map((R) => this.viewItems[R]), x = h.map((R) => r[R]), w = m.reduce((R, D) => R + (this.viewItems[D].minimumSize - r[D]), 0), k = m.reduce((R, D) => R + (this.viewItems[D].maximumSize - r[D]), 0), E = h.length === 0 ? Number.POSITIVE_INFINITY : h.reduce((R, D) => R + (r[D] - this.viewItems[D].minimumSize), 0), _ = h.length === 0 ? Number.NEGATIVE_INFINITY : h.reduce((R, D) => R + (r[D] - this.viewItems[D].maximumSize), 0), O = Math.max(w, _, l), N = Math.min(E, k, c);
    let A = !1;
    if (d) {
      const R = this.viewItems[d.index], D = n >= d.limitDelta;
      A = D !== R.visible, R.setVisible(D, d.size);
    }
    if (!A && f) {
      const R = this.viewItems[f.index], D = n < f.limitDelta;
      A = D !== R.visible, R.setVisible(D, f.size);
    }
    if (A) return this.resize(t, n, r, a, s, l, c);
    for (let R = 0, D = n = Vs(n, O, N); R < v.length; R++) {
      const I = v[R], z = Vs(g[R] + D, I.minimumSize, I.maximumSize);
      D -= z - g[R], I.size = z;
    }
    for (let R = 0, D = n; R < b.length; R++) {
      const I = b[R], z = Vs(x[R] - D, I.minimumSize, I.maximumSize);
      D += z - x[R], I.size = z;
    }
    return n;
  }
  distributeEmptySpace(t) {
    const n = this.viewItems.reduce((f, m) => f + m.size, 0);
    let r = this.size - n;
    const a = Ii(0, this.viewItems.length), s = [], l = a.filter((f) => this.viewItems[f].priority === $i.Low), c = a.filter((f) => this.viewItems[f].priority === $i.Normal), d = a.filter((f) => this.viewItems[f].priority === $i.High);
    s.push(...d, ...c, ...l), typeof t == "number" && bA(s, t);
    for (let f = 0; r !== 0 && f < s.length; f++) {
      const m = this.viewItems[s[f]], h = Vs(m.size + r, m.minimumSize, m.maximumSize);
      r -= h - m.size, m.size = h;
    }
  }
  layoutViews() {
    var t;
    this.contentSize = this.viewItems.reduce((r, a) => r + a.size, 0);
    let n = 0;
    for (const r of this.viewItems) r.layout(n), n += r.size;
    (t = this.onDidChange) != null && t.call(this, this.viewItems.map((r) => r.size)), this.sashItems.forEach((r) => r.sash.layout()), this.updateSashEnablement();
  }
  saveProportions() {
    this.proportionalLayout && this.contentSize > 0 && (this.proportions = this.viewItems.map((t) => t.size / this.contentSize));
  }
  updateSashEnablement() {
    let t = !1;
    const n = this.viewItems.map((d) => t = d.size - d.minimumSize > 0 || t);
    t = !1;
    const r = this.viewItems.map((d) => t = d.maximumSize - d.size > 0 || t), a = [...this.viewItems].reverse();
    t = !1;
    const s = a.map((d) => t = d.size - d.minimumSize > 0 || t).reverse();
    t = !1;
    const l = a.map((d) => t = d.maximumSize - d.size > 0 || t).reverse();
    let c = 0;
    for (let d = 0; d < this.sashItems.length; d++) {
      const {
        sash: f
      } = this.sashItems[d];
      c += this.viewItems[d].size;
      const m = !(n[d] && l[d + 1]), h = !(r[d] && s[d + 1]);
      if (m && h) {
        const v = Ii(d, -1, -1), g = Ii(d + 1, this.viewItems.length), b = this.findFirstSnapIndex(v), x = this.findFirstSnapIndex(g), w = typeof b == "number" && !this.viewItems[b].visible, k = typeof x == "number" && !this.viewItems[x].visible;
        w && s[d] && (c > 0 || this.startSnappingEnabled) ? f.state = xi.Minimum : k && n[d] && (c < this.contentSize || this.endSnappingEnabled) ? f.state = xi.Maximum : f.state = xi.Disabled;
      } else f.state = m && !h ? xi.Minimum : !m && h ? xi.Maximum : xi.Enabled;
    }
  }
  findFirstSnapIndex(t) {
    for (const n of t) {
      const r = this.viewItems[n];
      if (r.visible && r.snap) return n;
    }
    for (const n of t) {
      const r = this.viewItems[n];
      if (r.visible && r.maximumSize - r.minimumSize > 0) return;
      if (!r.visible && r.snap) return n;
    }
  }
}
class Ph {
  constructor(t) {
    this.size = void 0, this.size = t;
  }
  getPreferredSize() {
    return this.size;
  }
}
class f8 {
  constructor(t, n) {
    this.proportion = void 0, this.layoutService = void 0, this.proportion = t, this.layoutService = n;
  }
  getPreferredSize() {
    return this.proportion * this.layoutService.getSize();
  }
}
class w_ {
  getPreferredSize() {
  }
}
class p8 {
  get preferredSize() {
    return this.layoutStrategy.getPreferredSize();
  }
  set preferredSize(t) {
    if (typeof t == "number") this.layoutStrategy = new Ph(t);
    else if (typeof t == "string") {
      const n = t.trim();
      if (b_(n, "%")) {
        const r = Number(n.slice(0, -1)) / 100;
        this.layoutStrategy = new f8(r, this.layoutService);
      } else if (b_(n, "px")) {
        const r = Number(n.slice(0, -2)) / 100;
        this.layoutStrategy = new Ph(r);
      } else if (typeof Number.parseFloat(n) == "number") {
        const r = Number.parseFloat(n);
        this.layoutStrategy = new Ph(r);
      } else this.layoutStrategy = new w_();
    } else this.layoutStrategy = new w_();
  }
  constructor(t, n) {
    var r;
    if (this.minimumSize = 0, this.maximumSize = Number.POSITIVE_INFINITY, this.element = void 0, this.priority = void 0, this.snap = void 0, this.layoutService = void 0, this.layoutStrategy = void 0, this.layoutService = t, this.element = n.element, this.minimumSize = typeof n.minimumSize == "number" ? n.minimumSize : 30, this.maximumSize = typeof n.maximumSize == "number" ? n.maximumSize : Number.POSITIVE_INFINITY, typeof n.preferredSize == "number") this.layoutStrategy = new Ph(n.preferredSize);
    else if (typeof n.preferredSize == "string") {
      const a = n.preferredSize.trim();
      if (b_(a, "%")) {
        const s = Number(a.slice(0, -1)) / 100;
        this.layoutStrategy = new f8(s, this.layoutService);
      } else if (b_(a, "px")) {
        const s = Number(a.slice(0, -2));
        this.layoutStrategy = new Ph(s);
      } else if (typeof Number.parseFloat(a) == "number") {
        const s = Number.parseFloat(a);
        this.layoutStrategy = new Ph(s);
      } else this.layoutStrategy = new w_();
    } else this.layoutStrategy = new w_();
    this.priority = (r = n.priority) != null ? r : $i.Normal, this.snap = typeof n.snap == "boolean" && n.snap;
  }
  layout(t) {
  }
}
function m8(e) {
  return e.minSize !== void 0 || e.maxSize !== void 0 || e.preferredSize !== void 0 || e.priority !== void 0 || e.visible !== void 0;
}
const v1 = M.forwardRef(({
  className: e,
  children: t
}, n) => jt.createElement("div", {
  ref: n,
  className: bR("split-view-view", QJ, e)
}, t));
v1.displayName = "Allotment.Pane";
const aQ = M.forwardRef(({
  children: e,
  className: t,
  id: n,
  maxSize: r = 1 / 0,
  minSize: a = 30,
  proportionalLayout: s = !0,
  separator: l = !0,
  sizes: c,
  defaultSizes: d = c,
  snap: f = !1,
  vertical: m = !1,
  onChange: h,
  onReset: v,
  onVisibleChange: g,
  onDragStart: b,
  onDragEnd: x
}, w) => {
  const k = M.useRef(null), E = M.useRef([]), _ = M.useRef(/* @__PURE__ */ new Map()), O = M.useRef(null), N = M.useRef(/* @__PURE__ */ new Map()), A = M.useRef(new VVe()), R = M.useRef([]), [D, I] = M.useState(!1), z = M.useMemo(() => jt.Children.toArray(e).filter(jt.isValidElement), [e]), B = M.useCallback((P) => {
    var H, L;
    const G = (H = R.current) == null ? void 0 : H[P];
    return typeof G?.preferredSize == "number" && ((L = O.current) != null && L.resizeView(P, Math.round(G.preferredSize)), !0);
  }, []);
  return M.useImperativeHandle(w, () => ({
    reset: () => {
      if (v) v();
      else {
        var P;
        (P = O.current) == null || P.distributeViewSizes();
        for (let H = 0; H < R.current.length; H++) B(H);
      }
    },
    resize: (P) => {
      var H;
      (H = O.current) == null || H.resizeViews(P);
    }
  })), a8(() => {
    let P = !0;
    d && N.current.size !== d.length && (P = !1, console.warn(`Expected ${d.length} children based on defaultSizes but found ${N.current.size}`)), P && d && (E.current = z.map((G) => G.key));
    const H = cg({
      orientation: m ? Ui.Vertical : Ui.Horizontal,
      proportionalLayout: s
    }, P && d && {
      descriptor: {
        size: d.reduce((G, $) => G + $, 0),
        views: d.map((G, $) => {
          var K, q, Z, V;
          const F = _.current.get(E.current[$]), Y = new p8(A.current, cg({
            element: document.createElement("div"),
            minimumSize: (K = F?.minSize) != null ? K : a,
            maximumSize: (q = F?.maxSize) != null ? q : r,
            priority: (Z = F?.priority) != null ? Z : $i.Normal
          }, F?.preferredSize && {
            preferredSize: F?.preferredSize
          }, {
            snap: (V = F?.snap) != null ? V : f
          }));
          return R.current.push(Y), {
            container: [...N.current.values()][$],
            size: G,
            view: Y
          };
        })
      }
    });
    O.current = new QVe(k.current, H, h, b, x), O.current.on("sashDragStart", () => {
      var G;
      (G = k.current) == null || G.classList.add("split-view-sash-dragging");
    }), O.current.on("sashDragEnd", () => {
      var G;
      (G = k.current) == null || G.classList.remove("split-view-sash-dragging");
    }), O.current.on("sashchange", (G) => {
      if (g && O.current) {
        const $ = z.map((K) => K.key);
        for (let K = 0; K < $.length; K++) {
          const q = _.current.get($[K]);
          q?.visible !== void 0 && q.visible !== O.current.isViewVisible(K) && g(K, O.current.isViewVisible(K));
        }
      }
    }), O.current.on("sashreset", (G) => {
      if (v) v();
      else {
        var $;
        if (B(G) || B(G + 1)) return;
        ($ = O.current) == null || $.distributeViewSizes();
      }
    });
    const L = O.current;
    return () => {
      L.dispose();
    };
  }, []), a8(() => {
    if (D) {
      const U = z.map((ie) => ie.key), W = [...E.current], J = U.filter((ie) => !E.current.includes(ie)), oe = U.filter((ie) => E.current.includes(ie)), fe = E.current.map((ie) => !U.includes(ie));
      for (let ie = fe.length - 1; ie >= 0; ie--) {
        var P;
        fe[ie] && ((P = O.current) != null && P.removeView(ie), W.splice(ie, 1), R.current.splice(ie, 1));
      }
      for (const ie of J) {
        var H, L, G, $, K;
        const ce = _.current.get(ie), ge = new p8(A.current, cg({
          element: document.createElement("div"),
          minimumSize: (H = ce?.minSize) != null ? H : a,
          maximumSize: (L = ce?.maxSize) != null ? L : r,
          priority: (G = ce?.priority) != null ? G : $i.Normal
        }, ce?.preferredSize && {
          preferredSize: ce?.preferredSize
        }, {
          snap: ($ = ce?.snap) != null ? $ : f
        }));
        (K = O.current) != null && K.addView(N.current.get(ie), ge, nE.Distribute, U.findIndex((re) => re === ie)), W.splice(U.findIndex((re) => re === ie), 0, ie), R.current.splice(U.findIndex((re) => re === ie), 0, ge);
      }
      for (; !PVe(U, W); ) for (const [ie, ce] of U.entries()) {
        const ge = W.findIndex((re) => re === ce);
        if (ge !== ie) {
          var q;
          (q = O.current) == null || q.moveView(N.current.get(ce), ge, ie);
          const re = W[ge];
          W.splice(ge, 1), W.splice(ie, 0, re);
          break;
        }
      }
      for (const ie of J) {
        var Z;
        const ce = U.findIndex((re) => re === ie), ge = R.current[ce].preferredSize;
        ge !== void 0 && ((Z = O.current) == null || Z.resizeView(ce, ge));
      }
      for (const ie of [...J, ...oe]) {
        var V, F;
        const ce = _.current.get(ie), ge = U.findIndex((re) => re === ie);
        ce && m8(ce) && ce.visible !== void 0 && ((V = O.current) == null ? void 0 : V.isViewVisible(ge)) !== ce.visible && ((F = O.current) == null || F.setViewVisible(ge, ce.visible));
      }
      for (const ie of oe) {
        const ce = _.current.get(ie), ge = U.findIndex((re) => re === ie);
        if (ce && m8(ce)) {
          var Y;
          ce.preferredSize !== void 0 && R.current[ge].preferredSize !== ce.preferredSize && (R.current[ge].preferredSize = ce.preferredSize);
          let re = !1;
          ce.minSize !== void 0 && R.current[ge].minimumSize !== ce.minSize && (R.current[ge].minimumSize = ce.minSize, re = !0), ce.maxSize !== void 0 && R.current[ge].maximumSize !== ce.maxSize && (R.current[ge].maximumSize = ce.maxSize, re = !0), re && ((Y = O.current) == null || Y.layout());
        }
      }
      (J.length > 0 || fe.length > 0) && (E.current = U);
    }
  }, [z, D, r, a, f]), M.useEffect(() => {
    O.current && (O.current.onDidChange = h);
  }, [h]), M.useEffect(() => {
    O.current && (O.current.onDidDragStart = b);
  }, [b]), M.useEffect(() => {
    O.current && (O.current.onDidDragEnd = x);
  }, [x]), IVe({
    ref: k,
    onResize: ({
      width: P,
      height: H
    }) => {
      var L;
      P && H && ((L = O.current) != null && L.layout(m ? H : P), A.current.setSize(m ? H : P), I(!0));
    }
  }), M.useEffect(() => {
    tQ && ZVe(20);
  }, []), jt.createElement("div", {
    ref: k,
    className: bR("split-view", m ? "split-view-vertical" : "split-view-horizontal", {
      "split-view-separator-border": l
    }, $Ve, m ? LVe : FVe, {
      [BVe]: l
    }, t),
    id: n
  }, jt.createElement("div", {
    className: bR("split-view-container", TVe)
  }, jt.Children.toArray(e).map((P) => {
    if (!jt.isValidElement(P)) return null;
    const H = P.key;
    return P.type.displayName === "Allotment.Pane" ? (_.current.set(H, P.props), jt.cloneElement(P, {
      key: H,
      ref: (L) => {
        const G = P.ref;
        G && (G.current = L), L ? N.current.set(H, L) : N.current.delete(H);
      }
    })) : jt.createElement(v1, {
      key: H,
      ref: (L) => {
        L ? N.current.set(H, L) : N.current.delete(H);
      }
    }, P);
  })));
});
function ZVe(e) {
  const t = Vs(e, 4, 20), n = Vs(e, 1, 8);
  document.documentElement.style.setProperty("--sash-size", t + "px"), document.documentElement.style.setProperty("--sash-hover-size", n + "px"), (function(r) {
    nQ = r, rQ.emit("onDidChangeGlobalSize", r);
  })(t);
}
aQ.displayName = "Allotment";
var eHe = Object.assign(aQ, {
  Pane: v1
});
var tHe = {
  prefix: "fas",
  iconName: "gears",
  icon: [640, 512, ["cogs"], "f085", "M415.9 210.5c12.2-3.3 25 2.5 30.5 13.8L465 261.9c10.3 1.4 20.4 4.2 29.9 8.1l35-23.3c10.5-7 24.4-5.6 33.3 3.3l19.2 19.2c8.9 8.9 10.3 22.9 3.3 33.3l-23.3 34.9c1.9 4.7 3.6 9.6 5 14.7 1.4 5.1 2.3 10.1 3 15.2l37.7 18.6c11.3 5.6 17.1 18.4 13.8 30.5l-7 26.2c-3.3 12.1-14.6 20.3-27.2 19.5l-42-2.7c-6.3 8.1-13.6 15.6-21.9 22l2.7 41.9c.8 12.6-7.4 24-19.5 27.2l-26.2 7c-12.2 3.3-24.9-2.5-30.5-13.8l-18.6-37.6c-10.3-1.4-20.4-4.2-29.9-8.1l-35 23.3c-10.5 7-24.4 5.6-33.3-3.3l-19.2-19.2c-8.9-8.9-10.3-22.8-3.3-33.3l23.3-35c-1.9-4.7-3.6-9.6-5-14.7s-2.3-10.2-3-15.2l-37.7-18.6c-11.3-5.6-17-18.4-13.8-30.5l7-26.2c3.3-12.1 14.6-20.3 27.2-19.5l41.9 2.7c6.3-8.1 13.6-15.6 21.9-22l-2.7-41.8c-.8-12.6 7.4-24 19.5-27.2l26.2-7zM448.4 340a44 44 0 1 0 .1 88 44 44 0 1 0 -.1-88zM224.9-45.5l26.2 7c12.1 3.3 20.3 14.7 19.5 27.2l-2.7 41.8c8.3 6.4 15.6 13.8 21.9 22l42-2.7c12.5-.8 23.9 7.4 27.2 19.5l7 26.2c3.2 12.1-2.5 24.9-13.8 30.5l-37.7 18.6c-.7 5.1-1.7 10.2-3 15.2s-3.1 10-5 14.7l23.3 35c7 10.5 5.6 24.4-3.3 33.3L307.3 262c-8.9 8.9-22.8 10.3-33.3 3.3L239 242c-9.5 3.9-19.6 6.7-29.9 8.1l-18.6 37.6c-5.6 11.3-18.4 17-30.5 13.8l-26.2-7c-12.2-3.3-20.3-14.7-19.5-27.2l2.7-41.9c-8.3-6.4-15.6-13.8-21.9-22l-42 2.7c-12.5 .8-23.9-7.4-27.2-19.5l-7-26.2c-3.2-12.1 2.5-24.9 13.8-30.5l37.7-18.6c.7-5.1 1.7-10.1 3-15.2 1.4-5.1 3-10 5-14.7L55.1 46.5c-7-10.5-5.6-24.4 3.3-33.3L77.6-6c8.9-8.9 22.8-10.3 33.3-3.3l35 23.3c9.5-3.9 19.6-6.7 29.9-8.1l18.6-37.6c5.6-11.3 18.3-17 30.5-13.8zM192.4 84a44 44 0 1 0 0 88 44 44 0 1 0 0-88z"]
}, nHe = {
  prefix: "fas",
  iconName: "circle-pause",
  icon: [512, 512, [62092, "pause-circle"], "f28b", "M256 512a256 256 0 1 0 0-512 256 256 0 1 0 0 512zM224 192l0 128c0 17.7-14.3 32-32 32s-32-14.3-32-32l0-128c0-17.7 14.3-32 32-32s32 14.3 32 32zm128 0l0 128c0 17.7-14.3 32-32 32s-32-14.3-32-32l0-128c0-17.7 14.3-32 32-32s32 14.3 32 32z"]
}, rHe = {
  prefix: "fas",
  iconName: "circle-play",
  icon: [512, 512, [61469, "play-circle"], "f144", "M0 256a256 256 0 1 1 512 0 256 256 0 1 1 -512 0zM188.3 147.1c-7.6 4.2-12.3 12.3-12.3 20.9l0 176c0 8.7 4.7 16.7 12.3 20.9s16.8 4.1 24.3-.5l144-88c7.1-4.4 11.5-12.1 11.5-20.5s-4.4-16.1-11.5-20.5l-144-88c-7.4-4.5-16.7-4.7-24.3-.5z"]
};
function wR(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function oHe(e) {
  if (Array.isArray(e)) return e;
}
function aHe(e) {
  if (Array.isArray(e)) return wR(e);
}
function iHe(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function sHe(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, iQ(r.key), r);
  }
}
function lHe(e, t, n) {
  return t && sHe(e.prototype, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function J_(e, t) {
  var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (!n) {
    if (Array.isArray(e) || (n = y1(e)) || t) {
      n && (e = n);
      var r = 0, a = function() {
      };
      return {
        s: a,
        n: function() {
          return r >= e.length ? {
            done: !0
          } : {
            done: !1,
            value: e[r++]
          };
        },
        e: function(d) {
          throw d;
        },
        f: a
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var s, l = !0, c = !1;
  return {
    s: function() {
      n = n.call(e);
    },
    n: function() {
      var d = n.next();
      return l = d.done, d;
    },
    e: function(d) {
      c = !0, s = d;
    },
    f: function() {
      try {
        l || n.return == null || n.return();
      } finally {
        if (c) throw s;
      }
    }
  };
}
function Bt(e, t, n) {
  return (t = iQ(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function uHe(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function cHe(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, a, s, l, c = [], d = !0, f = !1;
    try {
      if (s = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n) return;
        d = !1;
      } else for (; !(d = (r = s.call(n)).done) && (c.push(r.value), c.length !== t); d = !0) ;
    } catch (m) {
      f = !0, a = m;
    } finally {
      try {
        if (!d && n.return != null && (l = n.return(), Object(l) !== l)) return;
      } finally {
        if (f) throw a;
      }
    }
    return c;
  }
}
function dHe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function fHe() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function h8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ie(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? h8(Object(n), !0).forEach(function(r) {
      Bt(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : h8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function QC(e, t) {
  return oHe(e) || cHe(e, t) || y1(e, t) || dHe();
}
function ol(e) {
  return aHe(e) || uHe(e) || y1(e) || fHe();
}
function pHe(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function iQ(e) {
  var t = pHe(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function rE(e) {
  "@babel/helpers - typeof";
  return rE = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, rE(e);
}
function y1(e, t) {
  if (e) {
    if (typeof e == "string") return wR(e, t);
    var n = {}.toString.call(e).slice(8, -1);
    return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? wR(e, t) : void 0;
  }
}
var g8 = function() {
}, b1 = {}, sQ = {}, lQ = null, uQ = {
  mark: g8,
  measure: g8
};
try {
  typeof window < "u" && (b1 = window), typeof document < "u" && (sQ = document), typeof MutationObserver < "u" && (lQ = MutationObserver), typeof performance < "u" && (uQ = performance);
} catch {
}
var mHe = b1.navigator || {}, v8 = mHe.userAgent, y8 = v8 === void 0 ? "" : v8, Td = b1, dr = sQ, b8 = lQ, x_ = uQ;
Td.document;
var rd = !!dr.documentElement && !!dr.head && typeof dr.addEventListener == "function" && typeof dr.createElement == "function", cQ = ~y8.indexOf("MSIE") || ~y8.indexOf("Trident/"), kA, hHe = /fa(k|kd|s|r|l|t|d|dr|dl|dt|b|slr|slpr|wsb|tl|ns|nds|es|jr|jfr|jdr|usb|ufsb|udsb|cr|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/, gHe = /Font ?Awesome ?([567 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit|Notdog Duo|Notdog|Chisel|Etch|Thumbprint|Jelly Fill|Jelly Duo|Jelly|Utility|Utility Fill|Utility Duo|Slab Press|Slab|Whiteboard)?.*/i, dQ = {
  classic: {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fab: "brands",
    "fa-brands": "brands"
  },
  duotone: {
    fa: "solid",
    fad: "solid",
    "fa-solid": "solid",
    "fa-duotone": "solid",
    fadr: "regular",
    "fa-regular": "regular",
    fadl: "light",
    "fa-light": "light",
    fadt: "thin",
    "fa-thin": "thin"
  },
  sharp: {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular",
    fasl: "light",
    "fa-light": "light",
    fast: "thin",
    "fa-thin": "thin"
  },
  "sharp-duotone": {
    fa: "solid",
    fasds: "solid",
    "fa-solid": "solid",
    fasdr: "regular",
    "fa-regular": "regular",
    fasdl: "light",
    "fa-light": "light",
    fasdt: "thin",
    "fa-thin": "thin"
  },
  slab: {
    "fa-regular": "regular",
    faslr: "regular"
  },
  "slab-press": {
    "fa-regular": "regular",
    faslpr: "regular"
  },
  thumbprint: {
    "fa-light": "light",
    fatl: "light"
  },
  whiteboard: {
    "fa-semibold": "semibold",
    fawsb: "semibold"
  },
  notdog: {
    "fa-solid": "solid",
    fans: "solid"
  },
  "notdog-duo": {
    "fa-solid": "solid",
    fands: "solid"
  },
  etch: {
    "fa-solid": "solid",
    faes: "solid"
  },
  jelly: {
    "fa-regular": "regular",
    fajr: "regular"
  },
  "jelly-fill": {
    "fa-regular": "regular",
    fajfr: "regular"
  },
  "jelly-duo": {
    "fa-regular": "regular",
    fajdr: "regular"
  },
  chisel: {
    "fa-regular": "regular",
    facr: "regular"
  },
  utility: {
    "fa-semibold": "semibold",
    fausb: "semibold"
  },
  "utility-duo": {
    "fa-semibold": "semibold",
    faudsb: "semibold"
  },
  "utility-fill": {
    "fa-semibold": "semibold",
    faufsb: "semibold"
  }
}, vHe = {
  GROUP: "duotone-group",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, fQ = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press", "fa-utility", "fa-utility-duo", "fa-utility-fill"], Fo = "classic", Tk = "duotone", pQ = "sharp", mQ = "sharp-duotone", hQ = "chisel", gQ = "etch", vQ = "jelly", yQ = "jelly-duo", bQ = "jelly-fill", wQ = "notdog", xQ = "notdog-duo", SQ = "slab", kQ = "slab-press", _Q = "thumbprint", EQ = "utility", CQ = "utility-duo", OQ = "utility-fill", MQ = "whiteboard", yHe = "Classic", bHe = "Duotone", wHe = "Sharp", xHe = "Sharp Duotone", SHe = "Chisel", kHe = "Etch", _He = "Jelly", EHe = "Jelly Duo", CHe = "Jelly Fill", OHe = "Notdog", MHe = "Notdog Duo", NHe = "Slab", AHe = "Slab Press", RHe = "Thumbprint", jHe = "Utility", PHe = "Utility Duo", DHe = "Utility Fill", IHe = "Whiteboard", NQ = [Fo, Tk, pQ, mQ, hQ, gQ, vQ, yQ, bQ, wQ, xQ, SQ, kQ, _Q, EQ, CQ, OQ, MQ];
kA = {}, Bt(Bt(Bt(Bt(Bt(Bt(Bt(Bt(Bt(Bt(kA, Fo, yHe), Tk, bHe), pQ, wHe), mQ, xHe), hQ, SHe), gQ, kHe), vQ, _He), yQ, EHe), bQ, CHe), wQ, OHe), Bt(Bt(Bt(Bt(Bt(Bt(Bt(Bt(kA, xQ, MHe), SQ, NHe), kQ, AHe), _Q, RHe), EQ, jHe), CQ, PHe), OQ, DHe), MQ, IHe);
var $He = {
  classic: {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  duotone: {
    900: "fad",
    400: "fadr",
    300: "fadl",
    100: "fadt"
  },
  sharp: {
    900: "fass",
    400: "fasr",
    300: "fasl",
    100: "fast"
  },
  "sharp-duotone": {
    900: "fasds",
    400: "fasdr",
    300: "fasdl",
    100: "fasdt"
  },
  slab: {
    400: "faslr"
  },
  "slab-press": {
    400: "faslpr"
  },
  whiteboard: {
    600: "fawsb"
  },
  thumbprint: {
    300: "fatl"
  },
  notdog: {
    900: "fans"
  },
  "notdog-duo": {
    900: "fands"
  },
  etch: {
    900: "faes"
  },
  chisel: {
    400: "facr"
  },
  jelly: {
    400: "fajr"
  },
  "jelly-fill": {
    400: "fajfr"
  },
  "jelly-duo": {
    400: "fajdr"
  },
  utility: {
    600: "fausb"
  },
  "utility-duo": {
    600: "faudsb"
  },
  "utility-fill": {
    600: "faufsb"
  }
}, zHe = {
  "Font Awesome 7 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 7 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  "Font Awesome 7 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 7 Duotone": {
    900: "fad",
    400: "fadr",
    normal: "fadr",
    300: "fadl",
    100: "fadt"
  },
  "Font Awesome 7 Sharp": {
    900: "fass",
    400: "fasr",
    normal: "fasr",
    300: "fasl",
    100: "fast"
  },
  "Font Awesome 7 Sharp Duotone": {
    900: "fasds",
    400: "fasdr",
    normal: "fasdr",
    300: "fasdl",
    100: "fasdt"
  },
  "Font Awesome 7 Jelly": {
    400: "fajr",
    normal: "fajr"
  },
  "Font Awesome 7 Jelly Fill": {
    400: "fajfr",
    normal: "fajfr"
  },
  "Font Awesome 7 Jelly Duo": {
    400: "fajdr",
    normal: "fajdr"
  },
  "Font Awesome 7 Slab": {
    400: "faslr",
    normal: "faslr"
  },
  "Font Awesome 7 Slab Press": {
    400: "faslpr",
    normal: "faslpr"
  },
  "Font Awesome 7 Thumbprint": {
    300: "fatl",
    normal: "fatl"
  },
  "Font Awesome 7 Notdog": {
    900: "fans",
    normal: "fans"
  },
  "Font Awesome 7 Notdog Duo": {
    900: "fands",
    normal: "fands"
  },
  "Font Awesome 7 Etch": {
    900: "faes",
    normal: "faes"
  },
  "Font Awesome 7 Chisel": {
    400: "facr",
    normal: "facr"
  },
  "Font Awesome 7 Whiteboard": {
    600: "fawsb",
    normal: "fawsb"
  },
  "Font Awesome 7 Utility": {
    600: "fausb",
    normal: "fausb"
  },
  "Font Awesome 7 Utility Duo": {
    600: "faudsb",
    normal: "faudsb"
  },
  "Font Awesome 7 Utility Fill": {
    600: "faufsb",
    normal: "faufsb"
  }
}, THe = /* @__PURE__ */ new Map([["classic", {
  defaultShortPrefixId: "fas",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin", "brands"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["duotone", {
  defaultShortPrefixId: "fad",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp", {
  defaultShortPrefixId: "fass",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp-duotone", {
  defaultShortPrefixId: "fasds",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["chisel", {
  defaultShortPrefixId: "facr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["etch", {
  defaultShortPrefixId: "faes",
  defaultStyleId: "solid",
  styleIds: ["solid"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["jelly", {
  defaultShortPrefixId: "fajr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["jelly-duo", {
  defaultShortPrefixId: "fajdr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["jelly-fill", {
  defaultShortPrefixId: "fajfr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["notdog", {
  defaultShortPrefixId: "fans",
  defaultStyleId: "solid",
  styleIds: ["solid"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["notdog-duo", {
  defaultShortPrefixId: "fands",
  defaultStyleId: "solid",
  styleIds: ["solid"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["slab", {
  defaultShortPrefixId: "faslr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["slab-press", {
  defaultShortPrefixId: "faslpr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["thumbprint", {
  defaultShortPrefixId: "fatl",
  defaultStyleId: "light",
  styleIds: ["light"],
  futureStyleIds: [],
  defaultFontWeight: 300
}], ["utility", {
  defaultShortPrefixId: "fausb",
  defaultStyleId: "semibold",
  styleIds: ["semibold"],
  futureStyleIds: [],
  defaultFontWeight: 600
}], ["utility-duo", {
  defaultShortPrefixId: "faudsb",
  defaultStyleId: "semibold",
  styleIds: ["semibold"],
  futureStyleIds: [],
  defaultFontWeight: 600
}], ["utility-fill", {
  defaultShortPrefixId: "faufsb",
  defaultStyleId: "semibold",
  styleIds: ["semibold"],
  futureStyleIds: [],
  defaultFontWeight: 600
}], ["whiteboard", {
  defaultShortPrefixId: "fawsb",
  defaultStyleId: "semibold",
  styleIds: ["semibold"],
  futureStyleIds: [],
  defaultFontWeight: 600
}]]), LHe = {
  chisel: {
    regular: "facr"
  },
  classic: {
    brands: "fab",
    light: "fal",
    regular: "far",
    solid: "fas",
    thin: "fat"
  },
  duotone: {
    light: "fadl",
    regular: "fadr",
    solid: "fad",
    thin: "fadt"
  },
  etch: {
    solid: "faes"
  },
  jelly: {
    regular: "fajr"
  },
  "jelly-duo": {
    regular: "fajdr"
  },
  "jelly-fill": {
    regular: "fajfr"
  },
  notdog: {
    solid: "fans"
  },
  "notdog-duo": {
    solid: "fands"
  },
  sharp: {
    light: "fasl",
    regular: "fasr",
    solid: "fass",
    thin: "fast"
  },
  "sharp-duotone": {
    light: "fasdl",
    regular: "fasdr",
    solid: "fasds",
    thin: "fasdt"
  },
  slab: {
    regular: "faslr"
  },
  "slab-press": {
    regular: "faslpr"
  },
  thumbprint: {
    light: "fatl"
  },
  utility: {
    semibold: "fausb"
  },
  "utility-duo": {
    semibold: "faudsb"
  },
  "utility-fill": {
    semibold: "faufsb"
  },
  whiteboard: {
    semibold: "fawsb"
  }
}, AQ = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], w8 = {
  kit: {
    fak: "kit",
    "fa-kit": "kit"
  },
  "kit-duotone": {
    fakd: "kit-duotone",
    "fa-kit-duotone": "kit-duotone"
  }
}, FHe = ["kit"], BHe = "kit", UHe = "kit-duotone", VHe = "Kit", HHe = "Kit Duotone";
Bt(Bt({}, BHe, VHe), UHe, HHe);
var WHe = {
  kit: {
    "fa-kit": "fak"
  }
}, qHe = {
  "Font Awesome Kit": {
    400: "fak",
    normal: "fak"
  },
  "Font Awesome Kit Duotone": {
    400: "fakd",
    normal: "fakd"
  }
}, GHe = {
  kit: {
    fak: "fa-kit"
  }
}, x8 = {
  kit: {
    kit: "fak"
  },
  "kit-duotone": {
    "kit-duotone": "fakd"
  }
}, _A, S_ = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, KHe = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press", "fa-utility", "fa-utility-duo", "fa-utility-fill"], YHe = "classic", XHe = "duotone", JHe = "sharp", QHe = "sharp-duotone", ZHe = "chisel", eWe = "etch", tWe = "jelly", nWe = "jelly-duo", rWe = "jelly-fill", oWe = "notdog", aWe = "notdog-duo", iWe = "slab", sWe = "slab-press", lWe = "thumbprint", uWe = "utility", cWe = "utility-duo", dWe = "utility-fill", fWe = "whiteboard", pWe = "Classic", mWe = "Duotone", hWe = "Sharp", gWe = "Sharp Duotone", vWe = "Chisel", yWe = "Etch", bWe = "Jelly", wWe = "Jelly Duo", xWe = "Jelly Fill", SWe = "Notdog", kWe = "Notdog Duo", _We = "Slab", EWe = "Slab Press", CWe = "Thumbprint", OWe = "Utility", MWe = "Utility Duo", NWe = "Utility Fill", AWe = "Whiteboard";
_A = {}, Bt(Bt(Bt(Bt(Bt(Bt(Bt(Bt(Bt(Bt(_A, YHe, pWe), XHe, mWe), JHe, hWe), QHe, gWe), ZHe, vWe), eWe, yWe), tWe, bWe), nWe, wWe), rWe, xWe), oWe, SWe), Bt(Bt(Bt(Bt(Bt(Bt(Bt(Bt(_A, aWe, kWe), iWe, _We), sWe, EWe), lWe, CWe), uWe, OWe), cWe, MWe), dWe, NWe), fWe, AWe);
var RWe = "kit", jWe = "kit-duotone", PWe = "Kit", DWe = "Kit Duotone";
Bt(Bt({}, RWe, PWe), jWe, DWe);
var IWe = {
  classic: {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
  },
  duotone: {
    "fa-regular": "fadr",
    "fa-light": "fadl",
    "fa-thin": "fadt"
  },
  sharp: {
    "fa-solid": "fass",
    "fa-regular": "fasr",
    "fa-light": "fasl",
    "fa-thin": "fast"
  },
  "sharp-duotone": {
    "fa-solid": "fasds",
    "fa-regular": "fasdr",
    "fa-light": "fasdl",
    "fa-thin": "fasdt"
  },
  slab: {
    "fa-regular": "faslr"
  },
  "slab-press": {
    "fa-regular": "faslpr"
  },
  whiteboard: {
    "fa-semibold": "fawsb"
  },
  thumbprint: {
    "fa-light": "fatl"
  },
  notdog: {
    "fa-solid": "fans"
  },
  "notdog-duo": {
    "fa-solid": "fands"
  },
  etch: {
    "fa-solid": "faes"
  },
  jelly: {
    "fa-regular": "fajr"
  },
  "jelly-fill": {
    "fa-regular": "fajfr"
  },
  "jelly-duo": {
    "fa-regular": "fajdr"
  },
  chisel: {
    "fa-regular": "facr"
  },
  utility: {
    "fa-semibold": "fausb"
  },
  "utility-duo": {
    "fa-semibold": "faudsb"
  },
  "utility-fill": {
    "fa-semibold": "faufsb"
  }
}, $We = {
  classic: ["fas", "far", "fal", "fat", "fad"],
  duotone: ["fadr", "fadl", "fadt"],
  sharp: ["fass", "fasr", "fasl", "fast"],
  "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"],
  slab: ["faslr"],
  "slab-press": ["faslpr"],
  whiteboard: ["fawsb"],
  thumbprint: ["fatl"],
  notdog: ["fans"],
  "notdog-duo": ["fands"],
  etch: ["faes"],
  jelly: ["fajr"],
  "jelly-fill": ["fajfr"],
  "jelly-duo": ["fajdr"],
  chisel: ["facr"],
  utility: ["fausb"],
  "utility-duo": ["faudsb"],
  "utility-fill": ["faufsb"]
}, xR = {
  classic: {
    fab: "fa-brands",
    fad: "fa-duotone",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
  },
  duotone: {
    fadr: "fa-regular",
    fadl: "fa-light",
    fadt: "fa-thin"
  },
  sharp: {
    fass: "fa-solid",
    fasr: "fa-regular",
    fasl: "fa-light",
    fast: "fa-thin"
  },
  "sharp-duotone": {
    fasds: "fa-solid",
    fasdr: "fa-regular",
    fasdl: "fa-light",
    fasdt: "fa-thin"
  },
  slab: {
    faslr: "fa-regular"
  },
  "slab-press": {
    faslpr: "fa-regular"
  },
  whiteboard: {
    fawsb: "fa-semibold"
  },
  thumbprint: {
    fatl: "fa-light"
  },
  notdog: {
    fans: "fa-solid"
  },
  "notdog-duo": {
    fands: "fa-solid"
  },
  etch: {
    faes: "fa-solid"
  },
  jelly: {
    fajr: "fa-regular"
  },
  "jelly-fill": {
    fajfr: "fa-regular"
  },
  "jelly-duo": {
    fajdr: "fa-regular"
  },
  chisel: {
    facr: "fa-regular"
  },
  utility: {
    fausb: "fa-semibold"
  },
  "utility-duo": {
    faudsb: "fa-semibold"
  },
  "utility-fill": {
    faufsb: "fa-semibold"
  }
}, zWe = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands", "fa-semibold"], RQ = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", "faslr", "faslpr", "fawsb", "fatl", "fans", "fands", "faes", "fajr", "fajfr", "fajdr", "facr", "fausb", "faudsb", "faufsb"].concat(KHe, zWe), TWe = ["solid", "regular", "light", "thin", "duotone", "brands", "semibold"], jQ = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], LWe = jQ.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), FWe = ["aw", "fw", "pull-left", "pull-right"], BWe = [].concat(ol(Object.keys($We)), TWe, FWe, ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "inverse", "layers", "layers-bottom-left", "layers-bottom-right", "layers-counter", "layers-text", "layers-top-left", "layers-top-right", "li", "pull-end", "pull-start", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", "width-auto", "width-fixed", S_.GROUP, S_.SWAP_OPACITY, S_.PRIMARY, S_.SECONDARY]).concat(jQ.map(function(e) {
  return "".concat(e, "x");
})).concat(LWe.map(function(e) {
  return "w-".concat(e);
})), UWe = {
  "Font Awesome 5 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 5 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal"
  },
  "Font Awesome 5 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 5 Duotone": {
    900: "fad"
  }
}, Wc = "___FONT_AWESOME___", SR = 16, PQ = "fa", DQ = "svg-inline--fa", Km = "data-fa-i2svg", kR = "data-fa-pseudo-element", VWe = "data-fa-pseudo-element-pending", w1 = "data-prefix", x1 = "data-icon", S8 = "fontawesome-i2svg", HWe = "async", WWe = ["HTML", "HEAD", "STYLE", "SCRIPT"], IQ = ["::before", "::after", ":before", ":after"], $Q = (function() {
  try {
    return !0;
  } catch {
    return !1;
  }
})();
function Lk(e) {
  return new Proxy(e, {
    get: function(n, r) {
      return r in n ? n[r] : n[Fo];
    }
  });
}
var zQ = Ie({}, dQ);
zQ[Fo] = Ie(Ie(Ie(Ie({}, {
  "fa-duotone": "duotone"
}), dQ[Fo]), w8.kit), w8["kit-duotone"]);
var qWe = Lk(zQ), _R = Ie({}, LHe);
_R[Fo] = Ie(Ie(Ie(Ie({}, {
  duotone: "fad"
}), _R[Fo]), x8.kit), x8["kit-duotone"]);
var k8 = Lk(_R), ER = Ie({}, xR);
ER[Fo] = Ie(Ie({}, ER[Fo]), GHe.kit);
var S1 = Lk(ER), CR = Ie({}, IWe);
CR[Fo] = Ie(Ie({}, CR[Fo]), WHe.kit);
Lk(CR);
var GWe = hHe, TQ = "fa-layers-text", KWe = gHe, YWe = Ie({}, $He);
Lk(YWe);
var XWe = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], EA = vHe, JWe = [].concat(ol(FHe), ol(BWe)), Xx = Td.FontAwesomeConfig || {};
function QWe(e) {
  var t = dr.querySelector("script[" + e + "]");
  if (t)
    return t.getAttribute(e);
}
function ZWe(e) {
  return e === "" ? !0 : e === "false" ? !1 : e === "true" ? !0 : e;
}
if (dr && typeof dr.querySelector == "function") {
  var eqe = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-search-pseudo-elements-warnings", "searchPseudoElementsWarnings"], ["data-search-pseudo-elements-full-scan", "searchPseudoElementsFullScan"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
  eqe.forEach(function(e) {
    var t = QC(e, 2), n = t[0], r = t[1], a = ZWe(QWe(n));
    a != null && (Xx[r] = a);
  });
}
var LQ = {
  styleDefault: "solid",
  familyDefault: Fo,
  cssPrefix: PQ,
  replacementClass: DQ,
  autoReplaceSvg: !0,
  autoAddCss: !0,
  searchPseudoElements: !1,
  searchPseudoElementsWarnings: !0,
  searchPseudoElementsFullScan: !1,
  observeMutations: !0,
  mutateApproach: "async",
  keepOriginalSource: !0,
  measurePerformance: !1,
  showMissingIcons: !0
};
Xx.familyPrefix && (Xx.cssPrefix = Xx.familyPrefix);
var Dg = Ie(Ie({}, LQ), Xx);
Dg.autoReplaceSvg || (Dg.observeMutations = !1);
var ft = {};
Object.keys(LQ).forEach(function(e) {
  Object.defineProperty(ft, e, {
    enumerable: !0,
    set: function(n) {
      Dg[e] = n, Jx.forEach(function(r) {
        return r(ft);
      });
    },
    get: function() {
      return Dg[e];
    }
  });
});
Object.defineProperty(ft, "familyPrefix", {
  enumerable: !0,
  set: function(t) {
    Dg.cssPrefix = t, Jx.forEach(function(n) {
      return n(ft);
    });
  },
  get: function() {
    return Dg.cssPrefix;
  }
});
Td.FontAwesomeConfig = ft;
var Jx = [];
function tqe(e) {
  return Jx.push(e), function() {
    Jx.splice(Jx.indexOf(e), 1);
  };
}
var Dh = SR, Il = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: !1,
  flipY: !1
};
function nqe(e) {
  if (!(!e || !rd)) {
    var t = dr.createElement("style");
    t.setAttribute("type", "text/css"), t.innerHTML = e;
    for (var n = dr.head.childNodes, r = null, a = n.length - 1; a > -1; a--) {
      var s = n[a], l = (s.tagName || "").toUpperCase();
      ["STYLE", "LINK"].indexOf(l) > -1 && (r = s);
    }
    return dr.head.insertBefore(t, r), e;
  }
}
var rqe = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function _8() {
  for (var e = 12, t = ""; e-- > 0; )
    t += rqe[Math.random() * 62 | 0];
  return t;
}
function Qg(e) {
  for (var t = [], n = (e || []).length >>> 0; n--; )
    t[n] = e[n];
  return t;
}
function k1(e) {
  return e.classList ? Qg(e.classList) : (e.getAttribute("class") || "").split(" ").filter(function(t) {
    return t;
  });
}
function FQ(e) {
  return "".concat(e).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function oqe(e) {
  return Object.keys(e || {}).reduce(function(t, n) {
    return t + "".concat(n, '="').concat(FQ(e[n]), '" ');
  }, "").trim();
}
function ZC(e) {
  return Object.keys(e || {}).reduce(function(t, n) {
    return t + "".concat(n, ": ").concat(e[n].trim(), ";");
  }, "");
}
function _1(e) {
  return e.size !== Il.size || e.x !== Il.x || e.y !== Il.y || e.rotate !== Il.rotate || e.flipX || e.flipY;
}
function aqe(e) {
  var t = e.transform, n = e.containerWidth, r = e.iconWidth, a = {
    transform: "translate(".concat(n / 2, " 256)")
  }, s = "translate(".concat(t.x * 32, ", ").concat(t.y * 32, ") "), l = "scale(".concat(t.size / 16 * (t.flipX ? -1 : 1), ", ").concat(t.size / 16 * (t.flipY ? -1 : 1), ") "), c = "rotate(".concat(t.rotate, " 0 0)"), d = {
    transform: "".concat(s, " ").concat(l, " ").concat(c)
  }, f = {
    transform: "translate(".concat(r / 2 * -1, " -256)")
  };
  return {
    outer: a,
    inner: d,
    path: f
  };
}
function iqe(e) {
  var t = e.transform, n = e.width, r = n === void 0 ? SR : n, a = e.height, s = a === void 0 ? SR : a, l = "";
  return cQ ? l += "translate(".concat(t.x / Dh - r / 2, "em, ").concat(t.y / Dh - s / 2, "em) ") : l += "translate(calc(-50% + ".concat(t.x / Dh, "em), calc(-50% + ").concat(t.y / Dh, "em)) "), l += "scale(".concat(t.size / Dh * (t.flipX ? -1 : 1), ", ").concat(t.size / Dh * (t.flipY ? -1 : 1), ") "), l += "rotate(".concat(t.rotate, "deg) "), l;
}
var sqe = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 7 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 7 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 7 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 7 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 7 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 7 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-slab-regular: normal 400 1em/1 "Font Awesome 7 Slab";
  --fa-font-slab-press-regular: normal 400 1em/1 "Font Awesome 7 Slab Press";
  --fa-font-whiteboard-semibold: normal 600 1em/1 "Font Awesome 7 Whiteboard";
  --fa-font-thumbprint-light: normal 300 1em/1 "Font Awesome 7 Thumbprint";
  --fa-font-notdog-solid: normal 900 1em/1 "Font Awesome 7 Notdog";
  --fa-font-notdog-duo-solid: normal 900 1em/1 "Font Awesome 7 Notdog Duo";
  --fa-font-etch-solid: normal 900 1em/1 "Font Awesome 7 Etch";
  --fa-font-jelly-regular: normal 400 1em/1 "Font Awesome 7 Jelly";
  --fa-font-jelly-fill-regular: normal 400 1em/1 "Font Awesome 7 Jelly Fill";
  --fa-font-jelly-duo-regular: normal 400 1em/1 "Font Awesome 7 Jelly Duo";
  --fa-font-chisel-regular: normal 400 1em/1 "Font Awesome 7 Chisel";
  --fa-font-utility-semibold: normal 600 1em/1 "Font Awesome 7 Utility";
  --fa-font-utility-duo-semibold: normal 600 1em/1 "Font Awesome 7 Utility Duo";
  --fa-font-utility-fill-semibold: normal 600 1em/1 "Font Awesome 7 Utility Fill";
}

.svg-inline--fa {
  box-sizing: content-box;
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285714em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left,
.svg-inline--fa .fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-pull-right,
.svg-inline--fa .fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  inset-block-start: 0.25em; /* syncing vertical alignment with Web Font rendering */
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.fa-layers .svg-inline--fa {
  inset: 0;
  margin: auto;
  position: absolute;
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: calc(10 / 16 * 1em); /* converts a 10px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 10 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 10 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xs {
  font-size: calc(12 / 16 * 1em); /* converts a 12px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 12 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 12 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-sm {
  font-size: calc(14 / 16 * 1em); /* converts a 14px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 14 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 14 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-lg {
  font-size: calc(20 / 16 * 1em); /* converts a 20px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 20 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 20 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xl {
  font-size: calc(24 / 16 * 1em); /* converts a 24px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 24 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 24 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-2xl {
  font-size: calc(32 / 16 * 1em); /* converts a 32px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 32 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 32 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-width-auto {
  --fa-width: auto;
}

.fa-fw,
.fa-width-fixed {
  --fa-width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-inline-start: var(--fa-li-margin, 2.5em);
  padding-inline-start: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

/* Heads Up: Bordered Icons will not be supported in the future!
  - This feature will be deprecated in the next major release of Font Awesome (v8)!
  - You may continue to use it in this version *v7), but it will not be supported in Font Awesome v8.
*/
/* Notes:
* --@{v.$css-prefix}-border-width = 1/16 by default (to render as ~1px based on a 16px default font-size)
* --@{v.$css-prefix}-border-padding =
  ** 3/16 for vertical padding (to give ~2px of vertical whitespace around an icon considering it's vertical alignment)
  ** 4/16 for horizontal padding (to give ~4px of horizontal whitespace around an icon)
*/
.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.0625em);
  box-sizing: var(--fa-border-box-sizing, content-box);
  padding: var(--fa-border-padding, 0.1875em 0.25em);
}

.fa-pull-left,
.fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right,
.fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
  .fa-bounce,
  .fa-fade,
  .fa-beat-fade,
  .fa-flip,
  .fa-pulse,
  .fa-shake,
  .fa-spin,
  .fa-spin-pulse {
    animation: none !important;
    transition: none !important;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.svg-inline--fa.fa-inverse {
  fill: var(--fa-inverse, #fff);
}

.fa-stack {
  display: inline-block;
  height: 2em;
  line-height: 2em;
  position: relative;
  vertical-align: middle;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.svg-inline--fa.fa-stack-1x {
  --fa-width: 1.25em;
  height: 1em;
  width: var(--fa-width);
}
.svg-inline--fa.fa-stack-2x {
  --fa-width: 2.5em;
  height: 2em;
  width: var(--fa-width);
}

.fa-stack-1x,
.fa-stack-2x {
  inset: 0;
  margin: auto;
  position: absolute;
  z-index: var(--fa-stack-z-index, auto);
}`;
function BQ() {
  var e = PQ, t = DQ, n = ft.cssPrefix, r = ft.replacementClass, a = sqe;
  if (n !== e || r !== t) {
    var s = new RegExp("\\.".concat(e, "\\-"), "g"), l = new RegExp("\\--".concat(e, "\\-"), "g"), c = new RegExp("\\.".concat(t), "g");
    a = a.replace(s, ".".concat(n, "-")).replace(l, "--".concat(n, "-")).replace(c, ".".concat(r));
  }
  return a;
}
var E8 = !1;
function CA() {
  ft.autoAddCss && !E8 && (nqe(BQ()), E8 = !0);
}
var lqe = {
  mixout: function() {
    return {
      dom: {
        css: BQ,
        insertCss: CA
      }
    };
  },
  hooks: function() {
    return {
      beforeDOMElementCreation: function() {
        CA();
      },
      beforeI2svg: function() {
        CA();
      }
    };
  }
}, qc = Td || {};
qc[Wc] || (qc[Wc] = {});
qc[Wc].styles || (qc[Wc].styles = {});
qc[Wc].hooks || (qc[Wc].hooks = {});
qc[Wc].shims || (qc[Wc].shims = []);
var Xs = qc[Wc], UQ = [], VQ = function() {
  dr.removeEventListener("DOMContentLoaded", VQ), oE = 1, UQ.map(function(t) {
    return t();
  });
}, oE = !1;
rd && (oE = (dr.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(dr.readyState), oE || dr.addEventListener("DOMContentLoaded", VQ));
function uqe(e) {
  rd && (oE ? setTimeout(e, 0) : UQ.push(e));
}
function Fk(e) {
  var t = e.tag, n = e.attributes, r = n === void 0 ? {} : n, a = e.children, s = a === void 0 ? [] : a;
  return typeof e == "string" ? FQ(e) : "<".concat(t, " ").concat(oqe(r), ">").concat(s.map(Fk).join(""), "</").concat(t, ">");
}
function C8(e, t, n) {
  if (e && e[t] && e[t][n])
    return {
      prefix: t,
      iconName: n,
      icon: e[t][n]
    };
}
var OA = function(t, n, r, a) {
  var s = Object.keys(t), l = s.length, c = n, d, f, m;
  for (r === void 0 ? (d = 1, m = t[s[0]]) : (d = 0, m = r); d < l; d++)
    f = s[d], m = c(m, t[f], f, t);
  return m;
};
function HQ(e) {
  return ol(e).length !== 1 ? null : e.codePointAt(0).toString(16);
}
function O8(e) {
  return Object.keys(e).reduce(function(t, n) {
    var r = e[n], a = !!r.icon;
    return a ? t[r.iconName] = r.icon : t[n] = r, t;
  }, {});
}
function OR(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = n.skipHooks, a = r === void 0 ? !1 : r, s = O8(t);
  typeof Xs.hooks.addPack == "function" && !a ? Xs.hooks.addPack(e, O8(t)) : Xs.styles[e] = Ie(Ie({}, Xs.styles[e] || {}), s), e === "fas" && OR("fa", t);
}
var TS = Xs.styles, cqe = Xs.shims, WQ = Object.keys(S1), dqe = WQ.reduce(function(e, t) {
  return e[t] = Object.keys(S1[t]), e;
}, {}), E1 = null, qQ = {}, GQ = {}, KQ = {}, YQ = {}, XQ = {};
function fqe(e) {
  return ~JWe.indexOf(e);
}
function pqe(e, t) {
  var n = t.split("-"), r = n[0], a = n.slice(1).join("-");
  return r === e && a !== "" && !fqe(a) ? a : null;
}
var JQ = function() {
  var t = function(s) {
    return OA(TS, function(l, c, d) {
      return l[d] = OA(c, s, {}), l;
    }, {});
  };
  qQ = t(function(a, s, l) {
    if (s[3] && (a[s[3]] = l), s[2]) {
      var c = s[2].filter(function(d) {
        return typeof d == "number";
      });
      c.forEach(function(d) {
        a[d.toString(16)] = l;
      });
    }
    return a;
  }), GQ = t(function(a, s, l) {
    if (a[l] = l, s[2]) {
      var c = s[2].filter(function(d) {
        return typeof d == "string";
      });
      c.forEach(function(d) {
        a[d] = l;
      });
    }
    return a;
  }), XQ = t(function(a, s, l) {
    var c = s[2];
    return a[l] = l, c.forEach(function(d) {
      a[d] = l;
    }), a;
  });
  var n = "far" in TS || ft.autoFetchSvg, r = OA(cqe, function(a, s) {
    var l = s[0], c = s[1], d = s[2];
    return c === "far" && !n && (c = "fas"), typeof l == "string" && (a.names[l] = {
      prefix: c,
      iconName: d
    }), typeof l == "number" && (a.unicodes[l.toString(16)] = {
      prefix: c,
      iconName: d
    }), a;
  }, {
    names: {},
    unicodes: {}
  });
  KQ = r.names, YQ = r.unicodes, E1 = eO(ft.styleDefault, {
    family: ft.familyDefault
  });
};
tqe(function(e) {
  E1 = eO(e.styleDefault, {
    family: ft.familyDefault
  });
});
JQ();
function C1(e, t) {
  return (qQ[e] || {})[t];
}
function mqe(e, t) {
  return (GQ[e] || {})[t];
}
function Nm(e, t) {
  return (XQ[e] || {})[t];
}
function QQ(e) {
  return KQ[e] || {
    prefix: null,
    iconName: null
  };
}
function hqe(e) {
  var t = YQ[e], n = C1("fas", e);
  return t || (n ? {
    prefix: "fas",
    iconName: n
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function Ld() {
  return E1;
}
var ZQ = function() {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
};
function gqe(e) {
  var t = Fo, n = WQ.reduce(function(r, a) {
    return r[a] = "".concat(ft.cssPrefix, "-").concat(a), r;
  }, {});
  return NQ.forEach(function(r) {
    (e.includes(n[r]) || e.some(function(a) {
      return dqe[r].includes(a);
    })) && (t = r);
  }), t;
}
function eO(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.family, r = n === void 0 ? Fo : n, a = qWe[r][e];
  if (r === Tk && !e)
    return "fad";
  var s = k8[r][e] || k8[r][a], l = e in Xs.styles ? e : null, c = s || l || null;
  return c;
}
function vqe(e) {
  var t = [], n = null;
  return e.forEach(function(r) {
    var a = pqe(ft.cssPrefix, r);
    a ? n = a : r && t.push(r);
  }), {
    iconName: n,
    rest: t
  };
}
function M8(e) {
  return e.sort().filter(function(t, n, r) {
    return r.indexOf(t) === n;
  });
}
var N8 = RQ.concat(AQ);
function tO(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.skipLookups, r = n === void 0 ? !1 : n, a = null, s = M8(e.filter(function(g) {
    return N8.includes(g);
  })), l = M8(e.filter(function(g) {
    return !N8.includes(g);
  })), c = s.filter(function(g) {
    return a = g, !fQ.includes(g);
  }), d = QC(c, 1), f = d[0], m = f === void 0 ? null : f, h = gqe(s), v = Ie(Ie({}, vqe(l)), {}, {
    prefix: eO(m, {
      family: h
    })
  });
  return Ie(Ie(Ie({}, v), xqe({
    values: e,
    family: h,
    styles: TS,
    config: ft,
    canonical: v,
    givenPrefix: a
  })), yqe(r, a, v));
}
function yqe(e, t, n) {
  var r = n.prefix, a = n.iconName;
  if (e || !r || !a)
    return {
      prefix: r,
      iconName: a
    };
  var s = t === "fa" ? QQ(a) : {}, l = Nm(r, a);
  return a = s.iconName || l || a, r = s.prefix || r, r === "far" && !TS.far && TS.fas && !ft.autoFetchSvg && (r = "fas"), {
    prefix: r,
    iconName: a
  };
}
var bqe = NQ.filter(function(e) {
  return e !== Fo || e !== Tk;
}), wqe = Object.keys(xR).filter(function(e) {
  return e !== Fo;
}).map(function(e) {
  return Object.keys(xR[e]);
}).flat();
function xqe(e) {
  var t = e.values, n = e.family, r = e.canonical, a = e.givenPrefix, s = a === void 0 ? "" : a, l = e.styles, c = l === void 0 ? {} : l, d = e.config, f = d === void 0 ? {} : d, m = n === Tk, h = t.includes("fa-duotone") || t.includes("fad"), v = f.familyDefault === "duotone", g = r.prefix === "fad" || r.prefix === "fa-duotone";
  if (!m && (h || v || g) && (r.prefix = "fad"), (t.includes("fa-brands") || t.includes("fab")) && (r.prefix = "fab"), !r.prefix && bqe.includes(n)) {
    var b = Object.keys(c).find(function(w) {
      return wqe.includes(w);
    });
    if (b || f.autoFetchSvg) {
      var x = THe.get(n).defaultShortPrefixId;
      r.prefix = x, r.iconName = Nm(r.prefix, r.iconName) || r.iconName;
    }
  }
  return (r.prefix === "fa" || s === "fa") && (r.prefix = Ld() || "fas"), r;
}
var Sqe = /* @__PURE__ */ (function() {
  function e() {
    iHe(this, e), this.definitions = {};
  }
  return lHe(e, [{
    key: "add",
    value: function() {
      for (var n = this, r = arguments.length, a = new Array(r), s = 0; s < r; s++)
        a[s] = arguments[s];
      var l = a.reduce(this._pullDefinitions, {});
      Object.keys(l).forEach(function(c) {
        n.definitions[c] = Ie(Ie({}, n.definitions[c] || {}), l[c]), OR(c, l[c]);
        var d = S1[Fo][c];
        d && OR(d, l[c]), JQ();
      });
    }
  }, {
    key: "reset",
    value: function() {
      this.definitions = {};
    }
  }, {
    key: "_pullDefinitions",
    value: function(n, r) {
      var a = r.prefix && r.iconName && r.icon ? {
        0: r
      } : r;
      return Object.keys(a).map(function(s) {
        var l = a[s], c = l.prefix, d = l.iconName, f = l.icon, m = f[2];
        n[c] || (n[c] = {}), m.length > 0 && m.forEach(function(h) {
          typeof h == "string" && (n[c][h] = f);
        }), n[c][d] = f;
      }), n;
    }
  }]);
})(), A8 = [], Yh = {}, dg = {}, kqe = Object.keys(dg);
function _qe(e, t) {
  var n = t.mixoutsTo;
  return A8 = e, Yh = {}, Object.keys(dg).forEach(function(r) {
    kqe.indexOf(r) === -1 && delete dg[r];
  }), A8.forEach(function(r) {
    var a = r.mixout ? r.mixout() : {};
    if (Object.keys(a).forEach(function(l) {
      typeof a[l] == "function" && (n[l] = a[l]), rE(a[l]) === "object" && Object.keys(a[l]).forEach(function(c) {
        n[l] || (n[l] = {}), n[l][c] = a[l][c];
      });
    }), r.hooks) {
      var s = r.hooks();
      Object.keys(s).forEach(function(l) {
        Yh[l] || (Yh[l] = []), Yh[l].push(s[l]);
      });
    }
    r.provides && r.provides(dg);
  }), n;
}
function MR(e, t) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), a = 2; a < n; a++)
    r[a - 2] = arguments[a];
  var s = Yh[e] || [];
  return s.forEach(function(l) {
    t = l.apply(null, [t].concat(r));
  }), t;
}
function Ym(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  var a = Yh[e] || [];
  a.forEach(function(s) {
    s.apply(null, n);
  });
}
function Fd() {
  var e = arguments[0], t = Array.prototype.slice.call(arguments, 1);
  return dg[e] ? dg[e].apply(null, t) : void 0;
}
function NR(e) {
  e.prefix === "fa" && (e.prefix = "fas");
  var t = e.iconName, n = e.prefix || Ld();
  if (t)
    return t = Nm(n, t) || t, C8(eZ.definitions, n, t) || C8(Xs.styles, n, t);
}
var eZ = new Sqe(), Eqe = function() {
  ft.autoReplaceSvg = !1, ft.observeMutations = !1, Ym("noAuto");
}, Cqe = {
  i2svg: function() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return rd ? (Ym("beforeI2svg", t), Fd("pseudoElements2svg", t), Fd("i2svg", t)) : Promise.reject(new Error("Operation requires a DOM of some kind."));
  },
  watch: function() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = t.autoReplaceSvgRoot;
    ft.autoReplaceSvg === !1 && (ft.autoReplaceSvg = !0), ft.observeMutations = !0, uqe(function() {
      Mqe({
        autoReplaceSvgRoot: n
      }), Ym("watch", t);
    });
  }
}, Oqe = {
  icon: function(t) {
    if (t === null)
      return null;
    if (rE(t) === "object" && t.prefix && t.iconName)
      return {
        prefix: t.prefix,
        iconName: Nm(t.prefix, t.iconName) || t.iconName
      };
    if (Array.isArray(t) && t.length === 2) {
      var n = t[1].indexOf("fa-") === 0 ? t[1].slice(3) : t[1], r = eO(t[0]);
      return {
        prefix: r,
        iconName: Nm(r, n) || n
      };
    }
    if (typeof t == "string" && (t.indexOf("".concat(ft.cssPrefix, "-")) > -1 || t.match(GWe))) {
      var a = tO(t.split(" "), {
        skipLookups: !0
      });
      return {
        prefix: a.prefix || Ld(),
        iconName: Nm(a.prefix, a.iconName) || a.iconName
      };
    }
    if (typeof t == "string") {
      var s = Ld();
      return {
        prefix: s,
        iconName: Nm(s, t) || t
      };
    }
  }
}, Pi = {
  noAuto: Eqe,
  config: ft,
  dom: Cqe,
  parse: Oqe,
  library: eZ,
  findIconDefinition: NR,
  toHtml: Fk
}, Mqe = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = t.autoReplaceSvgRoot, r = n === void 0 ? dr : n;
  (Object.keys(Xs.styles).length > 0 || ft.autoFetchSvg) && rd && ft.autoReplaceSvg && Pi.dom.i2svg({
    node: r
  });
};
function nO(e, t) {
  return Object.defineProperty(e, "abstract", {
    get: t
  }), Object.defineProperty(e, "html", {
    get: function() {
      return e.abstract.map(function(r) {
        return Fk(r);
      });
    }
  }), Object.defineProperty(e, "node", {
    get: function() {
      if (rd) {
        var r = dr.createElement("div");
        return r.innerHTML = e.html, r.children;
      }
    }
  }), e;
}
function Nqe(e) {
  var t = e.children, n = e.main, r = e.mask, a = e.attributes, s = e.styles, l = e.transform;
  if (_1(l) && n.found && !r.found) {
    var c = n.width, d = n.height, f = {
      x: c / d / 2,
      y: 0.5
    };
    a.style = ZC(Ie(Ie({}, s), {}, {
      "transform-origin": "".concat(f.x + l.x / 16, "em ").concat(f.y + l.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes: a,
    children: t
  }];
}
function Aqe(e) {
  var t = e.prefix, n = e.iconName, r = e.children, a = e.attributes, s = e.symbol, l = s === !0 ? "".concat(t, "-").concat(ft.cssPrefix, "-").concat(n) : s;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: Ie(Ie({}, a), {}, {
        id: l
      }),
      children: r
    }]
  }];
}
function Rqe(e) {
  var t = ["aria-label", "aria-labelledby", "title", "role"];
  return t.some(function(n) {
    return n in e;
  });
}
function O1(e) {
  var t = e.icons, n = t.main, r = t.mask, a = e.prefix, s = e.iconName, l = e.transform, c = e.symbol, d = e.maskId, f = e.extra, m = e.watchable, h = m === void 0 ? !1 : m, v = r.found ? r : n, g = v.width, b = v.height, x = [ft.replacementClass, s ? "".concat(ft.cssPrefix, "-").concat(s) : ""].filter(function(N) {
    return f.classes.indexOf(N) === -1;
  }).filter(function(N) {
    return N !== "" || !!N;
  }).concat(f.classes).join(" "), w = {
    children: [],
    attributes: Ie(Ie({}, f.attributes), {}, {
      "data-prefix": a,
      "data-icon": s,
      class: x,
      role: f.attributes.role || "img",
      viewBox: "0 0 ".concat(g, " ").concat(b)
    })
  };
  !Rqe(f.attributes) && !f.attributes["aria-hidden"] && (w.attributes["aria-hidden"] = "true"), h && (w.attributes[Km] = "");
  var k = Ie(Ie({}, w), {}, {
    prefix: a,
    iconName: s,
    main: n,
    mask: r,
    maskId: d,
    transform: l,
    symbol: c,
    styles: Ie({}, f.styles)
  }), E = r.found && n.found ? Fd("generateAbstractMask", k) || {
    children: [],
    attributes: {}
  } : Fd("generateAbstractIcon", k) || {
    children: [],
    attributes: {}
  }, _ = E.children, O = E.attributes;
  return k.children = _, k.attributes = O, c ? Aqe(k) : Nqe(k);
}
function R8(e) {
  var t = e.content, n = e.width, r = e.height, a = e.transform, s = e.extra, l = e.watchable, c = l === void 0 ? !1 : l, d = Ie(Ie({}, s.attributes), {}, {
    class: s.classes.join(" ")
  });
  c && (d[Km] = "");
  var f = Ie({}, s.styles);
  _1(a) && (f.transform = iqe({
    transform: a,
    width: n,
    height: r
  }), f["-webkit-transform"] = f.transform);
  var m = ZC(f);
  m.length > 0 && (d.style = m);
  var h = [];
  return h.push({
    tag: "span",
    attributes: d,
    children: [t]
  }), h;
}
function jqe(e) {
  var t = e.content, n = e.extra, r = Ie(Ie({}, n.attributes), {}, {
    class: n.classes.join(" ")
  }), a = ZC(n.styles);
  a.length > 0 && (r.style = a);
  var s = [];
  return s.push({
    tag: "span",
    attributes: r,
    children: [t]
  }), s;
}
var MA = Xs.styles;
function AR(e) {
  var t = e[0], n = e[1], r = e.slice(4), a = QC(r, 1), s = a[0], l = null;
  return Array.isArray(s) ? l = {
    tag: "g",
    attributes: {
      class: "".concat(ft.cssPrefix, "-").concat(EA.GROUP)
    },
    children: [{
      tag: "path",
      attributes: {
        class: "".concat(ft.cssPrefix, "-").concat(EA.SECONDARY),
        fill: "currentColor",
        d: s[0]
      }
    }, {
      tag: "path",
      attributes: {
        class: "".concat(ft.cssPrefix, "-").concat(EA.PRIMARY),
        fill: "currentColor",
        d: s[1]
      }
    }]
  } : l = {
    tag: "path",
    attributes: {
      fill: "currentColor",
      d: s
    }
  }, {
    found: !0,
    width: t,
    height: n,
    icon: l
  };
}
var Pqe = {
  found: !1,
  width: 512,
  height: 512
};
function Dqe(e, t) {
  !$Q && !ft.showMissingIcons && e && console.error('Icon with name "'.concat(e, '" and prefix "').concat(t, '" is missing.'));
}
function RR(e, t) {
  var n = t;
  return t === "fa" && ft.styleDefault !== null && (t = Ld()), new Promise(function(r, a) {
    if (n === "fa") {
      var s = QQ(e) || {};
      e = s.iconName || e, t = s.prefix || t;
    }
    if (e && t && MA[t] && MA[t][e]) {
      var l = MA[t][e];
      return r(AR(l));
    }
    Dqe(e, t), r(Ie(Ie({}, Pqe), {}, {
      icon: ft.showMissingIcons && e ? Fd("missingIconAbstract") || {} : {}
    }));
  });
}
var j8 = function() {
}, jR = ft.measurePerformance && x_ && x_.mark && x_.measure ? x_ : {
  mark: j8,
  measure: j8
}, Mx = 'FA "7.1.0"', Iqe = function(t) {
  return jR.mark("".concat(Mx, " ").concat(t, " begins")), function() {
    return tZ(t);
  };
}, tZ = function(t) {
  jR.mark("".concat(Mx, " ").concat(t, " ends")), jR.measure("".concat(Mx, " ").concat(t), "".concat(Mx, " ").concat(t, " begins"), "".concat(Mx, " ").concat(t, " ends"));
}, M1 = {
  begin: Iqe,
  end: tZ
}, Q_ = function() {
};
function P8(e) {
  var t = e.getAttribute ? e.getAttribute(Km) : null;
  return typeof t == "string";
}
function $qe(e) {
  var t = e.getAttribute ? e.getAttribute(w1) : null, n = e.getAttribute ? e.getAttribute(x1) : null;
  return t && n;
}
function zqe(e) {
  return e && e.classList && e.classList.contains && e.classList.contains(ft.replacementClass);
}
function Tqe() {
  if (ft.autoReplaceSvg === !0)
    return Z_.replace;
  var e = Z_[ft.autoReplaceSvg];
  return e || Z_.replace;
}
function Lqe(e) {
  return dr.createElementNS("http://www.w3.org/2000/svg", e);
}
function Fqe(e) {
  return dr.createElement(e);
}
function nZ(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.ceFn, r = n === void 0 ? e.tag === "svg" ? Lqe : Fqe : n;
  if (typeof e == "string")
    return dr.createTextNode(e);
  var a = r(e.tag);
  Object.keys(e.attributes || []).forEach(function(l) {
    a.setAttribute(l, e.attributes[l]);
  });
  var s = e.children || [];
  return s.forEach(function(l) {
    a.appendChild(nZ(l, {
      ceFn: r
    }));
  }), a;
}
function Bqe(e) {
  var t = " ".concat(e.outerHTML, " ");
  return t = "".concat(t, "Font Awesome fontawesome.com "), t;
}
var Z_ = {
  replace: function(t) {
    var n = t[0];
    if (n.parentNode)
      if (t[1].forEach(function(a) {
        n.parentNode.insertBefore(nZ(a), n);
      }), n.getAttribute(Km) === null && ft.keepOriginalSource) {
        var r = dr.createComment(Bqe(n));
        n.parentNode.replaceChild(r, n);
      } else
        n.remove();
  },
  nest: function(t) {
    var n = t[0], r = t[1];
    if (~k1(n).indexOf(ft.replacementClass))
      return Z_.replace(t);
    var a = new RegExp("".concat(ft.cssPrefix, "-.*"));
    if (delete r[0].attributes.id, r[0].attributes.class) {
      var s = r[0].attributes.class.split(" ").reduce(function(c, d) {
        return d === ft.replacementClass || d.match(a) ? c.toSvg.push(d) : c.toNode.push(d), c;
      }, {
        toNode: [],
        toSvg: []
      });
      r[0].attributes.class = s.toSvg.join(" "), s.toNode.length === 0 ? n.removeAttribute("class") : n.setAttribute("class", s.toNode.join(" "));
    }
    var l = r.map(function(c) {
      return Fk(c);
    }).join(`
`);
    n.setAttribute(Km, ""), n.innerHTML = l;
  }
};
function D8(e) {
  e();
}
function rZ(e, t) {
  var n = typeof t == "function" ? t : Q_;
  if (e.length === 0)
    n();
  else {
    var r = D8;
    ft.mutateApproach === HWe && (r = Td.requestAnimationFrame || D8), r(function() {
      var a = Tqe(), s = M1.begin("mutate");
      e.map(a), s(), n();
    });
  }
}
var N1 = !1;
function oZ() {
  N1 = !0;
}
function PR() {
  N1 = !1;
}
var aE = null;
function I8(e) {
  if (b8 && ft.observeMutations) {
    var t = e.treeCallback, n = t === void 0 ? Q_ : t, r = e.nodeCallback, a = r === void 0 ? Q_ : r, s = e.pseudoElementsCallback, l = s === void 0 ? Q_ : s, c = e.observeMutationsRoot, d = c === void 0 ? dr : c;
    aE = new b8(function(f) {
      if (!N1) {
        var m = Ld();
        Qg(f).forEach(function(h) {
          if (h.type === "childList" && h.addedNodes.length > 0 && !P8(h.addedNodes[0]) && (ft.searchPseudoElements && l(h.target), n(h.target)), h.type === "attributes" && h.target.parentNode && ft.searchPseudoElements && l([h.target], !0), h.type === "attributes" && P8(h.target) && ~XWe.indexOf(h.attributeName))
            if (h.attributeName === "class" && $qe(h.target)) {
              var v = tO(k1(h.target)), g = v.prefix, b = v.iconName;
              h.target.setAttribute(w1, g || m), b && h.target.setAttribute(x1, b);
            } else zqe(h.target) && a(h.target);
        });
      }
    }), rd && aE.observe(d, {
      childList: !0,
      attributes: !0,
      characterData: !0,
      subtree: !0
    });
  }
}
function Uqe() {
  aE && aE.disconnect();
}
function Vqe(e) {
  var t = e.getAttribute("style"), n = [];
  return t && (n = t.split(";").reduce(function(r, a) {
    var s = a.split(":"), l = s[0], c = s.slice(1);
    return l && c.length > 0 && (r[l] = c.join(":").trim()), r;
  }, {})), n;
}
function Hqe(e) {
  var t = e.getAttribute("data-prefix"), n = e.getAttribute("data-icon"), r = e.innerText !== void 0 ? e.innerText.trim() : "", a = tO(k1(e));
  return a.prefix || (a.prefix = Ld()), t && n && (a.prefix = t, a.iconName = n), a.iconName && a.prefix || (a.prefix && r.length > 0 && (a.iconName = mqe(a.prefix, e.innerText) || C1(a.prefix, HQ(e.innerText))), !a.iconName && ft.autoFetchSvg && e.firstChild && e.firstChild.nodeType === Node.TEXT_NODE && (a.iconName = e.firstChild.data)), a;
}
function Wqe(e) {
  var t = Qg(e.attributes).reduce(function(n, r) {
    return n.name !== "class" && n.name !== "style" && (n[r.name] = r.value), n;
  }, {});
  return t;
}
function qqe() {
  return {
    iconName: null,
    prefix: null,
    transform: Il,
    symbol: !1,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function $8(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: !0
  }, n = Hqe(e), r = n.iconName, a = n.prefix, s = n.rest, l = Wqe(e), c = MR("parseNodeAttributes", {}, e), d = t.styleParser ? Vqe(e) : [];
  return Ie({
    iconName: r,
    prefix: a,
    transform: Il,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: !1,
    extra: {
      classes: s,
      styles: d,
      attributes: l
    }
  }, c);
}
var Gqe = Xs.styles;
function aZ(e) {
  var t = ft.autoReplaceSvg === "nest" ? $8(e, {
    styleParser: !1
  }) : $8(e);
  return ~t.extra.classes.indexOf(TQ) ? Fd("generateLayersText", e, t) : Fd("generateSvgReplacementMutation", e, t);
}
function Kqe() {
  return [].concat(ol(AQ), ol(RQ));
}
function z8(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!rd) return Promise.resolve();
  var n = dr.documentElement.classList, r = function(h) {
    return n.add("".concat(S8, "-").concat(h));
  }, a = function(h) {
    return n.remove("".concat(S8, "-").concat(h));
  }, s = ft.autoFetchSvg ? Kqe() : fQ.concat(Object.keys(Gqe));
  s.includes("fa") || s.push("fa");
  var l = [".".concat(TQ, ":not([").concat(Km, "])")].concat(s.map(function(m) {
    return ".".concat(m, ":not([").concat(Km, "])");
  })).join(", ");
  if (l.length === 0)
    return Promise.resolve();
  var c = [];
  try {
    c = Qg(e.querySelectorAll(l));
  } catch {
  }
  if (c.length > 0)
    r("pending"), a("complete");
  else
    return Promise.resolve();
  var d = M1.begin("onTree"), f = c.reduce(function(m, h) {
    try {
      var v = aZ(h);
      v && m.push(v);
    } catch (g) {
      $Q || g.name === "MissingIcon" && console.error(g);
    }
    return m;
  }, []);
  return new Promise(function(m, h) {
    Promise.all(f).then(function(v) {
      rZ(v, function() {
        r("active"), r("complete"), a("pending"), typeof t == "function" && t(), d(), m();
      });
    }).catch(function(v) {
      d(), h(v);
    });
  });
}
function Yqe(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  aZ(e).then(function(n) {
    n && rZ([n], t);
  });
}
function Xqe(e) {
  return function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = (t || {}).icon ? t : NR(t || {}), a = n.mask;
    return a && (a = (a || {}).icon ? a : NR(a || {})), e(r, Ie(Ie({}, n), {}, {
      mask: a
    }));
  };
}
var Jqe = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = n.transform, a = r === void 0 ? Il : r, s = n.symbol, l = s === void 0 ? !1 : s, c = n.mask, d = c === void 0 ? null : c, f = n.maskId, m = f === void 0 ? null : f, h = n.classes, v = h === void 0 ? [] : h, g = n.attributes, b = g === void 0 ? {} : g, x = n.styles, w = x === void 0 ? {} : x;
  if (t) {
    var k = t.prefix, E = t.iconName, _ = t.icon;
    return nO(Ie({
      type: "icon"
    }, t), function() {
      return Ym("beforeDOMElementCreation", {
        iconDefinition: t,
        params: n
      }), O1({
        icons: {
          main: AR(_),
          mask: d ? AR(d.icon) : {
            found: !1,
            width: null,
            height: null,
            icon: {}
          }
        },
        prefix: k,
        iconName: E,
        transform: Ie(Ie({}, Il), a),
        symbol: l,
        maskId: m,
        extra: {
          attributes: b,
          styles: w,
          classes: v
        }
      });
    });
  }
}, Qqe = {
  mixout: function() {
    return {
      icon: Xqe(Jqe)
    };
  },
  hooks: function() {
    return {
      mutationObserverCallbacks: function(n) {
        return n.treeCallback = z8, n.nodeCallback = Yqe, n;
      }
    };
  },
  provides: function(t) {
    t.i2svg = function(n) {
      var r = n.node, a = r === void 0 ? dr : r, s = n.callback, l = s === void 0 ? function() {
      } : s;
      return z8(a, l);
    }, t.generateSvgReplacementMutation = function(n, r) {
      var a = r.iconName, s = r.prefix, l = r.transform, c = r.symbol, d = r.mask, f = r.maskId, m = r.extra;
      return new Promise(function(h, v) {
        Promise.all([RR(a, s), d.iconName ? RR(d.iconName, d.prefix) : Promise.resolve({
          found: !1,
          width: 512,
          height: 512,
          icon: {}
        })]).then(function(g) {
          var b = QC(g, 2), x = b[0], w = b[1];
          h([n, O1({
            icons: {
              main: x,
              mask: w
            },
            prefix: s,
            iconName: a,
            transform: l,
            symbol: c,
            maskId: f,
            extra: m,
            watchable: !0
          })]);
        }).catch(v);
      });
    }, t.generateAbstractIcon = function(n) {
      var r = n.children, a = n.attributes, s = n.main, l = n.transform, c = n.styles, d = ZC(c);
      d.length > 0 && (a.style = d);
      var f;
      return _1(l) && (f = Fd("generateAbstractTransformGrouping", {
        main: s,
        transform: l,
        containerWidth: s.width,
        iconWidth: s.width
      })), r.push(f || s.icon), {
        children: r,
        attributes: a
      };
    };
  }
}, Zqe = {
  mixout: function() {
    return {
      layer: function(n) {
        var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = r.classes, s = a === void 0 ? [] : a;
        return nO({
          type: "layer"
        }, function() {
          Ym("beforeDOMElementCreation", {
            assembler: n,
            params: r
          });
          var l = [];
          return n(function(c) {
            Array.isArray(c) ? c.map(function(d) {
              l = l.concat(d.abstract);
            }) : l = l.concat(c.abstract);
          }), [{
            tag: "span",
            attributes: {
              class: ["".concat(ft.cssPrefix, "-layers")].concat(ol(s)).join(" ")
            },
            children: l
          }];
        });
      }
    };
  }
}, eGe = {
  mixout: function() {
    return {
      counter: function(n) {
        var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        r.title;
        var a = r.classes, s = a === void 0 ? [] : a, l = r.attributes, c = l === void 0 ? {} : l, d = r.styles, f = d === void 0 ? {} : d;
        return nO({
          type: "counter",
          content: n
        }, function() {
          return Ym("beforeDOMElementCreation", {
            content: n,
            params: r
          }), jqe({
            content: n.toString(),
            extra: {
              attributes: c,
              styles: f,
              classes: ["".concat(ft.cssPrefix, "-layers-counter")].concat(ol(s))
            }
          });
        });
      }
    };
  }
}, tGe = {
  mixout: function() {
    return {
      text: function(n) {
        var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = r.transform, s = a === void 0 ? Il : a, l = r.classes, c = l === void 0 ? [] : l, d = r.attributes, f = d === void 0 ? {} : d, m = r.styles, h = m === void 0 ? {} : m;
        return nO({
          type: "text",
          content: n
        }, function() {
          return Ym("beforeDOMElementCreation", {
            content: n,
            params: r
          }), R8({
            content: n,
            transform: Ie(Ie({}, Il), s),
            extra: {
              attributes: f,
              styles: h,
              classes: ["".concat(ft.cssPrefix, "-layers-text")].concat(ol(c))
            }
          });
        });
      }
    };
  },
  provides: function(t) {
    t.generateLayersText = function(n, r) {
      var a = r.transform, s = r.extra, l = null, c = null;
      if (cQ) {
        var d = parseInt(getComputedStyle(n).fontSize, 10), f = n.getBoundingClientRect();
        l = f.width / d, c = f.height / d;
      }
      return Promise.resolve([n, R8({
        content: n.innerHTML,
        width: l,
        height: c,
        transform: a,
        extra: s,
        watchable: !0
      })]);
    };
  }
}, iZ = new RegExp('"', "ug"), T8 = [1105920, 1112319], L8 = Ie(Ie(Ie(Ie({}, {
  FontAwesome: {
    normal: "fas",
    400: "fas"
  }
}), zHe), UWe), qHe), DR = Object.keys(L8).reduce(function(e, t) {
  return e[t.toLowerCase()] = L8[t], e;
}, {}), nGe = Object.keys(DR).reduce(function(e, t) {
  var n = DR[t];
  return e[t] = n[900] || ol(Object.entries(n))[0][1], e;
}, {});
function rGe(e) {
  var t = e.replace(iZ, "");
  return HQ(ol(t)[0] || "");
}
function oGe(e) {
  var t = e.getPropertyValue("font-feature-settings").includes("ss01"), n = e.getPropertyValue("content"), r = n.replace(iZ, ""), a = r.codePointAt(0), s = a >= T8[0] && a <= T8[1], l = r.length === 2 ? r[0] === r[1] : !1;
  return s || l || t;
}
function aGe(e, t) {
  var n = e.replace(/^['"]|['"]$/g, "").toLowerCase(), r = parseInt(t), a = isNaN(r) ? "normal" : r;
  return (DR[n] || {})[a] || nGe[n];
}
function F8(e, t) {
  var n = "".concat(VWe).concat(t.replace(":", "-"));
  return new Promise(function(r, a) {
    if (e.getAttribute(n) !== null)
      return r();
    var s = Qg(e.children), l = s.filter(function(A) {
      return A.getAttribute(kR) === t;
    })[0], c = Td.getComputedStyle(e, t), d = c.getPropertyValue("font-family"), f = d.match(KWe), m = c.getPropertyValue("font-weight"), h = c.getPropertyValue("content");
    if (l && !f)
      return e.removeChild(l), r();
    if (f && h !== "none" && h !== "") {
      var v = c.getPropertyValue("content"), g = aGe(d, m), b = rGe(v), x = f[0].startsWith("FontAwesome"), w = oGe(c), k = C1(g, b), E = k;
      if (x) {
        var _ = hqe(b);
        _.iconName && _.prefix && (k = _.iconName, g = _.prefix);
      }
      if (k && !w && (!l || l.getAttribute(w1) !== g || l.getAttribute(x1) !== E)) {
        e.setAttribute(n, E), l && e.removeChild(l);
        var O = qqe(), N = O.extra;
        N.attributes[kR] = t, RR(k, g).then(function(A) {
          var R = O1(Ie(Ie({}, O), {}, {
            icons: {
              main: A,
              mask: ZQ()
            },
            prefix: g,
            iconName: E,
            extra: N,
            watchable: !0
          })), D = dr.createElementNS("http://www.w3.org/2000/svg", "svg");
          t === "::before" ? e.insertBefore(D, e.firstChild) : e.appendChild(D), D.outerHTML = R.map(function(I) {
            return Fk(I);
          }).join(`
`), e.removeAttribute(n), r();
        }).catch(a);
      } else
        r();
    } else
      r();
  });
}
function iGe(e) {
  return Promise.all([F8(e, "::before"), F8(e, "::after")]);
}
function sGe(e) {
  return e.parentNode !== document.head && !~WWe.indexOf(e.tagName.toUpperCase()) && !e.getAttribute(kR) && (!e.parentNode || e.parentNode.tagName !== "svg");
}
var lGe = function(t) {
  return !!t && IQ.some(function(n) {
    return t.includes(n);
  });
}, uGe = function(t) {
  if (!t) return [];
  var n = /* @__PURE__ */ new Set(), r = t.split(/,(?![^()]*\))/).map(function(d) {
    return d.trim();
  });
  r = r.flatMap(function(d) {
    return d.includes("(") ? d : d.split(",").map(function(f) {
      return f.trim();
    });
  });
  var a = J_(r), s;
  try {
    for (a.s(); !(s = a.n()).done; ) {
      var l = s.value;
      if (lGe(l)) {
        var c = IQ.reduce(function(d, f) {
          return d.replace(f, "");
        }, l);
        c !== "" && c !== "*" && n.add(c);
      }
    }
  } catch (d) {
    a.e(d);
  } finally {
    a.f();
  }
  return n;
};
function B8(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  if (rd) {
    var n;
    if (t)
      n = e;
    else if (ft.searchPseudoElementsFullScan)
      n = e.querySelectorAll("*");
    else {
      var r = /* @__PURE__ */ new Set(), a = J_(document.styleSheets), s;
      try {
        for (a.s(); !(s = a.n()).done; ) {
          var l = s.value;
          try {
            var c = J_(l.cssRules), d;
            try {
              for (c.s(); !(d = c.n()).done; ) {
                var f = d.value, m = uGe(f.selectorText), h = J_(m), v;
                try {
                  for (h.s(); !(v = h.n()).done; ) {
                    var g = v.value;
                    r.add(g);
                  }
                } catch (x) {
                  h.e(x);
                } finally {
                  h.f();
                }
              }
            } catch (x) {
              c.e(x);
            } finally {
              c.f();
            }
          } catch (x) {
            ft.searchPseudoElementsWarnings && console.warn("Font Awesome: cannot parse stylesheet: ".concat(l.href, " (").concat(x.message, `)
If it declares any Font Awesome CSS pseudo-elements, they will not be rendered as SVG icons. Add crossorigin="anonymous" to the <link>, enable searchPseudoElementsFullScan for slower but more thorough DOM parsing, or suppress this warning by setting searchPseudoElementsWarnings to false.`));
          }
        }
      } catch (x) {
        a.e(x);
      } finally {
        a.f();
      }
      if (!r.size) return;
      var b = Array.from(r).join(", ");
      try {
        n = e.querySelectorAll(b);
      } catch {
      }
    }
    return new Promise(function(x, w) {
      var k = Qg(n).filter(sGe).map(iGe), E = M1.begin("searchPseudoElements");
      oZ(), Promise.all(k).then(function() {
        E(), PR(), x();
      }).catch(function() {
        E(), PR(), w();
      });
    });
  }
}
var cGe = {
  hooks: function() {
    return {
      mutationObserverCallbacks: function(n) {
        return n.pseudoElementsCallback = B8, n;
      }
    };
  },
  provides: function(t) {
    t.pseudoElements2svg = function(n) {
      var r = n.node, a = r === void 0 ? dr : r;
      ft.searchPseudoElements && B8(a);
    };
  }
}, U8 = !1, dGe = {
  mixout: function() {
    return {
      dom: {
        unwatch: function() {
          oZ(), U8 = !0;
        }
      }
    };
  },
  hooks: function() {
    return {
      bootstrap: function() {
        I8(MR("mutationObserverCallbacks", {}));
      },
      noAuto: function() {
        Uqe();
      },
      watch: function(n) {
        var r = n.observeMutationsRoot;
        U8 ? PR() : I8(MR("mutationObserverCallbacks", {
          observeMutationsRoot: r
        }));
      }
    };
  }
}, V8 = function(t) {
  var n = {
    size: 16,
    x: 0,
    y: 0,
    flipX: !1,
    flipY: !1,
    rotate: 0
  };
  return t.toLowerCase().split(" ").reduce(function(r, a) {
    var s = a.toLowerCase().split("-"), l = s[0], c = s.slice(1).join("-");
    if (l && c === "h")
      return r.flipX = !0, r;
    if (l && c === "v")
      return r.flipY = !0, r;
    if (c = parseFloat(c), isNaN(c))
      return r;
    switch (l) {
      case "grow":
        r.size = r.size + c;
        break;
      case "shrink":
        r.size = r.size - c;
        break;
      case "left":
        r.x = r.x - c;
        break;
      case "right":
        r.x = r.x + c;
        break;
      case "up":
        r.y = r.y - c;
        break;
      case "down":
        r.y = r.y + c;
        break;
      case "rotate":
        r.rotate = r.rotate + c;
        break;
    }
    return r;
  }, n);
}, fGe = {
  mixout: function() {
    return {
      parse: {
        transform: function(n) {
          return V8(n);
        }
      }
    };
  },
  hooks: function() {
    return {
      parseNodeAttributes: function(n, r) {
        var a = r.getAttribute("data-fa-transform");
        return a && (n.transform = V8(a)), n;
      }
    };
  },
  provides: function(t) {
    t.generateAbstractTransformGrouping = function(n) {
      var r = n.main, a = n.transform, s = n.containerWidth, l = n.iconWidth, c = {
        transform: "translate(".concat(s / 2, " 256)")
      }, d = "translate(".concat(a.x * 32, ", ").concat(a.y * 32, ") "), f = "scale(".concat(a.size / 16 * (a.flipX ? -1 : 1), ", ").concat(a.size / 16 * (a.flipY ? -1 : 1), ") "), m = "rotate(".concat(a.rotate, " 0 0)"), h = {
        transform: "".concat(d, " ").concat(f, " ").concat(m)
      }, v = {
        transform: "translate(".concat(l / 2 * -1, " -256)")
      }, g = {
        outer: c,
        inner: h,
        path: v
      };
      return {
        tag: "g",
        attributes: Ie({}, g.outer),
        children: [{
          tag: "g",
          attributes: Ie({}, g.inner),
          children: [{
            tag: r.icon.tag,
            children: r.icon.children,
            attributes: Ie(Ie({}, r.icon.attributes), g.path)
          }]
        }]
      };
    };
  }
}, NA = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function H8(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return e.attributes && (e.attributes.fill || t) && (e.attributes.fill = "black"), e;
}
function pGe(e) {
  return e.tag === "g" ? e.children : [e];
}
var mGe = {
  hooks: function() {
    return {
      parseNodeAttributes: function(n, r) {
        var a = r.getAttribute("data-fa-mask"), s = a ? tO(a.split(" ").map(function(l) {
          return l.trim();
        })) : ZQ();
        return s.prefix || (s.prefix = Ld()), n.mask = s, n.maskId = r.getAttribute("data-fa-mask-id"), n;
      }
    };
  },
  provides: function(t) {
    t.generateAbstractMask = function(n) {
      var r = n.children, a = n.attributes, s = n.main, l = n.mask, c = n.maskId, d = n.transform, f = s.width, m = s.icon, h = l.width, v = l.icon, g = aqe({
        transform: d,
        containerWidth: h,
        iconWidth: f
      }), b = {
        tag: "rect",
        attributes: Ie(Ie({}, NA), {}, {
          fill: "white"
        })
      }, x = m.children ? {
        children: m.children.map(H8)
      } : {}, w = {
        tag: "g",
        attributes: Ie({}, g.inner),
        children: [H8(Ie({
          tag: m.tag,
          attributes: Ie(Ie({}, m.attributes), g.path)
        }, x))]
      }, k = {
        tag: "g",
        attributes: Ie({}, g.outer),
        children: [w]
      }, E = "mask-".concat(c || _8()), _ = "clip-".concat(c || _8()), O = {
        tag: "mask",
        attributes: Ie(Ie({}, NA), {}, {
          id: E,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        }),
        children: [b, k]
      }, N = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: _
          },
          children: pGe(v)
        }, O]
      };
      return r.push(N, {
        tag: "rect",
        attributes: Ie({
          fill: "currentColor",
          "clip-path": "url(#".concat(_, ")"),
          mask: "url(#".concat(E, ")")
        }, NA)
      }), {
        children: r,
        attributes: a
      };
    };
  }
}, hGe = {
  provides: function(t) {
    var n = !1;
    Td.matchMedia && (n = Td.matchMedia("(prefers-reduced-motion: reduce)").matches), t.missingIconAbstract = function() {
      var r = [], a = {
        fill: "currentColor"
      }, s = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      r.push({
        tag: "path",
        attributes: Ie(Ie({}, a), {}, {
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        })
      });
      var l = Ie(Ie({}, s), {}, {
        attributeName: "opacity"
      }), c = {
        tag: "circle",
        attributes: Ie(Ie({}, a), {}, {
          cx: "256",
          cy: "364",
          r: "28"
        }),
        children: []
      };
      return n || c.children.push({
        tag: "animate",
        attributes: Ie(Ie({}, s), {}, {
          attributeName: "r",
          values: "28;14;28;28;14;28;"
        })
      }, {
        tag: "animate",
        attributes: Ie(Ie({}, l), {}, {
          values: "1;0;1;1;0;1;"
        })
      }), r.push(c), r.push({
        tag: "path",
        attributes: Ie(Ie({}, a), {}, {
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        }),
        children: n ? [] : [{
          tag: "animate",
          attributes: Ie(Ie({}, l), {}, {
            values: "1;0;0;0;0;1;"
          })
        }]
      }), n || r.push({
        tag: "path",
        attributes: Ie(Ie({}, a), {}, {
          opacity: "0",
          d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
        }),
        children: [{
          tag: "animate",
          attributes: Ie(Ie({}, l), {}, {
            values: "0;0;1;1;0;0;"
          })
        }]
      }), {
        tag: "g",
        attributes: {
          class: "missing"
        },
        children: r
      };
    };
  }
}, gGe = {
  hooks: function() {
    return {
      parseNodeAttributes: function(n, r) {
        var a = r.getAttribute("data-fa-symbol"), s = a === null ? !1 : a === "" ? !0 : a;
        return n.symbol = s, n;
      }
    };
  }
}, vGe = [lqe, Qqe, Zqe, eGe, tGe, cGe, dGe, fGe, mGe, hGe, gGe];
_qe(vGe, {
  mixoutsTo: Pi
});
Pi.noAuto;
var LS = Pi.config;
Pi.library;
Pi.dom;
var sZ = Pi.parse;
Pi.findIconDefinition;
Pi.toHtml;
var yGe = Pi.icon;
Pi.layer;
Pi.text;
Pi.counter;
function bGe(e) {
  return e = e - 0, e === e;
}
function lZ(e) {
  return bGe(e) ? e : (e = e.replace(/[_-]+(.)?/g, (t, n) => n ? n.toUpperCase() : ""), e.charAt(0).toLowerCase() + e.slice(1));
}
function wGe(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
var Ih = /* @__PURE__ */ new Map(), xGe = 1e3;
function SGe(e) {
  if (Ih.has(e))
    return Ih.get(e);
  const t = {};
  let n = 0;
  const r = e.length;
  for (; n < r; ) {
    const a = e.indexOf(";", n), s = a === -1 ? r : a, l = e.slice(n, s).trim();
    if (l) {
      const c = l.indexOf(":");
      if (c > 0) {
        const d = l.slice(0, c).trim(), f = l.slice(c + 1).trim();
        if (d && f) {
          const m = lZ(d);
          t[m.startsWith("webkit") ? wGe(m) : m] = f;
        }
      }
    }
    n = s + 1;
  }
  if (Ih.size === xGe) {
    const a = Ih.keys().next().value;
    a && Ih.delete(a);
  }
  return Ih.set(e, t), t;
}
function uZ(e, t, n = {}) {
  if (typeof t == "string")
    return t;
  const r = (t.children || []).map((m) => uZ(e, m)), a = t.attributes || {}, s = {};
  for (const [m, h] of Object.entries(a))
    switch (!0) {
      case m === "class": {
        s.className = h;
        break;
      }
      case m === "style": {
        s.style = SGe(String(h));
        break;
      }
      case m.startsWith("aria-"):
      case m.startsWith("data-"): {
        s[m.toLowerCase()] = h;
        break;
      }
      default:
        s[lZ(m)] = h;
    }
  const {
    style: l,
    role: c,
    "aria-label": d,
    ...f
  } = n;
  return l && (s.style = s.style ? { ...s.style, ...l } : l), c && (s.role = c), d && (s["aria-label"] = d, s["aria-hidden"] = "false"), e(t.tag, { ...f, ...s }, ...r);
}
var kGe = uZ.bind(null, jt.createElement), W8 = (e, t) => {
  const n = M.useId();
  return e || (t ? n : void 0);
}, _Ge = class {
  constructor(e = "react-fontawesome") {
    this.enabled = !1;
    let t = !1;
    try {
      t = typeof process < "u" && !1;
    } catch {
    }
    this.scope = e, this.enabled = t;
  }
  /**
   * Logs messages to the console if not in production.
   * @param args - The message and/or data to log.
   */
  log(...e) {
    this.enabled && console.log(`[${this.scope}]`, ...e);
  }
  /**
   * Logs warnings to the console if not in production.
   * @param args - The warning message and/or data to log.
   */
  warn(...e) {
    this.enabled && console.warn(`[${this.scope}]`, ...e);
  }
  /**
   * Logs errors to the console if not in production.
   * @param args - The error message and/or data to log.
   */
  error(...e) {
    this.enabled && console.error(`[${this.scope}]`, ...e);
  }
};
typeof process < "u" && process.env.FA_VERSION;
var EGe = (
  // @ts-expect-error TS2872 - Expression is always truthy - This is true when v7 of SVGCore is used, but not when v6 is used.
  // This is the point of this check - if the property exists on config, we have v7, otherwise we have v6.
  // TS is checking this against the dev dependencies which uses v7, so it reports a false error here.
  "searchPseudoElementsFullScan" in LS ? "7.0.0" : "6.0.0"
), CGe = Number.parseInt(EGe) >= 7, Qx = "fa", _c = {
  beat: "fa-beat",
  fade: "fa-fade",
  beatFade: "fa-beat-fade",
  bounce: "fa-bounce",
  shake: "fa-shake",
  spin: "fa-spin",
  spinPulse: "fa-spin-pulse",
  spinReverse: "fa-spin-reverse",
  pulse: "fa-pulse"
}, OGe = {
  left: "fa-pull-left",
  right: "fa-pull-right"
}, MGe = {
  90: "fa-rotate-90",
  180: "fa-rotate-180",
  270: "fa-rotate-270"
}, NGe = {
  "2xs": "fa-2xs",
  xs: "fa-xs",
  sm: "fa-sm",
  lg: "fa-lg",
  xl: "fa-xl",
  "2xl": "fa-2xl",
  "1x": "fa-1x",
  "2x": "fa-2x",
  "3x": "fa-3x",
  "4x": "fa-4x",
  "5x": "fa-5x",
  "6x": "fa-6x",
  "7x": "fa-7x",
  "8x": "fa-8x",
  "9x": "fa-9x",
  "10x": "fa-10x"
}, Ec = {
  border: "fa-border",
  /** @deprecated */
  fixedWidth: "fa-fw",
  flip: "fa-flip",
  flipHorizontal: "fa-flip-horizontal",
  flipVertical: "fa-flip-vertical",
  inverse: "fa-inverse",
  rotateBy: "fa-rotate-by",
  swapOpacity: "fa-swap-opacity",
  widthAuto: "fa-width-auto"
};
function AGe(e) {
  const t = LS.cssPrefix || LS.familyPrefix || Qx;
  return t === Qx ? e : e.replace(
    new RegExp(String.raw`(?<=^|\s)${Qx}-`, "g"),
    `${t}-`
  );
}
function RGe(e) {
  const {
    beat: t,
    fade: n,
    beatFade: r,
    bounce: a,
    shake: s,
    spin: l,
    spinPulse: c,
    spinReverse: d,
    pulse: f,
    fixedWidth: m,
    inverse: h,
    border: v,
    flip: g,
    size: b,
    rotation: x,
    pull: w,
    swapOpacity: k,
    rotateBy: E,
    widthAuto: _,
    className: O
  } = e, N = [];
  return O && N.push(...O.split(" ")), t && N.push(_c.beat), n && N.push(_c.fade), r && N.push(_c.beatFade), a && N.push(_c.bounce), s && N.push(_c.shake), l && N.push(_c.spin), d && N.push(_c.spinReverse), c && N.push(_c.spinPulse), f && N.push(_c.pulse), m && N.push(Ec.fixedWidth), h && N.push(Ec.inverse), v && N.push(Ec.border), g === !0 && N.push(Ec.flip), (g === "horizontal" || g === "both") && N.push(Ec.flipHorizontal), (g === "vertical" || g === "both") && N.push(Ec.flipVertical), b != null && N.push(NGe[b]), x != null && x !== 0 && N.push(MGe[x]), w != null && N.push(OGe[w]), k && N.push(Ec.swapOpacity), CGe ? (E && N.push(Ec.rotateBy), _ && N.push(Ec.widthAuto), (LS.cssPrefix || LS.familyPrefix || Qx) === Qx ? N : (
    // TODO: see if we can achieve custom prefix support without iterating
    // eslint-disable-next-line unicorn/no-array-callback-reference
    N.map(AGe)
  )) : N;
}
var jGe = (e) => typeof e == "object" && "icon" in e && !!e.icon;
function q8(e) {
  if (e)
    return jGe(e) ? e : sZ.icon(e);
}
function PGe(e) {
  return Object.keys(e);
}
var G8 = new _Ge("FontAwesomeIcon"), cZ = {
  border: !1,
  className: "",
  mask: void 0,
  maskId: void 0,
  fixedWidth: !1,
  inverse: !1,
  flip: !1,
  icon: void 0,
  listItem: !1,
  pull: void 0,
  pulse: !1,
  rotation: void 0,
  rotateBy: !1,
  size: void 0,
  spin: !1,
  spinPulse: !1,
  spinReverse: !1,
  beat: !1,
  fade: !1,
  beatFade: !1,
  bounce: !1,
  shake: !1,
  symbol: !1,
  title: "",
  titleId: void 0,
  transform: void 0,
  swapOpacity: !1,
  widthAuto: !1
}, DGe = new Set(Object.keys(cZ)), e2 = jt.forwardRef((e, t) => {
  const n = { ...cZ, ...e }, {
    icon: r,
    mask: a,
    symbol: s,
    title: l,
    titleId: c,
    maskId: d,
    transform: f
  } = n, m = W8(d, !!a), h = W8(c, !!l), v = q8(r);
  if (!v)
    return G8.error("Icon lookup is undefined", r), null;
  const g = RGe(n), b = typeof f == "string" ? sZ.transform(f) : f, x = q8(a), w = yGe(v, {
    ...g.length > 0 && { classes: g },
    ...b && { transform: b },
    ...x && { mask: x },
    symbol: s,
    title: l,
    titleId: h,
    maskId: m
  });
  if (!w)
    return G8.error("Could not find icon", v), null;
  const { abstract: k } = w, E = { ref: t };
  for (const _ of PGe(n))
    DGe.has(_) || (E[_] = n[_]);
  return kGe(k[0], E);
});
e2.displayName = "FontAwesomeIcon";
const IGe = ({
  state: e
}) => {
  const [t, n] = M.useState(
    e.getState().python_code || ""
  ), [r, a] = M.useState(!1), s = e((c) => c.python_code_error), l = (c) => {
    n(c || ""), r && e.setState({ python_code: c || "" });
  };
  return /* @__PURE__ */ ka.jsxs(
    "div",
    {
      style: {
        // minWidth: "300px",
        // maxWidth: "50%",
        height: "100%",
        display: "flex",
        flexDirection: "column"
      },
      children: [
        /* @__PURE__ */ ka.jsxs("div", { style: { flex: 1, minHeight: 0 }, children: [
          /* @__PURE__ */ ka.jsx(
            AVe,
            {
              language: "python",
              theme: "vs-dark",
              onChange: l,
              value: t
            }
          ),
          /* @__PURE__ */ ka.jsx("div", { className: "controll_icons", children: r ? /* @__PURE__ */ ka.jsx(
            e2,
            {
              className: "controll_icon",
              icon: nHe,
              style: { color: "orange" },
              onClick: async () => {
                a(!1);
              },
              title: "Pause continuous run"
            }
          ) : /* @__PURE__ */ ka.jsxs(ka.Fragment, { children: [
            /* @__PURE__ */ ka.jsx(
              e2,
              {
                className: "controll_icon",
                icon: tHe,
                onClick: async () => {
                  e.setState({ python_code: t });
                },
                title: "Run"
              }
            ),
            /* @__PURE__ */ ka.jsx(
              e2,
              {
                className: "controll_icon",
                icon: rHe,
                onClick: async () => {
                  a(!0), e.setState({ python_code: t });
                },
                title: "Continuous run"
              }
            )
          ] }) })
        ] }),
        /* @__PURE__ */ ka.jsx("code", { style: { maxHeight: "50%", overflowY: "auto" }, children: s })
      ]
    }
  );
}, $Ge = {
  show_python_editor: !0,
  index_url: "",
  store_code: !0
}, zGe = US($Ge), TGe = (e) => {
  const t = zGe(e), n = e.storage_object;
  n !== void 0 && (n.fullprops = t);
  const r = t.ser_node || t.python_code, a = t.show_python_editor;
  if (!r && !a)
    throw new Error("no Node and no editor");
  if (t.id === void 0)
    throw new Error("id must be defined");
  const s = t.id, l = M.useRef(
    t.worker
  ), c = M.useRef(t.worker === void 0);
  if (!l.current) {
    const g = VJ({
      uuid: s + "_worker",
      shared_worker: !1
    });
    l.current = new h1({
      shared_worker: !1,
      uuid: s + "_worker",
      worker: g
    }), c.current = !0;
  }
  const d = l.current, f = M.useRef(void 0);
  if (f.current === void 0) {
    let g = t.python_code || "";
    if (t.store_code) {
      const b = localStorage.getItem(s + "_python_code");
      b && (g = b);
    }
    f.current = g;
  }
  const m = M.useRef(
    null
  );
  m.current || (m.current = wUe(() => ({
    ...t,
    id: s,
    worker: d,
    python_code: f.current || ""
  })));
  const h = m.current;
  M.useEffect(() => {
    const g = async () => {
      const O = h.getState().python_code;
      O && (h.getState().store_code && localStorage.setItem(s + "_python_code", O), d.postMessage({
        cmd: "worker:evalnode",
        msg: O,
        worker_id: d.uuid,
        id: "evalnode"
      }), d.getSyncManager().stepwise_fullsync());
    }, b = d.getHookManager().add_hook("starting", async () => {
      await g(), await h.getState().onload?.();
    }), x = setInterval(async () => {
      d.ready && (await g(), await h.getState().onload?.(), clearInterval(x));
    }, 500), w = d.getHookManager().add_hook(
      "node_mounted",
      async ({ worker: O, data: N }) => {
        O._zustand?.center_node(N), await new Promise((A) => setTimeout(A, 0)), O._zustand?.center_node(N), await new Promise((A) => setTimeout(A, 10)), O._zustand?.center_node(N), await new Promise((A) => setTimeout(A, 100)), O._zustand?.center_node(N);
      }
    ), k = d.getEventManager().add_ns_event_intercept("node_added", async (O) => {
      const N = O.data.node;
      return N && (N.frontend || (N.frontend = {}), N.frontend.pos = [0, 0]), O;
    }), E = d.registerMessageHook(async (O) => {
      O.id === "evalnode" && O.original.worker_id === d.uuid && (O.error ? h.setState({ python_code_error: O.error }) : h.setState({ python_code_error: "" }));
    }), _ = h.subscribe((O, N) => {
      O.python_code !== N.python_code && g();
    });
    return () => {
      _(), b?.(), w?.(), k?.(), E?.(), clearInterval(x), c.current && d.dispose?.();
    };
  }, [s, h, d]);
  const v = /* @__PURE__ */ ka.jsx(
    m1,
    {
      worker: d,
      id: s,
      useWorkerManager: !1,
      worker_url: "dummy",
      show_library: !1,
      header: { show: !1, showmenu: !1 },
      library: { show: !1 },
      flow: {
        minimap: !1,
        allowFullScreen: !1,
        allowExpand: !1,
        showNodeSettings: !1
      }
    }
  );
  return /* @__PURE__ */ ka.jsx(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: "row",
        height: "100%",
        width: "100%"
      },
      children: t.show_python_editor ? /* @__PURE__ */ ka.jsxs(
        eHe,
        {
          vertical: !1,
          defaultSizes: [50, 50],
          onDragEnd: () => {
            d?._zustand?.center_all();
          },
          children: [
            v,
            /* @__PURE__ */ ka.jsx(IGe, { state: h })
          ]
        }
      ) : v
    }
  );
}, LGe = (e, t, { intervalMs: n = 250 } = {}) => {
  let r = !0, a = !1;
  const s = setInterval(() => {
    !r || a || e.isConnected || (a = !0, r = !1, clearInterval(s), t());
  }, n);
  return () => {
    r && (r = !1, clearInterval(s));
  };
}, FGe = () => {
  const e = /* @__PURE__ */ new Map();
  return {
    register: (t, n) => {
      const r = e.get(t);
      return r && r !== n && r.dispose(), e.set(t, n), () => {
        e.get(t) === n && e.delete(t);
      };
    },
    get: (t) => e.get(t),
    delete: (t) => {
      const n = e.get(t);
      n && (n.dispose(), e.delete(t));
    }
  };
}, BGe = () => {
  const e = globalThis;
  return e.__funcnodes_nodebuilder_mount_registry || (e.__funcnodes_nodebuilder_mount_registry = FGe()), e.__funcnodes_nodebuilder_mount_registry;
}, UGe = ({
  element: e,
  worker: t,
  createRootAndRender: n,
  registry: r = BGe(),
  intervalMs: a = 250,
  disposeWorker: s = !0
}) => {
  let l = !1, c, d = () => {
  }, f = () => {
  };
  const m = {
    worker: t,
    dispose: () => {
      if (!l) {
        l = !0;
        try {
          f();
        } catch {
        }
        try {
          c?.unmount();
        } catch {
        }
        try {
          s && (t.stop(), t.dispose());
        } catch {
        }
        try {
          d();
        } catch {
        }
      }
    }
  };
  return d = r.register(e, m), c = n(), f = LGe(e, m.dispose, {
    intervalMs: a
  }), m;
}, VGe = (e, t) => {
  t === void 0 && (t = {}), t.storage_object = t.storage_object || {};
  const { element: n, eleid: r } = typeof e == "string" ? {
    element: document.getElementById(e),
    eleid: e
  } : { element: e, eleid: e.id };
  if (!n)
    throw new Error(`Element with id '${r}' not found`);
  const a = t.worker === void 0, s = t.worker || (() => {
    const f = VJ({
      uuid: r + "_worker",
      shared_worker: !1
    });
    return new h1({
      shared_worker: !1,
      uuid: r + "_worker",
      worker: f
    });
  })(), l = /* @__PURE__ */ ka.jsx(TGe, { id: r, ...t, worker: s });
  let c;
  return {
    ...UGe({
      element: n,
      worker: s,
      disposeWorker: a,
      createRootAndRender: () => (c = SZ.createRoot(n), c.render(l), c),
      intervalMs: 250
    }),
    root: c,
    content: l,
    storage_object: t.storage_object
  };
};
window.NodeBuilder = VGe;
window.FuncnodesPyodideWorker = h1;
