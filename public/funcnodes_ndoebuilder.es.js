var jw = window;
function m9(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const o in r)
        if (o !== "default" && !(o in e)) {
          const i = Object.getOwnPropertyDescriptor(r, o);
          i && Object.defineProperty(e, o, i.get ? i : {
            enumerable: !0,
            get: () => r[o]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
(function() {
  const t = document.createElement("link").relList;
  if (t && t.supports && t.supports("modulepreload"))
    return;
  for (const o of document.querySelectorAll('link[rel="modulepreload"]'))
    r(o);
  new MutationObserver((o) => {
    for (const i of o)
      if (i.type === "childList")
        for (const s of i.addedNodes)
          s.tagName === "LINK" && s.rel === "modulepreload" && r(s);
  }).observe(document, { childList: !0, subtree: !0 });
  function n(o) {
    const i = {};
    return o.integrity && (i.integrity = o.integrity), o.referrerPolicy && (i.referrerPolicy = o.referrerPolicy), o.crossOrigin === "use-credentials" ? i.credentials = "include" : o.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i;
  }
  function r(o) {
    if (o.ep)
      return;
    o.ep = !0;
    const i = n(o);
    fetch(o.href, i);
  }
})();
function Tm(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Xv = { exports: {} }, qc = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var JE;
function g9() {
  if (JE) return qc;
  JE = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment");
  function n(r, o, i) {
    var s = null;
    if (i !== void 0 && (s = "" + i), o.key !== void 0 && (s = "" + o.key), "key" in o) {
      i = {};
      for (var u in o)
        u !== "key" && (i[u] = o[u]);
    } else i = o;
    return o = i.ref, {
      $$typeof: e,
      type: r,
      key: s,
      ref: o !== void 0 ? o : null,
      props: i
    };
  }
  return qc.Fragment = t, qc.jsx = n, qc.jsxs = n, qc;
}
var eC;
function y9() {
  return eC || (eC = 1, Xv.exports = g9()), Xv.exports;
}
var Qn = y9(), Wv = { exports: {} }, Xc = {}, Gv = { exports: {} }, Zv = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tC;
function v9() {
  return tC || (tC = 1, function(e) {
    function t(P, H) {
      var Y = P.length;
      P.push(H);
      e: for (; 0 < Y; ) {
        var q = Y - 1 >>> 1, M = P[q];
        if (0 < o(M, H))
          P[q] = H, P[Y] = M, Y = q;
        else break e;
      }
    }
    function n(P) {
      return P.length === 0 ? null : P[0];
    }
    function r(P) {
      if (P.length === 0) return null;
      var H = P[0], Y = P.pop();
      if (Y !== H) {
        P[0] = Y;
        e: for (var q = 0, M = P.length, X = M >>> 1; q < X; ) {
          var K = 2 * (q + 1) - 1, L = P[K], ee = K + 1, ae = P[ee];
          if (0 > o(L, Y))
            ee < M && 0 > o(ae, L) ? (P[q] = ae, P[ee] = Y, q = ee) : (P[q] = L, P[K] = Y, q = K);
          else if (ee < M && 0 > o(ae, Y))
            P[q] = ae, P[ee] = Y, q = ee;
          else break e;
        }
      }
      return H;
    }
    function o(P, H) {
      var Y = P.sortIndex - H.sortIndex;
      return Y !== 0 ? Y : P.id - H.id;
    }
    if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var i = performance;
      e.unstable_now = function() {
        return i.now();
      };
    } else {
      var s = Date, u = s.now();
      e.unstable_now = function() {
        return s.now() - u;
      };
    }
    var c = [], d = [], p = 1, h = null, g = 3, y = !1, b = !1, v = !1, x = !1, _ = typeof setTimeout == "function" ? setTimeout : null, O = typeof clearTimeout == "function" ? clearTimeout : null, C = typeof setImmediate < "u" ? setImmediate : null;
    function N(P) {
      for (var H = n(d); H !== null; ) {
        if (H.callback === null) r(d);
        else if (H.startTime <= P)
          r(d), H.sortIndex = H.expirationTime, t(c, H);
        else break;
        H = n(d);
      }
    }
    function R(P) {
      if (v = !1, N(P), !b)
        if (n(c) !== null)
          b = !0, z || (z = !0, U());
        else {
          var H = n(d);
          H !== null && F(R, H.startTime - P);
        }
    }
    var z = !1, j = -1, I = 5, $ = -1;
    function A() {
      return x ? !0 : !(e.unstable_now() - $ < I);
    }
    function V() {
      if (x = !1, z) {
        var P = e.unstable_now();
        $ = P;
        var H = !0;
        try {
          e: {
            b = !1, v && (v = !1, O(j), j = -1), y = !0;
            var Y = g;
            try {
              t: {
                for (N(P), h = n(c); h !== null && !(h.expirationTime > P && A()); ) {
                  var q = h.callback;
                  if (typeof q == "function") {
                    h.callback = null, g = h.priorityLevel;
                    var M = q(
                      h.expirationTime <= P
                    );
                    if (P = e.unstable_now(), typeof M == "function") {
                      h.callback = M, N(P), H = !0;
                      break t;
                    }
                    h === n(c) && r(c), N(P);
                  } else r(c);
                  h = n(c);
                }
                if (h !== null) H = !0;
                else {
                  var X = n(d);
                  X !== null && F(
                    R,
                    X.startTime - P
                  ), H = !1;
                }
              }
              break e;
            } finally {
              h = null, g = Y, y = !1;
            }
            H = void 0;
          }
        } finally {
          H ? U() : z = !1;
        }
      }
    }
    var U;
    if (typeof C == "function")
      U = function() {
        C(V);
      };
    else if (typeof MessageChannel < "u") {
      var W = new MessageChannel(), D = W.port2;
      W.port1.onmessage = V, U = function() {
        D.postMessage(null);
      };
    } else
      U = function() {
        _(V, 0);
      };
    function F(P, H) {
      j = _(function() {
        P(e.unstable_now());
      }, H);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(P) {
      P.callback = null;
    }, e.unstable_forceFrameRate = function(P) {
      0 > P || 125 < P ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : I = 0 < P ? Math.floor(1e3 / P) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return g;
    }, e.unstable_next = function(P) {
      switch (g) {
        case 1:
        case 2:
        case 3:
          var H = 3;
          break;
        default:
          H = g;
      }
      var Y = g;
      g = H;
      try {
        return P();
      } finally {
        g = Y;
      }
    }, e.unstable_requestPaint = function() {
      x = !0;
    }, e.unstable_runWithPriority = function(P, H) {
      switch (P) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          P = 3;
      }
      var Y = g;
      g = P;
      try {
        return H();
      } finally {
        g = Y;
      }
    }, e.unstable_scheduleCallback = function(P, H, Y) {
      var q = e.unstable_now();
      switch (typeof Y == "object" && Y !== null ? (Y = Y.delay, Y = typeof Y == "number" && 0 < Y ? q + Y : q) : Y = q, P) {
        case 1:
          var M = -1;
          break;
        case 2:
          M = 250;
          break;
        case 5:
          M = 1073741823;
          break;
        case 4:
          M = 1e4;
          break;
        default:
          M = 5e3;
      }
      return M = Y + M, P = {
        id: p++,
        callback: H,
        priorityLevel: P,
        startTime: Y,
        expirationTime: M,
        sortIndex: -1
      }, Y > q ? (P.sortIndex = Y, t(d, P), n(c) === null && P === n(d) && (v ? (O(j), j = -1) : v = !0, F(R, Y - q))) : (P.sortIndex = M, t(c, P), b || y || (b = !0, z || (z = !0, U()))), P;
    }, e.unstable_shouldYield = A, e.unstable_wrapCallback = function(P) {
      var H = g;
      return function() {
        var Y = g;
        g = H;
        try {
          return P.apply(this, arguments);
        } finally {
          g = Y;
        }
      };
    };
  }(Zv)), Zv;
}
var nC;
function b9() {
  return nC || (nC = 1, Gv.exports = v9()), Gv.exports;
}
var Kv = { exports: {} }, We = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rC;
function w9() {
  if (rC) return We;
  rC = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), i = Symbol.for("react.consumer"), s = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), h = Symbol.iterator;
  function g(M) {
    return M === null || typeof M != "object" ? null : (M = h && M[h] || M["@@iterator"], typeof M == "function" ? M : null);
  }
  var y = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, b = Object.assign, v = {};
  function x(M, X, K) {
    this.props = M, this.context = X, this.refs = v, this.updater = K || y;
  }
  x.prototype.isReactComponent = {}, x.prototype.setState = function(M, X) {
    if (typeof M != "object" && typeof M != "function" && M != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, M, X, "setState");
  }, x.prototype.forceUpdate = function(M) {
    this.updater.enqueueForceUpdate(this, M, "forceUpdate");
  };
  function _() {
  }
  _.prototype = x.prototype;
  function O(M, X, K) {
    this.props = M, this.context = X, this.refs = v, this.updater = K || y;
  }
  var C = O.prototype = new _();
  C.constructor = O, b(C, x.prototype), C.isPureReactComponent = !0;
  var N = Array.isArray, R = { H: null, A: null, T: null, S: null, V: null }, z = Object.prototype.hasOwnProperty;
  function j(M, X, K, L, ee, ae) {
    return K = ae.ref, {
      $$typeof: e,
      type: M,
      key: X,
      ref: K !== void 0 ? K : null,
      props: ae
    };
  }
  function I(M, X) {
    return j(
      M.type,
      X,
      void 0,
      void 0,
      void 0,
      M.props
    );
  }
  function $(M) {
    return typeof M == "object" && M !== null && M.$$typeof === e;
  }
  function A(M) {
    var X = { "=": "=0", ":": "=2" };
    return "$" + M.replace(/[=:]/g, function(K) {
      return X[K];
    });
  }
  var V = /\/+/g;
  function U(M, X) {
    return typeof M == "object" && M !== null && M.key != null ? A("" + M.key) : X.toString(36);
  }
  function W() {
  }
  function D(M) {
    switch (M.status) {
      case "fulfilled":
        return M.value;
      case "rejected":
        throw M.reason;
      default:
        switch (typeof M.status == "string" ? M.then(W, W) : (M.status = "pending", M.then(
          function(X) {
            M.status === "pending" && (M.status = "fulfilled", M.value = X);
          },
          function(X) {
            M.status === "pending" && (M.status = "rejected", M.reason = X);
          }
        )), M.status) {
          case "fulfilled":
            return M.value;
          case "rejected":
            throw M.reason;
        }
    }
    throw M;
  }
  function F(M, X, K, L, ee) {
    var ae = typeof M;
    (ae === "undefined" || ae === "boolean") && (M = null);
    var le = !1;
    if (M === null) le = !0;
    else
      switch (ae) {
        case "bigint":
        case "string":
        case "number":
          le = !0;
          break;
        case "object":
          switch (M.$$typeof) {
            case e:
            case t:
              le = !0;
              break;
            case p:
              return le = M._init, F(
                le(M._payload),
                X,
                K,
                L,
                ee
              );
          }
      }
    if (le)
      return ee = ee(M), le = L === "" ? "." + U(M, 0) : L, N(ee) ? (K = "", le != null && (K = le.replace(V, "$&/") + "/"), F(ee, X, K, "", function(he) {
        return he;
      })) : ee != null && ($(ee) && (ee = I(
        ee,
        K + (ee.key == null || M && M.key === ee.key ? "" : ("" + ee.key).replace(
          V,
          "$&/"
        ) + "/") + le
      )), X.push(ee)), 1;
    le = 0;
    var me = L === "" ? "." : L + ":";
    if (N(M))
      for (var se = 0; se < M.length; se++)
        L = M[se], ae = me + U(L, se), le += F(
          L,
          X,
          K,
          ae,
          ee
        );
    else if (se = g(M), typeof se == "function")
      for (M = se.call(M), se = 0; !(L = M.next()).done; )
        L = L.value, ae = me + U(L, se++), le += F(
          L,
          X,
          K,
          ae,
          ee
        );
    else if (ae === "object") {
      if (typeof M.then == "function")
        return F(
          D(M),
          X,
          K,
          L,
          ee
        );
      throw X = String(M), Error(
        "Objects are not valid as a React child (found: " + (X === "[object Object]" ? "object with keys {" + Object.keys(M).join(", ") + "}" : X) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return le;
  }
  function P(M, X, K) {
    if (M == null) return M;
    var L = [], ee = 0;
    return F(M, L, "", "", function(ae) {
      return X.call(K, ae, ee++);
    }), L;
  }
  function H(M) {
    if (M._status === -1) {
      var X = M._result;
      X = X(), X.then(
        function(K) {
          (M._status === 0 || M._status === -1) && (M._status = 1, M._result = K);
        },
        function(K) {
          (M._status === 0 || M._status === -1) && (M._status = 2, M._result = K);
        }
      ), M._status === -1 && (M._status = 0, M._result = X);
    }
    if (M._status === 1) return M._result.default;
    throw M._result;
  }
  var Y = typeof reportError == "function" ? reportError : function(M) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var X = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof M == "object" && M !== null && typeof M.message == "string" ? String(M.message) : String(M),
        error: M
      });
      if (!window.dispatchEvent(X)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", M);
      return;
    }
    console.error(M);
  };
  function q() {
  }
  return We.Children = {
    map: P,
    forEach: function(M, X, K) {
      P(
        M,
        function() {
          X.apply(this, arguments);
        },
        K
      );
    },
    count: function(M) {
      var X = 0;
      return P(M, function() {
        X++;
      }), X;
    },
    toArray: function(M) {
      return P(M, function(X) {
        return X;
      }) || [];
    },
    only: function(M) {
      if (!$(M))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return M;
    }
  }, We.Component = x, We.Fragment = n, We.Profiler = o, We.PureComponent = O, We.StrictMode = r, We.Suspense = c, We.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = R, We.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(M) {
      return R.H.useMemoCache(M);
    }
  }, We.cache = function(M) {
    return function() {
      return M.apply(null, arguments);
    };
  }, We.cloneElement = function(M, X, K) {
    if (M == null)
      throw Error(
        "The argument must be a React element, but you passed " + M + "."
      );
    var L = b({}, M.props), ee = M.key, ae = void 0;
    if (X != null)
      for (le in X.ref !== void 0 && (ae = void 0), X.key !== void 0 && (ee = "" + X.key), X)
        !z.call(X, le) || le === "key" || le === "__self" || le === "__source" || le === "ref" && X.ref === void 0 || (L[le] = X[le]);
    var le = arguments.length - 2;
    if (le === 1) L.children = K;
    else if (1 < le) {
      for (var me = Array(le), se = 0; se < le; se++)
        me[se] = arguments[se + 2];
      L.children = me;
    }
    return j(M.type, ee, void 0, void 0, ae, L);
  }, We.createContext = function(M) {
    return M = {
      $$typeof: s,
      _currentValue: M,
      _currentValue2: M,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, M.Provider = M, M.Consumer = {
      $$typeof: i,
      _context: M
    }, M;
  }, We.createElement = function(M, X, K) {
    var L, ee = {}, ae = null;
    if (X != null)
      for (L in X.key !== void 0 && (ae = "" + X.key), X)
        z.call(X, L) && L !== "key" && L !== "__self" && L !== "__source" && (ee[L] = X[L]);
    var le = arguments.length - 2;
    if (le === 1) ee.children = K;
    else if (1 < le) {
      for (var me = Array(le), se = 0; se < le; se++)
        me[se] = arguments[se + 2];
      ee.children = me;
    }
    if (M && M.defaultProps)
      for (L in le = M.defaultProps, le)
        ee[L] === void 0 && (ee[L] = le[L]);
    return j(M, ae, void 0, void 0, null, ee);
  }, We.createRef = function() {
    return { current: null };
  }, We.forwardRef = function(M) {
    return { $$typeof: u, render: M };
  }, We.isValidElement = $, We.lazy = function(M) {
    return {
      $$typeof: p,
      _payload: { _status: -1, _result: M },
      _init: H
    };
  }, We.memo = function(M, X) {
    return {
      $$typeof: d,
      type: M,
      compare: X === void 0 ? null : X
    };
  }, We.startTransition = function(M) {
    var X = R.T, K = {};
    R.T = K;
    try {
      var L = M(), ee = R.S;
      ee !== null && ee(K, L), typeof L == "object" && L !== null && typeof L.then == "function" && L.then(q, Y);
    } catch (ae) {
      Y(ae);
    } finally {
      R.T = X;
    }
  }, We.unstable_useCacheRefresh = function() {
    return R.H.useCacheRefresh();
  }, We.use = function(M) {
    return R.H.use(M);
  }, We.useActionState = function(M, X, K) {
    return R.H.useActionState(M, X, K);
  }, We.useCallback = function(M, X) {
    return R.H.useCallback(M, X);
  }, We.useContext = function(M) {
    return R.H.useContext(M);
  }, We.useDebugValue = function() {
  }, We.useDeferredValue = function(M, X) {
    return R.H.useDeferredValue(M, X);
  }, We.useEffect = function(M, X, K) {
    var L = R.H;
    if (typeof K == "function")
      throw Error(
        "useEffect CRUD overload is not enabled in this build of React."
      );
    return L.useEffect(M, X);
  }, We.useId = function() {
    return R.H.useId();
  }, We.useImperativeHandle = function(M, X, K) {
    return R.H.useImperativeHandle(M, X, K);
  }, We.useInsertionEffect = function(M, X) {
    return R.H.useInsertionEffect(M, X);
  }, We.useLayoutEffect = function(M, X) {
    return R.H.useLayoutEffect(M, X);
  }, We.useMemo = function(M, X) {
    return R.H.useMemo(M, X);
  }, We.useOptimistic = function(M, X) {
    return R.H.useOptimistic(M, X);
  }, We.useReducer = function(M, X, K) {
    return R.H.useReducer(M, X, K);
  }, We.useRef = function(M) {
    return R.H.useRef(M);
  }, We.useState = function(M) {
    return R.H.useState(M);
  }, We.useSyncExternalStore = function(M, X, K) {
    return R.H.useSyncExternalStore(
      M,
      X,
      K
    );
  }, We.useTransition = function() {
    return R.H.useTransition();
  }, We.version = "19.1.0", We;
}
var oC;
function nf() {
  return oC || (oC = 1, Kv.exports = w9()), Kv.exports;
}
var Qv = { exports: {} }, In = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iC;
function x9() {
  if (iC) return In;
  iC = 1;
  var e = nf();
  function t(c) {
    var d = "https://react.dev/errors/" + c;
    if (1 < arguments.length) {
      d += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var p = 2; p < arguments.length; p++)
        d += "&args[]=" + encodeURIComponent(arguments[p]);
    }
    return "Minified React error #" + c + "; visit " + d + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function n() {
  }
  var r = {
    d: {
      f: n,
      r: function() {
        throw Error(t(522));
      },
      D: n,
      C: n,
      L: n,
      m: n,
      X: n,
      S: n,
      M: n
    },
    p: 0,
    findDOMNode: null
  }, o = Symbol.for("react.portal");
  function i(c, d, p) {
    var h = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: o,
      key: h == null ? null : "" + h,
      children: c,
      containerInfo: d,
      implementation: p
    };
  }
  var s = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function u(c, d) {
    if (c === "font") return "";
    if (typeof d == "string")
      return d === "use-credentials" ? d : "";
  }
  return In.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r, In.createPortal = function(c, d) {
    var p = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!d || d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11)
      throw Error(t(299));
    return i(c, d, null, p);
  }, In.flushSync = function(c) {
    var d = s.T, p = r.p;
    try {
      if (s.T = null, r.p = 2, c) return c();
    } finally {
      s.T = d, r.p = p, r.d.f();
    }
  }, In.preconnect = function(c, d) {
    typeof c == "string" && (d ? (d = d.crossOrigin, d = typeof d == "string" ? d === "use-credentials" ? d : "" : void 0) : d = null, r.d.C(c, d));
  }, In.prefetchDNS = function(c) {
    typeof c == "string" && r.d.D(c);
  }, In.preinit = function(c, d) {
    if (typeof c == "string" && d && typeof d.as == "string") {
      var p = d.as, h = u(p, d.crossOrigin), g = typeof d.integrity == "string" ? d.integrity : void 0, y = typeof d.fetchPriority == "string" ? d.fetchPriority : void 0;
      p === "style" ? r.d.S(
        c,
        typeof d.precedence == "string" ? d.precedence : void 0,
        {
          crossOrigin: h,
          integrity: g,
          fetchPriority: y
        }
      ) : p === "script" && r.d.X(c, {
        crossOrigin: h,
        integrity: g,
        fetchPriority: y,
        nonce: typeof d.nonce == "string" ? d.nonce : void 0
      });
    }
  }, In.preinitModule = function(c, d) {
    if (typeof c == "string")
      if (typeof d == "object" && d !== null) {
        if (d.as == null || d.as === "script") {
          var p = u(
            d.as,
            d.crossOrigin
          );
          r.d.M(c, {
            crossOrigin: p,
            integrity: typeof d.integrity == "string" ? d.integrity : void 0,
            nonce: typeof d.nonce == "string" ? d.nonce : void 0
          });
        }
      } else d == null && r.d.M(c);
  }, In.preload = function(c, d) {
    if (typeof c == "string" && typeof d == "object" && d !== null && typeof d.as == "string") {
      var p = d.as, h = u(p, d.crossOrigin);
      r.d.L(c, p, {
        crossOrigin: h,
        integrity: typeof d.integrity == "string" ? d.integrity : void 0,
        nonce: typeof d.nonce == "string" ? d.nonce : void 0,
        type: typeof d.type == "string" ? d.type : void 0,
        fetchPriority: typeof d.fetchPriority == "string" ? d.fetchPriority : void 0,
        referrerPolicy: typeof d.referrerPolicy == "string" ? d.referrerPolicy : void 0,
        imageSrcSet: typeof d.imageSrcSet == "string" ? d.imageSrcSet : void 0,
        imageSizes: typeof d.imageSizes == "string" ? d.imageSizes : void 0,
        media: typeof d.media == "string" ? d.media : void 0
      });
    }
  }, In.preloadModule = function(c, d) {
    if (typeof c == "string")
      if (d) {
        var p = u(d.as, d.crossOrigin);
        r.d.m(c, {
          as: typeof d.as == "string" && d.as !== "script" ? d.as : void 0,
          crossOrigin: p,
          integrity: typeof d.integrity == "string" ? d.integrity : void 0
        });
      } else r.d.m(c);
  }, In.requestFormReset = function(c) {
    r.d.r(c);
  }, In.unstable_batchedUpdates = function(c, d) {
    return c(d);
  }, In.useFormState = function(c, d, p) {
    return s.H.useFormState(c, d, p);
  }, In.useFormStatus = function() {
    return s.H.useHostTransitionStatus();
  }, In.version = "19.1.0", In;
}
var aC;
function lN() {
  if (aC) return Qv.exports;
  aC = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), Qv.exports = x9(), Qv.exports;
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sC;
function S9() {
  if (sC) return Xc;
  sC = 1;
  var e = b9(), t = nf(), n = lN();
  function r(a) {
    var l = "https://react.dev/errors/" + a;
    if (1 < arguments.length) {
      l += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var f = 2; f < arguments.length; f++)
        l += "&args[]=" + encodeURIComponent(arguments[f]);
    }
    return "Minified React error #" + a + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function o(a) {
    return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11);
  }
  function i(a) {
    var l = a, f = a;
    if (a.alternate) for (; l.return; ) l = l.return;
    else {
      a = l;
      do
        l = a, (l.flags & 4098) !== 0 && (f = l.return), a = l.return;
      while (a);
    }
    return l.tag === 3 ? f : null;
  }
  function s(a) {
    if (a.tag === 13) {
      var l = a.memoizedState;
      if (l === null && (a = a.alternate, a !== null && (l = a.memoizedState)), l !== null) return l.dehydrated;
    }
    return null;
  }
  function u(a) {
    if (i(a) !== a)
      throw Error(r(188));
  }
  function c(a) {
    var l = a.alternate;
    if (!l) {
      if (l = i(a), l === null) throw Error(r(188));
      return l !== a ? null : a;
    }
    for (var f = a, m = l; ; ) {
      var w = f.return;
      if (w === null) break;
      var k = w.alternate;
      if (k === null) {
        if (m = w.return, m !== null) {
          f = m;
          continue;
        }
        break;
      }
      if (w.child === k.child) {
        for (k = w.child; k; ) {
          if (k === f) return u(w), a;
          if (k === m) return u(w), l;
          k = k.sibling;
        }
        throw Error(r(188));
      }
      if (f.return !== m.return) f = w, m = k;
      else {
        for (var T = !1, B = w.child; B; ) {
          if (B === f) {
            T = !0, f = w, m = k;
            break;
          }
          if (B === m) {
            T = !0, m = w, f = k;
            break;
          }
          B = B.sibling;
        }
        if (!T) {
          for (B = k.child; B; ) {
            if (B === f) {
              T = !0, f = k, m = w;
              break;
            }
            if (B === m) {
              T = !0, m = k, f = w;
              break;
            }
            B = B.sibling;
          }
          if (!T) throw Error(r(189));
        }
      }
      if (f.alternate !== m) throw Error(r(190));
    }
    if (f.tag !== 3) throw Error(r(188));
    return f.stateNode.current === f ? a : l;
  }
  function d(a) {
    var l = a.tag;
    if (l === 5 || l === 26 || l === 27 || l === 6) return a;
    for (a = a.child; a !== null; ) {
      if (l = d(a), l !== null) return l;
      a = a.sibling;
    }
    return null;
  }
  var p = Object.assign, h = Symbol.for("react.element"), g = Symbol.for("react.transitional.element"), y = Symbol.for("react.portal"), b = Symbol.for("react.fragment"), v = Symbol.for("react.strict_mode"), x = Symbol.for("react.profiler"), _ = Symbol.for("react.provider"), O = Symbol.for("react.consumer"), C = Symbol.for("react.context"), N = Symbol.for("react.forward_ref"), R = Symbol.for("react.suspense"), z = Symbol.for("react.suspense_list"), j = Symbol.for("react.memo"), I = Symbol.for("react.lazy"), $ = Symbol.for("react.activity"), A = Symbol.for("react.memo_cache_sentinel"), V = Symbol.iterator;
  function U(a) {
    return a === null || typeof a != "object" ? null : (a = V && a[V] || a["@@iterator"], typeof a == "function" ? a : null);
  }
  var W = Symbol.for("react.client.reference");
  function D(a) {
    if (a == null) return null;
    if (typeof a == "function")
      return a.$$typeof === W ? null : a.displayName || a.name || null;
    if (typeof a == "string") return a;
    switch (a) {
      case b:
        return "Fragment";
      case x:
        return "Profiler";
      case v:
        return "StrictMode";
      case R:
        return "Suspense";
      case z:
        return "SuspenseList";
      case $:
        return "Activity";
    }
    if (typeof a == "object")
      switch (a.$$typeof) {
        case y:
          return "Portal";
        case C:
          return (a.displayName || "Context") + ".Provider";
        case O:
          return (a._context.displayName || "Context") + ".Consumer";
        case N:
          var l = a.render;
          return a = a.displayName, a || (a = l.displayName || l.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"), a;
        case j:
          return l = a.displayName || null, l !== null ? l : D(a.type) || "Memo";
        case I:
          l = a._payload, a = a._init;
          try {
            return D(a(l));
          } catch {
          }
      }
    return null;
  }
  var F = Array.isArray, P = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, H = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Y = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, q = [], M = -1;
  function X(a) {
    return { current: a };
  }
  function K(a) {
    0 > M || (a.current = q[M], q[M] = null, M--);
  }
  function L(a, l) {
    M++, q[M] = a.current, a.current = l;
  }
  var ee = X(null), ae = X(null), le = X(null), me = X(null);
  function se(a, l) {
    switch (L(le, l), L(ae, a), L(ee, null), l.nodeType) {
      case 9:
      case 11:
        a = (a = l.documentElement) && (a = a.namespaceURI) ? OE(a) : 0;
        break;
      default:
        if (a = l.tagName, l = l.namespaceURI)
          l = OE(l), a = AE(l, a);
        else
          switch (a) {
            case "svg":
              a = 1;
              break;
            case "math":
              a = 2;
              break;
            default:
              a = 0;
          }
    }
    K(ee), L(ee, a);
  }
  function he() {
    K(ee), K(ae), K(le);
  }
  function _e(a) {
    a.memoizedState !== null && L(me, a);
    var l = ee.current, f = AE(l, a.type);
    l !== f && (L(ae, a), L(ee, f));
  }
  function Se(a) {
    ae.current === a && (K(ee), K(ae)), me.current === a && (K(me), Fc._currentValue = Y);
  }
  var Ee = Object.prototype.hasOwnProperty, Ie = e.unstable_scheduleCallback, $e = e.unstable_cancelCallback, ct = e.unstable_shouldYield, $t = e.unstable_requestPaint, ft = e.unstable_now, br = e.unstable_getCurrentPriorityLevel, on = e.unstable_ImmediatePriority, vn = e.unstable_UserBlockingPriority, De = e.unstable_NormalPriority, qr = e.unstable_LowPriority, Xr = e.unstable_IdlePriority, qn = e.log, Wr = e.unstable_setDisableYieldValue, ce = null, ye = null;
  function Ae(a) {
    if (typeof qn == "function" && Wr(a), ye && typeof ye.setStrictMode == "function")
      try {
        ye.setStrictMode(ce, a);
      } catch {
      }
  }
  var Ve = Math.clz32 ? Math.clz32 : or, ut = Math.log, bn = Math.LN2;
  function or(a) {
    return a >>>= 0, a === 0 ? 32 : 31 - (ut(a) / bn | 0) | 0;
  }
  var Xt = 256, ir = 4194304;
  function kn(a) {
    var l = a & 42;
    if (l !== 0) return l;
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194048;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return a & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return a;
    }
  }
  function Wt(a, l, f) {
    var m = a.pendingLanes;
    if (m === 0) return 0;
    var w = 0, k = a.suspendedLanes, T = a.pingedLanes;
    a = a.warmLanes;
    var B = m & 134217727;
    return B !== 0 ? (m = B & ~k, m !== 0 ? w = kn(m) : (T &= B, T !== 0 ? w = kn(T) : f || (f = B & ~a, f !== 0 && (w = kn(f))))) : (B = m & ~k, B !== 0 ? w = kn(B) : T !== 0 ? w = kn(T) : f || (f = m & ~a, f !== 0 && (w = kn(f)))), w === 0 ? 0 : l !== 0 && l !== w && (l & k) === 0 && (k = w & -w, f = l & -l, k >= f || k === 32 && (f & 4194048) !== 0) ? l : w;
  }
  function Dn(a, l) {
    return (a.pendingLanes & ~(a.suspendedLanes & ~a.pingedLanes) & l) === 0;
  }
  function Xn(a, l) {
    switch (a) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return l + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function fs() {
    var a = Xt;
    return Xt <<= 1, (Xt & 4194048) === 0 && (Xt = 256), a;
  }
  function da() {
    var a = ir;
    return ir <<= 1, (ir & 62914560) === 0 && (ir = 4194304), a;
  }
  function wr(a) {
    for (var l = [], f = 0; 31 > f; f++) l.push(a);
    return l;
  }
  function En(a, l) {
    a.pendingLanes |= l, l !== 268435456 && (a.suspendedLanes = 0, a.pingedLanes = 0, a.warmLanes = 0);
  }
  function mo(a, l, f, m, w, k) {
    var T = a.pendingLanes;
    a.pendingLanes = f, a.suspendedLanes = 0, a.pingedLanes = 0, a.warmLanes = 0, a.expiredLanes &= f, a.entangledLanes &= f, a.errorRecoveryDisabledLanes &= f, a.shellSuspendCounter = 0;
    var B = a.entanglements, G = a.expirationTimes, ne = a.hiddenUpdates;
    for (f = T & ~f; 0 < f; ) {
      var fe = 31 - Ve(f), ge = 1 << fe;
      B[fe] = 0, G[fe] = -1;
      var re = ne[fe];
      if (re !== null)
        for (ne[fe] = null, fe = 0; fe < re.length; fe++) {
          var oe = re[fe];
          oe !== null && (oe.lane &= -536870913);
        }
      f &= ~ge;
    }
    m !== 0 && Lo(a, m, 0), k !== 0 && w === 0 && a.tag !== 0 && (a.suspendedLanes |= k & ~(T & ~l));
  }
  function Lo(a, l, f) {
    a.pendingLanes |= l, a.suspendedLanes &= ~l;
    var m = 31 - Ve(l);
    a.entangledLanes |= l, a.entanglements[m] = a.entanglements[m] | 1073741824 | f & 4194090;
  }
  function xr(a, l) {
    var f = a.entangledLanes |= l;
    for (a = a.entanglements; f; ) {
      var m = 31 - Ve(f), w = 1 << m;
      w & l | a[m] & l && (a[m] |= l), f &= ~w;
    }
  }
  function ps(a) {
    switch (a) {
      case 2:
        a = 1;
        break;
      case 8:
        a = 4;
        break;
      case 32:
        a = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        a = 128;
        break;
      case 268435456:
        a = 134217728;
        break;
      default:
        a = 0;
    }
    return a;
  }
  function Io(a) {
    return a &= -a, 2 < a ? 8 < a ? (a & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function Vo() {
    var a = H.p;
    return a !== 0 ? a : (a = window.event, a === void 0 ? 32 : XE(a.type));
  }
  function fl(a, l) {
    var f = H.p;
    try {
      return H.p = a, l();
    } finally {
      H.p = f;
    }
  }
  var Sr = Math.random().toString(36).slice(2), an = "__reactFiber$" + Sr, wn = "__reactProps$" + Sr, go = "__reactContainer$" + Sr, fa = "__reactEvents$" + Sr, pa = "__reactListeners$" + Sr, Bo = "__reactHandles$" + Sr, pl = "__reactResources$" + Sr, Pn = "__reactMarker$" + Sr;
  function hs(a) {
    delete a[an], delete a[wn], delete a[fa], delete a[pa], delete a[Bo];
  }
  function Cn(a) {
    var l = a[an];
    if (l) return l;
    for (var f = a.parentNode; f; ) {
      if (l = f[go] || f[an]) {
        if (f = l.alternate, l.child !== null || f !== null && f.child !== null)
          for (a = jE(a); a !== null; ) {
            if (f = a[an]) return f;
            a = jE(a);
          }
        return l;
      }
      a = f, f = a.parentNode;
    }
    return null;
  }
  function Gr(a) {
    if (a = a[an] || a[go]) {
      var l = a.tag;
      if (l === 5 || l === 6 || l === 13 || l === 26 || l === 27 || l === 3)
        return a;
    }
    return null;
  }
  function wi(a) {
    var l = a.tag;
    if (l === 5 || l === 26 || l === 27 || l === 6) return a.stateNode;
    throw Error(r(33));
  }
  function _r(a) {
    var l = a[pl];
    return l || (l = a[pl] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), l;
  }
  function Lt(a) {
    a[Pn] = !0;
  }
  var ms = /* @__PURE__ */ new Set(), gs = {};
  function Zr(a, l) {
    ar(a, l), ar(a + "Capture", l);
  }
  function ar(a, l) {
    for (gs[a] = l, a = 0; a < l.length; a++)
      ms.add(l[a]);
  }
  var ys = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), hl = {}, Q = {};
  function ie(a) {
    return Ee.call(Q, a) ? !0 : Ee.call(hl, a) ? !1 : ys.test(a) ? Q[a] = !0 : (hl[a] = !0, !1);
  }
  function xe(a, l, f) {
    if (ie(l))
      if (f === null) a.removeAttribute(l);
      else {
        switch (typeof f) {
          case "undefined":
          case "function":
          case "symbol":
            a.removeAttribute(l);
            return;
          case "boolean":
            var m = l.toLowerCase().slice(0, 5);
            if (m !== "data-" && m !== "aria-") {
              a.removeAttribute(l);
              return;
            }
        }
        a.setAttribute(l, "" + f);
      }
  }
  function Ce(a, l, f) {
    if (f === null) a.removeAttribute(l);
    else {
      switch (typeof f) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          a.removeAttribute(l);
          return;
      }
      a.setAttribute(l, "" + f);
    }
  }
  function Je(a, l, f, m) {
    if (m === null) a.removeAttribute(f);
    else {
      switch (typeof m) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          a.removeAttribute(f);
          return;
      }
      a.setAttributeNS(l, f, "" + m);
    }
  }
  var Ye, St;
  function bt(a) {
    if (Ye === void 0)
      try {
        throw Error();
      } catch (f) {
        var l = f.stack.trim().match(/\n( *(at )?)/);
        Ye = l && l[1] || "", St = -1 < f.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < f.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + Ye + a + St;
  }
  var On = !1;
  function Tt(a, l) {
    if (!a || On) return "";
    On = !0;
    var f = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var m = {
        DetermineComponentFrameRoot: function() {
          try {
            if (l) {
              var ge = function() {
                throw Error();
              };
              if (Object.defineProperty(ge.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(ge, []);
                } catch (oe) {
                  var re = oe;
                }
                Reflect.construct(a, [], ge);
              } else {
                try {
                  ge.call();
                } catch (oe) {
                  re = oe;
                }
                a.call(ge.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (oe) {
                re = oe;
              }
              (ge = a()) && typeof ge.catch == "function" && ge.catch(function() {
              });
            }
          } catch (oe) {
            if (oe && re && typeof oe.stack == "string")
              return [oe.stack, re.stack];
          }
          return [null, null];
        }
      };
      m.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var w = Object.getOwnPropertyDescriptor(
        m.DetermineComponentFrameRoot,
        "name"
      );
      w && w.configurable && Object.defineProperty(
        m.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var k = m.DetermineComponentFrameRoot(), T = k[0], B = k[1];
      if (T && B) {
        var G = T.split(`
`), ne = B.split(`
`);
        for (w = m = 0; m < G.length && !G[m].includes("DetermineComponentFrameRoot"); )
          m++;
        for (; w < ne.length && !ne[w].includes(
          "DetermineComponentFrameRoot"
        ); )
          w++;
        if (m === G.length || w === ne.length)
          for (m = G.length - 1, w = ne.length - 1; 1 <= m && 0 <= w && G[m] !== ne[w]; )
            w--;
        for (; 1 <= m && 0 <= w; m--, w--)
          if (G[m] !== ne[w]) {
            if (m !== 1 || w !== 1)
              do
                if (m--, w--, 0 > w || G[m] !== ne[w]) {
                  var fe = `
` + G[m].replace(" at new ", " at ");
                  return a.displayName && fe.includes("<anonymous>") && (fe = fe.replace("<anonymous>", a.displayName)), fe;
                }
              while (1 <= m && 0 <= w);
            break;
          }
      }
    } finally {
      On = !1, Error.prepareStackTrace = f;
    }
    return (f = a ? a.displayName || a.name : "") ? bt(f) : "";
  }
  function Yt(a) {
    switch (a.tag) {
      case 26:
      case 27:
      case 5:
        return bt(a.type);
      case 16:
        return bt("Lazy");
      case 13:
        return bt("Suspense");
      case 19:
        return bt("SuspenseList");
      case 0:
      case 15:
        return Tt(a.type, !1);
      case 11:
        return Tt(a.type.render, !1);
      case 1:
        return Tt(a.type, !0);
      case 31:
        return bt("Activity");
      default:
        return "";
    }
  }
  function Wn(a) {
    try {
      var l = "";
      do
        l += Yt(a), a = a.return;
      while (a);
      return l;
    } catch (f) {
      return `
Error generating stack: ` + f.message + `
` + f.stack;
    }
  }
  function It(a) {
    switch (typeof a) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function sn(a) {
    var l = a.type;
    return (a = a.nodeName) && a.toLowerCase() === "input" && (l === "checkbox" || l === "radio");
  }
  function Gn(a) {
    var l = sn(a) ? "checked" : "value", f = Object.getOwnPropertyDescriptor(
      a.constructor.prototype,
      l
    ), m = "" + a[l];
    if (!a.hasOwnProperty(l) && typeof f < "u" && typeof f.get == "function" && typeof f.set == "function") {
      var w = f.get, k = f.set;
      return Object.defineProperty(a, l, {
        configurable: !0,
        get: function() {
          return w.call(this);
        },
        set: function(T) {
          m = "" + T, k.call(this, T);
        }
      }), Object.defineProperty(a, l, {
        enumerable: f.enumerable
      }), {
        getValue: function() {
          return m;
        },
        setValue: function(T) {
          m = "" + T;
        },
        stopTracking: function() {
          a._valueTracker = null, delete a[l];
        }
      };
    }
  }
  function kr(a) {
    a._valueTracker || (a._valueTracker = Gn(a));
  }
  function xi(a) {
    if (!a) return !1;
    var l = a._valueTracker;
    if (!l) return !0;
    var f = l.getValue(), m = "";
    return a && (m = sn(a) ? a.checked ? "true" : "false" : a.value), a = m, a !== f ? (l.setValue(a), !0) : !1;
  }
  function Zn(a) {
    if (a = a || (typeof document < "u" ? document : void 0), typeof a > "u") return null;
    try {
      return a.activeElement || a.body;
    } catch {
      return a.body;
    }
  }
  var Si = /[\n"\\]/g;
  function An(a) {
    return a.replace(
      Si,
      function(l) {
        return "\\" + l.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function ha(a, l, f, m, w, k, T, B) {
    a.name = "", T != null && typeof T != "function" && typeof T != "symbol" && typeof T != "boolean" ? a.type = T : a.removeAttribute("type"), l != null ? T === "number" ? (l === 0 && a.value === "" || a.value != l) && (a.value = "" + It(l)) : a.value !== "" + It(l) && (a.value = "" + It(l)) : T !== "submit" && T !== "reset" || a.removeAttribute("value"), l != null ? pt(a, T, It(l)) : f != null ? pt(a, T, It(f)) : m != null && a.removeAttribute("value"), w == null && k != null && (a.defaultChecked = !!k), w != null && (a.checked = w && typeof w != "function" && typeof w != "symbol"), B != null && typeof B != "function" && typeof B != "symbol" && typeof B != "boolean" ? a.name = "" + It(B) : a.removeAttribute("name");
  }
  function zf(a, l, f, m, w, k, T, B) {
    if (k != null && typeof k != "function" && typeof k != "symbol" && typeof k != "boolean" && (a.type = k), l != null || f != null) {
      if (!(k !== "submit" && k !== "reset" || l != null))
        return;
      f = f != null ? "" + It(f) : "", l = l != null ? "" + It(l) : f, B || l === a.value || (a.value = l), a.defaultValue = l;
    }
    m = m ?? w, m = typeof m != "function" && typeof m != "symbol" && !!m, a.checked = B ? a.checked : !!m, a.defaultChecked = !!m, T != null && typeof T != "function" && typeof T != "symbol" && typeof T != "boolean" && (a.name = T);
  }
  function pt(a, l, f) {
    l === "number" && Zn(a.ownerDocument) === a || a.defaultValue === "" + f || (a.defaultValue = "" + f);
  }
  function ot(a, l, f, m) {
    if (a = a.options, l) {
      l = {};
      for (var w = 0; w < f.length; w++)
        l["$" + f[w]] = !0;
      for (f = 0; f < a.length; f++)
        w = l.hasOwnProperty("$" + a[f].value), a[f].selected !== w && (a[f].selected = w), w && m && (a[f].defaultSelected = !0);
    } else {
      for (f = "" + It(f), l = null, w = 0; w < a.length; w++) {
        if (a[w].value === f) {
          a[w].selected = !0, m && (a[w].defaultSelected = !0);
          return;
        }
        l !== null || a[w].disabled || (l = a[w]);
      }
      l !== null && (l.selected = !0);
    }
  }
  function vs(a, l, f) {
    if (l != null && (l = "" + It(l), l !== a.value && (a.value = l), f == null)) {
      a.defaultValue !== l && (a.defaultValue = l);
      return;
    }
    a.defaultValue = f != null ? "" + It(f) : "";
  }
  function yo(a, l, f, m) {
    if (l == null) {
      if (m != null) {
        if (f != null) throw Error(r(92));
        if (F(m)) {
          if (1 < m.length) throw Error(r(93));
          m = m[0];
        }
        f = m;
      }
      f == null && (f = ""), l = f;
    }
    f = It(l), a.defaultValue = f, m = a.textContent, m === f && m !== "" && m !== null && (a.value = m);
  }
  function Fo(a, l) {
    if (l) {
      var f = a.firstChild;
      if (f && f === a.lastChild && f.nodeType === 3) {
        f.nodeValue = l;
        return;
      }
    }
    a.textContent = l;
  }
  var sr = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function Kr(a, l, f) {
    var m = l.indexOf("--") === 0;
    f == null || typeof f == "boolean" || f === "" ? m ? a.setProperty(l, "") : l === "float" ? a.cssFloat = "" : a[l] = "" : m ? a.setProperty(l, f) : typeof f != "number" || f === 0 || sr.has(l) ? l === "float" ? a.cssFloat = f : a[l] = ("" + f).trim() : a[l] = f + "px";
  }
  function vo(a, l, f) {
    if (l != null && typeof l != "object")
      throw Error(r(62));
    if (a = a.style, f != null) {
      for (var m in f)
        !f.hasOwnProperty(m) || l != null && l.hasOwnProperty(m) || (m.indexOf("--") === 0 ? a.setProperty(m, "") : m === "float" ? a.cssFloat = "" : a[m] = "");
      for (var w in l)
        m = l[w], l.hasOwnProperty(w) && f[w] !== m && Kr(a, w, m);
    } else
      for (var k in l)
        l.hasOwnProperty(k) && Kr(a, k, l[k]);
  }
  function _i(a) {
    if (a.indexOf("-") === -1) return !1;
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var ml = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), Ju = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function ki(a) {
    return Ju.test("" + a) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : a;
  }
  var bo = null;
  function gl(a) {
    return a = a.target || a.srcElement || window, a.correspondingUseElement && (a = a.correspondingUseElement), a.nodeType === 3 ? a.parentNode : a;
  }
  var wo = null, Uo = null;
  function bs(a) {
    var l = Gr(a);
    if (l && (a = l.stateNode)) {
      var f = a[wn] || null;
      e: switch (a = l.stateNode, l.type) {
        case "input":
          if (ha(
            a,
            f.value,
            f.defaultValue,
            f.defaultValue,
            f.checked,
            f.defaultChecked,
            f.type,
            f.name
          ), l = f.name, f.type === "radio" && l != null) {
            for (f = a; f.parentNode; ) f = f.parentNode;
            for (f = f.querySelectorAll(
              'input[name="' + An(
                "" + l
              ) + '"][type="radio"]'
            ), l = 0; l < f.length; l++) {
              var m = f[l];
              if (m !== a && m.form === a.form) {
                var w = m[wn] || null;
                if (!w) throw Error(r(90));
                ha(
                  m,
                  w.value,
                  w.defaultValue,
                  w.defaultValue,
                  w.checked,
                  w.defaultChecked,
                  w.type,
                  w.name
                );
              }
            }
            for (l = 0; l < f.length; l++)
              m = f[l], m.form === a.form && xi(m);
          }
          break e;
        case "textarea":
          vs(a, f.value, f.defaultValue);
          break e;
        case "select":
          l = f.value, l != null && ot(a, !!f.multiple, l, !1);
      }
    }
  }
  var ma = !1;
  function ec(a, l, f) {
    if (ma) return a(l, f);
    ma = !0;
    try {
      var m = a(l);
      return m;
    } finally {
      if (ma = !1, (wo !== null || Uo !== null) && (vp(), wo && (l = wo, a = Uo, Uo = wo = null, bs(l), a)))
        for (l = 0; l < a.length; l++) bs(a[l]);
    }
  }
  function Ho(a, l) {
    var f = a.stateNode;
    if (f === null) return null;
    var m = f[wn] || null;
    if (m === null) return null;
    f = m[l];
    e: switch (l) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (m = !m.disabled) || (a = a.type, m = !(a === "button" || a === "input" || a === "select" || a === "textarea")), a = !m;
        break e;
      default:
        a = !1;
    }
    if (a) return null;
    if (f && typeof f != "function")
      throw Error(
        r(231, l, typeof f)
      );
    return f;
  }
  var lr = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Zg = !1;
  if (lr)
    try {
      var tc = {};
      Object.defineProperty(tc, "passive", {
        get: function() {
          Zg = !0;
        }
      }), window.addEventListener("test", tc, tc), window.removeEventListener("test", tc, tc);
    } catch {
      Zg = !1;
    }
  var ga = null, Kg = null, Tf = null;
  function R_() {
    if (Tf) return Tf;
    var a, l = Kg, f = l.length, m, w = "value" in ga ? ga.value : ga.textContent, k = w.length;
    for (a = 0; a < f && l[a] === w[a]; a++) ;
    var T = f - a;
    for (m = 1; m <= T && l[f - m] === w[k - m]; m++) ;
    return Tf = w.slice(a, 1 < m ? 1 - m : void 0);
  }
  function Df(a) {
    var l = a.keyCode;
    return "charCode" in a ? (a = a.charCode, a === 0 && l === 13 && (a = 13)) : a = l, a === 10 && (a = 13), 32 <= a || a === 13 ? a : 0;
  }
  function Pf() {
    return !0;
  }
  function j_() {
    return !1;
  }
  function ur(a) {
    function l(f, m, w, k, T) {
      this._reactName = f, this._targetInst = w, this.type = m, this.nativeEvent = k, this.target = T, this.currentTarget = null;
      for (var B in a)
        a.hasOwnProperty(B) && (f = a[B], this[B] = f ? f(k) : k[B]);
      return this.isDefaultPrevented = (k.defaultPrevented != null ? k.defaultPrevented : k.returnValue === !1) ? Pf : j_, this.isPropagationStopped = j_, this;
    }
    return p(l.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var f = this.nativeEvent;
        f && (f.preventDefault ? f.preventDefault() : typeof f.returnValue != "unknown" && (f.returnValue = !1), this.isDefaultPrevented = Pf);
      },
      stopPropagation: function() {
        var f = this.nativeEvent;
        f && (f.stopPropagation ? f.stopPropagation() : typeof f.cancelBubble != "unknown" && (f.cancelBubble = !0), this.isPropagationStopped = Pf);
      },
      persist: function() {
      },
      isPersistent: Pf
    }), l;
  }
  var ws = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(a) {
      return a.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, Lf = ur(ws), nc = p({}, ws, { view: 0, detail: 0 }), mP = ur(nc), Qg, Jg, rc, If = p({}, nc, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: ty,
    button: 0,
    buttons: 0,
    relatedTarget: function(a) {
      return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    },
    movementX: function(a) {
      return "movementX" in a ? a.movementX : (a !== rc && (rc && a.type === "mousemove" ? (Qg = a.screenX - rc.screenX, Jg = a.screenY - rc.screenY) : Jg = Qg = 0, rc = a), Qg);
    },
    movementY: function(a) {
      return "movementY" in a ? a.movementY : Jg;
    }
  }), z_ = ur(If), gP = p({}, If, { dataTransfer: 0 }), yP = ur(gP), vP = p({}, nc, { relatedTarget: 0 }), ey = ur(vP), bP = p({}, ws, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), wP = ur(bP), xP = p({}, ws, {
    clipboardData: function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    }
  }), SP = ur(xP), _P = p({}, ws, { data: 0 }), T_ = ur(_P), kP = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, EP = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, CP = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function OP(a) {
    var l = this.nativeEvent;
    return l.getModifierState ? l.getModifierState(a) : (a = CP[a]) ? !!l[a] : !1;
  }
  function ty() {
    return OP;
  }
  var AP = p({}, nc, {
    key: function(a) {
      if (a.key) {
        var l = kP[a.key] || a.key;
        if (l !== "Unidentified") return l;
      }
      return a.type === "keypress" ? (a = Df(a), a === 13 ? "Enter" : String.fromCharCode(a)) : a.type === "keydown" || a.type === "keyup" ? EP[a.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: ty,
    charCode: function(a) {
      return a.type === "keypress" ? Df(a) : 0;
    },
    keyCode: function(a) {
      return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
    },
    which: function(a) {
      return a.type === "keypress" ? Df(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
    }
  }), NP = ur(AP), MP = p({}, If, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), D_ = ur(MP), RP = p({}, nc, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: ty
  }), jP = ur(RP), zP = p({}, ws, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), TP = ur(zP), DP = p({}, If, {
    deltaX: function(a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function(a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), PP = ur(DP), LP = p({}, ws, {
    newState: 0,
    oldState: 0
  }), IP = ur(LP), VP = [9, 13, 27, 32], ny = lr && "CompositionEvent" in window, oc = null;
  lr && "documentMode" in document && (oc = document.documentMode);
  var BP = lr && "TextEvent" in window && !oc, P_ = lr && (!ny || oc && 8 < oc && 11 >= oc), L_ = " ", I_ = !1;
  function V_(a, l) {
    switch (a) {
      case "keyup":
        return VP.indexOf(l.keyCode) !== -1;
      case "keydown":
        return l.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function B_(a) {
    return a = a.detail, typeof a == "object" && "data" in a ? a.data : null;
  }
  var yl = !1;
  function FP(a, l) {
    switch (a) {
      case "compositionend":
        return B_(l);
      case "keypress":
        return l.which !== 32 ? null : (I_ = !0, L_);
      case "textInput":
        return a = l.data, a === L_ && I_ ? null : a;
      default:
        return null;
    }
  }
  function UP(a, l) {
    if (yl)
      return a === "compositionend" || !ny && V_(a, l) ? (a = R_(), Tf = Kg = ga = null, yl = !1, a) : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(l.ctrlKey || l.altKey || l.metaKey) || l.ctrlKey && l.altKey) {
          if (l.char && 1 < l.char.length)
            return l.char;
          if (l.which) return String.fromCharCode(l.which);
        }
        return null;
      case "compositionend":
        return P_ && l.locale !== "ko" ? null : l.data;
      default:
        return null;
    }
  }
  var HP = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function F_(a) {
    var l = a && a.nodeName && a.nodeName.toLowerCase();
    return l === "input" ? !!HP[a.type] : l === "textarea";
  }
  function U_(a, l, f, m) {
    wo ? Uo ? Uo.push(m) : Uo = [m] : wo = m, l = kp(l, "onChange"), 0 < l.length && (f = new Lf(
      "onChange",
      "change",
      null,
      f,
      m
    ), a.push({ event: f, listeners: l }));
  }
  var ic = null, ac = null;
  function $P(a) {
    SE(a, 0);
  }
  function Vf(a) {
    var l = wi(a);
    if (xi(l)) return a;
  }
  function H_(a, l) {
    if (a === "change") return l;
  }
  var $_ = !1;
  if (lr) {
    var ry;
    if (lr) {
      var oy = "oninput" in document;
      if (!oy) {
        var Y_ = document.createElement("div");
        Y_.setAttribute("oninput", "return;"), oy = typeof Y_.oninput == "function";
      }
      ry = oy;
    } else ry = !1;
    $_ = ry && (!document.documentMode || 9 < document.documentMode);
  }
  function q_() {
    ic && (ic.detachEvent("onpropertychange", X_), ac = ic = null);
  }
  function X_(a) {
    if (a.propertyName === "value" && Vf(ac)) {
      var l = [];
      U_(
        l,
        ac,
        a,
        gl(a)
      ), ec($P, l);
    }
  }
  function YP(a, l, f) {
    a === "focusin" ? (q_(), ic = l, ac = f, ic.attachEvent("onpropertychange", X_)) : a === "focusout" && q_();
  }
  function qP(a) {
    if (a === "selectionchange" || a === "keyup" || a === "keydown")
      return Vf(ac);
  }
  function XP(a, l) {
    if (a === "click") return Vf(l);
  }
  function WP(a, l) {
    if (a === "input" || a === "change")
      return Vf(l);
  }
  function GP(a, l) {
    return a === l && (a !== 0 || 1 / a === 1 / l) || a !== a && l !== l;
  }
  var Er = typeof Object.is == "function" ? Object.is : GP;
  function sc(a, l) {
    if (Er(a, l)) return !0;
    if (typeof a != "object" || a === null || typeof l != "object" || l === null)
      return !1;
    var f = Object.keys(a), m = Object.keys(l);
    if (f.length !== m.length) return !1;
    for (m = 0; m < f.length; m++) {
      var w = f[m];
      if (!Ee.call(l, w) || !Er(a[w], l[w]))
        return !1;
    }
    return !0;
  }
  function W_(a) {
    for (; a && a.firstChild; ) a = a.firstChild;
    return a;
  }
  function G_(a, l) {
    var f = W_(a);
    a = 0;
    for (var m; f; ) {
      if (f.nodeType === 3) {
        if (m = a + f.textContent.length, a <= l && m >= l)
          return { node: f, offset: l - a };
        a = m;
      }
      e: {
        for (; f; ) {
          if (f.nextSibling) {
            f = f.nextSibling;
            break e;
          }
          f = f.parentNode;
        }
        f = void 0;
      }
      f = W_(f);
    }
  }
  function Z_(a, l) {
    return a && l ? a === l ? !0 : a && a.nodeType === 3 ? !1 : l && l.nodeType === 3 ? Z_(a, l.parentNode) : "contains" in a ? a.contains(l) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(l) & 16) : !1 : !1;
  }
  function K_(a) {
    a = a != null && a.ownerDocument != null && a.ownerDocument.defaultView != null ? a.ownerDocument.defaultView : window;
    for (var l = Zn(a.document); l instanceof a.HTMLIFrameElement; ) {
      try {
        var f = typeof l.contentWindow.location.href == "string";
      } catch {
        f = !1;
      }
      if (f) a = l.contentWindow;
      else break;
      l = Zn(a.document);
    }
    return l;
  }
  function iy(a) {
    var l = a && a.nodeName && a.nodeName.toLowerCase();
    return l && (l === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || l === "textarea" || a.contentEditable === "true");
  }
  var ZP = lr && "documentMode" in document && 11 >= document.documentMode, vl = null, ay = null, lc = null, sy = !1;
  function Q_(a, l, f) {
    var m = f.window === f ? f.document : f.nodeType === 9 ? f : f.ownerDocument;
    sy || vl == null || vl !== Zn(m) || (m = vl, "selectionStart" in m && iy(m) ? m = { start: m.selectionStart, end: m.selectionEnd } : (m = (m.ownerDocument && m.ownerDocument.defaultView || window).getSelection(), m = {
      anchorNode: m.anchorNode,
      anchorOffset: m.anchorOffset,
      focusNode: m.focusNode,
      focusOffset: m.focusOffset
    }), lc && sc(lc, m) || (lc = m, m = kp(ay, "onSelect"), 0 < m.length && (l = new Lf(
      "onSelect",
      "select",
      null,
      l,
      f
    ), a.push({ event: l, listeners: m }), l.target = vl)));
  }
  function xs(a, l) {
    var f = {};
    return f[a.toLowerCase()] = l.toLowerCase(), f["Webkit" + a] = "webkit" + l, f["Moz" + a] = "moz" + l, f;
  }
  var bl = {
    animationend: xs("Animation", "AnimationEnd"),
    animationiteration: xs("Animation", "AnimationIteration"),
    animationstart: xs("Animation", "AnimationStart"),
    transitionrun: xs("Transition", "TransitionRun"),
    transitionstart: xs("Transition", "TransitionStart"),
    transitioncancel: xs("Transition", "TransitionCancel"),
    transitionend: xs("Transition", "TransitionEnd")
  }, ly = {}, J_ = {};
  lr && (J_ = document.createElement("div").style, "AnimationEvent" in window || (delete bl.animationend.animation, delete bl.animationiteration.animation, delete bl.animationstart.animation), "TransitionEvent" in window || delete bl.transitionend.transition);
  function Ss(a) {
    if (ly[a]) return ly[a];
    if (!bl[a]) return a;
    var l = bl[a], f;
    for (f in l)
      if (l.hasOwnProperty(f) && f in J_)
        return ly[a] = l[f];
    return a;
  }
  var ek = Ss("animationend"), tk = Ss("animationiteration"), nk = Ss("animationstart"), KP = Ss("transitionrun"), QP = Ss("transitionstart"), JP = Ss("transitioncancel"), rk = Ss("transitionend"), ok = /* @__PURE__ */ new Map(), uy = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  uy.push("scrollEnd");
  function xo(a, l) {
    ok.set(a, l), Zr(l, [a]);
  }
  var ik = /* @__PURE__ */ new WeakMap();
  function Qr(a, l) {
    if (typeof a == "object" && a !== null) {
      var f = ik.get(a);
      return f !== void 0 ? f : (l = {
        value: a,
        source: l,
        stack: Wn(l)
      }, ik.set(a, l), l);
    }
    return {
      value: a,
      source: l,
      stack: Wn(l)
    };
  }
  var Jr = [], wl = 0, cy = 0;
  function Bf() {
    for (var a = wl, l = cy = wl = 0; l < a; ) {
      var f = Jr[l];
      Jr[l++] = null;
      var m = Jr[l];
      Jr[l++] = null;
      var w = Jr[l];
      Jr[l++] = null;
      var k = Jr[l];
      if (Jr[l++] = null, m !== null && w !== null) {
        var T = m.pending;
        T === null ? w.next = w : (w.next = T.next, T.next = w), m.pending = w;
      }
      k !== 0 && ak(f, w, k);
    }
  }
  function Ff(a, l, f, m) {
    Jr[wl++] = a, Jr[wl++] = l, Jr[wl++] = f, Jr[wl++] = m, cy |= m, a.lanes |= m, a = a.alternate, a !== null && (a.lanes |= m);
  }
  function dy(a, l, f, m) {
    return Ff(a, l, f, m), Uf(a);
  }
  function xl(a, l) {
    return Ff(a, null, null, l), Uf(a);
  }
  function ak(a, l, f) {
    a.lanes |= f;
    var m = a.alternate;
    m !== null && (m.lanes |= f);
    for (var w = !1, k = a.return; k !== null; )
      k.childLanes |= f, m = k.alternate, m !== null && (m.childLanes |= f), k.tag === 22 && (a = k.stateNode, a === null || a._visibility & 1 || (w = !0)), a = k, k = k.return;
    return a.tag === 3 ? (k = a.stateNode, w && l !== null && (w = 31 - Ve(f), a = k.hiddenUpdates, m = a[w], m === null ? a[w] = [l] : m.push(l), l.lane = f | 536870912), k) : null;
  }
  function Uf(a) {
    if (50 < zc)
      throw zc = 0, yv = null, Error(r(185));
    for (var l = a.return; l !== null; )
      a = l, l = a.return;
    return a.tag === 3 ? a.stateNode : null;
  }
  var Sl = {};
  function eL(a, l, f, m) {
    this.tag = a, this.key = f, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = l, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = m, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Cr(a, l, f, m) {
    return new eL(a, l, f, m);
  }
  function fy(a) {
    return a = a.prototype, !(!a || !a.isReactComponent);
  }
  function Ei(a, l) {
    var f = a.alternate;
    return f === null ? (f = Cr(
      a.tag,
      l,
      a.key,
      a.mode
    ), f.elementType = a.elementType, f.type = a.type, f.stateNode = a.stateNode, f.alternate = a, a.alternate = f) : (f.pendingProps = l, f.type = a.type, f.flags = 0, f.subtreeFlags = 0, f.deletions = null), f.flags = a.flags & 65011712, f.childLanes = a.childLanes, f.lanes = a.lanes, f.child = a.child, f.memoizedProps = a.memoizedProps, f.memoizedState = a.memoizedState, f.updateQueue = a.updateQueue, l = a.dependencies, f.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }, f.sibling = a.sibling, f.index = a.index, f.ref = a.ref, f.refCleanup = a.refCleanup, f;
  }
  function sk(a, l) {
    a.flags &= 65011714;
    var f = a.alternate;
    return f === null ? (a.childLanes = 0, a.lanes = l, a.child = null, a.subtreeFlags = 0, a.memoizedProps = null, a.memoizedState = null, a.updateQueue = null, a.dependencies = null, a.stateNode = null) : (a.childLanes = f.childLanes, a.lanes = f.lanes, a.child = f.child, a.subtreeFlags = 0, a.deletions = null, a.memoizedProps = f.memoizedProps, a.memoizedState = f.memoizedState, a.updateQueue = f.updateQueue, a.type = f.type, l = f.dependencies, a.dependencies = l === null ? null : {
      lanes: l.lanes,
      firstContext: l.firstContext
    }), a;
  }
  function Hf(a, l, f, m, w, k) {
    var T = 0;
    if (m = a, typeof a == "function") fy(a) && (T = 1);
    else if (typeof a == "string")
      T = n9(
        a,
        f,
        ee.current
      ) ? 26 : a === "html" || a === "head" || a === "body" ? 27 : 5;
    else
      e: switch (a) {
        case $:
          return a = Cr(31, f, l, w), a.elementType = $, a.lanes = k, a;
        case b:
          return _s(f.children, w, k, l);
        case v:
          T = 8, w |= 24;
          break;
        case x:
          return a = Cr(12, f, l, w | 2), a.elementType = x, a.lanes = k, a;
        case R:
          return a = Cr(13, f, l, w), a.elementType = R, a.lanes = k, a;
        case z:
          return a = Cr(19, f, l, w), a.elementType = z, a.lanes = k, a;
        default:
          if (typeof a == "object" && a !== null)
            switch (a.$$typeof) {
              case _:
              case C:
                T = 10;
                break e;
              case O:
                T = 9;
                break e;
              case N:
                T = 11;
                break e;
              case j:
                T = 14;
                break e;
              case I:
                T = 16, m = null;
                break e;
            }
          T = 29, f = Error(
            r(130, a === null ? "null" : typeof a, "")
          ), m = null;
      }
    return l = Cr(T, f, l, w), l.elementType = a, l.type = m, l.lanes = k, l;
  }
  function _s(a, l, f, m) {
    return a = Cr(7, a, m, l), a.lanes = f, a;
  }
  function py(a, l, f) {
    return a = Cr(6, a, null, l), a.lanes = f, a;
  }
  function hy(a, l, f) {
    return l = Cr(
      4,
      a.children !== null ? a.children : [],
      a.key,
      l
    ), l.lanes = f, l.stateNode = {
      containerInfo: a.containerInfo,
      pendingChildren: null,
      implementation: a.implementation
    }, l;
  }
  var _l = [], kl = 0, $f = null, Yf = 0, eo = [], to = 0, ks = null, Ci = 1, Oi = "";
  function Es(a, l) {
    _l[kl++] = Yf, _l[kl++] = $f, $f = a, Yf = l;
  }
  function lk(a, l, f) {
    eo[to++] = Ci, eo[to++] = Oi, eo[to++] = ks, ks = a;
    var m = Ci;
    a = Oi;
    var w = 32 - Ve(m) - 1;
    m &= ~(1 << w), f += 1;
    var k = 32 - Ve(l) + w;
    if (30 < k) {
      var T = w - w % 5;
      k = (m & (1 << T) - 1).toString(32), m >>= T, w -= T, Ci = 1 << 32 - Ve(l) + w | f << w | m, Oi = k + a;
    } else
      Ci = 1 << k | f << w | m, Oi = a;
  }
  function my(a) {
    a.return !== null && (Es(a, 1), lk(a, 1, 0));
  }
  function gy(a) {
    for (; a === $f; )
      $f = _l[--kl], _l[kl] = null, Yf = _l[--kl], _l[kl] = null;
    for (; a === ks; )
      ks = eo[--to], eo[to] = null, Oi = eo[--to], eo[to] = null, Ci = eo[--to], eo[to] = null;
  }
  var Kn = null, Gt = null, ht = !1, Cs = null, $o = !1, yy = Error(r(519));
  function Os(a) {
    var l = Error(r(418, ""));
    throw dc(Qr(l, a)), yy;
  }
  function uk(a) {
    var l = a.stateNode, f = a.type, m = a.memoizedProps;
    switch (l[an] = a, l[wn] = m, f) {
      case "dialog":
        tt("cancel", l), tt("close", l);
        break;
      case "iframe":
      case "object":
      case "embed":
        tt("load", l);
        break;
      case "video":
      case "audio":
        for (f = 0; f < Dc.length; f++)
          tt(Dc[f], l);
        break;
      case "source":
        tt("error", l);
        break;
      case "img":
      case "image":
      case "link":
        tt("error", l), tt("load", l);
        break;
      case "details":
        tt("toggle", l);
        break;
      case "input":
        tt("invalid", l), zf(
          l,
          m.value,
          m.defaultValue,
          m.checked,
          m.defaultChecked,
          m.type,
          m.name,
          !0
        ), kr(l);
        break;
      case "select":
        tt("invalid", l);
        break;
      case "textarea":
        tt("invalid", l), yo(l, m.value, m.defaultValue, m.children), kr(l);
    }
    f = m.children, typeof f != "string" && typeof f != "number" && typeof f != "bigint" || l.textContent === "" + f || m.suppressHydrationWarning === !0 || CE(l.textContent, f) ? (m.popover != null && (tt("beforetoggle", l), tt("toggle", l)), m.onScroll != null && tt("scroll", l), m.onScrollEnd != null && tt("scrollend", l), m.onClick != null && (l.onclick = Ep), l = !0) : l = !1, l || Os(a);
  }
  function ck(a) {
    for (Kn = a.return; Kn; )
      switch (Kn.tag) {
        case 5:
        case 13:
          $o = !1;
          return;
        case 27:
        case 3:
          $o = !0;
          return;
        default:
          Kn = Kn.return;
      }
  }
  function uc(a) {
    if (a !== Kn) return !1;
    if (!ht) return ck(a), ht = !0, !1;
    var l = a.tag, f;
    if ((f = l !== 3 && l !== 27) && ((f = l === 5) && (f = a.type, f = !(f !== "form" && f !== "button") || zv(a.type, a.memoizedProps)), f = !f), f && Gt && Os(a), ck(a), l === 13) {
      if (a = a.memoizedState, a = a !== null ? a.dehydrated : null, !a) throw Error(r(317));
      e: {
        for (a = a.nextSibling, l = 0; a; ) {
          if (a.nodeType === 8)
            if (f = a.data, f === "/$") {
              if (l === 0) {
                Gt = _o(a.nextSibling);
                break e;
              }
              l--;
            } else
              f !== "$" && f !== "$!" && f !== "$?" || l++;
          a = a.nextSibling;
        }
        Gt = null;
      }
    } else
      l === 27 ? (l = Gt, ja(a.type) ? (a = Lv, Lv = null, Gt = a) : Gt = l) : Gt = Kn ? _o(a.stateNode.nextSibling) : null;
    return !0;
  }
  function cc() {
    Gt = Kn = null, ht = !1;
  }
  function dk() {
    var a = Cs;
    return a !== null && (fr === null ? fr = a : fr.push.apply(
      fr,
      a
    ), Cs = null), a;
  }
  function dc(a) {
    Cs === null ? Cs = [a] : Cs.push(a);
  }
  var vy = X(null), As = null, Ai = null;
  function ya(a, l, f) {
    L(vy, l._currentValue), l._currentValue = f;
  }
  function Ni(a) {
    a._currentValue = vy.current, K(vy);
  }
  function by(a, l, f) {
    for (; a !== null; ) {
      var m = a.alternate;
      if ((a.childLanes & l) !== l ? (a.childLanes |= l, m !== null && (m.childLanes |= l)) : m !== null && (m.childLanes & l) !== l && (m.childLanes |= l), a === f) break;
      a = a.return;
    }
  }
  function wy(a, l, f, m) {
    var w = a.child;
    for (w !== null && (w.return = a); w !== null; ) {
      var k = w.dependencies;
      if (k !== null) {
        var T = w.child;
        k = k.firstContext;
        e: for (; k !== null; ) {
          var B = k;
          k = w;
          for (var G = 0; G < l.length; G++)
            if (B.context === l[G]) {
              k.lanes |= f, B = k.alternate, B !== null && (B.lanes |= f), by(
                k.return,
                f,
                a
              ), m || (T = null);
              break e;
            }
          k = B.next;
        }
      } else if (w.tag === 18) {
        if (T = w.return, T === null) throw Error(r(341));
        T.lanes |= f, k = T.alternate, k !== null && (k.lanes |= f), by(T, f, a), T = null;
      } else T = w.child;
      if (T !== null) T.return = w;
      else
        for (T = w; T !== null; ) {
          if (T === a) {
            T = null;
            break;
          }
          if (w = T.sibling, w !== null) {
            w.return = T.return, T = w;
            break;
          }
          T = T.return;
        }
      w = T;
    }
  }
  function fc(a, l, f, m) {
    a = null;
    for (var w = l, k = !1; w !== null; ) {
      if (!k) {
        if ((w.flags & 524288) !== 0) k = !0;
        else if ((w.flags & 262144) !== 0) break;
      }
      if (w.tag === 10) {
        var T = w.alternate;
        if (T === null) throw Error(r(387));
        if (T = T.memoizedProps, T !== null) {
          var B = w.type;
          Er(w.pendingProps.value, T.value) || (a !== null ? a.push(B) : a = [B]);
        }
      } else if (w === me.current) {
        if (T = w.alternate, T === null) throw Error(r(387));
        T.memoizedState.memoizedState !== w.memoizedState.memoizedState && (a !== null ? a.push(Fc) : a = [Fc]);
      }
      w = w.return;
    }
    a !== null && wy(
      l,
      a,
      f,
      m
    ), l.flags |= 262144;
  }
  function qf(a) {
    for (a = a.firstContext; a !== null; ) {
      if (!Er(
        a.context._currentValue,
        a.memoizedValue
      ))
        return !0;
      a = a.next;
    }
    return !1;
  }
  function Ns(a) {
    As = a, Ai = null, a = a.dependencies, a !== null && (a.firstContext = null);
  }
  function Ln(a) {
    return fk(As, a);
  }
  function Xf(a, l) {
    return As === null && Ns(a), fk(a, l);
  }
  function fk(a, l) {
    var f = l._currentValue;
    if (l = { context: l, memoizedValue: f, next: null }, Ai === null) {
      if (a === null) throw Error(r(308));
      Ai = l, a.dependencies = { lanes: 0, firstContext: l }, a.flags |= 524288;
    } else Ai = Ai.next = l;
    return f;
  }
  var tL = typeof AbortController < "u" ? AbortController : function() {
    var a = [], l = this.signal = {
      aborted: !1,
      addEventListener: function(f, m) {
        a.push(m);
      }
    };
    this.abort = function() {
      l.aborted = !0, a.forEach(function(f) {
        return f();
      });
    };
  }, nL = e.unstable_scheduleCallback, rL = e.unstable_NormalPriority, gn = {
    $$typeof: C,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function xy() {
    return {
      controller: new tL(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function pc(a) {
    a.refCount--, a.refCount === 0 && nL(rL, function() {
      a.controller.abort();
    });
  }
  var hc = null, Sy = 0, El = 0, Cl = null;
  function oL(a, l) {
    if (hc === null) {
      var f = hc = [];
      Sy = 0, El = kv(), Cl = {
        status: "pending",
        value: void 0,
        then: function(m) {
          f.push(m);
        }
      };
    }
    return Sy++, l.then(pk, pk), l;
  }
  function pk() {
    if (--Sy === 0 && hc !== null) {
      Cl !== null && (Cl.status = "fulfilled");
      var a = hc;
      hc = null, El = 0, Cl = null;
      for (var l = 0; l < a.length; l++) (0, a[l])();
    }
  }
  function iL(a, l) {
    var f = [], m = {
      status: "pending",
      value: null,
      reason: null,
      then: function(w) {
        f.push(w);
      }
    };
    return a.then(
      function() {
        m.status = "fulfilled", m.value = l;
        for (var w = 0; w < f.length; w++) (0, f[w])(l);
      },
      function(w) {
        for (m.status = "rejected", m.reason = w, w = 0; w < f.length; w++)
          (0, f[w])(void 0);
      }
    ), m;
  }
  var hk = P.S;
  P.S = function(a, l) {
    typeof l == "object" && l !== null && typeof l.then == "function" && oL(a, l), hk !== null && hk(a, l);
  };
  var Ms = X(null);
  function _y() {
    var a = Ms.current;
    return a !== null ? a : Rt.pooledCache;
  }
  function Wf(a, l) {
    l === null ? L(Ms, Ms.current) : L(Ms, l.pool);
  }
  function mk() {
    var a = _y();
    return a === null ? null : { parent: gn._currentValue, pool: a };
  }
  var mc = Error(r(460)), gk = Error(r(474)), Gf = Error(r(542)), ky = { then: function() {
  } };
  function yk(a) {
    return a = a.status, a === "fulfilled" || a === "rejected";
  }
  function Zf() {
  }
  function vk(a, l, f) {
    switch (f = a[f], f === void 0 ? a.push(l) : f !== l && (l.then(Zf, Zf), l = f), l.status) {
      case "fulfilled":
        return l.value;
      case "rejected":
        throw a = l.reason, wk(a), a;
      default:
        if (typeof l.status == "string") l.then(Zf, Zf);
        else {
          if (a = Rt, a !== null && 100 < a.shellSuspendCounter)
            throw Error(r(482));
          a = l, a.status = "pending", a.then(
            function(m) {
              if (l.status === "pending") {
                var w = l;
                w.status = "fulfilled", w.value = m;
              }
            },
            function(m) {
              if (l.status === "pending") {
                var w = l;
                w.status = "rejected", w.reason = m;
              }
            }
          );
        }
        switch (l.status) {
          case "fulfilled":
            return l.value;
          case "rejected":
            throw a = l.reason, wk(a), a;
        }
        throw gc = l, mc;
    }
  }
  var gc = null;
  function bk() {
    if (gc === null) throw Error(r(459));
    var a = gc;
    return gc = null, a;
  }
  function wk(a) {
    if (a === mc || a === Gf)
      throw Error(r(483));
  }
  var va = !1;
  function Ey(a) {
    a.updateQueue = {
      baseState: a.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function Cy(a, l) {
    a = a.updateQueue, l.updateQueue === a && (l.updateQueue = {
      baseState: a.baseState,
      firstBaseUpdate: a.firstBaseUpdate,
      lastBaseUpdate: a.lastBaseUpdate,
      shared: a.shared,
      callbacks: null
    });
  }
  function ba(a) {
    return { lane: a, tag: 0, payload: null, callback: null, next: null };
  }
  function wa(a, l, f) {
    var m = a.updateQueue;
    if (m === null) return null;
    if (m = m.shared, (wt & 2) !== 0) {
      var w = m.pending;
      return w === null ? l.next = l : (l.next = w.next, w.next = l), m.pending = l, l = Uf(a), ak(a, null, f), l;
    }
    return Ff(a, m, l, f), Uf(a);
  }
  function yc(a, l, f) {
    if (l = l.updateQueue, l !== null && (l = l.shared, (f & 4194048) !== 0)) {
      var m = l.lanes;
      m &= a.pendingLanes, f |= m, l.lanes = f, xr(a, f);
    }
  }
  function Oy(a, l) {
    var f = a.updateQueue, m = a.alternate;
    if (m !== null && (m = m.updateQueue, f === m)) {
      var w = null, k = null;
      if (f = f.firstBaseUpdate, f !== null) {
        do {
          var T = {
            lane: f.lane,
            tag: f.tag,
            payload: f.payload,
            callback: null,
            next: null
          };
          k === null ? w = k = T : k = k.next = T, f = f.next;
        } while (f !== null);
        k === null ? w = k = l : k = k.next = l;
      } else w = k = l;
      f = {
        baseState: m.baseState,
        firstBaseUpdate: w,
        lastBaseUpdate: k,
        shared: m.shared,
        callbacks: m.callbacks
      }, a.updateQueue = f;
      return;
    }
    a = f.lastBaseUpdate, a === null ? f.firstBaseUpdate = l : a.next = l, f.lastBaseUpdate = l;
  }
  var Ay = !1;
  function vc() {
    if (Ay) {
      var a = Cl;
      if (a !== null) throw a;
    }
  }
  function bc(a, l, f, m) {
    Ay = !1;
    var w = a.updateQueue;
    va = !1;
    var k = w.firstBaseUpdate, T = w.lastBaseUpdate, B = w.shared.pending;
    if (B !== null) {
      w.shared.pending = null;
      var G = B, ne = G.next;
      G.next = null, T === null ? k = ne : T.next = ne, T = G;
      var fe = a.alternate;
      fe !== null && (fe = fe.updateQueue, B = fe.lastBaseUpdate, B !== T && (B === null ? fe.firstBaseUpdate = ne : B.next = ne, fe.lastBaseUpdate = G));
    }
    if (k !== null) {
      var ge = w.baseState;
      T = 0, fe = ne = G = null, B = k;
      do {
        var re = B.lane & -536870913, oe = re !== B.lane;
        if (oe ? (st & re) === re : (m & re) === re) {
          re !== 0 && re === El && (Ay = !0), fe !== null && (fe = fe.next = {
            lane: 0,
            tag: B.tag,
            payload: B.payload,
            callback: null,
            next: null
          });
          e: {
            var He = a, Be = B;
            re = l;
            var Et = f;
            switch (Be.tag) {
              case 1:
                if (He = Be.payload, typeof He == "function") {
                  ge = He.call(Et, ge, re);
                  break e;
                }
                ge = He;
                break e;
              case 3:
                He.flags = He.flags & -65537 | 128;
              case 0:
                if (He = Be.payload, re = typeof He == "function" ? He.call(Et, ge, re) : He, re == null) break e;
                ge = p({}, ge, re);
                break e;
              case 2:
                va = !0;
            }
          }
          re = B.callback, re !== null && (a.flags |= 64, oe && (a.flags |= 8192), oe = w.callbacks, oe === null ? w.callbacks = [re] : oe.push(re));
        } else
          oe = {
            lane: re,
            tag: B.tag,
            payload: B.payload,
            callback: B.callback,
            next: null
          }, fe === null ? (ne = fe = oe, G = ge) : fe = fe.next = oe, T |= re;
        if (B = B.next, B === null) {
          if (B = w.shared.pending, B === null)
            break;
          oe = B, B = oe.next, oe.next = null, w.lastBaseUpdate = oe, w.shared.pending = null;
        }
      } while (!0);
      fe === null && (G = ge), w.baseState = G, w.firstBaseUpdate = ne, w.lastBaseUpdate = fe, k === null && (w.shared.lanes = 0), Aa |= T, a.lanes = T, a.memoizedState = ge;
    }
  }
  function xk(a, l) {
    if (typeof a != "function")
      throw Error(r(191, a));
    a.call(l);
  }
  function Sk(a, l) {
    var f = a.callbacks;
    if (f !== null)
      for (a.callbacks = null, a = 0; a < f.length; a++)
        xk(f[a], l);
  }
  var Ol = X(null), Kf = X(0);
  function _k(a, l) {
    a = Pi, L(Kf, a), L(Ol, l), Pi = a | l.baseLanes;
  }
  function Ny() {
    L(Kf, Pi), L(Ol, Ol.current);
  }
  function My() {
    Pi = Kf.current, K(Ol), K(Kf);
  }
  var xa = 0, Ze = null, _t = null, ln = null, Qf = !1, Al = !1, Rs = !1, Jf = 0, wc = 0, Nl = null, aL = 0;
  function en() {
    throw Error(r(321));
  }
  function Ry(a, l) {
    if (l === null) return !1;
    for (var f = 0; f < l.length && f < a.length; f++)
      if (!Er(a[f], l[f])) return !1;
    return !0;
  }
  function jy(a, l, f, m, w, k) {
    return xa = k, Ze = l, l.memoizedState = null, l.updateQueue = null, l.lanes = 0, P.H = a === null || a.memoizedState === null ? a2 : s2, Rs = !1, k = f(m, w), Rs = !1, Al && (k = Ek(
      l,
      f,
      m,
      w
    )), kk(a), k;
  }
  function kk(a) {
    P.H = ip;
    var l = _t !== null && _t.next !== null;
    if (xa = 0, ln = _t = Ze = null, Qf = !1, wc = 0, Nl = null, l) throw Error(r(300));
    a === null || xn || (a = a.dependencies, a !== null && qf(a) && (xn = !0));
  }
  function Ek(a, l, f, m) {
    Ze = a;
    var w = 0;
    do {
      if (Al && (Nl = null), wc = 0, Al = !1, 25 <= w) throw Error(r(301));
      if (w += 1, ln = _t = null, a.updateQueue != null) {
        var k = a.updateQueue;
        k.lastEffect = null, k.events = null, k.stores = null, k.memoCache != null && (k.memoCache.index = 0);
      }
      P.H = pL, k = l(f, m);
    } while (Al);
    return k;
  }
  function sL() {
    var a = P.H, l = a.useState()[0];
    return l = typeof l.then == "function" ? xc(l) : l, a = a.useState()[0], (_t !== null ? _t.memoizedState : null) !== a && (Ze.flags |= 1024), l;
  }
  function zy() {
    var a = Jf !== 0;
    return Jf = 0, a;
  }
  function Ty(a, l, f) {
    l.updateQueue = a.updateQueue, l.flags &= -2053, a.lanes &= ~f;
  }
  function Dy(a) {
    if (Qf) {
      for (a = a.memoizedState; a !== null; ) {
        var l = a.queue;
        l !== null && (l.pending = null), a = a.next;
      }
      Qf = !1;
    }
    xa = 0, ln = _t = Ze = null, Al = !1, wc = Jf = 0, Nl = null;
  }
  function cr() {
    var a = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return ln === null ? Ze.memoizedState = ln = a : ln = ln.next = a, ln;
  }
  function un() {
    if (_t === null) {
      var a = Ze.alternate;
      a = a !== null ? a.memoizedState : null;
    } else a = _t.next;
    var l = ln === null ? Ze.memoizedState : ln.next;
    if (l !== null)
      ln = l, _t = a;
    else {
      if (a === null)
        throw Ze.alternate === null ? Error(r(467)) : Error(r(310));
      _t = a, a = {
        memoizedState: _t.memoizedState,
        baseState: _t.baseState,
        baseQueue: _t.baseQueue,
        queue: _t.queue,
        next: null
      }, ln === null ? Ze.memoizedState = ln = a : ln = ln.next = a;
    }
    return ln;
  }
  function Py() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function xc(a) {
    var l = wc;
    return wc += 1, Nl === null && (Nl = []), a = vk(Nl, a, l), l = Ze, (ln === null ? l.memoizedState : ln.next) === null && (l = l.alternate, P.H = l === null || l.memoizedState === null ? a2 : s2), a;
  }
  function ep(a) {
    if (a !== null && typeof a == "object") {
      if (typeof a.then == "function") return xc(a);
      if (a.$$typeof === C) return Ln(a);
    }
    throw Error(r(438, String(a)));
  }
  function Ly(a) {
    var l = null, f = Ze.updateQueue;
    if (f !== null && (l = f.memoCache), l == null) {
      var m = Ze.alternate;
      m !== null && (m = m.updateQueue, m !== null && (m = m.memoCache, m != null && (l = {
        data: m.data.map(function(w) {
          return w.slice();
        }),
        index: 0
      })));
    }
    if (l == null && (l = { data: [], index: 0 }), f === null && (f = Py(), Ze.updateQueue = f), f.memoCache = l, f = l.data[l.index], f === void 0)
      for (f = l.data[l.index] = Array(a), m = 0; m < a; m++)
        f[m] = A;
    return l.index++, f;
  }
  function Mi(a, l) {
    return typeof l == "function" ? l(a) : l;
  }
  function tp(a) {
    var l = un();
    return Iy(l, _t, a);
  }
  function Iy(a, l, f) {
    var m = a.queue;
    if (m === null) throw Error(r(311));
    m.lastRenderedReducer = f;
    var w = a.baseQueue, k = m.pending;
    if (k !== null) {
      if (w !== null) {
        var T = w.next;
        w.next = k.next, k.next = T;
      }
      l.baseQueue = w = k, m.pending = null;
    }
    if (k = a.baseState, w === null) a.memoizedState = k;
    else {
      l = w.next;
      var B = T = null, G = null, ne = l, fe = !1;
      do {
        var ge = ne.lane & -536870913;
        if (ge !== ne.lane ? (st & ge) === ge : (xa & ge) === ge) {
          var re = ne.revertLane;
          if (re === 0)
            G !== null && (G = G.next = {
              lane: 0,
              revertLane: 0,
              action: ne.action,
              hasEagerState: ne.hasEagerState,
              eagerState: ne.eagerState,
              next: null
            }), ge === El && (fe = !0);
          else if ((xa & re) === re) {
            ne = ne.next, re === El && (fe = !0);
            continue;
          } else
            ge = {
              lane: 0,
              revertLane: ne.revertLane,
              action: ne.action,
              hasEagerState: ne.hasEagerState,
              eagerState: ne.eagerState,
              next: null
            }, G === null ? (B = G = ge, T = k) : G = G.next = ge, Ze.lanes |= re, Aa |= re;
          ge = ne.action, Rs && f(k, ge), k = ne.hasEagerState ? ne.eagerState : f(k, ge);
        } else
          re = {
            lane: ge,
            revertLane: ne.revertLane,
            action: ne.action,
            hasEagerState: ne.hasEagerState,
            eagerState: ne.eagerState,
            next: null
          }, G === null ? (B = G = re, T = k) : G = G.next = re, Ze.lanes |= ge, Aa |= ge;
        ne = ne.next;
      } while (ne !== null && ne !== l);
      if (G === null ? T = k : G.next = B, !Er(k, a.memoizedState) && (xn = !0, fe && (f = Cl, f !== null)))
        throw f;
      a.memoizedState = k, a.baseState = T, a.baseQueue = G, m.lastRenderedState = k;
    }
    return w === null && (m.lanes = 0), [a.memoizedState, m.dispatch];
  }
  function Vy(a) {
    var l = un(), f = l.queue;
    if (f === null) throw Error(r(311));
    f.lastRenderedReducer = a;
    var m = f.dispatch, w = f.pending, k = l.memoizedState;
    if (w !== null) {
      f.pending = null;
      var T = w = w.next;
      do
        k = a(k, T.action), T = T.next;
      while (T !== w);
      Er(k, l.memoizedState) || (xn = !0), l.memoizedState = k, l.baseQueue === null && (l.baseState = k), f.lastRenderedState = k;
    }
    return [k, m];
  }
  function Ck(a, l, f) {
    var m = Ze, w = un(), k = ht;
    if (k) {
      if (f === void 0) throw Error(r(407));
      f = f();
    } else f = l();
    var T = !Er(
      (_t || w).memoizedState,
      f
    );
    T && (w.memoizedState = f, xn = !0), w = w.queue;
    var B = Nk.bind(null, m, w, a);
    if (Sc(2048, 8, B, [a]), w.getSnapshot !== l || T || ln !== null && ln.memoizedState.tag & 1) {
      if (m.flags |= 2048, Ml(
        9,
        np(),
        Ak.bind(
          null,
          m,
          w,
          f,
          l
        ),
        null
      ), Rt === null) throw Error(r(349));
      k || (xa & 124) !== 0 || Ok(m, l, f);
    }
    return f;
  }
  function Ok(a, l, f) {
    a.flags |= 16384, a = { getSnapshot: l, value: f }, l = Ze.updateQueue, l === null ? (l = Py(), Ze.updateQueue = l, l.stores = [a]) : (f = l.stores, f === null ? l.stores = [a] : f.push(a));
  }
  function Ak(a, l, f, m) {
    l.value = f, l.getSnapshot = m, Mk(l) && Rk(a);
  }
  function Nk(a, l, f) {
    return f(function() {
      Mk(l) && Rk(a);
    });
  }
  function Mk(a) {
    var l = a.getSnapshot;
    a = a.value;
    try {
      var f = l();
      return !Er(a, f);
    } catch {
      return !0;
    }
  }
  function Rk(a) {
    var l = xl(a, 2);
    l !== null && Rr(l, a, 2);
  }
  function By(a) {
    var l = cr();
    if (typeof a == "function") {
      var f = a;
      if (a = f(), Rs) {
        Ae(!0);
        try {
          f();
        } finally {
          Ae(!1);
        }
      }
    }
    return l.memoizedState = l.baseState = a, l.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Mi,
      lastRenderedState: a
    }, l;
  }
  function jk(a, l, f, m) {
    return a.baseState = f, Iy(
      a,
      _t,
      typeof m == "function" ? m : Mi
    );
  }
  function lL(a, l, f, m, w) {
    if (op(a)) throw Error(r(485));
    if (a = l.action, a !== null) {
      var k = {
        payload: w,
        action: a,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(T) {
          k.listeners.push(T);
        }
      };
      P.T !== null ? f(!0) : k.isTransition = !1, m(k), f = l.pending, f === null ? (k.next = l.pending = k, zk(l, k)) : (k.next = f.next, l.pending = f.next = k);
    }
  }
  function zk(a, l) {
    var f = l.action, m = l.payload, w = a.state;
    if (l.isTransition) {
      var k = P.T, T = {};
      P.T = T;
      try {
        var B = f(w, m), G = P.S;
        G !== null && G(T, B), Tk(a, l, B);
      } catch (ne) {
        Fy(a, l, ne);
      } finally {
        P.T = k;
      }
    } else
      try {
        k = f(w, m), Tk(a, l, k);
      } catch (ne) {
        Fy(a, l, ne);
      }
  }
  function Tk(a, l, f) {
    f !== null && typeof f == "object" && typeof f.then == "function" ? f.then(
      function(m) {
        Dk(a, l, m);
      },
      function(m) {
        return Fy(a, l, m);
      }
    ) : Dk(a, l, f);
  }
  function Dk(a, l, f) {
    l.status = "fulfilled", l.value = f, Pk(l), a.state = f, l = a.pending, l !== null && (f = l.next, f === l ? a.pending = null : (f = f.next, l.next = f, zk(a, f)));
  }
  function Fy(a, l, f) {
    var m = a.pending;
    if (a.pending = null, m !== null) {
      m = m.next;
      do
        l.status = "rejected", l.reason = f, Pk(l), l = l.next;
      while (l !== m);
    }
    a.action = null;
  }
  function Pk(a) {
    a = a.listeners;
    for (var l = 0; l < a.length; l++) (0, a[l])();
  }
  function Lk(a, l) {
    return l;
  }
  function Ik(a, l) {
    if (ht) {
      var f = Rt.formState;
      if (f !== null) {
        e: {
          var m = Ze;
          if (ht) {
            if (Gt) {
              t: {
                for (var w = Gt, k = $o; w.nodeType !== 8; ) {
                  if (!k) {
                    w = null;
                    break t;
                  }
                  if (w = _o(
                    w.nextSibling
                  ), w === null) {
                    w = null;
                    break t;
                  }
                }
                k = w.data, w = k === "F!" || k === "F" ? w : null;
              }
              if (w) {
                Gt = _o(
                  w.nextSibling
                ), m = w.data === "F!";
                break e;
              }
            }
            Os(m);
          }
          m = !1;
        }
        m && (l = f[0]);
      }
    }
    return f = cr(), f.memoizedState = f.baseState = l, m = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Lk,
      lastRenderedState: l
    }, f.queue = m, f = r2.bind(
      null,
      Ze,
      m
    ), m.dispatch = f, m = By(!1), k = qy.bind(
      null,
      Ze,
      !1,
      m.queue
    ), m = cr(), w = {
      state: l,
      dispatch: null,
      action: a,
      pending: null
    }, m.queue = w, f = lL.bind(
      null,
      Ze,
      w,
      k,
      f
    ), w.dispatch = f, m.memoizedState = a, [l, f, !1];
  }
  function Vk(a) {
    var l = un();
    return Bk(l, _t, a);
  }
  function Bk(a, l, f) {
    if (l = Iy(
      a,
      l,
      Lk
    )[0], a = tp(Mi)[0], typeof l == "object" && l !== null && typeof l.then == "function")
      try {
        var m = xc(l);
      } catch (T) {
        throw T === mc ? Gf : T;
      }
    else m = l;
    l = un();
    var w = l.queue, k = w.dispatch;
    return f !== l.memoizedState && (Ze.flags |= 2048, Ml(
      9,
      np(),
      uL.bind(null, w, f),
      null
    )), [m, k, a];
  }
  function uL(a, l) {
    a.action = l;
  }
  function Fk(a) {
    var l = un(), f = _t;
    if (f !== null)
      return Bk(l, f, a);
    un(), l = l.memoizedState, f = un();
    var m = f.queue.dispatch;
    return f.memoizedState = a, [l, m, !1];
  }
  function Ml(a, l, f, m) {
    return a = { tag: a, create: f, deps: m, inst: l, next: null }, l = Ze.updateQueue, l === null && (l = Py(), Ze.updateQueue = l), f = l.lastEffect, f === null ? l.lastEffect = a.next = a : (m = f.next, f.next = a, a.next = m, l.lastEffect = a), a;
  }
  function np() {
    return { destroy: void 0, resource: void 0 };
  }
  function Uk() {
    return un().memoizedState;
  }
  function rp(a, l, f, m) {
    var w = cr();
    m = m === void 0 ? null : m, Ze.flags |= a, w.memoizedState = Ml(
      1 | l,
      np(),
      f,
      m
    );
  }
  function Sc(a, l, f, m) {
    var w = un();
    m = m === void 0 ? null : m;
    var k = w.memoizedState.inst;
    _t !== null && m !== null && Ry(m, _t.memoizedState.deps) ? w.memoizedState = Ml(l, k, f, m) : (Ze.flags |= a, w.memoizedState = Ml(
      1 | l,
      k,
      f,
      m
    ));
  }
  function Hk(a, l) {
    rp(8390656, 8, a, l);
  }
  function $k(a, l) {
    Sc(2048, 8, a, l);
  }
  function Yk(a, l) {
    return Sc(4, 2, a, l);
  }
  function qk(a, l) {
    return Sc(4, 4, a, l);
  }
  function Xk(a, l) {
    if (typeof l == "function") {
      a = a();
      var f = l(a);
      return function() {
        typeof f == "function" ? f() : l(null);
      };
    }
    if (l != null)
      return a = a(), l.current = a, function() {
        l.current = null;
      };
  }
  function Wk(a, l, f) {
    f = f != null ? f.concat([a]) : null, Sc(4, 4, Xk.bind(null, l, a), f);
  }
  function Uy() {
  }
  function Gk(a, l) {
    var f = un();
    l = l === void 0 ? null : l;
    var m = f.memoizedState;
    return l !== null && Ry(l, m[1]) ? m[0] : (f.memoizedState = [a, l], a);
  }
  function Zk(a, l) {
    var f = un();
    l = l === void 0 ? null : l;
    var m = f.memoizedState;
    if (l !== null && Ry(l, m[1]))
      return m[0];
    if (m = a(), Rs) {
      Ae(!0);
      try {
        a();
      } finally {
        Ae(!1);
      }
    }
    return f.memoizedState = [m, l], m;
  }
  function Hy(a, l, f) {
    return f === void 0 || (xa & 1073741824) !== 0 ? a.memoizedState = l : (a.memoizedState = f, a = J2(), Ze.lanes |= a, Aa |= a, f);
  }
  function Kk(a, l, f, m) {
    return Er(f, l) ? f : Ol.current !== null ? (a = Hy(a, f, m), Er(a, l) || (xn = !0), a) : (xa & 42) === 0 ? (xn = !0, a.memoizedState = f) : (a = J2(), Ze.lanes |= a, Aa |= a, l);
  }
  function Qk(a, l, f, m, w) {
    var k = H.p;
    H.p = k !== 0 && 8 > k ? k : 8;
    var T = P.T, B = {};
    P.T = B, qy(a, !1, l, f);
    try {
      var G = w(), ne = P.S;
      if (ne !== null && ne(B, G), G !== null && typeof G == "object" && typeof G.then == "function") {
        var fe = iL(
          G,
          m
        );
        _c(
          a,
          l,
          fe,
          Mr(a)
        );
      } else
        _c(
          a,
          l,
          m,
          Mr(a)
        );
    } catch (ge) {
      _c(
        a,
        l,
        { then: function() {
        }, status: "rejected", reason: ge },
        Mr()
      );
    } finally {
      H.p = k, P.T = T;
    }
  }
  function cL() {
  }
  function $y(a, l, f, m) {
    if (a.tag !== 5) throw Error(r(476));
    var w = Jk(a).queue;
    Qk(
      a,
      w,
      l,
      Y,
      f === null ? cL : function() {
        return e2(a), f(m);
      }
    );
  }
  function Jk(a) {
    var l = a.memoizedState;
    if (l !== null) return l;
    l = {
      memoizedState: Y,
      baseState: Y,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Mi,
        lastRenderedState: Y
      },
      next: null
    };
    var f = {};
    return l.next = {
      memoizedState: f,
      baseState: f,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Mi,
        lastRenderedState: f
      },
      next: null
    }, a.memoizedState = l, a = a.alternate, a !== null && (a.memoizedState = l), l;
  }
  function e2(a) {
    var l = Jk(a).next.queue;
    _c(a, l, {}, Mr());
  }
  function Yy() {
    return Ln(Fc);
  }
  function t2() {
    return un().memoizedState;
  }
  function n2() {
    return un().memoizedState;
  }
  function dL(a) {
    for (var l = a.return; l !== null; ) {
      switch (l.tag) {
        case 24:
        case 3:
          var f = Mr();
          a = ba(f);
          var m = wa(l, a, f);
          m !== null && (Rr(m, l, f), yc(m, l, f)), l = { cache: xy() }, a.payload = l;
          return;
      }
      l = l.return;
    }
  }
  function fL(a, l, f) {
    var m = Mr();
    f = {
      lane: m,
      revertLane: 0,
      action: f,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, op(a) ? o2(l, f) : (f = dy(a, l, f, m), f !== null && (Rr(f, a, m), i2(f, l, m)));
  }
  function r2(a, l, f) {
    var m = Mr();
    _c(a, l, f, m);
  }
  function _c(a, l, f, m) {
    var w = {
      lane: m,
      revertLane: 0,
      action: f,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (op(a)) o2(l, w);
    else {
      var k = a.alternate;
      if (a.lanes === 0 && (k === null || k.lanes === 0) && (k = l.lastRenderedReducer, k !== null))
        try {
          var T = l.lastRenderedState, B = k(T, f);
          if (w.hasEagerState = !0, w.eagerState = B, Er(B, T))
            return Ff(a, l, w, 0), Rt === null && Bf(), !1;
        } catch {
        } finally {
        }
      if (f = dy(a, l, w, m), f !== null)
        return Rr(f, a, m), i2(f, l, m), !0;
    }
    return !1;
  }
  function qy(a, l, f, m) {
    if (m = {
      lane: 2,
      revertLane: kv(),
      action: m,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, op(a)) {
      if (l) throw Error(r(479));
    } else
      l = dy(
        a,
        f,
        m,
        2
      ), l !== null && Rr(l, a, 2);
  }
  function op(a) {
    var l = a.alternate;
    return a === Ze || l !== null && l === Ze;
  }
  function o2(a, l) {
    Al = Qf = !0;
    var f = a.pending;
    f === null ? l.next = l : (l.next = f.next, f.next = l), a.pending = l;
  }
  function i2(a, l, f) {
    if ((f & 4194048) !== 0) {
      var m = l.lanes;
      m &= a.pendingLanes, f |= m, l.lanes = f, xr(a, f);
    }
  }
  var ip = {
    readContext: Ln,
    use: ep,
    useCallback: en,
    useContext: en,
    useEffect: en,
    useImperativeHandle: en,
    useLayoutEffect: en,
    useInsertionEffect: en,
    useMemo: en,
    useReducer: en,
    useRef: en,
    useState: en,
    useDebugValue: en,
    useDeferredValue: en,
    useTransition: en,
    useSyncExternalStore: en,
    useId: en,
    useHostTransitionStatus: en,
    useFormState: en,
    useActionState: en,
    useOptimistic: en,
    useMemoCache: en,
    useCacheRefresh: en
  }, a2 = {
    readContext: Ln,
    use: ep,
    useCallback: function(a, l) {
      return cr().memoizedState = [
        a,
        l === void 0 ? null : l
      ], a;
    },
    useContext: Ln,
    useEffect: Hk,
    useImperativeHandle: function(a, l, f) {
      f = f != null ? f.concat([a]) : null, rp(
        4194308,
        4,
        Xk.bind(null, l, a),
        f
      );
    },
    useLayoutEffect: function(a, l) {
      return rp(4194308, 4, a, l);
    },
    useInsertionEffect: function(a, l) {
      rp(4, 2, a, l);
    },
    useMemo: function(a, l) {
      var f = cr();
      l = l === void 0 ? null : l;
      var m = a();
      if (Rs) {
        Ae(!0);
        try {
          a();
        } finally {
          Ae(!1);
        }
      }
      return f.memoizedState = [m, l], m;
    },
    useReducer: function(a, l, f) {
      var m = cr();
      if (f !== void 0) {
        var w = f(l);
        if (Rs) {
          Ae(!0);
          try {
            f(l);
          } finally {
            Ae(!1);
          }
        }
      } else w = l;
      return m.memoizedState = m.baseState = w, a = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: a,
        lastRenderedState: w
      }, m.queue = a, a = a.dispatch = fL.bind(
        null,
        Ze,
        a
      ), [m.memoizedState, a];
    },
    useRef: function(a) {
      var l = cr();
      return a = { current: a }, l.memoizedState = a;
    },
    useState: function(a) {
      a = By(a);
      var l = a.queue, f = r2.bind(null, Ze, l);
      return l.dispatch = f, [a.memoizedState, f];
    },
    useDebugValue: Uy,
    useDeferredValue: function(a, l) {
      var f = cr();
      return Hy(f, a, l);
    },
    useTransition: function() {
      var a = By(!1);
      return a = Qk.bind(
        null,
        Ze,
        a.queue,
        !0,
        !1
      ), cr().memoizedState = a, [!1, a];
    },
    useSyncExternalStore: function(a, l, f) {
      var m = Ze, w = cr();
      if (ht) {
        if (f === void 0)
          throw Error(r(407));
        f = f();
      } else {
        if (f = l(), Rt === null)
          throw Error(r(349));
        (st & 124) !== 0 || Ok(m, l, f);
      }
      w.memoizedState = f;
      var k = { value: f, getSnapshot: l };
      return w.queue = k, Hk(Nk.bind(null, m, k, a), [
        a
      ]), m.flags |= 2048, Ml(
        9,
        np(),
        Ak.bind(
          null,
          m,
          k,
          f,
          l
        ),
        null
      ), f;
    },
    useId: function() {
      var a = cr(), l = Rt.identifierPrefix;
      if (ht) {
        var f = Oi, m = Ci;
        f = (m & ~(1 << 32 - Ve(m) - 1)).toString(32) + f, l = "" + l + "R" + f, f = Jf++, 0 < f && (l += "H" + f.toString(32)), l += "";
      } else
        f = aL++, l = "" + l + "r" + f.toString(32) + "";
      return a.memoizedState = l;
    },
    useHostTransitionStatus: Yy,
    useFormState: Ik,
    useActionState: Ik,
    useOptimistic: function(a) {
      var l = cr();
      l.memoizedState = l.baseState = a;
      var f = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return l.queue = f, l = qy.bind(
        null,
        Ze,
        !0,
        f
      ), f.dispatch = l, [a, l];
    },
    useMemoCache: Ly,
    useCacheRefresh: function() {
      return cr().memoizedState = dL.bind(
        null,
        Ze
      );
    }
  }, s2 = {
    readContext: Ln,
    use: ep,
    useCallback: Gk,
    useContext: Ln,
    useEffect: $k,
    useImperativeHandle: Wk,
    useInsertionEffect: Yk,
    useLayoutEffect: qk,
    useMemo: Zk,
    useReducer: tp,
    useRef: Uk,
    useState: function() {
      return tp(Mi);
    },
    useDebugValue: Uy,
    useDeferredValue: function(a, l) {
      var f = un();
      return Kk(
        f,
        _t.memoizedState,
        a,
        l
      );
    },
    useTransition: function() {
      var a = tp(Mi)[0], l = un().memoizedState;
      return [
        typeof a == "boolean" ? a : xc(a),
        l
      ];
    },
    useSyncExternalStore: Ck,
    useId: t2,
    useHostTransitionStatus: Yy,
    useFormState: Vk,
    useActionState: Vk,
    useOptimistic: function(a, l) {
      var f = un();
      return jk(f, _t, a, l);
    },
    useMemoCache: Ly,
    useCacheRefresh: n2
  }, pL = {
    readContext: Ln,
    use: ep,
    useCallback: Gk,
    useContext: Ln,
    useEffect: $k,
    useImperativeHandle: Wk,
    useInsertionEffect: Yk,
    useLayoutEffect: qk,
    useMemo: Zk,
    useReducer: Vy,
    useRef: Uk,
    useState: function() {
      return Vy(Mi);
    },
    useDebugValue: Uy,
    useDeferredValue: function(a, l) {
      var f = un();
      return _t === null ? Hy(f, a, l) : Kk(
        f,
        _t.memoizedState,
        a,
        l
      );
    },
    useTransition: function() {
      var a = Vy(Mi)[0], l = un().memoizedState;
      return [
        typeof a == "boolean" ? a : xc(a),
        l
      ];
    },
    useSyncExternalStore: Ck,
    useId: t2,
    useHostTransitionStatus: Yy,
    useFormState: Fk,
    useActionState: Fk,
    useOptimistic: function(a, l) {
      var f = un();
      return _t !== null ? jk(f, _t, a, l) : (f.baseState = a, [a, f.queue.dispatch]);
    },
    useMemoCache: Ly,
    useCacheRefresh: n2
  }, Rl = null, kc = 0;
  function ap(a) {
    var l = kc;
    return kc += 1, Rl === null && (Rl = []), vk(Rl, a, l);
  }
  function Ec(a, l) {
    l = l.props.ref, a.ref = l !== void 0 ? l : null;
  }
  function sp(a, l) {
    throw l.$$typeof === h ? Error(r(525)) : (a = Object.prototype.toString.call(l), Error(
      r(
        31,
        a === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : a
      )
    ));
  }
  function l2(a) {
    var l = a._init;
    return l(a._payload);
  }
  function u2(a) {
    function l(J, Z) {
      if (a) {
        var te = J.deletions;
        te === null ? (J.deletions = [Z], J.flags |= 16) : te.push(Z);
      }
    }
    function f(J, Z) {
      if (!a) return null;
      for (; Z !== null; )
        l(J, Z), Z = Z.sibling;
      return null;
    }
    function m(J) {
      for (var Z = /* @__PURE__ */ new Map(); J !== null; )
        J.key !== null ? Z.set(J.key, J) : Z.set(J.index, J), J = J.sibling;
      return Z;
    }
    function w(J, Z) {
      return J = Ei(J, Z), J.index = 0, J.sibling = null, J;
    }
    function k(J, Z, te) {
      return J.index = te, a ? (te = J.alternate, te !== null ? (te = te.index, te < Z ? (J.flags |= 67108866, Z) : te) : (J.flags |= 67108866, Z)) : (J.flags |= 1048576, Z);
    }
    function T(J) {
      return a && J.alternate === null && (J.flags |= 67108866), J;
    }
    function B(J, Z, te, pe) {
      return Z === null || Z.tag !== 6 ? (Z = py(te, J.mode, pe), Z.return = J, Z) : (Z = w(Z, te), Z.return = J, Z);
    }
    function G(J, Z, te, pe) {
      var Oe = te.type;
      return Oe === b ? fe(
        J,
        Z,
        te.props.children,
        pe,
        te.key
      ) : Z !== null && (Z.elementType === Oe || typeof Oe == "object" && Oe !== null && Oe.$$typeof === I && l2(Oe) === Z.type) ? (Z = w(Z, te.props), Ec(Z, te), Z.return = J, Z) : (Z = Hf(
        te.type,
        te.key,
        te.props,
        null,
        J.mode,
        pe
      ), Ec(Z, te), Z.return = J, Z);
    }
    function ne(J, Z, te, pe) {
      return Z === null || Z.tag !== 4 || Z.stateNode.containerInfo !== te.containerInfo || Z.stateNode.implementation !== te.implementation ? (Z = hy(te, J.mode, pe), Z.return = J, Z) : (Z = w(Z, te.children || []), Z.return = J, Z);
    }
    function fe(J, Z, te, pe, Oe) {
      return Z === null || Z.tag !== 7 ? (Z = _s(
        te,
        J.mode,
        pe,
        Oe
      ), Z.return = J, Z) : (Z = w(Z, te), Z.return = J, Z);
    }
    function ge(J, Z, te) {
      if (typeof Z == "string" && Z !== "" || typeof Z == "number" || typeof Z == "bigint")
        return Z = py(
          "" + Z,
          J.mode,
          te
        ), Z.return = J, Z;
      if (typeof Z == "object" && Z !== null) {
        switch (Z.$$typeof) {
          case g:
            return te = Hf(
              Z.type,
              Z.key,
              Z.props,
              null,
              J.mode,
              te
            ), Ec(te, Z), te.return = J, te;
          case y:
            return Z = hy(
              Z,
              J.mode,
              te
            ), Z.return = J, Z;
          case I:
            var pe = Z._init;
            return Z = pe(Z._payload), ge(J, Z, te);
        }
        if (F(Z) || U(Z))
          return Z = _s(
            Z,
            J.mode,
            te,
            null
          ), Z.return = J, Z;
        if (typeof Z.then == "function")
          return ge(J, ap(Z), te);
        if (Z.$$typeof === C)
          return ge(
            J,
            Xf(J, Z),
            te
          );
        sp(J, Z);
      }
      return null;
    }
    function re(J, Z, te, pe) {
      var Oe = Z !== null ? Z.key : null;
      if (typeof te == "string" && te !== "" || typeof te == "number" || typeof te == "bigint")
        return Oe !== null ? null : B(J, Z, "" + te, pe);
      if (typeof te == "object" && te !== null) {
        switch (te.$$typeof) {
          case g:
            return te.key === Oe ? G(J, Z, te, pe) : null;
          case y:
            return te.key === Oe ? ne(J, Z, te, pe) : null;
          case I:
            return Oe = te._init, te = Oe(te._payload), re(J, Z, te, pe);
        }
        if (F(te) || U(te))
          return Oe !== null ? null : fe(J, Z, te, pe, null);
        if (typeof te.then == "function")
          return re(
            J,
            Z,
            ap(te),
            pe
          );
        if (te.$$typeof === C)
          return re(
            J,
            Z,
            Xf(J, te),
            pe
          );
        sp(J, te);
      }
      return null;
    }
    function oe(J, Z, te, pe, Oe) {
      if (typeof pe == "string" && pe !== "" || typeof pe == "number" || typeof pe == "bigint")
        return J = J.get(te) || null, B(Z, J, "" + pe, Oe);
      if (typeof pe == "object" && pe !== null) {
        switch (pe.$$typeof) {
          case g:
            return J = J.get(
              pe.key === null ? te : pe.key
            ) || null, G(Z, J, pe, Oe);
          case y:
            return J = J.get(
              pe.key === null ? te : pe.key
            ) || null, ne(Z, J, pe, Oe);
          case I:
            var Ke = pe._init;
            return pe = Ke(pe._payload), oe(
              J,
              Z,
              te,
              pe,
              Oe
            );
        }
        if (F(pe) || U(pe))
          return J = J.get(te) || null, fe(Z, J, pe, Oe, null);
        if (typeof pe.then == "function")
          return oe(
            J,
            Z,
            te,
            ap(pe),
            Oe
          );
        if (pe.$$typeof === C)
          return oe(
            J,
            Z,
            te,
            Xf(Z, pe),
            Oe
          );
        sp(Z, pe);
      }
      return null;
    }
    function He(J, Z, te, pe) {
      for (var Oe = null, Ke = null, Re = Z, Fe = Z = 0, _n = null; Re !== null && Fe < te.length; Fe++) {
        Re.index > Fe ? (_n = Re, Re = null) : _n = Re.sibling;
        var dt = re(
          J,
          Re,
          te[Fe],
          pe
        );
        if (dt === null) {
          Re === null && (Re = _n);
          break;
        }
        a && Re && dt.alternate === null && l(J, Re), Z = k(dt, Z, Fe), Ke === null ? Oe = dt : Ke.sibling = dt, Ke = dt, Re = _n;
      }
      if (Fe === te.length)
        return f(J, Re), ht && Es(J, Fe), Oe;
      if (Re === null) {
        for (; Fe < te.length; Fe++)
          Re = ge(J, te[Fe], pe), Re !== null && (Z = k(
            Re,
            Z,
            Fe
          ), Ke === null ? Oe = Re : Ke.sibling = Re, Ke = Re);
        return ht && Es(J, Fe), Oe;
      }
      for (Re = m(Re); Fe < te.length; Fe++)
        _n = oe(
          Re,
          J,
          Fe,
          te[Fe],
          pe
        ), _n !== null && (a && _n.alternate !== null && Re.delete(
          _n.key === null ? Fe : _n.key
        ), Z = k(
          _n,
          Z,
          Fe
        ), Ke === null ? Oe = _n : Ke.sibling = _n, Ke = _n);
      return a && Re.forEach(function(La) {
        return l(J, La);
      }), ht && Es(J, Fe), Oe;
    }
    function Be(J, Z, te, pe) {
      if (te == null) throw Error(r(151));
      for (var Oe = null, Ke = null, Re = Z, Fe = Z = 0, _n = null, dt = te.next(); Re !== null && !dt.done; Fe++, dt = te.next()) {
        Re.index > Fe ? (_n = Re, Re = null) : _n = Re.sibling;
        var La = re(J, Re, dt.value, pe);
        if (La === null) {
          Re === null && (Re = _n);
          break;
        }
        a && Re && La.alternate === null && l(J, Re), Z = k(La, Z, Fe), Ke === null ? Oe = La : Ke.sibling = La, Ke = La, Re = _n;
      }
      if (dt.done)
        return f(J, Re), ht && Es(J, Fe), Oe;
      if (Re === null) {
        for (; !dt.done; Fe++, dt = te.next())
          dt = ge(J, dt.value, pe), dt !== null && (Z = k(dt, Z, Fe), Ke === null ? Oe = dt : Ke.sibling = dt, Ke = dt);
        return ht && Es(J, Fe), Oe;
      }
      for (Re = m(Re); !dt.done; Fe++, dt = te.next())
        dt = oe(Re, J, Fe, dt.value, pe), dt !== null && (a && dt.alternate !== null && Re.delete(dt.key === null ? Fe : dt.key), Z = k(dt, Z, Fe), Ke === null ? Oe = dt : Ke.sibling = dt, Ke = dt);
      return a && Re.forEach(function(h9) {
        return l(J, h9);
      }), ht && Es(J, Fe), Oe;
    }
    function Et(J, Z, te, pe) {
      if (typeof te == "object" && te !== null && te.type === b && te.key === null && (te = te.props.children), typeof te == "object" && te !== null) {
        switch (te.$$typeof) {
          case g:
            e: {
              for (var Oe = te.key; Z !== null; ) {
                if (Z.key === Oe) {
                  if (Oe = te.type, Oe === b) {
                    if (Z.tag === 7) {
                      f(
                        J,
                        Z.sibling
                      ), pe = w(
                        Z,
                        te.props.children
                      ), pe.return = J, J = pe;
                      break e;
                    }
                  } else if (Z.elementType === Oe || typeof Oe == "object" && Oe !== null && Oe.$$typeof === I && l2(Oe) === Z.type) {
                    f(
                      J,
                      Z.sibling
                    ), pe = w(Z, te.props), Ec(pe, te), pe.return = J, J = pe;
                    break e;
                  }
                  f(J, Z);
                  break;
                } else l(J, Z);
                Z = Z.sibling;
              }
              te.type === b ? (pe = _s(
                te.props.children,
                J.mode,
                pe,
                te.key
              ), pe.return = J, J = pe) : (pe = Hf(
                te.type,
                te.key,
                te.props,
                null,
                J.mode,
                pe
              ), Ec(pe, te), pe.return = J, J = pe);
            }
            return T(J);
          case y:
            e: {
              for (Oe = te.key; Z !== null; ) {
                if (Z.key === Oe)
                  if (Z.tag === 4 && Z.stateNode.containerInfo === te.containerInfo && Z.stateNode.implementation === te.implementation) {
                    f(
                      J,
                      Z.sibling
                    ), pe = w(Z, te.children || []), pe.return = J, J = pe;
                    break e;
                  } else {
                    f(J, Z);
                    break;
                  }
                else l(J, Z);
                Z = Z.sibling;
              }
              pe = hy(te, J.mode, pe), pe.return = J, J = pe;
            }
            return T(J);
          case I:
            return Oe = te._init, te = Oe(te._payload), Et(
              J,
              Z,
              te,
              pe
            );
        }
        if (F(te))
          return He(
            J,
            Z,
            te,
            pe
          );
        if (U(te)) {
          if (Oe = U(te), typeof Oe != "function") throw Error(r(150));
          return te = Oe.call(te), Be(
            J,
            Z,
            te,
            pe
          );
        }
        if (typeof te.then == "function")
          return Et(
            J,
            Z,
            ap(te),
            pe
          );
        if (te.$$typeof === C)
          return Et(
            J,
            Z,
            Xf(J, te),
            pe
          );
        sp(J, te);
      }
      return typeof te == "string" && te !== "" || typeof te == "number" || typeof te == "bigint" ? (te = "" + te, Z !== null && Z.tag === 6 ? (f(J, Z.sibling), pe = w(Z, te), pe.return = J, J = pe) : (f(J, Z), pe = py(te, J.mode, pe), pe.return = J, J = pe), T(J)) : f(J, Z);
    }
    return function(J, Z, te, pe) {
      try {
        kc = 0;
        var Oe = Et(
          J,
          Z,
          te,
          pe
        );
        return Rl = null, Oe;
      } catch (Re) {
        if (Re === mc || Re === Gf) throw Re;
        var Ke = Cr(29, Re, null, J.mode);
        return Ke.lanes = pe, Ke.return = J, Ke;
      } finally {
      }
    };
  }
  var jl = u2(!0), c2 = u2(!1), no = X(null), Yo = null;
  function Sa(a) {
    var l = a.alternate;
    L(yn, yn.current & 1), L(no, a), Yo === null && (l === null || Ol.current !== null || l.memoizedState !== null) && (Yo = a);
  }
  function d2(a) {
    if (a.tag === 22) {
      if (L(yn, yn.current), L(no, a), Yo === null) {
        var l = a.alternate;
        l !== null && l.memoizedState !== null && (Yo = a);
      }
    } else _a();
  }
  function _a() {
    L(yn, yn.current), L(no, no.current);
  }
  function Ri(a) {
    K(no), Yo === a && (Yo = null), K(yn);
  }
  var yn = X(0);
  function lp(a) {
    for (var l = a; l !== null; ) {
      if (l.tag === 13) {
        var f = l.memoizedState;
        if (f !== null && (f = f.dehydrated, f === null || f.data === "$?" || Pv(f)))
          return l;
      } else if (l.tag === 19 && l.memoizedProps.revealOrder !== void 0) {
        if ((l.flags & 128) !== 0) return l;
      } else if (l.child !== null) {
        l.child.return = l, l = l.child;
        continue;
      }
      if (l === a) break;
      for (; l.sibling === null; ) {
        if (l.return === null || l.return === a) return null;
        l = l.return;
      }
      l.sibling.return = l.return, l = l.sibling;
    }
    return null;
  }
  function Xy(a, l, f, m) {
    l = a.memoizedState, f = f(m, l), f = f == null ? l : p({}, l, f), a.memoizedState = f, a.lanes === 0 && (a.updateQueue.baseState = f);
  }
  var Wy = {
    enqueueSetState: function(a, l, f) {
      a = a._reactInternals;
      var m = Mr(), w = ba(m);
      w.payload = l, f != null && (w.callback = f), l = wa(a, w, m), l !== null && (Rr(l, a, m), yc(l, a, m));
    },
    enqueueReplaceState: function(a, l, f) {
      a = a._reactInternals;
      var m = Mr(), w = ba(m);
      w.tag = 1, w.payload = l, f != null && (w.callback = f), l = wa(a, w, m), l !== null && (Rr(l, a, m), yc(l, a, m));
    },
    enqueueForceUpdate: function(a, l) {
      a = a._reactInternals;
      var f = Mr(), m = ba(f);
      m.tag = 2, l != null && (m.callback = l), l = wa(a, m, f), l !== null && (Rr(l, a, f), yc(l, a, f));
    }
  };
  function f2(a, l, f, m, w, k, T) {
    return a = a.stateNode, typeof a.shouldComponentUpdate == "function" ? a.shouldComponentUpdate(m, k, T) : l.prototype && l.prototype.isPureReactComponent ? !sc(f, m) || !sc(w, k) : !0;
  }
  function p2(a, l, f, m) {
    a = l.state, typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(f, m), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(f, m), l.state !== a && Wy.enqueueReplaceState(l, l.state, null);
  }
  function js(a, l) {
    var f = l;
    if ("ref" in l) {
      f = {};
      for (var m in l)
        m !== "ref" && (f[m] = l[m]);
    }
    if (a = a.defaultProps) {
      f === l && (f = p({}, f));
      for (var w in a)
        f[w] === void 0 && (f[w] = a[w]);
    }
    return f;
  }
  var up = typeof reportError == "function" ? reportError : function(a) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var l = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof a == "object" && a !== null && typeof a.message == "string" ? String(a.message) : String(a),
        error: a
      });
      if (!window.dispatchEvent(l)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", a);
      return;
    }
    console.error(a);
  };
  function h2(a) {
    up(a);
  }
  function m2(a) {
    console.error(a);
  }
  function g2(a) {
    up(a);
  }
  function cp(a, l) {
    try {
      var f = a.onUncaughtError;
      f(l.value, { componentStack: l.stack });
    } catch (m) {
      setTimeout(function() {
        throw m;
      });
    }
  }
  function y2(a, l, f) {
    try {
      var m = a.onCaughtError;
      m(f.value, {
        componentStack: f.stack,
        errorBoundary: l.tag === 1 ? l.stateNode : null
      });
    } catch (w) {
      setTimeout(function() {
        throw w;
      });
    }
  }
  function Gy(a, l, f) {
    return f = ba(f), f.tag = 3, f.payload = { element: null }, f.callback = function() {
      cp(a, l);
    }, f;
  }
  function v2(a) {
    return a = ba(a), a.tag = 3, a;
  }
  function b2(a, l, f, m) {
    var w = f.type.getDerivedStateFromError;
    if (typeof w == "function") {
      var k = m.value;
      a.payload = function() {
        return w(k);
      }, a.callback = function() {
        y2(l, f, m);
      };
    }
    var T = f.stateNode;
    T !== null && typeof T.componentDidCatch == "function" && (a.callback = function() {
      y2(l, f, m), typeof w != "function" && (Na === null ? Na = /* @__PURE__ */ new Set([this]) : Na.add(this));
      var B = m.stack;
      this.componentDidCatch(m.value, {
        componentStack: B !== null ? B : ""
      });
    });
  }
  function hL(a, l, f, m, w) {
    if (f.flags |= 32768, m !== null && typeof m == "object" && typeof m.then == "function") {
      if (l = f.alternate, l !== null && fc(
        l,
        f,
        w,
        !0
      ), f = no.current, f !== null) {
        switch (f.tag) {
          case 13:
            return Yo === null ? bv() : f.alternate === null && Zt === 0 && (Zt = 3), f.flags &= -257, f.flags |= 65536, f.lanes = w, m === ky ? f.flags |= 16384 : (l = f.updateQueue, l === null ? f.updateQueue = /* @__PURE__ */ new Set([m]) : l.add(m), xv(a, m, w)), !1;
          case 22:
            return f.flags |= 65536, m === ky ? f.flags |= 16384 : (l = f.updateQueue, l === null ? (l = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([m])
            }, f.updateQueue = l) : (f = l.retryQueue, f === null ? l.retryQueue = /* @__PURE__ */ new Set([m]) : f.add(m)), xv(a, m, w)), !1;
        }
        throw Error(r(435, f.tag));
      }
      return xv(a, m, w), bv(), !1;
    }
    if (ht)
      return l = no.current, l !== null ? ((l.flags & 65536) === 0 && (l.flags |= 256), l.flags |= 65536, l.lanes = w, m !== yy && (a = Error(r(422), { cause: m }), dc(Qr(a, f)))) : (m !== yy && (l = Error(r(423), {
        cause: m
      }), dc(
        Qr(l, f)
      )), a = a.current.alternate, a.flags |= 65536, w &= -w, a.lanes |= w, m = Qr(m, f), w = Gy(
        a.stateNode,
        m,
        w
      ), Oy(a, w), Zt !== 4 && (Zt = 2)), !1;
    var k = Error(r(520), { cause: m });
    if (k = Qr(k, f), jc === null ? jc = [k] : jc.push(k), Zt !== 4 && (Zt = 2), l === null) return !0;
    m = Qr(m, f), f = l;
    do {
      switch (f.tag) {
        case 3:
          return f.flags |= 65536, a = w & -w, f.lanes |= a, a = Gy(f.stateNode, m, a), Oy(f, a), !1;
        case 1:
          if (l = f.type, k = f.stateNode, (f.flags & 128) === 0 && (typeof l.getDerivedStateFromError == "function" || k !== null && typeof k.componentDidCatch == "function" && (Na === null || !Na.has(k))))
            return f.flags |= 65536, w &= -w, f.lanes |= w, w = v2(w), b2(
              w,
              a,
              f,
              m
            ), Oy(f, w), !1;
      }
      f = f.return;
    } while (f !== null);
    return !1;
  }
  var w2 = Error(r(461)), xn = !1;
  function Nn(a, l, f, m) {
    l.child = a === null ? c2(l, null, f, m) : jl(
      l,
      a.child,
      f,
      m
    );
  }
  function x2(a, l, f, m, w) {
    f = f.render;
    var k = l.ref;
    if ("ref" in m) {
      var T = {};
      for (var B in m)
        B !== "ref" && (T[B] = m[B]);
    } else T = m;
    return Ns(l), m = jy(
      a,
      l,
      f,
      T,
      k,
      w
    ), B = zy(), a !== null && !xn ? (Ty(a, l, w), ji(a, l, w)) : (ht && B && my(l), l.flags |= 1, Nn(a, l, m, w), l.child);
  }
  function S2(a, l, f, m, w) {
    if (a === null) {
      var k = f.type;
      return typeof k == "function" && !fy(k) && k.defaultProps === void 0 && f.compare === null ? (l.tag = 15, l.type = k, _2(
        a,
        l,
        k,
        m,
        w
      )) : (a = Hf(
        f.type,
        null,
        m,
        l,
        l.mode,
        w
      ), a.ref = l.ref, a.return = l, l.child = a);
    }
    if (k = a.child, !rv(a, w)) {
      var T = k.memoizedProps;
      if (f = f.compare, f = f !== null ? f : sc, f(T, m) && a.ref === l.ref)
        return ji(a, l, w);
    }
    return l.flags |= 1, a = Ei(k, m), a.ref = l.ref, a.return = l, l.child = a;
  }
  function _2(a, l, f, m, w) {
    if (a !== null) {
      var k = a.memoizedProps;
      if (sc(k, m) && a.ref === l.ref)
        if (xn = !1, l.pendingProps = m = k, rv(a, w))
          (a.flags & 131072) !== 0 && (xn = !0);
        else
          return l.lanes = a.lanes, ji(a, l, w);
    }
    return Zy(
      a,
      l,
      f,
      m,
      w
    );
  }
  function k2(a, l, f) {
    var m = l.pendingProps, w = m.children, k = a !== null ? a.memoizedState : null;
    if (m.mode === "hidden") {
      if ((l.flags & 128) !== 0) {
        if (m = k !== null ? k.baseLanes | f : f, a !== null) {
          for (w = l.child = a.child, k = 0; w !== null; )
            k = k | w.lanes | w.childLanes, w = w.sibling;
          l.childLanes = k & ~m;
        } else l.childLanes = 0, l.child = null;
        return E2(
          a,
          l,
          m,
          f
        );
      }
      if ((f & 536870912) !== 0)
        l.memoizedState = { baseLanes: 0, cachePool: null }, a !== null && Wf(
          l,
          k !== null ? k.cachePool : null
        ), k !== null ? _k(l, k) : Ny(), d2(l);
      else
        return l.lanes = l.childLanes = 536870912, E2(
          a,
          l,
          k !== null ? k.baseLanes | f : f,
          f
        );
    } else
      k !== null ? (Wf(l, k.cachePool), _k(l, k), _a(), l.memoizedState = null) : (a !== null && Wf(l, null), Ny(), _a());
    return Nn(a, l, w, f), l.child;
  }
  function E2(a, l, f, m) {
    var w = _y();
    return w = w === null ? null : { parent: gn._currentValue, pool: w }, l.memoizedState = {
      baseLanes: f,
      cachePool: w
    }, a !== null && Wf(l, null), Ny(), d2(l), a !== null && fc(a, l, m, !0), null;
  }
  function dp(a, l) {
    var f = l.ref;
    if (f === null)
      a !== null && a.ref !== null && (l.flags |= 4194816);
    else {
      if (typeof f != "function" && typeof f != "object")
        throw Error(r(284));
      (a === null || a.ref !== f) && (l.flags |= 4194816);
    }
  }
  function Zy(a, l, f, m, w) {
    return Ns(l), f = jy(
      a,
      l,
      f,
      m,
      void 0,
      w
    ), m = zy(), a !== null && !xn ? (Ty(a, l, w), ji(a, l, w)) : (ht && m && my(l), l.flags |= 1, Nn(a, l, f, w), l.child);
  }
  function C2(a, l, f, m, w, k) {
    return Ns(l), l.updateQueue = null, f = Ek(
      l,
      m,
      f,
      w
    ), kk(a), m = zy(), a !== null && !xn ? (Ty(a, l, k), ji(a, l, k)) : (ht && m && my(l), l.flags |= 1, Nn(a, l, f, k), l.child);
  }
  function O2(a, l, f, m, w) {
    if (Ns(l), l.stateNode === null) {
      var k = Sl, T = f.contextType;
      typeof T == "object" && T !== null && (k = Ln(T)), k = new f(m, k), l.memoizedState = k.state !== null && k.state !== void 0 ? k.state : null, k.updater = Wy, l.stateNode = k, k._reactInternals = l, k = l.stateNode, k.props = m, k.state = l.memoizedState, k.refs = {}, Ey(l), T = f.contextType, k.context = typeof T == "object" && T !== null ? Ln(T) : Sl, k.state = l.memoizedState, T = f.getDerivedStateFromProps, typeof T == "function" && (Xy(
        l,
        f,
        T,
        m
      ), k.state = l.memoizedState), typeof f.getDerivedStateFromProps == "function" || typeof k.getSnapshotBeforeUpdate == "function" || typeof k.UNSAFE_componentWillMount != "function" && typeof k.componentWillMount != "function" || (T = k.state, typeof k.componentWillMount == "function" && k.componentWillMount(), typeof k.UNSAFE_componentWillMount == "function" && k.UNSAFE_componentWillMount(), T !== k.state && Wy.enqueueReplaceState(k, k.state, null), bc(l, m, k, w), vc(), k.state = l.memoizedState), typeof k.componentDidMount == "function" && (l.flags |= 4194308), m = !0;
    } else if (a === null) {
      k = l.stateNode;
      var B = l.memoizedProps, G = js(f, B);
      k.props = G;
      var ne = k.context, fe = f.contextType;
      T = Sl, typeof fe == "object" && fe !== null && (T = Ln(fe));
      var ge = f.getDerivedStateFromProps;
      fe = typeof ge == "function" || typeof k.getSnapshotBeforeUpdate == "function", B = l.pendingProps !== B, fe || typeof k.UNSAFE_componentWillReceiveProps != "function" && typeof k.componentWillReceiveProps != "function" || (B || ne !== T) && p2(
        l,
        k,
        m,
        T
      ), va = !1;
      var re = l.memoizedState;
      k.state = re, bc(l, m, k, w), vc(), ne = l.memoizedState, B || re !== ne || va ? (typeof ge == "function" && (Xy(
        l,
        f,
        ge,
        m
      ), ne = l.memoizedState), (G = va || f2(
        l,
        f,
        G,
        m,
        re,
        ne,
        T
      )) ? (fe || typeof k.UNSAFE_componentWillMount != "function" && typeof k.componentWillMount != "function" || (typeof k.componentWillMount == "function" && k.componentWillMount(), typeof k.UNSAFE_componentWillMount == "function" && k.UNSAFE_componentWillMount()), typeof k.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof k.componentDidMount == "function" && (l.flags |= 4194308), l.memoizedProps = m, l.memoizedState = ne), k.props = m, k.state = ne, k.context = T, m = G) : (typeof k.componentDidMount == "function" && (l.flags |= 4194308), m = !1);
    } else {
      k = l.stateNode, Cy(a, l), T = l.memoizedProps, fe = js(f, T), k.props = fe, ge = l.pendingProps, re = k.context, ne = f.contextType, G = Sl, typeof ne == "object" && ne !== null && (G = Ln(ne)), B = f.getDerivedStateFromProps, (ne = typeof B == "function" || typeof k.getSnapshotBeforeUpdate == "function") || typeof k.UNSAFE_componentWillReceiveProps != "function" && typeof k.componentWillReceiveProps != "function" || (T !== ge || re !== G) && p2(
        l,
        k,
        m,
        G
      ), va = !1, re = l.memoizedState, k.state = re, bc(l, m, k, w), vc();
      var oe = l.memoizedState;
      T !== ge || re !== oe || va || a !== null && a.dependencies !== null && qf(a.dependencies) ? (typeof B == "function" && (Xy(
        l,
        f,
        B,
        m
      ), oe = l.memoizedState), (fe = va || f2(
        l,
        f,
        fe,
        m,
        re,
        oe,
        G
      ) || a !== null && a.dependencies !== null && qf(a.dependencies)) ? (ne || typeof k.UNSAFE_componentWillUpdate != "function" && typeof k.componentWillUpdate != "function" || (typeof k.componentWillUpdate == "function" && k.componentWillUpdate(m, oe, G), typeof k.UNSAFE_componentWillUpdate == "function" && k.UNSAFE_componentWillUpdate(
        m,
        oe,
        G
      )), typeof k.componentDidUpdate == "function" && (l.flags |= 4), typeof k.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof k.componentDidUpdate != "function" || T === a.memoizedProps && re === a.memoizedState || (l.flags |= 4), typeof k.getSnapshotBeforeUpdate != "function" || T === a.memoizedProps && re === a.memoizedState || (l.flags |= 1024), l.memoizedProps = m, l.memoizedState = oe), k.props = m, k.state = oe, k.context = G, m = fe) : (typeof k.componentDidUpdate != "function" || T === a.memoizedProps && re === a.memoizedState || (l.flags |= 4), typeof k.getSnapshotBeforeUpdate != "function" || T === a.memoizedProps && re === a.memoizedState || (l.flags |= 1024), m = !1);
    }
    return k = m, dp(a, l), m = (l.flags & 128) !== 0, k || m ? (k = l.stateNode, f = m && typeof f.getDerivedStateFromError != "function" ? null : k.render(), l.flags |= 1, a !== null && m ? (l.child = jl(
      l,
      a.child,
      null,
      w
    ), l.child = jl(
      l,
      null,
      f,
      w
    )) : Nn(a, l, f, w), l.memoizedState = k.state, a = l.child) : a = ji(
      a,
      l,
      w
    ), a;
  }
  function A2(a, l, f, m) {
    return cc(), l.flags |= 256, Nn(a, l, f, m), l.child;
  }
  var Ky = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function Qy(a) {
    return { baseLanes: a, cachePool: mk() };
  }
  function Jy(a, l, f) {
    return a = a !== null ? a.childLanes & ~f : 0, l && (a |= ro), a;
  }
  function N2(a, l, f) {
    var m = l.pendingProps, w = !1, k = (l.flags & 128) !== 0, T;
    if ((T = k) || (T = a !== null && a.memoizedState === null ? !1 : (yn.current & 2) !== 0), T && (w = !0, l.flags &= -129), T = (l.flags & 32) !== 0, l.flags &= -33, a === null) {
      if (ht) {
        if (w ? Sa(l) : _a(), ht) {
          var B = Gt, G;
          if (G = B) {
            e: {
              for (G = B, B = $o; G.nodeType !== 8; ) {
                if (!B) {
                  B = null;
                  break e;
                }
                if (G = _o(
                  G.nextSibling
                ), G === null) {
                  B = null;
                  break e;
                }
              }
              B = G;
            }
            B !== null ? (l.memoizedState = {
              dehydrated: B,
              treeContext: ks !== null ? { id: Ci, overflow: Oi } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, G = Cr(
              18,
              null,
              null,
              0
            ), G.stateNode = B, G.return = l, l.child = G, Kn = l, Gt = null, G = !0) : G = !1;
          }
          G || Os(l);
        }
        if (B = l.memoizedState, B !== null && (B = B.dehydrated, B !== null))
          return Pv(B) ? l.lanes = 32 : l.lanes = 536870912, null;
        Ri(l);
      }
      return B = m.children, m = m.fallback, w ? (_a(), w = l.mode, B = fp(
        { mode: "hidden", children: B },
        w
      ), m = _s(
        m,
        w,
        f,
        null
      ), B.return = l, m.return = l, B.sibling = m, l.child = B, w = l.child, w.memoizedState = Qy(f), w.childLanes = Jy(
        a,
        T,
        f
      ), l.memoizedState = Ky, m) : (Sa(l), ev(l, B));
    }
    if (G = a.memoizedState, G !== null && (B = G.dehydrated, B !== null)) {
      if (k)
        l.flags & 256 ? (Sa(l), l.flags &= -257, l = tv(
          a,
          l,
          f
        )) : l.memoizedState !== null ? (_a(), l.child = a.child, l.flags |= 128, l = null) : (_a(), w = m.fallback, B = l.mode, m = fp(
          { mode: "visible", children: m.children },
          B
        ), w = _s(
          w,
          B,
          f,
          null
        ), w.flags |= 2, m.return = l, w.return = l, m.sibling = w, l.child = m, jl(
          l,
          a.child,
          null,
          f
        ), m = l.child, m.memoizedState = Qy(f), m.childLanes = Jy(
          a,
          T,
          f
        ), l.memoizedState = Ky, l = w);
      else if (Sa(l), Pv(B)) {
        if (T = B.nextSibling && B.nextSibling.dataset, T) var ne = T.dgst;
        T = ne, m = Error(r(419)), m.stack = "", m.digest = T, dc({ value: m, source: null, stack: null }), l = tv(
          a,
          l,
          f
        );
      } else if (xn || fc(a, l, f, !1), T = (f & a.childLanes) !== 0, xn || T) {
        if (T = Rt, T !== null && (m = f & -f, m = (m & 42) !== 0 ? 1 : ps(m), m = (m & (T.suspendedLanes | f)) !== 0 ? 0 : m, m !== 0 && m !== G.retryLane))
          throw G.retryLane = m, xl(a, m), Rr(T, a, m), w2;
        B.data === "$?" || bv(), l = tv(
          a,
          l,
          f
        );
      } else
        B.data === "$?" ? (l.flags |= 192, l.child = a.child, l = null) : (a = G.treeContext, Gt = _o(
          B.nextSibling
        ), Kn = l, ht = !0, Cs = null, $o = !1, a !== null && (eo[to++] = Ci, eo[to++] = Oi, eo[to++] = ks, Ci = a.id, Oi = a.overflow, ks = l), l = ev(
          l,
          m.children
        ), l.flags |= 4096);
      return l;
    }
    return w ? (_a(), w = m.fallback, B = l.mode, G = a.child, ne = G.sibling, m = Ei(G, {
      mode: "hidden",
      children: m.children
    }), m.subtreeFlags = G.subtreeFlags & 65011712, ne !== null ? w = Ei(ne, w) : (w = _s(
      w,
      B,
      f,
      null
    ), w.flags |= 2), w.return = l, m.return = l, m.sibling = w, l.child = m, m = w, w = l.child, B = a.child.memoizedState, B === null ? B = Qy(f) : (G = B.cachePool, G !== null ? (ne = gn._currentValue, G = G.parent !== ne ? { parent: ne, pool: ne } : G) : G = mk(), B = {
      baseLanes: B.baseLanes | f,
      cachePool: G
    }), w.memoizedState = B, w.childLanes = Jy(
      a,
      T,
      f
    ), l.memoizedState = Ky, m) : (Sa(l), f = a.child, a = f.sibling, f = Ei(f, {
      mode: "visible",
      children: m.children
    }), f.return = l, f.sibling = null, a !== null && (T = l.deletions, T === null ? (l.deletions = [a], l.flags |= 16) : T.push(a)), l.child = f, l.memoizedState = null, f);
  }
  function ev(a, l) {
    return l = fp(
      { mode: "visible", children: l },
      a.mode
    ), l.return = a, a.child = l;
  }
  function fp(a, l) {
    return a = Cr(22, a, null, l), a.lanes = 0, a.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }, a;
  }
  function tv(a, l, f) {
    return jl(l, a.child, null, f), a = ev(
      l,
      l.pendingProps.children
    ), a.flags |= 2, l.memoizedState = null, a;
  }
  function M2(a, l, f) {
    a.lanes |= l;
    var m = a.alternate;
    m !== null && (m.lanes |= l), by(a.return, l, f);
  }
  function nv(a, l, f, m, w) {
    var k = a.memoizedState;
    k === null ? a.memoizedState = {
      isBackwards: l,
      rendering: null,
      renderingStartTime: 0,
      last: m,
      tail: f,
      tailMode: w
    } : (k.isBackwards = l, k.rendering = null, k.renderingStartTime = 0, k.last = m, k.tail = f, k.tailMode = w);
  }
  function R2(a, l, f) {
    var m = l.pendingProps, w = m.revealOrder, k = m.tail;
    if (Nn(a, l, m.children, f), m = yn.current, (m & 2) !== 0)
      m = m & 1 | 2, l.flags |= 128;
    else {
      if (a !== null && (a.flags & 128) !== 0)
        e: for (a = l.child; a !== null; ) {
          if (a.tag === 13)
            a.memoizedState !== null && M2(a, f, l);
          else if (a.tag === 19)
            M2(a, f, l);
          else if (a.child !== null) {
            a.child.return = a, a = a.child;
            continue;
          }
          if (a === l) break e;
          for (; a.sibling === null; ) {
            if (a.return === null || a.return === l)
              break e;
            a = a.return;
          }
          a.sibling.return = a.return, a = a.sibling;
        }
      m &= 1;
    }
    switch (L(yn, m), w) {
      case "forwards":
        for (f = l.child, w = null; f !== null; )
          a = f.alternate, a !== null && lp(a) === null && (w = f), f = f.sibling;
        f = w, f === null ? (w = l.child, l.child = null) : (w = f.sibling, f.sibling = null), nv(
          l,
          !1,
          w,
          f,
          k
        );
        break;
      case "backwards":
        for (f = null, w = l.child, l.child = null; w !== null; ) {
          if (a = w.alternate, a !== null && lp(a) === null) {
            l.child = w;
            break;
          }
          a = w.sibling, w.sibling = f, f = w, w = a;
        }
        nv(
          l,
          !0,
          f,
          null,
          k
        );
        break;
      case "together":
        nv(l, !1, null, null, void 0);
        break;
      default:
        l.memoizedState = null;
    }
    return l.child;
  }
  function ji(a, l, f) {
    if (a !== null && (l.dependencies = a.dependencies), Aa |= l.lanes, (f & l.childLanes) === 0)
      if (a !== null) {
        if (fc(
          a,
          l,
          f,
          !1
        ), (f & l.childLanes) === 0)
          return null;
      } else return null;
    if (a !== null && l.child !== a.child)
      throw Error(r(153));
    if (l.child !== null) {
      for (a = l.child, f = Ei(a, a.pendingProps), l.child = f, f.return = l; a.sibling !== null; )
        a = a.sibling, f = f.sibling = Ei(a, a.pendingProps), f.return = l;
      f.sibling = null;
    }
    return l.child;
  }
  function rv(a, l) {
    return (a.lanes & l) !== 0 ? !0 : (a = a.dependencies, !!(a !== null && qf(a)));
  }
  function mL(a, l, f) {
    switch (l.tag) {
      case 3:
        se(l, l.stateNode.containerInfo), ya(l, gn, a.memoizedState.cache), cc();
        break;
      case 27:
      case 5:
        _e(l);
        break;
      case 4:
        se(l, l.stateNode.containerInfo);
        break;
      case 10:
        ya(
          l,
          l.type,
          l.memoizedProps.value
        );
        break;
      case 13:
        var m = l.memoizedState;
        if (m !== null)
          return m.dehydrated !== null ? (Sa(l), l.flags |= 128, null) : (f & l.child.childLanes) !== 0 ? N2(a, l, f) : (Sa(l), a = ji(
            a,
            l,
            f
          ), a !== null ? a.sibling : null);
        Sa(l);
        break;
      case 19:
        var w = (a.flags & 128) !== 0;
        if (m = (f & l.childLanes) !== 0, m || (fc(
          a,
          l,
          f,
          !1
        ), m = (f & l.childLanes) !== 0), w) {
          if (m)
            return R2(
              a,
              l,
              f
            );
          l.flags |= 128;
        }
        if (w = l.memoizedState, w !== null && (w.rendering = null, w.tail = null, w.lastEffect = null), L(yn, yn.current), m) break;
        return null;
      case 22:
      case 23:
        return l.lanes = 0, k2(a, l, f);
      case 24:
        ya(l, gn, a.memoizedState.cache);
    }
    return ji(a, l, f);
  }
  function j2(a, l, f) {
    if (a !== null)
      if (a.memoizedProps !== l.pendingProps)
        xn = !0;
      else {
        if (!rv(a, f) && (l.flags & 128) === 0)
          return xn = !1, mL(
            a,
            l,
            f
          );
        xn = (a.flags & 131072) !== 0;
      }
    else
      xn = !1, ht && (l.flags & 1048576) !== 0 && lk(l, Yf, l.index);
    switch (l.lanes = 0, l.tag) {
      case 16:
        e: {
          a = l.pendingProps;
          var m = l.elementType, w = m._init;
          if (m = w(m._payload), l.type = m, typeof m == "function")
            fy(m) ? (a = js(m, a), l.tag = 1, l = O2(
              null,
              l,
              m,
              a,
              f
            )) : (l.tag = 0, l = Zy(
              null,
              l,
              m,
              a,
              f
            ));
          else {
            if (m != null) {
              if (w = m.$$typeof, w === N) {
                l.tag = 11, l = x2(
                  null,
                  l,
                  m,
                  a,
                  f
                );
                break e;
              } else if (w === j) {
                l.tag = 14, l = S2(
                  null,
                  l,
                  m,
                  a,
                  f
                );
                break e;
              }
            }
            throw l = D(m) || m, Error(r(306, l, ""));
          }
        }
        return l;
      case 0:
        return Zy(
          a,
          l,
          l.type,
          l.pendingProps,
          f
        );
      case 1:
        return m = l.type, w = js(
          m,
          l.pendingProps
        ), O2(
          a,
          l,
          m,
          w,
          f
        );
      case 3:
        e: {
          if (se(
            l,
            l.stateNode.containerInfo
          ), a === null) throw Error(r(387));
          m = l.pendingProps;
          var k = l.memoizedState;
          w = k.element, Cy(a, l), bc(l, m, null, f);
          var T = l.memoizedState;
          if (m = T.cache, ya(l, gn, m), m !== k.cache && wy(
            l,
            [gn],
            f,
            !0
          ), vc(), m = T.element, k.isDehydrated)
            if (k = {
              element: m,
              isDehydrated: !1,
              cache: T.cache
            }, l.updateQueue.baseState = k, l.memoizedState = k, l.flags & 256) {
              l = A2(
                a,
                l,
                m,
                f
              );
              break e;
            } else if (m !== w) {
              w = Qr(
                Error(r(424)),
                l
              ), dc(w), l = A2(
                a,
                l,
                m,
                f
              );
              break e;
            } else {
              switch (a = l.stateNode.containerInfo, a.nodeType) {
                case 9:
                  a = a.body;
                  break;
                default:
                  a = a.nodeName === "HTML" ? a.ownerDocument.body : a;
              }
              for (Gt = _o(a.firstChild), Kn = l, ht = !0, Cs = null, $o = !0, f = c2(
                l,
                null,
                m,
                f
              ), l.child = f; f; )
                f.flags = f.flags & -3 | 4096, f = f.sibling;
            }
          else {
            if (cc(), m === w) {
              l = ji(
                a,
                l,
                f
              );
              break e;
            }
            Nn(
              a,
              l,
              m,
              f
            );
          }
          l = l.child;
        }
        return l;
      case 26:
        return dp(a, l), a === null ? (f = PE(
          l.type,
          null,
          l.pendingProps,
          null
        )) ? l.memoizedState = f : ht || (f = l.type, a = l.pendingProps, m = Cp(
          le.current
        ).createElement(f), m[an] = l, m[wn] = a, Rn(m, f, a), Lt(m), l.stateNode = m) : l.memoizedState = PE(
          l.type,
          a.memoizedProps,
          l.pendingProps,
          a.memoizedState
        ), null;
      case 27:
        return _e(l), a === null && ht && (m = l.stateNode = zE(
          l.type,
          l.pendingProps,
          le.current
        ), Kn = l, $o = !0, w = Gt, ja(l.type) ? (Lv = w, Gt = _o(
          m.firstChild
        )) : Gt = w), Nn(
          a,
          l,
          l.pendingProps.children,
          f
        ), dp(a, l), a === null && (l.flags |= 4194304), l.child;
      case 5:
        return a === null && ht && ((w = m = Gt) && (m = HL(
          m,
          l.type,
          l.pendingProps,
          $o
        ), m !== null ? (l.stateNode = m, Kn = l, Gt = _o(
          m.firstChild
        ), $o = !1, w = !0) : w = !1), w || Os(l)), _e(l), w = l.type, k = l.pendingProps, T = a !== null ? a.memoizedProps : null, m = k.children, zv(w, k) ? m = null : T !== null && zv(w, T) && (l.flags |= 32), l.memoizedState !== null && (w = jy(
          a,
          l,
          sL,
          null,
          null,
          f
        ), Fc._currentValue = w), dp(a, l), Nn(a, l, m, f), l.child;
      case 6:
        return a === null && ht && ((a = f = Gt) && (f = $L(
          f,
          l.pendingProps,
          $o
        ), f !== null ? (l.stateNode = f, Kn = l, Gt = null, a = !0) : a = !1), a || Os(l)), null;
      case 13:
        return N2(a, l, f);
      case 4:
        return se(
          l,
          l.stateNode.containerInfo
        ), m = l.pendingProps, a === null ? l.child = jl(
          l,
          null,
          m,
          f
        ) : Nn(
          a,
          l,
          m,
          f
        ), l.child;
      case 11:
        return x2(
          a,
          l,
          l.type,
          l.pendingProps,
          f
        );
      case 7:
        return Nn(
          a,
          l,
          l.pendingProps,
          f
        ), l.child;
      case 8:
        return Nn(
          a,
          l,
          l.pendingProps.children,
          f
        ), l.child;
      case 12:
        return Nn(
          a,
          l,
          l.pendingProps.children,
          f
        ), l.child;
      case 10:
        return m = l.pendingProps, ya(l, l.type, m.value), Nn(
          a,
          l,
          m.children,
          f
        ), l.child;
      case 9:
        return w = l.type._context, m = l.pendingProps.children, Ns(l), w = Ln(w), m = m(w), l.flags |= 1, Nn(a, l, m, f), l.child;
      case 14:
        return S2(
          a,
          l,
          l.type,
          l.pendingProps,
          f
        );
      case 15:
        return _2(
          a,
          l,
          l.type,
          l.pendingProps,
          f
        );
      case 19:
        return R2(a, l, f);
      case 31:
        return m = l.pendingProps, f = l.mode, m = {
          mode: m.mode,
          children: m.children
        }, a === null ? (f = fp(
          m,
          f
        ), f.ref = l.ref, l.child = f, f.return = l, l = f) : (f = Ei(a.child, m), f.ref = l.ref, l.child = f, f.return = l, l = f), l;
      case 22:
        return k2(a, l, f);
      case 24:
        return Ns(l), m = Ln(gn), a === null ? (w = _y(), w === null && (w = Rt, k = xy(), w.pooledCache = k, k.refCount++, k !== null && (w.pooledCacheLanes |= f), w = k), l.memoizedState = {
          parent: m,
          cache: w
        }, Ey(l), ya(l, gn, w)) : ((a.lanes & f) !== 0 && (Cy(a, l), bc(l, null, null, f), vc()), w = a.memoizedState, k = l.memoizedState, w.parent !== m ? (w = { parent: m, cache: m }, l.memoizedState = w, l.lanes === 0 && (l.memoizedState = l.updateQueue.baseState = w), ya(l, gn, m)) : (m = k.cache, ya(l, gn, m), m !== w.cache && wy(
          l,
          [gn],
          f,
          !0
        ))), Nn(
          a,
          l,
          l.pendingProps.children,
          f
        ), l.child;
      case 29:
        throw l.pendingProps;
    }
    throw Error(r(156, l.tag));
  }
  function zi(a) {
    a.flags |= 4;
  }
  function z2(a, l) {
    if (l.type !== "stylesheet" || (l.state.loading & 4) !== 0)
      a.flags &= -16777217;
    else if (a.flags |= 16777216, !FE(l)) {
      if (l = no.current, l !== null && ((st & 4194048) === st ? Yo !== null : (st & 62914560) !== st && (st & 536870912) === 0 || l !== Yo))
        throw gc = ky, gk;
      a.flags |= 8192;
    }
  }
  function pp(a, l) {
    l !== null && (a.flags |= 4), a.flags & 16384 && (l = a.tag !== 22 ? da() : 536870912, a.lanes |= l, Pl |= l);
  }
  function Cc(a, l) {
    if (!ht)
      switch (a.tailMode) {
        case "hidden":
          l = a.tail;
          for (var f = null; l !== null; )
            l.alternate !== null && (f = l), l = l.sibling;
          f === null ? a.tail = null : f.sibling = null;
          break;
        case "collapsed":
          f = a.tail;
          for (var m = null; f !== null; )
            f.alternate !== null && (m = f), f = f.sibling;
          m === null ? l || a.tail === null ? a.tail = null : a.tail.sibling = null : m.sibling = null;
      }
  }
  function qt(a) {
    var l = a.alternate !== null && a.alternate.child === a.child, f = 0, m = 0;
    if (l)
      for (var w = a.child; w !== null; )
        f |= w.lanes | w.childLanes, m |= w.subtreeFlags & 65011712, m |= w.flags & 65011712, w.return = a, w = w.sibling;
    else
      for (w = a.child; w !== null; )
        f |= w.lanes | w.childLanes, m |= w.subtreeFlags, m |= w.flags, w.return = a, w = w.sibling;
    return a.subtreeFlags |= m, a.childLanes = f, l;
  }
  function gL(a, l, f) {
    var m = l.pendingProps;
    switch (gy(l), l.tag) {
      case 31:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return qt(l), null;
      case 1:
        return qt(l), null;
      case 3:
        return f = l.stateNode, m = null, a !== null && (m = a.memoizedState.cache), l.memoizedState.cache !== m && (l.flags |= 2048), Ni(gn), he(), f.pendingContext && (f.context = f.pendingContext, f.pendingContext = null), (a === null || a.child === null) && (uc(l) ? zi(l) : a === null || a.memoizedState.isDehydrated && (l.flags & 256) === 0 || (l.flags |= 1024, dk())), qt(l), null;
      case 26:
        return f = l.memoizedState, a === null ? (zi(l), f !== null ? (qt(l), z2(l, f)) : (qt(l), l.flags &= -16777217)) : f ? f !== a.memoizedState ? (zi(l), qt(l), z2(l, f)) : (qt(l), l.flags &= -16777217) : (a.memoizedProps !== m && zi(l), qt(l), l.flags &= -16777217), null;
      case 27:
        Se(l), f = le.current;
        var w = l.type;
        if (a !== null && l.stateNode != null)
          a.memoizedProps !== m && zi(l);
        else {
          if (!m) {
            if (l.stateNode === null)
              throw Error(r(166));
            return qt(l), null;
          }
          a = ee.current, uc(l) ? uk(l) : (a = zE(w, m, f), l.stateNode = a, zi(l));
        }
        return qt(l), null;
      case 5:
        if (Se(l), f = l.type, a !== null && l.stateNode != null)
          a.memoizedProps !== m && zi(l);
        else {
          if (!m) {
            if (l.stateNode === null)
              throw Error(r(166));
            return qt(l), null;
          }
          if (a = ee.current, uc(l))
            uk(l);
          else {
            switch (w = Cp(
              le.current
            ), a) {
              case 1:
                a = w.createElementNS(
                  "http://www.w3.org/2000/svg",
                  f
                );
                break;
              case 2:
                a = w.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  f
                );
                break;
              default:
                switch (f) {
                  case "svg":
                    a = w.createElementNS(
                      "http://www.w3.org/2000/svg",
                      f
                    );
                    break;
                  case "math":
                    a = w.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      f
                    );
                    break;
                  case "script":
                    a = w.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild);
                    break;
                  case "select":
                    a = typeof m.is == "string" ? w.createElement("select", { is: m.is }) : w.createElement("select"), m.multiple ? a.multiple = !0 : m.size && (a.size = m.size);
                    break;
                  default:
                    a = typeof m.is == "string" ? w.createElement(f, { is: m.is }) : w.createElement(f);
                }
            }
            a[an] = l, a[wn] = m;
            e: for (w = l.child; w !== null; ) {
              if (w.tag === 5 || w.tag === 6)
                a.appendChild(w.stateNode);
              else if (w.tag !== 4 && w.tag !== 27 && w.child !== null) {
                w.child.return = w, w = w.child;
                continue;
              }
              if (w === l) break e;
              for (; w.sibling === null; ) {
                if (w.return === null || w.return === l)
                  break e;
                w = w.return;
              }
              w.sibling.return = w.return, w = w.sibling;
            }
            l.stateNode = a;
            e: switch (Rn(a, f, m), f) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                a = !!m.autoFocus;
                break e;
              case "img":
                a = !0;
                break e;
              default:
                a = !1;
            }
            a && zi(l);
          }
        }
        return qt(l), l.flags &= -16777217, null;
      case 6:
        if (a && l.stateNode != null)
          a.memoizedProps !== m && zi(l);
        else {
          if (typeof m != "string" && l.stateNode === null)
            throw Error(r(166));
          if (a = le.current, uc(l)) {
            if (a = l.stateNode, f = l.memoizedProps, m = null, w = Kn, w !== null)
              switch (w.tag) {
                case 27:
                case 5:
                  m = w.memoizedProps;
              }
            a[an] = l, a = !!(a.nodeValue === f || m !== null && m.suppressHydrationWarning === !0 || CE(a.nodeValue, f)), a || Os(l);
          } else
            a = Cp(a).createTextNode(
              m
            ), a[an] = l, l.stateNode = a;
        }
        return qt(l), null;
      case 13:
        if (m = l.memoizedState, a === null || a.memoizedState !== null && a.memoizedState.dehydrated !== null) {
          if (w = uc(l), m !== null && m.dehydrated !== null) {
            if (a === null) {
              if (!w) throw Error(r(318));
              if (w = l.memoizedState, w = w !== null ? w.dehydrated : null, !w) throw Error(r(317));
              w[an] = l;
            } else
              cc(), (l.flags & 128) === 0 && (l.memoizedState = null), l.flags |= 4;
            qt(l), w = !1;
          } else
            w = dk(), a !== null && a.memoizedState !== null && (a.memoizedState.hydrationErrors = w), w = !0;
          if (!w)
            return l.flags & 256 ? (Ri(l), l) : (Ri(l), null);
        }
        if (Ri(l), (l.flags & 128) !== 0)
          return l.lanes = f, l;
        if (f = m !== null, a = a !== null && a.memoizedState !== null, f) {
          m = l.child, w = null, m.alternate !== null && m.alternate.memoizedState !== null && m.alternate.memoizedState.cachePool !== null && (w = m.alternate.memoizedState.cachePool.pool);
          var k = null;
          m.memoizedState !== null && m.memoizedState.cachePool !== null && (k = m.memoizedState.cachePool.pool), k !== w && (m.flags |= 2048);
        }
        return f !== a && f && (l.child.flags |= 8192), pp(l, l.updateQueue), qt(l), null;
      case 4:
        return he(), a === null && Av(l.stateNode.containerInfo), qt(l), null;
      case 10:
        return Ni(l.type), qt(l), null;
      case 19:
        if (K(yn), w = l.memoizedState, w === null) return qt(l), null;
        if (m = (l.flags & 128) !== 0, k = w.rendering, k === null)
          if (m) Cc(w, !1);
          else {
            if (Zt !== 0 || a !== null && (a.flags & 128) !== 0)
              for (a = l.child; a !== null; ) {
                if (k = lp(a), k !== null) {
                  for (l.flags |= 128, Cc(w, !1), a = k.updateQueue, l.updateQueue = a, pp(l, a), l.subtreeFlags = 0, a = f, f = l.child; f !== null; )
                    sk(f, a), f = f.sibling;
                  return L(
                    yn,
                    yn.current & 1 | 2
                  ), l.child;
                }
                a = a.sibling;
              }
            w.tail !== null && ft() > gp && (l.flags |= 128, m = !0, Cc(w, !1), l.lanes = 4194304);
          }
        else {
          if (!m)
            if (a = lp(k), a !== null) {
              if (l.flags |= 128, m = !0, a = a.updateQueue, l.updateQueue = a, pp(l, a), Cc(w, !0), w.tail === null && w.tailMode === "hidden" && !k.alternate && !ht)
                return qt(l), null;
            } else
              2 * ft() - w.renderingStartTime > gp && f !== 536870912 && (l.flags |= 128, m = !0, Cc(w, !1), l.lanes = 4194304);
          w.isBackwards ? (k.sibling = l.child, l.child = k) : (a = w.last, a !== null ? a.sibling = k : l.child = k, w.last = k);
        }
        return w.tail !== null ? (l = w.tail, w.rendering = l, w.tail = l.sibling, w.renderingStartTime = ft(), l.sibling = null, a = yn.current, L(yn, m ? a & 1 | 2 : a & 1), l) : (qt(l), null);
      case 22:
      case 23:
        return Ri(l), My(), m = l.memoizedState !== null, a !== null ? a.memoizedState !== null !== m && (l.flags |= 8192) : m && (l.flags |= 8192), m ? (f & 536870912) !== 0 && (l.flags & 128) === 0 && (qt(l), l.subtreeFlags & 6 && (l.flags |= 8192)) : qt(l), f = l.updateQueue, f !== null && pp(l, f.retryQueue), f = null, a !== null && a.memoizedState !== null && a.memoizedState.cachePool !== null && (f = a.memoizedState.cachePool.pool), m = null, l.memoizedState !== null && l.memoizedState.cachePool !== null && (m = l.memoizedState.cachePool.pool), m !== f && (l.flags |= 2048), a !== null && K(Ms), null;
      case 24:
        return f = null, a !== null && (f = a.memoizedState.cache), l.memoizedState.cache !== f && (l.flags |= 2048), Ni(gn), qt(l), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(r(156, l.tag));
  }
  function yL(a, l) {
    switch (gy(l), l.tag) {
      case 1:
        return a = l.flags, a & 65536 ? (l.flags = a & -65537 | 128, l) : null;
      case 3:
        return Ni(gn), he(), a = l.flags, (a & 65536) !== 0 && (a & 128) === 0 ? (l.flags = a & -65537 | 128, l) : null;
      case 26:
      case 27:
      case 5:
        return Se(l), null;
      case 13:
        if (Ri(l), a = l.memoizedState, a !== null && a.dehydrated !== null) {
          if (l.alternate === null)
            throw Error(r(340));
          cc();
        }
        return a = l.flags, a & 65536 ? (l.flags = a & -65537 | 128, l) : null;
      case 19:
        return K(yn), null;
      case 4:
        return he(), null;
      case 10:
        return Ni(l.type), null;
      case 22:
      case 23:
        return Ri(l), My(), a !== null && K(Ms), a = l.flags, a & 65536 ? (l.flags = a & -65537 | 128, l) : null;
      case 24:
        return Ni(gn), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function T2(a, l) {
    switch (gy(l), l.tag) {
      case 3:
        Ni(gn), he();
        break;
      case 26:
      case 27:
      case 5:
        Se(l);
        break;
      case 4:
        he();
        break;
      case 13:
        Ri(l);
        break;
      case 19:
        K(yn);
        break;
      case 10:
        Ni(l.type);
        break;
      case 22:
      case 23:
        Ri(l), My(), a !== null && K(Ms);
        break;
      case 24:
        Ni(gn);
    }
  }
  function Oc(a, l) {
    try {
      var f = l.updateQueue, m = f !== null ? f.lastEffect : null;
      if (m !== null) {
        var w = m.next;
        f = w;
        do {
          if ((f.tag & a) === a) {
            m = void 0;
            var k = f.create, T = f.inst;
            m = k(), T.destroy = m;
          }
          f = f.next;
        } while (f !== w);
      }
    } catch (B) {
      Ot(l, l.return, B);
    }
  }
  function ka(a, l, f) {
    try {
      var m = l.updateQueue, w = m !== null ? m.lastEffect : null;
      if (w !== null) {
        var k = w.next;
        m = k;
        do {
          if ((m.tag & a) === a) {
            var T = m.inst, B = T.destroy;
            if (B !== void 0) {
              T.destroy = void 0, w = l;
              var G = f, ne = B;
              try {
                ne();
              } catch (fe) {
                Ot(
                  w,
                  G,
                  fe
                );
              }
            }
          }
          m = m.next;
        } while (m !== k);
      }
    } catch (fe) {
      Ot(l, l.return, fe);
    }
  }
  function D2(a) {
    var l = a.updateQueue;
    if (l !== null) {
      var f = a.stateNode;
      try {
        Sk(l, f);
      } catch (m) {
        Ot(a, a.return, m);
      }
    }
  }
  function P2(a, l, f) {
    f.props = js(
      a.type,
      a.memoizedProps
    ), f.state = a.memoizedState;
    try {
      f.componentWillUnmount();
    } catch (m) {
      Ot(a, l, m);
    }
  }
  function Ac(a, l) {
    try {
      var f = a.ref;
      if (f !== null) {
        switch (a.tag) {
          case 26:
          case 27:
          case 5:
            var m = a.stateNode;
            break;
          case 30:
            m = a.stateNode;
            break;
          default:
            m = a.stateNode;
        }
        typeof f == "function" ? a.refCleanup = f(m) : f.current = m;
      }
    } catch (w) {
      Ot(a, l, w);
    }
  }
  function qo(a, l) {
    var f = a.ref, m = a.refCleanup;
    if (f !== null)
      if (typeof m == "function")
        try {
          m();
        } catch (w) {
          Ot(a, l, w);
        } finally {
          a.refCleanup = null, a = a.alternate, a != null && (a.refCleanup = null);
        }
      else if (typeof f == "function")
        try {
          f(null);
        } catch (w) {
          Ot(a, l, w);
        }
      else f.current = null;
  }
  function L2(a) {
    var l = a.type, f = a.memoizedProps, m = a.stateNode;
    try {
      e: switch (l) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          f.autoFocus && m.focus();
          break e;
        case "img":
          f.src ? m.src = f.src : f.srcSet && (m.srcset = f.srcSet);
      }
    } catch (w) {
      Ot(a, a.return, w);
    }
  }
  function ov(a, l, f) {
    try {
      var m = a.stateNode;
      IL(m, a.type, f, l), m[wn] = l;
    } catch (w) {
      Ot(a, a.return, w);
    }
  }
  function I2(a) {
    return a.tag === 5 || a.tag === 3 || a.tag === 26 || a.tag === 27 && ja(a.type) || a.tag === 4;
  }
  function iv(a) {
    e: for (; ; ) {
      for (; a.sibling === null; ) {
        if (a.return === null || I2(a.return)) return null;
        a = a.return;
      }
      for (a.sibling.return = a.return, a = a.sibling; a.tag !== 5 && a.tag !== 6 && a.tag !== 18; ) {
        if (a.tag === 27 && ja(a.type) || a.flags & 2 || a.child === null || a.tag === 4) continue e;
        a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2)) return a.stateNode;
    }
  }
  function av(a, l, f) {
    var m = a.tag;
    if (m === 5 || m === 6)
      a = a.stateNode, l ? (f.nodeType === 9 ? f.body : f.nodeName === "HTML" ? f.ownerDocument.body : f).insertBefore(a, l) : (l = f.nodeType === 9 ? f.body : f.nodeName === "HTML" ? f.ownerDocument.body : f, l.appendChild(a), f = f._reactRootContainer, f != null || l.onclick !== null || (l.onclick = Ep));
    else if (m !== 4 && (m === 27 && ja(a.type) && (f = a.stateNode, l = null), a = a.child, a !== null))
      for (av(a, l, f), a = a.sibling; a !== null; )
        av(a, l, f), a = a.sibling;
  }
  function hp(a, l, f) {
    var m = a.tag;
    if (m === 5 || m === 6)
      a = a.stateNode, l ? f.insertBefore(a, l) : f.appendChild(a);
    else if (m !== 4 && (m === 27 && ja(a.type) && (f = a.stateNode), a = a.child, a !== null))
      for (hp(a, l, f), a = a.sibling; a !== null; )
        hp(a, l, f), a = a.sibling;
  }
  function V2(a) {
    var l = a.stateNode, f = a.memoizedProps;
    try {
      for (var m = a.type, w = l.attributes; w.length; )
        l.removeAttributeNode(w[0]);
      Rn(l, m, f), l[an] = a, l[wn] = f;
    } catch (k) {
      Ot(a, a.return, k);
    }
  }
  var Ti = !1, tn = !1, sv = !1, B2 = typeof WeakSet == "function" ? WeakSet : Set, Sn = null;
  function vL(a, l) {
    if (a = a.containerInfo, Rv = jp, a = K_(a), iy(a)) {
      if ("selectionStart" in a)
        var f = {
          start: a.selectionStart,
          end: a.selectionEnd
        };
      else
        e: {
          f = (f = a.ownerDocument) && f.defaultView || window;
          var m = f.getSelection && f.getSelection();
          if (m && m.rangeCount !== 0) {
            f = m.anchorNode;
            var w = m.anchorOffset, k = m.focusNode;
            m = m.focusOffset;
            try {
              f.nodeType, k.nodeType;
            } catch {
              f = null;
              break e;
            }
            var T = 0, B = -1, G = -1, ne = 0, fe = 0, ge = a, re = null;
            t: for (; ; ) {
              for (var oe; ge !== f || w !== 0 && ge.nodeType !== 3 || (B = T + w), ge !== k || m !== 0 && ge.nodeType !== 3 || (G = T + m), ge.nodeType === 3 && (T += ge.nodeValue.length), (oe = ge.firstChild) !== null; )
                re = ge, ge = oe;
              for (; ; ) {
                if (ge === a) break t;
                if (re === f && ++ne === w && (B = T), re === k && ++fe === m && (G = T), (oe = ge.nextSibling) !== null) break;
                ge = re, re = ge.parentNode;
              }
              ge = oe;
            }
            f = B === -1 || G === -1 ? null : { start: B, end: G };
          } else f = null;
        }
      f = f || { start: 0, end: 0 };
    } else f = null;
    for (jv = { focusedElem: a, selectionRange: f }, jp = !1, Sn = l; Sn !== null; )
      if (l = Sn, a = l.child, (l.subtreeFlags & 1024) !== 0 && a !== null)
        a.return = l, Sn = a;
      else
        for (; Sn !== null; ) {
          switch (l = Sn, k = l.alternate, a = l.flags, l.tag) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((a & 1024) !== 0 && k !== null) {
                a = void 0, f = l, w = k.memoizedProps, k = k.memoizedState, m = f.stateNode;
                try {
                  var He = js(
                    f.type,
                    w,
                    f.elementType === f.type
                  );
                  a = m.getSnapshotBeforeUpdate(
                    He,
                    k
                  ), m.__reactInternalSnapshotBeforeUpdate = a;
                } catch (Be) {
                  Ot(
                    f,
                    f.return,
                    Be
                  );
                }
              }
              break;
            case 3:
              if ((a & 1024) !== 0) {
                if (a = l.stateNode.containerInfo, f = a.nodeType, f === 9)
                  Dv(a);
                else if (f === 1)
                  switch (a.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      Dv(a);
                      break;
                    default:
                      a.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((a & 1024) !== 0) throw Error(r(163));
          }
          if (a = l.sibling, a !== null) {
            a.return = l.return, Sn = a;
            break;
          }
          Sn = l.return;
        }
  }
  function F2(a, l, f) {
    var m = f.flags;
    switch (f.tag) {
      case 0:
      case 11:
      case 15:
        Ea(a, f), m & 4 && Oc(5, f);
        break;
      case 1:
        if (Ea(a, f), m & 4)
          if (a = f.stateNode, l === null)
            try {
              a.componentDidMount();
            } catch (T) {
              Ot(f, f.return, T);
            }
          else {
            var w = js(
              f.type,
              l.memoizedProps
            );
            l = l.memoizedState;
            try {
              a.componentDidUpdate(
                w,
                l,
                a.__reactInternalSnapshotBeforeUpdate
              );
            } catch (T) {
              Ot(
                f,
                f.return,
                T
              );
            }
          }
        m & 64 && D2(f), m & 512 && Ac(f, f.return);
        break;
      case 3:
        if (Ea(a, f), m & 64 && (a = f.updateQueue, a !== null)) {
          if (l = null, f.child !== null)
            switch (f.child.tag) {
              case 27:
              case 5:
                l = f.child.stateNode;
                break;
              case 1:
                l = f.child.stateNode;
            }
          try {
            Sk(a, l);
          } catch (T) {
            Ot(f, f.return, T);
          }
        }
        break;
      case 27:
        l === null && m & 4 && V2(f);
      case 26:
      case 5:
        Ea(a, f), l === null && m & 4 && L2(f), m & 512 && Ac(f, f.return);
        break;
      case 12:
        Ea(a, f);
        break;
      case 13:
        Ea(a, f), m & 4 && $2(a, f), m & 64 && (a = f.memoizedState, a !== null && (a = a.dehydrated, a !== null && (f = OL.bind(
          null,
          f
        ), YL(a, f))));
        break;
      case 22:
        if (m = f.memoizedState !== null || Ti, !m) {
          l = l !== null && l.memoizedState !== null || tn, w = Ti;
          var k = tn;
          Ti = m, (tn = l) && !k ? Ca(
            a,
            f,
            (f.subtreeFlags & 8772) !== 0
          ) : Ea(a, f), Ti = w, tn = k;
        }
        break;
      case 30:
        break;
      default:
        Ea(a, f);
    }
  }
  function U2(a) {
    var l = a.alternate;
    l !== null && (a.alternate = null, U2(l)), a.child = null, a.deletions = null, a.sibling = null, a.tag === 5 && (l = a.stateNode, l !== null && hs(l)), a.stateNode = null, a.return = null, a.dependencies = null, a.memoizedProps = null, a.memoizedState = null, a.pendingProps = null, a.stateNode = null, a.updateQueue = null;
  }
  var Vt = null, dr = !1;
  function Di(a, l, f) {
    for (f = f.child; f !== null; )
      H2(a, l, f), f = f.sibling;
  }
  function H2(a, l, f) {
    if (ye && typeof ye.onCommitFiberUnmount == "function")
      try {
        ye.onCommitFiberUnmount(ce, f);
      } catch {
      }
    switch (f.tag) {
      case 26:
        tn || qo(f, l), Di(
          a,
          l,
          f
        ), f.memoizedState ? f.memoizedState.count-- : f.stateNode && (f = f.stateNode, f.parentNode.removeChild(f));
        break;
      case 27:
        tn || qo(f, l);
        var m = Vt, w = dr;
        ja(f.type) && (Vt = f.stateNode, dr = !1), Di(
          a,
          l,
          f
        ), Lc(f.stateNode), Vt = m, dr = w;
        break;
      case 5:
        tn || qo(f, l);
      case 6:
        if (m = Vt, w = dr, Vt = null, Di(
          a,
          l,
          f
        ), Vt = m, dr = w, Vt !== null)
          if (dr)
            try {
              (Vt.nodeType === 9 ? Vt.body : Vt.nodeName === "HTML" ? Vt.ownerDocument.body : Vt).removeChild(f.stateNode);
            } catch (k) {
              Ot(
                f,
                l,
                k
              );
            }
          else
            try {
              Vt.removeChild(f.stateNode);
            } catch (k) {
              Ot(
                f,
                l,
                k
              );
            }
        break;
      case 18:
        Vt !== null && (dr ? (a = Vt, RE(
          a.nodeType === 9 ? a.body : a.nodeName === "HTML" ? a.ownerDocument.body : a,
          f.stateNode
        ), Yc(a)) : RE(Vt, f.stateNode));
        break;
      case 4:
        m = Vt, w = dr, Vt = f.stateNode.containerInfo, dr = !0, Di(
          a,
          l,
          f
        ), Vt = m, dr = w;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        tn || ka(2, f, l), tn || ka(4, f, l), Di(
          a,
          l,
          f
        );
        break;
      case 1:
        tn || (qo(f, l), m = f.stateNode, typeof m.componentWillUnmount == "function" && P2(
          f,
          l,
          m
        )), Di(
          a,
          l,
          f
        );
        break;
      case 21:
        Di(
          a,
          l,
          f
        );
        break;
      case 22:
        tn = (m = tn) || f.memoizedState !== null, Di(
          a,
          l,
          f
        ), tn = m;
        break;
      default:
        Di(
          a,
          l,
          f
        );
    }
  }
  function $2(a, l) {
    if (l.memoizedState === null && (a = l.alternate, a !== null && (a = a.memoizedState, a !== null && (a = a.dehydrated, a !== null))))
      try {
        Yc(a);
      } catch (f) {
        Ot(l, l.return, f);
      }
  }
  function bL(a) {
    switch (a.tag) {
      case 13:
      case 19:
        var l = a.stateNode;
        return l === null && (l = a.stateNode = new B2()), l;
      case 22:
        return a = a.stateNode, l = a._retryCache, l === null && (l = a._retryCache = new B2()), l;
      default:
        throw Error(r(435, a.tag));
    }
  }
  function lv(a, l) {
    var f = bL(a);
    l.forEach(function(m) {
      var w = AL.bind(null, a, m);
      f.has(m) || (f.add(m), m.then(w, w));
    });
  }
  function Or(a, l) {
    var f = l.deletions;
    if (f !== null)
      for (var m = 0; m < f.length; m++) {
        var w = f[m], k = a, T = l, B = T;
        e: for (; B !== null; ) {
          switch (B.tag) {
            case 27:
              if (ja(B.type)) {
                Vt = B.stateNode, dr = !1;
                break e;
              }
              break;
            case 5:
              Vt = B.stateNode, dr = !1;
              break e;
            case 3:
            case 4:
              Vt = B.stateNode.containerInfo, dr = !0;
              break e;
          }
          B = B.return;
        }
        if (Vt === null) throw Error(r(160));
        H2(k, T, w), Vt = null, dr = !1, k = w.alternate, k !== null && (k.return = null), w.return = null;
      }
    if (l.subtreeFlags & 13878)
      for (l = l.child; l !== null; )
        Y2(l, a), l = l.sibling;
  }
  var So = null;
  function Y2(a, l) {
    var f = a.alternate, m = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Or(l, a), Ar(a), m & 4 && (ka(3, a, a.return), Oc(3, a), ka(5, a, a.return));
        break;
      case 1:
        Or(l, a), Ar(a), m & 512 && (tn || f === null || qo(f, f.return)), m & 64 && Ti && (a = a.updateQueue, a !== null && (m = a.callbacks, m !== null && (f = a.shared.hiddenCallbacks, a.shared.hiddenCallbacks = f === null ? m : f.concat(m))));
        break;
      case 26:
        var w = So;
        if (Or(l, a), Ar(a), m & 512 && (tn || f === null || qo(f, f.return)), m & 4) {
          var k = f !== null ? f.memoizedState : null;
          if (m = a.memoizedState, f === null)
            if (m === null)
              if (a.stateNode === null) {
                e: {
                  m = a.type, f = a.memoizedProps, w = w.ownerDocument || w;
                  t: switch (m) {
                    case "title":
                      k = w.getElementsByTagName("title")[0], (!k || k[Pn] || k[an] || k.namespaceURI === "http://www.w3.org/2000/svg" || k.hasAttribute("itemprop")) && (k = w.createElement(m), w.head.insertBefore(
                        k,
                        w.querySelector("head > title")
                      )), Rn(k, m, f), k[an] = a, Lt(k), m = k;
                      break e;
                    case "link":
                      var T = VE(
                        "link",
                        "href",
                        w
                      ).get(m + (f.href || ""));
                      if (T) {
                        for (var B = 0; B < T.length; B++)
                          if (k = T[B], k.getAttribute("href") === (f.href == null || f.href === "" ? null : f.href) && k.getAttribute("rel") === (f.rel == null ? null : f.rel) && k.getAttribute("title") === (f.title == null ? null : f.title) && k.getAttribute("crossorigin") === (f.crossOrigin == null ? null : f.crossOrigin)) {
                            T.splice(B, 1);
                            break t;
                          }
                      }
                      k = w.createElement(m), Rn(k, m, f), w.head.appendChild(k);
                      break;
                    case "meta":
                      if (T = VE(
                        "meta",
                        "content",
                        w
                      ).get(m + (f.content || ""))) {
                        for (B = 0; B < T.length; B++)
                          if (k = T[B], k.getAttribute("content") === (f.content == null ? null : "" + f.content) && k.getAttribute("name") === (f.name == null ? null : f.name) && k.getAttribute("property") === (f.property == null ? null : f.property) && k.getAttribute("http-equiv") === (f.httpEquiv == null ? null : f.httpEquiv) && k.getAttribute("charset") === (f.charSet == null ? null : f.charSet)) {
                            T.splice(B, 1);
                            break t;
                          }
                      }
                      k = w.createElement(m), Rn(k, m, f), w.head.appendChild(k);
                      break;
                    default:
                      throw Error(r(468, m));
                  }
                  k[an] = a, Lt(k), m = k;
                }
                a.stateNode = m;
              } else
                BE(
                  w,
                  a.type,
                  a.stateNode
                );
            else
              a.stateNode = IE(
                w,
                m,
                a.memoizedProps
              );
          else
            k !== m ? (k === null ? f.stateNode !== null && (f = f.stateNode, f.parentNode.removeChild(f)) : k.count--, m === null ? BE(
              w,
              a.type,
              a.stateNode
            ) : IE(
              w,
              m,
              a.memoizedProps
            )) : m === null && a.stateNode !== null && ov(
              a,
              a.memoizedProps,
              f.memoizedProps
            );
        }
        break;
      case 27:
        Or(l, a), Ar(a), m & 512 && (tn || f === null || qo(f, f.return)), f !== null && m & 4 && ov(
          a,
          a.memoizedProps,
          f.memoizedProps
        );
        break;
      case 5:
        if (Or(l, a), Ar(a), m & 512 && (tn || f === null || qo(f, f.return)), a.flags & 32) {
          w = a.stateNode;
          try {
            Fo(w, "");
          } catch (oe) {
            Ot(a, a.return, oe);
          }
        }
        m & 4 && a.stateNode != null && (w = a.memoizedProps, ov(
          a,
          w,
          f !== null ? f.memoizedProps : w
        )), m & 1024 && (sv = !0);
        break;
      case 6:
        if (Or(l, a), Ar(a), m & 4) {
          if (a.stateNode === null)
            throw Error(r(162));
          m = a.memoizedProps, f = a.stateNode;
          try {
            f.nodeValue = m;
          } catch (oe) {
            Ot(a, a.return, oe);
          }
        }
        break;
      case 3:
        if (Np = null, w = So, So = Op(l.containerInfo), Or(l, a), So = w, Ar(a), m & 4 && f !== null && f.memoizedState.isDehydrated)
          try {
            Yc(l.containerInfo);
          } catch (oe) {
            Ot(a, a.return, oe);
          }
        sv && (sv = !1, q2(a));
        break;
      case 4:
        m = So, So = Op(
          a.stateNode.containerInfo
        ), Or(l, a), Ar(a), So = m;
        break;
      case 12:
        Or(l, a), Ar(a);
        break;
      case 13:
        Or(l, a), Ar(a), a.child.flags & 8192 && a.memoizedState !== null != (f !== null && f.memoizedState !== null) && (hv = ft()), m & 4 && (m = a.updateQueue, m !== null && (a.updateQueue = null, lv(a, m)));
        break;
      case 22:
        w = a.memoizedState !== null;
        var G = f !== null && f.memoizedState !== null, ne = Ti, fe = tn;
        if (Ti = ne || w, tn = fe || G, Or(l, a), tn = fe, Ti = ne, Ar(a), m & 8192)
          e: for (l = a.stateNode, l._visibility = w ? l._visibility & -2 : l._visibility | 1, w && (f === null || G || Ti || tn || zs(a)), f = null, l = a; ; ) {
            if (l.tag === 5 || l.tag === 26) {
              if (f === null) {
                G = f = l;
                try {
                  if (k = G.stateNode, w)
                    T = k.style, typeof T.setProperty == "function" ? T.setProperty("display", "none", "important") : T.display = "none";
                  else {
                    B = G.stateNode;
                    var ge = G.memoizedProps.style, re = ge != null && ge.hasOwnProperty("display") ? ge.display : null;
                    B.style.display = re == null || typeof re == "boolean" ? "" : ("" + re).trim();
                  }
                } catch (oe) {
                  Ot(G, G.return, oe);
                }
              }
            } else if (l.tag === 6) {
              if (f === null) {
                G = l;
                try {
                  G.stateNode.nodeValue = w ? "" : G.memoizedProps;
                } catch (oe) {
                  Ot(G, G.return, oe);
                }
              }
            } else if ((l.tag !== 22 && l.tag !== 23 || l.memoizedState === null || l === a) && l.child !== null) {
              l.child.return = l, l = l.child;
              continue;
            }
            if (l === a) break e;
            for (; l.sibling === null; ) {
              if (l.return === null || l.return === a) break e;
              f === l && (f = null), l = l.return;
            }
            f === l && (f = null), l.sibling.return = l.return, l = l.sibling;
          }
        m & 4 && (m = a.updateQueue, m !== null && (f = m.retryQueue, f !== null && (m.retryQueue = null, lv(a, f))));
        break;
      case 19:
        Or(l, a), Ar(a), m & 4 && (m = a.updateQueue, m !== null && (a.updateQueue = null, lv(a, m)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        Or(l, a), Ar(a);
    }
  }
  function Ar(a) {
    var l = a.flags;
    if (l & 2) {
      try {
        for (var f, m = a.return; m !== null; ) {
          if (I2(m)) {
            f = m;
            break;
          }
          m = m.return;
        }
        if (f == null) throw Error(r(160));
        switch (f.tag) {
          case 27:
            var w = f.stateNode, k = iv(a);
            hp(a, k, w);
            break;
          case 5:
            var T = f.stateNode;
            f.flags & 32 && (Fo(T, ""), f.flags &= -33);
            var B = iv(a);
            hp(a, B, T);
            break;
          case 3:
          case 4:
            var G = f.stateNode.containerInfo, ne = iv(a);
            av(
              a,
              ne,
              G
            );
            break;
          default:
            throw Error(r(161));
        }
      } catch (fe) {
        Ot(a, a.return, fe);
      }
      a.flags &= -3;
    }
    l & 4096 && (a.flags &= -4097);
  }
  function q2(a) {
    if (a.subtreeFlags & 1024)
      for (a = a.child; a !== null; ) {
        var l = a;
        q2(l), l.tag === 5 && l.flags & 1024 && l.stateNode.reset(), a = a.sibling;
      }
  }
  function Ea(a, l) {
    if (l.subtreeFlags & 8772)
      for (l = l.child; l !== null; )
        F2(a, l.alternate, l), l = l.sibling;
  }
  function zs(a) {
    for (a = a.child; a !== null; ) {
      var l = a;
      switch (l.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          ka(4, l, l.return), zs(l);
          break;
        case 1:
          qo(l, l.return);
          var f = l.stateNode;
          typeof f.componentWillUnmount == "function" && P2(
            l,
            l.return,
            f
          ), zs(l);
          break;
        case 27:
          Lc(l.stateNode);
        case 26:
        case 5:
          qo(l, l.return), zs(l);
          break;
        case 22:
          l.memoizedState === null && zs(l);
          break;
        case 30:
          zs(l);
          break;
        default:
          zs(l);
      }
      a = a.sibling;
    }
  }
  function Ca(a, l, f) {
    for (f = f && (l.subtreeFlags & 8772) !== 0, l = l.child; l !== null; ) {
      var m = l.alternate, w = a, k = l, T = k.flags;
      switch (k.tag) {
        case 0:
        case 11:
        case 15:
          Ca(
            w,
            k,
            f
          ), Oc(4, k);
          break;
        case 1:
          if (Ca(
            w,
            k,
            f
          ), m = k, w = m.stateNode, typeof w.componentDidMount == "function")
            try {
              w.componentDidMount();
            } catch (ne) {
              Ot(m, m.return, ne);
            }
          if (m = k, w = m.updateQueue, w !== null) {
            var B = m.stateNode;
            try {
              var G = w.shared.hiddenCallbacks;
              if (G !== null)
                for (w.shared.hiddenCallbacks = null, w = 0; w < G.length; w++)
                  xk(G[w], B);
            } catch (ne) {
              Ot(m, m.return, ne);
            }
          }
          f && T & 64 && D2(k), Ac(k, k.return);
          break;
        case 27:
          V2(k);
        case 26:
        case 5:
          Ca(
            w,
            k,
            f
          ), f && m === null && T & 4 && L2(k), Ac(k, k.return);
          break;
        case 12:
          Ca(
            w,
            k,
            f
          );
          break;
        case 13:
          Ca(
            w,
            k,
            f
          ), f && T & 4 && $2(w, k);
          break;
        case 22:
          k.memoizedState === null && Ca(
            w,
            k,
            f
          ), Ac(k, k.return);
          break;
        case 30:
          break;
        default:
          Ca(
            w,
            k,
            f
          );
      }
      l = l.sibling;
    }
  }
  function uv(a, l) {
    var f = null;
    a !== null && a.memoizedState !== null && a.memoizedState.cachePool !== null && (f = a.memoizedState.cachePool.pool), a = null, l.memoizedState !== null && l.memoizedState.cachePool !== null && (a = l.memoizedState.cachePool.pool), a !== f && (a != null && a.refCount++, f != null && pc(f));
  }
  function cv(a, l) {
    a = null, l.alternate !== null && (a = l.alternate.memoizedState.cache), l = l.memoizedState.cache, l !== a && (l.refCount++, a != null && pc(a));
  }
  function Xo(a, l, f, m) {
    if (l.subtreeFlags & 10256)
      for (l = l.child; l !== null; )
        X2(
          a,
          l,
          f,
          m
        ), l = l.sibling;
  }
  function X2(a, l, f, m) {
    var w = l.flags;
    switch (l.tag) {
      case 0:
      case 11:
      case 15:
        Xo(
          a,
          l,
          f,
          m
        ), w & 2048 && Oc(9, l);
        break;
      case 1:
        Xo(
          a,
          l,
          f,
          m
        );
        break;
      case 3:
        Xo(
          a,
          l,
          f,
          m
        ), w & 2048 && (a = null, l.alternate !== null && (a = l.alternate.memoizedState.cache), l = l.memoizedState.cache, l !== a && (l.refCount++, a != null && pc(a)));
        break;
      case 12:
        if (w & 2048) {
          Xo(
            a,
            l,
            f,
            m
          ), a = l.stateNode;
          try {
            var k = l.memoizedProps, T = k.id, B = k.onPostCommit;
            typeof B == "function" && B(
              T,
              l.alternate === null ? "mount" : "update",
              a.passiveEffectDuration,
              -0
            );
          } catch (G) {
            Ot(l, l.return, G);
          }
        } else
          Xo(
            a,
            l,
            f,
            m
          );
        break;
      case 13:
        Xo(
          a,
          l,
          f,
          m
        );
        break;
      case 23:
        break;
      case 22:
        k = l.stateNode, T = l.alternate, l.memoizedState !== null ? k._visibility & 2 ? Xo(
          a,
          l,
          f,
          m
        ) : Nc(a, l) : k._visibility & 2 ? Xo(
          a,
          l,
          f,
          m
        ) : (k._visibility |= 2, zl(
          a,
          l,
          f,
          m,
          (l.subtreeFlags & 10256) !== 0
        )), w & 2048 && uv(T, l);
        break;
      case 24:
        Xo(
          a,
          l,
          f,
          m
        ), w & 2048 && cv(l.alternate, l);
        break;
      default:
        Xo(
          a,
          l,
          f,
          m
        );
    }
  }
  function zl(a, l, f, m, w) {
    for (w = w && (l.subtreeFlags & 10256) !== 0, l = l.child; l !== null; ) {
      var k = a, T = l, B = f, G = m, ne = T.flags;
      switch (T.tag) {
        case 0:
        case 11:
        case 15:
          zl(
            k,
            T,
            B,
            G,
            w
          ), Oc(8, T);
          break;
        case 23:
          break;
        case 22:
          var fe = T.stateNode;
          T.memoizedState !== null ? fe._visibility & 2 ? zl(
            k,
            T,
            B,
            G,
            w
          ) : Nc(
            k,
            T
          ) : (fe._visibility |= 2, zl(
            k,
            T,
            B,
            G,
            w
          )), w && ne & 2048 && uv(
            T.alternate,
            T
          );
          break;
        case 24:
          zl(
            k,
            T,
            B,
            G,
            w
          ), w && ne & 2048 && cv(T.alternate, T);
          break;
        default:
          zl(
            k,
            T,
            B,
            G,
            w
          );
      }
      l = l.sibling;
    }
  }
  function Nc(a, l) {
    if (l.subtreeFlags & 10256)
      for (l = l.child; l !== null; ) {
        var f = a, m = l, w = m.flags;
        switch (m.tag) {
          case 22:
            Nc(f, m), w & 2048 && uv(
              m.alternate,
              m
            );
            break;
          case 24:
            Nc(f, m), w & 2048 && cv(m.alternate, m);
            break;
          default:
            Nc(f, m);
        }
        l = l.sibling;
      }
  }
  var Mc = 8192;
  function Tl(a) {
    if (a.subtreeFlags & Mc)
      for (a = a.child; a !== null; )
        W2(a), a = a.sibling;
  }
  function W2(a) {
    switch (a.tag) {
      case 26:
        Tl(a), a.flags & Mc && a.memoizedState !== null && o9(
          So,
          a.memoizedState,
          a.memoizedProps
        );
        break;
      case 5:
        Tl(a);
        break;
      case 3:
      case 4:
        var l = So;
        So = Op(a.stateNode.containerInfo), Tl(a), So = l;
        break;
      case 22:
        a.memoizedState === null && (l = a.alternate, l !== null && l.memoizedState !== null ? (l = Mc, Mc = 16777216, Tl(a), Mc = l) : Tl(a));
        break;
      default:
        Tl(a);
    }
  }
  function G2(a) {
    var l = a.alternate;
    if (l !== null && (a = l.child, a !== null)) {
      l.child = null;
      do
        l = a.sibling, a.sibling = null, a = l;
      while (a !== null);
    }
  }
  function Rc(a) {
    var l = a.deletions;
    if ((a.flags & 16) !== 0) {
      if (l !== null)
        for (var f = 0; f < l.length; f++) {
          var m = l[f];
          Sn = m, K2(
            m,
            a
          );
        }
      G2(a);
    }
    if (a.subtreeFlags & 10256)
      for (a = a.child; a !== null; )
        Z2(a), a = a.sibling;
  }
  function Z2(a) {
    switch (a.tag) {
      case 0:
      case 11:
      case 15:
        Rc(a), a.flags & 2048 && ka(9, a, a.return);
        break;
      case 3:
        Rc(a);
        break;
      case 12:
        Rc(a);
        break;
      case 22:
        var l = a.stateNode;
        a.memoizedState !== null && l._visibility & 2 && (a.return === null || a.return.tag !== 13) ? (l._visibility &= -3, mp(a)) : Rc(a);
        break;
      default:
        Rc(a);
    }
  }
  function mp(a) {
    var l = a.deletions;
    if ((a.flags & 16) !== 0) {
      if (l !== null)
        for (var f = 0; f < l.length; f++) {
          var m = l[f];
          Sn = m, K2(
            m,
            a
          );
        }
      G2(a);
    }
    for (a = a.child; a !== null; ) {
      switch (l = a, l.tag) {
        case 0:
        case 11:
        case 15:
          ka(8, l, l.return), mp(l);
          break;
        case 22:
          f = l.stateNode, f._visibility & 2 && (f._visibility &= -3, mp(l));
          break;
        default:
          mp(l);
      }
      a = a.sibling;
    }
  }
  function K2(a, l) {
    for (; Sn !== null; ) {
      var f = Sn;
      switch (f.tag) {
        case 0:
        case 11:
        case 15:
          ka(8, f, l);
          break;
        case 23:
        case 22:
          if (f.memoizedState !== null && f.memoizedState.cachePool !== null) {
            var m = f.memoizedState.cachePool.pool;
            m != null && m.refCount++;
          }
          break;
        case 24:
          pc(f.memoizedState.cache);
      }
      if (m = f.child, m !== null) m.return = f, Sn = m;
      else
        e: for (f = a; Sn !== null; ) {
          m = Sn;
          var w = m.sibling, k = m.return;
          if (U2(m), m === f) {
            Sn = null;
            break e;
          }
          if (w !== null) {
            w.return = k, Sn = w;
            break e;
          }
          Sn = k;
        }
    }
  }
  var wL = {
    getCacheForType: function(a) {
      var l = Ln(gn), f = l.data.get(a);
      return f === void 0 && (f = a(), l.data.set(a, f)), f;
    }
  }, xL = typeof WeakMap == "function" ? WeakMap : Map, wt = 0, Rt = null, et = null, st = 0, xt = 0, Nr = null, Oa = !1, Dl = !1, dv = !1, Pi = 0, Zt = 0, Aa = 0, Ts = 0, fv = 0, ro = 0, Pl = 0, jc = null, fr = null, pv = !1, hv = 0, gp = 1 / 0, yp = null, Na = null, Mn = 0, Ma = null, Ll = null, Il = 0, mv = 0, gv = null, Q2 = null, zc = 0, yv = null;
  function Mr() {
    if ((wt & 2) !== 0 && st !== 0)
      return st & -st;
    if (P.T !== null) {
      var a = El;
      return a !== 0 ? a : kv();
    }
    return Vo();
  }
  function J2() {
    ro === 0 && (ro = (st & 536870912) === 0 || ht ? fs() : 536870912);
    var a = no.current;
    return a !== null && (a.flags |= 32), ro;
  }
  function Rr(a, l, f) {
    (a === Rt && (xt === 2 || xt === 9) || a.cancelPendingCommit !== null) && (Vl(a, 0), Ra(
      a,
      st,
      ro,
      !1
    )), En(a, f), ((wt & 2) === 0 || a !== Rt) && (a === Rt && ((wt & 2) === 0 && (Ts |= f), Zt === 4 && Ra(
      a,
      st,
      ro,
      !1
    )), Wo(a));
  }
  function eE(a, l, f) {
    if ((wt & 6) !== 0) throw Error(r(327));
    var m = !f && (l & 124) === 0 && (l & a.expiredLanes) === 0 || Dn(a, l), w = m ? kL(a, l) : wv(a, l, !0), k = m;
    do {
      if (w === 0) {
        Dl && !m && Ra(a, l, 0, !1);
        break;
      } else {
        if (f = a.current.alternate, k && !SL(f)) {
          w = wv(a, l, !1), k = !1;
          continue;
        }
        if (w === 2) {
          if (k = l, a.errorRecoveryDisabledLanes & k)
            var T = 0;
          else
            T = a.pendingLanes & -536870913, T = T !== 0 ? T : T & 536870912 ? 536870912 : 0;
          if (T !== 0) {
            l = T;
            e: {
              var B = a;
              w = jc;
              var G = B.current.memoizedState.isDehydrated;
              if (G && (Vl(B, T).flags |= 256), T = wv(
                B,
                T,
                !1
              ), T !== 2) {
                if (dv && !G) {
                  B.errorRecoveryDisabledLanes |= k, Ts |= k, w = 4;
                  break e;
                }
                k = fr, fr = w, k !== null && (fr === null ? fr = k : fr.push.apply(
                  fr,
                  k
                ));
              }
              w = T;
            }
            if (k = !1, w !== 2) continue;
          }
        }
        if (w === 1) {
          Vl(a, 0), Ra(a, l, 0, !0);
          break;
        }
        e: {
          switch (m = a, k = w, k) {
            case 0:
            case 1:
              throw Error(r(345));
            case 4:
              if ((l & 4194048) !== l) break;
            case 6:
              Ra(
                m,
                l,
                ro,
                !Oa
              );
              break e;
            case 2:
              fr = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(r(329));
          }
          if ((l & 62914560) === l && (w = hv + 300 - ft(), 10 < w)) {
            if (Ra(
              m,
              l,
              ro,
              !Oa
            ), Wt(m, 0, !0) !== 0) break e;
            m.timeoutHandle = NE(
              tE.bind(
                null,
                m,
                f,
                fr,
                yp,
                pv,
                l,
                ro,
                Ts,
                Pl,
                Oa,
                k,
                2,
                -0,
                0
              ),
              w
            );
            break e;
          }
          tE(
            m,
            f,
            fr,
            yp,
            pv,
            l,
            ro,
            Ts,
            Pl,
            Oa,
            k,
            0,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    Wo(a);
  }
  function tE(a, l, f, m, w, k, T, B, G, ne, fe, ge, re, oe) {
    if (a.timeoutHandle = -1, ge = l.subtreeFlags, (ge & 8192 || (ge & 16785408) === 16785408) && (Bc = { stylesheets: null, count: 0, unsuspend: r9 }, W2(l), ge = i9(), ge !== null)) {
      a.cancelPendingCommit = ge(
        lE.bind(
          null,
          a,
          l,
          k,
          f,
          m,
          w,
          T,
          B,
          G,
          fe,
          1,
          re,
          oe
        )
      ), Ra(a, k, T, !ne);
      return;
    }
    lE(
      a,
      l,
      k,
      f,
      m,
      w,
      T,
      B,
      G
    );
  }
  function SL(a) {
    for (var l = a; ; ) {
      var f = l.tag;
      if ((f === 0 || f === 11 || f === 15) && l.flags & 16384 && (f = l.updateQueue, f !== null && (f = f.stores, f !== null)))
        for (var m = 0; m < f.length; m++) {
          var w = f[m], k = w.getSnapshot;
          w = w.value;
          try {
            if (!Er(k(), w)) return !1;
          } catch {
            return !1;
          }
        }
      if (f = l.child, l.subtreeFlags & 16384 && f !== null)
        f.return = l, l = f;
      else {
        if (l === a) break;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === a) return !0;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
    }
    return !0;
  }
  function Ra(a, l, f, m) {
    l &= ~fv, l &= ~Ts, a.suspendedLanes |= l, a.pingedLanes &= ~l, m && (a.warmLanes |= l), m = a.expirationTimes;
    for (var w = l; 0 < w; ) {
      var k = 31 - Ve(w), T = 1 << k;
      m[k] = -1, w &= ~T;
    }
    f !== 0 && Lo(a, f, l);
  }
  function vp() {
    return (wt & 6) === 0 ? (Tc(0), !1) : !0;
  }
  function vv() {
    if (et !== null) {
      if (xt === 0)
        var a = et.return;
      else
        a = et, Ai = As = null, Dy(a), Rl = null, kc = 0, a = et;
      for (; a !== null; )
        T2(a.alternate, a), a = a.return;
      et = null;
    }
  }
  function Vl(a, l) {
    var f = a.timeoutHandle;
    f !== -1 && (a.timeoutHandle = -1, BL(f)), f = a.cancelPendingCommit, f !== null && (a.cancelPendingCommit = null, f()), vv(), Rt = a, et = f = Ei(a.current, null), st = l, xt = 0, Nr = null, Oa = !1, Dl = Dn(a, l), dv = !1, Pl = ro = fv = Ts = Aa = Zt = 0, fr = jc = null, pv = !1, (l & 8) !== 0 && (l |= l & 32);
    var m = a.entangledLanes;
    if (m !== 0)
      for (a = a.entanglements, m &= l; 0 < m; ) {
        var w = 31 - Ve(m), k = 1 << w;
        l |= a[w], m &= ~k;
      }
    return Pi = l, Bf(), f;
  }
  function nE(a, l) {
    Ze = null, P.H = ip, l === mc || l === Gf ? (l = bk(), xt = 3) : l === gk ? (l = bk(), xt = 4) : xt = l === w2 ? 8 : l !== null && typeof l == "object" && typeof l.then == "function" ? 6 : 1, Nr = l, et === null && (Zt = 1, cp(
      a,
      Qr(l, a.current)
    ));
  }
  function rE() {
    var a = P.H;
    return P.H = ip, a === null ? ip : a;
  }
  function oE() {
    var a = P.A;
    return P.A = wL, a;
  }
  function bv() {
    Zt = 4, Oa || (st & 4194048) !== st && no.current !== null || (Dl = !0), (Aa & 134217727) === 0 && (Ts & 134217727) === 0 || Rt === null || Ra(
      Rt,
      st,
      ro,
      !1
    );
  }
  function wv(a, l, f) {
    var m = wt;
    wt |= 2;
    var w = rE(), k = oE();
    (Rt !== a || st !== l) && (yp = null, Vl(a, l)), l = !1;
    var T = Zt;
    e: do
      try {
        if (xt !== 0 && et !== null) {
          var B = et, G = Nr;
          switch (xt) {
            case 8:
              vv(), T = 6;
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              no.current === null && (l = !0);
              var ne = xt;
              if (xt = 0, Nr = null, Bl(a, B, G, ne), f && Dl) {
                T = 0;
                break e;
              }
              break;
            default:
              ne = xt, xt = 0, Nr = null, Bl(a, B, G, ne);
          }
        }
        _L(), T = Zt;
        break;
      } catch (fe) {
        nE(a, fe);
      }
    while (!0);
    return l && a.shellSuspendCounter++, Ai = As = null, wt = m, P.H = w, P.A = k, et === null && (Rt = null, st = 0, Bf()), T;
  }
  function _L() {
    for (; et !== null; ) iE(et);
  }
  function kL(a, l) {
    var f = wt;
    wt |= 2;
    var m = rE(), w = oE();
    Rt !== a || st !== l ? (yp = null, gp = ft() + 500, Vl(a, l)) : Dl = Dn(
      a,
      l
    );
    e: do
      try {
        if (xt !== 0 && et !== null) {
          l = et;
          var k = Nr;
          t: switch (xt) {
            case 1:
              xt = 0, Nr = null, Bl(a, l, k, 1);
              break;
            case 2:
            case 9:
              if (yk(k)) {
                xt = 0, Nr = null, aE(l);
                break;
              }
              l = function() {
                xt !== 2 && xt !== 9 || Rt !== a || (xt = 7), Wo(a);
              }, k.then(l, l);
              break e;
            case 3:
              xt = 7;
              break e;
            case 4:
              xt = 5;
              break e;
            case 7:
              yk(k) ? (xt = 0, Nr = null, aE(l)) : (xt = 0, Nr = null, Bl(a, l, k, 7));
              break;
            case 5:
              var T = null;
              switch (et.tag) {
                case 26:
                  T = et.memoizedState;
                case 5:
                case 27:
                  var B = et;
                  if (!T || FE(T)) {
                    xt = 0, Nr = null;
                    var G = B.sibling;
                    if (G !== null) et = G;
                    else {
                      var ne = B.return;
                      ne !== null ? (et = ne, bp(ne)) : et = null;
                    }
                    break t;
                  }
              }
              xt = 0, Nr = null, Bl(a, l, k, 5);
              break;
            case 6:
              xt = 0, Nr = null, Bl(a, l, k, 6);
              break;
            case 8:
              vv(), Zt = 6;
              break e;
            default:
              throw Error(r(462));
          }
        }
        EL();
        break;
      } catch (fe) {
        nE(a, fe);
      }
    while (!0);
    return Ai = As = null, P.H = m, P.A = w, wt = f, et !== null ? 0 : (Rt = null, st = 0, Bf(), Zt);
  }
  function EL() {
    for (; et !== null && !ct(); )
      iE(et);
  }
  function iE(a) {
    var l = j2(a.alternate, a, Pi);
    a.memoizedProps = a.pendingProps, l === null ? bp(a) : et = l;
  }
  function aE(a) {
    var l = a, f = l.alternate;
    switch (l.tag) {
      case 15:
      case 0:
        l = C2(
          f,
          l,
          l.pendingProps,
          l.type,
          void 0,
          st
        );
        break;
      case 11:
        l = C2(
          f,
          l,
          l.pendingProps,
          l.type.render,
          l.ref,
          st
        );
        break;
      case 5:
        Dy(l);
      default:
        T2(f, l), l = et = sk(l, Pi), l = j2(f, l, Pi);
    }
    a.memoizedProps = a.pendingProps, l === null ? bp(a) : et = l;
  }
  function Bl(a, l, f, m) {
    Ai = As = null, Dy(l), Rl = null, kc = 0;
    var w = l.return;
    try {
      if (hL(
        a,
        w,
        l,
        f,
        st
      )) {
        Zt = 1, cp(
          a,
          Qr(f, a.current)
        ), et = null;
        return;
      }
    } catch (k) {
      if (w !== null) throw et = w, k;
      Zt = 1, cp(
        a,
        Qr(f, a.current)
      ), et = null;
      return;
    }
    l.flags & 32768 ? (ht || m === 1 ? a = !0 : Dl || (st & 536870912) !== 0 ? a = !1 : (Oa = a = !0, (m === 2 || m === 9 || m === 3 || m === 6) && (m = no.current, m !== null && m.tag === 13 && (m.flags |= 16384))), sE(l, a)) : bp(l);
  }
  function bp(a) {
    var l = a;
    do {
      if ((l.flags & 32768) !== 0) {
        sE(
          l,
          Oa
        );
        return;
      }
      a = l.return;
      var f = gL(
        l.alternate,
        l,
        Pi
      );
      if (f !== null) {
        et = f;
        return;
      }
      if (l = l.sibling, l !== null) {
        et = l;
        return;
      }
      et = l = a;
    } while (l !== null);
    Zt === 0 && (Zt = 5);
  }
  function sE(a, l) {
    do {
      var f = yL(a.alternate, a);
      if (f !== null) {
        f.flags &= 32767, et = f;
        return;
      }
      if (f = a.return, f !== null && (f.flags |= 32768, f.subtreeFlags = 0, f.deletions = null), !l && (a = a.sibling, a !== null)) {
        et = a;
        return;
      }
      et = a = f;
    } while (a !== null);
    Zt = 6, et = null;
  }
  function lE(a, l, f, m, w, k, T, B, G) {
    a.cancelPendingCommit = null;
    do
      wp();
    while (Mn !== 0);
    if ((wt & 6) !== 0) throw Error(r(327));
    if (l !== null) {
      if (l === a.current) throw Error(r(177));
      if (k = l.lanes | l.childLanes, k |= cy, mo(
        a,
        f,
        k,
        T,
        B,
        G
      ), a === Rt && (et = Rt = null, st = 0), Ll = l, Ma = a, Il = f, mv = k, gv = w, Q2 = m, (l.subtreeFlags & 10256) !== 0 || (l.flags & 10256) !== 0 ? (a.callbackNode = null, a.callbackPriority = 0, NL(De, function() {
        return pE(), null;
      })) : (a.callbackNode = null, a.callbackPriority = 0), m = (l.flags & 13878) !== 0, (l.subtreeFlags & 13878) !== 0 || m) {
        m = P.T, P.T = null, w = H.p, H.p = 2, T = wt, wt |= 4;
        try {
          vL(a, l, f);
        } finally {
          wt = T, H.p = w, P.T = m;
        }
      }
      Mn = 1, uE(), cE(), dE();
    }
  }
  function uE() {
    if (Mn === 1) {
      Mn = 0;
      var a = Ma, l = Ll, f = (l.flags & 13878) !== 0;
      if ((l.subtreeFlags & 13878) !== 0 || f) {
        f = P.T, P.T = null;
        var m = H.p;
        H.p = 2;
        var w = wt;
        wt |= 4;
        try {
          Y2(l, a);
          var k = jv, T = K_(a.containerInfo), B = k.focusedElem, G = k.selectionRange;
          if (T !== B && B && B.ownerDocument && Z_(
            B.ownerDocument.documentElement,
            B
          )) {
            if (G !== null && iy(B)) {
              var ne = G.start, fe = G.end;
              if (fe === void 0 && (fe = ne), "selectionStart" in B)
                B.selectionStart = ne, B.selectionEnd = Math.min(
                  fe,
                  B.value.length
                );
              else {
                var ge = B.ownerDocument || document, re = ge && ge.defaultView || window;
                if (re.getSelection) {
                  var oe = re.getSelection(), He = B.textContent.length, Be = Math.min(G.start, He), Et = G.end === void 0 ? Be : Math.min(G.end, He);
                  !oe.extend && Be > Et && (T = Et, Et = Be, Be = T);
                  var J = G_(
                    B,
                    Be
                  ), Z = G_(
                    B,
                    Et
                  );
                  if (J && Z && (oe.rangeCount !== 1 || oe.anchorNode !== J.node || oe.anchorOffset !== J.offset || oe.focusNode !== Z.node || oe.focusOffset !== Z.offset)) {
                    var te = ge.createRange();
                    te.setStart(J.node, J.offset), oe.removeAllRanges(), Be > Et ? (oe.addRange(te), oe.extend(Z.node, Z.offset)) : (te.setEnd(Z.node, Z.offset), oe.addRange(te));
                  }
                }
              }
            }
            for (ge = [], oe = B; oe = oe.parentNode; )
              oe.nodeType === 1 && ge.push({
                element: oe,
                left: oe.scrollLeft,
                top: oe.scrollTop
              });
            for (typeof B.focus == "function" && B.focus(), B = 0; B < ge.length; B++) {
              var pe = ge[B];
              pe.element.scrollLeft = pe.left, pe.element.scrollTop = pe.top;
            }
          }
          jp = !!Rv, jv = Rv = null;
        } finally {
          wt = w, H.p = m, P.T = f;
        }
      }
      a.current = l, Mn = 2;
    }
  }
  function cE() {
    if (Mn === 2) {
      Mn = 0;
      var a = Ma, l = Ll, f = (l.flags & 8772) !== 0;
      if ((l.subtreeFlags & 8772) !== 0 || f) {
        f = P.T, P.T = null;
        var m = H.p;
        H.p = 2;
        var w = wt;
        wt |= 4;
        try {
          F2(a, l.alternate, l);
        } finally {
          wt = w, H.p = m, P.T = f;
        }
      }
      Mn = 3;
    }
  }
  function dE() {
    if (Mn === 4 || Mn === 3) {
      Mn = 0, $t();
      var a = Ma, l = Ll, f = Il, m = Q2;
      (l.subtreeFlags & 10256) !== 0 || (l.flags & 10256) !== 0 ? Mn = 5 : (Mn = 0, Ll = Ma = null, fE(a, a.pendingLanes));
      var w = a.pendingLanes;
      if (w === 0 && (Na = null), Io(f), l = l.stateNode, ye && typeof ye.onCommitFiberRoot == "function")
        try {
          ye.onCommitFiberRoot(
            ce,
            l,
            void 0,
            (l.current.flags & 128) === 128
          );
        } catch {
        }
      if (m !== null) {
        l = P.T, w = H.p, H.p = 2, P.T = null;
        try {
          for (var k = a.onRecoverableError, T = 0; T < m.length; T++) {
            var B = m[T];
            k(B.value, {
              componentStack: B.stack
            });
          }
        } finally {
          P.T = l, H.p = w;
        }
      }
      (Il & 3) !== 0 && wp(), Wo(a), w = a.pendingLanes, (f & 4194090) !== 0 && (w & 42) !== 0 ? a === yv ? zc++ : (zc = 0, yv = a) : zc = 0, Tc(0);
    }
  }
  function fE(a, l) {
    (a.pooledCacheLanes &= l) === 0 && (l = a.pooledCache, l != null && (a.pooledCache = null, pc(l)));
  }
  function wp(a) {
    return uE(), cE(), dE(), pE();
  }
  function pE() {
    if (Mn !== 5) return !1;
    var a = Ma, l = mv;
    mv = 0;
    var f = Io(Il), m = P.T, w = H.p;
    try {
      H.p = 32 > f ? 32 : f, P.T = null, f = gv, gv = null;
      var k = Ma, T = Il;
      if (Mn = 0, Ll = Ma = null, Il = 0, (wt & 6) !== 0) throw Error(r(331));
      var B = wt;
      if (wt |= 4, Z2(k.current), X2(
        k,
        k.current,
        T,
        f
      ), wt = B, Tc(0, !1), ye && typeof ye.onPostCommitFiberRoot == "function")
        try {
          ye.onPostCommitFiberRoot(ce, k);
        } catch {
        }
      return !0;
    } finally {
      H.p = w, P.T = m, fE(a, l);
    }
  }
  function hE(a, l, f) {
    l = Qr(f, l), l = Gy(a.stateNode, l, 2), a = wa(a, l, 2), a !== null && (En(a, 2), Wo(a));
  }
  function Ot(a, l, f) {
    if (a.tag === 3)
      hE(a, a, f);
    else
      for (; l !== null; ) {
        if (l.tag === 3) {
          hE(
            l,
            a,
            f
          );
          break;
        } else if (l.tag === 1) {
          var m = l.stateNode;
          if (typeof l.type.getDerivedStateFromError == "function" || typeof m.componentDidCatch == "function" && (Na === null || !Na.has(m))) {
            a = Qr(f, a), f = v2(2), m = wa(l, f, 2), m !== null && (b2(
              f,
              m,
              l,
              a
            ), En(m, 2), Wo(m));
            break;
          }
        }
        l = l.return;
      }
  }
  function xv(a, l, f) {
    var m = a.pingCache;
    if (m === null) {
      m = a.pingCache = new xL();
      var w = /* @__PURE__ */ new Set();
      m.set(l, w);
    } else
      w = m.get(l), w === void 0 && (w = /* @__PURE__ */ new Set(), m.set(l, w));
    w.has(f) || (dv = !0, w.add(f), a = CL.bind(null, a, l, f), l.then(a, a));
  }
  function CL(a, l, f) {
    var m = a.pingCache;
    m !== null && m.delete(l), a.pingedLanes |= a.suspendedLanes & f, a.warmLanes &= ~f, Rt === a && (st & f) === f && (Zt === 4 || Zt === 3 && (st & 62914560) === st && 300 > ft() - hv ? (wt & 2) === 0 && Vl(a, 0) : fv |= f, Pl === st && (Pl = 0)), Wo(a);
  }
  function mE(a, l) {
    l === 0 && (l = da()), a = xl(a, l), a !== null && (En(a, l), Wo(a));
  }
  function OL(a) {
    var l = a.memoizedState, f = 0;
    l !== null && (f = l.retryLane), mE(a, f);
  }
  function AL(a, l) {
    var f = 0;
    switch (a.tag) {
      case 13:
        var m = a.stateNode, w = a.memoizedState;
        w !== null && (f = w.retryLane);
        break;
      case 19:
        m = a.stateNode;
        break;
      case 22:
        m = a.stateNode._retryCache;
        break;
      default:
        throw Error(r(314));
    }
    m !== null && m.delete(l), mE(a, f);
  }
  function NL(a, l) {
    return Ie(a, l);
  }
  var xp = null, Fl = null, Sv = !1, Sp = !1, _v = !1, Ds = 0;
  function Wo(a) {
    a !== Fl && a.next === null && (Fl === null ? xp = Fl = a : Fl = Fl.next = a), Sp = !0, Sv || (Sv = !0, RL());
  }
  function Tc(a, l) {
    if (!_v && Sp) {
      _v = !0;
      do
        for (var f = !1, m = xp; m !== null; ) {
          if (a !== 0) {
            var w = m.pendingLanes;
            if (w === 0) var k = 0;
            else {
              var T = m.suspendedLanes, B = m.pingedLanes;
              k = (1 << 31 - Ve(42 | a) + 1) - 1, k &= w & ~(T & ~B), k = k & 201326741 ? k & 201326741 | 1 : k ? k | 2 : 0;
            }
            k !== 0 && (f = !0, bE(m, k));
          } else
            k = st, k = Wt(
              m,
              m === Rt ? k : 0,
              m.cancelPendingCommit !== null || m.timeoutHandle !== -1
            ), (k & 3) === 0 || Dn(m, k) || (f = !0, bE(m, k));
          m = m.next;
        }
      while (f);
      _v = !1;
    }
  }
  function ML() {
    gE();
  }
  function gE() {
    Sp = Sv = !1;
    var a = 0;
    Ds !== 0 && (VL() && (a = Ds), Ds = 0);
    for (var l = ft(), f = null, m = xp; m !== null; ) {
      var w = m.next, k = yE(m, l);
      k === 0 ? (m.next = null, f === null ? xp = w : f.next = w, w === null && (Fl = f)) : (f = m, (a !== 0 || (k & 3) !== 0) && (Sp = !0)), m = w;
    }
    Tc(a);
  }
  function yE(a, l) {
    for (var f = a.suspendedLanes, m = a.pingedLanes, w = a.expirationTimes, k = a.pendingLanes & -62914561; 0 < k; ) {
      var T = 31 - Ve(k), B = 1 << T, G = w[T];
      G === -1 ? ((B & f) === 0 || (B & m) !== 0) && (w[T] = Xn(B, l)) : G <= l && (a.expiredLanes |= B), k &= ~B;
    }
    if (l = Rt, f = st, f = Wt(
      a,
      a === l ? f : 0,
      a.cancelPendingCommit !== null || a.timeoutHandle !== -1
    ), m = a.callbackNode, f === 0 || a === l && (xt === 2 || xt === 9) || a.cancelPendingCommit !== null)
      return m !== null && m !== null && $e(m), a.callbackNode = null, a.callbackPriority = 0;
    if ((f & 3) === 0 || Dn(a, f)) {
      if (l = f & -f, l === a.callbackPriority) return l;
      switch (m !== null && $e(m), Io(f)) {
        case 2:
        case 8:
          f = vn;
          break;
        case 32:
          f = De;
          break;
        case 268435456:
          f = Xr;
          break;
        default:
          f = De;
      }
      return m = vE.bind(null, a), f = Ie(f, m), a.callbackPriority = l, a.callbackNode = f, l;
    }
    return m !== null && m !== null && $e(m), a.callbackPriority = 2, a.callbackNode = null, 2;
  }
  function vE(a, l) {
    if (Mn !== 0 && Mn !== 5)
      return a.callbackNode = null, a.callbackPriority = 0, null;
    var f = a.callbackNode;
    if (wp() && a.callbackNode !== f)
      return null;
    var m = st;
    return m = Wt(
      a,
      a === Rt ? m : 0,
      a.cancelPendingCommit !== null || a.timeoutHandle !== -1
    ), m === 0 ? null : (eE(a, m, l), yE(a, ft()), a.callbackNode != null && a.callbackNode === f ? vE.bind(null, a) : null);
  }
  function bE(a, l) {
    if (wp()) return null;
    eE(a, l, !0);
  }
  function RL() {
    FL(function() {
      (wt & 6) !== 0 ? Ie(
        on,
        ML
      ) : gE();
    });
  }
  function kv() {
    return Ds === 0 && (Ds = fs()), Ds;
  }
  function wE(a) {
    return a == null || typeof a == "symbol" || typeof a == "boolean" ? null : typeof a == "function" ? a : ki("" + a);
  }
  function xE(a, l) {
    var f = l.ownerDocument.createElement("input");
    return f.name = l.name, f.value = l.value, a.id && f.setAttribute("form", a.id), l.parentNode.insertBefore(f, l), a = new FormData(a), f.parentNode.removeChild(f), a;
  }
  function jL(a, l, f, m, w) {
    if (l === "submit" && f && f.stateNode === w) {
      var k = wE(
        (w[wn] || null).action
      ), T = m.submitter;
      T && (l = (l = T[wn] || null) ? wE(l.formAction) : T.getAttribute("formAction"), l !== null && (k = l, T = null));
      var B = new Lf(
        "action",
        "action",
        null,
        m,
        w
      );
      a.push({
        event: B,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (m.defaultPrevented) {
                if (Ds !== 0) {
                  var G = T ? xE(w, T) : new FormData(w);
                  $y(
                    f,
                    {
                      pending: !0,
                      data: G,
                      method: w.method,
                      action: k
                    },
                    null,
                    G
                  );
                }
              } else
                typeof k == "function" && (B.preventDefault(), G = T ? xE(w, T) : new FormData(w), $y(
                  f,
                  {
                    pending: !0,
                    data: G,
                    method: w.method,
                    action: k
                  },
                  k,
                  G
                ));
            },
            currentTarget: w
          }
        ]
      });
    }
  }
  for (var Ev = 0; Ev < uy.length; Ev++) {
    var Cv = uy[Ev], zL = Cv.toLowerCase(), TL = Cv[0].toUpperCase() + Cv.slice(1);
    xo(
      zL,
      "on" + TL
    );
  }
  xo(ek, "onAnimationEnd"), xo(tk, "onAnimationIteration"), xo(nk, "onAnimationStart"), xo("dblclick", "onDoubleClick"), xo("focusin", "onFocus"), xo("focusout", "onBlur"), xo(KP, "onTransitionRun"), xo(QP, "onTransitionStart"), xo(JP, "onTransitionCancel"), xo(rk, "onTransitionEnd"), ar("onMouseEnter", ["mouseout", "mouseover"]), ar("onMouseLeave", ["mouseout", "mouseover"]), ar("onPointerEnter", ["pointerout", "pointerover"]), ar("onPointerLeave", ["pointerout", "pointerover"]), Zr(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), Zr(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), Zr("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), Zr(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), Zr(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), Zr(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var Dc = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), DL = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Dc)
  );
  function SE(a, l) {
    l = (l & 4) !== 0;
    for (var f = 0; f < a.length; f++) {
      var m = a[f], w = m.event;
      m = m.listeners;
      e: {
        var k = void 0;
        if (l)
          for (var T = m.length - 1; 0 <= T; T--) {
            var B = m[T], G = B.instance, ne = B.currentTarget;
            if (B = B.listener, G !== k && w.isPropagationStopped())
              break e;
            k = B, w.currentTarget = ne;
            try {
              k(w);
            } catch (fe) {
              up(fe);
            }
            w.currentTarget = null, k = G;
          }
        else
          for (T = 0; T < m.length; T++) {
            if (B = m[T], G = B.instance, ne = B.currentTarget, B = B.listener, G !== k && w.isPropagationStopped())
              break e;
            k = B, w.currentTarget = ne;
            try {
              k(w);
            } catch (fe) {
              up(fe);
            }
            w.currentTarget = null, k = G;
          }
      }
    }
  }
  function tt(a, l) {
    var f = l[fa];
    f === void 0 && (f = l[fa] = /* @__PURE__ */ new Set());
    var m = a + "__bubble";
    f.has(m) || (_E(l, a, 2, !1), f.add(m));
  }
  function Ov(a, l, f) {
    var m = 0;
    l && (m |= 4), _E(
      f,
      a,
      m,
      l
    );
  }
  var _p = "_reactListening" + Math.random().toString(36).slice(2);
  function Av(a) {
    if (!a[_p]) {
      a[_p] = !0, ms.forEach(function(f) {
        f !== "selectionchange" && (DL.has(f) || Ov(f, !1, a), Ov(f, !0, a));
      });
      var l = a.nodeType === 9 ? a : a.ownerDocument;
      l === null || l[_p] || (l[_p] = !0, Ov("selectionchange", !1, l));
    }
  }
  function _E(a, l, f, m) {
    switch (XE(l)) {
      case 2:
        var w = l9;
        break;
      case 8:
        w = u9;
        break;
      default:
        w = Uv;
    }
    f = w.bind(
      null,
      l,
      f,
      a
    ), w = void 0, !Zg || l !== "touchstart" && l !== "touchmove" && l !== "wheel" || (w = !0), m ? w !== void 0 ? a.addEventListener(l, f, {
      capture: !0,
      passive: w
    }) : a.addEventListener(l, f, !0) : w !== void 0 ? a.addEventListener(l, f, {
      passive: w
    }) : a.addEventListener(l, f, !1);
  }
  function Nv(a, l, f, m, w) {
    var k = m;
    if ((l & 1) === 0 && (l & 2) === 0 && m !== null)
      e: for (; ; ) {
        if (m === null) return;
        var T = m.tag;
        if (T === 3 || T === 4) {
          var B = m.stateNode.containerInfo;
          if (B === w) break;
          if (T === 4)
            for (T = m.return; T !== null; ) {
              var G = T.tag;
              if ((G === 3 || G === 4) && T.stateNode.containerInfo === w)
                return;
              T = T.return;
            }
          for (; B !== null; ) {
            if (T = Cn(B), T === null) return;
            if (G = T.tag, G === 5 || G === 6 || G === 26 || G === 27) {
              m = k = T;
              continue e;
            }
            B = B.parentNode;
          }
        }
        m = m.return;
      }
    ec(function() {
      var ne = k, fe = gl(f), ge = [];
      e: {
        var re = ok.get(a);
        if (re !== void 0) {
          var oe = Lf, He = a;
          switch (a) {
            case "keypress":
              if (Df(f) === 0) break e;
            case "keydown":
            case "keyup":
              oe = NP;
              break;
            case "focusin":
              He = "focus", oe = ey;
              break;
            case "focusout":
              He = "blur", oe = ey;
              break;
            case "beforeblur":
            case "afterblur":
              oe = ey;
              break;
            case "click":
              if (f.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              oe = z_;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              oe = yP;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              oe = jP;
              break;
            case ek:
            case tk:
            case nk:
              oe = wP;
              break;
            case rk:
              oe = TP;
              break;
            case "scroll":
            case "scrollend":
              oe = mP;
              break;
            case "wheel":
              oe = PP;
              break;
            case "copy":
            case "cut":
            case "paste":
              oe = SP;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              oe = D_;
              break;
            case "toggle":
            case "beforetoggle":
              oe = IP;
          }
          var Be = (l & 4) !== 0, Et = !Be && (a === "scroll" || a === "scrollend"), J = Be ? re !== null ? re + "Capture" : null : re;
          Be = [];
          for (var Z = ne, te; Z !== null; ) {
            var pe = Z;
            if (te = pe.stateNode, pe = pe.tag, pe !== 5 && pe !== 26 && pe !== 27 || te === null || J === null || (pe = Ho(Z, J), pe != null && Be.push(
              Pc(Z, pe, te)
            )), Et) break;
            Z = Z.return;
          }
          0 < Be.length && (re = new oe(
            re,
            He,
            null,
            f,
            fe
          ), ge.push({ event: re, listeners: Be }));
        }
      }
      if ((l & 7) === 0) {
        e: {
          if (re = a === "mouseover" || a === "pointerover", oe = a === "mouseout" || a === "pointerout", re && f !== bo && (He = f.relatedTarget || f.fromElement) && (Cn(He) || He[go]))
            break e;
          if ((oe || re) && (re = fe.window === fe ? fe : (re = fe.ownerDocument) ? re.defaultView || re.parentWindow : window, oe ? (He = f.relatedTarget || f.toElement, oe = ne, He = He ? Cn(He) : null, He !== null && (Et = i(He), Be = He.tag, He !== Et || Be !== 5 && Be !== 27 && Be !== 6) && (He = null)) : (oe = null, He = ne), oe !== He)) {
            if (Be = z_, pe = "onMouseLeave", J = "onMouseEnter", Z = "mouse", (a === "pointerout" || a === "pointerover") && (Be = D_, pe = "onPointerLeave", J = "onPointerEnter", Z = "pointer"), Et = oe == null ? re : wi(oe), te = He == null ? re : wi(He), re = new Be(
              pe,
              Z + "leave",
              oe,
              f,
              fe
            ), re.target = Et, re.relatedTarget = te, pe = null, Cn(fe) === ne && (Be = new Be(
              J,
              Z + "enter",
              He,
              f,
              fe
            ), Be.target = te, Be.relatedTarget = Et, pe = Be), Et = pe, oe && He)
              t: {
                for (Be = oe, J = He, Z = 0, te = Be; te; te = Ul(te))
                  Z++;
                for (te = 0, pe = J; pe; pe = Ul(pe))
                  te++;
                for (; 0 < Z - te; )
                  Be = Ul(Be), Z--;
                for (; 0 < te - Z; )
                  J = Ul(J), te--;
                for (; Z--; ) {
                  if (Be === J || J !== null && Be === J.alternate)
                    break t;
                  Be = Ul(Be), J = Ul(J);
                }
                Be = null;
              }
            else Be = null;
            oe !== null && kE(
              ge,
              re,
              oe,
              Be,
              !1
            ), He !== null && Et !== null && kE(
              ge,
              Et,
              He,
              Be,
              !0
            );
          }
        }
        e: {
          if (re = ne ? wi(ne) : window, oe = re.nodeName && re.nodeName.toLowerCase(), oe === "select" || oe === "input" && re.type === "file")
            var Oe = H_;
          else if (F_(re))
            if ($_)
              Oe = WP;
            else {
              Oe = qP;
              var Ke = YP;
            }
          else
            oe = re.nodeName, !oe || oe.toLowerCase() !== "input" || re.type !== "checkbox" && re.type !== "radio" ? ne && _i(ne.elementType) && (Oe = H_) : Oe = XP;
          if (Oe && (Oe = Oe(a, ne))) {
            U_(
              ge,
              Oe,
              f,
              fe
            );
            break e;
          }
          Ke && Ke(a, re, ne), a === "focusout" && ne && re.type === "number" && ne.memoizedProps.value != null && pt(re, "number", re.value);
        }
        switch (Ke = ne ? wi(ne) : window, a) {
          case "focusin":
            (F_(Ke) || Ke.contentEditable === "true") && (vl = Ke, ay = ne, lc = null);
            break;
          case "focusout":
            lc = ay = vl = null;
            break;
          case "mousedown":
            sy = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            sy = !1, Q_(ge, f, fe);
            break;
          case "selectionchange":
            if (ZP) break;
          case "keydown":
          case "keyup":
            Q_(ge, f, fe);
        }
        var Re;
        if (ny)
          e: {
            switch (a) {
              case "compositionstart":
                var Fe = "onCompositionStart";
                break e;
              case "compositionend":
                Fe = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Fe = "onCompositionUpdate";
                break e;
            }
            Fe = void 0;
          }
        else
          yl ? V_(a, f) && (Fe = "onCompositionEnd") : a === "keydown" && f.keyCode === 229 && (Fe = "onCompositionStart");
        Fe && (P_ && f.locale !== "ko" && (yl || Fe !== "onCompositionStart" ? Fe === "onCompositionEnd" && yl && (Re = R_()) : (ga = fe, Kg = "value" in ga ? ga.value : ga.textContent, yl = !0)), Ke = kp(ne, Fe), 0 < Ke.length && (Fe = new T_(
          Fe,
          a,
          null,
          f,
          fe
        ), ge.push({ event: Fe, listeners: Ke }), Re ? Fe.data = Re : (Re = B_(f), Re !== null && (Fe.data = Re)))), (Re = BP ? FP(a, f) : UP(a, f)) && (Fe = kp(ne, "onBeforeInput"), 0 < Fe.length && (Ke = new T_(
          "onBeforeInput",
          "beforeinput",
          null,
          f,
          fe
        ), ge.push({
          event: Ke,
          listeners: Fe
        }), Ke.data = Re)), jL(
          ge,
          a,
          ne,
          f,
          fe
        );
      }
      SE(ge, l);
    });
  }
  function Pc(a, l, f) {
    return {
      instance: a,
      listener: l,
      currentTarget: f
    };
  }
  function kp(a, l) {
    for (var f = l + "Capture", m = []; a !== null; ) {
      var w = a, k = w.stateNode;
      if (w = w.tag, w !== 5 && w !== 26 && w !== 27 || k === null || (w = Ho(a, f), w != null && m.unshift(
        Pc(a, w, k)
      ), w = Ho(a, l), w != null && m.push(
        Pc(a, w, k)
      )), a.tag === 3) return m;
      a = a.return;
    }
    return [];
  }
  function Ul(a) {
    if (a === null) return null;
    do
      a = a.return;
    while (a && a.tag !== 5 && a.tag !== 27);
    return a || null;
  }
  function kE(a, l, f, m, w) {
    for (var k = l._reactName, T = []; f !== null && f !== m; ) {
      var B = f, G = B.alternate, ne = B.stateNode;
      if (B = B.tag, G !== null && G === m) break;
      B !== 5 && B !== 26 && B !== 27 || ne === null || (G = ne, w ? (ne = Ho(f, k), ne != null && T.unshift(
        Pc(f, ne, G)
      )) : w || (ne = Ho(f, k), ne != null && T.push(
        Pc(f, ne, G)
      ))), f = f.return;
    }
    T.length !== 0 && a.push({ event: l, listeners: T });
  }
  var PL = /\r\n?/g, LL = /\u0000|\uFFFD/g;
  function EE(a) {
    return (typeof a == "string" ? a : "" + a).replace(PL, `
`).replace(LL, "");
  }
  function CE(a, l) {
    return l = EE(l), EE(a) === l;
  }
  function Ep() {
  }
  function kt(a, l, f, m, w, k) {
    switch (f) {
      case "children":
        typeof m == "string" ? l === "body" || l === "textarea" && m === "" || Fo(a, m) : (typeof m == "number" || typeof m == "bigint") && l !== "body" && Fo(a, "" + m);
        break;
      case "className":
        Ce(a, "class", m);
        break;
      case "tabIndex":
        Ce(a, "tabindex", m);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Ce(a, f, m);
        break;
      case "style":
        vo(a, m, k);
        break;
      case "data":
        if (l !== "object") {
          Ce(a, "data", m);
          break;
        }
      case "src":
      case "href":
        if (m === "" && (l !== "a" || f !== "href")) {
          a.removeAttribute(f);
          break;
        }
        if (m == null || typeof m == "function" || typeof m == "symbol" || typeof m == "boolean") {
          a.removeAttribute(f);
          break;
        }
        m = ki("" + m), a.setAttribute(f, m);
        break;
      case "action":
      case "formAction":
        if (typeof m == "function") {
          a.setAttribute(
            f,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof k == "function" && (f === "formAction" ? (l !== "input" && kt(a, l, "name", w.name, w, null), kt(
            a,
            l,
            "formEncType",
            w.formEncType,
            w,
            null
          ), kt(
            a,
            l,
            "formMethod",
            w.formMethod,
            w,
            null
          ), kt(
            a,
            l,
            "formTarget",
            w.formTarget,
            w,
            null
          )) : (kt(a, l, "encType", w.encType, w, null), kt(a, l, "method", w.method, w, null), kt(a, l, "target", w.target, w, null)));
        if (m == null || typeof m == "symbol" || typeof m == "boolean") {
          a.removeAttribute(f);
          break;
        }
        m = ki("" + m), a.setAttribute(f, m);
        break;
      case "onClick":
        m != null && (a.onclick = Ep);
        break;
      case "onScroll":
        m != null && tt("scroll", a);
        break;
      case "onScrollEnd":
        m != null && tt("scrollend", a);
        break;
      case "dangerouslySetInnerHTML":
        if (m != null) {
          if (typeof m != "object" || !("__html" in m))
            throw Error(r(61));
          if (f = m.__html, f != null) {
            if (w.children != null) throw Error(r(60));
            a.innerHTML = f;
          }
        }
        break;
      case "multiple":
        a.multiple = m && typeof m != "function" && typeof m != "symbol";
        break;
      case "muted":
        a.muted = m && typeof m != "function" && typeof m != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (m == null || typeof m == "function" || typeof m == "boolean" || typeof m == "symbol") {
          a.removeAttribute("xlink:href");
          break;
        }
        f = ki("" + m), a.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          f
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        m != null && typeof m != "function" && typeof m != "symbol" ? a.setAttribute(f, "" + m) : a.removeAttribute(f);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        m && typeof m != "function" && typeof m != "symbol" ? a.setAttribute(f, "") : a.removeAttribute(f);
        break;
      case "capture":
      case "download":
        m === !0 ? a.setAttribute(f, "") : m !== !1 && m != null && typeof m != "function" && typeof m != "symbol" ? a.setAttribute(f, m) : a.removeAttribute(f);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        m != null && typeof m != "function" && typeof m != "symbol" && !isNaN(m) && 1 <= m ? a.setAttribute(f, m) : a.removeAttribute(f);
        break;
      case "rowSpan":
      case "start":
        m == null || typeof m == "function" || typeof m == "symbol" || isNaN(m) ? a.removeAttribute(f) : a.setAttribute(f, m);
        break;
      case "popover":
        tt("beforetoggle", a), tt("toggle", a), xe(a, "popover", m);
        break;
      case "xlinkActuate":
        Je(
          a,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          m
        );
        break;
      case "xlinkArcrole":
        Je(
          a,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          m
        );
        break;
      case "xlinkRole":
        Je(
          a,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          m
        );
        break;
      case "xlinkShow":
        Je(
          a,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          m
        );
        break;
      case "xlinkTitle":
        Je(
          a,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          m
        );
        break;
      case "xlinkType":
        Je(
          a,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          m
        );
        break;
      case "xmlBase":
        Je(
          a,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          m
        );
        break;
      case "xmlLang":
        Je(
          a,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          m
        );
        break;
      case "xmlSpace":
        Je(
          a,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          m
        );
        break;
      case "is":
        xe(a, "is", m);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < f.length) || f[0] !== "o" && f[0] !== "O" || f[1] !== "n" && f[1] !== "N") && (f = ml.get(f) || f, xe(a, f, m));
    }
  }
  function Mv(a, l, f, m, w, k) {
    switch (f) {
      case "style":
        vo(a, m, k);
        break;
      case "dangerouslySetInnerHTML":
        if (m != null) {
          if (typeof m != "object" || !("__html" in m))
            throw Error(r(61));
          if (f = m.__html, f != null) {
            if (w.children != null) throw Error(r(60));
            a.innerHTML = f;
          }
        }
        break;
      case "children":
        typeof m == "string" ? Fo(a, m) : (typeof m == "number" || typeof m == "bigint") && Fo(a, "" + m);
        break;
      case "onScroll":
        m != null && tt("scroll", a);
        break;
      case "onScrollEnd":
        m != null && tt("scrollend", a);
        break;
      case "onClick":
        m != null && (a.onclick = Ep);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!gs.hasOwnProperty(f))
          e: {
            if (f[0] === "o" && f[1] === "n" && (w = f.endsWith("Capture"), l = f.slice(2, w ? f.length - 7 : void 0), k = a[wn] || null, k = k != null ? k[f] : null, typeof k == "function" && a.removeEventListener(l, k, w), typeof m == "function")) {
              typeof k != "function" && k !== null && (f in a ? a[f] = null : a.hasAttribute(f) && a.removeAttribute(f)), a.addEventListener(l, m, w);
              break e;
            }
            f in a ? a[f] = m : m === !0 ? a.setAttribute(f, "") : xe(a, f, m);
          }
    }
  }
  function Rn(a, l, f) {
    switch (l) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        tt("error", a), tt("load", a);
        var m = !1, w = !1, k;
        for (k in f)
          if (f.hasOwnProperty(k)) {
            var T = f[k];
            if (T != null)
              switch (k) {
                case "src":
                  m = !0;
                  break;
                case "srcSet":
                  w = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(r(137, l));
                default:
                  kt(a, l, k, T, f, null);
              }
          }
        w && kt(a, l, "srcSet", f.srcSet, f, null), m && kt(a, l, "src", f.src, f, null);
        return;
      case "input":
        tt("invalid", a);
        var B = k = T = w = null, G = null, ne = null;
        for (m in f)
          if (f.hasOwnProperty(m)) {
            var fe = f[m];
            if (fe != null)
              switch (m) {
                case "name":
                  w = fe;
                  break;
                case "type":
                  T = fe;
                  break;
                case "checked":
                  G = fe;
                  break;
                case "defaultChecked":
                  ne = fe;
                  break;
                case "value":
                  k = fe;
                  break;
                case "defaultValue":
                  B = fe;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (fe != null)
                    throw Error(r(137, l));
                  break;
                default:
                  kt(a, l, m, fe, f, null);
              }
          }
        zf(
          a,
          k,
          B,
          G,
          ne,
          T,
          w,
          !1
        ), kr(a);
        return;
      case "select":
        tt("invalid", a), m = T = k = null;
        for (w in f)
          if (f.hasOwnProperty(w) && (B = f[w], B != null))
            switch (w) {
              case "value":
                k = B;
                break;
              case "defaultValue":
                T = B;
                break;
              case "multiple":
                m = B;
              default:
                kt(a, l, w, B, f, null);
            }
        l = k, f = T, a.multiple = !!m, l != null ? ot(a, !!m, l, !1) : f != null && ot(a, !!m, f, !0);
        return;
      case "textarea":
        tt("invalid", a), k = w = m = null;
        for (T in f)
          if (f.hasOwnProperty(T) && (B = f[T], B != null))
            switch (T) {
              case "value":
                m = B;
                break;
              case "defaultValue":
                w = B;
                break;
              case "children":
                k = B;
                break;
              case "dangerouslySetInnerHTML":
                if (B != null) throw Error(r(91));
                break;
              default:
                kt(a, l, T, B, f, null);
            }
        yo(a, m, w, k), kr(a);
        return;
      case "option":
        for (G in f)
          if (f.hasOwnProperty(G) && (m = f[G], m != null))
            switch (G) {
              case "selected":
                a.selected = m && typeof m != "function" && typeof m != "symbol";
                break;
              default:
                kt(a, l, G, m, f, null);
            }
        return;
      case "dialog":
        tt("beforetoggle", a), tt("toggle", a), tt("cancel", a), tt("close", a);
        break;
      case "iframe":
      case "object":
        tt("load", a);
        break;
      case "video":
      case "audio":
        for (m = 0; m < Dc.length; m++)
          tt(Dc[m], a);
        break;
      case "image":
        tt("error", a), tt("load", a);
        break;
      case "details":
        tt("toggle", a);
        break;
      case "embed":
      case "source":
      case "link":
        tt("error", a), tt("load", a);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (ne in f)
          if (f.hasOwnProperty(ne) && (m = f[ne], m != null))
            switch (ne) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(r(137, l));
              default:
                kt(a, l, ne, m, f, null);
            }
        return;
      default:
        if (_i(l)) {
          for (fe in f)
            f.hasOwnProperty(fe) && (m = f[fe], m !== void 0 && Mv(
              a,
              l,
              fe,
              m,
              f,
              void 0
            ));
          return;
        }
    }
    for (B in f)
      f.hasOwnProperty(B) && (m = f[B], m != null && kt(a, l, B, m, f, null));
  }
  function IL(a, l, f, m) {
    switch (l) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var w = null, k = null, T = null, B = null, G = null, ne = null, fe = null;
        for (oe in f) {
          var ge = f[oe];
          if (f.hasOwnProperty(oe) && ge != null)
            switch (oe) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                G = ge;
              default:
                m.hasOwnProperty(oe) || kt(a, l, oe, null, m, ge);
            }
        }
        for (var re in m) {
          var oe = m[re];
          if (ge = f[re], m.hasOwnProperty(re) && (oe != null || ge != null))
            switch (re) {
              case "type":
                k = oe;
                break;
              case "name":
                w = oe;
                break;
              case "checked":
                ne = oe;
                break;
              case "defaultChecked":
                fe = oe;
                break;
              case "value":
                T = oe;
                break;
              case "defaultValue":
                B = oe;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (oe != null)
                  throw Error(r(137, l));
                break;
              default:
                oe !== ge && kt(
                  a,
                  l,
                  re,
                  oe,
                  m,
                  ge
                );
            }
        }
        ha(
          a,
          T,
          B,
          G,
          ne,
          fe,
          k,
          w
        );
        return;
      case "select":
        oe = T = B = re = null;
        for (k in f)
          if (G = f[k], f.hasOwnProperty(k) && G != null)
            switch (k) {
              case "value":
                break;
              case "multiple":
                oe = G;
              default:
                m.hasOwnProperty(k) || kt(
                  a,
                  l,
                  k,
                  null,
                  m,
                  G
                );
            }
        for (w in m)
          if (k = m[w], G = f[w], m.hasOwnProperty(w) && (k != null || G != null))
            switch (w) {
              case "value":
                re = k;
                break;
              case "defaultValue":
                B = k;
                break;
              case "multiple":
                T = k;
              default:
                k !== G && kt(
                  a,
                  l,
                  w,
                  k,
                  m,
                  G
                );
            }
        l = B, f = T, m = oe, re != null ? ot(a, !!f, re, !1) : !!m != !!f && (l != null ? ot(a, !!f, l, !0) : ot(a, !!f, f ? [] : "", !1));
        return;
      case "textarea":
        oe = re = null;
        for (B in f)
          if (w = f[B], f.hasOwnProperty(B) && w != null && !m.hasOwnProperty(B))
            switch (B) {
              case "value":
                break;
              case "children":
                break;
              default:
                kt(a, l, B, null, m, w);
            }
        for (T in m)
          if (w = m[T], k = f[T], m.hasOwnProperty(T) && (w != null || k != null))
            switch (T) {
              case "value":
                re = w;
                break;
              case "defaultValue":
                oe = w;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (w != null) throw Error(r(91));
                break;
              default:
                w !== k && kt(a, l, T, w, m, k);
            }
        vs(a, re, oe);
        return;
      case "option":
        for (var He in f)
          if (re = f[He], f.hasOwnProperty(He) && re != null && !m.hasOwnProperty(He))
            switch (He) {
              case "selected":
                a.selected = !1;
                break;
              default:
                kt(
                  a,
                  l,
                  He,
                  null,
                  m,
                  re
                );
            }
        for (G in m)
          if (re = m[G], oe = f[G], m.hasOwnProperty(G) && re !== oe && (re != null || oe != null))
            switch (G) {
              case "selected":
                a.selected = re && typeof re != "function" && typeof re != "symbol";
                break;
              default:
                kt(
                  a,
                  l,
                  G,
                  re,
                  m,
                  oe
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var Be in f)
          re = f[Be], f.hasOwnProperty(Be) && re != null && !m.hasOwnProperty(Be) && kt(a, l, Be, null, m, re);
        for (ne in m)
          if (re = m[ne], oe = f[ne], m.hasOwnProperty(ne) && re !== oe && (re != null || oe != null))
            switch (ne) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (re != null)
                  throw Error(r(137, l));
                break;
              default:
                kt(
                  a,
                  l,
                  ne,
                  re,
                  m,
                  oe
                );
            }
        return;
      default:
        if (_i(l)) {
          for (var Et in f)
            re = f[Et], f.hasOwnProperty(Et) && re !== void 0 && !m.hasOwnProperty(Et) && Mv(
              a,
              l,
              Et,
              void 0,
              m,
              re
            );
          for (fe in m)
            re = m[fe], oe = f[fe], !m.hasOwnProperty(fe) || re === oe || re === void 0 && oe === void 0 || Mv(
              a,
              l,
              fe,
              re,
              m,
              oe
            );
          return;
        }
    }
    for (var J in f)
      re = f[J], f.hasOwnProperty(J) && re != null && !m.hasOwnProperty(J) && kt(a, l, J, null, m, re);
    for (ge in m)
      re = m[ge], oe = f[ge], !m.hasOwnProperty(ge) || re === oe || re == null && oe == null || kt(a, l, ge, re, m, oe);
  }
  var Rv = null, jv = null;
  function Cp(a) {
    return a.nodeType === 9 ? a : a.ownerDocument;
  }
  function OE(a) {
    switch (a) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function AE(a, l) {
    if (a === 0)
      switch (l) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return a === 1 && l === "foreignObject" ? 0 : a;
  }
  function zv(a, l) {
    return a === "textarea" || a === "noscript" || typeof l.children == "string" || typeof l.children == "number" || typeof l.children == "bigint" || typeof l.dangerouslySetInnerHTML == "object" && l.dangerouslySetInnerHTML !== null && l.dangerouslySetInnerHTML.__html != null;
  }
  var Tv = null;
  function VL() {
    var a = window.event;
    return a && a.type === "popstate" ? a === Tv ? !1 : (Tv = a, !0) : (Tv = null, !1);
  }
  var NE = typeof setTimeout == "function" ? setTimeout : void 0, BL = typeof clearTimeout == "function" ? clearTimeout : void 0, ME = typeof Promise == "function" ? Promise : void 0, FL = typeof queueMicrotask == "function" ? queueMicrotask : typeof ME < "u" ? function(a) {
    return ME.resolve(null).then(a).catch(UL);
  } : NE;
  function UL(a) {
    setTimeout(function() {
      throw a;
    });
  }
  function ja(a) {
    return a === "head";
  }
  function RE(a, l) {
    var f = l, m = 0, w = 0;
    do {
      var k = f.nextSibling;
      if (a.removeChild(f), k && k.nodeType === 8)
        if (f = k.data, f === "/$") {
          if (0 < m && 8 > m) {
            f = m;
            var T = a.ownerDocument;
            if (f & 1 && Lc(T.documentElement), f & 2 && Lc(T.body), f & 4)
              for (f = T.head, Lc(f), T = f.firstChild; T; ) {
                var B = T.nextSibling, G = T.nodeName;
                T[Pn] || G === "SCRIPT" || G === "STYLE" || G === "LINK" && T.rel.toLowerCase() === "stylesheet" || f.removeChild(T), T = B;
              }
          }
          if (w === 0) {
            a.removeChild(k), Yc(l);
            return;
          }
          w--;
        } else
          f === "$" || f === "$?" || f === "$!" ? w++ : m = f.charCodeAt(0) - 48;
      else m = 0;
      f = k;
    } while (f);
    Yc(l);
  }
  function Dv(a) {
    var l = a.firstChild;
    for (l && l.nodeType === 10 && (l = l.nextSibling); l; ) {
      var f = l;
      switch (l = l.nextSibling, f.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          Dv(f), hs(f);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (f.rel.toLowerCase() === "stylesheet") continue;
      }
      a.removeChild(f);
    }
  }
  function HL(a, l, f, m) {
    for (; a.nodeType === 1; ) {
      var w = f;
      if (a.nodeName.toLowerCase() !== l.toLowerCase()) {
        if (!m && (a.nodeName !== "INPUT" || a.type !== "hidden"))
          break;
      } else if (m) {
        if (!a[Pn])
          switch (l) {
            case "meta":
              if (!a.hasAttribute("itemprop")) break;
              return a;
            case "link":
              if (k = a.getAttribute("rel"), k === "stylesheet" && a.hasAttribute("data-precedence"))
                break;
              if (k !== w.rel || a.getAttribute("href") !== (w.href == null || w.href === "" ? null : w.href) || a.getAttribute("crossorigin") !== (w.crossOrigin == null ? null : w.crossOrigin) || a.getAttribute("title") !== (w.title == null ? null : w.title))
                break;
              return a;
            case "style":
              if (a.hasAttribute("data-precedence")) break;
              return a;
            case "script":
              if (k = a.getAttribute("src"), (k !== (w.src == null ? null : w.src) || a.getAttribute("type") !== (w.type == null ? null : w.type) || a.getAttribute("crossorigin") !== (w.crossOrigin == null ? null : w.crossOrigin)) && k && a.hasAttribute("async") && !a.hasAttribute("itemprop"))
                break;
              return a;
            default:
              return a;
          }
      } else if (l === "input" && a.type === "hidden") {
        var k = w.name == null ? null : "" + w.name;
        if (w.type === "hidden" && a.getAttribute("name") === k)
          return a;
      } else return a;
      if (a = _o(a.nextSibling), a === null) break;
    }
    return null;
  }
  function $L(a, l, f) {
    if (l === "") return null;
    for (; a.nodeType !== 3; )
      if ((a.nodeType !== 1 || a.nodeName !== "INPUT" || a.type !== "hidden") && !f || (a = _o(a.nextSibling), a === null)) return null;
    return a;
  }
  function Pv(a) {
    return a.data === "$!" || a.data === "$?" && a.ownerDocument.readyState === "complete";
  }
  function YL(a, l) {
    var f = a.ownerDocument;
    if (a.data !== "$?" || f.readyState === "complete")
      l();
    else {
      var m = function() {
        l(), f.removeEventListener("DOMContentLoaded", m);
      };
      f.addEventListener("DOMContentLoaded", m), a._reactRetry = m;
    }
  }
  function _o(a) {
    for (; a != null; a = a.nextSibling) {
      var l = a.nodeType;
      if (l === 1 || l === 3) break;
      if (l === 8) {
        if (l = a.data, l === "$" || l === "$!" || l === "$?" || l === "F!" || l === "F")
          break;
        if (l === "/$") return null;
      }
    }
    return a;
  }
  var Lv = null;
  function jE(a) {
    a = a.previousSibling;
    for (var l = 0; a; ) {
      if (a.nodeType === 8) {
        var f = a.data;
        if (f === "$" || f === "$!" || f === "$?") {
          if (l === 0) return a;
          l--;
        } else f === "/$" && l++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  function zE(a, l, f) {
    switch (l = Cp(f), a) {
      case "html":
        if (a = l.documentElement, !a) throw Error(r(452));
        return a;
      case "head":
        if (a = l.head, !a) throw Error(r(453));
        return a;
      case "body":
        if (a = l.body, !a) throw Error(r(454));
        return a;
      default:
        throw Error(r(451));
    }
  }
  function Lc(a) {
    for (var l = a.attributes; l.length; )
      a.removeAttributeNode(l[0]);
    hs(a);
  }
  var oo = /* @__PURE__ */ new Map(), TE = /* @__PURE__ */ new Set();
  function Op(a) {
    return typeof a.getRootNode == "function" ? a.getRootNode() : a.nodeType === 9 ? a : a.ownerDocument;
  }
  var Li = H.d;
  H.d = {
    f: qL,
    r: XL,
    D: WL,
    C: GL,
    L: ZL,
    m: KL,
    X: JL,
    S: QL,
    M: e9
  };
  function qL() {
    var a = Li.f(), l = vp();
    return a || l;
  }
  function XL(a) {
    var l = Gr(a);
    l !== null && l.tag === 5 && l.type === "form" ? e2(l) : Li.r(a);
  }
  var Hl = typeof document > "u" ? null : document;
  function DE(a, l, f) {
    var m = Hl;
    if (m && typeof l == "string" && l) {
      var w = An(l);
      w = 'link[rel="' + a + '"][href="' + w + '"]', typeof f == "string" && (w += '[crossorigin="' + f + '"]'), TE.has(w) || (TE.add(w), a = { rel: a, crossOrigin: f, href: l }, m.querySelector(w) === null && (l = m.createElement("link"), Rn(l, "link", a), Lt(l), m.head.appendChild(l)));
    }
  }
  function WL(a) {
    Li.D(a), DE("dns-prefetch", a, null);
  }
  function GL(a, l) {
    Li.C(a, l), DE("preconnect", a, l);
  }
  function ZL(a, l, f) {
    Li.L(a, l, f);
    var m = Hl;
    if (m && a && l) {
      var w = 'link[rel="preload"][as="' + An(l) + '"]';
      l === "image" && f && f.imageSrcSet ? (w += '[imagesrcset="' + An(
        f.imageSrcSet
      ) + '"]', typeof f.imageSizes == "string" && (w += '[imagesizes="' + An(
        f.imageSizes
      ) + '"]')) : w += '[href="' + An(a) + '"]';
      var k = w;
      switch (l) {
        case "style":
          k = $l(a);
          break;
        case "script":
          k = Yl(a);
      }
      oo.has(k) || (a = p(
        {
          rel: "preload",
          href: l === "image" && f && f.imageSrcSet ? void 0 : a,
          as: l
        },
        f
      ), oo.set(k, a), m.querySelector(w) !== null || l === "style" && m.querySelector(Ic(k)) || l === "script" && m.querySelector(Vc(k)) || (l = m.createElement("link"), Rn(l, "link", a), Lt(l), m.head.appendChild(l)));
    }
  }
  function KL(a, l) {
    Li.m(a, l);
    var f = Hl;
    if (f && a) {
      var m = l && typeof l.as == "string" ? l.as : "script", w = 'link[rel="modulepreload"][as="' + An(m) + '"][href="' + An(a) + '"]', k = w;
      switch (m) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          k = Yl(a);
      }
      if (!oo.has(k) && (a = p({ rel: "modulepreload", href: a }, l), oo.set(k, a), f.querySelector(w) === null)) {
        switch (m) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (f.querySelector(Vc(k)))
              return;
        }
        m = f.createElement("link"), Rn(m, "link", a), Lt(m), f.head.appendChild(m);
      }
    }
  }
  function QL(a, l, f) {
    Li.S(a, l, f);
    var m = Hl;
    if (m && a) {
      var w = _r(m).hoistableStyles, k = $l(a);
      l = l || "default";
      var T = w.get(k);
      if (!T) {
        var B = { loading: 0, preload: null };
        if (T = m.querySelector(
          Ic(k)
        ))
          B.loading = 5;
        else {
          a = p(
            { rel: "stylesheet", href: a, "data-precedence": l },
            f
          ), (f = oo.get(k)) && Iv(a, f);
          var G = T = m.createElement("link");
          Lt(G), Rn(G, "link", a), G._p = new Promise(function(ne, fe) {
            G.onload = ne, G.onerror = fe;
          }), G.addEventListener("load", function() {
            B.loading |= 1;
          }), G.addEventListener("error", function() {
            B.loading |= 2;
          }), B.loading |= 4, Ap(T, l, m);
        }
        T = {
          type: "stylesheet",
          instance: T,
          count: 1,
          state: B
        }, w.set(k, T);
      }
    }
  }
  function JL(a, l) {
    Li.X(a, l);
    var f = Hl;
    if (f && a) {
      var m = _r(f).hoistableScripts, w = Yl(a), k = m.get(w);
      k || (k = f.querySelector(Vc(w)), k || (a = p({ src: a, async: !0 }, l), (l = oo.get(w)) && Vv(a, l), k = f.createElement("script"), Lt(k), Rn(k, "link", a), f.head.appendChild(k)), k = {
        type: "script",
        instance: k,
        count: 1,
        state: null
      }, m.set(w, k));
    }
  }
  function e9(a, l) {
    Li.M(a, l);
    var f = Hl;
    if (f && a) {
      var m = _r(f).hoistableScripts, w = Yl(a), k = m.get(w);
      k || (k = f.querySelector(Vc(w)), k || (a = p({ src: a, async: !0, type: "module" }, l), (l = oo.get(w)) && Vv(a, l), k = f.createElement("script"), Lt(k), Rn(k, "link", a), f.head.appendChild(k)), k = {
        type: "script",
        instance: k,
        count: 1,
        state: null
      }, m.set(w, k));
    }
  }
  function PE(a, l, f, m) {
    var w = (w = le.current) ? Op(w) : null;
    if (!w) throw Error(r(446));
    switch (a) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof f.precedence == "string" && typeof f.href == "string" ? (l = $l(f.href), f = _r(
          w
        ).hoistableStyles, m = f.get(l), m || (m = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, f.set(l, m)), m) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (f.rel === "stylesheet" && typeof f.href == "string" && typeof f.precedence == "string") {
          a = $l(f.href);
          var k = _r(
            w
          ).hoistableStyles, T = k.get(a);
          if (T || (w = w.ownerDocument || w, T = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, k.set(a, T), (k = w.querySelector(
            Ic(a)
          )) && !k._p && (T.instance = k, T.state.loading = 5), oo.has(a) || (f = {
            rel: "preload",
            as: "style",
            href: f.href,
            crossOrigin: f.crossOrigin,
            integrity: f.integrity,
            media: f.media,
            hrefLang: f.hrefLang,
            referrerPolicy: f.referrerPolicy
          }, oo.set(a, f), k || t9(
            w,
            a,
            f,
            T.state
          ))), l && m === null)
            throw Error(r(528, ""));
          return T;
        }
        if (l && m !== null)
          throw Error(r(529, ""));
        return null;
      case "script":
        return l = f.async, f = f.src, typeof f == "string" && l && typeof l != "function" && typeof l != "symbol" ? (l = Yl(f), f = _r(
          w
        ).hoistableScripts, m = f.get(l), m || (m = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, f.set(l, m)), m) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(r(444, a));
    }
  }
  function $l(a) {
    return 'href="' + An(a) + '"';
  }
  function Ic(a) {
    return 'link[rel="stylesheet"][' + a + "]";
  }
  function LE(a) {
    return p({}, a, {
      "data-precedence": a.precedence,
      precedence: null
    });
  }
  function t9(a, l, f, m) {
    a.querySelector('link[rel="preload"][as="style"][' + l + "]") ? m.loading = 1 : (l = a.createElement("link"), m.preload = l, l.addEventListener("load", function() {
      return m.loading |= 1;
    }), l.addEventListener("error", function() {
      return m.loading |= 2;
    }), Rn(l, "link", f), Lt(l), a.head.appendChild(l));
  }
  function Yl(a) {
    return '[src="' + An(a) + '"]';
  }
  function Vc(a) {
    return "script[async]" + a;
  }
  function IE(a, l, f) {
    if (l.count++, l.instance === null)
      switch (l.type) {
        case "style":
          var m = a.querySelector(
            'style[data-href~="' + An(f.href) + '"]'
          );
          if (m)
            return l.instance = m, Lt(m), m;
          var w = p({}, f, {
            "data-href": f.href,
            "data-precedence": f.precedence,
            href: null,
            precedence: null
          });
          return m = (a.ownerDocument || a).createElement(
            "style"
          ), Lt(m), Rn(m, "style", w), Ap(m, f.precedence, a), l.instance = m;
        case "stylesheet":
          w = $l(f.href);
          var k = a.querySelector(
            Ic(w)
          );
          if (k)
            return l.state.loading |= 4, l.instance = k, Lt(k), k;
          m = LE(f), (w = oo.get(w)) && Iv(m, w), k = (a.ownerDocument || a).createElement("link"), Lt(k);
          var T = k;
          return T._p = new Promise(function(B, G) {
            T.onload = B, T.onerror = G;
          }), Rn(k, "link", m), l.state.loading |= 4, Ap(k, f.precedence, a), l.instance = k;
        case "script":
          return k = Yl(f.src), (w = a.querySelector(
            Vc(k)
          )) ? (l.instance = w, Lt(w), w) : (m = f, (w = oo.get(k)) && (m = p({}, f), Vv(m, w)), a = a.ownerDocument || a, w = a.createElement("script"), Lt(w), Rn(w, "link", m), a.head.appendChild(w), l.instance = w);
        case "void":
          return null;
        default:
          throw Error(r(443, l.type));
      }
    else
      l.type === "stylesheet" && (l.state.loading & 4) === 0 && (m = l.instance, l.state.loading |= 4, Ap(m, f.precedence, a));
    return l.instance;
  }
  function Ap(a, l, f) {
    for (var m = f.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), w = m.length ? m[m.length - 1] : null, k = w, T = 0; T < m.length; T++) {
      var B = m[T];
      if (B.dataset.precedence === l) k = B;
      else if (k !== w) break;
    }
    k ? k.parentNode.insertBefore(a, k.nextSibling) : (l = f.nodeType === 9 ? f.head : f, l.insertBefore(a, l.firstChild));
  }
  function Iv(a, l) {
    a.crossOrigin == null && (a.crossOrigin = l.crossOrigin), a.referrerPolicy == null && (a.referrerPolicy = l.referrerPolicy), a.title == null && (a.title = l.title);
  }
  function Vv(a, l) {
    a.crossOrigin == null && (a.crossOrigin = l.crossOrigin), a.referrerPolicy == null && (a.referrerPolicy = l.referrerPolicy), a.integrity == null && (a.integrity = l.integrity);
  }
  var Np = null;
  function VE(a, l, f) {
    if (Np === null) {
      var m = /* @__PURE__ */ new Map(), w = Np = /* @__PURE__ */ new Map();
      w.set(f, m);
    } else
      w = Np, m = w.get(f), m || (m = /* @__PURE__ */ new Map(), w.set(f, m));
    if (m.has(a)) return m;
    for (m.set(a, null), f = f.getElementsByTagName(a), w = 0; w < f.length; w++) {
      var k = f[w];
      if (!(k[Pn] || k[an] || a === "link" && k.getAttribute("rel") === "stylesheet") && k.namespaceURI !== "http://www.w3.org/2000/svg") {
        var T = k.getAttribute(l) || "";
        T = a + T;
        var B = m.get(T);
        B ? B.push(k) : m.set(T, [k]);
      }
    }
    return m;
  }
  function BE(a, l, f) {
    a = a.ownerDocument || a, a.head.insertBefore(
      f,
      l === "title" ? a.querySelector("head > title") : null
    );
  }
  function n9(a, l, f) {
    if (f === 1 || l.itemProp != null) return !1;
    switch (a) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof l.precedence != "string" || typeof l.href != "string" || l.href === "")
          break;
        return !0;
      case "link":
        if (typeof l.rel != "string" || typeof l.href != "string" || l.href === "" || l.onLoad || l.onError)
          break;
        switch (l.rel) {
          case "stylesheet":
            return a = l.disabled, typeof l.precedence == "string" && a == null;
          default:
            return !0;
        }
      case "script":
        if (l.async && typeof l.async != "function" && typeof l.async != "symbol" && !l.onLoad && !l.onError && l.src && typeof l.src == "string")
          return !0;
    }
    return !1;
  }
  function FE(a) {
    return !(a.type === "stylesheet" && (a.state.loading & 3) === 0);
  }
  var Bc = null;
  function r9() {
  }
  function o9(a, l, f) {
    if (Bc === null) throw Error(r(475));
    var m = Bc;
    if (l.type === "stylesheet" && (typeof f.media != "string" || matchMedia(f.media).matches !== !1) && (l.state.loading & 4) === 0) {
      if (l.instance === null) {
        var w = $l(f.href), k = a.querySelector(
          Ic(w)
        );
        if (k) {
          a = k._p, a !== null && typeof a == "object" && typeof a.then == "function" && (m.count++, m = Mp.bind(m), a.then(m, m)), l.state.loading |= 4, l.instance = k, Lt(k);
          return;
        }
        k = a.ownerDocument || a, f = LE(f), (w = oo.get(w)) && Iv(f, w), k = k.createElement("link"), Lt(k);
        var T = k;
        T._p = new Promise(function(B, G) {
          T.onload = B, T.onerror = G;
        }), Rn(k, "link", f), l.instance = k;
      }
      m.stylesheets === null && (m.stylesheets = /* @__PURE__ */ new Map()), m.stylesheets.set(l, a), (a = l.state.preload) && (l.state.loading & 3) === 0 && (m.count++, l = Mp.bind(m), a.addEventListener("load", l), a.addEventListener("error", l));
    }
  }
  function i9() {
    if (Bc === null) throw Error(r(475));
    var a = Bc;
    return a.stylesheets && a.count === 0 && Bv(a, a.stylesheets), 0 < a.count ? function(l) {
      var f = setTimeout(function() {
        if (a.stylesheets && Bv(a, a.stylesheets), a.unsuspend) {
          var m = a.unsuspend;
          a.unsuspend = null, m();
        }
      }, 6e4);
      return a.unsuspend = l, function() {
        a.unsuspend = null, clearTimeout(f);
      };
    } : null;
  }
  function Mp() {
    if (this.count--, this.count === 0) {
      if (this.stylesheets) Bv(this, this.stylesheets);
      else if (this.unsuspend) {
        var a = this.unsuspend;
        this.unsuspend = null, a();
      }
    }
  }
  var Rp = null;
  function Bv(a, l) {
    a.stylesheets = null, a.unsuspend !== null && (a.count++, Rp = /* @__PURE__ */ new Map(), l.forEach(a9, a), Rp = null, Mp.call(a));
  }
  function a9(a, l) {
    if (!(l.state.loading & 4)) {
      var f = Rp.get(a);
      if (f) var m = f.get(null);
      else {
        f = /* @__PURE__ */ new Map(), Rp.set(a, f);
        for (var w = a.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), k = 0; k < w.length; k++) {
          var T = w[k];
          (T.nodeName === "LINK" || T.getAttribute("media") !== "not all") && (f.set(T.dataset.precedence, T), m = T);
        }
        m && f.set(null, m);
      }
      w = l.instance, T = w.getAttribute("data-precedence"), k = f.get(T) || m, k === m && f.set(null, w), f.set(T, w), this.count++, m = Mp.bind(this), w.addEventListener("load", m), w.addEventListener("error", m), k ? k.parentNode.insertBefore(w, k.nextSibling) : (a = a.nodeType === 9 ? a.head : a, a.insertBefore(w, a.firstChild)), l.state.loading |= 4;
    }
  }
  var Fc = {
    $$typeof: C,
    Provider: null,
    Consumer: null,
    _currentValue: Y,
    _currentValue2: Y,
    _threadCount: 0
  };
  function s9(a, l, f, m, w, k, T, B) {
    this.tag = 1, this.containerInfo = a, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = wr(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = wr(0), this.hiddenUpdates = wr(null), this.identifierPrefix = m, this.onUncaughtError = w, this.onCaughtError = k, this.onRecoverableError = T, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = B, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function UE(a, l, f, m, w, k, T, B, G, ne, fe, ge) {
    return a = new s9(
      a,
      l,
      f,
      T,
      B,
      G,
      ne,
      ge
    ), l = 1, k === !0 && (l |= 24), k = Cr(3, null, null, l), a.current = k, k.stateNode = a, l = xy(), l.refCount++, a.pooledCache = l, l.refCount++, k.memoizedState = {
      element: m,
      isDehydrated: f,
      cache: l
    }, Ey(k), a;
  }
  function HE(a) {
    return a ? (a = Sl, a) : Sl;
  }
  function $E(a, l, f, m, w, k) {
    w = HE(w), m.context === null ? m.context = w : m.pendingContext = w, m = ba(l), m.payload = { element: f }, k = k === void 0 ? null : k, k !== null && (m.callback = k), f = wa(a, m, l), f !== null && (Rr(f, a, l), yc(f, a, l));
  }
  function YE(a, l) {
    if (a = a.memoizedState, a !== null && a.dehydrated !== null) {
      var f = a.retryLane;
      a.retryLane = f !== 0 && f < l ? f : l;
    }
  }
  function Fv(a, l) {
    YE(a, l), (a = a.alternate) && YE(a, l);
  }
  function qE(a) {
    if (a.tag === 13) {
      var l = xl(a, 67108864);
      l !== null && Rr(l, a, 67108864), Fv(a, 67108864);
    }
  }
  var jp = !0;
  function l9(a, l, f, m) {
    var w = P.T;
    P.T = null;
    var k = H.p;
    try {
      H.p = 2, Uv(a, l, f, m);
    } finally {
      H.p = k, P.T = w;
    }
  }
  function u9(a, l, f, m) {
    var w = P.T;
    P.T = null;
    var k = H.p;
    try {
      H.p = 8, Uv(a, l, f, m);
    } finally {
      H.p = k, P.T = w;
    }
  }
  function Uv(a, l, f, m) {
    if (jp) {
      var w = Hv(m);
      if (w === null)
        Nv(
          a,
          l,
          m,
          zp,
          f
        ), WE(a, m);
      else if (d9(
        w,
        a,
        l,
        f,
        m
      ))
        m.stopPropagation();
      else if (WE(a, m), l & 4 && -1 < c9.indexOf(a)) {
        for (; w !== null; ) {
          var k = Gr(w);
          if (k !== null)
            switch (k.tag) {
              case 3:
                if (k = k.stateNode, k.current.memoizedState.isDehydrated) {
                  var T = kn(k.pendingLanes);
                  if (T !== 0) {
                    var B = k;
                    for (B.pendingLanes |= 2, B.entangledLanes |= 2; T; ) {
                      var G = 1 << 31 - Ve(T);
                      B.entanglements[1] |= G, T &= ~G;
                    }
                    Wo(k), (wt & 6) === 0 && (gp = ft() + 500, Tc(0));
                  }
                }
                break;
              case 13:
                B = xl(k, 2), B !== null && Rr(B, k, 2), vp(), Fv(k, 2);
            }
          if (k = Hv(m), k === null && Nv(
            a,
            l,
            m,
            zp,
            f
          ), k === w) break;
          w = k;
        }
        w !== null && m.stopPropagation();
      } else
        Nv(
          a,
          l,
          m,
          null,
          f
        );
    }
  }
  function Hv(a) {
    return a = gl(a), $v(a);
  }
  var zp = null;
  function $v(a) {
    if (zp = null, a = Cn(a), a !== null) {
      var l = i(a);
      if (l === null) a = null;
      else {
        var f = l.tag;
        if (f === 13) {
          if (a = s(l), a !== null) return a;
          a = null;
        } else if (f === 3) {
          if (l.stateNode.current.memoizedState.isDehydrated)
            return l.tag === 3 ? l.stateNode.containerInfo : null;
          a = null;
        } else l !== a && (a = null);
      }
    }
    return zp = a, null;
  }
  function XE(a) {
    switch (a) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (br()) {
          case on:
            return 2;
          case vn:
            return 8;
          case De:
          case qr:
            return 32;
          case Xr:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var Yv = !1, za = null, Ta = null, Da = null, Uc = /* @__PURE__ */ new Map(), Hc = /* @__PURE__ */ new Map(), Pa = [], c9 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function WE(a, l) {
    switch (a) {
      case "focusin":
      case "focusout":
        za = null;
        break;
      case "dragenter":
      case "dragleave":
        Ta = null;
        break;
      case "mouseover":
      case "mouseout":
        Da = null;
        break;
      case "pointerover":
      case "pointerout":
        Uc.delete(l.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Hc.delete(l.pointerId);
    }
  }
  function $c(a, l, f, m, w, k) {
    return a === null || a.nativeEvent !== k ? (a = {
      blockedOn: l,
      domEventName: f,
      eventSystemFlags: m,
      nativeEvent: k,
      targetContainers: [w]
    }, l !== null && (l = Gr(l), l !== null && qE(l)), a) : (a.eventSystemFlags |= m, l = a.targetContainers, w !== null && l.indexOf(w) === -1 && l.push(w), a);
  }
  function d9(a, l, f, m, w) {
    switch (l) {
      case "focusin":
        return za = $c(
          za,
          a,
          l,
          f,
          m,
          w
        ), !0;
      case "dragenter":
        return Ta = $c(
          Ta,
          a,
          l,
          f,
          m,
          w
        ), !0;
      case "mouseover":
        return Da = $c(
          Da,
          a,
          l,
          f,
          m,
          w
        ), !0;
      case "pointerover":
        var k = w.pointerId;
        return Uc.set(
          k,
          $c(
            Uc.get(k) || null,
            a,
            l,
            f,
            m,
            w
          )
        ), !0;
      case "gotpointercapture":
        return k = w.pointerId, Hc.set(
          k,
          $c(
            Hc.get(k) || null,
            a,
            l,
            f,
            m,
            w
          )
        ), !0;
    }
    return !1;
  }
  function GE(a) {
    var l = Cn(a.target);
    if (l !== null) {
      var f = i(l);
      if (f !== null) {
        if (l = f.tag, l === 13) {
          if (l = s(f), l !== null) {
            a.blockedOn = l, fl(a.priority, function() {
              if (f.tag === 13) {
                var m = Mr();
                m = ps(m);
                var w = xl(f, m);
                w !== null && Rr(w, f, m), Fv(f, m);
              }
            });
            return;
          }
        } else if (l === 3 && f.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = f.tag === 3 ? f.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function Tp(a) {
    if (a.blockedOn !== null) return !1;
    for (var l = a.targetContainers; 0 < l.length; ) {
      var f = Hv(a.nativeEvent);
      if (f === null) {
        f = a.nativeEvent;
        var m = new f.constructor(
          f.type,
          f
        );
        bo = m, f.target.dispatchEvent(m), bo = null;
      } else
        return l = Gr(f), l !== null && qE(l), a.blockedOn = f, !1;
      l.shift();
    }
    return !0;
  }
  function ZE(a, l, f) {
    Tp(a) && f.delete(l);
  }
  function f9() {
    Yv = !1, za !== null && Tp(za) && (za = null), Ta !== null && Tp(Ta) && (Ta = null), Da !== null && Tp(Da) && (Da = null), Uc.forEach(ZE), Hc.forEach(ZE);
  }
  function Dp(a, l) {
    a.blockedOn === l && (a.blockedOn = null, Yv || (Yv = !0, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      f9
    )));
  }
  var Pp = null;
  function KE(a) {
    Pp !== a && (Pp = a, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      function() {
        Pp === a && (Pp = null);
        for (var l = 0; l < a.length; l += 3) {
          var f = a[l], m = a[l + 1], w = a[l + 2];
          if (typeof m != "function") {
            if ($v(m || f) === null)
              continue;
            break;
          }
          var k = Gr(f);
          k !== null && (a.splice(l, 3), l -= 3, $y(
            k,
            {
              pending: !0,
              data: w,
              method: f.method,
              action: m
            },
            m,
            w
          ));
        }
      }
    ));
  }
  function Yc(a) {
    function l(G) {
      return Dp(G, a);
    }
    za !== null && Dp(za, a), Ta !== null && Dp(Ta, a), Da !== null && Dp(Da, a), Uc.forEach(l), Hc.forEach(l);
    for (var f = 0; f < Pa.length; f++) {
      var m = Pa[f];
      m.blockedOn === a && (m.blockedOn = null);
    }
    for (; 0 < Pa.length && (f = Pa[0], f.blockedOn === null); )
      GE(f), f.blockedOn === null && Pa.shift();
    if (f = (a.ownerDocument || a).$$reactFormReplay, f != null)
      for (m = 0; m < f.length; m += 3) {
        var w = f[m], k = f[m + 1], T = w[wn] || null;
        if (typeof k == "function")
          T || KE(f);
        else if (T) {
          var B = null;
          if (k && k.hasAttribute("formAction")) {
            if (w = k, T = k[wn] || null)
              B = T.formAction;
            else if ($v(w) !== null) continue;
          } else B = T.action;
          typeof B == "function" ? f[m + 1] = B : (f.splice(m, 3), m -= 3), KE(f);
        }
      }
  }
  function qv(a) {
    this._internalRoot = a;
  }
  Lp.prototype.render = qv.prototype.render = function(a) {
    var l = this._internalRoot;
    if (l === null) throw Error(r(409));
    var f = l.current, m = Mr();
    $E(f, m, a, l, null, null);
  }, Lp.prototype.unmount = qv.prototype.unmount = function() {
    var a = this._internalRoot;
    if (a !== null) {
      this._internalRoot = null;
      var l = a.containerInfo;
      $E(a.current, 2, null, a, null, null), vp(), l[go] = null;
    }
  };
  function Lp(a) {
    this._internalRoot = a;
  }
  Lp.prototype.unstable_scheduleHydration = function(a) {
    if (a) {
      var l = Vo();
      a = { blockedOn: null, target: a, priority: l };
      for (var f = 0; f < Pa.length && l !== 0 && l < Pa[f].priority; f++) ;
      Pa.splice(f, 0, a), f === 0 && GE(a);
    }
  };
  var QE = t.version;
  if (QE !== "19.1.0")
    throw Error(
      r(
        527,
        QE,
        "19.1.0"
      )
    );
  H.findDOMNode = function(a) {
    var l = a._reactInternals;
    if (l === void 0)
      throw typeof a.render == "function" ? Error(r(188)) : (a = Object.keys(a).join(","), Error(r(268, a)));
    return a = c(l), a = a !== null ? d(a) : null, a = a === null ? null : a.stateNode, a;
  };
  var p9 = {
    bundleType: 0,
    version: "19.1.0",
    rendererPackageName: "react-dom",
    currentDispatcherRef: P,
    reconcilerVersion: "19.1.0"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Ip = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Ip.isDisabled && Ip.supportsFiber)
      try {
        ce = Ip.inject(
          p9
        ), ye = Ip;
      } catch {
      }
  }
  return Xc.createRoot = function(a, l) {
    if (!o(a)) throw Error(r(299));
    var f = !1, m = "", w = h2, k = m2, T = g2, B = null;
    return l != null && (l.unstable_strictMode === !0 && (f = !0), l.identifierPrefix !== void 0 && (m = l.identifierPrefix), l.onUncaughtError !== void 0 && (w = l.onUncaughtError), l.onCaughtError !== void 0 && (k = l.onCaughtError), l.onRecoverableError !== void 0 && (T = l.onRecoverableError), l.unstable_transitionCallbacks !== void 0 && (B = l.unstable_transitionCallbacks)), l = UE(
      a,
      1,
      !1,
      null,
      null,
      f,
      m,
      w,
      k,
      T,
      B,
      null
    ), a[go] = l.current, Av(a), new qv(l);
  }, Xc.hydrateRoot = function(a, l, f) {
    if (!o(a)) throw Error(r(299));
    var m = !1, w = "", k = h2, T = m2, B = g2, G = null, ne = null;
    return f != null && (f.unstable_strictMode === !0 && (m = !0), f.identifierPrefix !== void 0 && (w = f.identifierPrefix), f.onUncaughtError !== void 0 && (k = f.onUncaughtError), f.onCaughtError !== void 0 && (T = f.onCaughtError), f.onRecoverableError !== void 0 && (B = f.onRecoverableError), f.unstable_transitionCallbacks !== void 0 && (G = f.unstable_transitionCallbacks), f.formState !== void 0 && (ne = f.formState)), l = UE(
      a,
      1,
      !0,
      l,
      f ?? null,
      m,
      w,
      k,
      T,
      B,
      G,
      ne
    ), l.context = HE(null), f = l.current, m = Mr(), m = ps(m), w = ba(m), w.callback = null, wa(f, w, m), f = m, l.current.lanes = f, En(l, f), Wo(l), a[go] = l.current, Av(a), new Lp(l);
  }, Xc.version = "19.1.0", Xc;
}
var lC;
function _9() {
  if (lC) return Wv.exports;
  lC = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), Wv.exports = S9(), Wv.exports;
}
var k9 = _9(), S = nf();
const Qe = /* @__PURE__ */ Tm(S), uN = /* @__PURE__ */ m9({
  __proto__: null,
  default: Qe
}, [S]);
var rf = lN();
const E9 = /* @__PURE__ */ Tm(rf);
var C9 = Object.defineProperty, O9 = (e, t, n) => t in e ? C9(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, xh = (e, t, n) => O9(e, typeof t != "symbol" ? t + "" : t, n);
function Dm(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var uC = { exports: {} }, Wc = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cC;
function A9() {
  if (cC) return Wc;
  cC = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment");
  function n(r, o, i) {
    var s = null;
    if (i !== void 0 && (s = "" + i), o.key !== void 0 && (s = "" + o.key), "key" in o) {
      i = {};
      for (var u in o)
        u !== "key" && (i[u] = o[u]);
    } else i = o;
    return o = i.ref, {
      $$typeof: e,
      type: r,
      key: s,
      ref: o !== void 0 ? o : null,
      props: i
    };
  }
  return Wc.Fragment = t, Wc.jsx = n, Wc.jsxs = n, Wc;
}
var dC;
function N9() {
  return dC || (dC = 1, uC.exports = A9()), uC.exports;
}
var E = N9();
const M9 = {}, fC = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (u, c) => {
    const d = typeof u == "function" ? u(t) : u;
    if (!Object.is(d, t)) {
      const p = t;
      t = c ?? (typeof d != "object" || d === null) ? d : Object.assign({}, t, d), n.forEach((h) => h(t, p));
    }
  }, o = () => t, i = { setState: r, getState: o, getInitialState: () => s, subscribe: (u) => (n.add(u), () => n.delete(u)), destroy: () => {
    (M9 ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), n.clear();
  } }, s = t = e(r, o, i);
  return i;
}, cN = (e) => e ? fC(e) : fC;
var pC = { exports: {} }, Jv = {}, hC = { exports: {} }, eb = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mC;
function R9() {
  if (mC) return eb;
  mC = 1;
  var e = Qe;
  function t(h, g) {
    return h === g && (h !== 0 || 1 / h === 1 / g) || h !== h && g !== g;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, o = e.useEffect, i = e.useLayoutEffect, s = e.useDebugValue;
  function u(h, g) {
    var y = g(), b = r({ inst: { value: y, getSnapshot: g } }), v = b[0].inst, x = b[1];
    return i(
      function() {
        v.value = y, v.getSnapshot = g, c(v) && x({ inst: v });
      },
      [h, y, g]
    ), o(
      function() {
        return c(v) && x({ inst: v }), h(function() {
          c(v) && x({ inst: v });
        });
      },
      [h]
    ), s(y), y;
  }
  function c(h) {
    var g = h.getSnapshot;
    h = h.value;
    try {
      var y = g();
      return !n(h, y);
    } catch {
      return !0;
    }
  }
  function d(h, g) {
    return g();
  }
  var p = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? d : u;
  return eb.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : p, eb;
}
var gC;
function j9() {
  return gC || (gC = 1, hC.exports = R9()), hC.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yC;
function z9() {
  if (yC) return Jv;
  yC = 1;
  var e = Qe, t = j9();
  function n(d, p) {
    return d === p && (d !== 0 || 1 / d === 1 / p) || d !== d && p !== p;
  }
  var r = typeof Object.is == "function" ? Object.is : n, o = t.useSyncExternalStore, i = e.useRef, s = e.useEffect, u = e.useMemo, c = e.useDebugValue;
  return Jv.useSyncExternalStoreWithSelector = function(d, p, h, g, y) {
    var b = i(null);
    if (b.current === null) {
      var v = { hasValue: !1, value: null };
      b.current = v;
    } else v = b.current;
    b = u(
      function() {
        function _(z) {
          if (!O) {
            if (O = !0, C = z, z = g(z), y !== void 0 && v.hasValue) {
              var j = v.value;
              if (y(j, z))
                return N = j;
            }
            return N = z;
          }
          if (j = N, r(C, z)) return j;
          var I = g(z);
          return y !== void 0 && y(j, I) ? (C = z, j) : (C = z, N = I);
        }
        var O = !1, C, N, R = h === void 0 ? null : h;
        return [
          function() {
            return _(p());
          },
          R === null ? void 0 : function() {
            return _(R());
          }
        ];
      },
      [p, h, g, y]
    );
    var x = o(d, b[0], b[1]);
    return s(
      function() {
        v.hasValue = !0, v.value = x;
      },
      [x]
    ), c(x), x;
  }, Jv;
}
var vC;
function T9() {
  return vC || (vC = 1, pC.exports = z9()), pC.exports;
}
var D9 = T9();
const dN = /* @__PURE__ */ Dm(D9), fN = {}, { useDebugValue: P9 } = Qe, { useSyncExternalStoreWithSelector: L9 } = dN;
let bC = !1;
const I9 = (e) => e;
function V9(e, t = I9, n) {
  (fN ? "production" : void 0) !== "production" && n && !bC && (console.warn(
    "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
  ), bC = !0);
  const r = L9(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return P9(r), r;
}
const wC = (e) => {
  (fN ? "production" : void 0) !== "production" && typeof e != "function" && console.warn(
    "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
  );
  const t = typeof e == "function" ? cN(e) : e, n = (r, o) => V9(t, r, o);
  return Object.assign(n, t), n;
}, Jn = (e) => e ? wC(e) : wC, B9 = () => ({
  libstate: Jn((e, t) => ({
    lib: {
      shelves: []
    },
    external_worker: [],
    set: (n) => e((r) => ({ ...r, ...n })),
    get_lib: () => t().lib,
    get_external_worker: () => t().external_worker
  }))
}), F9 = ({}) => {
  const e = /* @__PURE__ */ new Map();
  return {
    nodesstates: e,
    get_node: (t, n = !0) => {
      const r = e.get(t);
      if (!r && n) {
        const o = e.keys();
        throw new Error(
          `Node ${t} not found, available nodes: ${Array.from(o)}`
        );
      }
      return r;
    }
  };
};
function Ga(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function xS(e, t) {
  if (e === t) return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null || e.constructor !== t.constructor) return !1;
  if (e.constructor === Object || e.constructor === Array) {
    const n = Object.keys(e), r = Object.keys(t);
    if (n.length !== r.length) return !1;
    for (const o of n)
      if (!r.includes(o) || !xS(e[o], t[o])) return !1;
  }
  return e instanceof Date && t instanceof Date ? e.getTime() === t.getTime() : !0;
}
const No = (e, t) => {
  let n = !1;
  if (!Ga(e))
    throw new Error("Target must be a plain object not" + typeof e);
  if (!Ga(t))
    throw new Error("Source must be a plain object not" + typeof t);
  const r = { ...e };
  return Object.keys(t).forEach((o) => {
    const i = t[o], s = e[o];
    if (Ga(i) && Ga(s)) {
      const { new_obj: u, change: c } = No(
        s,
        i
      );
      c && (n = !0, r[o] = u);
    } else xS(s, i) || (n = !0, r[o] = i);
  }), { new_obj: r, change: n };
}, of = (e, t) => {
  let n = !1;
  if (!Ga(e))
    throw new Error("Target must be a plain object");
  if (!Ga(t))
    throw new Error("Source must be a plain object");
  const r = { ...e };
  return Object.keys(t).forEach((o) => {
    const i = t[o], s = e[o];
    if (!(s === void 0 && i === void 0)) {
      if (s === void 0) {
        n = !0, r[o] = i;
        return;
      }
      if (Ga(i) && Ga(s)) {
        const { new_obj: u, change: c } = of(
          s,
          i
        );
        c && (n = !0, r[o] = u);
      }
    }
  }), { new_obj: r, change: n };
}, Jo = (e, t) => t === void 0 ? [e, !1] : [t, e !== t];
function pN(e, t) {
  throw new Error("Unhandled case: " + e + " with: " + JSON.stringify(t));
}
const hN = (e) => {
  e.io === void 0 && (e.io = {});
  let t = e.io, n = e.io_order;
  if (n === void 0)
    if (Array.isArray(t)) {
      n = t.map((o) => o.id);
      const r = {};
      for (const o of t)
        r[o.id] = o;
      t = r;
    } else
      n = Object.keys(e.io);
  else if (Array.isArray(t)) {
    const r = {};
    for (const o of t)
      r[o.id] = o, n.includes(o.id) || n.push(o.id);
    t = r;
  } else
    for (const r in t)
      n.includes(r) || n.push(r);
  return { ...e, io_order: n, io: t };
}, U9 = (e, t) => {
  const n = e.getState(), r = {}, o = hN(t), i = Object.keys(
    o
  );
  for (const s of i)
    switch (s) {
      case "id": {
        const [u, c] = Jo(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "node_id": {
        const [u, c] = Jo(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "node_name": {
        const [u, c] = Jo(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "name": {
        const [u, c] = Jo(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "in_trigger": {
        n[s].setState(!!o[s]);
        break;
      }
      case "error": {
        o[s] !== n[s] && (r[s] = o[s]);
        break;
      }
      case "render_options": {
        const [u, c] = ((d, p) => {
          if (p === void 0) return [d, !1];
          if (d === void 0) return [p, p !== void 0];
          const { new_obj: h, change: g } = No(d, p);
          return [h, g];
        })(n[s], o[s]);
        c && (r[s] = u);
        break;
      }
      case "io_order": {
        const [u, c] = ((d, p) => p === void 0 ? [d, !1] : [p, !xS(d, p)])(n[s], o[s]);
        c && (r[s] = u);
        break;
      }
      case "io": {
        const u = n[s], c = o[s];
        if (c === void 0 || u === void 0) break;
        for (const d in c) {
          if (u[d] === void 0) {
            console.error(
              "io key not found in oldvalue:",
              d,
              "allowed:",
              u,
              "for update:",
              o
            );
            continue;
          }
          u[d].update(c[d]);
        }
        break;
      }
      case "progress": {
        const [u, c] = ((d, p) => {
          if (p === void 0) return [d, !1];
          if (d === void 0) return [p, p !== void 0];
          const { new_obj: h, change: g } = No(d, p);
          return [h, g];
        })(n[s].getState(), o[s]);
        c && n[s].setState(u);
        break;
      }
      case "description": {
        r[s] = o[s];
        break;
      }
      case "properties": {
        const [u, c] = ((d, p) => {
          if (p === void 0) return [d, !1];
          if (d === void 0) return [p, p !== void 0];
          const { new_obj: h, change: g } = No(d, p);
          return [h, g];
        })(n[s], o[s]);
        c && (r[s] = u);
        break;
      }
      case "status": {
        const [u, c] = ((d, p) => {
          if (p === void 0) return [d, !1];
          if (d === void 0) return [p, p !== void 0];
          const { new_obj: h, change: g } = No(d, p);
          return [h, g];
        })(n[s], o[s]);
        c && (r[s] = u);
        break;
      }
      default:
        try {
          pN(s, o[s]);
        } catch (u) {
          console.error(u);
        }
    }
  Object.keys(r).length > 0 && e.setState(r);
}, xC = (e, t) => {
  e.properties = e.properties || {}, t.pos && (e.properties["frontend:pos"] = t.pos), t.size && (e.properties["frontend:size"] = t.size), t.collapsed !== void 0 && (e.properties["frontend:collapsed"] = !!t.collapsed);
}, H9 = (e, t) => {
  const n = e.getState(), r = {}, o = {}, i = Object.keys(t);
  for (const s of i)
    switch (s) {
      case "name": {
        const [u, c] = Jo(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "id": {
        const [u, c] = Jo(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "connected": {
        const [u, c] = Jo(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "does_trigger": {
        const [u, c] = Jo(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "hidden": {
        const [u, c] = Jo(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "full_id": {
        const [u, c] = Jo(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "is_input":
        break;
      case "node":
        break;
      case "type":
        break;
      case "value": {
        o.preview = t[s];
        break;
      }
      case "fullvalue": {
        o.full = t[s];
        break;
      }
      case "render_options": {
        const [u, c] = ((d, p) => {
          if (p === void 0) return [d, !1];
          if (d === void 0) return [p, p !== void 0];
          const { new_obj: h, change: g } = No(d, p);
          return [h, g];
        })(n[s], t[s]);
        c && (r[s] = u);
        break;
      }
      case "value_options": {
        const [u, c] = ((d, p) => {
          if (p === void 0) return [d, !1];
          if (d === void 0) return [p, p !== void 0];
          const { new_obj: h, change: g } = No(d, p);
          return [h, g];
        })(n[s], t[s]);
        c && (r[s] = u);
        break;
      }
      case "valuepreview_type": {
        r[s] = t[s];
        break;
      }
      case "emit_value_set": {
        r[s] = t[s];
        break;
      }
      case "default": {
        r[s] = t[s];
        break;
      }
      case "required": {
        r[s] = t[s];
        break;
      }
      default:
        try {
          pN(s, t[s]);
        } catch (u) {
          console.error(u);
        }
    }
  Object.keys(o).length > 0 && e.updateValueStore(o), Object.keys(r).length > 0 && e.setState(r);
};
class Hi {
  constructor({ data: t, mime: n }) {
    this._data = t, this._mime = n;
  }
  get data() {
    return this._data;
  }
  get value() {
    return this._data;
  }
  get mime() {
    return this._mime;
  }
  toString() {
    return this._data instanceof ArrayBuffer ? `DataStructure(${this._data.byteLength},${this._mime})` : this._data instanceof Blob ? `DataStructure(${this._data.size},${this._mime})` : this._data instanceof String ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Array ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Object ? `DataStructure(${Object.keys(this._data).length},${this._mime})` : `DataStructure(${this._mime})`;
  }
  toJSON() {
    return this.toString();
  }
  dispose() {
  }
}
class $9 extends Hi {
  get objectUrl() {
    if (this._objectUrl)
      return this._objectUrl;
    const t = this.data instanceof Blob ? this.data : new Blob([this.data], { type: this.mime });
    return this._objectUrl = URL.createObjectURL(t), this._objectUrl;
  }
  dispose() {
    this._objectUrl && URL.revokeObjectURL(this._objectUrl), super.dispose();
  }
  get value() {
    return this.objectUrl;
  }
}
const dn = (e) => e.buffer ? e.buffer : e, Y9 = {
  x: (e, t) => null,
  //  pad byte 	no value 	(7 )
  c: (e, t) => new DataView(dn(e)).getInt8(0),
  //  char 	bytes of length 1 	1 	b 	signed char 	integer 	1 	(1 ), (2 )
  B: (e, t) => new DataView(dn(e)).getUint8(0),
  //  unsigned char 	integer 	1 	(2 )
  "?": (e, t) => new DataView(dn(e)).getInt8(0) === 1,
  //  _Bool 	bool 	1 	(1 )
  h: (e, t) => new DataView(dn(e)).getInt16(0, t),
  //  short 	integer 	2 	(2 )
  H: (e, t) => new DataView(dn(e)).getUint16(0, t),
  //  unsigned short 	integer 	2 	(2 )
  i: (e, t) => new DataView(dn(e)).getInt32(0, t),
  //  int 	integer 	4 	(2 )
  I: (e, t) => new DataView(dn(e)).getUint32(0, t),
  //  unsigned int 	integer 	4 	(2 )
  l: (e, t) => new DataView(dn(e)).getInt32(0, t),
  //  long 	integer 	4 	(2 )
  L: (e, t) => new DataView(dn(e)).getUint32(0, t),
  //  unsigned long 	integer 	4 	(2 )
  q: (e, t) => Number(
    new DataView(dn(e)).getBigInt64(0, t)
  ),
  //  long long 	integer 	8 	(2 )
  Q: (e, t) => Number(
    new DataView(dn(e)).getBigUint64(0, t)
  ),
  //  unsigned long long 	integer 	8 	(2 )
  n: (e, t) => Number(
    new DataView(dn(e)).getBigInt64(0, t)
  ),
  //  ssize_t 	integer 	(3 )
  N: (e, t) => Number(
    new DataView(dn(e)).getBigUint64(0, t)
  ),
  //  size_t 	integer 	(3 )
  // "e":(data:ArrayBufferLike)=>{return new DataView(to_arraybuffer(data)).getFloat16(0)}, //  (6 ) float 	2 	(4 )
  f: (e, t) => new DataView(dn(e)).getFloat32(0, t),
  //  float 	float 	4 	(4 )
  d: (e, t) => new DataView(dn(e)).getFloat64(0, t),
  //  double 	float 	8 	(4 )
  s: (e, t) => new TextDecoder().decode(dn(e)),
  //  char[] 	bytes 	(9 )
  p: (e, t) => new TextDecoder().decode(dn(e)),
  //  char[] 	bytes 	(8 )
  P: (e, t) => Number(
    new DataView(dn(e)).getBigUint64(0, t)
  )
  //  void* 	int
};
class q9 extends Hi {
  constructor({ data: t, mime: n }) {
    super({ data: t, mime: n }), this._cType = n.split("application/fn.struct.")[1], this._value = null, this.parse_value();
  }
  parse_value() {
    let t = !0, n = this._cType;
    return n.startsWith("<") && (t = !0, n = n.slice(1)), n.startsWith(">") && (t = !1, n = n.slice(1)), n.startsWith("!") && (t = !1, n = n.slice(1)), n.startsWith("@") && (t = !1, n = n.slice(1)), n.startsWith("=") && (t = !1, n = n.slice(1)), this._value = Y9[n](this.data, t), this._value;
  }
  get value() {
    return this._value;
  }
  toString() {
    return this._value === null ? "null" : this._value.toString();
  }
}
class Vs extends Hi {
  constructor({ data: t, mime: n }) {
    super({ data: t, mime: n }), t.length === 0 ? this._json = void 0 : (this._json = JSON.parse(new TextDecoder().decode(dn(t))), this._json === "<NoValue>" && (this._json = void 0));
  }
  get value() {
    return this._json;
  }
  static fromObject(t) {
    const n = t === "<NoValue>" ? new Uint8Array(0) : new TextEncoder().encode(JSON.stringify(t));
    return new Vs({ data: n, mime: "application/json" });
  }
  toString() {
    return JSON.stringify(this._json);
  }
}
class X9 extends Hi {
  constructor({ data: t, mime: n }) {
    super({ data: t, mime: n }), this._value = new TextDecoder().decode(dn(t));
  }
  get value() {
    return this._value;
  }
  toString() {
    return this._value;
  }
}
const SC = ({
  data: e,
  mime: t
}) => e instanceof ArrayBuffer || e instanceof Uint8Array ? t.startsWith("application/fn.struct.") ? new q9({ data: e, mime: t }) : t.startsWith("application/json") ? new Vs({ data: e, mime: t }) : t === "text" || t.startsWith("text/") ? new X9({ data: e, mime: t }) : new $9({ data: e, mime: t }) : new Hi({ data: e, mime: t }), W9 = {
  id: "dummy",
  node_id: "dummy",
  node_name: "dummy",
  properties: {
    "frontend:size": [200, 100],
    "frontend:pos": [NaN, NaN],
    "frontend:collapsed": !1
  },
  io: {},
  name: "dummy",
  in_trigger: !1,
  progress: {
    ascii: !1,
    elapsed: 0,
    initial: 0,
    n: 0,
    prefix: "idle",
    unit: "it",
    unit_divisor: 1e3,
    unit_scale: !1
  }
}, G9 = {
  id: "dummy",
  name: "dummy",
  node: "dummy",
  full_id: "dummy",
  type: "any",
  value: void 0,
  is_input: !1,
  connected: !1,
  does_trigger: !0,
  fullvalue: void 0,
  render_options: {
    set_default: !0,
    type: "any"
  },
  hidden: !1,
  emit_value_set: !0,
  required: !1
}, Z9 = (e, t) => {
  const n = () => {
    var r;
    t.node === void 0 || t.id === void 0 || (r = e.worker) == null || r.get_io_full_value({ nid: t.node, ioid: t.id });
  };
  return t.value === "<NoValue>" && (t.value = void 0), t.fullvalue === "<NoValue>" && (t.fullvalue = void 0), t.hidden === void 0 && (t.hidden = !1), {
    ...t,
    try_get_full_value: n,
    set_hidden: (r) => {
      var o;
      t.node === void 0 || t.id === void 0 || (o = e.worker) == null || o.update_io_options({
        nid: t.node,
        ioid: t.id,
        options: { hidden: r }
      });
    }
  };
}, K9 = (e, t) => {
  if (!t.id)
    throw new Error(
      "IO must have an id but is missing for " + JSON.stringify(t)
    );
  t.name === void 0 && (t.name = t.id);
  const { new_obj: n } = of(t, G9);
  return (n.render_options.type === "any" || n.render_options.type === void 0) && (n.render_options.type = n.type), Z9(e, n);
}, Q9 = (e, t, n) => {
  let r;
  if (e === void 0)
    throw new Error("nodestore is undefined");
  return r = {
    _state: Jn(
      (o, i) => K9(t, n)
    ),
    use: () => r._state(),
    getState: () => r._state.getState(),
    setState: (o) => {
      r._state.setState(o);
    },
    update: (o) => {
      H9(r, o);
    },
    valuestore: Jn((o, i) => {
      let s = n.value;
      s === "<NoValue>" && (s = void 0), !(s instanceof Hi) && s !== void 0 && (s = Vs.fromObject(s));
      let u = n.fullvalue;
      return u === "<NoValue>" && (u = void 0), !(u instanceof Hi) && u !== void 0 && (u = Vs.fromObject(u)), {
        preview: s,
        full: u
      };
    }),
    updateValueStore: (o) => {
      r.valuestore.setState((i) => (i.preview && typeof i.preview.dispose == "function" && i.preview.dispose(), i.full && typeof i.full.dispose == "function" && i.full.dispose(), o.preview !== void 0 && o.full === void 0 && (o.full = void 0, i.full = void 0), o.preview !== void 0 && !(o.preview instanceof Hi) && (o.preview = Vs.fromObject(o.preview)), o.full !== void 0 && !(o.full instanceof Hi) && (o.full = Vs.fromObject(o.full)), { ...i, ...o }));
    },
    node: e
  }, r;
}, J9 = (e, t, n) => {
  const r = n.io_order;
  if (r === void 0)
    throw new Error("Node must have io_order");
  return {
    ...n,
    in_trigger: Jn(() => !1),
    inputs: Object.keys(n.io).filter((o) => n.io[o].is_input),
    outputs: Object.keys(n.io).filter((o) => !n.io[o].is_input),
    io: Object.fromEntries(
      Object.entries(n.io).map(([o, i]) => [
        o,
        Q9(e, t, i)
      ])
    ),
    io_order: r,
    progress: Jn(() => n.progress)
  };
}, e8 = (e, t, n) => {
  if (!n.id)
    throw new Error("Node must have an id");
  const { new_obj: r } = of(
    n,
    W9
  );
  return J9(
    e,
    t,
    r
  );
}, t8 = (e, t) => {
  const n = {
    use: () => n._state(),
    getState: () => n._state.getState(),
    setState: (r) => {
      n._state.setState(r);
    },
    update: (r) => {
      U9(n._state, r);
    }
  };
  return n._state = Jn((r, o) => e8(n, e, hN(t))), n;
};
function mn(e) {
  if (typeof e == "string" || typeof e == "number") return "" + e;
  let t = "";
  if (Array.isArray(e))
    for (let n = 0, r; n < e.length; n++)
      (r = mn(e[n])) !== "" && (t += (t && " ") + r);
  else
    for (let n in e)
      e[n] && (t += (t && " ") + n);
  return t;
}
var n8 = { value: () => {
} };
function Pm() {
  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
    if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r)) throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new Sh(n);
}
function Sh(e) {
  this._ = e;
}
function r8(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var r = "", o = n.indexOf(".");
    if (o >= 0 && (r = n.slice(o + 1), n = n.slice(0, o)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
Sh.prototype = Pm.prototype = {
  constructor: Sh,
  on: function(e, t) {
    var n = this._, r = r8(e + "", n), o, i = -1, s = r.length;
    if (arguments.length < 2) {
      for (; ++i < s; ) if ((o = (e = r[i]).type) && (o = o8(n[o], e.name))) return o;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++i < s; )
      if (o = (e = r[i]).type) n[o] = _C(n[o], e.name, t);
      else if (t == null) for (o in n) n[o] = _C(n[o], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t) e[n] = t[n].slice();
    return new Sh(e);
  },
  call: function(e, t) {
    if ((o = arguments.length - 2) > 0) for (var n = new Array(o), r = 0, o, i; r < o; ++r) n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (i = this._[e], r = 0, o = i.length; r < o; ++r) i[r].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (var r = this._[e], o = 0, i = r.length; o < i; ++o) r[o].value.apply(t, n);
  }
};
function o8(e, t) {
  for (var n = 0, r = e.length, o; n < r; ++n)
    if ((o = e[n]).name === t)
      return o.value;
}
function _C(e, t, n) {
  for (var r = 0, o = e.length; r < o; ++r)
    if (e[r].name === t) {
      e[r] = n8, e = e.slice(0, r).concat(e.slice(r + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var zw = "http://www.w3.org/1999/xhtml";
const kC = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: zw,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Lm(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), kC.hasOwnProperty(t) ? { space: kC[t], local: e } : e;
}
function i8(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === zw && t.documentElement.namespaceURI === zw ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function a8(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function mN(e) {
  var t = Lm(e);
  return (t.local ? a8 : i8)(t);
}
function s8() {
}
function SS(e) {
  return e == null ? s8 : function() {
    return this.querySelector(e);
  };
}
function l8(e) {
  typeof e != "function" && (e = SS(e));
  for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
    for (var i = t[o], s = i.length, u = r[o] = new Array(s), c, d, p = 0; p < s; ++p)
      (c = i[p]) && (d = e.call(c, c.__data__, p, i)) && ("__data__" in c && (d.__data__ = c.__data__), u[p] = d);
  return new Hr(r, this._parents);
}
function u8(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function c8() {
  return [];
}
function gN(e) {
  return e == null ? c8 : function() {
    return this.querySelectorAll(e);
  };
}
function d8(e) {
  return function() {
    return u8(e.apply(this, arguments));
  };
}
function f8(e) {
  typeof e == "function" ? e = d8(e) : e = gN(e);
  for (var t = this._groups, n = t.length, r = [], o = [], i = 0; i < n; ++i)
    for (var s = t[i], u = s.length, c, d = 0; d < u; ++d)
      (c = s[d]) && (r.push(e.call(c, c.__data__, d, s)), o.push(c));
  return new Hr(r, o);
}
function yN(e) {
  return function() {
    return this.matches(e);
  };
}
function vN(e) {
  return function(t) {
    return t.matches(e);
  };
}
var p8 = Array.prototype.find;
function h8(e) {
  return function() {
    return p8.call(this.children, e);
  };
}
function m8() {
  return this.firstElementChild;
}
function g8(e) {
  return this.select(e == null ? m8 : h8(typeof e == "function" ? e : vN(e)));
}
var y8 = Array.prototype.filter;
function v8() {
  return Array.from(this.children);
}
function b8(e) {
  return function() {
    return y8.call(this.children, e);
  };
}
function w8(e) {
  return this.selectAll(e == null ? v8 : b8(typeof e == "function" ? e : vN(e)));
}
function x8(e) {
  typeof e != "function" && (e = yN(e));
  for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
    for (var i = t[o], s = i.length, u = r[o] = [], c, d = 0; d < s; ++d)
      (c = i[d]) && e.call(c, c.__data__, d, i) && u.push(c);
  return new Hr(r, this._parents);
}
function bN(e) {
  return new Array(e.length);
}
function S8() {
  return new Hr(this._enter || this._groups.map(bN), this._parents);
}
function $h(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
$h.prototype = {
  constructor: $h,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function _8(e) {
  return function() {
    return e;
  };
}
function k8(e, t, n, r, o, i) {
  for (var s = 0, u, c = t.length, d = i.length; s < d; ++s)
    (u = t[s]) ? (u.__data__ = i[s], r[s] = u) : n[s] = new $h(e, i[s]);
  for (; s < c; ++s)
    (u = t[s]) && (o[s] = u);
}
function E8(e, t, n, r, o, i, s) {
  var u, c, d = /* @__PURE__ */ new Map(), p = t.length, h = i.length, g = new Array(p), y;
  for (u = 0; u < p; ++u)
    (c = t[u]) && (g[u] = y = s.call(c, c.__data__, u, t) + "", d.has(y) ? o[u] = c : d.set(y, c));
  for (u = 0; u < h; ++u)
    y = s.call(e, i[u], u, i) + "", (c = d.get(y)) ? (r[u] = c, c.__data__ = i[u], d.delete(y)) : n[u] = new $h(e, i[u]);
  for (u = 0; u < p; ++u)
    (c = t[u]) && d.get(g[u]) === c && (o[u] = c);
}
function C8(e) {
  return e.__data__;
}
function O8(e, t) {
  if (!arguments.length) return Array.from(this, C8);
  var n = t ? E8 : k8, r = this._parents, o = this._groups;
  typeof e != "function" && (e = _8(e));
  for (var i = o.length, s = new Array(i), u = new Array(i), c = new Array(i), d = 0; d < i; ++d) {
    var p = r[d], h = o[d], g = h.length, y = A8(e.call(p, p && p.__data__, d, r)), b = y.length, v = u[d] = new Array(b), x = s[d] = new Array(b), _ = c[d] = new Array(g);
    n(p, h, v, x, _, y, t);
    for (var O = 0, C = 0, N, R; O < b; ++O)
      if (N = v[O]) {
        for (O >= C && (C = O + 1); !(R = x[C]) && ++C < b; ) ;
        N._next = R || null;
      }
  }
  return s = new Hr(s, r), s._enter = u, s._exit = c, s;
}
function A8(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function N8() {
  return new Hr(this._exit || this._groups.map(bN), this._parents);
}
function M8(e, t, n) {
  var r = this.enter(), o = this, i = this.exit();
  return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (o = t(o), o && (o = o.selection())), n == null ? i.remove() : n(i), r && o ? r.merge(o).order() : o;
}
function R8(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, o = n.length, i = r.length, s = Math.min(o, i), u = new Array(o), c = 0; c < s; ++c)
    for (var d = n[c], p = r[c], h = d.length, g = u[c] = new Array(h), y, b = 0; b < h; ++b)
      (y = d[b] || p[b]) && (g[b] = y);
  for (; c < o; ++c)
    u[c] = n[c];
  return new Hr(u, this._parents);
}
function j8() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var r = e[t], o = r.length - 1, i = r[o], s; --o >= 0; )
      (s = r[o]) && (i && s.compareDocumentPosition(i) ^ 4 && i.parentNode.insertBefore(s, i), i = s);
  return this;
}
function z8(e) {
  e || (e = T8);
  function t(h, g) {
    return h && g ? e(h.__data__, g.__data__) : !h - !g;
  }
  for (var n = this._groups, r = n.length, o = new Array(r), i = 0; i < r; ++i) {
    for (var s = n[i], u = s.length, c = o[i] = new Array(u), d, p = 0; p < u; ++p)
      (d = s[p]) && (c[p] = d);
    c.sort(t);
  }
  return new Hr(o, this._parents).order();
}
function T8(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function D8() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function P8() {
  return Array.from(this);
}
function L8() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], o = 0, i = r.length; o < i; ++o) {
      var s = r[o];
      if (s) return s;
    }
  return null;
}
function I8() {
  let e = 0;
  for (const t of this) ++e;
  return e;
}
function V8() {
  return !this.node();
}
function B8(e) {
  for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
    for (var o = t[n], i = 0, s = o.length, u; i < s; ++i)
      (u = o[i]) && e.call(u, u.__data__, i, o);
  return this;
}
function F8(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function U8(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function H8(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function $8(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function Y8(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function q8(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function X8(e, t) {
  var n = Lm(e);
  if (arguments.length < 2) {
    var r = this.node();
    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
  }
  return this.each((t == null ? n.local ? U8 : F8 : typeof t == "function" ? n.local ? q8 : Y8 : n.local ? $8 : H8)(n, t));
}
function wN(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function W8(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function G8(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function Z8(e, t, n) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n);
  };
}
function K8(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? W8 : typeof t == "function" ? Z8 : G8)(e, t, n ?? "")) : Eu(this.node(), e);
}
function Eu(e, t) {
  return e.style.getPropertyValue(t) || wN(e).getComputedStyle(e, null).getPropertyValue(t);
}
function Q8(e) {
  return function() {
    delete this[e];
  };
}
function J8(e, t) {
  return function() {
    this[e] = t;
  };
}
function e7(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function t7(e, t) {
  return arguments.length > 1 ? this.each((t == null ? Q8 : typeof t == "function" ? e7 : J8)(e, t)) : this.node()[e];
}
function xN(e) {
  return e.trim().split(/^|\s+/);
}
function _S(e) {
  return e.classList || new SN(e);
}
function SN(e) {
  this._node = e, this._names = xN(e.getAttribute("class") || "");
}
SN.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function _N(e, t) {
  for (var n = _S(e), r = -1, o = t.length; ++r < o; ) n.add(t[r]);
}
function kN(e, t) {
  for (var n = _S(e), r = -1, o = t.length; ++r < o; ) n.remove(t[r]);
}
function n7(e) {
  return function() {
    _N(this, e);
  };
}
function r7(e) {
  return function() {
    kN(this, e);
  };
}
function o7(e, t) {
  return function() {
    (t.apply(this, arguments) ? _N : kN)(this, e);
  };
}
function i7(e, t) {
  var n = xN(e + "");
  if (arguments.length < 2) {
    for (var r = _S(this.node()), o = -1, i = n.length; ++o < i; ) if (!r.contains(n[o])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? o7 : t ? n7 : r7)(n, t));
}
function a7() {
  this.textContent = "";
}
function s7(e) {
  return function() {
    this.textContent = e;
  };
}
function l7(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function u7(e) {
  return arguments.length ? this.each(e == null ? a7 : (typeof e == "function" ? l7 : s7)(e)) : this.node().textContent;
}
function c7() {
  this.innerHTML = "";
}
function d7(e) {
  return function() {
    this.innerHTML = e;
  };
}
function f7(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function p7(e) {
  return arguments.length ? this.each(e == null ? c7 : (typeof e == "function" ? f7 : d7)(e)) : this.node().innerHTML;
}
function h7() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function m7() {
  return this.each(h7);
}
function g7() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function y7() {
  return this.each(g7);
}
function v7(e) {
  var t = typeof e == "function" ? e : mN(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function b7() {
  return null;
}
function w7(e, t) {
  var n = typeof e == "function" ? e : mN(e), r = t == null ? b7 : typeof t == "function" ? t : SS(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
  });
}
function x7() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function S7() {
  return this.each(x7);
}
function _7() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function k7() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function E7(e) {
  return this.select(e ? k7 : _7);
}
function C7(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function O7(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function A7(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", r = t.indexOf(".");
    return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };
  });
}
function N7(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, r = -1, o = t.length, i; n < o; ++n)
        i = t[n], (!e.type || i.type === e.type) && i.name === e.name ? this.removeEventListener(i.type, i.listener, i.options) : t[++r] = i;
      ++r ? t.length = r : delete this.__on;
    }
  };
}
function M7(e, t, n) {
  return function() {
    var r = this.__on, o, i = O7(t);
    if (r) {
      for (var s = 0, u = r.length; s < u; ++s)
        if ((o = r[s]).type === e.type && o.name === e.name) {
          this.removeEventListener(o.type, o.listener, o.options), this.addEventListener(o.type, o.listener = i, o.options = n), o.value = t;
          return;
        }
    }
    this.addEventListener(e.type, i, n), o = { type: e.type, name: e.name, value: t, listener: i, options: n }, r ? r.push(o) : this.__on = [o];
  };
}
function R7(e, t, n) {
  var r = A7(e + ""), o, i = r.length, s;
  if (arguments.length < 2) {
    var u = this.node().__on;
    if (u) {
      for (var c = 0, d = u.length, p; c < d; ++c)
        for (o = 0, p = u[c]; o < i; ++o)
          if ((s = r[o]).type === p.type && s.name === p.name)
            return p.value;
    }
    return;
  }
  for (u = t ? M7 : N7, o = 0; o < i; ++o) this.each(u(r[o], t, n));
  return this;
}
function EN(e, t, n) {
  var r = wN(e), o = r.CustomEvent;
  typeof o == "function" ? o = new o(t, n) : (o = r.document.createEvent("Event"), n ? (o.initEvent(t, n.bubbles, n.cancelable), o.detail = n.detail) : o.initEvent(t, !1, !1)), e.dispatchEvent(o);
}
function j7(e, t) {
  return function() {
    return EN(this, e, t);
  };
}
function z7(e, t) {
  return function() {
    return EN(this, e, t.apply(this, arguments));
  };
}
function T7(e, t) {
  return this.each((typeof t == "function" ? z7 : j7)(e, t));
}
function* D7() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], o = 0, i = r.length, s; o < i; ++o)
      (s = r[o]) && (yield s);
}
var CN = [null];
function Hr(e, t) {
  this._groups = e, this._parents = t;
}
function af() {
  return new Hr([[document.documentElement]], CN);
}
function P7() {
  return this;
}
Hr.prototype = af.prototype = {
  constructor: Hr,
  select: l8,
  selectAll: f8,
  selectChild: g8,
  selectChildren: w8,
  filter: x8,
  data: O8,
  enter: S8,
  exit: N8,
  join: M8,
  merge: R8,
  selection: P7,
  order: j8,
  sort: z8,
  call: D8,
  nodes: P8,
  node: L8,
  size: I8,
  empty: V8,
  each: B8,
  attr: X8,
  style: K8,
  property: t7,
  classed: i7,
  text: u7,
  html: p7,
  raise: m7,
  lower: y7,
  append: v7,
  insert: w7,
  remove: S7,
  clone: E7,
  datum: C7,
  on: R7,
  dispatch: T7,
  [Symbol.iterator]: D7
};
function Pr(e) {
  return typeof e == "string" ? new Hr([[document.querySelector(e)]], [document.documentElement]) : new Hr([[e]], CN);
}
function L7(e) {
  let t;
  for (; t = e.sourceEvent; ) e = t;
  return e;
}
function Co(e, t) {
  if (e = L7(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var r = n.createSVGPoint();
      return r.x = e.clientX, r.y = e.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
    }
    if (t.getBoundingClientRect) {
      var o = t.getBoundingClientRect();
      return [e.clientX - o.left - t.clientLeft, e.clientY - o.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
const I7 = { passive: !1 }, Ad = { capture: !0, passive: !1 };
function tb(e) {
  e.stopImmediatePropagation();
}
function mu(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function ON(e) {
  var t = e.document.documentElement, n = Pr(e).on("dragstart.drag", mu, Ad);
  "onselectstart" in t ? n.on("selectstart.drag", mu, Ad) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function AN(e, t) {
  var n = e.document.documentElement, r = Pr(e).on("dragstart.drag", null);
  t && (r.on("click.drag", mu, Ad), setTimeout(function() {
    r.on("click.drag", null);
  }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
const Vp = (e) => () => e;
function Tw(e, {
  sourceEvent: t,
  subject: n,
  target: r,
  identifier: o,
  active: i,
  x: s,
  y: u,
  dx: c,
  dy: d,
  dispatch: p
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    subject: { value: n, enumerable: !0, configurable: !0 },
    target: { value: r, enumerable: !0, configurable: !0 },
    identifier: { value: o, enumerable: !0, configurable: !0 },
    active: { value: i, enumerable: !0, configurable: !0 },
    x: { value: s, enumerable: !0, configurable: !0 },
    y: { value: u, enumerable: !0, configurable: !0 },
    dx: { value: c, enumerable: !0, configurable: !0 },
    dy: { value: d, enumerable: !0, configurable: !0 },
    _: { value: p }
  });
}
Tw.prototype.on = function() {
  var e = this._.on.apply(this._, arguments);
  return e === this._ ? this : e;
};
function V7(e) {
  return !e.ctrlKey && !e.button;
}
function B7() {
  return this.parentNode;
}
function F7(e, t) {
  return t ?? { x: e.x, y: e.y };
}
function U7() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function NN() {
  var e = V7, t = B7, n = F7, r = U7, o = {}, i = Pm("start", "drag", "end"), s = 0, u, c, d, p, h = 0;
  function g(N) {
    N.on("mousedown.drag", y).filter(r).on("touchstart.drag", x).on("touchmove.drag", _, I7).on("touchend.drag touchcancel.drag", O).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function y(N, R) {
    if (!(p || !e.call(this, N, R))) {
      var z = C(this, t.call(this, N, R), N, R, "mouse");
      z && (Pr(N.view).on("mousemove.drag", b, Ad).on("mouseup.drag", v, Ad), ON(N.view), tb(N), d = !1, u = N.clientX, c = N.clientY, z("start", N));
    }
  }
  function b(N) {
    if (mu(N), !d) {
      var R = N.clientX - u, z = N.clientY - c;
      d = R * R + z * z > h;
    }
    o.mouse("drag", N);
  }
  function v(N) {
    Pr(N.view).on("mousemove.drag mouseup.drag", null), AN(N.view, d), mu(N), o.mouse("end", N);
  }
  function x(N, R) {
    if (e.call(this, N, R)) {
      var z = N.changedTouches, j = t.call(this, N, R), I = z.length, $, A;
      for ($ = 0; $ < I; ++$)
        (A = C(this, j, N, R, z[$].identifier, z[$])) && (tb(N), A("start", N, z[$]));
    }
  }
  function _(N) {
    var R = N.changedTouches, z = R.length, j, I;
    for (j = 0; j < z; ++j)
      (I = o[R[j].identifier]) && (mu(N), I("drag", N, R[j]));
  }
  function O(N) {
    var R = N.changedTouches, z = R.length, j, I;
    for (p && clearTimeout(p), p = setTimeout(function() {
      p = null;
    }, 500), j = 0; j < z; ++j)
      (I = o[R[j].identifier]) && (tb(N), I("end", N, R[j]));
  }
  function C(N, R, z, j, I, $) {
    var A = i.copy(), V = Co($ || z, R), U, W, D;
    if ((D = n.call(N, new Tw("beforestart", {
      sourceEvent: z,
      target: g,
      identifier: I,
      active: s,
      x: V[0],
      y: V[1],
      dx: 0,
      dy: 0,
      dispatch: A
    }), j)) != null)
      return U = D.x - V[0] || 0, W = D.y - V[1] || 0, function F(P, H, Y) {
        var q = V, M;
        switch (P) {
          case "start":
            o[I] = F, M = s++;
            break;
          case "end":
            delete o[I], --s;
          // falls through
          case "drag":
            V = Co(Y || H, R), M = s;
            break;
        }
        A.call(
          P,
          N,
          new Tw(P, {
            sourceEvent: H,
            subject: D,
            target: g,
            identifier: I,
            active: M,
            x: V[0] + U,
            y: V[1] + W,
            dx: V[0] - q[0],
            dy: V[1] - q[1],
            dispatch: A
          }),
          j
        );
      };
  }
  return g.filter = function(N) {
    return arguments.length ? (e = typeof N == "function" ? N : Vp(!!N), g) : e;
  }, g.container = function(N) {
    return arguments.length ? (t = typeof N == "function" ? N : Vp(N), g) : t;
  }, g.subject = function(N) {
    return arguments.length ? (n = typeof N == "function" ? N : Vp(N), g) : n;
  }, g.touchable = function(N) {
    return arguments.length ? (r = typeof N == "function" ? N : Vp(!!N), g) : r;
  }, g.on = function() {
    var N = i.on.apply(i, arguments);
    return N === i ? g : N;
  }, g.clickDistance = function(N) {
    return arguments.length ? (h = (N = +N) * N, g) : Math.sqrt(h);
  }, g;
}
function kS(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function MN(e, t) {
  var n = Object.create(e.prototype);
  for (var r in t) n[r] = t[r];
  return n;
}
function sf() {
}
var Nd = 0.7, Yh = 1 / Nd, gu = "\\s*([+-]?\\d+)\\s*", Md = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", ui = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", H7 = /^#([0-9a-f]{3,8})$/, $7 = new RegExp(`^rgb\\(${gu},${gu},${gu}\\)$`), Y7 = new RegExp(`^rgb\\(${ui},${ui},${ui}\\)$`), q7 = new RegExp(`^rgba\\(${gu},${gu},${gu},${Md}\\)$`), X7 = new RegExp(`^rgba\\(${ui},${ui},${ui},${Md}\\)$`), W7 = new RegExp(`^hsl\\(${Md},${ui},${ui}\\)$`), G7 = new RegExp(`^hsla\\(${Md},${ui},${ui},${Md}\\)$`), EC = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
kS(sf, Rd, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: CC,
  // Deprecated! Use color.formatHex.
  formatHex: CC,
  formatHex8: Z7,
  formatHsl: K7,
  formatRgb: OC,
  toString: OC
});
function CC() {
  return this.rgb().formatHex();
}
function Z7() {
  return this.rgb().formatHex8();
}
function K7() {
  return RN(this).formatHsl();
}
function OC() {
  return this.rgb().formatRgb();
}
function Rd(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = H7.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? AC(t) : n === 3 ? new mr(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? Bp(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? Bp(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = $7.exec(e)) ? new mr(t[1], t[2], t[3], 1) : (t = Y7.exec(e)) ? new mr(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = q7.exec(e)) ? Bp(t[1], t[2], t[3], t[4]) : (t = X7.exec(e)) ? Bp(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = W7.exec(e)) ? RC(t[1], t[2] / 100, t[3] / 100, 1) : (t = G7.exec(e)) ? RC(t[1], t[2] / 100, t[3] / 100, t[4]) : EC.hasOwnProperty(e) ? AC(EC[e]) : e === "transparent" ? new mr(NaN, NaN, NaN, 0) : null;
}
function AC(e) {
  return new mr(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function Bp(e, t, n, r) {
  return r <= 0 && (e = t = n = NaN), new mr(e, t, n, r);
}
function Q7(e) {
  return e instanceof sf || (e = Rd(e)), e ? (e = e.rgb(), new mr(e.r, e.g, e.b, e.opacity)) : new mr();
}
function Dw(e, t, n, r) {
  return arguments.length === 1 ? Q7(e) : new mr(e, t, n, r ?? 1);
}
function mr(e, t, n, r) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
}
kS(mr, Dw, MN(sf, {
  brighter(e) {
    return e = e == null ? Yh : Math.pow(Yh, e), new mr(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Nd : Math.pow(Nd, e), new mr(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new mr(qs(this.r), qs(this.g), qs(this.b), qh(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: NC,
  // Deprecated! Use color.formatHex.
  formatHex: NC,
  formatHex8: J7,
  formatRgb: MC,
  toString: MC
}));
function NC() {
  return `#${Bs(this.r)}${Bs(this.g)}${Bs(this.b)}`;
}
function J7() {
  return `#${Bs(this.r)}${Bs(this.g)}${Bs(this.b)}${Bs((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function MC() {
  const e = qh(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${qs(this.r)}, ${qs(this.g)}, ${qs(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function qh(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function qs(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Bs(e) {
  return e = qs(e), (e < 16 ? "0" : "") + e.toString(16);
}
function RC(e, t, n, r) {
  return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Ao(e, t, n, r);
}
function RN(e) {
  if (e instanceof Ao) return new Ao(e.h, e.s, e.l, e.opacity);
  if (e instanceof sf || (e = Rd(e)), !e) return new Ao();
  if (e instanceof Ao) return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, r = e.b / 255, o = Math.min(t, n, r), i = Math.max(t, n, r), s = NaN, u = i - o, c = (i + o) / 2;
  return u ? (t === i ? s = (n - r) / u + (n < r) * 6 : n === i ? s = (r - t) / u + 2 : s = (t - n) / u + 4, u /= c < 0.5 ? i + o : 2 - i - o, s *= 60) : u = c > 0 && c < 1 ? 0 : s, new Ao(s, u, c, e.opacity);
}
function eI(e, t, n, r) {
  return arguments.length === 1 ? RN(e) : new Ao(e, t, n, r ?? 1);
}
function Ao(e, t, n, r) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
}
kS(Ao, eI, MN(sf, {
  brighter(e) {
    return e = e == null ? Yh : Math.pow(Yh, e), new Ao(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Nd : Math.pow(Nd, e), new Ao(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, o = 2 * n - r;
    return new mr(
      nb(e >= 240 ? e - 240 : e + 120, o, r),
      nb(e, o, r),
      nb(e < 120 ? e + 240 : e - 120, o, r),
      this.opacity
    );
  },
  clamp() {
    return new Ao(jC(this.h), Fp(this.s), Fp(this.l), qh(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = qh(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${jC(this.h)}, ${Fp(this.s) * 100}%, ${Fp(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function jC(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function Fp(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function nb(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const jN = (e) => () => e;
function tI(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function nI(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {
    return Math.pow(e + r * t, n);
  };
}
function rI(e) {
  return (e = +e) == 1 ? zN : function(t, n) {
    return n - t ? nI(t, n, e) : jN(isNaN(t) ? n : t);
  };
}
function zN(e, t) {
  var n = t - e;
  return n ? tI(e, n) : jN(isNaN(e) ? t : e);
}
const zC = function e(t) {
  var n = rI(t);
  function r(o, i) {
    var s = n((o = Dw(o)).r, (i = Dw(i)).r), u = n(o.g, i.g), c = n(o.b, i.b), d = zN(o.opacity, i.opacity);
    return function(p) {
      return o.r = s(p), o.g = u(p), o.b = c(p), o.opacity = d(p), o + "";
    };
  }
  return r.gamma = e, r;
}(1);
function $a(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
var Pw = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, rb = new RegExp(Pw.source, "g");
function oI(e) {
  return function() {
    return e;
  };
}
function iI(e) {
  return function(t) {
    return e(t) + "";
  };
}
function aI(e, t) {
  var n = Pw.lastIndex = rb.lastIndex = 0, r, o, i, s = -1, u = [], c = [];
  for (e = e + "", t = t + ""; (r = Pw.exec(e)) && (o = rb.exec(t)); )
    (i = o.index) > n && (i = t.slice(n, i), u[s] ? u[s] += i : u[++s] = i), (r = r[0]) === (o = o[0]) ? u[s] ? u[s] += o : u[++s] = o : (u[++s] = null, c.push({ i: s, x: $a(r, o) })), n = rb.lastIndex;
  return n < t.length && (i = t.slice(n), u[s] ? u[s] += i : u[++s] = i), u.length < 2 ? c[0] ? iI(c[0].x) : oI(t) : (t = c.length, function(d) {
    for (var p = 0, h; p < t; ++p) u[(h = c[p]).i] = h.x(d);
    return u.join("");
  });
}
var TC = 180 / Math.PI, TN = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function DN(e, t, n, r, o, i) {
  var s, u, c;
  return (s = Math.sqrt(e * e + t * t)) && (e /= s, t /= s), (c = e * n + t * r) && (n -= e * c, r -= t * c), (u = Math.sqrt(n * n + r * r)) && (n /= u, r /= u, c /= u), e * r < t * n && (e = -e, t = -t, c = -c, s = -s), {
    translateX: o,
    translateY: i,
    rotate: Math.atan2(t, e) * TC,
    skewX: Math.atan(c) * TC,
    scaleX: s,
    scaleY: u
  };
}
var Up;
function sI(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? TN : DN(t.a, t.b, t.c, t.d, t.e, t.f);
}
function lI(e) {
  return e == null || (Up || (Up = document.createElementNS("http://www.w3.org/2000/svg", "g")), Up.setAttribute("transform", e), !(e = Up.transform.baseVal.consolidate())) ? TN : (e = e.matrix, DN(e.a, e.b, e.c, e.d, e.e, e.f));
}
function PN(e, t, n, r) {
  function o(d) {
    return d.length ? d.pop() + " " : "";
  }
  function i(d, p, h, g, y, b) {
    if (d !== h || p !== g) {
      var v = y.push("translate(", null, t, null, n);
      b.push({ i: v - 4, x: $a(d, h) }, { i: v - 2, x: $a(p, g) });
    } else (h || g) && y.push("translate(" + h + t + g + n);
  }
  function s(d, p, h, g) {
    d !== p ? (d - p > 180 ? p += 360 : p - d > 180 && (d += 360), g.push({ i: h.push(o(h) + "rotate(", null, r) - 2, x: $a(d, p) })) : p && h.push(o(h) + "rotate(" + p + r);
  }
  function u(d, p, h, g) {
    d !== p ? g.push({ i: h.push(o(h) + "skewX(", null, r) - 2, x: $a(d, p) }) : p && h.push(o(h) + "skewX(" + p + r);
  }
  function c(d, p, h, g, y, b) {
    if (d !== h || p !== g) {
      var v = y.push(o(y) + "scale(", null, ",", null, ")");
      b.push({ i: v - 4, x: $a(d, h) }, { i: v - 2, x: $a(p, g) });
    } else (h !== 1 || g !== 1) && y.push(o(y) + "scale(" + h + "," + g + ")");
  }
  return function(d, p) {
    var h = [], g = [];
    return d = e(d), p = e(p), i(d.translateX, d.translateY, p.translateX, p.translateY, h, g), s(d.rotate, p.rotate, h, g), u(d.skewX, p.skewX, h, g), c(d.scaleX, d.scaleY, p.scaleX, p.scaleY, h, g), d = p = null, function(y) {
      for (var b = -1, v = g.length, x; ++b < v; ) h[(x = g[b]).i] = x.x(y);
      return h.join("");
    };
  };
}
var uI = PN(sI, "px, ", "px)", "deg)"), cI = PN(lI, ", ", ")", ")"), dI = 1e-12;
function DC(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function fI(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function pI(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const hI = function e(t, n, r) {
  function o(i, s) {
    var u = i[0], c = i[1], d = i[2], p = s[0], h = s[1], g = s[2], y = p - u, b = h - c, v = y * y + b * b, x, _;
    if (v < dI)
      _ = Math.log(g / d) / t, x = function(j) {
        return [
          u + j * y,
          c + j * b,
          d * Math.exp(t * j * _)
        ];
      };
    else {
      var O = Math.sqrt(v), C = (g * g - d * d + r * v) / (2 * d * n * O), N = (g * g - d * d - r * v) / (2 * g * n * O), R = Math.log(Math.sqrt(C * C + 1) - C), z = Math.log(Math.sqrt(N * N + 1) - N);
      _ = (z - R) / t, x = function(j) {
        var I = j * _, $ = DC(R), A = d / (n * O) * ($ * pI(t * I + R) - fI(R));
        return [
          u + A * y,
          c + A * b,
          d * $ / DC(t * I + R)
        ];
      };
    }
    return x.duration = _ * 1e3 * t / Math.SQRT2, x;
  }
  return o.rho = function(i) {
    var s = Math.max(1e-3, +i), u = s * s, c = u * u;
    return e(s, u, c);
  }, o;
}(Math.SQRT2, 2, 4);
var Cu = 0, ad = 0, Gc = 0, LN = 1e3, Xh, sd, Wh = 0, Gs = 0, Im = 0, jd = typeof performance == "object" && performance.now ? performance : Date, IN = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function ES() {
  return Gs || (IN(mI), Gs = jd.now() + Im);
}
function mI() {
  Gs = 0;
}
function Gh() {
  this._call = this._time = this._next = null;
}
Gh.prototype = VN.prototype = {
  constructor: Gh,
  restart: function(e, t, n) {
    if (typeof e != "function") throw new TypeError("callback is not a function");
    n = (n == null ? ES() : +n) + (t == null ? 0 : +t), !this._next && sd !== this && (sd ? sd._next = this : Xh = this, sd = this), this._call = e, this._time = n, Lw();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Lw());
  }
};
function VN(e, t, n) {
  var r = new Gh();
  return r.restart(e, t, n), r;
}
function gI() {
  ES(), ++Cu;
  for (var e = Xh, t; e; )
    (t = Gs - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --Cu;
}
function PC() {
  Gs = (Wh = jd.now()) + Im, Cu = ad = 0;
  try {
    gI();
  } finally {
    Cu = 0, vI(), Gs = 0;
  }
}
function yI() {
  var e = jd.now(), t = e - Wh;
  t > LN && (Im -= t, Wh = e);
}
function vI() {
  for (var e, t = Xh, n, r = 1 / 0; t; )
    t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : Xh = n);
  sd = e, Lw(r);
}
function Lw(e) {
  if (!Cu) {
    ad && (ad = clearTimeout(ad));
    var t = e - Gs;
    t > 24 ? (e < 1 / 0 && (ad = setTimeout(PC, e - jd.now() - Im)), Gc && (Gc = clearInterval(Gc))) : (Gc || (Wh = jd.now(), Gc = setInterval(yI, LN)), Cu = 1, IN(PC));
  }
}
function LC(e, t, n) {
  var r = new Gh();
  return t = t == null ? 0 : +t, r.restart((o) => {
    r.stop(), e(o + t);
  }, t, n), r;
}
var bI = Pm("start", "end", "cancel", "interrupt"), wI = [], BN = 0, IC = 1, Iw = 2, _h = 3, VC = 4, Vw = 5, kh = 6;
function Vm(e, t, n, r, o, i) {
  var s = e.__transition;
  if (!s) e.__transition = {};
  else if (n in s) return;
  xI(e, n, {
    name: t,
    index: r,
    // For context during callback.
    group: o,
    // For context during callback.
    on: bI,
    tween: wI,
    time: i.time,
    delay: i.delay,
    duration: i.duration,
    ease: i.ease,
    timer: null,
    state: BN
  });
}
function CS(e, t) {
  var n = To(e, t);
  if (n.state > BN) throw new Error("too late; already scheduled");
  return n;
}
function hi(e, t) {
  var n = To(e, t);
  if (n.state > _h) throw new Error("too late; already running");
  return n;
}
function To(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t])) throw new Error("transition not found");
  return n;
}
function xI(e, t, n) {
  var r = e.__transition, o;
  r[t] = n, n.timer = VN(i, 0, n.time);
  function i(d) {
    n.state = IC, n.timer.restart(s, n.delay, n.time), n.delay <= d && s(d - n.delay);
  }
  function s(d) {
    var p, h, g, y;
    if (n.state !== IC) return c();
    for (p in r)
      if (y = r[p], y.name === n.name) {
        if (y.state === _h) return LC(s);
        y.state === VC ? (y.state = kh, y.timer.stop(), y.on.call("interrupt", e, e.__data__, y.index, y.group), delete r[p]) : +p < t && (y.state = kh, y.timer.stop(), y.on.call("cancel", e, e.__data__, y.index, y.group), delete r[p]);
      }
    if (LC(function() {
      n.state === _h && (n.state = VC, n.timer.restart(u, n.delay, n.time), u(d));
    }), n.state = Iw, n.on.call("start", e, e.__data__, n.index, n.group), n.state === Iw) {
      for (n.state = _h, o = new Array(g = n.tween.length), p = 0, h = -1; p < g; ++p)
        (y = n.tween[p].value.call(e, e.__data__, n.index, n.group)) && (o[++h] = y);
      o.length = h + 1;
    }
  }
  function u(d) {
    for (var p = d < n.duration ? n.ease.call(null, d / n.duration) : (n.timer.restart(c), n.state = Vw, 1), h = -1, g = o.length; ++h < g; )
      o[h].call(e, p);
    n.state === Vw && (n.on.call("end", e, e.__data__, n.index, n.group), c());
  }
  function c() {
    n.state = kh, n.timer.stop(), delete r[t];
    for (var d in r) return;
    delete e.__transition;
  }
}
function Eh(e, t) {
  var n = e.__transition, r, o, i = !0, s;
  if (n) {
    t = t == null ? null : t + "";
    for (s in n) {
      if ((r = n[s]).name !== t) {
        i = !1;
        continue;
      }
      o = r.state > Iw && r.state < Vw, r.state = kh, r.timer.stop(), r.on.call(o ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete n[s];
    }
    i && delete e.__transition;
  }
}
function SI(e) {
  return this.each(function() {
    Eh(this, e);
  });
}
function _I(e, t) {
  var n, r;
  return function() {
    var o = hi(this, e), i = o.tween;
    if (i !== n) {
      r = n = i;
      for (var s = 0, u = r.length; s < u; ++s)
        if (r[s].name === t) {
          r = r.slice(), r.splice(s, 1);
          break;
        }
    }
    o.tween = r;
  };
}
function kI(e, t, n) {
  var r, o;
  if (typeof n != "function") throw new Error();
  return function() {
    var i = hi(this, e), s = i.tween;
    if (s !== r) {
      o = (r = s).slice();
      for (var u = { name: t, value: n }, c = 0, d = o.length; c < d; ++c)
        if (o[c].name === t) {
          o[c] = u;
          break;
        }
      c === d && o.push(u);
    }
    i.tween = o;
  };
}
function EI(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var r = To(this.node(), n).tween, o = 0, i = r.length, s; o < i; ++o)
      if ((s = r[o]).name === e)
        return s.value;
    return null;
  }
  return this.each((t == null ? _I : kI)(n, e, t));
}
function OS(e, t, n) {
  var r = e._id;
  return e.each(function() {
    var o = hi(this, r);
    (o.value || (o.value = {}))[t] = n.apply(this, arguments);
  }), function(o) {
    return To(o, r).value[t];
  };
}
function FN(e, t) {
  var n;
  return (typeof t == "number" ? $a : t instanceof Rd ? zC : (n = Rd(t)) ? (t = n, zC) : aI)(e, t);
}
function CI(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function OI(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function AI(e, t, n) {
  var r, o = n + "", i;
  return function() {
    var s = this.getAttribute(e);
    return s === o ? null : s === r ? i : i = t(r = s, n);
  };
}
function NI(e, t, n) {
  var r, o = n + "", i;
  return function() {
    var s = this.getAttributeNS(e.space, e.local);
    return s === o ? null : s === r ? i : i = t(r = s, n);
  };
}
function MI(e, t, n) {
  var r, o, i;
  return function() {
    var s, u = n(this), c;
    return u == null ? void this.removeAttribute(e) : (s = this.getAttribute(e), c = u + "", s === c ? null : s === r && c === o ? i : (o = c, i = t(r = s, u)));
  };
}
function RI(e, t, n) {
  var r, o, i;
  return function() {
    var s, u = n(this), c;
    return u == null ? void this.removeAttributeNS(e.space, e.local) : (s = this.getAttributeNS(e.space, e.local), c = u + "", s === c ? null : s === r && c === o ? i : (o = c, i = t(r = s, u)));
  };
}
function jI(e, t) {
  var n = Lm(e), r = n === "transform" ? cI : FN;
  return this.attrTween(e, typeof t == "function" ? (n.local ? RI : MI)(n, r, OS(this, "attr." + e, t)) : t == null ? (n.local ? OI : CI)(n) : (n.local ? NI : AI)(n, r, t));
}
function zI(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function TI(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function DI(e, t) {
  var n, r;
  function o() {
    var i = t.apply(this, arguments);
    return i !== r && (n = (r = i) && TI(e, i)), n;
  }
  return o._value = t, o;
}
function PI(e, t) {
  var n, r;
  function o() {
    var i = t.apply(this, arguments);
    return i !== r && (n = (r = i) && zI(e, i)), n;
  }
  return o._value = t, o;
}
function LI(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (t == null) return this.tween(n, null);
  if (typeof t != "function") throw new Error();
  var r = Lm(e);
  return this.tween(n, (r.local ? DI : PI)(r, t));
}
function II(e, t) {
  return function() {
    CS(this, e).delay = +t.apply(this, arguments);
  };
}
function VI(e, t) {
  return t = +t, function() {
    CS(this, e).delay = t;
  };
}
function BI(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? II : VI)(t, e)) : To(this.node(), t).delay;
}
function FI(e, t) {
  return function() {
    hi(this, e).duration = +t.apply(this, arguments);
  };
}
function UI(e, t) {
  return t = +t, function() {
    hi(this, e).duration = t;
  };
}
function HI(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? FI : UI)(t, e)) : To(this.node(), t).duration;
}
function $I(e, t) {
  if (typeof t != "function") throw new Error();
  return function() {
    hi(this, e).ease = t;
  };
}
function YI(e) {
  var t = this._id;
  return arguments.length ? this.each($I(t, e)) : To(this.node(), t).ease;
}
function qI(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    hi(this, e).ease = n;
  };
}
function XI(e) {
  if (typeof e != "function") throw new Error();
  return this.each(qI(this._id, e));
}
function WI(e) {
  typeof e != "function" && (e = yN(e));
  for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
    for (var i = t[o], s = i.length, u = r[o] = [], c, d = 0; d < s; ++d)
      (c = i[d]) && e.call(c, c.__data__, d, i) && u.push(c);
  return new Gi(r, this._parents, this._name, this._id);
}
function GI(e) {
  if (e._id !== this._id) throw new Error();
  for (var t = this._groups, n = e._groups, r = t.length, o = n.length, i = Math.min(r, o), s = new Array(r), u = 0; u < i; ++u)
    for (var c = t[u], d = n[u], p = c.length, h = s[u] = new Array(p), g, y = 0; y < p; ++y)
      (g = c[y] || d[y]) && (h[y] = g);
  for (; u < r; ++u)
    s[u] = t[u];
  return new Gi(s, this._parents, this._name, this._id);
}
function ZI(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function KI(e, t, n) {
  var r, o, i = ZI(t) ? CS : hi;
  return function() {
    var s = i(this, e), u = s.on;
    u !== r && (o = (r = u).copy()).on(t, n), s.on = o;
  };
}
function QI(e, t) {
  var n = this._id;
  return arguments.length < 2 ? To(this.node(), n).on.on(e) : this.each(KI(n, e, t));
}
function JI(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition) if (+n !== e) return;
    t && t.removeChild(this);
  };
}
function eV() {
  return this.on("end.remove", JI(this._id));
}
function tV(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = SS(e));
  for (var r = this._groups, o = r.length, i = new Array(o), s = 0; s < o; ++s)
    for (var u = r[s], c = u.length, d = i[s] = new Array(c), p, h, g = 0; g < c; ++g)
      (p = u[g]) && (h = e.call(p, p.__data__, g, u)) && ("__data__" in p && (h.__data__ = p.__data__), d[g] = h, Vm(d[g], t, n, g, d, To(p, n)));
  return new Gi(i, this._parents, t, n);
}
function nV(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = gN(e));
  for (var r = this._groups, o = r.length, i = [], s = [], u = 0; u < o; ++u)
    for (var c = r[u], d = c.length, p, h = 0; h < d; ++h)
      if (p = c[h]) {
        for (var g = e.call(p, p.__data__, h, c), y, b = To(p, n), v = 0, x = g.length; v < x; ++v)
          (y = g[v]) && Vm(y, t, n, v, g, b);
        i.push(g), s.push(p);
      }
  return new Gi(i, s, t, n);
}
var rV = af.prototype.constructor;
function oV() {
  return new rV(this._groups, this._parents);
}
function iV(e, t) {
  var n, r, o;
  return function() {
    var i = Eu(this, e), s = (this.style.removeProperty(e), Eu(this, e));
    return i === s ? null : i === n && s === r ? o : o = t(n = i, r = s);
  };
}
function UN(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function aV(e, t, n) {
  var r, o = n + "", i;
  return function() {
    var s = Eu(this, e);
    return s === o ? null : s === r ? i : i = t(r = s, n);
  };
}
function sV(e, t, n) {
  var r, o, i;
  return function() {
    var s = Eu(this, e), u = n(this), c = u + "";
    return u == null && (c = u = (this.style.removeProperty(e), Eu(this, e))), s === c ? null : s === r && c === o ? i : (o = c, i = t(r = s, u));
  };
}
function lV(e, t) {
  var n, r, o, i = "style." + t, s = "end." + i, u;
  return function() {
    var c = hi(this, e), d = c.on, p = c.value[i] == null ? u || (u = UN(t)) : void 0;
    (d !== n || o !== p) && (r = (n = d).copy()).on(s, o = p), c.on = r;
  };
}
function uV(e, t, n) {
  var r = (e += "") == "transform" ? uI : FN;
  return t == null ? this.styleTween(e, iV(e, r)).on("end.style." + e, UN(e)) : typeof t == "function" ? this.styleTween(e, sV(e, r, OS(this, "style." + e, t))).each(lV(this._id, e)) : this.styleTween(e, aV(e, r, t), n).on("end.style." + e, null);
}
function cV(e, t, n) {
  return function(r) {
    this.style.setProperty(e, t.call(this, r), n);
  };
}
function dV(e, t, n) {
  var r, o;
  function i() {
    var s = t.apply(this, arguments);
    return s !== o && (r = (o = s) && cV(e, s, n)), r;
  }
  return i._value = t, i;
}
function fV(e, t, n) {
  var r = "style." + (e += "");
  if (arguments.length < 2) return (r = this.tween(r)) && r._value;
  if (t == null) return this.tween(r, null);
  if (typeof t != "function") throw new Error();
  return this.tween(r, dV(e, t, n ?? ""));
}
function pV(e) {
  return function() {
    this.textContent = e;
  };
}
function hV(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function mV(e) {
  return this.tween("text", typeof e == "function" ? hV(OS(this, "text", e)) : pV(e == null ? "" : e + ""));
}
function gV(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function yV(e) {
  var t, n;
  function r() {
    var o = e.apply(this, arguments);
    return o !== n && (t = (n = o) && gV(o)), t;
  }
  return r._value = e, r;
}
function vV(e) {
  var t = "text";
  if (arguments.length < 1) return (t = this.tween(t)) && t._value;
  if (e == null) return this.tween(t, null);
  if (typeof e != "function") throw new Error();
  return this.tween(t, yV(e));
}
function bV() {
  for (var e = this._name, t = this._id, n = HN(), r = this._groups, o = r.length, i = 0; i < o; ++i)
    for (var s = r[i], u = s.length, c, d = 0; d < u; ++d)
      if (c = s[d]) {
        var p = To(c, t);
        Vm(c, e, n, d, s, {
          time: p.time + p.delay + p.duration,
          delay: 0,
          duration: p.duration,
          ease: p.ease
        });
      }
  return new Gi(r, this._parents, e, n);
}
function wV() {
  var e, t, n = this, r = n._id, o = n.size();
  return new Promise(function(i, s) {
    var u = { value: s }, c = { value: function() {
      --o === 0 && i();
    } };
    n.each(function() {
      var d = hi(this, r), p = d.on;
      p !== e && (t = (e = p).copy(), t._.cancel.push(u), t._.interrupt.push(u), t._.end.push(c)), d.on = t;
    }), o === 0 && i();
  });
}
var xV = 0;
function Gi(e, t, n, r) {
  this._groups = e, this._parents = t, this._name = n, this._id = r;
}
function HN() {
  return ++xV;
}
var Ii = af.prototype;
Gi.prototype = {
  constructor: Gi,
  select: tV,
  selectAll: nV,
  selectChild: Ii.selectChild,
  selectChildren: Ii.selectChildren,
  filter: WI,
  merge: GI,
  selection: oV,
  transition: bV,
  call: Ii.call,
  nodes: Ii.nodes,
  node: Ii.node,
  size: Ii.size,
  empty: Ii.empty,
  each: Ii.each,
  on: QI,
  attr: jI,
  attrTween: LI,
  style: uV,
  styleTween: fV,
  text: mV,
  textTween: vV,
  remove: eV,
  tween: EI,
  delay: BI,
  duration: HI,
  ease: YI,
  easeVarying: XI,
  end: wV,
  [Symbol.iterator]: Ii[Symbol.iterator]
};
function SV(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var _V = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: SV
};
function kV(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function EV(e) {
  var t, n;
  e instanceof Gi ? (t = e._id, e = e._name) : (t = HN(), (n = _V).time = ES(), e = e == null ? null : e + "");
  for (var r = this._groups, o = r.length, i = 0; i < o; ++i)
    for (var s = r[i], u = s.length, c, d = 0; d < u; ++d)
      (c = s[d]) && Vm(c, e, t, d, s, n || kV(c, t));
  return new Gi(r, this._parents, e, t);
}
af.prototype.interrupt = SI;
af.prototype.transition = EV;
const Hp = (e) => () => e;
function CV(e, {
  sourceEvent: t,
  target: n,
  transform: r,
  dispatch: o
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    transform: { value: r, enumerable: !0, configurable: !0 },
    _: { value: o }
  });
}
function $i(e, t, n) {
  this.k = e, this.x = t, this.y = n;
}
$i.prototype = {
  constructor: $i,
  scale: function(e) {
    return e === 1 ? this : new $i(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new $i(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var Bm = new $i(1, 0, 0);
$N.prototype = $i.prototype;
function $N(e) {
  for (; !e.__zoom; ) if (!(e = e.parentNode)) return Bm;
  return e.__zoom;
}
function ob(e) {
  e.stopImmediatePropagation();
}
function Zc(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function OV(e) {
  return (!e.ctrlKey || e.type === "wheel") && !e.button;
}
function AV() {
  var e = this;
  return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
}
function BC() {
  return this.__zoom || Bm;
}
function NV(e) {
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
}
function MV() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function RV(e, t, n) {
  var r = e.invertX(t[0][0]) - n[0][0], o = e.invertX(t[1][0]) - n[1][0], i = e.invertY(t[0][1]) - n[0][1], s = e.invertY(t[1][1]) - n[1][1];
  return e.translate(
    o > r ? (r + o) / 2 : Math.min(0, r) || Math.max(0, o),
    s > i ? (i + s) / 2 : Math.min(0, i) || Math.max(0, s)
  );
}
function YN() {
  var e = OV, t = AV, n = RV, r = NV, o = MV, i = [0, 1 / 0], s = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], u = 250, c = hI, d = Pm("start", "zoom", "end"), p, h, g, y = 500, b = 150, v = 0, x = 10;
  function _(D) {
    D.property("__zoom", BC).on("wheel.zoom", I, { passive: !1 }).on("mousedown.zoom", $).on("dblclick.zoom", A).filter(o).on("touchstart.zoom", V).on("touchmove.zoom", U).on("touchend.zoom touchcancel.zoom", W).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  _.transform = function(D, F, P, H) {
    var Y = D.selection ? D.selection() : D;
    Y.property("__zoom", BC), D !== Y ? R(D, F, P, H) : Y.interrupt().each(function() {
      z(this, arguments).event(H).start().zoom(null, typeof F == "function" ? F.apply(this, arguments) : F).end();
    });
  }, _.scaleBy = function(D, F, P, H) {
    _.scaleTo(D, function() {
      var Y = this.__zoom.k, q = typeof F == "function" ? F.apply(this, arguments) : F;
      return Y * q;
    }, P, H);
  }, _.scaleTo = function(D, F, P, H) {
    _.transform(D, function() {
      var Y = t.apply(this, arguments), q = this.__zoom, M = P == null ? N(Y) : typeof P == "function" ? P.apply(this, arguments) : P, X = q.invert(M), K = typeof F == "function" ? F.apply(this, arguments) : F;
      return n(C(O(q, K), M, X), Y, s);
    }, P, H);
  }, _.translateBy = function(D, F, P, H) {
    _.transform(D, function() {
      return n(this.__zoom.translate(
        typeof F == "function" ? F.apply(this, arguments) : F,
        typeof P == "function" ? P.apply(this, arguments) : P
      ), t.apply(this, arguments), s);
    }, null, H);
  }, _.translateTo = function(D, F, P, H, Y) {
    _.transform(D, function() {
      var q = t.apply(this, arguments), M = this.__zoom, X = H == null ? N(q) : typeof H == "function" ? H.apply(this, arguments) : H;
      return n(Bm.translate(X[0], X[1]).scale(M.k).translate(
        typeof F == "function" ? -F.apply(this, arguments) : -F,
        typeof P == "function" ? -P.apply(this, arguments) : -P
      ), q, s);
    }, H, Y);
  };
  function O(D, F) {
    return F = Math.max(i[0], Math.min(i[1], F)), F === D.k ? D : new $i(F, D.x, D.y);
  }
  function C(D, F, P) {
    var H = F[0] - P[0] * D.k, Y = F[1] - P[1] * D.k;
    return H === D.x && Y === D.y ? D : new $i(D.k, H, Y);
  }
  function N(D) {
    return [(+D[0][0] + +D[1][0]) / 2, (+D[0][1] + +D[1][1]) / 2];
  }
  function R(D, F, P, H) {
    D.on("start.zoom", function() {
      z(this, arguments).event(H).start();
    }).on("interrupt.zoom end.zoom", function() {
      z(this, arguments).event(H).end();
    }).tween("zoom", function() {
      var Y = this, q = arguments, M = z(Y, q).event(H), X = t.apply(Y, q), K = P == null ? N(X) : typeof P == "function" ? P.apply(Y, q) : P, L = Math.max(X[1][0] - X[0][0], X[1][1] - X[0][1]), ee = Y.__zoom, ae = typeof F == "function" ? F.apply(Y, q) : F, le = c(ee.invert(K).concat(L / ee.k), ae.invert(K).concat(L / ae.k));
      return function(me) {
        if (me === 1) me = ae;
        else {
          var se = le(me), he = L / se[2];
          me = new $i(he, K[0] - se[0] * he, K[1] - se[1] * he);
        }
        M.zoom(null, me);
      };
    });
  }
  function z(D, F, P) {
    return !P && D.__zooming || new j(D, F);
  }
  function j(D, F) {
    this.that = D, this.args = F, this.active = 0, this.sourceEvent = null, this.extent = t.apply(D, F), this.taps = 0;
  }
  j.prototype = {
    event: function(D) {
      return D && (this.sourceEvent = D), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(D, F) {
      return this.mouse && D !== "mouse" && (this.mouse[1] = F.invert(this.mouse[0])), this.touch0 && D !== "touch" && (this.touch0[1] = F.invert(this.touch0[0])), this.touch1 && D !== "touch" && (this.touch1[1] = F.invert(this.touch1[0])), this.that.__zoom = F, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(D) {
      var F = Pr(this.that).datum();
      d.call(
        D,
        this.that,
        new CV(D, {
          sourceEvent: this.sourceEvent,
          target: _,
          transform: this.that.__zoom,
          dispatch: d
        }),
        F
      );
    }
  };
  function I(D, ...F) {
    if (!e.apply(this, arguments)) return;
    var P = z(this, F).event(D), H = this.__zoom, Y = Math.max(i[0], Math.min(i[1], H.k * Math.pow(2, r.apply(this, arguments)))), q = Co(D);
    if (P.wheel)
      (P.mouse[0][0] !== q[0] || P.mouse[0][1] !== q[1]) && (P.mouse[1] = H.invert(P.mouse[0] = q)), clearTimeout(P.wheel);
    else {
      if (H.k === Y) return;
      P.mouse = [q, H.invert(q)], Eh(this), P.start();
    }
    Zc(D), P.wheel = setTimeout(M, b), P.zoom("mouse", n(C(O(H, Y), P.mouse[0], P.mouse[1]), P.extent, s));
    function M() {
      P.wheel = null, P.end();
    }
  }
  function $(D, ...F) {
    if (g || !e.apply(this, arguments)) return;
    var P = D.currentTarget, H = z(this, F, !0).event(D), Y = Pr(D.view).on("mousemove.zoom", K, !0).on("mouseup.zoom", L, !0), q = Co(D, P), M = D.clientX, X = D.clientY;
    ON(D.view), ob(D), H.mouse = [q, this.__zoom.invert(q)], Eh(this), H.start();
    function K(ee) {
      if (Zc(ee), !H.moved) {
        var ae = ee.clientX - M, le = ee.clientY - X;
        H.moved = ae * ae + le * le > v;
      }
      H.event(ee).zoom("mouse", n(C(H.that.__zoom, H.mouse[0] = Co(ee, P), H.mouse[1]), H.extent, s));
    }
    function L(ee) {
      Y.on("mousemove.zoom mouseup.zoom", null), AN(ee.view, H.moved), Zc(ee), H.event(ee).end();
    }
  }
  function A(D, ...F) {
    if (e.apply(this, arguments)) {
      var P = this.__zoom, H = Co(D.changedTouches ? D.changedTouches[0] : D, this), Y = P.invert(H), q = P.k * (D.shiftKey ? 0.5 : 2), M = n(C(O(P, q), H, Y), t.apply(this, F), s);
      Zc(D), u > 0 ? Pr(this).transition().duration(u).call(R, M, H, D) : Pr(this).call(_.transform, M, H, D);
    }
  }
  function V(D, ...F) {
    if (e.apply(this, arguments)) {
      var P = D.touches, H = P.length, Y = z(this, F, D.changedTouches.length === H).event(D), q, M, X, K;
      for (ob(D), M = 0; M < H; ++M)
        X = P[M], K = Co(X, this), K = [K, this.__zoom.invert(K), X.identifier], Y.touch0 ? !Y.touch1 && Y.touch0[2] !== K[2] && (Y.touch1 = K, Y.taps = 0) : (Y.touch0 = K, q = !0, Y.taps = 1 + !!p);
      p && (p = clearTimeout(p)), q && (Y.taps < 2 && (h = K[0], p = setTimeout(function() {
        p = null;
      }, y)), Eh(this), Y.start());
    }
  }
  function U(D, ...F) {
    if (this.__zooming) {
      var P = z(this, F).event(D), H = D.changedTouches, Y = H.length, q, M, X, K;
      for (Zc(D), q = 0; q < Y; ++q)
        M = H[q], X = Co(M, this), P.touch0 && P.touch0[2] === M.identifier ? P.touch0[0] = X : P.touch1 && P.touch1[2] === M.identifier && (P.touch1[0] = X);
      if (M = P.that.__zoom, P.touch1) {
        var L = P.touch0[0], ee = P.touch0[1], ae = P.touch1[0], le = P.touch1[1], me = (me = ae[0] - L[0]) * me + (me = ae[1] - L[1]) * me, se = (se = le[0] - ee[0]) * se + (se = le[1] - ee[1]) * se;
        M = O(M, Math.sqrt(me / se)), X = [(L[0] + ae[0]) / 2, (L[1] + ae[1]) / 2], K = [(ee[0] + le[0]) / 2, (ee[1] + le[1]) / 2];
      } else if (P.touch0) X = P.touch0[0], K = P.touch0[1];
      else return;
      P.zoom("touch", n(C(M, X, K), P.extent, s));
    }
  }
  function W(D, ...F) {
    if (this.__zooming) {
      var P = z(this, F).event(D), H = D.changedTouches, Y = H.length, q, M;
      for (ob(D), g && clearTimeout(g), g = setTimeout(function() {
        g = null;
      }, y), q = 0; q < Y; ++q)
        M = H[q], P.touch0 && P.touch0[2] === M.identifier ? delete P.touch0 : P.touch1 && P.touch1[2] === M.identifier && delete P.touch1;
      if (P.touch1 && !P.touch0 && (P.touch0 = P.touch1, delete P.touch1), P.touch0) P.touch0[1] = this.__zoom.invert(P.touch0[0]);
      else if (P.end(), P.taps === 2 && (M = Co(M, this), Math.hypot(h[0] - M[0], h[1] - M[1]) < x)) {
        var X = Pr(this).on("dblclick.zoom");
        X && X.apply(this, arguments);
      }
    }
  }
  return _.wheelDelta = function(D) {
    return arguments.length ? (r = typeof D == "function" ? D : Hp(+D), _) : r;
  }, _.filter = function(D) {
    return arguments.length ? (e = typeof D == "function" ? D : Hp(!!D), _) : e;
  }, _.touchable = function(D) {
    return arguments.length ? (o = typeof D == "function" ? D : Hp(!!D), _) : o;
  }, _.extent = function(D) {
    return arguments.length ? (t = typeof D == "function" ? D : Hp([[+D[0][0], +D[0][1]], [+D[1][0], +D[1][1]]]), _) : t;
  }, _.scaleExtent = function(D) {
    return arguments.length ? (i[0] = +D[0], i[1] = +D[1], _) : [i[0], i[1]];
  }, _.translateExtent = function(D) {
    return arguments.length ? (s[0][0] = +D[0][0], s[1][0] = +D[1][0], s[0][1] = +D[0][1], s[1][1] = +D[1][1], _) : [[s[0][0], s[0][1]], [s[1][0], s[1][1]]];
  }, _.constrain = function(D) {
    return arguments.length ? (n = D, _) : n;
  }, _.duration = function(D) {
    return arguments.length ? (u = +D, _) : u;
  }, _.interpolate = function(D) {
    return arguments.length ? (c = D, _) : c;
  }, _.on = function() {
    var D = d.on.apply(d, arguments);
    return D === d ? _ : D;
  }, _.clickDistance = function(D) {
    return arguments.length ? (v = (D = +D) * D, _) : Math.sqrt(v);
  }, _.tapDistance = function(D) {
    return arguments.length ? (x = +D, _) : x;
  }, _;
}
const fi = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (e) => `Node type "${e}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (e) => `The old edge with id=${e} does not exist.`,
  error009: (e) => `Marker type "${e}" doesn't exist.`,
  error008: (e, { id: t, sourceHandle: n, targetHandle: r }) => `Couldn't create edge for ${e} handle id: "${e === "source" ? n : r}", edge id: ${t}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (e) => `Edge type "${e}" not found. Using fallback type "default".`,
  error012: (e) => `Node with id "${e}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
  error013: (e = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${e}/dist/style.css' or base.css to make sure everything is working properly.`,
  error014: () => "useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.",
  error015: () => "It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs."
}, zd = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
], qN = ["Enter", " ", "Escape"];
var Ou;
(function(e) {
  e.Strict = "strict", e.Loose = "loose";
})(Ou || (Ou = {}));
var Xs;
(function(e) {
  e.Free = "free", e.Vertical = "vertical", e.Horizontal = "horizontal";
})(Xs || (Xs = {}));
var Td;
(function(e) {
  e.Partial = "partial", e.Full = "full";
})(Td || (Td = {}));
const XN = {
  inProgress: !1,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null
};
var Ya;
(function(e) {
  e.Bezier = "default", e.Straight = "straight", e.Step = "step", e.SmoothStep = "smoothstep", e.SimpleBezier = "simplebezier";
})(Ya || (Ya = {}));
var Zh;
(function(e) {
  e.Arrow = "arrow", e.ArrowClosed = "arrowclosed";
})(Zh || (Zh = {}));
var je;
(function(e) {
  e.Left = "left", e.Top = "top", e.Right = "right", e.Bottom = "bottom";
})(je || (je = {}));
const FC = {
  [je.Left]: je.Right,
  [je.Right]: je.Left,
  [je.Top]: je.Bottom,
  [je.Bottom]: je.Top
};
function WN(e) {
  return e === null ? null : e ? "valid" : "invalid";
}
const GN = (e) => "id" in e && "source" in e && "target" in e, jV = (e) => "id" in e && "position" in e && !("source" in e) && !("target" in e), AS = (e) => "id" in e && "internals" in e && !("source" in e) && !("target" in e), lf = (e, t = [0, 0]) => {
  const { width: n, height: r } = ra(e), o = e.origin ?? t, i = n * o[0], s = r * o[1];
  return {
    x: e.position.x - i,
    y: e.position.y - s
  };
}, zV = (e, t = { nodeOrigin: [0, 0] }) => {
  if (e.length === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  const n = e.reduce((r, o) => {
    const i = typeof o == "string";
    let s = !t.nodeLookup && !i ? o : void 0;
    t.nodeLookup && (s = i ? t.nodeLookup.get(o) : AS(o) ? o : t.nodeLookup.get(o.id));
    const u = s ? Kh(s, t.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
    return Fm(r, u);
  }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 });
  return Um(n);
}, uf = (e, t = {}) => {
  if (e.size === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  let n = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 };
  return e.forEach((r) => {
    if (t.filter === void 0 || t.filter(r)) {
      const o = Kh(r);
      n = Fm(n, o);
    }
  }), Um(n);
}, ZN = (e, t, [n, r, o] = [0, 0, 1], i = !1, s = !1) => {
  const u = {
    ...cf(t, [n, r, o]),
    width: t.width / o,
    height: t.height / o
  }, c = [];
  for (const d of e.values()) {
    const { measured: p, selectable: h = !0, hidden: g = !1 } = d;
    if (s && !h || g)
      continue;
    const y = p.width ?? d.width ?? d.initialWidth ?? null, b = p.height ?? d.height ?? d.initialHeight ?? null, v = Dd(u, Nu(d)), x = (y ?? 0) * (b ?? 0), _ = i && v > 0;
    (!d.internals.handleBounds || _ || v >= x || d.dragging) && c.push(d);
  }
  return c;
}, TV = (e, t) => {
  const n = /* @__PURE__ */ new Set();
  return e.forEach((r) => {
    n.add(r.id);
  }), t.filter((r) => n.has(r.source) || n.has(r.target));
};
function DV(e, t) {
  const n = /* @__PURE__ */ new Map(), r = t != null && t.nodes ? new Set(t.nodes.map((o) => o.id)) : null;
  return e.forEach((o) => {
    o.measured.width && o.measured.height && (t?.includeHiddenNodes || !o.hidden) && (!r || r.has(o.id)) && n.set(o.id, o);
  }), n;
}
async function PV({ nodes: e, width: t, height: n, panZoom: r, minZoom: o, maxZoom: i }, s) {
  if (e.size === 0)
    return Promise.resolve(!0);
  const u = DV(e, s), c = uf(u), d = NS(c, t, n, s?.minZoom ?? o, s?.maxZoom ?? i, s?.padding ?? 0.1);
  return await r.setViewport(d, { duration: s?.duration }), Promise.resolve(!0);
}
function KN({ nodeId: e, nextPosition: t, nodeLookup: n, nodeOrigin: r = [0, 0], nodeExtent: o, onError: i }) {
  const s = n.get(e), u = s.parentId ? n.get(s.parentId) : void 0, { x: c, y: d } = u ? u.internals.positionAbsolute : { x: 0, y: 0 }, p = s.origin ?? r;
  let h = o;
  if (s.extent === "parent" && !s.expandParent)
    if (!u)
      i?.("005", fi.error005());
    else {
      const y = u.measured.width, b = u.measured.height;
      y && b && (h = [
        [c, d],
        [c + y, d + b]
      ]);
    }
  else u && Mu(s.extent) && (h = [
    [s.extent[0][0] + c, s.extent[0][1] + d],
    [s.extent[1][0] + c, s.extent[1][1] + d]
  ]);
  const g = Mu(h) ? Zs(t, h, s.measured) : t;
  return (s.measured.width === void 0 || s.measured.height === void 0) && i?.("015", fi.error015()), {
    position: {
      x: g.x - c + (s.measured.width ?? 0) * p[0],
      y: g.y - d + (s.measured.height ?? 0) * p[1]
    },
    positionAbsolute: g
  };
}
async function LV({ nodesToRemove: e = [], edgesToRemove: t = [], nodes: n, edges: r, onBeforeDelete: o }) {
  const i = new Set(e.map((h) => h.id)), s = [];
  for (const h of n) {
    if (h.deletable === !1)
      continue;
    const g = i.has(h.id), y = !g && h.parentId && s.find((b) => b.id === h.parentId);
    (g || y) && s.push(h);
  }
  const u = new Set(t.map((h) => h.id)), c = r.filter((h) => h.deletable !== !1), d = TV(s, c);
  for (const h of c)
    u.has(h.id) && !d.find((g) => g.id === h.id) && d.push(h);
  if (!o)
    return {
      edges: d,
      nodes: s
    };
  const p = await o({
    nodes: s,
    edges: d
  });
  return typeof p == "boolean" ? p ? { edges: d, nodes: s } : { edges: [], nodes: [] } : p;
}
const Au = (e, t = 0, n = 1) => Math.min(Math.max(e, t), n), Zs = (e = { x: 0, y: 0 }, t, n) => ({
  x: Au(e.x, t[0][0], t[1][0] - (n?.width ?? 0)),
  y: Au(e.y, t[0][1], t[1][1] - (n?.height ?? 0))
});
function QN(e, t, n) {
  const { width: r, height: o } = ra(n), { x: i, y: s } = n.internals.positionAbsolute;
  return Zs(e, [
    [i, s],
    [i + r, s + o]
  ], t);
}
const UC = (e, t, n) => e < t ? Au(Math.abs(e - t), 1, t) / t : e > n ? -Au(Math.abs(e - n), 1, t) / t : 0, JN = (e, t, n = 15, r = 40) => {
  const o = UC(e.x, r, t.width - r) * n, i = UC(e.y, r, t.height - r) * n;
  return [o, i];
}, Fm = (e, t) => ({
  x: Math.min(e.x, t.x),
  y: Math.min(e.y, t.y),
  x2: Math.max(e.x2, t.x2),
  y2: Math.max(e.y2, t.y2)
}), Bw = ({ x: e, y: t, width: n, height: r }) => ({
  x: e,
  y: t,
  x2: e + n,
  y2: t + r
}), Um = ({ x: e, y: t, x2: n, y2: r }) => ({
  x: e,
  y: t,
  width: n - e,
  height: r - t
}), Nu = (e, t = [0, 0]) => {
  var n, r;
  const { x: o, y: i } = AS(e) ? e.internals.positionAbsolute : lf(e, t);
  return {
    x: o,
    y: i,
    width: ((n = e.measured) == null ? void 0 : n.width) ?? e.width ?? e.initialWidth ?? 0,
    height: ((r = e.measured) == null ? void 0 : r.height) ?? e.height ?? e.initialHeight ?? 0
  };
}, Kh = (e, t = [0, 0]) => {
  var n, r;
  const { x: o, y: i } = AS(e) ? e.internals.positionAbsolute : lf(e, t);
  return {
    x: o,
    y: i,
    x2: o + (((n = e.measured) == null ? void 0 : n.width) ?? e.width ?? e.initialWidth ?? 0),
    y2: i + (((r = e.measured) == null ? void 0 : r.height) ?? e.height ?? e.initialHeight ?? 0)
  };
}, e1 = (e, t) => Um(Fm(Bw(e), Bw(t))), Dd = (e, t) => {
  const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)), r = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y));
  return Math.ceil(n * r);
}, HC = (e) => Mo(e.width) && Mo(e.height) && Mo(e.x) && Mo(e.y), Mo = (e) => !isNaN(e) && isFinite(e), IV = (e, t) => {
}, Hm = (e, t = [1, 1]) => ({
  x: t[0] * Math.round(e.x / t[0]),
  y: t[1] * Math.round(e.y / t[1])
}), cf = ({ x: e, y: t }, [n, r, o], i = !1, s = [1, 1]) => {
  const u = {
    x: (e - n) / o,
    y: (t - r) / o
  };
  return i ? Hm(u, s) : u;
}, Qh = ({ x: e, y: t }, [n, r, o]) => ({
  x: e * o + n,
  y: t * o + r
});
function ql(e, t) {
  if (typeof e == "number")
    return Math.floor(t - t / (1 + e));
  if (typeof e == "string" && e.endsWith("px")) {
    const n = parseFloat(e);
    if (!Number.isNaN(n))
      return Math.floor(n);
  }
  if (typeof e == "string" && e.endsWith("%")) {
    const n = parseFloat(e);
    if (!Number.isNaN(n))
      return Math.floor(t * n * 0.01);
  }
  return console.error(`[React Flow] The padding value "${e}" is invalid. Please provide a number or a string with a valid unit (px or %).`), 0;
}
function VV(e, t, n) {
  if (typeof e == "string" || typeof e == "number") {
    const r = ql(e, n), o = ql(e, t);
    return {
      top: r,
      right: o,
      bottom: r,
      left: o,
      x: o * 2,
      y: r * 2
    };
  }
  if (typeof e == "object") {
    const r = ql(e.top ?? e.y ?? 0, n), o = ql(e.bottom ?? e.y ?? 0, n), i = ql(e.left ?? e.x ?? 0, t), s = ql(e.right ?? e.x ?? 0, t);
    return { top: r, right: s, bottom: o, left: i, x: i + s, y: r + o };
  }
  return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };
}
function BV(e, t, n, r, o, i) {
  const { x: s, y: u } = Qh(e, [t, n, r]), { x: c, y: d } = Qh({ x: e.x + e.width, y: e.y + e.height }, [t, n, r]), p = o - c, h = i - d;
  return {
    left: Math.floor(s),
    top: Math.floor(u),
    right: Math.floor(p),
    bottom: Math.floor(h)
  };
}
const NS = (e, t, n, r, o, i) => {
  const s = VV(i, t, n), u = (t - s.x) / e.width, c = (n - s.y) / e.height, d = Math.min(u, c), p = Au(d, r, o), h = e.x + e.width / 2, g = e.y + e.height / 2, y = t / 2 - h * p, b = n / 2 - g * p, v = BV(e, y, b, p, t, n), x = {
    left: Math.min(v.left - s.left, 0),
    top: Math.min(v.top - s.top, 0),
    right: Math.min(v.right - s.right, 0),
    bottom: Math.min(v.bottom - s.bottom, 0)
  };
  return {
    x: y - x.left + x.right,
    y: b - x.top + x.bottom,
    zoom: p
  };
}, Jh = () => {
  var e;
  return typeof navigator < "u" && ((e = navigator?.userAgent) == null ? void 0 : e.indexOf("Mac")) >= 0;
};
function Mu(e) {
  return e !== void 0 && e !== "parent";
}
function ra(e) {
  var t, n;
  return {
    width: ((t = e.measured) == null ? void 0 : t.width) ?? e.width ?? e.initialWidth ?? 0,
    height: ((n = e.measured) == null ? void 0 : n.height) ?? e.height ?? e.initialHeight ?? 0
  };
}
function t1(e) {
  var t, n;
  return (((t = e.measured) == null ? void 0 : t.width) ?? e.width ?? e.initialWidth) !== void 0 && (((n = e.measured) == null ? void 0 : n.height) ?? e.height ?? e.initialHeight) !== void 0;
}
function n1(e, t = { width: 0, height: 0 }, n, r, o) {
  const i = { ...e }, s = r.get(n);
  if (s) {
    const u = s.origin || o;
    i.x += s.internals.positionAbsolute.x - (t.width ?? 0) * u[0], i.y += s.internals.positionAbsolute.y - (t.height ?? 0) * u[1];
  }
  return i;
}
function $C(e, t) {
  if (e.size !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
}
function md(e, { snapGrid: t = [0, 0], snapToGrid: n = !1, transform: r, containerBounds: o }) {
  const { x: i, y: s } = Yi(e), u = cf({ x: i - (o?.left ?? 0), y: s - (o?.top ?? 0) }, r), { x: c, y: d } = n ? Hm(u, t) : u;
  return {
    xSnapped: c,
    ySnapped: d,
    ...u
  };
}
const MS = (e) => ({
  width: e.offsetWidth,
  height: e.offsetHeight
}), r1 = (e) => {
  var t;
  return ((t = e?.getRootNode) == null ? void 0 : t.call(e)) || window?.document;
}, FV = ["INPUT", "SELECT", "TEXTAREA"];
function o1(e) {
  var t, n;
  const r = ((n = (t = e.composedPath) == null ? void 0 : t.call(e)) == null ? void 0 : n[0]) || e.target;
  return r?.nodeType !== 1 ? !1 : FV.includes(r.nodeName) || r.hasAttribute("contenteditable") || !!r.closest(".nokey");
}
const i1 = (e) => "clientX" in e, Yi = (e, t) => {
  var n, r;
  const o = i1(e), i = o ? e.clientX : (n = e.touches) == null ? void 0 : n[0].clientX, s = o ? e.clientY : (r = e.touches) == null ? void 0 : r[0].clientY;
  return {
    x: i - (t?.left ?? 0),
    y: s - (t?.top ?? 0)
  };
}, YC = (e, t, n, r, o) => {
  const i = t.querySelectorAll(`.${e}`);
  return !i || !i.length ? null : Array.from(i).map((s) => {
    const u = s.getBoundingClientRect();
    return {
      id: s.getAttribute("data-handleid"),
      type: e,
      nodeId: o,
      position: s.getAttribute("data-handlepos"),
      x: (u.left - n.left) / r,
      y: (u.top - n.top) / r,
      ...MS(s)
    };
  });
};
function a1({ sourceX: e, sourceY: t, targetX: n, targetY: r, sourceControlX: o, sourceControlY: i, targetControlX: s, targetControlY: u }) {
  const c = e * 0.125 + o * 0.375 + s * 0.375 + n * 0.125, d = t * 0.125 + i * 0.375 + u * 0.375 + r * 0.125, p = Math.abs(c - e), h = Math.abs(d - t);
  return [c, d, p, h];
}
function $p(e, t) {
  return e >= 0 ? 0.5 * e : t * 25 * Math.sqrt(-e);
}
function qC({ pos: e, x1: t, y1: n, x2: r, y2: o, c: i }) {
  switch (e) {
    case je.Left:
      return [t - $p(t - r, i), n];
    case je.Right:
      return [t + $p(r - t, i), n];
    case je.Top:
      return [t, n - $p(n - o, i)];
    case je.Bottom:
      return [t, n + $p(o - n, i)];
  }
}
function RS({ sourceX: e, sourceY: t, sourcePosition: n = je.Bottom, targetX: r, targetY: o, targetPosition: i = je.Top, curvature: s = 0.25 }) {
  const [u, c] = qC({
    pos: n,
    x1: e,
    y1: t,
    x2: r,
    y2: o,
    c: s
  }), [d, p] = qC({
    pos: i,
    x1: r,
    y1: o,
    x2: e,
    y2: t,
    c: s
  }), [h, g, y, b] = a1({
    sourceX: e,
    sourceY: t,
    targetX: r,
    targetY: o,
    sourceControlX: u,
    sourceControlY: c,
    targetControlX: d,
    targetControlY: p
  });
  return [
    `M${e},${t} C${u},${c} ${d},${p} ${r},${o}`,
    h,
    g,
    y,
    b
  ];
}
function s1({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
  const o = Math.abs(n - e) / 2, i = n < e ? n + o : n - o, s = Math.abs(r - t) / 2, u = r < t ? r + s : r - s;
  return [i, u, o, s];
}
function UV({ sourceNode: e, targetNode: t, selected: n = !1, zIndex: r = 0, elevateOnSelect: o = !1 }) {
  if (!o)
    return r;
  const i = n || t.selected || e.selected, s = Math.max(e.internals.z || 0, t.internals.z || 0, 1e3);
  return r + (i ? s : 0);
}
function HV({ sourceNode: e, targetNode: t, width: n, height: r, transform: o }) {
  const i = Fm(Kh(e), Kh(t));
  i.x === i.x2 && (i.x2 += 1), i.y === i.y2 && (i.y2 += 1);
  const s = {
    x: -o[0] / o[2],
    y: -o[1] / o[2],
    width: n / o[2],
    height: r / o[2]
  };
  return Dd(s, Um(i)) > 0;
}
const $V = ({ source: e, sourceHandle: t, target: n, targetHandle: r }) => `xy-edge__${e}${t || ""}-${n}${r || ""}`, YV = (e, t) => t.some((n) => n.source === e.source && n.target === e.target && (n.sourceHandle === e.sourceHandle || !n.sourceHandle && !e.sourceHandle) && (n.targetHandle === e.targetHandle || !n.targetHandle && !e.targetHandle)), qV = (e, t) => {
  if (!e.source || !e.target)
    return t;
  let n;
  return GN(e) ? n = { ...e } : n = {
    ...e,
    id: $V(e)
  }, YV(n, t) ? t : (n.sourceHandle === null && delete n.sourceHandle, n.targetHandle === null && delete n.targetHandle, t.concat(n));
};
function l1({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
  const [o, i, s, u] = s1({
    sourceX: e,
    sourceY: t,
    targetX: n,
    targetY: r
  });
  return [`M ${e},${t}L ${n},${r}`, o, i, s, u];
}
const XC = {
  [je.Left]: { x: -1, y: 0 },
  [je.Right]: { x: 1, y: 0 },
  [je.Top]: { x: 0, y: -1 },
  [je.Bottom]: { x: 0, y: 1 }
}, XV = ({ source: e, sourcePosition: t = je.Bottom, target: n }) => t === je.Left || t === je.Right ? e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, WC = (e, t) => Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
function WV({ source: e, sourcePosition: t = je.Bottom, target: n, targetPosition: r = je.Top, center: o, offset: i }) {
  const s = XC[t], u = XC[r], c = { x: e.x + s.x * i, y: e.y + s.y * i }, d = { x: n.x + u.x * i, y: n.y + u.y * i }, p = XV({
    source: c,
    sourcePosition: t,
    target: d
  }), h = p.x !== 0 ? "x" : "y", g = p[h];
  let y = [], b, v;
  const x = { x: 0, y: 0 }, _ = { x: 0, y: 0 }, [O, C, N, R] = s1({
    sourceX: e.x,
    sourceY: e.y,
    targetX: n.x,
    targetY: n.y
  });
  if (s[h] * u[h] === -1) {
    b = o.x ?? O, v = o.y ?? C;
    const z = [
      { x: b, y: c.y },
      { x: b, y: d.y }
    ], j = [
      { x: c.x, y: v },
      { x: d.x, y: v }
    ];
    s[h] === g ? y = h === "x" ? z : j : y = h === "x" ? j : z;
  } else {
    const z = [{ x: c.x, y: d.y }], j = [{ x: d.x, y: c.y }];
    if (h === "x" ? y = s.x === g ? j : z : y = s.y === g ? z : j, t === r) {
      const U = Math.abs(e[h] - n[h]);
      if (U <= i) {
        const W = Math.min(i - 1, i - U);
        s[h] === g ? x[h] = (c[h] > e[h] ? -1 : 1) * W : _[h] = (d[h] > n[h] ? -1 : 1) * W;
      }
    }
    if (t !== r) {
      const U = h === "x" ? "y" : "x", W = s[h] === u[U], D = c[U] > d[U], F = c[U] < d[U];
      (s[h] === 1 && (!W && D || W && F) || s[h] !== 1 && (!W && F || W && D)) && (y = h === "x" ? z : j);
    }
    const I = { x: c.x + x.x, y: c.y + x.y }, $ = { x: d.x + _.x, y: d.y + _.y }, A = Math.max(Math.abs(I.x - y[0].x), Math.abs($.x - y[0].x)), V = Math.max(Math.abs(I.y - y[0].y), Math.abs($.y - y[0].y));
    A >= V ? (b = (I.x + $.x) / 2, v = y[0].y) : (b = y[0].x, v = (I.y + $.y) / 2);
  }
  return [[
    e,
    { x: c.x + x.x, y: c.y + x.y },
    ...y,
    { x: d.x + _.x, y: d.y + _.y },
    n
  ], b, v, N, R];
}
function GV(e, t, n, r) {
  const o = Math.min(WC(e, t) / 2, WC(t, n) / 2, r), { x: i, y: s } = t;
  if (e.x === i && i === n.x || e.y === s && s === n.y)
    return `L${i} ${s}`;
  if (e.y === s) {
    const d = e.x < n.x ? -1 : 1, p = e.y < n.y ? 1 : -1;
    return `L ${i + o * d},${s}Q ${i},${s} ${i},${s + o * p}`;
  }
  const u = e.x < n.x ? 1 : -1, c = e.y < n.y ? -1 : 1;
  return `L ${i},${s + o * c}Q ${i},${s} ${i + o * u},${s}`;
}
function Fw({ sourceX: e, sourceY: t, sourcePosition: n = je.Bottom, targetX: r, targetY: o, targetPosition: i = je.Top, borderRadius: s = 5, centerX: u, centerY: c, offset: d = 20 }) {
  const [p, h, g, y, b] = WV({
    source: { x: e, y: t },
    sourcePosition: n,
    target: { x: r, y: o },
    targetPosition: i,
    center: { x: u, y: c },
    offset: d
  });
  return [p.reduce((v, x, _) => {
    let O = "";
    return _ > 0 && _ < p.length - 1 ? O = GV(p[_ - 1], x, p[_ + 1], s) : O = `${_ === 0 ? "M" : "L"}${x.x} ${x.y}`, v += O, v;
  }, ""), h, g, y, b];
}
function GC(e) {
  var t;
  return e && !!(e.internals.handleBounds || (t = e.handles) != null && t.length) && !!(e.measured.width || e.width || e.initialWidth);
}
function ZV(e) {
  var t;
  const { sourceNode: n, targetNode: r } = e;
  if (!GC(n) || !GC(r))
    return null;
  const o = n.internals.handleBounds || ZC(n.handles), i = r.internals.handleBounds || ZC(r.handles), s = KC(o?.source ?? [], e.sourceHandle), u = KC(
    // when connection type is loose we can define all handles as sources and connect source -> source
    e.connectionMode === Ou.Strict ? i?.target ?? [] : (i?.target ?? []).concat(i?.source ?? []),
    e.targetHandle
  );
  if (!s || !u)
    return (t = e.onError) == null || t.call(e, "008", fi.error008(s ? "target" : "source", {
      id: e.id,
      sourceHandle: e.sourceHandle,
      targetHandle: e.targetHandle
    })), null;
  const c = s?.position || je.Bottom, d = u?.position || je.Top, p = Pd(n, s, c), h = Pd(r, u, d);
  return {
    sourceX: p.x,
    sourceY: p.y,
    targetX: h.x,
    targetY: h.y,
    sourcePosition: c,
    targetPosition: d
  };
}
function ZC(e) {
  if (!e)
    return null;
  const t = [], n = [];
  for (const r of e)
    r.width = r.width ?? 1, r.height = r.height ?? 1, r.type === "source" ? t.push(r) : r.type === "target" && n.push(r);
  return {
    source: t,
    target: n
  };
}
function Pd(e, t, n = je.Left, r = !1) {
  const o = (t?.x ?? 0) + e.internals.positionAbsolute.x, i = (t?.y ?? 0) + e.internals.positionAbsolute.y, { width: s, height: u } = t ?? ra(e);
  if (r)
    return { x: o + s / 2, y: i + u / 2 };
  switch (t?.position ?? n) {
    case je.Top:
      return { x: o + s / 2, y: i };
    case je.Right:
      return { x: o + s, y: i + u / 2 };
    case je.Bottom:
      return { x: o + s / 2, y: i + u };
    case je.Left:
      return { x: o, y: i + u / 2 };
  }
}
function KC(e, t) {
  return e && (t ? e.find((n) => n.id === t) : e[0]) || null;
}
function Uw(e, t) {
  return e ? typeof e == "string" ? e : `${t ? `${t}__` : ""}${Object.keys(e).sort().map((n) => `${n}=${e[n]}`).join("&")}` : "";
}
function KV(e, { id: t, defaultColor: n, defaultMarkerStart: r, defaultMarkerEnd: o }) {
  const i = /* @__PURE__ */ new Set();
  return e.reduce((s, u) => ([u.markerStart || r, u.markerEnd || o].forEach((c) => {
    if (c && typeof c == "object") {
      const d = Uw(c, t);
      i.has(d) || (s.push({ id: d, color: c.color || n, ...c }), i.add(d));
    }
  }), s), []).sort((s, u) => s.id.localeCompare(u.id));
}
const jS = {
  nodeOrigin: [0, 0],
  nodeExtent: zd,
  elevateNodesOnSelect: !0,
  defaults: {}
}, QV = {
  ...jS,
  checkEquality: !0
};
function zS(e, t) {
  const n = { ...e };
  for (const r in t)
    t[r] !== void 0 && (n[r] = t[r]);
  return n;
}
function JV(e, t, n) {
  const r = zS(jS, n);
  for (const o of e.values())
    if (o.parentId)
      TS(o, e, t, r);
    else {
      const i = lf(o, r.nodeOrigin), s = Mu(o.extent) ? o.extent : r.nodeExtent, u = Zs(i, s, ra(o));
      o.internals.positionAbsolute = u;
    }
}
function Hw(e, t, n, r) {
  var o, i;
  const s = zS(QV, r);
  let u = !0;
  const c = new Map(t), d = s != null && s.elevateNodesOnSelect ? 1e3 : 0;
  t.clear(), n.clear();
  for (const p of e) {
    let h = c.get(p.id);
    if (s.checkEquality && p === h?.internals.userNode)
      t.set(p.id, h);
    else {
      const g = lf(p, s.nodeOrigin), y = Mu(p.extent) ? p.extent : s.nodeExtent, b = Zs(g, y, ra(p));
      h = {
        ...s.defaults,
        ...p,
        measured: {
          width: (o = p.measured) == null ? void 0 : o.width,
          height: (i = p.measured) == null ? void 0 : i.height
        },
        internals: {
          positionAbsolute: b,
          // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
          handleBounds: p.measured ? h?.internals.handleBounds : void 0,
          z: u1(p, d),
          userNode: p
        }
      }, t.set(p.id, h);
    }
    (!h.measured || !h.measured.width || !h.measured.height) && !h.hidden && (u = !1), p.parentId && TS(h, t, n, r);
  }
  return u;
}
function eB(e, t) {
  if (!e.parentId)
    return;
  const n = t.get(e.parentId);
  n ? n.set(e.id, e) : t.set(e.parentId, /* @__PURE__ */ new Map([[e.id, e]]));
}
function TS(e, t, n, r) {
  const { elevateNodesOnSelect: o, nodeOrigin: i, nodeExtent: s } = zS(jS, r), u = e.parentId, c = t.get(u);
  if (!c) {
    console.warn(`Parent node ${u} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
    return;
  }
  eB(e, n);
  const d = o ? 1e3 : 0, { x: p, y: h, z: g } = tB(e, c, i, s, d), { positionAbsolute: y } = e.internals, b = p !== y.x || h !== y.y;
  (b || g !== e.internals.z) && t.set(e.id, {
    ...e,
    internals: {
      ...e.internals,
      positionAbsolute: b ? { x: p, y: h } : y,
      z: g
    }
  });
}
function u1(e, t) {
  return (Mo(e.zIndex) ? e.zIndex : 0) + (e.selected ? t : 0);
}
function tB(e, t, n, r, o) {
  const { x: i, y: s } = t.internals.positionAbsolute, u = ra(e), c = lf(e, n), d = Mu(e.extent) ? Zs(c, e.extent, u) : c;
  let p = Zs({ x: i + d.x, y: s + d.y }, r, u);
  e.extent === "parent" && (p = QN(p, u, t));
  const h = u1(e, o), g = t.internals.z ?? 0;
  return {
    x: p.x,
    y: p.y,
    z: g > h ? g : h
  };
}
function DS(e, t, n, r = [0, 0]) {
  var o;
  const i = [], s = /* @__PURE__ */ new Map();
  for (const u of e) {
    const c = t.get(u.parentId);
    if (!c)
      continue;
    const d = ((o = s.get(u.parentId)) == null ? void 0 : o.expandedRect) ?? Nu(c), p = e1(d, u.rect);
    s.set(u.parentId, { expandedRect: p, parent: c });
  }
  return s.size > 0 && s.forEach(({ expandedRect: u, parent: c }, d) => {
    var p;
    const h = c.internals.positionAbsolute, g = ra(c), y = c.origin ?? r, b = u.x < h.x ? Math.round(Math.abs(h.x - u.x)) : 0, v = u.y < h.y ? Math.round(Math.abs(h.y - u.y)) : 0, x = Math.max(g.width, Math.round(u.width)), _ = Math.max(g.height, Math.round(u.height)), O = (x - g.width) * y[0], C = (_ - g.height) * y[1];
    (b > 0 || v > 0 || O || C) && (i.push({
      id: d,
      type: "position",
      position: {
        x: c.position.x - b + O,
        y: c.position.y - v + C
      }
    }), (p = n.get(d)) == null || p.forEach((N) => {
      e.some((R) => R.id === N.id) || i.push({
        id: N.id,
        type: "position",
        position: {
          x: N.position.x + b,
          y: N.position.y + v
        }
      });
    })), (g.width < u.width || g.height < u.height || b || v) && i.push({
      id: d,
      type: "dimensions",
      setAttributes: !0,
      dimensions: {
        width: x + (b ? y[0] * b - O : 0),
        height: _ + (v ? y[1] * v - C : 0)
      }
    });
  }), i;
}
function nB(e, t, n, r, o, i) {
  const s = r?.querySelector(".xyflow__viewport");
  let u = !1;
  if (!s)
    return { changes: [], updatedInternals: u };
  const c = [], d = window.getComputedStyle(s), { m22: p } = new window.DOMMatrixReadOnly(d.transform), h = [];
  for (const g of e.values()) {
    const y = t.get(g.id);
    if (!y)
      continue;
    if (y.hidden) {
      t.set(y.id, {
        ...y,
        internals: {
          ...y.internals,
          handleBounds: void 0
        }
      }), u = !0;
      continue;
    }
    const b = MS(g.nodeElement), v = y.measured.width !== b.width || y.measured.height !== b.height;
    if (b.width && b.height && (v || !y.internals.handleBounds || g.force)) {
      const x = g.nodeElement.getBoundingClientRect(), _ = Mu(y.extent) ? y.extent : i;
      let { positionAbsolute: O } = y.internals;
      y.parentId && y.extent === "parent" ? O = QN(O, b, t.get(y.parentId)) : _ && (O = Zs(O, _, b));
      const C = {
        ...y,
        measured: b,
        internals: {
          ...y.internals,
          positionAbsolute: O,
          handleBounds: {
            source: YC("source", g.nodeElement, x, p, y.id),
            target: YC("target", g.nodeElement, x, p, y.id)
          }
        }
      };
      t.set(y.id, C), y.parentId && TS(C, t, n, { nodeOrigin: o }), u = !0, v && (c.push({
        id: y.id,
        type: "dimensions",
        dimensions: b
      }), y.expandParent && y.parentId && h.push({
        id: y.id,
        parentId: y.parentId,
        rect: Nu(C, o)
      }));
    }
  }
  if (h.length > 0) {
    const g = DS(h, t, n, o);
    c.push(...g);
  }
  return { changes: c, updatedInternals: u };
}
async function rB({ delta: e, panZoom: t, transform: n, translateExtent: r, width: o, height: i }) {
  if (!t || !e.x && !e.y)
    return Promise.resolve(!1);
  const s = await t.setViewportConstrained({
    x: n[0] + e.x,
    y: n[1] + e.y,
    zoom: n[2]
  }, [
    [0, 0],
    [o, i]
  ], r), u = !!s && (s.x !== n[0] || s.y !== n[1] || s.k !== n[2]);
  return Promise.resolve(u);
}
function QC(e, t, n, r, o, i) {
  let s = o;
  const u = r.get(s) || /* @__PURE__ */ new Map();
  r.set(s, u.set(n, t)), s = `${o}-${e}`;
  const c = r.get(s) || /* @__PURE__ */ new Map();
  if (r.set(s, c.set(n, t)), i) {
    s = `${o}-${e}-${i}`;
    const d = r.get(s) || /* @__PURE__ */ new Map();
    r.set(s, d.set(n, t));
  }
}
function c1(e, t, n) {
  e.clear(), t.clear();
  for (const r of n) {
    const { source: o, target: i, sourceHandle: s = null, targetHandle: u = null } = r, c = { edgeId: r.id, source: o, target: i, sourceHandle: s, targetHandle: u }, d = `${o}-${s}--${i}-${u}`, p = `${i}-${u}--${o}-${s}`;
    QC("source", c, p, e, o, s), QC("target", c, d, e, i, u), t.set(r.id, r);
  }
}
function d1(e, t) {
  if (!e.parentId)
    return !1;
  const n = t.get(e.parentId);
  return n ? n.selected ? !0 : d1(n, t) : !1;
}
function JC(e, t, n) {
  var r;
  let o = e;
  do {
    if ((r = o?.matches) != null && r.call(o, t))
      return !0;
    if (o === n)
      return !1;
    o = o?.parentElement;
  } while (o);
  return !1;
}
function oB(e, t, n, r) {
  const o = /* @__PURE__ */ new Map();
  for (const [i, s] of e)
    if ((s.selected || s.id === r) && (!s.parentId || !d1(s, e)) && (s.draggable || t && typeof s.draggable > "u")) {
      const u = e.get(i);
      u && o.set(i, {
        id: i,
        position: u.position || { x: 0, y: 0 },
        distance: {
          x: n.x - u.internals.positionAbsolute.x,
          y: n.y - u.internals.positionAbsolute.y
        },
        extent: u.extent,
        parentId: u.parentId,
        origin: u.origin,
        expandParent: u.expandParent,
        internals: {
          positionAbsolute: u.internals.positionAbsolute || { x: 0, y: 0 }
        },
        measured: {
          width: u.measured.width ?? 0,
          height: u.measured.height ?? 0
        }
      });
    }
  return o;
}
function ib({ nodeId: e, dragItems: t, nodeLookup: n, dragging: r = !0 }) {
  var o, i, s;
  const u = [];
  for (const [d, p] of t) {
    const h = (o = n.get(d)) == null ? void 0 : o.internals.userNode;
    h && u.push({
      ...h,
      position: p.position,
      dragging: r
    });
  }
  if (!e)
    return [u[0], u];
  const c = (i = n.get(e)) == null ? void 0 : i.internals.userNode;
  return [
    c ? {
      ...c,
      position: ((s = t.get(e)) == null ? void 0 : s.position) || c.position,
      dragging: r
    } : u[0],
    u
  ];
}
function iB({ onNodeMouseDown: e, getStoreItems: t, onDragStart: n, onDrag: r, onDragStop: o }) {
  let i = { x: null, y: null }, s = 0, u = /* @__PURE__ */ new Map(), c = !1, d = { x: 0, y: 0 }, p = null, h = !1, g = null, y = !1;
  function b({ noDragClassName: x, handleSelector: _, domNode: O, isSelectable: C, nodeId: N, nodeClickDistance: R = 0 }) {
    g = Pr(O);
    function z({ x: A, y: V }, U) {
      const { nodeLookup: W, nodeExtent: D, snapGrid: F, snapToGrid: P, nodeOrigin: H, onNodeDrag: Y, onSelectionDrag: q, onError: M, updateNodePositions: X } = t();
      i = { x: A, y: V };
      let K = !1, L = { x: 0, y: 0, x2: 0, y2: 0 };
      if (u.size > 1 && D) {
        const ee = uf(u);
        L = Bw(ee);
      }
      for (const [ee, ae] of u) {
        if (!W.has(ee))
          continue;
        let le = { x: A - ae.distance.x, y: V - ae.distance.y };
        P && (le = Hm(le, F));
        let me = [
          [D[0][0], D[0][1]],
          [D[1][0], D[1][1]]
        ];
        if (u.size > 1 && D && !ae.extent) {
          const { positionAbsolute: _e } = ae.internals, Se = _e.x - L.x + D[0][0], Ee = _e.x + ae.measured.width - L.x2 + D[1][0], Ie = _e.y - L.y + D[0][1], $e = _e.y + ae.measured.height - L.y2 + D[1][1];
          me = [
            [Se, Ie],
            [Ee, $e]
          ];
        }
        const { position: se, positionAbsolute: he } = KN({
          nodeId: ee,
          nextPosition: le,
          nodeLookup: W,
          nodeExtent: me,
          nodeOrigin: H,
          onError: M
        });
        K = K || ae.position.x !== se.x || ae.position.y !== se.y, ae.position = se, ae.internals.positionAbsolute = he;
      }
      if (K && (X(u, !0), U && (r || Y || !N && q))) {
        const [ee, ae] = ib({
          nodeId: N,
          dragItems: u,
          nodeLookup: W
        });
        r?.(U, u, ee, ae), Y?.(U, ee, ae), N || q == null || q(U, ae);
      }
    }
    async function j() {
      if (!p)
        return;
      const { transform: A, panBy: V, autoPanSpeed: U, autoPanOnNodeDrag: W } = t();
      if (!W) {
        c = !1, cancelAnimationFrame(s);
        return;
      }
      const [D, F] = JN(d, p, U);
      (D !== 0 || F !== 0) && (i.x = (i.x ?? 0) - D / A[2], i.y = (i.y ?? 0) - F / A[2], await V({ x: D, y: F }) && z(i, null)), s = requestAnimationFrame(j);
    }
    function I(A) {
      var V;
      const { nodeLookup: U, multiSelectionActive: W, nodesDraggable: D, transform: F, snapGrid: P, snapToGrid: H, selectNodesOnDrag: Y, onNodeDragStart: q, onSelectionDragStart: M, unselectNodesAndEdges: X } = t();
      h = !0, (!Y || !C) && !W && N && ((V = U.get(N)) != null && V.selected || X()), C && Y && N && e?.(N);
      const K = md(A.sourceEvent, { transform: F, snapGrid: P, snapToGrid: H, containerBounds: p });
      if (i = K, u = oB(U, D, K, N), u.size > 0 && (n || q || !N && M)) {
        const [L, ee] = ib({
          nodeId: N,
          dragItems: u,
          nodeLookup: U
        });
        n?.(A.sourceEvent, u, L, ee), q?.(A.sourceEvent, L, ee), N || M == null || M(A.sourceEvent, ee);
      }
    }
    const $ = NN().clickDistance(R).on("start", (A) => {
      const { domNode: V, nodeDragThreshold: U, transform: W, snapGrid: D, snapToGrid: F } = t();
      p = V?.getBoundingClientRect() || null, y = !1, U === 0 && I(A), i = md(A.sourceEvent, { transform: W, snapGrid: D, snapToGrid: F, containerBounds: p }), d = Yi(A.sourceEvent, p);
    }).on("drag", (A) => {
      const { autoPanOnNodeDrag: V, transform: U, snapGrid: W, snapToGrid: D, nodeDragThreshold: F, nodeLookup: P } = t(), H = md(A.sourceEvent, { transform: U, snapGrid: W, snapToGrid: D, containerBounds: p });
      if ((A.sourceEvent.type === "touchmove" && A.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors
      N && !P.has(N)) && (y = !0), !y) {
        if (!c && V && h && (c = !0, j()), !h) {
          const Y = H.xSnapped - (i.x ?? 0), q = H.ySnapped - (i.y ?? 0);
          Math.sqrt(Y * Y + q * q) > F && I(A);
        }
        (i.x !== H.xSnapped || i.y !== H.ySnapped) && u && h && (d = Yi(A.sourceEvent, p), z(H, A.sourceEvent));
      }
    }).on("end", (A) => {
      if (!(!h || y) && (c = !1, h = !1, cancelAnimationFrame(s), u.size > 0)) {
        const { nodeLookup: V, updateNodePositions: U, onNodeDragStop: W, onSelectionDragStop: D } = t();
        if (U(u, !1), o || W || !N && D) {
          const [F, P] = ib({
            nodeId: N,
            dragItems: u,
            nodeLookup: V,
            dragging: !1
          });
          o?.(A.sourceEvent, u, F, P), W?.(A.sourceEvent, F, P), N || D == null || D(A.sourceEvent, P);
        }
      }
    }).filter((A) => {
      const V = A.target;
      return !A.button && (!x || !JC(V, `.${x}`, O)) && (!_ || JC(V, _, O));
    });
    g.call($);
  }
  function v() {
    g?.on(".drag", null);
  }
  return {
    update: b,
    destroy: v
  };
}
function aB(e, t, n) {
  const r = [], o = {
    x: e.x - n,
    y: e.y - n,
    width: n * 2,
    height: n * 2
  };
  for (const i of t.values())
    Dd(o, Nu(i)) > 0 && r.push(i);
  return r;
}
const sB = 250;
function lB(e, t, n, r) {
  var o, i;
  let s = [], u = 1 / 0;
  const c = aB(e, n, t + sB);
  for (const d of c) {
    const p = [...((o = d.internals.handleBounds) == null ? void 0 : o.source) ?? [], ...((i = d.internals.handleBounds) == null ? void 0 : i.target) ?? []];
    for (const h of p) {
      if (r.nodeId === h.nodeId && r.type === h.type && r.id === h.id)
        continue;
      const { x: g, y } = Pd(d, h, h.position, !0), b = Math.sqrt(Math.pow(g - e.x, 2) + Math.pow(y - e.y, 2));
      b > t || (b < u ? (s = [{ ...h, x: g, y }], u = b) : b === u && s.push({ ...h, x: g, y }));
    }
  }
  if (!s.length)
    return null;
  if (s.length > 1) {
    const d = r.type === "source" ? "target" : "source";
    return s.find((p) => p.type === d) ?? s[0];
  }
  return s[0];
}
function f1(e, t, n, r, o, i = !1) {
  var s, u, c;
  const d = r.get(e);
  if (!d)
    return null;
  const p = o === "strict" ? (s = d.internals.handleBounds) == null ? void 0 : s[t] : [...((u = d.internals.handleBounds) == null ? void 0 : u.source) ?? [], ...((c = d.internals.handleBounds) == null ? void 0 : c.target) ?? []], h = (n ? p?.find((g) => g.id === n) : p?.[0]) ?? null;
  return h && i ? { ...h, ...Pd(d, h, h.position, !0) } : h;
}
function p1(e, t) {
  return e || (t != null && t.classList.contains("target") ? "target" : t != null && t.classList.contains("source") ? "source" : null);
}
function uB(e, t) {
  let n = null;
  return t ? n = !0 : e && !t && (n = !1), n;
}
const h1 = () => !0;
function cB(e, { connectionMode: t, connectionRadius: n, handleId: r, nodeId: o, edgeUpdaterType: i, isTarget: s, domNode: u, nodeLookup: c, lib: d, autoPanOnConnect: p, flowId: h, panBy: g, cancelConnection: y, onConnectStart: b, onConnect: v, onConnectEnd: x, isValidConnection: _ = h1, onReconnectEnd: O, updateConnection: C, getTransform: N, getFromHandle: R, autoPanSpeed: z }) {
  const j = r1(e.target);
  let I = 0, $;
  const { x: A, y: V } = Yi(e), U = j?.elementFromPoint(A, V), W = p1(i, U), D = u?.getBoundingClientRect();
  if (!D || !W)
    return;
  const F = f1(o, W, r, c, t);
  if (!F)
    return;
  let P = Yi(e, D), H = !1, Y = null, q = !1, M = null;
  function X() {
    if (!p || !D)
      return;
    const [se, he] = JN(P, D, z);
    g({ x: se, y: he }), I = requestAnimationFrame(X);
  }
  const K = {
    ...F,
    nodeId: o,
    type: W,
    position: F.position
  }, L = c.get(o), ee = {
    inProgress: !0,
    isValid: null,
    from: Pd(L, K, je.Left, !0),
    fromHandle: K,
    fromPosition: K.position,
    fromNode: L,
    to: P,
    toHandle: null,
    toPosition: FC[K.position],
    toNode: null
  };
  C(ee);
  let ae = ee;
  b?.(e, { nodeId: o, handleId: r, handleType: W });
  function le(se) {
    if (!R() || !K) {
      me(se);
      return;
    }
    const he = N();
    P = Yi(se, D), $ = lB(cf(P, he, !1, [1, 1]), n, c, K), H || (X(), H = !0);
    const _e = m1(se, {
      handle: $,
      connectionMode: t,
      fromNodeId: o,
      fromHandleId: r,
      fromType: s ? "target" : "source",
      isValidConnection: _,
      doc: j,
      lib: d,
      flowId: h,
      nodeLookup: c
    });
    M = _e.handleDomNode, Y = _e.connection, q = uB(!!$, _e.isValid);
    const Se = {
      // from stays the same
      ...ae,
      isValid: q,
      to: $ && q ? Qh({ x: $.x, y: $.y }, he) : P,
      toHandle: _e.toHandle,
      toPosition: q && _e.toHandle ? _e.toHandle.position : FC[K.position],
      toNode: _e.toHandle ? c.get(_e.toHandle.nodeId) : null
    };
    q && $ && ae.toHandle && Se.toHandle && ae.toHandle.type === Se.toHandle.type && ae.toHandle.nodeId === Se.toHandle.nodeId && ae.toHandle.id === Se.toHandle.id && ae.to.x === Se.to.x && ae.to.y === Se.to.y || (C(Se), ae = Se);
  }
  function me(se) {
    ($ || M) && Y && q && v?.(Y);
    const { inProgress: he, ..._e } = ae, Se = {
      ..._e,
      toPosition: ae.toHandle ? ae.toPosition : null
    };
    x?.(se, Se), i && O?.(se, Se), y(), cancelAnimationFrame(I), H = !1, q = !1, Y = null, M = null, j.removeEventListener("mousemove", le), j.removeEventListener("mouseup", me), j.removeEventListener("touchmove", le), j.removeEventListener("touchend", me);
  }
  j.addEventListener("mousemove", le), j.addEventListener("mouseup", me), j.addEventListener("touchmove", le), j.addEventListener("touchend", me);
}
function m1(e, { handle: t, connectionMode: n, fromNodeId: r, fromHandleId: o, fromType: i, doc: s, lib: u, flowId: c, isValidConnection: d = h1, nodeLookup: p }) {
  const h = i === "target", g = t ? s.querySelector(`.${u}-flow__handle[data-id="${c}-${t?.nodeId}-${t?.id}-${t?.type}"]`) : null, { x: y, y: b } = Yi(e), v = s.elementFromPoint(y, b), x = v != null && v.classList.contains(`${u}-flow__handle`) ? v : g, _ = {
    handleDomNode: x,
    isValid: !1,
    connection: null,
    toHandle: null
  };
  if (x) {
    const O = p1(void 0, x), C = x.getAttribute("data-nodeid"), N = x.getAttribute("data-handleid"), R = x.classList.contains("connectable"), z = x.classList.contains("connectableend");
    if (!C || !O)
      return _;
    const j = {
      source: h ? C : r,
      sourceHandle: h ? N : o,
      target: h ? r : C,
      targetHandle: h ? o : N
    };
    _.connection = j;
    const I = R && z && (n === Ou.Strict ? h && O === "source" || !h && O === "target" : C !== r || N !== o);
    _.isValid = I && d(j), _.toHandle = f1(C, O, N, p, n, !1);
  }
  return _;
}
const $w = {
  onPointerDown: cB,
  isValid: m1
};
function dB({ domNode: e, panZoom: t, getTransform: n, getViewScale: r }) {
  const o = Pr(e);
  function i({ translateExtent: u, width: c, height: d, zoomStep: p = 10, pannable: h = !0, zoomable: g = !0, inversePan: y = !1 }) {
    const b = (C) => {
      const N = n();
      if (C.sourceEvent.type !== "wheel" || !t)
        return;
      const R = -C.sourceEvent.deltaY * (C.sourceEvent.deltaMode === 1 ? 0.05 : C.sourceEvent.deltaMode ? 1 : 2e-3) * p, z = N[2] * Math.pow(2, R);
      t.scaleTo(z);
    };
    let v = [0, 0];
    const x = (C) => {
      (C.sourceEvent.type === "mousedown" || C.sourceEvent.type === "touchstart") && (v = [
        C.sourceEvent.clientX ?? C.sourceEvent.touches[0].clientX,
        C.sourceEvent.clientY ?? C.sourceEvent.touches[0].clientY
      ]);
    }, _ = (C) => {
      const N = n();
      if (C.sourceEvent.type !== "mousemove" && C.sourceEvent.type !== "touchmove" || !t)
        return;
      const R = [
        C.sourceEvent.clientX ?? C.sourceEvent.touches[0].clientX,
        C.sourceEvent.clientY ?? C.sourceEvent.touches[0].clientY
      ], z = [R[0] - v[0], R[1] - v[1]];
      v = R;
      const j = r() * Math.max(N[2], Math.log(N[2])) * (y ? -1 : 1), I = {
        x: N[0] - z[0] * j,
        y: N[1] - z[1] * j
      }, $ = [
        [0, 0],
        [c, d]
      ];
      t.setViewportConstrained({
        x: I.x,
        y: I.y,
        zoom: N[2]
      }, $, u);
    }, O = YN().on("start", x).on("zoom", h ? _ : null).on("zoom.wheel", g ? b : null);
    o.call(O, {});
  }
  function s() {
    o.on("zoom", null);
  }
  return {
    update: i,
    destroy: s,
    pointer: Co
  };
}
const fB = (e, t) => e.x !== t.x || e.y !== t.y || e.zoom !== t.k, $m = (e) => ({
  x: e.x,
  y: e.y,
  zoom: e.k
}), ab = ({ x: e, y: t, zoom: n }) => Bm.translate(e, t).scale(n), lu = (e, t) => e.target.closest(`.${t}`), g1 = (e, t) => t === 2 && Array.isArray(e) && e.includes(2), sb = (e, t = 0, n = () => {
}) => {
  const r = typeof t == "number" && t > 0;
  return r || n(), r ? e.transition().duration(t).on("end", n) : e;
}, y1 = (e) => {
  const t = e.ctrlKey && Jh() ? 10 : 1;
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * t;
};
function pB({ zoomPanValues: e, noWheelClassName: t, d3Selection: n, d3Zoom: r, panOnScrollMode: o, panOnScrollSpeed: i, zoomOnPinch: s, onPanZoomStart: u, onPanZoom: c, onPanZoomEnd: d }) {
  return (p) => {
    if (lu(p, t))
      return !1;
    p.preventDefault(), p.stopImmediatePropagation();
    const h = n.property("__zoom").k || 1;
    if (p.ctrlKey && s) {
      const x = Co(p), _ = y1(p), O = h * Math.pow(2, _);
      r.scaleTo(n, O, x, p);
      return;
    }
    const g = p.deltaMode === 1 ? 20 : 1;
    let y = o === Xs.Vertical ? 0 : p.deltaX * g, b = o === Xs.Horizontal ? 0 : p.deltaY * g;
    !Jh() && p.shiftKey && o !== Xs.Vertical && (y = p.deltaY * g, b = 0), r.translateBy(
      n,
      -(y / h) * i,
      -(b / h) * i,
      // @ts-ignore
      { internal: !0 }
    );
    const v = $m(n.property("__zoom"));
    clearTimeout(e.panScrollTimeout), e.isPanScrolling || (e.isPanScrolling = !0, u?.(p, v)), e.isPanScrolling && (c?.(p, v), e.panScrollTimeout = setTimeout(() => {
      d?.(p, v), e.isPanScrolling = !1;
    }, 150));
  };
}
function hB({ noWheelClassName: e, preventScrolling: t, d3ZoomHandler: n }) {
  return function(r, o) {
    const i = r.type === "wheel", s = !t && i && !r.ctrlKey, u = lu(r, e);
    if (r.ctrlKey && i && u && r.preventDefault(), s || u)
      return null;
    r.preventDefault(), n.call(this, r, o);
  };
}
function mB({ zoomPanValues: e, onDraggingChange: t, onPanZoomStart: n }) {
  return (r) => {
    var o, i, s;
    if ((o = r.sourceEvent) != null && o.internal)
      return;
    const u = $m(r.transform);
    e.mouseButton = ((i = r.sourceEvent) == null ? void 0 : i.button) || 0, e.isZoomingOrPanning = !0, e.prevViewport = u, ((s = r.sourceEvent) == null ? void 0 : s.type) === "mousedown" && t(!0), n && n?.(r.sourceEvent, u);
  };
}
function gB({ zoomPanValues: e, panOnDrag: t, onPaneContextMenu: n, onTransformChange: r, onPanZoom: o }) {
  return (i) => {
    var s, u;
    e.usedRightMouseButton = !!(n && g1(t, e.mouseButton ?? 0)), (s = i.sourceEvent) != null && s.sync || r([i.transform.x, i.transform.y, i.transform.k]), o && !((u = i.sourceEvent) != null && u.internal) && o?.(i.sourceEvent, $m(i.transform));
  };
}
function yB({ zoomPanValues: e, panOnDrag: t, panOnScroll: n, onDraggingChange: r, onPanZoomEnd: o, onPaneContextMenu: i }) {
  return (s) => {
    var u;
    if (!((u = s.sourceEvent) != null && u.internal) && (e.isZoomingOrPanning = !1, i && g1(t, e.mouseButton ?? 0) && !e.usedRightMouseButton && s.sourceEvent && i(s.sourceEvent), e.usedRightMouseButton = !1, r(!1), o && fB(e.prevViewport, s.transform))) {
      const c = $m(s.transform);
      e.prevViewport = c, clearTimeout(e.timerId), e.timerId = setTimeout(
        () => {
          o?.(s.sourceEvent, c);
        },
        // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
        n ? 150 : 0
      );
    }
  };
}
function vB({ zoomActivationKeyPressed: e, zoomOnScroll: t, zoomOnPinch: n, panOnDrag: r, panOnScroll: o, zoomOnDoubleClick: i, userSelectionActive: s, noWheelClassName: u, noPanClassName: c, lib: d }) {
  return (p) => {
    var h;
    const g = e || t, y = n && p.ctrlKey;
    if (p.button === 1 && p.type === "mousedown" && (lu(p, `${d}-flow__node`) || lu(p, `${d}-flow__edge`)))
      return !0;
    if (!r && !g && !o && !i && !n || s || lu(p, u) && p.type === "wheel" || lu(p, c) && (p.type !== "wheel" || o && p.type === "wheel" && !e) || !n && p.ctrlKey && p.type === "wheel")
      return !1;
    if (!n && p.type === "touchstart" && ((h = p.touches) == null ? void 0 : h.length) > 1)
      return p.preventDefault(), !1;
    if (!g && !o && !y && p.type === "wheel" || !r && (p.type === "mousedown" || p.type === "touchstart") || Array.isArray(r) && !r.includes(p.button) && p.type === "mousedown")
      return !1;
    const b = Array.isArray(r) && r.includes(p.button) || !p.button || p.button <= 1;
    return (!p.ctrlKey || p.type === "wheel") && b;
  };
}
function bB({ domNode: e, minZoom: t, maxZoom: n, paneClickDistance: r, translateExtent: o, viewport: i, onPanZoom: s, onPanZoomStart: u, onPanZoomEnd: c, onDraggingChange: d }) {
  const p = {
    isZoomingOrPanning: !1,
    usedRightMouseButton: !1,
    prevViewport: { x: 0, y: 0, zoom: 0 },
    mouseButton: 0,
    timerId: void 0,
    panScrollTimeout: void 0,
    isPanScrolling: !1
  }, h = e.getBoundingClientRect(), g = YN().clickDistance(!Mo(r) || r < 0 ? 0 : r).scaleExtent([t, n]).translateExtent(o), y = Pr(e).call(g);
  C({
    x: i.x,
    y: i.y,
    zoom: Au(i.zoom, t, n)
  }, [
    [0, 0],
    [h.width, h.height]
  ], o);
  const b = y.on("wheel.zoom"), v = y.on("dblclick.zoom");
  g.wheelDelta(y1);
  function x(U, W) {
    return y ? new Promise((D) => {
      g?.transform(sb(y, W?.duration, () => D(!0)), U);
    }) : Promise.resolve(!1);
  }
  function _({ noWheelClassName: U, noPanClassName: W, onPaneContextMenu: D, userSelectionActive: F, panOnScroll: P, panOnDrag: H, panOnScrollMode: Y, panOnScrollSpeed: q, preventScrolling: M, zoomOnPinch: X, zoomOnScroll: K, zoomOnDoubleClick: L, zoomActivationKeyPressed: ee, lib: ae, onTransformChange: le }) {
    F && !p.isZoomingOrPanning && O();
    const me = P && !ee && !F ? pB({
      zoomPanValues: p,
      noWheelClassName: U,
      d3Selection: y,
      d3Zoom: g,
      panOnScrollMode: Y,
      panOnScrollSpeed: q,
      zoomOnPinch: X,
      onPanZoomStart: u,
      onPanZoom: s,
      onPanZoomEnd: c
    }) : hB({
      noWheelClassName: U,
      preventScrolling: M,
      d3ZoomHandler: b
    });
    if (y.on("wheel.zoom", me, { passive: !1 }), !F) {
      const he = mB({
        zoomPanValues: p,
        onDraggingChange: d,
        onPanZoomStart: u
      });
      g.on("start", he);
      const _e = gB({
        zoomPanValues: p,
        panOnDrag: H,
        onPaneContextMenu: !!D,
        onPanZoom: s,
        onTransformChange: le
      });
      g.on("zoom", _e);
      const Se = yB({
        zoomPanValues: p,
        panOnDrag: H,
        panOnScroll: P,
        onPaneContextMenu: D,
        onPanZoomEnd: c,
        onDraggingChange: d
      });
      g.on("end", Se);
    }
    const se = vB({
      zoomActivationKeyPressed: ee,
      panOnDrag: H,
      zoomOnScroll: K,
      panOnScroll: P,
      zoomOnDoubleClick: L,
      zoomOnPinch: X,
      userSelectionActive: F,
      noPanClassName: W,
      noWheelClassName: U,
      lib: ae
    });
    g.filter(se), L ? y.on("dblclick.zoom", v) : y.on("dblclick.zoom", null);
  }
  function O() {
    g.on("zoom", null);
  }
  async function C(U, W, D) {
    const F = ab(U), P = g?.constrain()(F, W, D);
    return P && await x(P), new Promise((H) => H(P));
  }
  async function N(U, W) {
    const D = ab(U);
    return await x(D, W), new Promise((F) => F(D));
  }
  function R(U) {
    if (y) {
      const W = ab(U), D = y.property("__zoom");
      (D.k !== U.zoom || D.x !== U.x || D.y !== U.y) && g?.transform(y, W, null, { sync: !0 });
    }
  }
  function z() {
    const U = y ? $N(y.node()) : { x: 0, y: 0, k: 1 };
    return { x: U.x, y: U.y, zoom: U.k };
  }
  function j(U, W) {
    return y ? new Promise((D) => {
      g?.scaleTo(sb(y, W?.duration, () => D(!0)), U);
    }) : Promise.resolve(!1);
  }
  function I(U, W) {
    return y ? new Promise((D) => {
      g?.scaleBy(sb(y, W?.duration, () => D(!0)), U);
    }) : Promise.resolve(!1);
  }
  function $(U) {
    g?.scaleExtent(U);
  }
  function A(U) {
    g?.translateExtent(U);
  }
  function V(U) {
    const W = !Mo(U) || U < 0 ? 0 : U;
    g?.clickDistance(W);
  }
  return {
    update: _,
    destroy: O,
    setViewport: N,
    setViewportConstrained: C,
    getViewport: z,
    scaleTo: j,
    scaleBy: I,
    setScaleExtent: $,
    setTranslateExtent: A,
    syncViewport: R,
    setClickDistance: V
  };
}
var gd;
(function(e) {
  e.Line = "line", e.Handle = "handle";
})(gd || (gd = {}));
function wB({ width: e, prevWidth: t, height: n, prevHeight: r, affectsX: o, affectsY: i }) {
  const s = e - t, u = n - r, c = [s > 0 ? 1 : s < 0 ? -1 : 0, u > 0 ? 1 : u < 0 ? -1 : 0];
  return s && o && (c[0] = c[0] * -1), u && i && (c[1] = c[1] * -1), c;
}
function xB(e) {
  const t = e.includes("right") || e.includes("left"), n = e.includes("bottom") || e.includes("top"), r = e.includes("left"), o = e.includes("top");
  return {
    isHorizontal: t,
    isVertical: n,
    affectsX: r,
    affectsY: o
  };
}
function Ia(e, t) {
  return Math.max(0, t - e);
}
function Va(e, t) {
  return Math.max(0, e - t);
}
function Yp(e, t, n) {
  return Math.max(0, t - e, e - n);
}
function eO(e, t) {
  return e ? !t : t;
}
function SB(e, t, n, r, o, i, s, u) {
  let { affectsX: c, affectsY: d } = t;
  const { isHorizontal: p, isVertical: h } = t, g = p && h, { xSnapped: y, ySnapped: b } = n, { minWidth: v, maxWidth: x, minHeight: _, maxHeight: O } = r, { x: C, y: N, width: R, height: z, aspectRatio: j } = e;
  let I = Math.floor(p ? y - e.pointerX : 0), $ = Math.floor(h ? b - e.pointerY : 0);
  const A = R + (c ? -I : I), V = z + (d ? -$ : $), U = -i[0] * R, W = -i[1] * z;
  let D = Yp(A, v, x), F = Yp(V, _, O);
  if (s) {
    let Y = 0, q = 0;
    c && I < 0 ? Y = Ia(C + I + U, s[0][0]) : !c && I > 0 && (Y = Va(C + A + U, s[1][0])), d && $ < 0 ? q = Ia(N + $ + W, s[0][1]) : !d && $ > 0 && (q = Va(N + V + W, s[1][1])), D = Math.max(D, Y), F = Math.max(F, q);
  }
  if (u) {
    let Y = 0, q = 0;
    c && I > 0 ? Y = Va(C + I, u[0][0]) : !c && I < 0 && (Y = Ia(C + A, u[1][0])), d && $ > 0 ? q = Va(N + $, u[0][1]) : !d && $ < 0 && (q = Ia(N + V, u[1][1])), D = Math.max(D, Y), F = Math.max(F, q);
  }
  if (o) {
    if (p) {
      const Y = Yp(A / j, _, O) * j;
      if (D = Math.max(D, Y), s) {
        let q = 0;
        !c && !d || c && !d && g ? q = Va(N + W + A / j, s[1][1]) * j : q = Ia(N + W + (c ? I : -I) / j, s[0][1]) * j, D = Math.max(D, q);
      }
      if (u) {
        let q = 0;
        !c && !d || c && !d && g ? q = Ia(N + A / j, u[1][1]) * j : q = Va(N + (c ? I : -I) / j, u[0][1]) * j, D = Math.max(D, q);
      }
    }
    if (h) {
      const Y = Yp(V * j, v, x) / j;
      if (F = Math.max(F, Y), s) {
        let q = 0;
        !c && !d || d && !c && g ? q = Va(C + V * j + U, s[1][0]) / j : q = Ia(C + (d ? $ : -$) * j + U, s[0][0]) / j, F = Math.max(F, q);
      }
      if (u) {
        let q = 0;
        !c && !d || d && !c && g ? q = Ia(C + V * j, u[1][0]) / j : q = Va(C + (d ? $ : -$) * j, u[0][0]) / j, F = Math.max(F, q);
      }
    }
  }
  $ = $ + ($ < 0 ? F : -F), I = I + (I < 0 ? D : -D), o && (g ? A > V * j ? $ = (eO(c, d) ? -I : I) / j : I = (eO(c, d) ? -$ : $) * j : p ? ($ = I / j, d = c) : (I = $ * j, c = d));
  const P = c ? C + I : C, H = d ? N + $ : N;
  return {
    width: R + (c ? -I : I),
    height: z + (d ? -$ : $),
    x: i[0] * I * (c ? -1 : 1) + P,
    y: i[1] * $ * (d ? -1 : 1) + H
  };
}
const v1 = { width: 0, height: 0, x: 0, y: 0 }, _B = {
  ...v1,
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
};
function kB(e) {
  return [
    [0, 0],
    [e.measured.width, e.measured.height]
  ];
}
function EB(e, t, n) {
  const r = t.position.x + e.position.x, o = t.position.y + e.position.y, i = e.measured.width ?? 0, s = e.measured.height ?? 0, u = n[0] * i, c = n[1] * s;
  return [
    [r - u, o - c],
    [r + i - u, o + s - c]
  ];
}
function CB({ domNode: e, nodeId: t, getStoreItems: n, onChange: r, onEnd: o }) {
  const i = Pr(e);
  function s({ controlPosition: c, boundaries: d, keepAspectRatio: p, onResizeStart: h, onResize: g, onResizeEnd: y, shouldResize: b }) {
    let v = { ...v1 }, x = { ..._B };
    const _ = xB(c);
    let O, C = null, N = [], R, z, j;
    const I = NN().on("start", ($) => {
      const { nodeLookup: A, transform: V, snapGrid: U, snapToGrid: W, nodeOrigin: D, paneDomNode: F } = n();
      if (O = A.get(t), !O)
        return;
      C = F?.getBoundingClientRect() ?? null;
      const { xSnapped: P, ySnapped: H } = md($.sourceEvent, {
        transform: V,
        snapGrid: U,
        snapToGrid: W,
        containerBounds: C
      });
      v = {
        width: O.measured.width ?? 0,
        height: O.measured.height ?? 0,
        x: O.position.x ?? 0,
        y: O.position.y ?? 0
      }, x = {
        ...v,
        pointerX: P,
        pointerY: H,
        aspectRatio: v.width / v.height
      }, R = void 0, O.parentId && (O.extent === "parent" || O.expandParent) && (R = A.get(O.parentId), z = R && O.extent === "parent" ? kB(R) : void 0), N = [], j = void 0;
      for (const [Y, q] of A)
        if (q.parentId === t && (N.push({
          id: Y,
          position: { ...q.position },
          extent: q.extent
        }), q.extent === "parent" || q.expandParent)) {
          const M = EB(q, O, q.origin ?? D);
          j ? j = [
            [Math.min(M[0][0], j[0][0]), Math.min(M[0][1], j[0][1])],
            [Math.max(M[1][0], j[1][0]), Math.max(M[1][1], j[1][1])]
          ] : j = M;
        }
      h?.($, { ...v });
    }).on("drag", ($) => {
      const { transform: A, snapGrid: V, snapToGrid: U, nodeOrigin: W } = n(), D = md($.sourceEvent, {
        transform: A,
        snapGrid: V,
        snapToGrid: U,
        containerBounds: C
      }), F = [];
      if (!O)
        return;
      const { x: P, y: H, width: Y, height: q } = v, M = {}, X = O.origin ?? W, { width: K, height: L, x: ee, y: ae } = SB(x, _, D, d, p, X, z, j), le = K !== Y, me = L !== q, se = ee !== P && le, he = ae !== H && me;
      if (!se && !he && !le && !me)
        return;
      if ((se || he || X[0] === 1 || X[1] === 1) && (M.x = se ? ee : v.x, M.y = he ? ae : v.y, v.x = M.x, v.y = M.y, N.length > 0)) {
        const Ee = ee - P, Ie = ae - H;
        for (const $e of N)
          $e.position = {
            x: $e.position.x - Ee + X[0] * (K - Y),
            y: $e.position.y - Ie + X[1] * (L - q)
          }, F.push($e);
      }
      if ((le || me) && (M.width = le ? K : v.width, M.height = me ? L : v.height, v.width = M.width, v.height = M.height), R && O.expandParent) {
        const Ee = X[0] * (M.width ?? 0);
        M.x && M.x < Ee && (v.x = Ee, x.x = x.x - (M.x - Ee));
        const Ie = X[1] * (M.height ?? 0);
        M.y && M.y < Ie && (v.y = Ie, x.y = x.y - (M.y - Ie));
      }
      const _e = wB({
        width: v.width,
        prevWidth: Y,
        height: v.height,
        prevHeight: q,
        affectsX: _.affectsX,
        affectsY: _.affectsY
      }), Se = { ...v, direction: _e };
      b?.($, Se) !== !1 && (g?.($, Se), r(M, F));
    }).on("end", ($) => {
      y?.($, { ...v }), o?.({ ...v });
    });
    i.call(I);
  }
  function u() {
    i.on(".drag", null);
  }
  return {
    update: s,
    destroy: u
  };
}
const { useDebugValue: OB } = Qe, { useSyncExternalStoreWithSelector: AB } = dN, NB = (e) => e;
function b1(e, t = NB, n) {
  const r = AB(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return OB(r), r;
}
const tO = (e, t) => {
  const n = cN(e), r = (o, i = t) => b1(n, o, i);
  return Object.assign(r, n), r;
}, MB = (e, t) => e ? tO(e, t) : tO;
function Ft(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1;
    for (const [r, o] of e)
      if (!Object.is(o, t.get(r)))
        return !1;
    return !0;
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1;
    for (const r of e)
      if (!t.has(r))
        return !1;
    return !0;
  }
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !1;
  for (const r of n)
    if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
      return !1;
  return !0;
}
const Ym = S.createContext(null), RB = Ym.Provider, w1 = fi.error001();
function at(e, t) {
  const n = S.useContext(Ym);
  if (n === null)
    throw new Error(w1);
  return b1(n, e, t);
}
function Ht() {
  const e = S.useContext(Ym);
  if (e === null)
    throw new Error(w1);
  return S.useMemo(() => ({
    getState: e.getState,
    setState: e.setState,
    subscribe: e.subscribe
  }), [e]);
}
const nO = { display: "none" }, jB = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0px, 0px, 0px, 0px)",
  clipPath: "inset(100%)"
}, x1 = "react-flow__node-desc", S1 = "react-flow__edge-desc", zB = "react-flow__aria-live", TB = (e) => e.ariaLiveMessage;
function DB({ rfId: e }) {
  const t = at(TB);
  return E.jsx("div", { id: `${zB}-${e}`, "aria-live": "assertive", "aria-atomic": "true", style: jB, children: t });
}
function PB({ rfId: e, disableKeyboardA11y: t }) {
  return E.jsxs(E.Fragment, { children: [E.jsxs("div", { id: `${x1}-${e}`, style: nO, children: ["Press enter or space to select a node.", !t && "You can then use the arrow keys to move the node around.", " Press delete to remove it and escape to cancel.", " "] }), E.jsx("div", { id: `${S1}-${e}`, style: nO, children: "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel." }), !t && E.jsx(DB, { rfId: e })] });
}
const LB = (e) => e.userSelectionActive ? "none" : "all", qm = S.forwardRef(({ position: e = "top-left", children: t, className: n, style: r, ...o }, i) => {
  const s = at(LB), u = `${e}`.split("-");
  return E.jsx("div", { className: mn(["react-flow__panel", n, ...u]), style: { ...r, pointerEvents: s }, ref: i, ...o, children: t });
});
qm.displayName = "Panel";
function IB({ proOptions: e, position: t = "bottom-right" }) {
  return e != null && e.hideAttribution ? null : E.jsx(qm, { position: t, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children: E.jsx("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution", children: "React Flow" }) });
}
const VB = (e) => {
  const t = [], n = [];
  for (const [, r] of e.nodeLookup)
    r.selected && t.push(r.internals.userNode);
  for (const [, r] of e.edgeLookup)
    r.selected && n.push(r);
  return { selectedNodes: t, selectedEdges: n };
}, qp = (e) => e.id;
function BB(e, t) {
  return Ft(e.selectedNodes.map(qp), t.selectedNodes.map(qp)) && Ft(e.selectedEdges.map(qp), t.selectedEdges.map(qp));
}
function FB({ onSelectionChange: e }) {
  const t = Ht(), { selectedNodes: n, selectedEdges: r } = at(VB, BB);
  return S.useEffect(() => {
    const o = { nodes: n, edges: r };
    e?.(o), t.getState().onSelectionChangeHandlers.forEach((i) => i(o));
  }, [n, r, e]), null;
}
const UB = (e) => !!e.onSelectionChangeHandlers;
function HB({ onSelectionChange: e }) {
  const t = at(UB);
  return e || t ? E.jsx(FB, { onSelectionChange: e }) : null;
}
const _1 = [0, 0], $B = { x: 0, y: 0, zoom: 1 }, YB = [
  "nodes",
  "edges",
  "defaultNodes",
  "defaultEdges",
  "onConnect",
  "onConnectStart",
  "onConnectEnd",
  "onClickConnectStart",
  "onClickConnectEnd",
  "nodesDraggable",
  "nodesConnectable",
  "nodesFocusable",
  "edgesFocusable",
  "edgesReconnectable",
  "elevateNodesOnSelect",
  "elevateEdgesOnSelect",
  "minZoom",
  "maxZoom",
  "nodeExtent",
  "onNodesChange",
  "onEdgesChange",
  "elementsSelectable",
  "connectionMode",
  "snapGrid",
  "snapToGrid",
  "translateExtent",
  "connectOnClick",
  "defaultEdgeOptions",
  "fitView",
  "fitViewOptions",
  "onNodesDelete",
  "onEdgesDelete",
  "onDelete",
  "onNodeDrag",
  "onNodeDragStart",
  "onNodeDragStop",
  "onSelectionDrag",
  "onSelectionDragStart",
  "onSelectionDragStop",
  "onMoveStart",
  "onMove",
  "onMoveEnd",
  "noPanClassName",
  "nodeOrigin",
  "autoPanOnConnect",
  "autoPanOnNodeDrag",
  "onError",
  "connectionRadius",
  "isValidConnection",
  "selectNodesOnDrag",
  "nodeDragThreshold",
  "onBeforeDelete",
  "debug",
  "autoPanSpeed",
  "paneClickDistance"
], rO = [...YB, "rfId"], qB = (e) => ({
  setNodes: e.setNodes,
  setEdges: e.setEdges,
  setMinZoom: e.setMinZoom,
  setMaxZoom: e.setMaxZoom,
  setTranslateExtent: e.setTranslateExtent,
  setNodeExtent: e.setNodeExtent,
  reset: e.reset,
  setDefaultNodesAndEdges: e.setDefaultNodesAndEdges,
  setPaneClickDistance: e.setPaneClickDistance
}), oO = {
  /*
   * these are values that are also passed directly to other components
   * than the StoreUpdater. We can reduce the number of setStore calls
   * by setting the same values here as prev fields.
   */
  translateExtent: zd,
  nodeOrigin: _1,
  minZoom: 0.5,
  maxZoom: 2,
  elementsSelectable: !0,
  noPanClassName: "nopan",
  rfId: "1",
  paneClickDistance: 0
};
function XB(e) {
  const { setNodes: t, setEdges: n, setMinZoom: r, setMaxZoom: o, setTranslateExtent: i, setNodeExtent: s, reset: u, setDefaultNodesAndEdges: c, setPaneClickDistance: d } = at(qB, Ft), p = Ht();
  S.useEffect(() => (c(e.defaultNodes, e.defaultEdges), () => {
    h.current = oO, u();
  }), []);
  const h = S.useRef(oO);
  return S.useEffect(
    () => {
      for (const g of rO) {
        const y = e[g], b = h.current[g];
        y !== b && (typeof e[g] > "u" || (g === "nodes" ? t(y) : g === "edges" ? n(y) : g === "minZoom" ? r(y) : g === "maxZoom" ? o(y) : g === "translateExtent" ? i(y) : g === "nodeExtent" ? s(y) : g === "paneClickDistance" ? d(y) : g === "fitView" ? p.setState({ fitViewQueued: y }) : g === "fitViewOptions" ? p.setState({ fitViewOptions: y }) : p.setState({ [g]: y })));
      }
      h.current = e;
    },
    // Only re-run the effect if one of the fields we track changes
    rO.map((g) => e[g])
  ), null;
}
function iO() {
  return typeof window > "u" || !window.matchMedia ? null : window.matchMedia("(prefers-color-scheme: dark)");
}
function WB(e) {
  var t;
  const [n, r] = S.useState(e === "system" ? null : e);
  return S.useEffect(() => {
    if (e !== "system") {
      r(e);
      return;
    }
    const o = iO(), i = () => r(o != null && o.matches ? "dark" : "light");
    return i(), o?.addEventListener("change", i), () => {
      o?.removeEventListener("change", i);
    };
  }, [e]), n !== null ? n : (t = iO()) != null && t.matches ? "dark" : "light";
}
const aO = typeof document < "u" ? document : null;
function Ru(e = null, t = { target: aO, actInsideInputWithModifier: !0 }) {
  const [n, r] = S.useState(!1), o = S.useRef(!1), i = S.useRef(/* @__PURE__ */ new Set([])), [s, u] = S.useMemo(() => {
    if (e !== null) {
      const c = (Array.isArray(e) ? e : [e]).filter((p) => typeof p == "string").map((p) => p.replace("+", `
`).replace(`

`, `
+`).split(`
`)), d = c.reduce((p, h) => p.concat(...h), []);
      return [c, d];
    }
    return [[], []];
  }, [e]);
  return S.useEffect(() => {
    const c = t?.target || aO;
    if (e !== null) {
      const d = (g) => {
        var y, b;
        if (o.current = g.ctrlKey || g.metaKey || g.shiftKey || g.altKey, (!o.current || o.current && !t.actInsideInputWithModifier) && o1(g))
          return !1;
        const v = lO(g.code, u);
        if (i.current.add(g[v]), sO(s, i.current, !1)) {
          const x = ((b = (y = g.composedPath) == null ? void 0 : y.call(g)) == null ? void 0 : b[0]) || g.target, _ = x?.nodeName === "BUTTON" || x?.nodeName === "A";
          t.preventDefault !== !1 && (o.current || !_) && g.preventDefault(), r(!0);
        }
      }, p = (g) => {
        const y = lO(g.code, u);
        sO(s, i.current, !0) ? (r(!1), i.current.clear()) : i.current.delete(g[y]), g.key === "Meta" && i.current.clear(), o.current = !1;
      }, h = () => {
        i.current.clear(), r(!1);
      };
      return c?.addEventListener("keydown", d), c?.addEventListener("keyup", p), window.addEventListener("blur", h), window.addEventListener("contextmenu", h), () => {
        c?.removeEventListener("keydown", d), c?.removeEventListener("keyup", p), window.removeEventListener("blur", h), window.removeEventListener("contextmenu", h);
      };
    }
  }, [e, r]), n;
}
function sO(e, t, n) {
  return e.filter((r) => n || r.length === t.size).some((r) => r.every((o) => t.has(o)));
}
function lO(e, t) {
  return t.includes(e) ? "code" : "key";
}
const GB = () => {
  const e = Ht();
  return S.useMemo(() => ({
    zoomIn: (t) => {
      const { panZoom: n } = e.getState();
      return n ? n.scaleBy(1.2, { duration: t?.duration }) : Promise.resolve(!1);
    },
    zoomOut: (t) => {
      const { panZoom: n } = e.getState();
      return n ? n.scaleBy(1 / 1.2, { duration: t?.duration }) : Promise.resolve(!1);
    },
    zoomTo: (t, n) => {
      const { panZoom: r } = e.getState();
      return r ? r.scaleTo(t, { duration: n?.duration }) : Promise.resolve(!1);
    },
    getZoom: () => e.getState().transform[2],
    setViewport: async (t, n) => {
      const { transform: [r, o, i], panZoom: s } = e.getState();
      return s ? (await s.setViewport({
        x: t.x ?? r,
        y: t.y ?? o,
        zoom: t.zoom ?? i
      }, { duration: n?.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    getViewport: () => {
      const [t, n, r] = e.getState().transform;
      return { x: t, y: n, zoom: r };
    },
    setCenter: async (t, n, r) => {
      const { width: o, height: i, maxZoom: s, panZoom: u } = e.getState(), c = typeof r?.zoom < "u" ? r.zoom : s, d = o / 2 - t * c, p = i / 2 - n * c;
      return u ? (await u.setViewport({
        x: d,
        y: p,
        zoom: c
      }, { duration: r?.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    fitBounds: async (t, n) => {
      const { width: r, height: o, minZoom: i, maxZoom: s, panZoom: u } = e.getState(), c = NS(t, r, o, i, s, n?.padding ?? 0.1);
      return u ? (await u.setViewport(c, { duration: n?.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    screenToFlowPosition: (t, n = {}) => {
      const { transform: r, snapGrid: o, snapToGrid: i, domNode: s } = e.getState();
      if (!s)
        return t;
      const { x: u, y: c } = s.getBoundingClientRect(), d = {
        x: t.x - u,
        y: t.y - c
      }, p = n.snapGrid ?? o, h = n.snapToGrid ?? i;
      return cf(d, r, h, p);
    },
    flowToScreenPosition: (t) => {
      const { transform: n, domNode: r } = e.getState();
      if (!r)
        return t;
      const { x: o, y: i } = r.getBoundingClientRect(), s = Qh(t, n);
      return {
        x: s.x + o,
        y: s.y + i
      };
    }
  }), []);
};
function k1(e, t) {
  const n = [], r = /* @__PURE__ */ new Map(), o = [];
  for (const i of e)
    if (i.type === "add") {
      o.push(i);
      continue;
    } else if (i.type === "remove" || i.type === "replace")
      r.set(i.id, [i]);
    else {
      const s = r.get(i.id);
      s ? s.push(i) : r.set(i.id, [i]);
    }
  for (const i of t) {
    const s = r.get(i.id);
    if (!s) {
      n.push(i);
      continue;
    }
    if (s[0].type === "remove")
      continue;
    if (s[0].type === "replace") {
      n.push({ ...s[0].item });
      continue;
    }
    const u = { ...i };
    for (const c of s)
      ZB(c, u);
    n.push(u);
  }
  return o.length && o.forEach((i) => {
    i.index !== void 0 ? n.splice(i.index, 0, { ...i.item }) : n.push({ ...i.item });
  }), n;
}
function ZB(e, t) {
  switch (e.type) {
    case "select": {
      t.selected = e.selected;
      break;
    }
    case "position": {
      typeof e.position < "u" && (t.position = e.position), typeof e.dragging < "u" && (t.dragging = e.dragging);
      break;
    }
    case "dimensions": {
      typeof e.dimensions < "u" && (t.measured ?? (t.measured = {}), t.measured.width = e.dimensions.width, t.measured.height = e.dimensions.height, e.setAttributes && (t.width = e.dimensions.width, t.height = e.dimensions.height)), typeof e.resizing == "boolean" && (t.resizing = e.resizing);
      break;
    }
  }
}
function E1(e, t) {
  return k1(e, t);
}
function C1(e, t) {
  return k1(e, t);
}
function Ls(e, t) {
  return {
    id: e,
    type: "select",
    selected: t
  };
}
function uu(e, t = /* @__PURE__ */ new Set(), n = !1) {
  const r = [];
  for (const [o, i] of e) {
    const s = t.has(o);
    !(i.selected === void 0 && !s) && i.selected !== s && (n && (i.selected = s), r.push(Ls(i.id, s)));
  }
  return r;
}
function uO({ items: e = [], lookup: t }) {
  var n;
  const r = [], o = new Map(e.map((i) => [i.id, i]));
  for (const [i, s] of e.entries()) {
    const u = t.get(s.id), c = ((n = u?.internals) == null ? void 0 : n.userNode) ?? u;
    c !== void 0 && c !== s && r.push({ id: s.id, item: s, type: "replace" }), c === void 0 && r.push({ item: s, type: "add", index: i });
  }
  for (const [i] of t)
    o.get(i) === void 0 && r.push({ id: i, type: "remove" });
  return r;
}
function cO(e) {
  return {
    id: e.id,
    type: "remove"
  };
}
const dO = (e) => jV(e), KB = (e) => GN(e);
function O1(e) {
  return S.forwardRef(e);
}
const QB = typeof window < "u" ? S.useLayoutEffect : S.useEffect;
function fO(e) {
  const [t, n] = S.useState(BigInt(0)), [r] = S.useState(() => JB(() => n((o) => o + BigInt(1))));
  return QB(() => {
    const o = r.get();
    o.length && (e(o), r.reset());
  }, [t]), r;
}
function JB(e) {
  let t = [];
  return {
    get: () => t,
    reset: () => {
      t = [];
    },
    push: (n) => {
      t.push(n), e();
    }
  };
}
const A1 = S.createContext(null);
function eF({ children: e }) {
  const t = Ht(), n = S.useCallback((u) => {
    const { nodes: c = [], setNodes: d, hasDefaultNodes: p, onNodesChange: h, nodeLookup: g, fitViewQueued: y } = t.getState();
    let b = c;
    for (const v of u)
      b = typeof v == "function" ? v(b) : v;
    if (p)
      d(b);
    else {
      const v = uO({
        items: b,
        lookup: g
      });
      v.length > 0 ? h?.(v) : y && window.requestAnimationFrame(() => {
        const { fitViewQueued: x, nodes: _, setNodes: O } = t.getState();
        x && O(_);
      });
    }
  }, []), r = fO(n), o = S.useCallback((u) => {
    const { edges: c = [], setEdges: d, hasDefaultEdges: p, onEdgesChange: h, edgeLookup: g } = t.getState();
    let y = c;
    for (const b of u)
      y = typeof b == "function" ? b(y) : b;
    p ? d(y) : h && h(uO({
      items: y,
      lookup: g
    }));
  }, []), i = fO(o), s = S.useMemo(() => ({ nodeQueue: r, edgeQueue: i }), []);
  return E.jsx(A1.Provider, { value: s, children: e });
}
function tF() {
  const e = S.useContext(A1);
  if (!e)
    throw new Error("useBatchContext must be used within a BatchProvider");
  return e;
}
const nF = (e) => !!e.panZoom;
function df() {
  const e = GB(), t = Ht(), n = tF(), r = at(nF), o = S.useMemo(() => {
    const i = (h) => t.getState().nodeLookup.get(h), s = (h) => {
      n.nodeQueue.push(h);
    }, u = (h) => {
      n.edgeQueue.push(h);
    }, c = (h) => {
      var g, y;
      const { nodeLookup: b, nodeOrigin: v } = t.getState(), x = dO(h) ? h : b.get(h.id), _ = x.parentId ? n1(x.position, x.measured, x.parentId, b, v) : x.position, O = {
        ...x,
        position: _,
        width: ((g = x.measured) == null ? void 0 : g.width) ?? x.width,
        height: ((y = x.measured) == null ? void 0 : y.height) ?? x.height
      };
      return Nu(O);
    }, d = (h, g, y = { replace: !1 }) => {
      s((b) => b.map((v) => {
        if (v.id === h) {
          const x = typeof g == "function" ? g(v) : g;
          return y.replace && dO(x) ? x : { ...v, ...x };
        }
        return v;
      }));
    }, p = (h, g, y = { replace: !1 }) => {
      u((b) => b.map((v) => {
        if (v.id === h) {
          const x = typeof g == "function" ? g(v) : g;
          return y.replace && KB(x) ? x : { ...v, ...x };
        }
        return v;
      }));
    };
    return {
      getNodes: () => t.getState().nodes.map((h) => ({ ...h })),
      getNode: (h) => {
        var g;
        return (g = i(h)) == null ? void 0 : g.internals.userNode;
      },
      getInternalNode: i,
      getEdges: () => {
        const { edges: h = [] } = t.getState();
        return h.map((g) => ({ ...g }));
      },
      getEdge: (h) => t.getState().edgeLookup.get(h),
      setNodes: s,
      setEdges: u,
      addNodes: (h) => {
        const g = Array.isArray(h) ? h : [h];
        n.nodeQueue.push((y) => [...y, ...g]);
      },
      addEdges: (h) => {
        const g = Array.isArray(h) ? h : [h];
        n.edgeQueue.push((y) => [...y, ...g]);
      },
      toObject: () => {
        const { nodes: h = [], edges: g = [], transform: y } = t.getState(), [b, v, x] = y;
        return {
          nodes: h.map((_) => ({ ..._ })),
          edges: g.map((_) => ({ ..._ })),
          viewport: {
            x: b,
            y: v,
            zoom: x
          }
        };
      },
      deleteElements: async ({ nodes: h = [], edges: g = [] }) => {
        const { nodes: y, edges: b, onNodesDelete: v, onEdgesDelete: x, triggerNodeChanges: _, triggerEdgeChanges: O, onDelete: C, onBeforeDelete: N } = t.getState(), { nodes: R, edges: z } = await LV({
          nodesToRemove: h,
          edgesToRemove: g,
          nodes: y,
          edges: b,
          onBeforeDelete: N
        }), j = z.length > 0, I = R.length > 0;
        if (j) {
          const $ = z.map(cO);
          x?.(z), O($);
        }
        if (I) {
          const $ = R.map(cO);
          v?.(R), _($);
        }
        return (I || j) && C?.({ nodes: R, edges: z }), { deletedNodes: R, deletedEdges: z };
      },
      getIntersectingNodes: (h, g = !0, y) => {
        const b = HC(h), v = b ? h : c(h), x = y !== void 0;
        return v ? (y || t.getState().nodes).filter((_) => {
          const O = t.getState().nodeLookup.get(_.id);
          if (O && !b && (_.id === h.id || !O.internals.positionAbsolute))
            return !1;
          const C = Nu(x ? _ : O), N = Dd(C, v);
          return g && N > 0 || N >= v.width * v.height;
        }) : [];
      },
      isNodeIntersecting: (h, g, y = !0) => {
        const b = HC(h) ? h : c(h);
        if (!b)
          return !1;
        const v = Dd(b, g);
        return y && v > 0 || v >= b.width * b.height;
      },
      updateNode: d,
      updateNodeData: (h, g, y = { replace: !1 }) => {
        d(h, (b) => {
          const v = typeof g == "function" ? g(b) : g;
          return y.replace ? { ...b, data: v } : { ...b, data: { ...b.data, ...v } };
        }, y);
      },
      updateEdge: p,
      updateEdgeData: (h, g, y = { replace: !1 }) => {
        p(h, (b) => {
          const v = typeof g == "function" ? g(b) : g;
          return y.replace ? { ...b, data: v } : { ...b, data: { ...b.data, ...v } };
        }, y);
      },
      getNodesBounds: (h) => {
        const { nodeLookup: g, nodeOrigin: y } = t.getState();
        return zV(h, { nodeLookup: g, nodeOrigin: y });
      },
      getHandleConnections: ({ type: h, id: g, nodeId: y }) => {
        var b;
        return Array.from(((b = t.getState().connectionLookup.get(`${y}-${h}${g ? `-${g}` : ""}`)) == null ? void 0 : b.values()) ?? []);
      },
      getNodeConnections: ({ type: h, handleId: g, nodeId: y }) => {
        var b;
        return Array.from(((b = t.getState().connectionLookup.get(`${y}${h ? g ? `-${h}-${g}` : `-${h}` : ""}`)) == null ? void 0 : b.values()) ?? []);
      },
      fitView: async (h) => {
        const g = t.getState().fitViewResolver ?? Promise.withResolvers();
        return t.setState({ fitViewQueued: !0, fitViewOptions: h, fitViewResolver: g }), n.nodeQueue.push((y) => [...y]), g.promise;
      }
    };
  }, []);
  return S.useMemo(() => ({
    ...o,
    ...e,
    viewportInitialized: r
  }), [r]);
}
const pO = (e) => e.selected, rF = { actInsideInputWithModifier: !1 }, oF = typeof window < "u" ? window : void 0;
function iF({ deleteKeyCode: e, multiSelectionKeyCode: t }) {
  const n = Ht(), { deleteElements: r } = df(), o = Ru(e, rF), i = Ru(t, { target: oF });
  S.useEffect(() => {
    if (o) {
      const { edges: s, nodes: u } = n.getState();
      r({ nodes: u.filter(pO), edges: s.filter(pO) }), n.setState({ nodesSelectionActive: !1 });
    }
  }, [o]), S.useEffect(() => {
    n.setState({ multiSelectionActive: i });
  }, [i]);
}
function aF(e) {
  const t = Ht();
  S.useEffect(() => {
    const n = () => {
      var r, o;
      if (!e.current)
        return !1;
      const i = MS(e.current);
      (i.height === 0 || i.width === 0) && ((o = (r = t.getState()).onError) == null || o.call(r, "004", fi.error004())), t.setState({ width: i.width || 500, height: i.height || 500 });
    };
    if (e.current) {
      n(), window.addEventListener("resize", n);
      const r = new ResizeObserver(() => n());
      return r.observe(e.current), () => {
        window.removeEventListener("resize", n), r && e.current && r.unobserve(e.current);
      };
    }
  }, []);
}
const Xm = {
  position: "absolute",
  width: "100%",
  height: "100%",
  top: 0,
  left: 0
}, sF = (e) => ({
  userSelectionActive: e.userSelectionActive,
  lib: e.lib
});
function lF({ onPaneContextMenu: e, zoomOnScroll: t = !0, zoomOnPinch: n = !0, panOnScroll: r = !1, panOnScrollSpeed: o = 0.5, panOnScrollMode: i = Xs.Free, zoomOnDoubleClick: s = !0, panOnDrag: u = !0, defaultViewport: c, translateExtent: d, minZoom: p, maxZoom: h, zoomActivationKeyCode: g, preventScrolling: y = !0, children: b, noWheelClassName: v, noPanClassName: x, onViewportChange: _, isControlledViewport: O, paneClickDistance: C }) {
  const N = Ht(), R = S.useRef(null), { userSelectionActive: z, lib: j } = at(sF, Ft), I = Ru(g), $ = S.useRef();
  aF(R);
  const A = S.useCallback((V) => {
    _?.({ x: V[0], y: V[1], zoom: V[2] }), O || N.setState({ transform: V });
  }, [_, O]);
  return S.useEffect(() => {
    if (R.current) {
      $.current = bB({
        domNode: R.current,
        minZoom: p,
        maxZoom: h,
        translateExtent: d,
        viewport: c,
        paneClickDistance: C,
        onDraggingChange: (D) => N.setState({ paneDragging: D }),
        onPanZoomStart: (D, F) => {
          const { onViewportChangeStart: P, onMoveStart: H } = N.getState();
          H?.(D, F), P?.(F);
        },
        onPanZoom: (D, F) => {
          const { onViewportChange: P, onMove: H } = N.getState();
          H?.(D, F), P?.(F);
        },
        onPanZoomEnd: (D, F) => {
          const { onViewportChangeEnd: P, onMoveEnd: H } = N.getState();
          H?.(D, F), P?.(F);
        }
      });
      const { x: V, y: U, zoom: W } = $.current.getViewport();
      return N.setState({
        panZoom: $.current,
        transform: [V, U, W],
        domNode: R.current.closest(".react-flow")
      }), () => {
        var D;
        (D = $.current) == null || D.destroy();
      };
    }
  }, []), S.useEffect(() => {
    var V;
    (V = $.current) == null || V.update({
      onPaneContextMenu: e,
      zoomOnScroll: t,
      zoomOnPinch: n,
      panOnScroll: r,
      panOnScrollSpeed: o,
      panOnScrollMode: i,
      zoomOnDoubleClick: s,
      panOnDrag: u,
      zoomActivationKeyPressed: I,
      preventScrolling: y,
      noPanClassName: x,
      userSelectionActive: z,
      noWheelClassName: v,
      lib: j,
      onTransformChange: A
    });
  }, [
    e,
    t,
    n,
    r,
    o,
    i,
    s,
    u,
    I,
    y,
    x,
    z,
    v,
    j,
    A
  ]), E.jsx("div", { className: "react-flow__renderer", ref: R, style: Xm, children: b });
}
const uF = (e) => ({
  userSelectionActive: e.userSelectionActive,
  userSelectionRect: e.userSelectionRect
});
function cF() {
  const { userSelectionActive: e, userSelectionRect: t } = at(uF, Ft);
  return e && t ? E.jsx("div", { className: "react-flow__selection react-flow__container", style: {
    width: t.width,
    height: t.height,
    transform: `translate(${t.x}px, ${t.y}px)`
  } }) : null;
}
const lb = (e, t) => (n) => {
  n.target === t.current && e?.(n);
}, dF = (e) => ({
  userSelectionActive: e.userSelectionActive,
  elementsSelectable: e.elementsSelectable,
  connectionInProgress: e.connection.inProgress,
  dragging: e.paneDragging
});
function fF({ isSelecting: e, selectionKeyPressed: t, selectionMode: n = Td.Full, panOnDrag: r, selectionOnDrag: o, onSelectionStart: i, onSelectionEnd: s, onPaneClick: u, onPaneContextMenu: c, onPaneScroll: d, onPaneMouseEnter: p, onPaneMouseMove: h, onPaneMouseLeave: g, children: y }) {
  const b = Ht(), { userSelectionActive: v, elementsSelectable: x, dragging: _, connectionInProgress: O } = at(dF, Ft), C = x && (e || v), N = S.useRef(null), R = S.useRef(), z = S.useRef(/* @__PURE__ */ new Set()), j = S.useRef(/* @__PURE__ */ new Set()), I = S.useRef(!1), $ = S.useRef(!1), A = (H) => {
    if (I.current || O) {
      I.current = !1;
      return;
    }
    u?.(H), b.getState().resetSelectedElements(), b.setState({ nodesSelectionActive: !1 });
  }, V = (H) => {
    if (Array.isArray(r) && r != null && r.includes(2)) {
      H.preventDefault();
      return;
    }
    c?.(H);
  }, U = d ? (H) => d(H) : void 0, W = (H) => {
    var Y, q;
    const { resetSelectedElements: M, domNode: X } = b.getState();
    if (R.current = X?.getBoundingClientRect(), !x || !e || H.button !== 0 || H.target !== N.current || !R.current)
      return;
    (q = (Y = H.target) == null ? void 0 : Y.setPointerCapture) == null || q.call(Y, H.pointerId), $.current = !0, I.current = !1;
    const { x: K, y: L } = Yi(H.nativeEvent, R.current);
    M(), b.setState({
      userSelectionRect: {
        width: 0,
        height: 0,
        startX: K,
        startY: L,
        x: K,
        y: L
      }
    }), i?.(H);
  }, D = (H) => {
    const { userSelectionRect: Y, transform: q, nodeLookup: M, edgeLookup: X, connectionLookup: K, triggerNodeChanges: L, triggerEdgeChanges: ee, defaultEdgeOptions: ae } = b.getState();
    if (!R.current || !Y)
      return;
    I.current = !0;
    const { x: le, y: me } = Yi(H.nativeEvent, R.current), { startX: se, startY: he } = Y, _e = {
      startX: se,
      startY: he,
      x: le < se ? le : se,
      y: me < he ? me : he,
      width: Math.abs(le - se),
      height: Math.abs(me - he)
    }, Se = z.current, Ee = j.current;
    z.current = new Set(ZN(M, _e, q, n === Td.Partial, !0).map(($e) => $e.id)), j.current = /* @__PURE__ */ new Set();
    const Ie = ae?.selectable ?? !0;
    for (const $e of z.current) {
      const ct = K.get($e);
      if (ct)
        for (const { edgeId: $t } of ct.values()) {
          const ft = X.get($t);
          ft && (ft.selectable ?? Ie) && j.current.add($t);
        }
    }
    if (!$C(Se, z.current)) {
      const $e = uu(M, z.current, !0);
      L($e);
    }
    if (!$C(Ee, j.current)) {
      const $e = uu(X, j.current);
      ee($e);
    }
    b.setState({
      userSelectionRect: _e,
      userSelectionActive: !0,
      nodesSelectionActive: !1
    });
  }, F = (H) => {
    var Y, q;
    if (H.button !== 0 || !$.current)
      return;
    (q = (Y = H.target) == null ? void 0 : Y.releasePointerCapture) == null || q.call(Y, H.pointerId);
    const { userSelectionRect: M } = b.getState();
    !v && M && H.target === N.current && A?.(H), b.setState({
      userSelectionActive: !1,
      userSelectionRect: null,
      nodesSelectionActive: z.current.size > 0
    }), s?.(H), (t || o) && (I.current = !1), $.current = !1;
  }, P = r === !0 || Array.isArray(r) && r.includes(0);
  return E.jsxs("div", { className: mn(["react-flow__pane", { draggable: P, dragging: _, selection: e }]), onClick: C ? void 0 : lb(A, N), onContextMenu: lb(V, N), onWheel: lb(U, N), onPointerEnter: C ? void 0 : p, onPointerDown: C ? W : h, onPointerMove: C ? D : h, onPointerUp: C ? F : void 0, onPointerLeave: g, ref: N, style: Xm, children: [y, E.jsx(cF, {})] });
}
function Yw({ id: e, store: t, unselect: n = !1, nodeRef: r }) {
  const { addSelectedNodes: o, unselectNodesAndEdges: i, multiSelectionActive: s, nodeLookup: u, onError: c } = t.getState(), d = u.get(e);
  if (!d) {
    c?.("012", fi.error012(e));
    return;
  }
  t.setState({ nodesSelectionActive: !1 }), d.selected ? (n || d.selected && s) && (i({ nodes: [d], edges: [] }), requestAnimationFrame(() => {
    var p;
    return (p = r?.current) == null ? void 0 : p.blur();
  })) : o([e]);
}
function N1({ nodeRef: e, disabled: t = !1, noDragClassName: n, handleSelector: r, nodeId: o, isSelectable: i, nodeClickDistance: s }) {
  const u = Ht(), [c, d] = S.useState(!1), p = S.useRef();
  return S.useEffect(() => {
    p.current = iB({
      getStoreItems: () => u.getState(),
      onNodeMouseDown: (h) => {
        Yw({
          id: h,
          store: u,
          nodeRef: e
        });
      },
      onDragStart: () => {
        d(!0);
      },
      onDragStop: () => {
        d(!1);
      }
    });
  }, []), S.useEffect(() => {
    var h, g;
    if (t)
      (h = p.current) == null || h.destroy();
    else if (e.current)
      return (g = p.current) == null || g.update({
        noDragClassName: n,
        handleSelector: r,
        domNode: e.current,
        isSelectable: i,
        nodeId: o,
        nodeClickDistance: s
      }), () => {
        var y;
        (y = p.current) == null || y.destroy();
      };
  }, [n, r, t, i, e, o]), c;
}
const pF = (e) => (t) => t.selected && (t.draggable || e && typeof t.draggable > "u");
function M1() {
  const e = Ht();
  return S.useCallback((t) => {
    const { nodeExtent: n, snapToGrid: r, snapGrid: o, nodesDraggable: i, onError: s, updateNodePositions: u, nodeLookup: c, nodeOrigin: d } = e.getState(), p = /* @__PURE__ */ new Map(), h = pF(i), g = r ? o[0] : 5, y = r ? o[1] : 5, b = t.direction.x * g * t.factor, v = t.direction.y * y * t.factor;
    for (const [, x] of c) {
      if (!h(x))
        continue;
      let _ = {
        x: x.internals.positionAbsolute.x + b,
        y: x.internals.positionAbsolute.y + v
      };
      r && (_ = Hm(_, o));
      const { position: O, positionAbsolute: C } = KN({
        nodeId: x.id,
        nextPosition: _,
        nodeLookup: c,
        nodeExtent: n,
        nodeOrigin: d,
        onError: s
      });
      x.position = O, x.internals.positionAbsolute = C, p.set(x.id, x);
    }
    u(p);
  }, []);
}
const PS = S.createContext(null), hF = PS.Provider;
PS.Consumer;
const R1 = () => S.useContext(PS), mF = (e) => ({
  connectOnClick: e.connectOnClick,
  noPanClassName: e.noPanClassName,
  rfId: e.rfId
}), gF = (e, t, n) => (r) => {
  const { connectionClickStartHandle: o, connectionMode: i, connection: s } = r, { fromHandle: u, toHandle: c, isValid: d } = s, p = c?.nodeId === e && c?.id === t && c?.type === n;
  return {
    connectingFrom: u?.nodeId === e && u?.id === t && u?.type === n,
    connectingTo: p,
    clickConnecting: o?.nodeId === e && o?.id === t && o?.type === n,
    isPossibleEndHandle: i === Ou.Strict ? u?.type !== n : e !== u?.nodeId || t !== u?.id,
    connectionInProcess: !!u,
    clickConnectionInProcess: !!o,
    valid: p && d
  };
};
function yF({ type: e = "source", position: t = je.Top, isValidConnection: n, isConnectable: r = !0, isConnectableStart: o = !0, isConnectableEnd: i = !0, id: s, onConnect: u, children: c, className: d, onMouseDown: p, onTouchStart: h, ...g }, y) {
  var b, v;
  const x = s || null, _ = e === "target", O = Ht(), C = R1(), { connectOnClick: N, noPanClassName: R, rfId: z } = at(mF, Ft), { connectingFrom: j, connectingTo: I, clickConnecting: $, isPossibleEndHandle: A, connectionInProcess: V, clickConnectionInProcess: U, valid: W } = at(gF(C, x, e), Ft);
  C || (v = (b = O.getState()).onError) == null || v.call(b, "010", fi.error010());
  const D = (H) => {
    const { defaultEdgeOptions: Y, onConnect: q, hasDefaultEdges: M } = O.getState(), X = {
      ...Y,
      ...H
    };
    if (M) {
      const { edges: K, setEdges: L } = O.getState();
      L(qV(X, K));
    }
    q?.(X), u?.(X);
  }, F = (H) => {
    if (!C)
      return;
    const Y = i1(H.nativeEvent);
    if (o && (Y && H.button === 0 || !Y)) {
      const q = O.getState();
      $w.onPointerDown(H.nativeEvent, {
        autoPanOnConnect: q.autoPanOnConnect,
        connectionMode: q.connectionMode,
        connectionRadius: q.connectionRadius,
        domNode: q.domNode,
        nodeLookup: q.nodeLookup,
        lib: q.lib,
        isTarget: _,
        handleId: x,
        nodeId: C,
        flowId: q.rfId,
        panBy: q.panBy,
        cancelConnection: q.cancelConnection,
        onConnectStart: q.onConnectStart,
        onConnectEnd: q.onConnectEnd,
        updateConnection: q.updateConnection,
        onConnect: D,
        isValidConnection: n || q.isValidConnection,
        getTransform: () => O.getState().transform,
        getFromHandle: () => O.getState().connection.fromHandle,
        autoPanSpeed: q.autoPanSpeed
      });
    }
    Y ? p?.(H) : h?.(H);
  }, P = (H) => {
    const { onClickConnectStart: Y, onClickConnectEnd: q, connectionClickStartHandle: M, connectionMode: X, isValidConnection: K, lib: L, rfId: ee, nodeLookup: ae, connection: le } = O.getState();
    if (!C || !M && !o)
      return;
    if (!M) {
      Y?.(H.nativeEvent, { nodeId: C, handleId: x, handleType: e }), O.setState({ connectionClickStartHandle: { nodeId: C, type: e, id: x } });
      return;
    }
    const me = r1(H.target), se = n || K, { connection: he, isValid: _e } = $w.isValid(H.nativeEvent, {
      handle: {
        nodeId: C,
        id: x,
        type: e
      },
      connectionMode: X,
      fromNodeId: M.nodeId,
      fromHandleId: M.id || null,
      fromType: M.type,
      isValidConnection: se,
      flowId: ee,
      doc: me,
      lib: L,
      nodeLookup: ae
    });
    _e && he && D(he);
    const Se = structuredClone(le);
    delete Se.inProgress, Se.toPosition = Se.toHandle ? Se.toHandle.position : null, q?.(H, Se), O.setState({ connectionClickStartHandle: null });
  };
  return E.jsx("div", { "data-handleid": x, "data-nodeid": C, "data-handlepos": t, "data-id": `${z}-${C}-${x}-${e}`, className: mn([
    "react-flow__handle",
    `react-flow__handle-${t}`,
    "nodrag",
    R,
    d,
    {
      source: !_,
      target: _,
      connectable: r,
      connectablestart: o,
      connectableend: i,
      clickconnecting: $,
      connectingfrom: j,
      connectingto: I,
      valid: W,
      /*
       * shows where you can start a connection from
       * and where you can end it while connecting
       */
      connectionindicator: r && (!V || A) && (V || U ? i : o)
    }
  ]), onMouseDown: F, onTouchStart: F, onClick: N ? P : void 0, ref: y, ...g, children: c });
}
const Ld = S.memo(O1(yF));
function vF({ data: e, isConnectable: t, sourcePosition: n = je.Bottom }) {
  return E.jsxs(E.Fragment, { children: [e?.label, E.jsx(Ld, { type: "source", position: n, isConnectable: t })] });
}
function bF({ data: e, isConnectable: t, targetPosition: n = je.Top, sourcePosition: r = je.Bottom }) {
  return E.jsxs(E.Fragment, { children: [E.jsx(Ld, { type: "target", position: n, isConnectable: t }), e?.label, E.jsx(Ld, { type: "source", position: r, isConnectable: t })] });
}
function wF() {
  return null;
}
function xF({ data: e, isConnectable: t, targetPosition: n = je.Top }) {
  return E.jsxs(E.Fragment, { children: [E.jsx(Ld, { type: "target", position: n, isConnectable: t }), e?.label] });
}
const em = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
}, hO = {
  input: vF,
  default: bF,
  output: xF,
  group: wF
};
function SF(e) {
  var t, n, r, o;
  return e.internals.handleBounds === void 0 ? {
    width: e.width ?? e.initialWidth ?? ((t = e.style) == null ? void 0 : t.width),
    height: e.height ?? e.initialHeight ?? ((n = e.style) == null ? void 0 : n.height)
  } : {
    width: e.width ?? ((r = e.style) == null ? void 0 : r.width),
    height: e.height ?? ((o = e.style) == null ? void 0 : o.height)
  };
}
const _F = (e) => {
  const { width: t, height: n, x: r, y: o } = uf(e.nodeLookup, {
    filter: (i) => !!i.selected
  });
  return {
    width: Mo(t) ? t : null,
    height: Mo(n) ? n : null,
    userSelectionActive: e.userSelectionActive,
    transformString: `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]}) translate(${r}px,${o}px)`
  };
};
function kF({ onSelectionContextMenu: e, noPanClassName: t, disableKeyboardA11y: n }) {
  const r = Ht(), { width: o, height: i, transformString: s, userSelectionActive: u } = at(_F, Ft), c = M1(), d = S.useRef(null);
  if (S.useEffect(() => {
    var g;
    n || (g = d.current) == null || g.focus({
      preventScroll: !0
    });
  }, [n]), N1({
    nodeRef: d
  }), u || !o || !i)
    return null;
  const p = e ? (g) => {
    const y = r.getState().nodes.filter((b) => b.selected);
    e(g, y);
  } : void 0, h = (g) => {
    Object.prototype.hasOwnProperty.call(em, g.key) && (g.preventDefault(), c({
      direction: em[g.key],
      factor: g.shiftKey ? 4 : 1
    }));
  };
  return E.jsx("div", { className: mn(["react-flow__nodesselection", "react-flow__container", t]), style: {
    transform: s
  }, children: E.jsx("div", { ref: d, className: "react-flow__nodesselection-rect", onContextMenu: p, tabIndex: n ? void 0 : -1, onKeyDown: n ? void 0 : h, style: {
    width: o,
    height: i
  } }) });
}
const mO = typeof window < "u" ? window : void 0, EF = (e) => ({ nodesSelectionActive: e.nodesSelectionActive, userSelectionActive: e.userSelectionActive });
function j1({ children: e, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: o, onPaneContextMenu: i, onPaneScroll: s, paneClickDistance: u, deleteKeyCode: c, selectionKeyCode: d, selectionOnDrag: p, selectionMode: h, onSelectionStart: g, onSelectionEnd: y, multiSelectionKeyCode: b, panActivationKeyCode: v, zoomActivationKeyCode: x, elementsSelectable: _, zoomOnScroll: O, zoomOnPinch: C, panOnScroll: N, panOnScrollSpeed: R, panOnScrollMode: z, zoomOnDoubleClick: j, panOnDrag: I, defaultViewport: $, translateExtent: A, minZoom: V, maxZoom: U, preventScrolling: W, onSelectionContextMenu: D, noWheelClassName: F, noPanClassName: P, disableKeyboardA11y: H, onViewportChange: Y, isControlledViewport: q }) {
  const { nodesSelectionActive: M, userSelectionActive: X } = at(EF), K = Ru(d, { target: mO }), L = Ru(v, { target: mO }), ee = L || I, ae = L || N, le = p && ee !== !0, me = K || X || le;
  return iF({ deleteKeyCode: c, multiSelectionKeyCode: b }), E.jsx(lF, { onPaneContextMenu: i, elementsSelectable: _, zoomOnScroll: O, zoomOnPinch: C, panOnScroll: ae, panOnScrollSpeed: R, panOnScrollMode: z, zoomOnDoubleClick: j, panOnDrag: !K && ee, defaultViewport: $, translateExtent: A, minZoom: V, maxZoom: U, zoomActivationKeyCode: x, preventScrolling: W, noWheelClassName: F, noPanClassName: P, onViewportChange: Y, isControlledViewport: q, paneClickDistance: u, children: E.jsxs(fF, { onSelectionStart: g, onSelectionEnd: y, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: o, onPaneContextMenu: i, onPaneScroll: s, panOnDrag: ee, isSelecting: !!me, selectionMode: h, selectionKeyPressed: K, selectionOnDrag: le, children: [e, M && E.jsx(kF, { onSelectionContextMenu: D, noPanClassName: P, disableKeyboardA11y: H })] }) });
}
j1.displayName = "FlowRenderer";
const CF = S.memo(j1), OF = (e) => (t) => e ? ZN(t.nodeLookup, { x: 0, y: 0, width: t.width, height: t.height }, t.transform, !0).map((n) => n.id) : Array.from(t.nodeLookup.keys());
function AF(e) {
  return at(S.useCallback(OF(e), [e]), Ft);
}
const NF = (e) => e.updateNodeInternals;
function MF() {
  const e = at(NF), [t] = S.useState(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((n) => {
    const r = /* @__PURE__ */ new Map();
    n.forEach((o) => {
      const i = o.target.getAttribute("data-id");
      r.set(i, {
        id: i,
        nodeElement: o.target,
        force: !0
      });
    }), e(r);
  }));
  return S.useEffect(() => () => {
    t?.disconnect();
  }, [t]), t;
}
function RF({ node: e, nodeType: t, hasDimensions: n, resizeObserver: r }) {
  const o = Ht(), i = S.useRef(null), s = S.useRef(null), u = S.useRef(e.sourcePosition), c = S.useRef(e.targetPosition), d = S.useRef(t), p = n && !!e.internals.handleBounds;
  return S.useEffect(() => {
    i.current && !e.hidden && (!p || s.current !== i.current) && (s.current && r?.unobserve(s.current), r?.observe(i.current), s.current = i.current);
  }, [p, e.hidden]), S.useEffect(() => () => {
    s.current && (r?.unobserve(s.current), s.current = null);
  }, []), S.useEffect(() => {
    if (i.current) {
      const h = d.current !== t, g = u.current !== e.sourcePosition, y = c.current !== e.targetPosition;
      (h || g || y) && (d.current = t, u.current = e.sourcePosition, c.current = e.targetPosition, o.getState().updateNodeInternals(/* @__PURE__ */ new Map([[e.id, { id: e.id, nodeElement: i.current, force: !0 }]])));
    }
  }, [e.id, t, e.sourcePosition, e.targetPosition]), i;
}
function jF({ id: e, onClick: t, onMouseEnter: n, onMouseMove: r, onMouseLeave: o, onContextMenu: i, onDoubleClick: s, nodesDraggable: u, elementsSelectable: c, nodesConnectable: d, nodesFocusable: p, resizeObserver: h, noDragClassName: g, noPanClassName: y, disableKeyboardA11y: b, rfId: v, nodeTypes: x, nodeClickDistance: _, onError: O }) {
  const { node: C, internals: N, isParent: R } = at((me) => {
    const se = me.nodeLookup.get(e), he = me.parentLookup.has(e);
    return {
      node: se,
      internals: se.internals,
      isParent: he
    };
  }, Ft);
  let z = C.type || "default", j = x?.[z] || hO[z];
  j === void 0 && (O?.("003", fi.error003(z)), z = "default", j = hO.default);
  const I = !!(C.draggable || u && typeof C.draggable > "u"), $ = !!(C.selectable || c && typeof C.selectable > "u"), A = !!(C.connectable || d && typeof C.connectable > "u"), V = !!(C.focusable || p && typeof C.focusable > "u"), U = Ht(), W = t1(C), D = RF({ node: C, nodeType: z, hasDimensions: W, resizeObserver: h }), F = N1({
    nodeRef: D,
    disabled: C.hidden || !I,
    noDragClassName: g,
    handleSelector: C.dragHandle,
    nodeId: e,
    isSelectable: $,
    nodeClickDistance: _
  }), P = M1();
  if (C.hidden)
    return null;
  const H = ra(C), Y = SF(C), q = $ || I || t || n || r || o, M = n ? (me) => n(me, { ...N.userNode }) : void 0, X = r ? (me) => r(me, { ...N.userNode }) : void 0, K = o ? (me) => o(me, { ...N.userNode }) : void 0, L = i ? (me) => i(me, { ...N.userNode }) : void 0, ee = s ? (me) => s(me, { ...N.userNode }) : void 0, ae = (me) => {
    const { selectNodesOnDrag: se, nodeDragThreshold: he } = U.getState();
    $ && (!se || !I || he > 0) && Yw({
      id: e,
      store: U,
      nodeRef: D
    }), t && t(me, { ...N.userNode });
  }, le = (me) => {
    if (!(o1(me.nativeEvent) || b))
      if (qN.includes(me.key) && $) {
        const se = me.key === "Escape";
        Yw({
          id: e,
          store: U,
          unselect: se,
          nodeRef: D
        });
      } else I && C.selected && Object.prototype.hasOwnProperty.call(em, me.key) && (me.preventDefault(), U.setState({
        ariaLiveMessage: `Moved selected node ${me.key.replace("Arrow", "").toLowerCase()}. New position, x: ${~~N.positionAbsolute.x}, y: ${~~N.positionAbsolute.y}`
      }), P({
        direction: em[me.key],
        factor: me.shiftKey ? 4 : 1
      }));
  };
  return E.jsx("div", { className: mn([
    "react-flow__node",
    `react-flow__node-${z}`,
    {
      // this is overwritable by passing `nopan` as a class name
      [y]: I
    },
    C.className,
    {
      selected: C.selected,
      selectable: $,
      parent: R,
      draggable: I,
      dragging: F
    }
  ]), ref: D, style: {
    zIndex: N.z,
    transform: `translate(${N.positionAbsolute.x}px,${N.positionAbsolute.y}px)`,
    pointerEvents: q ? "all" : "none",
    visibility: W ? "visible" : "hidden",
    ...C.style,
    ...Y
  }, "data-id": e, "data-testid": `rf__node-${e}`, onMouseEnter: M, onMouseMove: X, onMouseLeave: K, onContextMenu: L, onClick: ae, onDoubleClick: ee, onKeyDown: V ? le : void 0, tabIndex: V ? 0 : void 0, role: V ? "button" : void 0, "aria-describedby": b ? void 0 : `${x1}-${v}`, "aria-label": C.ariaLabel, children: E.jsx(hF, { value: e, children: E.jsx(j, { id: e, data: C.data, type: z, positionAbsoluteX: N.positionAbsolute.x, positionAbsoluteY: N.positionAbsolute.y, selected: C.selected ?? !1, selectable: $, draggable: I, deletable: C.deletable ?? !0, isConnectable: A, sourcePosition: C.sourcePosition, targetPosition: C.targetPosition, dragging: F, dragHandle: C.dragHandle, zIndex: N.z, parentId: C.parentId, ...H }) }) });
}
const zF = (e) => ({
  nodesDraggable: e.nodesDraggable,
  nodesConnectable: e.nodesConnectable,
  nodesFocusable: e.nodesFocusable,
  elementsSelectable: e.elementsSelectable,
  onError: e.onError
});
function z1(e) {
  const { nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: o, onError: i } = at(zF, Ft), s = AF(e.onlyRenderVisibleElements), u = MF();
  return E.jsx("div", { className: "react-flow__nodes", style: Xm, children: s.map((c) => (
    /*
     * The split of responsibilities between NodeRenderer and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For example, when youre dragging a single node, that node gets
     * updated multiple times per second. If `NodeRenderer` were to update
     * every time, it would have to re-run the `nodes.map()` loop every
     * time. This gets pricey with hundreds of nodes, especially if every
     * loop cycle does more than just rendering a JSX element!
     *
     * As a result of this choice, we took the following implementation
     * decisions:
     * - NodeRenderer subscribes *only* to node IDs  and therefore
     *   rerender *only* when visible nodes are added or removed.
     * - NodeRenderer performs all operations the result of which can be
     *   shared between nodes (such as creating the `ResizeObserver`
     *   instance, or subscribing to `selector`). This means extra prop
     *   drilling into `NodeComponentWrapper`, but it means we need to run
     *   these operations only once  instead of once per node.
     * - Any operations that youd normally write inside `nodes.map` are
     *   moved into `NodeComponentWrapper`. This ensures they are
     *   memorized  so if `NodeRenderer` *has* to rerender, it only
     *   needs to regenerate the list of nodes, nothing else.
     */
    E.jsx(jF, { id: c, nodeTypes: e.nodeTypes, nodeExtent: e.nodeExtent, onClick: e.onNodeClick, onMouseEnter: e.onNodeMouseEnter, onMouseMove: e.onNodeMouseMove, onMouseLeave: e.onNodeMouseLeave, onContextMenu: e.onNodeContextMenu, onDoubleClick: e.onNodeDoubleClick, noDragClassName: e.noDragClassName, noPanClassName: e.noPanClassName, rfId: e.rfId, disableKeyboardA11y: e.disableKeyboardA11y, resizeObserver: u, nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: o, nodeClickDistance: e.nodeClickDistance, onError: i }, c)
  )) });
}
z1.displayName = "NodeRenderer";
const TF = S.memo(z1);
function DF(e) {
  return at(S.useCallback((t) => {
    if (!e)
      return t.edges.map((r) => r.id);
    const n = [];
    if (t.width && t.height)
      for (const r of t.edges) {
        const o = t.nodeLookup.get(r.source), i = t.nodeLookup.get(r.target);
        o && i && HV({
          sourceNode: o,
          targetNode: i,
          width: t.width,
          height: t.height,
          transform: t.transform
        }) && n.push(r.id);
      }
    return n;
  }, [e]), Ft);
}
const PF = ({ color: e = "none", strokeWidth: t = 1 }) => E.jsx("polyline", { style: {
  stroke: e,
  strokeWidth: t
}, strokeLinecap: "round", strokeLinejoin: "round", fill: "none", points: "-5,-4 0,0 -5,4" }), LF = ({ color: e = "none", strokeWidth: t = 1 }) => E.jsx("polyline", { style: {
  stroke: e,
  fill: e,
  strokeWidth: t
}, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" }), gO = {
  [Zh.Arrow]: PF,
  [Zh.ArrowClosed]: LF
};
function IF(e) {
  const t = Ht();
  return S.useMemo(() => {
    var n, r;
    return Object.prototype.hasOwnProperty.call(gO, e) ? gO[e] : ((r = (n = t.getState()).onError) == null || r.call(n, "009", fi.error009(e)), null);
  }, [e]);
}
const VF = ({ id: e, type: t, color: n, width: r = 12.5, height: o = 12.5, markerUnits: i = "strokeWidth", strokeWidth: s, orient: u = "auto-start-reverse" }) => {
  const c = IF(t);
  return c ? E.jsx("marker", { className: "react-flow__arrowhead", id: e, markerWidth: `${r}`, markerHeight: `${o}`, viewBox: "-10 -10 20 20", markerUnits: i, orient: u, refX: "0", refY: "0", children: E.jsx(c, { color: n, strokeWidth: s }) }) : null;
}, T1 = ({ defaultColor: e, rfId: t }) => {
  const n = at((i) => i.edges), r = at((i) => i.defaultEdgeOptions), o = S.useMemo(() => KV(n, {
    id: t,
    defaultColor: e,
    defaultMarkerStart: r?.markerStart,
    defaultMarkerEnd: r?.markerEnd
  }), [n, r, t, e]);
  return o.length ? E.jsx("svg", { className: "react-flow__marker", children: E.jsx("defs", { children: o.map((i) => E.jsx(VF, { id: i.id, type: i.type, color: i.color, width: i.width, height: i.height, markerUnits: i.markerUnits, strokeWidth: i.strokeWidth, orient: i.orient }, i.id)) }) }) : null;
};
T1.displayName = "MarkerDefinitions";
var BF = S.memo(T1);
function D1({ x: e, y: t, label: n, labelStyle: r, labelShowBg: o = !0, labelBgStyle: i, labelBgPadding: s = [2, 4], labelBgBorderRadius: u = 2, children: c, className: d, ...p }) {
  const [h, g] = S.useState({ x: 1, y: 0, width: 0, height: 0 }), y = mn(["react-flow__edge-textwrapper", d]), b = S.useRef(null);
  return S.useEffect(() => {
    if (b.current) {
      const v = b.current.getBBox();
      g({
        x: v.x,
        y: v.y,
        width: v.width,
        height: v.height
      });
    }
  }, [n]), n ? E.jsxs("g", { transform: `translate(${e - h.width / 2} ${t - h.height / 2})`, className: y, visibility: h.width ? "visible" : "hidden", ...p, children: [o && E.jsx("rect", { width: h.width + 2 * s[0], x: -s[0], y: -s[1], height: h.height + 2 * s[1], className: "react-flow__edge-textbg", style: i, rx: u, ry: u }), E.jsx("text", { className: "react-flow__edge-text", y: h.height / 2, dy: "0.3em", ref: b, style: r, children: n }), c] }) : null;
}
D1.displayName = "EdgeText";
const FF = S.memo(D1);
function ff({ path: e, labelX: t, labelY: n, label: r, labelStyle: o, labelShowBg: i, labelBgStyle: s, labelBgPadding: u, labelBgBorderRadius: c, interactionWidth: d = 20, ...p }) {
  return E.jsxs(E.Fragment, { children: [E.jsx("path", { ...p, d: e, fill: "none", className: mn(["react-flow__edge-path", p.className]) }), d && E.jsx("path", { d: e, fill: "none", strokeOpacity: 0, strokeWidth: d, className: "react-flow__edge-interaction" }), r && Mo(t) && Mo(n) ? E.jsx(FF, { x: t, y: n, label: r, labelStyle: o, labelShowBg: i, labelBgStyle: s, labelBgPadding: u, labelBgBorderRadius: c }) : null] });
}
function yO({ pos: e, x1: t, y1: n, x2: r, y2: o }) {
  return e === je.Left || e === je.Right ? [0.5 * (t + r), n] : [t, 0.5 * (n + o)];
}
function P1({ sourceX: e, sourceY: t, sourcePosition: n = je.Bottom, targetX: r, targetY: o, targetPosition: i = je.Top }) {
  const [s, u] = yO({
    pos: n,
    x1: e,
    y1: t,
    x2: r,
    y2: o
  }), [c, d] = yO({
    pos: i,
    x1: r,
    y1: o,
    x2: e,
    y2: t
  }), [p, h, g, y] = a1({
    sourceX: e,
    sourceY: t,
    targetX: r,
    targetY: o,
    sourceControlX: s,
    sourceControlY: u,
    targetControlX: c,
    targetControlY: d
  });
  return [
    `M${e},${t} C${s},${u} ${c},${d} ${r},${o}`,
    p,
    h,
    g,
    y
  ];
}
function L1(e) {
  return S.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: i, sourcePosition: s, targetPosition: u, label: c, labelStyle: d, labelShowBg: p, labelBgStyle: h, labelBgPadding: g, labelBgBorderRadius: y, style: b, markerEnd: v, markerStart: x, interactionWidth: _ }) => {
    const [O, C, N] = P1({
      sourceX: n,
      sourceY: r,
      sourcePosition: s,
      targetX: o,
      targetY: i,
      targetPosition: u
    }), R = e.isInternal ? void 0 : t;
    return E.jsx(ff, { id: R, path: O, labelX: C, labelY: N, label: c, labelStyle: d, labelShowBg: p, labelBgStyle: h, labelBgPadding: g, labelBgBorderRadius: y, style: b, markerEnd: v, markerStart: x, interactionWidth: _ });
  });
}
const UF = L1({ isInternal: !1 }), I1 = L1({ isInternal: !0 });
UF.displayName = "SimpleBezierEdge";
I1.displayName = "SimpleBezierEdgeInternal";
function V1(e) {
  return S.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: i, label: s, labelStyle: u, labelShowBg: c, labelBgStyle: d, labelBgPadding: p, labelBgBorderRadius: h, style: g, sourcePosition: y = je.Bottom, targetPosition: b = je.Top, markerEnd: v, markerStart: x, pathOptions: _, interactionWidth: O }) => {
    const [C, N, R] = Fw({
      sourceX: n,
      sourceY: r,
      sourcePosition: y,
      targetX: o,
      targetY: i,
      targetPosition: b,
      borderRadius: _?.borderRadius,
      offset: _?.offset
    }), z = e.isInternal ? void 0 : t;
    return E.jsx(ff, { id: z, path: C, labelX: N, labelY: R, label: s, labelStyle: u, labelShowBg: c, labelBgStyle: d, labelBgPadding: p, labelBgBorderRadius: h, style: g, markerEnd: v, markerStart: x, interactionWidth: O });
  });
}
const B1 = V1({ isInternal: !1 }), F1 = V1({ isInternal: !0 });
B1.displayName = "SmoothStepEdge";
F1.displayName = "SmoothStepEdgeInternal";
function U1(e) {
  return S.memo(({ id: t, ...n }) => {
    var r;
    const o = e.isInternal ? void 0 : t;
    return E.jsx(B1, { ...n, id: o, pathOptions: S.useMemo(() => {
      var i;
      return { borderRadius: 0, offset: (i = n.pathOptions) == null ? void 0 : i.offset };
    }, [(r = n.pathOptions) == null ? void 0 : r.offset]) });
  });
}
const HF = U1({ isInternal: !1 }), H1 = U1({ isInternal: !0 });
HF.displayName = "StepEdge";
H1.displayName = "StepEdgeInternal";
function $1(e) {
  return S.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: i, label: s, labelStyle: u, labelShowBg: c, labelBgStyle: d, labelBgPadding: p, labelBgBorderRadius: h, style: g, markerEnd: y, markerStart: b, interactionWidth: v }) => {
    const [x, _, O] = l1({ sourceX: n, sourceY: r, targetX: o, targetY: i }), C = e.isInternal ? void 0 : t;
    return E.jsx(ff, { id: C, path: x, labelX: _, labelY: O, label: s, labelStyle: u, labelShowBg: c, labelBgStyle: d, labelBgPadding: p, labelBgBorderRadius: h, style: g, markerEnd: y, markerStart: b, interactionWidth: v });
  });
}
const $F = $1({ isInternal: !1 }), Y1 = $1({ isInternal: !0 });
$F.displayName = "StraightEdge";
Y1.displayName = "StraightEdgeInternal";
function q1(e) {
  return S.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: i, sourcePosition: s = je.Bottom, targetPosition: u = je.Top, label: c, labelStyle: d, labelShowBg: p, labelBgStyle: h, labelBgPadding: g, labelBgBorderRadius: y, style: b, markerEnd: v, markerStart: x, pathOptions: _, interactionWidth: O }) => {
    const [C, N, R] = RS({
      sourceX: n,
      sourceY: r,
      sourcePosition: s,
      targetX: o,
      targetY: i,
      targetPosition: u,
      curvature: _?.curvature
    }), z = e.isInternal ? void 0 : t;
    return E.jsx(ff, { id: z, path: C, labelX: N, labelY: R, label: c, labelStyle: d, labelShowBg: p, labelBgStyle: h, labelBgPadding: g, labelBgBorderRadius: y, style: b, markerEnd: v, markerStart: x, interactionWidth: O });
  });
}
const YF = q1({ isInternal: !1 }), X1 = q1({ isInternal: !0 });
YF.displayName = "BezierEdge";
X1.displayName = "BezierEdgeInternal";
const vO = {
  default: X1,
  straight: Y1,
  step: H1,
  smoothstep: F1,
  simplebezier: I1
}, bO = {
  sourceX: null,
  sourceY: null,
  targetX: null,
  targetY: null,
  sourcePosition: null,
  targetPosition: null
}, qF = (e, t, n) => n === je.Left ? e - t : n === je.Right ? e + t : e, XF = (e, t, n) => n === je.Top ? e - t : n === je.Bottom ? e + t : e, wO = "react-flow__edgeupdater";
function xO({ position: e, centerX: t, centerY: n, radius: r = 10, onMouseDown: o, onMouseEnter: i, onMouseOut: s, type: u }) {
  return E.jsx("circle", { onMouseDown: o, onMouseEnter: i, onMouseOut: s, className: mn([wO, `${wO}-${u}`]), cx: qF(t, r, e), cy: XF(n, r, e), r, stroke: "transparent", fill: "transparent" });
}
function WF({ isReconnectable: e, reconnectRadius: t, edge: n, sourceX: r, sourceY: o, targetX: i, targetY: s, sourcePosition: u, targetPosition: c, onReconnect: d, onReconnectStart: p, onReconnectEnd: h, setReconnecting: g, setUpdateHover: y }) {
  const b = Ht(), v = (N, R) => {
    if (N.button !== 0)
      return;
    const { autoPanOnConnect: z, domNode: j, isValidConnection: I, connectionMode: $, connectionRadius: A, lib: V, onConnectStart: U, onConnectEnd: W, cancelConnection: D, nodeLookup: F, rfId: P, panBy: H, updateConnection: Y } = b.getState(), q = R.type === "target";
    g(!0), p?.(N, n, R.type);
    const M = (K, L) => {
      g(!1), h?.(K, n, R.type, L);
    }, X = (K) => d?.(n, K);
    $w.onPointerDown(N.nativeEvent, {
      autoPanOnConnect: z,
      connectionMode: $,
      connectionRadius: A,
      domNode: j,
      handleId: R.id,
      nodeId: R.nodeId,
      nodeLookup: F,
      isTarget: q,
      edgeUpdaterType: R.type,
      lib: V,
      flowId: P,
      cancelConnection: D,
      panBy: H,
      isValidConnection: I,
      onConnect: X,
      onConnectStart: U,
      onConnectEnd: W,
      onReconnectEnd: M,
      updateConnection: Y,
      getTransform: () => b.getState().transform,
      getFromHandle: () => b.getState().connection.fromHandle
    });
  }, x = (N) => v(N, { nodeId: n.target, id: n.targetHandle ?? null, type: "target" }), _ = (N) => v(N, { nodeId: n.source, id: n.sourceHandle ?? null, type: "source" }), O = () => y(!0), C = () => y(!1);
  return E.jsxs(E.Fragment, { children: [(e === !0 || e === "source") && E.jsx(xO, { position: u, centerX: r, centerY: o, radius: t, onMouseDown: x, onMouseEnter: O, onMouseOut: C, type: "source" }), (e === !0 || e === "target") && E.jsx(xO, { position: c, centerX: i, centerY: s, radius: t, onMouseDown: _, onMouseEnter: O, onMouseOut: C, type: "target" })] });
}
function GF({ id: e, edgesFocusable: t, edgesReconnectable: n, elementsSelectable: r, onClick: o, onDoubleClick: i, onContextMenu: s, onMouseEnter: u, onMouseMove: c, onMouseLeave: d, reconnectRadius: p, onReconnect: h, onReconnectStart: g, onReconnectEnd: y, rfId: b, edgeTypes: v, noPanClassName: x, onError: _, disableKeyboardA11y: O }) {
  let C = at((Ee) => Ee.edgeLookup.get(e));
  const N = at((Ee) => Ee.defaultEdgeOptions);
  C = N ? { ...N, ...C } : C;
  let R = C.type || "default", z = v?.[R] || vO[R];
  z === void 0 && (_?.("011", fi.error011(R)), R = "default", z = vO.default);
  const j = !!(C.focusable || t && typeof C.focusable > "u"), I = typeof h < "u" && (C.reconnectable || n && typeof C.reconnectable > "u"), $ = !!(C.selectable || r && typeof C.selectable > "u"), A = S.useRef(null), [V, U] = S.useState(!1), [W, D] = S.useState(!1), F = Ht(), { zIndex: P, sourceX: H, sourceY: Y, targetX: q, targetY: M, sourcePosition: X, targetPosition: K } = at(S.useCallback((Ee) => {
    const Ie = Ee.nodeLookup.get(C.source), $e = Ee.nodeLookup.get(C.target);
    if (!Ie || !$e)
      return {
        zIndex: C.zIndex,
        ...bO
      };
    const ct = ZV({
      id: e,
      sourceNode: Ie,
      targetNode: $e,
      sourceHandle: C.sourceHandle || null,
      targetHandle: C.targetHandle || null,
      connectionMode: Ee.connectionMode,
      onError: _
    });
    return {
      zIndex: UV({
        selected: C.selected,
        zIndex: C.zIndex,
        sourceNode: Ie,
        targetNode: $e,
        elevateOnSelect: Ee.elevateEdgesOnSelect
      }),
      ...ct || bO
    };
  }, [C.source, C.target, C.sourceHandle, C.targetHandle, C.selected, C.zIndex]), Ft), L = S.useMemo(() => C.markerStart ? `url('#${Uw(C.markerStart, b)}')` : void 0, [C.markerStart, b]), ee = S.useMemo(() => C.markerEnd ? `url('#${Uw(C.markerEnd, b)}')` : void 0, [C.markerEnd, b]);
  if (C.hidden || H === null || Y === null || q === null || M === null)
    return null;
  const ae = (Ee) => {
    var Ie;
    const { addSelectedEdges: $e, unselectNodesAndEdges: ct, multiSelectionActive: $t } = F.getState();
    $ && (F.setState({ nodesSelectionActive: !1 }), C.selected && $t ? (ct({ nodes: [], edges: [C] }), (Ie = A.current) == null || Ie.blur()) : $e([e])), o && o(Ee, C);
  }, le = i ? (Ee) => {
    i(Ee, { ...C });
  } : void 0, me = s ? (Ee) => {
    s(Ee, { ...C });
  } : void 0, se = u ? (Ee) => {
    u(Ee, { ...C });
  } : void 0, he = c ? (Ee) => {
    c(Ee, { ...C });
  } : void 0, _e = d ? (Ee) => {
    d(Ee, { ...C });
  } : void 0, Se = (Ee) => {
    var Ie;
    if (!O && qN.includes(Ee.key) && $) {
      const { unselectNodesAndEdges: $e, addSelectedEdges: ct } = F.getState();
      Ee.key === "Escape" ? ((Ie = A.current) == null || Ie.blur(), $e({ edges: [C] })) : ct([e]);
    }
  };
  return E.jsx("svg", { style: { zIndex: P }, children: E.jsxs("g", { className: mn([
    "react-flow__edge",
    `react-flow__edge-${R}`,
    C.className,
    x,
    {
      selected: C.selected,
      animated: C.animated,
      inactive: !$ && !o,
      updating: V,
      selectable: $
    }
  ]), onClick: ae, onDoubleClick: le, onContextMenu: me, onMouseEnter: se, onMouseMove: he, onMouseLeave: _e, onKeyDown: j ? Se : void 0, tabIndex: j ? 0 : void 0, role: j ? "button" : "img", "data-id": e, "data-testid": `rf__edge-${e}`, "aria-label": C.ariaLabel === null ? void 0 : C.ariaLabel || `Edge from ${C.source} to ${C.target}`, "aria-describedby": j ? `${S1}-${b}` : void 0, ref: A, children: [!W && E.jsx(z, { id: e, source: C.source, target: C.target, type: C.type, selected: C.selected, animated: C.animated, selectable: $, deletable: C.deletable ?? !0, label: C.label, labelStyle: C.labelStyle, labelShowBg: C.labelShowBg, labelBgStyle: C.labelBgStyle, labelBgPadding: C.labelBgPadding, labelBgBorderRadius: C.labelBgBorderRadius, sourceX: H, sourceY: Y, targetX: q, targetY: M, sourcePosition: X, targetPosition: K, data: C.data, style: C.style, sourceHandleId: C.sourceHandle, targetHandleId: C.targetHandle, markerStart: L, markerEnd: ee, pathOptions: "pathOptions" in C ? C.pathOptions : void 0, interactionWidth: C.interactionWidth }), I && E.jsx(WF, { edge: C, isReconnectable: I, reconnectRadius: p, onReconnect: h, onReconnectStart: g, onReconnectEnd: y, sourceX: H, sourceY: Y, targetX: q, targetY: M, sourcePosition: X, targetPosition: K, setUpdateHover: U, setReconnecting: D })] }) });
}
const ZF = (e) => ({
  edgesFocusable: e.edgesFocusable,
  edgesReconnectable: e.edgesReconnectable,
  elementsSelectable: e.elementsSelectable,
  connectionMode: e.connectionMode,
  onError: e.onError
});
function W1({ defaultMarkerColor: e, onlyRenderVisibleElements: t, rfId: n, edgeTypes: r, noPanClassName: o, onReconnect: i, onEdgeContextMenu: s, onEdgeMouseEnter: u, onEdgeMouseMove: c, onEdgeMouseLeave: d, onEdgeClick: p, reconnectRadius: h, onEdgeDoubleClick: g, onReconnectStart: y, onReconnectEnd: b, disableKeyboardA11y: v }) {
  const { edgesFocusable: x, edgesReconnectable: _, elementsSelectable: O, onError: C } = at(ZF, Ft), N = DF(t);
  return E.jsxs("div", { className: "react-flow__edges", children: [E.jsx(BF, { defaultColor: e, rfId: n }), N.map((R) => E.jsx(GF, { id: R, edgesFocusable: x, edgesReconnectable: _, elementsSelectable: O, noPanClassName: o, onReconnect: i, onContextMenu: s, onMouseEnter: u, onMouseMove: c, onMouseLeave: d, onClick: p, reconnectRadius: h, onDoubleClick: g, onReconnectStart: y, onReconnectEnd: b, rfId: n, onError: C, edgeTypes: r, disableKeyboardA11y: v }, R))] });
}
W1.displayName = "EdgeRenderer";
const KF = S.memo(W1), QF = (e) => `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`;
function JF({ children: e }) {
  const t = at(QF);
  return E.jsx("div", { className: "react-flow__viewport xyflow__viewport react-flow__container", style: { transform: t }, children: e });
}
function eU(e) {
  const t = df(), n = S.useRef(!1);
  S.useEffect(() => {
    !n.current && t.viewportInitialized && e && (setTimeout(() => e(t), 1), n.current = !0);
  }, [e, t.viewportInitialized]);
}
const tU = (e) => {
  var t;
  return (t = e.panZoom) == null ? void 0 : t.syncViewport;
};
function nU(e) {
  const t = at(tU), n = Ht();
  return S.useEffect(() => {
    e && (t?.(e), n.setState({ transform: [e.x, e.y, e.zoom] }));
  }, [e, t]), null;
}
function rU(e) {
  return e.connection.inProgress ? { ...e.connection, to: cf(e.connection.to, e.transform) } : { ...e.connection };
}
function oU(e) {
  return rU;
}
function iU(e) {
  const t = oU();
  return at(t, Ft);
}
const aU = (e) => ({
  nodesConnectable: e.nodesConnectable,
  isValid: e.connection.isValid,
  inProgress: e.connection.inProgress,
  width: e.width,
  height: e.height
});
function sU({ containerStyle: e, style: t, type: n, component: r }) {
  const { nodesConnectable: o, width: i, height: s, isValid: u, inProgress: c } = at(aU, Ft);
  return i && o && c ? E.jsx("svg", { style: e, width: i, height: s, className: "react-flow__connectionline react-flow__container", children: E.jsx("g", { className: mn(["react-flow__connection", WN(u)]), children: E.jsx(G1, { style: t, type: n, CustomComponent: r, isValid: u }) }) }) : null;
}
const G1 = ({ style: e, type: t = Ya.Bezier, CustomComponent: n, isValid: r }) => {
  const { inProgress: o, from: i, fromNode: s, fromHandle: u, fromPosition: c, to: d, toNode: p, toHandle: h, toPosition: g } = iU();
  if (!o)
    return;
  if (n)
    return E.jsx(n, { connectionLineType: t, connectionLineStyle: e, fromNode: s, fromHandle: u, fromX: i.x, fromY: i.y, toX: d.x, toY: d.y, fromPosition: c, toPosition: g, connectionStatus: WN(r), toNode: p, toHandle: h });
  let y = "";
  const b = {
    sourceX: i.x,
    sourceY: i.y,
    sourcePosition: c,
    targetX: d.x,
    targetY: d.y,
    targetPosition: g
  };
  switch (t) {
    case Ya.Bezier:
      [y] = RS(b);
      break;
    case Ya.SimpleBezier:
      [y] = P1(b);
      break;
    case Ya.Step:
      [y] = Fw({
        ...b,
        borderRadius: 0
      });
      break;
    case Ya.SmoothStep:
      [y] = Fw(b);
      break;
    default:
      [y] = l1(b);
  }
  return E.jsx("path", { d: y, fill: "none", className: "react-flow__connection-path", style: e });
};
G1.displayName = "ConnectionLine";
const lU = {};
function SO(e = lU) {
  S.useRef(e), Ht(), S.useEffect(() => {
  }, [e]);
}
function uU() {
  Ht(), S.useRef(!1), S.useEffect(() => {
  }, []);
}
function Z1({ nodeTypes: e, edgeTypes: t, onInit: n, onNodeClick: r, onEdgeClick: o, onNodeDoubleClick: i, onEdgeDoubleClick: s, onNodeMouseEnter: u, onNodeMouseMove: c, onNodeMouseLeave: d, onNodeContextMenu: p, onSelectionContextMenu: h, onSelectionStart: g, onSelectionEnd: y, connectionLineType: b, connectionLineStyle: v, connectionLineComponent: x, connectionLineContainerStyle: _, selectionKeyCode: O, selectionOnDrag: C, selectionMode: N, multiSelectionKeyCode: R, panActivationKeyCode: z, zoomActivationKeyCode: j, deleteKeyCode: I, onlyRenderVisibleElements: $, elementsSelectable: A, defaultViewport: V, translateExtent: U, minZoom: W, maxZoom: D, preventScrolling: F, defaultMarkerColor: P, zoomOnScroll: H, zoomOnPinch: Y, panOnScroll: q, panOnScrollSpeed: M, panOnScrollMode: X, zoomOnDoubleClick: K, panOnDrag: L, onPaneClick: ee, onPaneMouseEnter: ae, onPaneMouseMove: le, onPaneMouseLeave: me, onPaneScroll: se, onPaneContextMenu: he, paneClickDistance: _e, nodeClickDistance: Se, onEdgeContextMenu: Ee, onEdgeMouseEnter: Ie, onEdgeMouseMove: $e, onEdgeMouseLeave: ct, reconnectRadius: $t, onReconnect: ft, onReconnectStart: br, onReconnectEnd: on, noDragClassName: vn, noWheelClassName: De, noPanClassName: qr, disableKeyboardA11y: Xr, nodeExtent: qn, rfId: Wr, viewport: ce, onViewportChange: ye }) {
  return SO(e), SO(t), uU(), eU(n), nU(ce), E.jsx(CF, { onPaneClick: ee, onPaneMouseEnter: ae, onPaneMouseMove: le, onPaneMouseLeave: me, onPaneContextMenu: he, onPaneScroll: se, paneClickDistance: _e, deleteKeyCode: I, selectionKeyCode: O, selectionOnDrag: C, selectionMode: N, onSelectionStart: g, onSelectionEnd: y, multiSelectionKeyCode: R, panActivationKeyCode: z, zoomActivationKeyCode: j, elementsSelectable: A, zoomOnScroll: H, zoomOnPinch: Y, zoomOnDoubleClick: K, panOnScroll: q, panOnScrollSpeed: M, panOnScrollMode: X, panOnDrag: L, defaultViewport: V, translateExtent: U, minZoom: W, maxZoom: D, onSelectionContextMenu: h, preventScrolling: F, noDragClassName: vn, noWheelClassName: De, noPanClassName: qr, disableKeyboardA11y: Xr, onViewportChange: ye, isControlledViewport: !!ce, children: E.jsxs(JF, { children: [E.jsx(KF, { edgeTypes: t, onEdgeClick: o, onEdgeDoubleClick: s, onReconnect: ft, onReconnectStart: br, onReconnectEnd: on, onlyRenderVisibleElements: $, onEdgeContextMenu: Ee, onEdgeMouseEnter: Ie, onEdgeMouseMove: $e, onEdgeMouseLeave: ct, reconnectRadius: $t, defaultMarkerColor: P, noPanClassName: qr, disableKeyboardA11y: Xr, rfId: Wr }), E.jsx(sU, { style: v, type: b, component: x, containerStyle: _ }), E.jsx("div", { className: "react-flow__edgelabel-renderer" }), E.jsx(TF, { nodeTypes: e, onNodeClick: r, onNodeDoubleClick: i, onNodeMouseEnter: u, onNodeMouseMove: c, onNodeMouseLeave: d, onNodeContextMenu: p, nodeClickDistance: Se, onlyRenderVisibleElements: $, noPanClassName: qr, noDragClassName: vn, disableKeyboardA11y: Xr, nodeExtent: qn, rfId: Wr }), E.jsx("div", { className: "react-flow__viewport-portal" })] }) });
}
Z1.displayName = "GraphView";
const cU = S.memo(Z1), _O = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: o, height: i, fitView: s, nodeOrigin: u, nodeExtent: c } = {}) => {
  const d = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Map(), y = r ?? t ?? [], b = n ?? e ?? [], v = u ?? [0, 0], x = c ?? zd;
  c1(h, g, y), Hw(b, d, p, {
    nodeOrigin: v,
    nodeExtent: x,
    elevateNodesOnSelect: !1
  });
  let _ = [0, 0, 1];
  if (s && o && i) {
    const O = uf(d, {
      filter: (z) => !!((z.width || z.initialWidth) && (z.height || z.initialHeight))
    }), { x: C, y: N, zoom: R } = NS(O, o, i, 0.5, 2, 0.1);
    _ = [C, N, R];
  }
  return {
    rfId: "1",
    width: 0,
    height: 0,
    transform: _,
    nodes: b,
    nodeLookup: d,
    parentLookup: p,
    edges: y,
    edgeLookup: g,
    connectionLookup: h,
    onNodesChange: null,
    onEdgesChange: null,
    hasDefaultNodes: n !== void 0,
    hasDefaultEdges: r !== void 0,
    panZoom: null,
    minZoom: 0.5,
    maxZoom: 2,
    translateExtent: zd,
    nodeExtent: x,
    nodesSelectionActive: !1,
    userSelectionActive: !1,
    userSelectionRect: null,
    connectionMode: Ou.Strict,
    domNode: null,
    paneDragging: !1,
    noPanClassName: "nopan",
    nodeOrigin: v,
    nodeDragThreshold: 1,
    snapGrid: [15, 15],
    snapToGrid: !1,
    nodesDraggable: !0,
    nodesConnectable: !0,
    nodesFocusable: !0,
    edgesFocusable: !0,
    edgesReconnectable: !0,
    elementsSelectable: !0,
    elevateNodesOnSelect: !0,
    elevateEdgesOnSelect: !1,
    selectNodesOnDrag: !0,
    multiSelectionActive: !1,
    fitViewQueued: s ?? !1,
    fitViewOptions: void 0,
    fitViewResolver: null,
    connection: { ...XN },
    connectionClickStartHandle: null,
    connectOnClick: !0,
    ariaLiveMessage: "",
    autoPanOnConnect: !0,
    autoPanOnNodeDrag: !0,
    autoPanSpeed: 15,
    connectionRadius: 20,
    onError: IV,
    isValidConnection: void 0,
    onSelectionChangeHandlers: [],
    lib: "react",
    debug: !1
  };
}, dU = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: o, height: i, fitView: s, nodeOrigin: u, nodeExtent: c }) => MB((d, p) => {
  async function h() {
    const { nodeLookup: g, panZoom: y, fitViewOptions: b, fitViewResolver: v, width: x, height: _, minZoom: O, maxZoom: C } = p();
    y && (await PV({
      nodes: g,
      width: x,
      height: _,
      panZoom: y,
      minZoom: O,
      maxZoom: C
    }, b), v?.resolve(!0), d({ fitViewResolver: null }));
  }
  return {
    ..._O({ nodes: e, edges: t, width: o, height: i, fitView: s, nodeOrigin: u, nodeExtent: c, defaultNodes: n, defaultEdges: r }),
    setNodes: (g) => {
      const { nodeLookup: y, parentLookup: b, nodeOrigin: v, elevateNodesOnSelect: x, fitViewQueued: _ } = p(), O = Hw(g, y, b, {
        nodeOrigin: v,
        nodeExtent: c,
        elevateNodesOnSelect: x,
        checkEquality: !0
      });
      _ && O ? (h(), d({ nodes: g, fitViewQueued: !1, fitViewOptions: void 0 })) : d({ nodes: g });
    },
    setEdges: (g) => {
      const { connectionLookup: y, edgeLookup: b } = p();
      c1(y, b, g), d({ edges: g });
    },
    setDefaultNodesAndEdges: (g, y) => {
      if (g) {
        const { setNodes: b } = p();
        b(g), d({ hasDefaultNodes: !0 });
      }
      if (y) {
        const { setEdges: b } = p();
        b(y), d({ hasDefaultEdges: !0 });
      }
    },
    /*
     * Every node gets registerd at a ResizeObserver. Whenever a node
     * changes its dimensions, this function is called to measure the
     * new dimensions and update the nodes.
     */
    updateNodeInternals: (g) => {
      const { triggerNodeChanges: y, nodeLookup: b, parentLookup: v, domNode: x, nodeOrigin: _, nodeExtent: O, debug: C, fitViewQueued: N } = p(), { changes: R, updatedInternals: z } = nB(g, b, v, x, _, O);
      z && (JV(b, v, { nodeOrigin: _, nodeExtent: O }), N ? (h(), d({ fitViewQueued: !1, fitViewOptions: void 0 })) : d({}), R?.length > 0 && (C && console.log("React Flow: trigger node changes", R), y?.(R)));
    },
    updateNodePositions: (g, y = !1) => {
      const b = [], v = [], { nodeLookup: x, triggerNodeChanges: _ } = p();
      for (const [O, C] of g) {
        const N = x.get(O), R = !!(N != null && N.expandParent && N != null && N.parentId && C != null && C.position), z = {
          id: O,
          type: "position",
          position: R ? {
            x: Math.max(0, C.position.x),
            y: Math.max(0, C.position.y)
          } : C.position,
          dragging: y
        };
        R && N.parentId && b.push({
          id: O,
          parentId: N.parentId,
          rect: {
            ...C.internals.positionAbsolute,
            width: C.measured.width ?? 0,
            height: C.measured.height ?? 0
          }
        }), v.push(z);
      }
      if (b.length > 0) {
        const { parentLookup: O, nodeOrigin: C } = p(), N = DS(b, x, O, C);
        v.push(...N);
      }
      _(v);
    },
    triggerNodeChanges: (g) => {
      const { onNodesChange: y, setNodes: b, nodes: v, hasDefaultNodes: x, debug: _ } = p();
      if (g != null && g.length) {
        if (x) {
          const O = E1(g, v);
          b(O);
        }
        _ && console.log("React Flow: trigger node changes", g), y?.(g);
      }
    },
    triggerEdgeChanges: (g) => {
      const { onEdgesChange: y, setEdges: b, edges: v, hasDefaultEdges: x, debug: _ } = p();
      if (g != null && g.length) {
        if (x) {
          const O = C1(g, v);
          b(O);
        }
        _ && console.log("React Flow: trigger edge changes", g), y?.(g);
      }
    },
    addSelectedNodes: (g) => {
      const { multiSelectionActive: y, edgeLookup: b, nodeLookup: v, triggerNodeChanges: x, triggerEdgeChanges: _ } = p();
      if (y) {
        const O = g.map((C) => Ls(C, !0));
        x(O);
        return;
      }
      x(uu(v, /* @__PURE__ */ new Set([...g]), !0)), _(uu(b));
    },
    addSelectedEdges: (g) => {
      const { multiSelectionActive: y, edgeLookup: b, nodeLookup: v, triggerNodeChanges: x, triggerEdgeChanges: _ } = p();
      if (y) {
        const O = g.map((C) => Ls(C, !0));
        _(O);
        return;
      }
      _(uu(b, /* @__PURE__ */ new Set([...g]))), x(uu(v, /* @__PURE__ */ new Set(), !0));
    },
    unselectNodesAndEdges: ({ nodes: g, edges: y } = {}) => {
      const { edges: b, nodes: v, nodeLookup: x, triggerNodeChanges: _, triggerEdgeChanges: O } = p(), C = g || v, N = y || b, R = C.map((j) => {
        const I = x.get(j.id);
        return I && (I.selected = !1), Ls(j.id, !1);
      }), z = N.map((j) => Ls(j.id, !1));
      _(R), O(z);
    },
    setMinZoom: (g) => {
      const { panZoom: y, maxZoom: b } = p();
      y?.setScaleExtent([g, b]), d({ minZoom: g });
    },
    setMaxZoom: (g) => {
      const { panZoom: y, minZoom: b } = p();
      y?.setScaleExtent([b, g]), d({ maxZoom: g });
    },
    setTranslateExtent: (g) => {
      var y;
      (y = p().panZoom) == null || y.setTranslateExtent(g), d({ translateExtent: g });
    },
    setPaneClickDistance: (g) => {
      var y;
      (y = p().panZoom) == null || y.setClickDistance(g);
    },
    resetSelectedElements: () => {
      const { edges: g, nodes: y, triggerNodeChanges: b, triggerEdgeChanges: v } = p(), x = y.reduce((O, C) => C.selected ? [...O, Ls(C.id, !1)] : O, []), _ = g.reduce((O, C) => C.selected ? [...O, Ls(C.id, !1)] : O, []);
      b(x), v(_);
    },
    setNodeExtent: (g) => {
      const { nodes: y, nodeLookup: b, parentLookup: v, nodeOrigin: x, elevateNodesOnSelect: _, nodeExtent: O } = p();
      g[0][0] === O[0][0] && g[0][1] === O[0][1] && g[1][0] === O[1][0] && g[1][1] === O[1][1] || (Hw(y, b, v, {
        nodeOrigin: x,
        nodeExtent: g,
        elevateNodesOnSelect: _,
        checkEquality: !1
      }), d({ nodeExtent: g }));
    },
    panBy: (g) => {
      const { transform: y, width: b, height: v, panZoom: x, translateExtent: _ } = p();
      return rB({ delta: g, panZoom: x, transform: y, translateExtent: _, width: b, height: v });
    },
    cancelConnection: () => {
      d({
        connection: { ...XN }
      });
    },
    updateConnection: (g) => {
      d({ connection: g });
    },
    reset: () => d({ ..._O() })
  };
}, Object.is);
function fU({ initialNodes: e, initialEdges: t, defaultNodes: n, defaultEdges: r, initialWidth: o, initialHeight: i, fitView: s, nodeOrigin: u, nodeExtent: c, children: d }) {
  const [p] = S.useState(() => dU({
    nodes: e,
    edges: t,
    defaultNodes: n,
    defaultEdges: r,
    width: o,
    height: i,
    fitView: s,
    nodeOrigin: u,
    nodeExtent: c
  }));
  return E.jsx(RB, { value: p, children: E.jsx(eF, { children: d }) });
}
function pU({ children: e, nodes: t, edges: n, defaultNodes: r, defaultEdges: o, width: i, height: s, fitView: u, nodeOrigin: c, nodeExtent: d }) {
  return S.useContext(Ym) ? E.jsx(E.Fragment, { children: e }) : E.jsx(fU, { initialNodes: t, initialEdges: n, defaultNodes: r, defaultEdges: o, initialWidth: i, initialHeight: s, fitView: u, nodeOrigin: c, nodeExtent: d, children: e });
}
const hU = {
  width: "100%",
  height: "100%",
  overflow: "hidden",
  position: "relative",
  zIndex: 0
};
function mU({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, className: o, nodeTypes: i, edgeTypes: s, onNodeClick: u, onEdgeClick: c, onInit: d, onMove: p, onMoveStart: h, onMoveEnd: g, onConnect: y, onConnectStart: b, onConnectEnd: v, onClickConnectStart: x, onClickConnectEnd: _, onNodeMouseEnter: O, onNodeMouseMove: C, onNodeMouseLeave: N, onNodeContextMenu: R, onNodeDoubleClick: z, onNodeDragStart: j, onNodeDrag: I, onNodeDragStop: $, onNodesDelete: A, onEdgesDelete: V, onDelete: U, onSelectionChange: W, onSelectionDragStart: D, onSelectionDrag: F, onSelectionDragStop: P, onSelectionContextMenu: H, onSelectionStart: Y, onSelectionEnd: q, onBeforeDelete: M, connectionMode: X, connectionLineType: K = Ya.Bezier, connectionLineStyle: L, connectionLineComponent: ee, connectionLineContainerStyle: ae, deleteKeyCode: le = "Backspace", selectionKeyCode: me = "Shift", selectionOnDrag: se = !1, selectionMode: he = Td.Full, panActivationKeyCode: _e = "Space", multiSelectionKeyCode: Se = Jh() ? "Meta" : "Control", zoomActivationKeyCode: Ee = Jh() ? "Meta" : "Control", snapToGrid: Ie, snapGrid: $e, onlyRenderVisibleElements: ct = !1, selectNodesOnDrag: $t, nodesDraggable: ft, nodesConnectable: br, nodesFocusable: on, nodeOrigin: vn = _1, edgesFocusable: De, edgesReconnectable: qr, elementsSelectable: Xr = !0, defaultViewport: qn = $B, minZoom: Wr = 0.5, maxZoom: ce = 2, translateExtent: ye = zd, preventScrolling: Ae = !0, nodeExtent: Ve, defaultMarkerColor: ut = "#b1b1b7", zoomOnScroll: bn = !0, zoomOnPinch: or = !0, panOnScroll: Xt = !1, panOnScrollSpeed: ir = 0.5, panOnScrollMode: kn = Xs.Free, zoomOnDoubleClick: Wt = !0, panOnDrag: Dn = !0, onPaneClick: Xn, onPaneMouseEnter: fs, onPaneMouseMove: da, onPaneMouseLeave: wr, onPaneScroll: En, onPaneContextMenu: mo, paneClickDistance: Lo = 0, nodeClickDistance: xr = 0, children: ps, onReconnect: Io, onReconnectStart: Vo, onReconnectEnd: fl, onEdgeContextMenu: Sr, onEdgeDoubleClick: an, onEdgeMouseEnter: wn, onEdgeMouseMove: go, onEdgeMouseLeave: fa, reconnectRadius: pa = 10, onNodesChange: Bo, onEdgesChange: pl, noDragClassName: Pn = "nodrag", noWheelClassName: hs = "nowheel", noPanClassName: Cn = "nopan", fitView: Gr, fitViewOptions: wi, connectOnClick: _r, attributionPosition: Lt, proOptions: ms, defaultEdgeOptions: gs, elevateNodesOnSelect: Zr, elevateEdgesOnSelect: ar, disableKeyboardA11y: ys = !1, autoPanOnConnect: hl, autoPanOnNodeDrag: Q, autoPanSpeed: ie, connectionRadius: xe, isValidConnection: Ce, onError: Je, style: Ye, id: St, nodeDragThreshold: bt, viewport: On, onViewportChange: Tt, width: Yt, height: Wn, colorMode: It = "light", debug: sn, onScroll: Gn, ...kr }, xi) {
  const Zn = St || "1", Si = WB(It), An = S.useCallback((ha) => {
    ha.currentTarget.scrollTo({ top: 0, left: 0, behavior: "instant" }), Gn?.(ha);
  }, [Gn]);
  return E.jsx("div", { "data-testid": "rf__wrapper", ...kr, onScroll: An, style: { ...Ye, ...hU }, ref: xi, className: mn(["react-flow", o, Si]), id: St, children: E.jsxs(pU, { nodes: e, edges: t, width: Yt, height: Wn, fitView: Gr, nodeOrigin: vn, nodeExtent: Ve, children: [E.jsx(cU, { onInit: d, onNodeClick: u, onEdgeClick: c, onNodeMouseEnter: O, onNodeMouseMove: C, onNodeMouseLeave: N, onNodeContextMenu: R, onNodeDoubleClick: z, nodeTypes: i, edgeTypes: s, connectionLineType: K, connectionLineStyle: L, connectionLineComponent: ee, connectionLineContainerStyle: ae, selectionKeyCode: me, selectionOnDrag: se, selectionMode: he, deleteKeyCode: le, multiSelectionKeyCode: Se, panActivationKeyCode: _e, zoomActivationKeyCode: Ee, onlyRenderVisibleElements: ct, defaultViewport: qn, translateExtent: ye, minZoom: Wr, maxZoom: ce, preventScrolling: Ae, zoomOnScroll: bn, zoomOnPinch: or, zoomOnDoubleClick: Wt, panOnScroll: Xt, panOnScrollSpeed: ir, panOnScrollMode: kn, panOnDrag: Dn, onPaneClick: Xn, onPaneMouseEnter: fs, onPaneMouseMove: da, onPaneMouseLeave: wr, onPaneScroll: En, onPaneContextMenu: mo, paneClickDistance: Lo, nodeClickDistance: xr, onSelectionContextMenu: H, onSelectionStart: Y, onSelectionEnd: q, onReconnect: Io, onReconnectStart: Vo, onReconnectEnd: fl, onEdgeContextMenu: Sr, onEdgeDoubleClick: an, onEdgeMouseEnter: wn, onEdgeMouseMove: go, onEdgeMouseLeave: fa, reconnectRadius: pa, defaultMarkerColor: ut, noDragClassName: Pn, noWheelClassName: hs, noPanClassName: Cn, rfId: Zn, disableKeyboardA11y: ys, nodeExtent: Ve, viewport: On, onViewportChange: Tt }), E.jsx(XB, { nodes: e, edges: t, defaultNodes: n, defaultEdges: r, onConnect: y, onConnectStart: b, onConnectEnd: v, onClickConnectStart: x, onClickConnectEnd: _, nodesDraggable: ft, nodesConnectable: br, nodesFocusable: on, edgesFocusable: De, edgesReconnectable: qr, elementsSelectable: Xr, elevateNodesOnSelect: Zr, elevateEdgesOnSelect: ar, minZoom: Wr, maxZoom: ce, nodeExtent: Ve, onNodesChange: Bo, onEdgesChange: pl, snapToGrid: Ie, snapGrid: $e, connectionMode: X, translateExtent: ye, connectOnClick: _r, defaultEdgeOptions: gs, fitView: Gr, fitViewOptions: wi, onNodesDelete: A, onEdgesDelete: V, onDelete: U, onNodeDragStart: j, onNodeDrag: I, onNodeDragStop: $, onSelectionDrag: F, onSelectionDragStart: D, onSelectionDragStop: P, onMove: p, onMoveStart: h, onMoveEnd: g, noPanClassName: Cn, nodeOrigin: vn, rfId: Zn, autoPanOnConnect: hl, autoPanOnNodeDrag: Q, autoPanSpeed: ie, onError: Je, connectionRadius: xe, isValidConnection: Ce, selectNodesOnDrag: $t, nodeDragThreshold: bt, onBeforeDelete: M, paneClickDistance: Lo, debug: sn }), E.jsx(HB, { onSelectionChange: W }), ps, E.jsx(IB, { proOptions: ms, position: Lt }), E.jsx(PB, { rfId: Zn, disableKeyboardA11y: ys })] }) });
}
var gU = O1(mU);
const yU = (e) => e.nodes;
function vU() {
  return at(yU, Ft);
}
const bU = (e) => e.edges;
function wU() {
  return at(bU, Ft);
}
function xU({ dimensions: e, lineWidth: t, variant: n, className: r }) {
  return E.jsx("path", { strokeWidth: t, d: `M${e[0] / 2} 0 V${e[1]} M0 ${e[1] / 2} H${e[0]}`, className: mn(["react-flow__background-pattern", n, r]) });
}
function SU({ radius: e, className: t }) {
  return E.jsx("circle", { cx: e, cy: e, r: e, className: mn(["react-flow__background-pattern", "dots", t]) });
}
var Ka;
(function(e) {
  e.Lines = "lines", e.Dots = "dots", e.Cross = "cross";
})(Ka || (Ka = {}));
const _U = {
  [Ka.Dots]: 1,
  [Ka.Lines]: 1,
  [Ka.Cross]: 6
}, kU = (e) => ({ transform: e.transform, patternId: `pattern-${e.rfId}` });
function K1({
  id: e,
  variant: t = Ka.Dots,
  // only used for dots and cross
  gap: n = 20,
  // only used for lines and cross
  size: r,
  lineWidth: o = 1,
  offset: i = 0,
  color: s,
  bgColor: u,
  style: c,
  className: d,
  patternClassName: p
}) {
  const h = S.useRef(null), { transform: g, patternId: y } = at(kU, Ft), b = r || _U[t], v = t === Ka.Dots, x = t === Ka.Cross, _ = Array.isArray(n) ? n : [n, n], O = [_[0] * g[2] || 1, _[1] * g[2] || 1], C = b * g[2], N = Array.isArray(i) ? i : [i, i], R = x ? [C, C] : O, z = [
    N[0] * g[2] || 1 + R[0] / 2,
    N[1] * g[2] || 1 + R[1] / 2
  ], j = `${y}${e || ""}`;
  return E.jsxs("svg", { className: mn(["react-flow__background", d]), style: {
    ...c,
    ...Xm,
    "--xy-background-color-props": u,
    "--xy-background-pattern-color-props": s
  }, ref: h, "data-testid": "rf__background", children: [E.jsx("pattern", { id: j, x: g[0] % O[0], y: g[1] % O[1], width: O[0], height: O[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${z[0]},-${z[1]})`, children: v ? E.jsx(SU, { radius: C / 2, className: p }) : E.jsx(xU, { dimensions: R, lineWidth: o, variant: t, className: p }) }), E.jsx("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${j})` })] });
}
K1.displayName = "Background";
const EU = S.memo(K1);
function CU() {
  return E.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: E.jsx("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" }) });
}
function OU() {
  return E.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5", children: E.jsx("path", { d: "M0 0h32v4.2H0z" }) });
}
function AU() {
  return E.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30", children: E.jsx("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" }) });
}
function NU() {
  return E.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: E.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" }) });
}
function MU() {
  return E.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: E.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" }) });
}
function Xp({ children: e, className: t, ...n }) {
  return E.jsx("button", { type: "button", className: mn(["react-flow__controls-button", t]), ...n, children: e });
}
const RU = (e) => ({
  isInteractive: e.nodesDraggable || e.nodesConnectable || e.elementsSelectable,
  minZoomReached: e.transform[2] <= e.minZoom,
  maxZoomReached: e.transform[2] >= e.maxZoom
});
function Q1({ style: e, showZoom: t = !0, showFitView: n = !0, showInteractive: r = !0, fitViewOptions: o, onZoomIn: i, onZoomOut: s, onFitView: u, onInteractiveChange: c, className: d, children: p, position: h = "bottom-left", orientation: g = "vertical", "aria-label": y = "React Flow controls" }) {
  const b = Ht(), { isInteractive: v, minZoomReached: x, maxZoomReached: _ } = at(RU, Ft), { zoomIn: O, zoomOut: C, fitView: N } = df(), R = () => {
    O(), i?.();
  }, z = () => {
    C(), s?.();
  }, j = () => {
    N(o), u?.();
  }, I = () => {
    b.setState({
      nodesDraggable: !v,
      nodesConnectable: !v,
      elementsSelectable: !v
    }), c?.(!v);
  }, $ = g === "horizontal" ? "horizontal" : "vertical";
  return E.jsxs(qm, { className: mn(["react-flow__controls", $, d]), position: h, style: e, "data-testid": "rf__controls", "aria-label": y, children: [t && E.jsxs(E.Fragment, { children: [E.jsx(Xp, { onClick: R, className: "react-flow__controls-zoomin", title: "zoom in", "aria-label": "zoom in", disabled: _, children: E.jsx(CU, {}) }), E.jsx(Xp, { onClick: z, className: "react-flow__controls-zoomout", title: "zoom out", "aria-label": "zoom out", disabled: x, children: E.jsx(OU, {}) })] }), n && E.jsx(Xp, { className: "react-flow__controls-fitview", onClick: j, title: "fit view", "aria-label": "fit view", children: E.jsx(AU, {}) }), r && E.jsx(Xp, { className: "react-flow__controls-interactive", onClick: I, title: "toggle interactivity", "aria-label": "toggle interactivity", children: v ? E.jsx(MU, {}) : E.jsx(NU, {}) }), p] });
}
Q1.displayName = "Controls";
S.memo(Q1);
function jU({ id: e, x: t, y: n, width: r, height: o, style: i, color: s, strokeColor: u, strokeWidth: c, className: d, borderRadius: p, shapeRendering: h, selected: g, onClick: y }) {
  const { background: b, backgroundColor: v } = i || {}, x = s || b || v;
  return E.jsx("rect", { className: mn(["react-flow__minimap-node", { selected: g }, d]), x: t, y: n, rx: p, ry: p, width: r, height: o, style: {
    fill: x,
    stroke: u,
    strokeWidth: c
  }, shapeRendering: h, onClick: y ? (_) => y(_, e) : void 0 });
}
const zU = S.memo(jU), TU = (e) => e.nodes.map((t) => t.id), ub = (e) => e instanceof Function ? e : () => e;
function DU({
  nodeStrokeColor: e,
  nodeColor: t,
  nodeClassName: n = "",
  nodeBorderRadius: r = 5,
  nodeStrokeWidth: o,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: i = zU,
  onClick: s
}) {
  const u = at(TU, Ft), c = ub(t), d = ub(e), p = ub(n), h = typeof window > "u" || window.chrome ? "crispEdges" : "geometricPrecision";
  return E.jsx(E.Fragment, { children: u.map((g) => (
    /*
     * The split of responsibilities between MiniMapNodes and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For more details, see a similar commit in `NodeRenderer/index.tsx`.
     */
    E.jsx(LU, { id: g, nodeColorFunc: c, nodeStrokeColorFunc: d, nodeClassNameFunc: p, nodeBorderRadius: r, nodeStrokeWidth: o, NodeComponent: i, onClick: s, shapeRendering: h }, g)
  )) });
}
function PU({ id: e, nodeColorFunc: t, nodeStrokeColorFunc: n, nodeClassNameFunc: r, nodeBorderRadius: o, nodeStrokeWidth: i, shapeRendering: s, NodeComponent: u, onClick: c }) {
  const { node: d, x: p, y: h, width: g, height: y } = at((b) => {
    const { internals: v } = b.nodeLookup.get(e), x = v.userNode, { x: _, y: O } = v.positionAbsolute, { width: C, height: N } = ra(x);
    return {
      node: x,
      x: _,
      y: O,
      width: C,
      height: N
    };
  }, Ft);
  return !d || d.hidden || !t1(d) ? null : E.jsx(u, { x: p, y: h, width: g, height: y, style: d.style, selected: !!d.selected, className: r(d), color: t(d), borderRadius: o, strokeColor: n(d), strokeWidth: i, shapeRendering: s, onClick: c, id: d.id });
}
const LU = S.memo(PU);
var IU = S.memo(DU);
const VU = 200, BU = 150, FU = (e) => !e.hidden, UU = (e) => {
  const t = {
    x: -e.transform[0] / e.transform[2],
    y: -e.transform[1] / e.transform[2],
    width: e.width / e.transform[2],
    height: e.height / e.transform[2]
  };
  return {
    viewBB: t,
    boundingRect: e.nodeLookup.size > 0 ? e1(uf(e.nodeLookup, { filter: FU }), t) : t,
    rfId: e.rfId,
    panZoom: e.panZoom,
    translateExtent: e.translateExtent,
    flowWidth: e.width,
    flowHeight: e.height
  };
}, HU = "react-flow__minimap-desc";
function J1({
  style: e,
  className: t,
  nodeStrokeColor: n,
  nodeColor: r,
  nodeClassName: o = "",
  nodeBorderRadius: i = 5,
  nodeStrokeWidth: s,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: u,
  bgColor: c,
  maskColor: d,
  maskStrokeColor: p,
  maskStrokeWidth: h,
  position: g = "bottom-right",
  onClick: y,
  onNodeClick: b,
  pannable: v = !1,
  zoomable: x = !1,
  ariaLabel: _ = "React Flow mini map",
  inversePan: O,
  zoomStep: C = 10,
  offsetScale: N = 5
}) {
  const R = Ht(), z = S.useRef(null), { boundingRect: j, viewBB: I, rfId: $, panZoom: A, translateExtent: V, flowWidth: U, flowHeight: W } = at(UU, Ft), D = e?.width ?? VU, F = e?.height ?? BU, P = j.width / D, H = j.height / F, Y = Math.max(P, H), q = Y * D, M = Y * F, X = N * Y, K = j.x - (q - j.width) / 2 - X, L = j.y - (M - j.height) / 2 - X, ee = q + X * 2, ae = M + X * 2, le = `${HU}-${$}`, me = S.useRef(0), se = S.useRef();
  me.current = Y, S.useEffect(() => {
    if (z.current && A)
      return se.current = dB({
        domNode: z.current,
        panZoom: A,
        getTransform: () => R.getState().transform,
        getViewScale: () => me.current
      }), () => {
        var Se;
        (Se = se.current) == null || Se.destroy();
      };
  }, [A]), S.useEffect(() => {
    var Se;
    (Se = se.current) == null || Se.update({
      translateExtent: V,
      width: U,
      height: W,
      inversePan: O,
      pannable: v,
      zoomStep: C,
      zoomable: x
    });
  }, [v, x, O, C, V, U, W]);
  const he = y ? (Se) => {
    var Ee;
    const [Ie, $e] = ((Ee = se.current) == null ? void 0 : Ee.pointer(Se)) || [0, 0];
    y(Se, { x: Ie, y: $e });
  } : void 0, _e = b ? S.useCallback((Se, Ee) => {
    const Ie = R.getState().nodeLookup.get(Ee).internals.userNode;
    b(Se, Ie);
  }, []) : void 0;
  return E.jsx(qm, { position: g, style: {
    ...e,
    "--xy-minimap-background-color-props": typeof c == "string" ? c : void 0,
    "--xy-minimap-mask-background-color-props": typeof d == "string" ? d : void 0,
    "--xy-minimap-mask-stroke-color-props": typeof p == "string" ? p : void 0,
    "--xy-minimap-mask-stroke-width-props": typeof h == "number" ? h * Y : void 0,
    "--xy-minimap-node-background-color-props": typeof r == "string" ? r : void 0,
    "--xy-minimap-node-stroke-color-props": typeof n == "string" ? n : void 0,
    "--xy-minimap-node-stroke-width-props": typeof s == "number" ? s : void 0
  }, className: mn(["react-flow__minimap", t]), "data-testid": "rf__minimap", children: E.jsxs("svg", { width: D, height: F, viewBox: `${K} ${L} ${ee} ${ae}`, className: "react-flow__minimap-svg", role: "img", "aria-labelledby": le, ref: z, onClick: he, children: [_ && E.jsx("title", { id: le, children: _ }), E.jsx(IU, { onClick: _e, nodeColor: r, nodeStrokeColor: n, nodeBorderRadius: i, nodeClassName: o, nodeStrokeWidth: s, nodeComponent: u }), E.jsx("path", { className: "react-flow__minimap-mask", d: `M${K - X},${L - X}h${ee + X * 2}v${ae + X * 2}h${-ee - X * 2}z
        M${I.x},${I.y}h${I.width}v${I.height}h${-I.width}z`, fillRule: "evenodd", pointerEvents: "none" })] }) });
}
J1.displayName = "MiniMap";
const $U = S.memo(J1);
function YU({ nodeId: e, position: t, variant: n = gd.Handle, className: r, style: o = {}, children: i, color: s, minWidth: u = 10, minHeight: c = 10, maxWidth: d = Number.MAX_VALUE, maxHeight: p = Number.MAX_VALUE, keepAspectRatio: h = !1, shouldResize: g, onResizeStart: y, onResize: b, onResizeEnd: v }) {
  const x = R1(), _ = typeof e == "string" ? e : x, O = Ht(), C = S.useRef(null), N = n === gd.Line ? "right" : "bottom-right", R = t ?? N, z = S.useRef(null);
  S.useEffect(() => {
    if (!(!C.current || !_))
      return z.current || (z.current = CB({
        domNode: C.current,
        nodeId: _,
        getStoreItems: () => {
          const { nodeLookup: A, transform: V, snapGrid: U, snapToGrid: W, nodeOrigin: D, domNode: F } = O.getState();
          return {
            nodeLookup: A,
            transform: V,
            snapGrid: U,
            snapToGrid: W,
            nodeOrigin: D,
            paneDomNode: F
          };
        },
        onChange: (A, V) => {
          const { triggerNodeChanges: U, nodeLookup: W, parentLookup: D, nodeOrigin: F } = O.getState(), P = [], H = { x: A.x, y: A.y }, Y = W.get(_);
          if (Y && Y.expandParent && Y.parentId) {
            const q = Y.origin ?? F, M = A.width ?? Y.measured.width ?? 0, X = A.height ?? Y.measured.height ?? 0, K = {
              id: Y.id,
              parentId: Y.parentId,
              rect: {
                width: M,
                height: X,
                ...n1({
                  x: A.x ?? Y.position.x,
                  y: A.y ?? Y.position.y
                }, { width: M, height: X }, Y.parentId, W, q)
              }
            }, L = DS([K], W, D, F);
            P.push(...L), H.x = A.x ? Math.max(q[0] * M, A.x) : void 0, H.y = A.y ? Math.max(q[1] * X, A.y) : void 0;
          }
          if (H.x !== void 0 && H.y !== void 0) {
            const q = {
              id: _,
              type: "position",
              position: { ...H }
            };
            P.push(q);
          }
          if (A.width !== void 0 && A.height !== void 0) {
            const q = {
              id: _,
              type: "dimensions",
              resizing: !0,
              setAttributes: !0,
              dimensions: {
                width: A.width,
                height: A.height
              }
            };
            P.push(q);
          }
          for (const q of V) {
            const M = {
              ...q,
              type: "position"
            };
            P.push(M);
          }
          U(P);
        },
        onEnd: ({ width: A, height: V }) => {
          const U = {
            id: _,
            type: "dimensions",
            resizing: !1,
            dimensions: {
              width: A,
              height: V
            }
          };
          O.getState().triggerNodeChanges([U]);
        }
      })), z.current.update({
        controlPosition: R,
        boundaries: {
          minWidth: u,
          minHeight: c,
          maxWidth: d,
          maxHeight: p
        },
        keepAspectRatio: h,
        onResizeStart: y,
        onResize: b,
        onResizeEnd: v,
        shouldResize: g
      }), () => {
        var A;
        (A = z.current) == null || A.destroy();
      };
  }, [
    R,
    u,
    c,
    d,
    p,
    h,
    y,
    b,
    v,
    g
  ]);
  const j = R.split("-"), I = n === gd.Line ? "borderColor" : "backgroundColor", $ = s ? { ...o, [I]: s } : o;
  return E.jsx("div", { className: mn(["react-flow__resize-control", "nodrag", ...j, n, r]), ref: C, style: $, children: i });
}
S.memo(YU);
const qU = ({
  on_node_change: e,
  on_edge_change: t,
  on_connect: n
}) => {
  const r = e || ((i) => {
  }), o = n || ((i) => {
  });
  return Jn((i, s) => ({
    nodes: [],
    edges: [],
    onNodesChange: (u) => {
      i({
        nodes: E1(u, s().nodes)
      }), r(u);
    },
    onEdgesChange: (u) => {
      i({
        edges: C1(u, s().edges)
      });
    },
    onConnect: (u) => {
      u.source == null || u.target == null || o(u);
    }
  }));
}, kO = ({
  src_nid: e,
  src_ioid: t,
  trg_nid: n,
  trg_ioid: r
}) => [`${e}:${t}`, `${n}:${r}`].sort().join("--");
function XU(e) {
  console.error("Unhandled case: " + e);
}
const WU = (e) => {
  if ((e.v ? Number(e.v) : 0) > 0) throw new Error("Plugin version is too new");
  return e;
};
class GU {
  constructor(t) {
    this.iostore = t;
  }
  get connected() {
    return this.iostore.getState().connected;
  }
  set connected(t) {
    this.iostore.setState({ connected: t });
  }
  get does_trigger() {
    return this.iostore.getState().does_trigger;
  }
  set does_trigger(t) {
    this.iostore.setState({ does_trigger: t });
  }
  get full_id() {
    return this.iostore.getState().full_id;
  }
  set full_id(t) {
    this.iostore.setState({ full_id: t });
  }
  get id() {
    return this.iostore.getState().id;
  }
  set id(t) {
    this.iostore.setState({ id: t });
  }
  get is_input() {
    return this.iostore.getState().is_input;
  }
  set is_input(t) {
    this.iostore.setState({ is_input: t });
  }
  get name() {
    return this.iostore.getState().name;
  }
  set name(t) {
    this.iostore.setState({ name: t });
  }
  get node() {
    return this.iostore.getState().node;
  }
  set node(t) {
    this.iostore.setState({ node: t });
  }
  get type() {
    return this.iostore.getState().type;
  }
  set type(t) {
    this.iostore.setState({ type: t });
  }
  get value() {
    return this.iostore.valuestore.getState().preview;
  }
  set value(t) {
    this.iostore.updateValueStore({ preview: t });
  }
  get fullvalue() {
    return this.iostore.valuestore.getState().full;
  }
  set fullvalue(t) {
    this.iostore.updateValueStore({ full: t });
  }
  get render_options() {
    return this.iostore.getState().render_options;
  }
  set render_options(t) {
    this.iostore.setState({ render_options: t });
  }
  get hidden() {
    return this.iostore.getState().hidden;
  }
  set hidden(t) {
    this.iostore.setState({ hidden: t });
  }
  get try_get_full_value() {
    return this.iostore.getState().try_get_full_value;
  }
  get set_hidden() {
    return this.iostore.getState().set_hidden;
  }
}
const Xl = (e) => (t) => {
  const { iostore: n, ...r } = t, o = new GU(n);
  return e({ ...r, io: o });
}, ZU = (e) => {
  const t = e.v ? Number(e.v) : 0;
  if (t > 1) throw new Error("Plugin version is too new");
  if (t === 1) return e;
  const n = WU(e);
  return { ...n, renderpluginfactory: (r) => {
    var o;
    const i = ((o = n.renderpluginfactory) == null ? void 0 : o.call(n, r)) || {}, s = n.RendererPlugin || {}, u = Object.keys({ ...s, ...i }), c = {};
    for (const d of u)
      switch (d) {
        case "input_renderers":
          const p = {};
          for (const [x, _] of Object.entries(s.input_renderers || {}))
            _ !== void 0 && (p[x] = Xl(_));
          c.input_renderers = p;
          break;
        case "output_renderers":
          const h = {};
          for (const [x, _] of Object.entries(
            s.output_renderers || {}
          ))
            _ !== void 0 && (h[x] = Xl(_));
          c.output_renderers = h;
          break;
        case "handle_preview_renderers":
          const g = {};
          for (const [x, _] of Object.entries(
            s.handle_preview_renderers || {}
          ))
            _ !== void 0 && (g[x] = Xl(_));
          c.handle_preview_renderers = g;
          break;
        case "data_overlay_renderers":
          const y = {};
          for (const [x, _] of Object.entries(
            s.data_overlay_renderers || {}
          ))
            _ !== void 0 && (y[x] = Xl(_));
          c.data_overlay_renderers = y;
          break;
        case "data_preview_renderers":
          const b = {};
          for (const [x, _] of Object.entries(
            s.data_preview_renderers || {}
          ))
            _ !== void 0 && (b[x] = Xl(_));
          c.data_preview_renderers = b;
          break;
        case "data_view_renderers":
          const v = {};
          for (const [x, _] of Object.entries(
            s.data_view_renderers || {}
          ))
            _ !== void 0 && (v[x] = Xl(_));
          c.data_view_renderers = v;
          break;
        default:
          XU(d);
      }
    return c;
  }, v: 1 };
}, KU = (e) => ZU(e), hr = {
  DEBUG: 0,
  INFO: 10,
  WARN: 20,
  ERROR: 30
}, QU = hr.INFO, EO = (e) => typeof e == "string" ? e : e === hr.DEBUG ? "DEBUG" : e === hr.INFO ? "INFO" : e === hr.WARN ? "WARN" : e === hr.ERROR ? "ERROR" : "UNKNOWN";
function JU() {
  const e = [];
  return function(t, n) {
    if (typeof n != "object" || n === null)
      return n;
    for (; e.length > 0 && e.at(-1) !== this; )
      e.pop();
    return e.includes(n) ? "[Circular]" : (e.push(n), n);
  };
}
const eH = (e) => {
  if (typeof e == "number") return e;
  const t = e.toLowerCase();
  if (t === "debug") return hr.DEBUG;
  if (t === "info") return hr.INFO;
  if (t === "warn" || t === "warning") return hr.WARN;
  if (t === "error") return hr.ERROR;
  throw new Error(`Unknown log level: ${e}`);
};
class eM {
  constructor(t, n = hr.INFO) {
    this.name = t, this.level = eH(n), this._level_name = EO(n);
  }
  set_level(t) {
    this.level = t, this._level_name = EO(t);
  }
  _fomat_message(t, ...n) {
    return `[${this.name}] ${this._level_name}: ${t} ${n.map((r) => JSON.stringify(r, JU())).join(" ")}`;
  }
  debug(t, ...n) {
    this.level <= hr.DEBUG && console.debug(this._fomat_message(t, ...n));
  }
  info(t, ...n) {
    this.level <= hr.INFO && console.info(this._fomat_message(t, ...n));
  }
  warn(t, ...n) {
    this.level <= hr.WARN && console.warn(this._fomat_message(t, ...n));
  }
  error(t, ...n) {
    this.level <= hr.ERROR && console.error(this._fomat_message(t, ...n));
  }
}
const qw = !1, tH = (e, t) => {
  const n = e.properties || {};
  n["frontend:size"] || (n["frontend:size"] = [200, 100]);
  const r = n["frontend:pos"];
  if (!r || r.length !== 2 || isNaN(r[0]) || r[0] === null || isNaN(r[1]) || r[1] === null)
    if (!t || !t.rf_instance || t.reactflowRef === null)
      n["frontend:pos"] = [0, 0];
    else {
      const o = t.reactflowRef.getBoundingClientRect(), i = o.left + o.width / 2, s = o.top + o.height / 2, u = t.rf_instance.screenToFlowPosition({
        x: i,
        y: s
      });
      n["frontend:pos"] = [
        u.x - n["frontend:size"][0] / 2,
        u.y - n["frontend:size"][0] / 2
      ];
    }
  n["frontend:collapsed"] || (n["frontend:collapsed"] = !1), e.properties = n;
}, nH = (e, t) => {
  const n = e.getState();
  if (tH(n, t), n.id === void 0)
    throw new Error("Node must have an id");
  const r = {
    nodestore: e
  };
  return {
    position: {
      x: n.properties["frontend:pos"][0],
      y: n.properties["frontend:pos"][1]
    },
    data: r,
    type: "default",
    ...n
  };
}, tM = (e) => {
  const t = {
    ...e
  }, n = (v) => {
    var x;
    const _ = d.getState();
    if (v.from_remote) {
      let O = p.get_node(v.node.id, !1);
      if (O)
        return;
      if (!O)
        try {
          O = t8(b, v.node), p.nodesstates.set(v.node.id, O);
        } catch (R) {
          b.logger.error(`Failed to create node store ${R}`);
          return;
        }
      const C = O.getState();
      b.logger.info("Add node", C.id, C.name);
      const N = [..._.nodes, nH(O, b)];
      d.setState({ nodes: N });
      for (const R in v.node.io) {
        const z = v.node.io[R].id;
        z !== void 0 && ((x = b.worker) == null || x.get_io_value({ nid: v.node.id, ioid: z }));
      }
      setTimeout(() => {
        var R;
        (R = b.worker) == null || R.call_hooks("node_added", { node: C.id });
      }, 0);
    }
  }, r = (v) => {
    if (v.node.in_trigger && (v.node.error = void 0), v.from_remote) {
      const x = p.get_node(v.id, !1);
      if (!x) {
        console.error("Node not found to update", v.id);
        return;
      }
      x.update(v.node);
    } else
      b.worker && b.worker.locally_update_node(v);
  }, o = (v) => {
    var x;
    b.logger.info("Deleting node", v.id), v.from_remote ? d.getState().onNodesChange([
      {
        type: "remove",
        id: v.id
      }
    ]) : (x = b.worker) == null || x.remove_node(v.id);
  }, i = (v) => {
    b.logger.error("Error", v), u({
      type: "update",
      id: v.id,
      node: {
        in_trigger: !1,
        error: v.error
      },
      from_remote: !0
    });
  }, s = (v) => {
    var x;
    v.from_remote ? u({
      type: "update",
      id: v.id,
      node: {
        in_trigger: !0,
        error: void 0
      },
      from_remote: !0
    }) : (x = b.worker) == null || x.trigger_node(v.id);
  }, u = (v) => {
    switch (v.type) {
      case "add":
        n(v);
        break;
      case "update":
        r(v);
        break;
      case "delete":
        o(v);
        break;
      case "error":
        i(v);
        break;
      case "trigger":
        s(v);
        break;
      default:
        b.logger.error("Unknown node action", v);
    }
  }, c = (v) => {
    var x, _, O, C;
    const N = d.getState();
    switch (v.type) {
      case "add":
        if (v.from_remote) {
          const R = N.edges, z = kO(v);
          if (R.some((I) => I.id === z))
            return;
          const j = {
            id: z,
            source: v.src_nid,
            target: v.trg_nid,
            sourceHandle: v.src_ioid,
            targetHandle: v.trg_ioid,
            className: "funcnodes-edge animated"
          };
          b.logger.info("Adding edge", j), d.setState({ edges: [...R, j] }), (x = b.worker) == null || x.get_remote_node_state(v.src_nid), (_ = b.worker) == null || _.get_remote_node_state(v.trg_nid);
        }
        break;
      case "delete":
        if (v.from_remote) {
          const R = N.edges, z = kO(v);
          b.logger.info("Deleting edge", z);
          const j = R.filter((I) => I.id !== z);
          d.setState({ edges: j }), (O = b.worker) == null || O.get_remote_node_state(v.src_nid), (C = b.worker) == null || C.get_remote_node_state(v.trg_nid);
        }
        break;
      default:
        b.logger.error("Unknown edge action", v);
    }
  }, d = qU({
    on_node_change: (v) => {
      for (const x of v)
        switch (x.type) {
          case "position":
            x.position && u({
              type: "update",
              id: x.id,
              node: {
                properties: {
                  "frontend:pos": [x.position.x, x.position.y]
                }
              },
              from_remote: !1
            });
            break;
          case "dimensions":
            x.dimensions && u({
              type: "update",
              id: x.id,
              node: {
                properties: {
                  "frontend:size": [
                    x.dimensions.width,
                    x.dimensions.height
                  ]
                }
              },
              from_remote: !1
            });
            break;
        }
    },
    on_edge_change: (v) => {
    },
    on_connect: (v) => {
      v.source === null || v.target === null || v.sourceHandle === null || v.targetHandle === null || !b.worker || b.worker.add_edge({
        src_nid: v.source,
        src_ioid: v.sourceHandle,
        trg_nid: v.target,
        trg_ioid: v.targetHandle,
        replace: !0
      });
    }
  }), p = F9({}), h = B9(), g = () => {
    var v, x;
    (v = b.worker) == null || v.disconnect(), b.set_worker(void 0), (x = b.workermanager) == null || x.setWorker(void 0), b.lib.libstate.getState().set({ lib: { shelves: [] }, external_worker: [] }), b.nodespace.nodesstates.clear(), b.useReactFlowStore.setState({ nodes: [], edges: [] }), b.auto_progress();
  }, y = (v) => {
    var x;
    if (!b.rf_instance)
      return;
    v = Array.isArray(v) ? v : [v];
    const _ = b.useReactFlowStore.getState().nodes.filter((O) => v.includes(O.id));
    _.length > 0 && ((x = b.rf_instance) == null || x.fitView({ padding: 0.2, nodes: _ }));
  }, b = {
    local_settings: Jn((v, x) => ({
      view_settings: {},
      update_view_settings: (_) => {
        const O = b.local_settings.getState().view_settings, { new_obj: C, change: N } = No(O, _);
        N && b.local_settings.setState((R) => ({
          ...R,
          view_settings: C
        }));
      }
    })),
    local_state: Jn((v, x) => ({
      selected_nodes: [],
      selected_edges: [],
      funcnodescontainerRef: null
    })),
    options: t,
    lib: h,
    workermanager: void 0,
    workers: Jn((v, x) => ({})),
    workerstate: Jn((v, x) => ({
      is_open: !1
    })),
    render_options: Jn((v, x) => ({})),
    progress_state: Jn((v, x) => ({
      message: "please select worker",
      status: "info",
      progress: 0,
      blocking: !1
    })),
    update_render_options: (v) => {
      const x = b.render_options.getState(), { new_obj: _, change: O } = No(x, v);
      O && b.render_options.setState(_);
    },
    worker: void 0,
    _unsubscribeFromWorker: void 0,
    set_worker: (v) => {
      v !== b.worker && (b._unsubscribeFromWorker && (b._unsubscribeFromWorker(), b._unsubscribeFromWorker = void 0), v && (b._unsubscribeFromWorker = v.state.subscribe((x) => {
        b.workerstate.setState(x);
      }), b.workerstate.setState(v.state.getState())), b.worker = v, v?.set_zustand(b));
    },
    nodespace: p,
    useReactFlowStore: d,
    on_node_action: u,
    on_edge_action: c,
    reactflowRef: null,
    clear_all: g,
    center_node: y,
    center_all: () => {
      var v;
      console.log("center all", b.rf_instance), (v = b.rf_instance) == null || v.fitView({ padding: 0.2 });
    },
    set_progress: (v) => {
      if (v.message === "")
        return b.auto_progress();
      const x = b.progress_state.getState(), { new_obj: _, change: O } = No(
        x,
        v
      );
      O && b.progress_state.setState(_);
    },
    auto_progress: () => {
      if (b.workermanager !== void 0 && !b.workermanager.open)
        return b.set_progress({
          progress: 0,
          message: "connecting to worker manager",
          status: "error",
          blocking: !1
        });
      if (b.worker === void 0)
        return b.set_progress({
          progress: 0,
          message: "please select worker",
          status: "error",
          blocking: !1
        });
      if (!b.worker.is_open)
        return b.set_progress({
          progress: 0,
          message: "connecting to worker",
          status: "info",
          blocking: !0
        });
      b.set_progress({
        progress: 1,
        message: "running",
        status: "info",
        blocking: !1
      });
    },
    plugins: Jn((v, x) => ({})),
    add_plugin: (v, x) => {
      if (x === void 0) return;
      const _ = KU(x);
      b.plugins.setState((O) => ({ ...O, [v]: _ }));
    },
    dev_settings: {
      debug: !0
    },
    logger: new eM("fn", QU)
  };
  return b;
};
function nM(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: rH } = Object.prototype, { getPrototypeOf: LS } = Object, Wm = /* @__PURE__ */ ((e) => (t) => {
  const n = rH.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Do = (e) => (e = e.toLowerCase(), (t) => Wm(t) === e), Gm = (e) => (t) => typeof t === e, { isArray: Bu } = Array, Id = Gm("undefined");
function oH(e) {
  return e !== null && !Id(e) && e.constructor !== null && !Id(e.constructor) && Ir(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const rM = Do("ArrayBuffer");
function iH(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && rM(e.buffer), t;
}
const aH = Gm("string"), Ir = Gm("function"), oM = Gm("number"), Zm = (e) => e !== null && typeof e == "object", sH = (e) => e === !0 || e === !1, Ch = (e) => {
  if (Wm(e) !== "object")
    return !1;
  const t = LS(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, lH = Do("Date"), uH = Do("File"), cH = Do("Blob"), dH = Do("FileList"), fH = (e) => Zm(e) && Ir(e.pipe), pH = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || Ir(e.append) && ((t = Wm(e)) === "formdata" || // detect form-data instance
  t === "object" && Ir(e.toString) && e.toString() === "[object FormData]"));
}, hH = Do("URLSearchParams"), [mH, gH, yH, vH] = ["ReadableStream", "Request", "Response", "Headers"].map(Do), bH = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function pf(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, o;
  if (typeof e != "object" && (e = [e]), Bu(e))
    for (r = 0, o = e.length; r < o; r++)
      t.call(null, e[r], r, e);
  else {
    const i = n ? Object.getOwnPropertyNames(e) : Object.keys(e), s = i.length;
    let u;
    for (r = 0; r < s; r++)
      u = i[r], t.call(null, e[u], u, e);
  }
}
function iM(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, o;
  for (; r-- > 0; )
    if (o = n[r], t === o.toLowerCase())
      return o;
  return null;
}
const Fs = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : jw, aM = (e) => !Id(e) && e !== Fs;
function Xw() {
  const { caseless: e } = aM(this) && this || {}, t = {}, n = (r, o) => {
    const i = e && iM(t, o) || o;
    Ch(t[i]) && Ch(r) ? t[i] = Xw(t[i], r) : Ch(r) ? t[i] = Xw({}, r) : Bu(r) ? t[i] = r.slice() : t[i] = r;
  };
  for (let r = 0, o = arguments.length; r < o; r++)
    arguments[r] && pf(arguments[r], n);
  return t;
}
const wH = (e, t, n, { allOwnKeys: r } = {}) => (pf(t, (o, i) => {
  n && Ir(o) ? e[i] = nM(o, n) : e[i] = o;
}, { allOwnKeys: r }), e), xH = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), SH = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, _H = (e, t, n, r) => {
  let o, i, s;
  const u = {};
  if (t = t || {}, e == null) return t;
  do {
    for (o = Object.getOwnPropertyNames(e), i = o.length; i-- > 0; )
      s = o[i], (!r || r(s, e, t)) && !u[s] && (t[s] = e[s], u[s] = !0);
    e = n !== !1 && LS(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, kH = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, EH = (e) => {
  if (!e) return null;
  if (Bu(e)) return e;
  let t = e.length;
  if (!oM(t)) return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, CH = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && LS(Uint8Array)), OH = (e, t) => {
  const n = (e && e[Symbol.iterator]).call(e);
  let r;
  for (; (r = n.next()) && !r.done; ) {
    const o = r.value;
    t.call(e, o[0], o[1]);
  }
}, AH = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, NH = Do("HTMLFormElement"), MH = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(t, n, r) {
    return n.toUpperCase() + r;
  }
), CO = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), RH = Do("RegExp"), sM = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  pf(n, (o, i) => {
    let s;
    (s = t(o, i, e)) !== !1 && (r[i] = s || o);
  }), Object.defineProperties(e, r);
}, jH = (e) => {
  sM(e, (t, n) => {
    if (Ir(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (Ir(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, zH = (e, t) => {
  const n = {}, r = (o) => {
    o.forEach((i) => {
      n[i] = !0;
    });
  };
  return Bu(e) ? r(e) : r(String(e).split(t)), n;
}, TH = () => {
}, DH = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
function PH(e) {
  return !!(e && Ir(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const LH = (e) => {
  const t = new Array(10), n = (r, o) => {
    if (Zm(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        t[o] = r;
        const i = Bu(r) ? [] : {};
        return pf(r, (s, u) => {
          const c = n(s, o + 1);
          !Id(c) && (i[u] = c);
        }), t[o] = void 0, i;
      }
    }
    return r;
  };
  return n(e, 0);
}, IH = Do("AsyncFunction"), VH = (e) => e && (Zm(e) || Ir(e)) && Ir(e.then) && Ir(e.catch), lM = ((e, t) => e ? setImmediate : t ? ((n, r) => (Fs.addEventListener("message", ({ source: o, data: i }) => {
  o === Fs && i === n && r.length && r.shift()();
}, !1), (o) => {
  r.push(o), Fs.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  Ir(Fs.postMessage)
), BH = typeof queueMicrotask < "u" ? queueMicrotask.bind(Fs) : typeof process < "u" && process.nextTick || lM, ue = {
  isArray: Bu,
  isArrayBuffer: rM,
  isBuffer: oH,
  isFormData: pH,
  isArrayBufferView: iH,
  isString: aH,
  isNumber: oM,
  isBoolean: sH,
  isObject: Zm,
  isPlainObject: Ch,
  isReadableStream: mH,
  isRequest: gH,
  isResponse: yH,
  isHeaders: vH,
  isUndefined: Id,
  isDate: lH,
  isFile: uH,
  isBlob: cH,
  isRegExp: RH,
  isFunction: Ir,
  isStream: fH,
  isURLSearchParams: hH,
  isTypedArray: CH,
  isFileList: dH,
  forEach: pf,
  merge: Xw,
  extend: wH,
  trim: bH,
  stripBOM: xH,
  inherits: SH,
  toFlatObject: _H,
  kindOf: Wm,
  kindOfTest: Do,
  endsWith: kH,
  toArray: EH,
  forEachEntry: OH,
  matchAll: AH,
  isHTMLForm: NH,
  hasOwnProperty: CO,
  hasOwnProp: CO,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: sM,
  freezeMethods: jH,
  toObjectSet: zH,
  toCamelCase: MH,
  noop: TH,
  toFiniteNumber: DH,
  findKey: iM,
  global: Fs,
  isContextDefined: aM,
  isSpecCompliantForm: PH,
  toJSONObject: LH,
  isAsyncFn: IH,
  isThenable: VH,
  setImmediate: lM,
  asap: BH
};
function Xe(e, t, n, r, o) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), o && (this.response = o, this.status = o.status ? o.status : null);
}
ue.inherits(Xe, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: ue.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const uM = Xe.prototype, cM = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  cM[e] = { value: e };
});
Object.defineProperties(Xe, cM);
Object.defineProperty(uM, "isAxiosError", { value: !0 });
Xe.from = (e, t, n, r, o, i) => {
  const s = Object.create(uM);
  return ue.toFlatObject(e, s, function(u) {
    return u !== Error.prototype;
  }, (u) => u !== "isAxiosError"), Xe.call(s, e.message, t, n, r, o), s.cause = e, s.name = e.name, i && Object.assign(s, i), s;
};
const FH = null;
function Ww(e) {
  return ue.isPlainObject(e) || ue.isArray(e);
}
function dM(e) {
  return ue.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function OO(e, t, n) {
  return e ? e.concat(t).map(function(r, o) {
    return r = dM(r), !n && o ? "[" + r + "]" : r;
  }).join(n ? "." : "") : t;
}
function UH(e) {
  return ue.isArray(e) && !e.some(Ww);
}
const HH = ue.toFlatObject(ue, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function Km(e, t, n) {
  if (!ue.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = ue.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(y, b) {
    return !ue.isUndefined(b[y]);
  });
  const r = n.metaTokens, o = n.visitor || d, i = n.dots, s = n.indexes, u = (n.Blob || typeof Blob < "u" && Blob) && ue.isSpecCompliantForm(t);
  if (!ue.isFunction(o))
    throw new TypeError("visitor must be a function");
  function c(y) {
    if (y === null) return "";
    if (ue.isDate(y))
      return y.toISOString();
    if (!u && ue.isBlob(y))
      throw new Xe("Blob is not supported. Use a Buffer instead.");
    return ue.isArrayBuffer(y) || ue.isTypedArray(y) ? u && typeof Blob == "function" ? new Blob([y]) : Buffer.from(y) : y;
  }
  function d(y, b, v) {
    let x = y;
    if (y && !v && typeof y == "object") {
      if (ue.endsWith(b, "{}"))
        b = r ? b : b.slice(0, -2), y = JSON.stringify(y);
      else if (ue.isArray(y) && UH(y) || (ue.isFileList(y) || ue.endsWith(b, "[]")) && (x = ue.toArray(y)))
        return b = dM(b), x.forEach(function(_, O) {
          !(ue.isUndefined(_) || _ === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            s === !0 ? OO([b], O, i) : s === null ? b : b + "[]",
            c(_)
          );
        }), !1;
    }
    return Ww(y) ? !0 : (t.append(OO(v, b, i), c(y)), !1);
  }
  const p = [], h = Object.assign(HH, {
    defaultVisitor: d,
    convertValue: c,
    isVisitable: Ww
  });
  function g(y, b) {
    if (!ue.isUndefined(y)) {
      if (p.indexOf(y) !== -1)
        throw Error("Circular reference detected in " + b.join("."));
      p.push(y), ue.forEach(y, function(v, x) {
        (!(ue.isUndefined(v) || v === null) && o.call(
          t,
          v,
          ue.isString(x) ? x.trim() : x,
          b,
          h
        )) === !0 && g(v, b ? b.concat(x) : [x]);
      }), p.pop();
    }
  }
  if (!ue.isObject(e))
    throw new TypeError("data must be an object");
  return g(e), t;
}
function AO(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(n) {
    return t[n];
  });
}
function IS(e, t) {
  this._pairs = [], e && Km(e, this, t);
}
const fM = IS.prototype;
fM.append = function(e, t) {
  this._pairs.push([e, t]);
};
fM.toString = function(e) {
  const t = e ? function(n) {
    return e.call(this, n, AO);
  } : AO;
  return this._pairs.map(function(n) {
    return t(n[0]) + "=" + t(n[1]);
  }, "").join("&");
};
function $H(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function pM(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || $H;
  ue.isFunction(n) && (n = {
    serialize: n
  });
  const o = n && n.serialize;
  let i;
  if (o ? i = o(t, n) : i = ue.isURLSearchParams(t) ? t.toString() : new IS(t, n).toString(r), i) {
    const s = e.indexOf("#");
    s !== -1 && (e = e.slice(0, s)), e += (e.indexOf("?") === -1 ? "?" : "&") + i;
  }
  return e;
}
class NO {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    ue.forEach(this.handlers, function(n) {
      n !== null && t(n);
    });
  }
}
const hM = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, YH = typeof URLSearchParams < "u" ? URLSearchParams : IS, qH = typeof FormData < "u" ? FormData : null, XH = typeof Blob < "u" ? Blob : null, WH = {
  isBrowser: !0,
  classes: {
    URLSearchParams: YH,
    FormData: qH,
    Blob: XH
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, VS = typeof window < "u" && typeof document < "u", Gw = typeof navigator == "object" && navigator || void 0, GH = VS && (!Gw || ["ReactNative", "NativeScript", "NS"].indexOf(Gw.product) < 0), ZH = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", KH = VS && window.location.href || "http://localhost", QH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: VS,
  hasStandardBrowserEnv: GH,
  hasStandardBrowserWebWorkerEnv: ZH,
  navigator: Gw,
  origin: KH
}, Symbol.toStringTag, { value: "Module" })), Fn = {
  ...QH,
  ...WH
};
function JH(e, t) {
  return Km(e, new Fn.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, o, i) {
      return Fn.isNode && ue.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : i.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function e$(e) {
  return ue.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function t$(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const o = n.length;
  let i;
  for (r = 0; r < o; r++)
    i = n[r], t[i] = e[i];
  return t;
}
function mM(e) {
  function t(n, r, o, i) {
    let s = n[i++];
    if (s === "__proto__") return !0;
    const u = Number.isFinite(+s), c = i >= n.length;
    return s = !s && ue.isArray(o) ? o.length : s, c ? (ue.hasOwnProp(o, s) ? o[s] = [o[s], r] : o[s] = r, !u) : ((!o[s] || !ue.isObject(o[s])) && (o[s] = []), t(n, r, o[s], i) && ue.isArray(o[s]) && (o[s] = t$(o[s])), !u);
  }
  if (ue.isFormData(e) && ue.isFunction(e.entries)) {
    const n = {};
    return ue.forEachEntry(e, (r, o) => {
      t(e$(r), o, n, 0);
    }), n;
  }
  return null;
}
function n$(e, t, n) {
  if (ue.isString(e))
    try {
      return (t || JSON.parse)(e), ue.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const hf = {
  transitional: hM,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, t) {
    const n = t.getContentType() || "", r = n.indexOf("application/json") > -1, o = ue.isObject(e);
    if (o && ue.isHTMLForm(e) && (e = new FormData(e)), ue.isFormData(e))
      return r ? JSON.stringify(mM(e)) : e;
    if (ue.isArrayBuffer(e) || ue.isBuffer(e) || ue.isStream(e) || ue.isFile(e) || ue.isBlob(e) || ue.isReadableStream(e))
      return e;
    if (ue.isArrayBufferView(e))
      return e.buffer;
    if (ue.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let i;
    if (o) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return JH(e, this.formSerializer).toString();
      if ((i = ue.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
        const s = this.env && this.env.FormData;
        return Km(
          i ? { "files[]": e } : e,
          s && new s(),
          this.formSerializer
        );
      }
    }
    return o || r ? (t.setContentType("application/json", !1), n$(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || hf.transitional, n = t && t.forcedJSONParsing, r = this.responseType === "json";
    if (ue.isResponse(e) || ue.isReadableStream(e))
      return e;
    if (e && ue.isString(e) && (n && !this.responseType || r)) {
      const o = !(t && t.silentJSONParsing) && r;
      try {
        return JSON.parse(e);
      } catch (i) {
        if (o)
          throw i.name === "SyntaxError" ? Xe.from(i, Xe.ERR_BAD_RESPONSE, this, null, this.response) : i;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Fn.classes.FormData,
    Blob: Fn.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
ue.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  hf.headers[e] = {};
});
const r$ = ue.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), o$ = (e) => {
  const t = {};
  let n, r, o;
  return e && e.split(`
`).forEach(function(i) {
    o = i.indexOf(":"), n = i.substring(0, o).trim().toLowerCase(), r = i.substring(o + 1).trim(), !(!n || t[n] && r$[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, MO = Symbol("internals");
function Kc(e) {
  return e && String(e).trim().toLowerCase();
}
function Oh(e) {
  return e === !1 || e == null ? e : ue.isArray(e) ? e.map(Oh) : String(e);
}
function i$(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
const a$ = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function cb(e, t, n, r, o) {
  if (ue.isFunction(r))
    return r.call(this, t, n);
  if (o && (t = n), !!ue.isString(t)) {
    if (ue.isString(r))
      return t.indexOf(r) !== -1;
    if (ue.isRegExp(r))
      return r.test(t);
  }
}
function s$(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function l$(e, t) {
  const n = ue.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(o, i, s) {
        return this[r].call(this, t, o, i, s);
      },
      configurable: !0
    });
  });
}
let gr = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, n) {
    const r = this;
    function o(s, u, c) {
      const d = Kc(u);
      if (!d)
        throw new Error("header name must be a non-empty string");
      const p = ue.findKey(r, d);
      (!p || r[p] === void 0 || c === !0 || c === void 0 && r[p] !== !1) && (r[p || u] = Oh(s));
    }
    const i = (s, u) => ue.forEach(s, (c, d) => o(c, d, u));
    if (ue.isPlainObject(e) || e instanceof this.constructor)
      i(e, t);
    else if (ue.isString(e) && (e = e.trim()) && !a$(e))
      i(o$(e), t);
    else if (ue.isHeaders(e))
      for (const [s, u] of e.entries())
        o(u, s, n);
    else
      e != null && o(t, e, n);
    return this;
  }
  get(e, t) {
    if (e = Kc(e), e) {
      const n = ue.findKey(this, e);
      if (n) {
        const r = this[n];
        if (!t)
          return r;
        if (t === !0)
          return i$(r);
        if (ue.isFunction(t))
          return t.call(this, r, n);
        if (ue.isRegExp(t))
          return t.exec(r);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (e = Kc(e), e) {
      const n = ue.findKey(this, e);
      return !!(n && this[n] !== void 0 && (!t || cb(this, this[n], n, t)));
    }
    return !1;
  }
  delete(e, t) {
    const n = this;
    let r = !1;
    function o(i) {
      if (i = Kc(i), i) {
        const s = ue.findKey(n, i);
        s && (!t || cb(n, n[s], s, t)) && (delete n[s], r = !0);
      }
    }
    return ue.isArray(e) ? e.forEach(o) : o(e), r;
  }
  clear(e) {
    const t = Object.keys(this);
    let n = t.length, r = !1;
    for (; n--; ) {
      const o = t[n];
      (!e || cb(this, this[o], o, e, !0)) && (delete this[o], r = !0);
    }
    return r;
  }
  normalize(e) {
    const t = this, n = {};
    return ue.forEach(this, (r, o) => {
      const i = ue.findKey(n, o);
      if (i) {
        t[i] = Oh(r), delete t[o];
        return;
      }
      const s = e ? s$(o) : String(o).trim();
      s !== o && delete t[o], t[s] = Oh(r), n[s] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return ue.forEach(this, (n, r) => {
      n != null && n !== !1 && (t[r] = e && ue.isArray(n) ? n.join(", ") : n);
    }), t;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...t) {
    const n = new this(e);
    return t.forEach((r) => n.set(r)), n;
  }
  static accessor(e) {
    const t = (this[MO] = this[MO] = {
      accessors: {}
    }).accessors, n = this.prototype;
    function r(o) {
      const i = Kc(o);
      t[i] || (l$(n, o), t[i] = !0);
    }
    return ue.isArray(e) ? e.forEach(r) : r(e), this;
  }
};
gr.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
ue.reduceDescriptors(gr.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(r) {
      this[n] = r;
    }
  };
});
ue.freezeMethods(gr);
function db(e, t) {
  const n = this || hf, r = t || n, o = gr.from(r.headers);
  let i = r.data;
  return ue.forEach(e, function(s) {
    i = s.call(n, i, o.normalize(), t ? t.status : void 0);
  }), o.normalize(), i;
}
function gM(e) {
  return !!(e && e.__CANCEL__);
}
function Fu(e, t, n) {
  Xe.call(this, e ?? "canceled", Xe.ERR_CANCELED, t, n), this.name = "CanceledError";
}
ue.inherits(Fu, Xe, {
  __CANCEL__: !0
});
function yM(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new Xe(
    "Request failed with status code " + n.status,
    [Xe.ERR_BAD_REQUEST, Xe.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function u$(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function c$(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let o = 0, i = 0, s;
  return t = t !== void 0 ? t : 1e3, function(u) {
    const c = Date.now(), d = r[i];
    s || (s = c), n[o] = u, r[o] = c;
    let p = i, h = 0;
    for (; p !== o; )
      h += n[p++], p = p % e;
    if (o = (o + 1) % e, o === i && (i = (i + 1) % e), c - s < t)
      return;
    const g = d && c - d;
    return g ? Math.round(h * 1e3 / g) : void 0;
  };
}
function d$(e, t) {
  let n = 0, r = 1e3 / t, o, i;
  const s = (u, c = Date.now()) => {
    n = c, o = null, i && (clearTimeout(i), i = null), e.apply(null, u);
  };
  return [(...u) => {
    const c = Date.now(), d = c - n;
    d >= r ? s(u, c) : (o = u, i || (i = setTimeout(() => {
      i = null, s(o);
    }, r - d)));
  }, () => o && s(o)];
}
const tm = (e, t, n = 3) => {
  let r = 0;
  const o = c$(50, 250);
  return d$((i) => {
    const s = i.loaded, u = i.lengthComputable ? i.total : void 0, c = s - r, d = o(c), p = s <= u;
    r = s;
    const h = {
      loaded: s,
      total: u,
      progress: u ? s / u : void 0,
      bytes: c,
      rate: d || void 0,
      estimated: d && u && p ? (u - s) / d : void 0,
      event: i,
      lengthComputable: u != null,
      [t ? "download" : "upload"]: !0
    };
    e(h);
  }, n);
}, RO = (e, t) => {
  const n = e != null;
  return [(r) => t[0]({
    lengthComputable: n,
    total: e,
    loaded: r
  }), t[1]];
}, jO = (e) => (...t) => ue.asap(() => e(...t)), f$ = Fn.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (n) => (n = new URL(n, Fn.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(
  new URL(Fn.origin),
  Fn.navigator && /(msie|trident)/i.test(Fn.navigator.userAgent)
) : () => !0, p$ = Fn.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, r, o, i) {
      const s = [e + "=" + encodeURIComponent(t)];
      ue.isNumber(n) && s.push("expires=" + new Date(n).toGMTString()), ue.isString(r) && s.push("path=" + r), ue.isString(o) && s.push("domain=" + o), i === !0 && s.push("secure"), document.cookie = s.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function h$(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function m$(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function vM(e, t, n) {
  let r = !h$(t);
  return e && (r || n == !1) ? m$(e, t) : t;
}
const zO = (e) => e instanceof gr ? { ...e } : e;
function Ks(e, t) {
  t = t || {};
  const n = {};
  function r(d, p, h, g) {
    return ue.isPlainObject(d) && ue.isPlainObject(p) ? ue.merge.call({ caseless: g }, d, p) : ue.isPlainObject(p) ? ue.merge({}, p) : ue.isArray(p) ? p.slice() : p;
  }
  function o(d, p, h, g) {
    if (ue.isUndefined(p)) {
      if (!ue.isUndefined(d))
        return r(void 0, d, h, g);
    } else return r(d, p, h, g);
  }
  function i(d, p) {
    if (!ue.isUndefined(p))
      return r(void 0, p);
  }
  function s(d, p) {
    if (ue.isUndefined(p)) {
      if (!ue.isUndefined(d))
        return r(void 0, d);
    } else return r(void 0, p);
  }
  function u(d, p, h) {
    if (h in t)
      return r(d, p);
    if (h in e)
      return r(void 0, d);
  }
  const c = {
    url: i,
    method: i,
    data: i,
    baseURL: s,
    transformRequest: s,
    transformResponse: s,
    paramsSerializer: s,
    timeout: s,
    timeoutMessage: s,
    withCredentials: s,
    withXSRFToken: s,
    adapter: s,
    responseType: s,
    xsrfCookieName: s,
    xsrfHeaderName: s,
    onUploadProgress: s,
    onDownloadProgress: s,
    decompress: s,
    maxContentLength: s,
    maxBodyLength: s,
    beforeRedirect: s,
    transport: s,
    httpAgent: s,
    httpsAgent: s,
    cancelToken: s,
    socketPath: s,
    responseEncoding: s,
    validateStatus: u,
    headers: (d, p, h) => o(zO(d), zO(p), h, !0)
  };
  return ue.forEach(Object.keys(Object.assign({}, e, t)), function(d) {
    const p = c[d] || o, h = p(e[d], t[d], d);
    ue.isUndefined(h) && p !== u || (n[d] = h);
  }), n;
}
const bM = (e) => {
  const t = Ks({}, e);
  let { data: n, withXSRFToken: r, xsrfHeaderName: o, xsrfCookieName: i, headers: s, auth: u } = t;
  t.headers = s = gr.from(s), t.url = pM(vM(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), u && s.set(
    "Authorization",
    "Basic " + btoa((u.username || "") + ":" + (u.password ? unescape(encodeURIComponent(u.password)) : ""))
  );
  let c;
  if (ue.isFormData(n)) {
    if (Fn.hasStandardBrowserEnv || Fn.hasStandardBrowserWebWorkerEnv)
      s.setContentType(void 0);
    else if ((c = s.getContentType()) !== !1) {
      const [d, ...p] = c ? c.split(";").map((h) => h.trim()).filter(Boolean) : [];
      s.setContentType([d || "multipart/form-data", ...p].join("; "));
    }
  }
  if (Fn.hasStandardBrowserEnv && (r && ue.isFunction(r) && (r = r(t)), r || r !== !1 && f$(t.url))) {
    const d = o && i && p$.read(i);
    d && s.set(o, d);
  }
  return t;
}, g$ = typeof XMLHttpRequest < "u", y$ = g$ && function(e) {
  return new Promise(function(t, n) {
    const r = bM(e);
    let o = r.data;
    const i = gr.from(r.headers).normalize();
    let { responseType: s, onUploadProgress: u, onDownloadProgress: c } = r, d, p, h, g, y;
    function b() {
      g && g(), y && y(), r.cancelToken && r.cancelToken.unsubscribe(d), r.signal && r.signal.removeEventListener("abort", d);
    }
    let v = new XMLHttpRequest();
    v.open(r.method.toUpperCase(), r.url, !0), v.timeout = r.timeout;
    function x() {
      if (!v)
        return;
      const O = gr.from(
        "getAllResponseHeaders" in v && v.getAllResponseHeaders()
      ), C = {
        data: !s || s === "text" || s === "json" ? v.responseText : v.response,
        status: v.status,
        statusText: v.statusText,
        headers: O,
        config: e,
        request: v
      };
      yM(function(N) {
        t(N), b();
      }, function(N) {
        n(N), b();
      }, C), v = null;
    }
    "onloadend" in v ? v.onloadend = x : v.onreadystatechange = function() {
      !v || v.readyState !== 4 || v.status === 0 && !(v.responseURL && v.responseURL.indexOf("file:") === 0) || setTimeout(x);
    }, v.onabort = function() {
      v && (n(new Xe("Request aborted", Xe.ECONNABORTED, e, v)), v = null);
    }, v.onerror = function() {
      n(new Xe("Network Error", Xe.ERR_NETWORK, e, v)), v = null;
    }, v.ontimeout = function() {
      let O = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded";
      const C = r.transitional || hM;
      r.timeoutErrorMessage && (O = r.timeoutErrorMessage), n(new Xe(
        O,
        C.clarifyTimeoutError ? Xe.ETIMEDOUT : Xe.ECONNABORTED,
        e,
        v
      )), v = null;
    }, o === void 0 && i.setContentType(null), "setRequestHeader" in v && ue.forEach(i.toJSON(), function(O, C) {
      v.setRequestHeader(C, O);
    }), ue.isUndefined(r.withCredentials) || (v.withCredentials = !!r.withCredentials), s && s !== "json" && (v.responseType = r.responseType), c && ([h, y] = tm(c, !0), v.addEventListener("progress", h)), u && v.upload && ([p, g] = tm(u), v.upload.addEventListener("progress", p), v.upload.addEventListener("loadend", g)), (r.cancelToken || r.signal) && (d = (O) => {
      v && (n(!O || O.type ? new Fu(null, e, v) : O), v.abort(), v = null);
    }, r.cancelToken && r.cancelToken.subscribe(d), r.signal && (r.signal.aborted ? d() : r.signal.addEventListener("abort", d)));
    const _ = u$(r.url);
    if (_ && Fn.protocols.indexOf(_) === -1) {
      n(new Xe("Unsupported protocol " + _ + ":", Xe.ERR_BAD_REQUEST, e));
      return;
    }
    v.send(o || null);
  });
}, v$ = (e, t) => {
  const { length: n } = e = e ? e.filter(Boolean) : [];
  if (t || n) {
    let r = new AbortController(), o;
    const i = function(d) {
      if (!o) {
        o = !0, u();
        const p = d instanceof Error ? d : this.reason;
        r.abort(p instanceof Xe ? p : new Fu(p instanceof Error ? p.message : p));
      }
    };
    let s = t && setTimeout(() => {
      s = null, i(new Xe(`timeout ${t} of ms exceeded`, Xe.ETIMEDOUT));
    }, t);
    const u = () => {
      e && (s && clearTimeout(s), s = null, e.forEach((d) => {
        d.unsubscribe ? d.unsubscribe(i) : d.removeEventListener("abort", i);
      }), e = null);
    };
    e.forEach((d) => d.addEventListener("abort", i));
    const { signal: c } = r;
    return c.unsubscribe = () => ue.asap(u), c;
  }
}, b$ = function* (e, t) {
  let n = e.byteLength;
  if (n < t) {
    yield e;
    return;
  }
  let r = 0, o;
  for (; r < n; )
    o = r + t, yield e.slice(r, o), r = o;
}, w$ = async function* (e, t) {
  for await (const n of x$(e))
    yield* b$(n, t);
}, x$ = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: n, value: r } = await t.read();
      if (n)
        break;
      yield r;
    }
  } finally {
    await t.cancel();
  }
}, TO = (e, t, n, r) => {
  const o = w$(e, t);
  let i = 0, s, u = (c) => {
    s || (s = !0, r && r(c));
  };
  return new ReadableStream({
    async pull(c) {
      try {
        const { done: d, value: p } = await o.next();
        if (d) {
          u(), c.close();
          return;
        }
        let h = p.byteLength;
        if (n) {
          let g = i += h;
          n(g);
        }
        c.enqueue(new Uint8Array(p));
      } catch (d) {
        throw u(d), d;
      }
    },
    cancel(c) {
      return u(c), o.return();
    }
  }, {
    highWaterMark: 2
  });
}, Qm = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", wM = Qm && typeof ReadableStream == "function", S$ = Qm && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), xM = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, _$ = wM && xM(() => {
  let e = !1;
  const t = new Request(Fn.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), DO = 64 * 1024, Zw = wM && xM(() => ue.isReadableStream(new Response("").body)), nm = {
  stream: Zw && ((e) => e.body)
};
Qm && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !nm[t] && (nm[t] = ue.isFunction(e[t]) ? (n) => n[t]() : (n, r) => {
      throw new Xe(`Response type '${t}' is not supported`, Xe.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const k$ = async (e) => {
  if (e == null)
    return 0;
  if (ue.isBlob(e))
    return e.size;
  if (ue.isSpecCompliantForm(e))
    return (await new Request(Fn.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (ue.isArrayBufferView(e) || ue.isArrayBuffer(e))
    return e.byteLength;
  if (ue.isURLSearchParams(e) && (e = e + ""), ue.isString(e))
    return (await S$(e)).byteLength;
}, E$ = async (e, t) => ue.toFiniteNumber(e.getContentLength()) ?? k$(t), C$ = Qm && (async (e) => {
  let {
    url: t,
    method: n,
    data: r,
    signal: o,
    cancelToken: i,
    timeout: s,
    onDownloadProgress: u,
    onUploadProgress: c,
    responseType: d,
    headers: p,
    withCredentials: h = "same-origin",
    fetchOptions: g
  } = bM(e);
  d = d ? (d + "").toLowerCase() : "text";
  let y = v$([o, i && i.toAbortSignal()], s), b;
  const v = y && y.unsubscribe && (() => {
    y.unsubscribe();
  });
  let x;
  try {
    if (c && _$ && n !== "get" && n !== "head" && (x = await E$(p, r)) !== 0) {
      let R = new Request(t, {
        method: "POST",
        body: r,
        duplex: "half"
      }), z;
      if (ue.isFormData(r) && (z = R.headers.get("content-type")) && p.setContentType(z), R.body) {
        const [j, I] = RO(
          x,
          tm(jO(c))
        );
        r = TO(R.body, DO, j, I);
      }
    }
    ue.isString(h) || (h = h ? "include" : "omit");
    const _ = "credentials" in Request.prototype;
    b = new Request(t, {
      ...g,
      signal: y,
      method: n.toUpperCase(),
      headers: p.normalize().toJSON(),
      body: r,
      duplex: "half",
      credentials: _ ? h : void 0
    });
    let O = await fetch(b);
    const C = Zw && (d === "stream" || d === "response");
    if (Zw && (u || C && v)) {
      const R = {};
      ["status", "statusText", "headers"].forEach(($) => {
        R[$] = O[$];
      });
      const z = ue.toFiniteNumber(O.headers.get("content-length")), [j, I] = u && RO(
        z,
        tm(jO(u), !0)
      ) || [];
      O = new Response(
        TO(O.body, DO, j, () => {
          I && I(), v && v();
        }),
        R
      );
    }
    d = d || "text";
    let N = await nm[ue.findKey(nm, d) || "text"](O, e);
    return !C && v && v(), await new Promise((R, z) => {
      yM(R, z, {
        data: N,
        headers: gr.from(O.headers),
        status: O.status,
        statusText: O.statusText,
        config: e,
        request: b
      });
    });
  } catch (_) {
    throw v && v(), _ && _.name === "TypeError" && /fetch/i.test(_.message) ? Object.assign(
      new Xe("Network Error", Xe.ERR_NETWORK, e, b),
      {
        cause: _.cause || _
      }
    ) : Xe.from(_, _ && _.code, e, b);
  }
}), Kw = {
  http: FH,
  xhr: y$,
  fetch: C$
};
ue.forEach(Kw, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const PO = (e) => `- ${e}`, O$ = (e) => ue.isFunction(e) || e === null || e === !1, SM = {
  getAdapter: (e) => {
    e = ue.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, r;
    const o = {};
    for (let i = 0; i < t; i++) {
      n = e[i];
      let s;
      if (r = n, !O$(n) && (r = Kw[(s = String(n)).toLowerCase()], r === void 0))
        throw new Xe(`Unknown adapter '${s}'`);
      if (r)
        break;
      o[s || "#" + i] = r;
    }
    if (!r) {
      const i = Object.entries(o).map(
        ([u, c]) => `adapter ${u} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let s = t ? i.length > 1 ? `since :
` + i.map(PO).join(`
`) : " " + PO(i[0]) : "as no adapter specified";
      throw new Xe(
        "There is no suitable adapter to dispatch the request " + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: Kw
};
function fb(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Fu(null, e);
}
function LO(e) {
  return fb(e), e.headers = gr.from(e.headers), e.data = db.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), SM.getAdapter(e.adapter || hf.adapter)(e).then(function(t) {
    return fb(e), t.data = db.call(
      e,
      e.transformResponse,
      t
    ), t.headers = gr.from(t.headers), t;
  }, function(t) {
    return gM(t) || (fb(e), t && t.response && (t.response.data = db.call(
      e,
      e.transformResponse,
      t.response
    ), t.response.headers = gr.from(t.response.headers))), Promise.reject(t);
  });
}
const _M = "1.8.4", Jm = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  Jm[e] = function(n) {
    return typeof n === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const IO = {};
Jm.transitional = function(e, t, n) {
  function r(o, i) {
    return "[Axios v" + _M + "] Transitional option '" + o + "'" + i + (n ? ". " + n : "");
  }
  return (o, i, s) => {
    if (e === !1)
      throw new Xe(
        r(i, " has been removed" + (t ? " in " + t : "")),
        Xe.ERR_DEPRECATED
      );
    return t && !IO[i] && (IO[i] = !0, console.warn(
      r(
        i,
        " has been deprecated since v" + t + " and will be removed in the near future"
      )
    )), e ? e(o, i, s) : !0;
  };
};
Jm.spelling = function(e) {
  return (t, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0);
};
function A$(e, t, n) {
  if (typeof e != "object")
    throw new Xe("options must be an object", Xe.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let o = r.length;
  for (; o-- > 0; ) {
    const i = r[o], s = t[i];
    if (s) {
      const u = e[i], c = u === void 0 || s(u, i, e);
      if (c !== !0)
        throw new Xe("option " + i + " must be " + c, Xe.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new Xe("Unknown option " + i, Xe.ERR_BAD_OPTION);
  }
}
const Ah = {
  assertOptions: A$,
  validators: Jm
}, Go = Ah.validators;
let Ws = class {
  constructor(e) {
    this.defaults = e, this.interceptors = {
      request: new NO(),
      response: new NO()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, t) {
    try {
      return await this._request(e, t);
    } catch (n) {
      if (n instanceof Error) {
        let r = {};
        Error.captureStackTrace ? Error.captureStackTrace(r) : r = new Error();
        const o = r.stack ? r.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? o && !String(n.stack).endsWith(o.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + o) : n.stack = o;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(e, t) {
    typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = Ks(this.defaults, t);
    const { transitional: n, paramsSerializer: r, headers: o } = t;
    n !== void 0 && Ah.assertOptions(n, {
      silentJSONParsing: Go.transitional(Go.boolean),
      forcedJSONParsing: Go.transitional(Go.boolean),
      clarifyTimeoutError: Go.transitional(Go.boolean)
    }, !1), r != null && (ue.isFunction(r) ? t.paramsSerializer = {
      serialize: r
    } : Ah.assertOptions(r, {
      encode: Go.function,
      serialize: Go.function
    }, !0)), t.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), Ah.assertOptions(t, {
      baseUrl: Go.spelling("baseURL"),
      withXsrfToken: Go.spelling("withXSRFToken")
    }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase();
    let i = o && ue.merge(
      o.common,
      o[t.method]
    );
    o && ue.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (y) => {
        delete o[y];
      }
    ), t.headers = gr.concat(i, o);
    const s = [];
    let u = !0;
    this.interceptors.request.forEach(function(y) {
      typeof y.runWhen == "function" && y.runWhen(t) === !1 || (u = u && y.synchronous, s.unshift(y.fulfilled, y.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(y) {
      c.push(y.fulfilled, y.rejected);
    });
    let d, p = 0, h;
    if (!u) {
      const y = [LO.bind(this), void 0];
      for (y.unshift.apply(y, s), y.push.apply(y, c), h = y.length, d = Promise.resolve(t); p < h; )
        d = d.then(y[p++], y[p++]);
      return d;
    }
    h = s.length;
    let g = t;
    for (p = 0; p < h; ) {
      const y = s[p++], b = s[p++];
      try {
        g = y(g);
      } catch (v) {
        b.call(this, v);
        break;
      }
    }
    try {
      d = LO.call(this, g);
    } catch (y) {
      return Promise.reject(y);
    }
    for (p = 0, h = c.length; p < h; )
      d = d.then(c[p++], c[p++]);
    return d;
  }
  getUri(e) {
    e = Ks(this.defaults, e);
    const t = vM(e.baseURL, e.url, e.allowAbsoluteUrls);
    return pM(t, e.params, e.paramsSerializer);
  }
};
ue.forEach(["delete", "get", "head", "options"], function(e) {
  Ws.prototype[e] = function(t, n) {
    return this.request(Ks(n || {}, {
      method: e,
      url: t,
      data: (n || {}).data
    }));
  };
});
ue.forEach(["post", "put", "patch"], function(e) {
  function t(n) {
    return function(r, o, i) {
      return this.request(Ks(i || {}, {
        method: e,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: r,
        data: o
      }));
    };
  }
  Ws.prototype[e] = t(), Ws.prototype[e + "Form"] = t(!0);
});
let N$ = class kM {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(o) {
      n = o;
    });
    const r = this;
    this.promise.then((o) => {
      if (!r._listeners) return;
      let i = r._listeners.length;
      for (; i-- > 0; )
        r._listeners[i](o);
      r._listeners = null;
    }), this.promise.then = (o) => {
      let i;
      const s = new Promise((u) => {
        r.subscribe(u), i = u;
      }).then(o);
      return s.cancel = function() {
        r.unsubscribe(i);
      }, s;
    }, t(function(o, i, s) {
      r.reason || (r.reason = new Fu(o, i, s), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), n = (r) => {
      t.abort(r);
    };
    return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new kM(function(n) {
        t = n;
      }),
      cancel: t
    };
  }
};
function M$(e) {
  return function(t) {
    return e.apply(null, t);
  };
}
function R$(e) {
  return ue.isObject(e) && e.isAxiosError === !0;
}
const Qw = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Qw).forEach(([e, t]) => {
  Qw[t] = e;
});
function EM(e) {
  const t = new Ws(e), n = nM(Ws.prototype.request, t);
  return ue.extend(n, Ws.prototype, t, { allOwnKeys: !0 }), ue.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(r) {
    return EM(Ks(e, r));
  }, n;
}
const nn = EM(hf);
nn.Axios = Ws;
nn.CanceledError = Fu;
nn.CancelToken = N$;
nn.isCancel = gM;
nn.VERSION = _M;
nn.toFormData = Km;
nn.AxiosError = Xe;
nn.Cancel = nn.CanceledError;
nn.all = function(e) {
  return Promise.all(e);
};
nn.spread = M$;
nn.isAxiosError = R$;
nn.mergeConfig = Ks;
nn.AxiosHeaders = gr;
nn.formToJSON = (e) => mM(ue.isHTMLForm(e) ? new FormData(e) : e);
nn.getAdapter = SM.getAdapter;
nn.HttpStatusCode = Qw;
nn.default = nn;
const {
  Axios: xve,
  AxiosError: Sve,
  CanceledError: _ve,
  isCancel: kve,
  CancelToken: Eve,
  VERSION: Cve,
  all: Ove,
  Cancel: Ave,
  isAxiosError: Nve,
  spread: Mve,
  toFormData: Rve,
  AxiosHeaders: jve,
  HttpStatusCode: zve,
  formToJSON: Tve,
  getAdapter: Dve,
  mergeConfig: Pve
} = nn, jn = [];
for (let e = 0; e < 256; ++e)
  jn.push((e + 256).toString(16).slice(1));
function j$(e, t = 0) {
  return (jn[e[t + 0]] + jn[e[t + 1]] + jn[e[t + 2]] + jn[e[t + 3]] + "-" + jn[e[t + 4]] + jn[e[t + 5]] + "-" + jn[e[t + 6]] + jn[e[t + 7]] + "-" + jn[e[t + 8]] + jn[e[t + 9]] + "-" + jn[e[t + 10]] + jn[e[t + 11]] + jn[e[t + 12]] + jn[e[t + 13]] + jn[e[t + 14]] + jn[e[t + 15]]).toLowerCase();
}
let pb;
const z$ = new Uint8Array(16);
function T$() {
  if (!pb) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    pb = crypto.getRandomValues.bind(crypto);
  }
  return pb(z$);
}
const D$ = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), VO = { randomUUID: D$ };
function CM(e, t, n) {
  var r;
  if (VO.randomUUID && !e)
    return VO.randomUUID();
  e = e || {};
  const o = e.random ?? ((r = e.rng) == null ? void 0 : r.call(e)) ?? T$();
  if (o.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, j$(o);
}
class OM {
  constructor(t) {
    this.CHUNK_TIMEOUT = 1e4, this.PONGDELAY = 2e3, this.blobChunks = {}, this._hooks = /* @__PURE__ */ new Map(), this._ns_event_intercepts = /* @__PURE__ */ new Map(), this._unique_cmd_outs = {}, this.uuid = t.uuid, this.on_error = t.on_error || ((n) => {
      var r;
      (r = this._zustand) == null || r.logger.error(n);
    }), this.messagePromises = /* @__PURE__ */ new Map(), this._local_nodeupdates = /* @__PURE__ */ new Map(), this._nodeupdatetimer = setTimeout(() => {
      this.sync_local_node_updates();
    }, 5e3), this.state = Jn((n, r) => ({
      is_open: !1
    })), t.zustand && this.set_zustand(t.zustand), t.on_sync_complete ? this.on_sync_complete = t.on_sync_complete : this.on_sync_complete = async () => {
    }, this._responsive = !1, this._last_pong = Date.now() - this.PONGDELAY * 100, setInterval(() => {
      this.is_open && this.send({ type: "ping" });
    }, this.PONGDELAY), setInterval(() => {
      Date.now() - this._last_pong > this.PONGDELAY * 3 ? this._responsive = !1 : this._responsive = !0;
    }, this.PONGDELAY * 2), setInterval(() => {
      const n = Date.now();
      for (const r in this.blobChunks)
        n - this.blobChunks[r].timestamp > this.CHUNK_TIMEOUT && delete this.blobChunks[r];
    }, this.CHUNK_TIMEOUT / 2);
  }
  _receive_pong() {
    this._last_pong = Date.now(), this._responsive = !0;
  }
  set_zustand(t) {
    t !== this._zustand && (this._zustand = t, t.set_worker(this), this._zustand.auto_progress(), this.stepwise_fullsync());
  }
  add_hook(t, n) {
    const r = this._hooks.get(t) || [];
    return r.push(n), this._hooks.set(t, r), () => {
      const o = this._hooks.get(t) || [], i = o.indexOf(n);
      i >= 0 && o.splice(i, 1);
    };
  }
  async call_hooks(t, n) {
    const r = [];
    for (const o of this._hooks.get(t) || []) {
      const i = o({ worker: this, data: n });
      i instanceof Promise && r.push(i);
    }
    await Promise.all(r);
  }
  add_ns_event_intercept(t, n) {
    const r = this._ns_event_intercepts.get(t) || [];
    return r.push(n), this._ns_event_intercepts.set(t, r), () => {
      const o = this._ns_event_intercepts.get(t) || [], i = o.indexOf(n);
      i >= 0 && o.splice(i, 1);
    };
  }
  async intercept_ns_event(t) {
    let n = t;
    for (const r of this._ns_event_intercepts.get(t.event) || [])
      n = await r(n);
    return n;
  }
  get is_open() {
    return this.state.getState().is_open;
  }
  set is_open(t) {
    this.state.setState({ is_open: t });
  }
  async stepwise_fullsync() {
    this._zustand && this.is_open && (await this.sync_lib(), await this.sync_external_worker(), await this.sync_funcnodes_plugins(), await this.sync_nodespace(), await this.sync_view_state(), await this.on_sync_complete(this));
  }
  async sync_lib() {
    if (!this._zustand || !this.is_open) return;
    const t = await this._send_cmd({
      cmd: "get_library",
      wait_for_response: !0,
      retries: 2,
      unique: !0
    });
    this._zustand.lib.libstate.getState().set({
      lib: t
    });
  }
  async sync_external_worker() {
    if (!this._zustand || !this.is_open) return;
    const t = await this._send_cmd({
      cmd: "get_worker_dependencies",
      wait_for_response: !0,
      unique: !0
    });
    this._zustand.lib.libstate.getState().set({
      external_worker: t
    });
  }
  async sync_funcnodes_plugins() {
    if (!this._zustand || !this.is_open) return;
    const t = await this._send_cmd({
      cmd: "get_plugin_keys",
      wait_for_response: !0,
      unique: !0,
      kwargs: { type: "react" }
    });
    for (const n of t) {
      const r = await this._send_cmd({
        cmd: "get_plugin",
        wait_for_response: !0,
        kwargs: { key: n, type: "react" },
        unique: !0
      });
      if (r.js)
        for (const o of r.js) {
          const i = document.createElement("script");
          i.text = atob(o), document.body.appendChild(i);
        }
      if (r.css)
        for (const o of r.css) {
          const i = document.createElement("style");
          i.innerHTML = atob(o), document.head.appendChild(i);
        }
      if (r.module !== void 0) {
        const o = atob(r.module), i = o.length, s = new Uint8Array(i);
        for (let p = 0; p < i; p++)
          s[p] = o.charCodeAt(p);
        const u = new Blob([s], { type: "application/javascript" }), c = URL.createObjectURL(u), d = await import(
          /* @vite-ignore */
          c
        );
        URL.revokeObjectURL(c), this._zustand.add_plugin(n, d.default);
      }
    }
  }
  async sync_view_state() {
    if (!this._zustand || !this.is_open) return;
    const t = await this._send_cmd({
      cmd: "view_state",
      wait_for_response: !0,
      unique: !0
    });
    t.renderoptions && this._zustand.update_render_options(t.renderoptions);
    const n = t.nodes;
    if (n)
      for (const r in n) {
        const o = {};
        xC(o, n[r]), this._zustand.on_node_action({
          type: "update",
          node: o,
          id: r,
          from_remote: !0
        });
      }
  }
  async sync_nodespace() {
    if (!this._zustand || !this.is_open) return;
    const t = await this._send_cmd({
      cmd: "get_nodes",
      kwargs: { with_frontend: !0 },
      wait_for_response: !0,
      unique: !0
    });
    for (const r of t)
      this._receive_node_added(r);
    const n = await this._send_cmd({
      cmd: "get_edges",
      wait_for_response: !0,
      unique: !0
    });
    for (const r of n)
      this._receive_edge_added(...r);
  }
  async fullsync() {
    if (!this._zustand || !this.is_open) return;
    let t;
    for (; ; )
      try {
        t = await this._send_cmd({
          cmd: "full_state",
          unique: !0
        });
        break;
      } catch (r) {
        this._zustand.logger.error("Error in fullsync", r);
      }
    this._zustand.logger.debug("Full state", t), this._zustand.lib.libstate.getState().set({
      lib: t.backend.lib,
      external_worker: t.worker_dependencies
    }), t.view.renderoptions && this._zustand.update_render_options(t.view.renderoptions);
    const n = t.view.nodes;
    for (const r of t.backend.nodes) {
      const o = n[r.id];
      o !== void 0 && xC(r, o), this._receive_node_added(r);
    }
    for (const r of t.backend.edges)
      this._receive_edge_added(...r);
  }
  async _receive_edge_added(t, n, r, o) {
    this._zustand && this._zustand.on_edge_action({
      type: "add",
      from_remote: !0,
      src_nid: t,
      src_ioid: n,
      trg_nid: r,
      trg_ioid: o
    });
  }
  async trigger_node(t) {
    await this._send_cmd({
      cmd: "trigger_node",
      kwargs: { nid: t },
      wait_for_response: !1
    });
  }
  async add_node(t) {
    const n = await this._send_cmd({
      cmd: "add_node",
      kwargs: { id: t }
    });
    this._receive_node_added(n);
  }
  async remove_node(t) {
    await this._send_cmd({
      cmd: "remove_node",
      kwargs: { id: t }
    });
  }
  async _receive_node_added(t) {
    this._zustand && this._zustand.on_node_action({
      type: "add",
      node: t,
      id: t.id,
      from_remote: !0
    });
  }
  add_edge({
    src_nid: t,
    src_ioid: n,
    trg_nid: r,
    trg_ioid: o,
    replace: i = !1
  }) {
    return this._send_cmd({
      cmd: "add_edge",
      kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: o, replace: i }
    });
  }
  remove_edge({
    src_nid: t,
    src_ioid: n,
    trg_nid: r,
    trg_ioid: o
  }) {
    return this._send_cmd({
      cmd: "remove_edge",
      kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: o }
    });
  }
  async add_external_worker({
    module: t,
    cls_module: n,
    cls_name: r
  }) {
    return await this._send_cmd({
      cmd: "add_external_worker",
      kwargs: { module: t, cls_module: n, cls_name: r }
    });
  }
  sync_local_node_updates() {
    clearTimeout(this._nodeupdatetimer), this._local_nodeupdates.forEach(async (t, n) => {
      const r = await this._send_cmd({
        cmd: "update_node",
        kwargs: { nid: n, data: t },
        wait_for_response: !0
      });
      this._zustand && this._zustand.on_node_action({
        type: "update",
        node: r,
        id: n,
        from_remote: !0
      });
    }), this._local_nodeupdates.clear(), this._nodeupdatetimer = setTimeout(() => {
      this.sync_local_node_updates();
    }, 200);
  }
  locally_update_node(t) {
    const n = this._local_nodeupdates.get(t.id);
    if (n) {
      const { new_obj: r, change: o } = No(n, t.node);
      o && this._local_nodeupdates.set(t.id, r);
    } else
      this._local_nodeupdates.set(t.id, t.node);
    t.immediate && this.sync_local_node_updates();
  }
  async get_remote_node_state(t) {
    const n = await this._send_cmd({
      cmd: "get_node_state",
      kwargs: { nid: t },
      wait_for_response: !0
    });
    this._zustand && this._zustand.on_node_action({
      type: "update",
      node: n,
      id: n.id,
      from_remote: !0
    });
  }
  set_io_value({
    nid: t,
    ioid: n,
    value: r,
    set_default: o = !1
  }) {
    return this._send_cmd({
      cmd: "set_io_value",
      kwargs: { nid: t, ioid: n, value: r, set_default: o },
      wait_for_response: !0
    });
  }
  clear() {
    return this._send_cmd({ cmd: "clear", unique: !0 });
  }
  save() {
    return this._send_cmd({
      cmd: "save",
      wait_for_response: !0,
      unique: !0
    });
  }
  load(t) {
    return this._send_cmd({
      cmd: "load_data",
      kwargs: { data: t },
      wait_for_response: !0
    }).then(() => {
      this.stepwise_fullsync();
    });
  }
  async get_io_value({ nid: t, ioid: n }) {
    const r = await this._send_cmd({
      cmd: "get_io_value",
      kwargs: { nid: t, ioid: n },
      wait_for_response: !0
    });
    return this._zustand && this._zustand.on_node_action({
      type: "update",
      node: {
        io: {
          [n]: {
            value: r
          }
        }
      },
      id: t,
      from_remote: !0
    }), r;
  }
  async get_ios_values({ nid: t }) {
    const n = await this._send_cmd({
      cmd: "get_ios_values",
      kwargs: { nid: t },
      wait_for_response: !0
    });
    if (!this._zustand) return n;
    const r = {};
    for (const o in n)
      r[o] = { value: n[o] };
    return this._zustand.on_node_action({
      type: "update",
      node: {
        io: r
      },
      id: t,
      from_remote: !0
    }), n;
  }
  async get_runstate() {
    return await this._send_cmd({
      cmd: "get_runstate",
      wait_for_response: !0,
      unique: !0
    });
  }
  async _send_cmd({
    cmd: t,
    kwargs: n,
    as_bytes: r = !1,
    wait_for_response: o = !0,
    response_timeout: i = 5e3,
    retries: s = 2,
    unique: u = !1
  }) {
    const c = {
      type: "cmd",
      as_bytes: r,
      cmd: t,
      kwargs: n || {}
    };
    if (await new Promise(async (d) => {
      if (this._responsive) return d();
      const p = setInterval(() => {
        this._responsive && (clearInterval(p), d());
      }, 100);
    }), o) {
      if (u && this._unique_cmd_outs[c.cmd] !== void 0)
        return this._unique_cmd_outs[c.cmd];
      s < 0 && (s = 0);
      const d = (async () => {
        let p;
        for (; s >= 0; ) {
          const h = c.id || CM();
          c.id = h;
          const g = new Promise((y, b) => {
            const v = setTimeout(() => {
              b("Timeout@wait_for_response for " + t);
            }, i);
            this.messagePromises.set(h, {
              resolve: (x) => {
                clearTimeout(v), y(x), this.messagePromises.delete(h);
              },
              reject: (x) => {
                clearTimeout(v), b(x), this.messagePromises.delete(h);
              }
            });
          });
          await this.send(c);
          try {
            p = await g;
            break;
          } catch (y) {
            if (s === 0)
              throw delete this._unique_cmd_outs[c.cmd], y;
            s -= 1;
            continue;
          }
        }
        return delete this._unique_cmd_outs[c.cmd], p;
      })();
      return u && (this._unique_cmd_outs[c.cmd] = d), d;
    }
    return this.send(c);
  }
  async send(t) {
    throw new Error("async send(data: any)  not implemented");
  }
  async upload_file({
    files: t,
    onProgressCallback: n,
    root: r
  }) {
    throw new Error("upload_file not implemented ");
  }
  async handle_large_message_hint({}) {
    throw new Error(
      "async handle_large_message_hint({}: LargeMessageHint) not implemented "
    );
  }
  async receive_workerevent({ event: t, data: n }) {
    switch (t) {
      case "worker_error":
        return this._zustand ? this._zustand.logger.error(n.error) : void 0;
      case "update_worker_dependencies":
        return this._zustand ? this._zustand.lib.libstate.getState().set({
          external_worker: n.worker_dependencies
        }) : void 0;
      case "lib_update":
        await this.sync_lib();
        return;
      case "fullsync":
        await this.stepwise_fullsync();
        return;
      case "external_worker_update":
        await this.sync_lib(), await this.sync_external_worker();
        return;
      case "starting":
        this.call_hooks("starting");
        return;
      case "stopping":
        this.call_hooks("stopping");
        return;
      default:
        console.warn("Unhandled worker event", t, n);
        break;
    }
  }
  async receive_nodespace_event(t) {
    const { event: n, data: r } = await this.intercept_ns_event(t);
    switch (n) {
      case "after_set_value":
        return this._zustand ? this._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            io: {
              [r.io]: {
                value: r.result
              }
            }
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "after_update_value_options":
        return this._zustand ? this._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            io: {
              [r.io]: {
                value_options: r.result
              }
            }
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerstart":
        return this._zustand ? this._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !0
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerdone":
        return this._zustand ? this._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !1
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerfast":
        if (!this._zustand) return;
        this._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !0
          },
          id: r.node,
          from_remote: !0
        }), setTimeout(() => {
          this._zustand && this._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              in_trigger: !1
            },
            id: r.node,
            from_remote: !0
          });
        }, 50);
        return;
      case "node_trigger_error":
        return this._zustand ? this._zustand.on_node_action({
          type: "error",
          errortype: "trigger",
          error: r.error,
          id: r.node,
          tb: r.tb,
          from_remote: !0
        }) : void 0;
      case "node_removed":
        if (!this._zustand) return;
        this._zustand.on_node_action({
          type: "delete",
          id: r.node,
          from_remote: !0
        }), this.call_hooks("node_removed", { node: r.node });
        return;
      case "node_added":
        this._receive_node_added(r.node);
        return;
      case "after_disconnect":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this._zustand ? void 0 : this._zustand.on_edge_action({
          type: "delete",
          from_remote: !0,
          src_nid: r.result[0],
          src_ioid: r.result[1],
          trg_nid: r.result[2],
          trg_ioid: r.result[3]
        });
      case "after_unforward":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this._zustand ? void 0 : this._zustand.on_edge_action({
          type: "delete",
          from_remote: !0,
          src_nid: r.result[0],
          src_ioid: r.result[1],
          trg_nid: r.result[2],
          trg_ioid: r.result[3]
        });
      case "after_connect":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
          ...r.result
        );
      case "after_forward":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
          ...r.result
        );
      case "after_add_shelf":
        return !r.result || !this._zustand ? void 0 : this._zustand.lib.libstate.getState().set({
          lib: r.result
        });
      case "after_remove_shelf":
        return !r.result || !this._zustand ? void 0 : this._zustand.lib.libstate.getState().set({
          lib: r.result
        });
      case "progress":
        if (!this._zustand) return;
        if (r.node)
          return this._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              progress: r.info
            },
            id: r.node,
            from_remote: !0
          });
        console.warn("Unhandled nodepsace event", n, r);
        break;
      default:
        if (["after_set_nodespace"].includes(n)) return;
        console.warn("Unhandled nodepsace event", n, r);
        break;
    }
  }
  async add_lib(t, n) {
    return await this._send_cmd({
      cmd: "add_package_dependency",
      kwargs: { name: t, version: n },
      wait_for_response: !1
    });
  }
  async remove_lib(t) {
    return await this._send_cmd({
      cmd: "remove_package_dependency",
      kwargs: { name: t },
      wait_for_response: !1
    });
  }
  async receive(t) {
    let n;
    switch (this._last_pong = Date.now(), this._responsive = !0, t.type) {
      case "pong":
        this._receive_pong();
        return;
      case "nsevent":
        return await this.receive_nodespace_event(t);
      case "result":
        if (n = t.id && this.messagePromises.get(t.id), n)
          return n.resolve(t.result);
        break;
      case "error":
        if (this.on_error(t.tb + `
` + t.error), n = t.id && this.messagePromises.get(t.id), n)
          return n.reject(t.error);
        break;
      case "progress":
        if (!this._zustand) return;
        this._zustand.set_progress(t);
        break;
      case "workerevent":
        return await this.receive_workerevent(t);
      case "large_message":
        return await this.handle_large_message_hint(t);
      default:
        console.warn("Unhandled message", t);
        break;
    }
  }
  async onbytes(t) {
    try {
      const n = new TextDecoder("utf-8").decode(t), r = n.indexOf(`\r
\r
`);
      if (r === -1) {
        console.error(`Header terminator not found for:
`, n);
        return;
      }
      const o = n.substring(0, r + 4), i = t.slice(r + 4), s = o.split(";"), u = {};
      if (s.forEach((h) => {
        const [g, y] = h.split("=");
        u[g.trim()] = y.trim();
      }), !u.chunk || !u.msgid) {
        console.error(
          "Header missing required fields chunk or msgid",
          u
        );
        return;
      }
      const [c, d] = u.chunk.split("/"), p = u.msgid;
      if (c === "1" && d === "1")
        return this.recieve_bytes(u, i);
      if (this.blobChunks[p] || (this.blobChunks[p] = {
        chunks: Array.from({ length: parseInt(d) }, () => null),
        timestamp: Date.now()
      }), this.blobChunks[p].chunks.length !== parseInt(d)) {
        console.error("Total chunks mismatch");
        return;
      }
      if (this.blobChunks[p].chunks[parseInt(c) - 1] = t, this.blobChunks[p].chunks.every((h) => h !== null)) {
        const h = new Uint8Array(
          this.blobChunks[p].chunks.reduce((g, y) => g.concat(Array.from(y)), [])
        );
        this.recieve_bytes(u, h), delete this.blobChunks[p];
      }
    } catch (n) {
      console.error("Websocketworker: onbytes error", n, t);
      return;
    }
  }
  async recieve_bytes(t, n) {
    const { type: r } = t;
    if (r === "io_value") {
      if (!this._zustand) return;
      const { node: o, io: i, preview: s, mime: u } = t, c = s ? "value" : "fullvalue";
      (!o || !i) && console.error("Invalid io_value message", t);
      const d = SC({
        data: n,
        mime: u || "application/octet-stream"
      });
      this._zustand.on_node_action({
        type: "update",
        node: {
          id: o,
          io: {
            [i]: {
              [c]: d
            }
          }
        },
        id: o,
        from_remote: !0
      });
    } else if (r == "result") {
      const o = t.id && this.messagePromises.get(t.id);
      o && o.resolve({ bytes: n, header: t });
    } else
      console.warn("Unhandled bytes message", t);
  }
  disconnect() {
  }
  onclose() {
    this.is_open = !1, this._zustand && this._zustand.auto_progress();
  }
  async reconnect() {
  }
  async stop() {
    await this._send_cmd({ cmd: "stop_worker", wait_for_response: !1 });
    const t = this.onclose.bind(this);
    this.onclose = () => {
      t(), this._zustand && (this._zustand.worker === this && this._zustand.clear_all(), this.onclose = t);
    };
  }
  async get_io_full_value({ nid: t, ioid: n }) {
    const r = await this._send_cmd({
      cmd: "get_io_full_value",
      kwargs: { nid: t, ioid: n },
      wait_for_response: !0,
      as_bytes: !0
    });
    if (!this._zustand) return r;
    if (!this._zustand) return;
    const { header: o, bytes: i } = r, { mime: s } = o, u = SC({
      data: i,
      mime: s || "application/octet-stream"
    });
    return this._zustand.on_node_action({
      type: "update",
      node: {
        id: t,
        io: {
          [n]: {
            fullvalue: u
          }
        }
      },
      id: t,
      from_remote: !0
    }), r;
  }
  async update_io_options({
    nid: t,
    ioid: n,
    options: r
  }) {
    const o = await this._send_cmd({
      cmd: "update_io_options",
      kwargs: { nid: t, ioid: n, ...r },
      wait_for_response: !0
    });
    if (!this._zustand) return o;
    this._zustand.on_node_action({
      type: "update",
      node: {
        io: {
          [n]: {
            ...r
          }
        }
      },
      id: t,
      from_remote: !0
    });
  }
  async get_node_status(t) {
    return await this._send_cmd({
      cmd: "get_node_state",
      kwargs: { nid: t },
      wait_for_response: !0
    });
  }
  async get_available_modules() {
    return await this._send_cmd({
      cmd: "get_available_modules",
      wait_for_response: !0,
      unique: !0
    });
  }
  async update_external_worker(t, n, r) {
    return await this._send_cmd({
      cmd: "update_external_worker",
      kwargs: { worker_id: t, class_id: n, ...r },
      wait_for_response: !0
    });
  }
  async remove_external_worker(t, n) {
    return await this._send_cmd({
      cmd: "remove_external_worker",
      kwargs: { worker_id: t, class_id: n },
      wait_for_response: !0
    });
  }
  async export({ withFiles: t = !1 }) {
    return await this._send_cmd({
      cmd: "export_worker",
      wait_for_response: !0,
      kwargs: { with_files: t }
    });
  }
  async update_from_export(t) {
    const n = this.add_hook("node_added", async ({}) => {
      var r;
      (r = this._zustand) == null || r.center_all();
    });
    try {
      const r = await this._send_cmd({
        cmd: "update_from_export",
        kwargs: { data: t },
        wait_for_response: !0,
        response_timeout: 6e5,
        // 10 minutes
        unique: !0
      });
      return await new Promise((o) => {
        setTimeout(() => {
          o();
        }, 1e3);
      }), await this.stepwise_fullsync(), r;
    } finally {
      n();
    }
  }
}
class AM extends OM {
  constructor(t) {
    super(t), this._websocket = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 5e3, this._reconnect = !0, this._reconnect_timeout = void 0, this._url = t.url, this._reconnect_timeout = setTimeout(() => {
      this.connect();
    }, 200), this._zustand && this._zustand.auto_progress();
  }
  connect() {
    var t;
    (t = this._zustand) == null || t.logger.info("Connecting to websocket"), this.is_open = !1, this._websocket = new WebSocket(this._url), this._websocket.onopen = () => {
      this.onopen();
    }, this._websocket.onclose = () => {
      this.onclose();
    }, this._websocket.onerror = () => {
      this.on_ws_error();
    }, this._websocket.onmessage = (n) => {
      typeof n.data == "string" ? this.onmessage(n.data) : n.data instanceof Blob && n.data.arrayBuffer().then((r) => {
        const o = new Uint8Array(r);
        this.onbytes(o);
      });
    };
  }
  calculateReconnectTimeout() {
    return Math.min(
      this.initialTimeout * Math.pow(2, this.reconnectAttempts),
      this.maxTimeout
    );
  }
  auto_reconnect() {
    var t, n;
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      let r = this.calculateReconnectTimeout();
      (t = this._zustand) == null || t.logger.info(`Attempting to reconnect in ${r} ms`), this._reconnect_timeout = setTimeout(() => {
        this._websocket && this._websocket.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
      }, r);
    } else
      (n = this._zustand) == null || n.logger.warn(
        "Maximum reconnect attempts reached. Giving up."
      );
  }
  async onmessage(t) {
    var n;
    try {
      const r = JSON.parse(t);
      (n = this._zustand) == null || n.logger.debug(
        `Recieved data of length: ${t.length} and data"`,
        r
      ), await this.receive(r);
    } catch (r) {
      console.error("Websocketworker: onmessage JSON.parse error", r, t);
      return;
    }
  }
  get http_protocol() {
    return this.secure_url ? "https" : "http";
  }
  get secure_url() {
    return this._url.startsWith("wss");
  }
  get url_wo_protocol() {
    return this._url.substring(this.secure_url ? 6 : 5);
  }
  get http_url() {
    var t = this.http_protocol + "://" + this.url_wo_protocol;
    return t[t.length - 1] !== "/" && (t += "/"), t;
  }
  get_io_subscription_url({
    node_id: t,
    io_id: n,
    stream: r
  }) {
    let o = this.http_url + `node/${t}/io/${n}/value`;
    return r && (o += "/stream"), o;
  }
  async upload_file({
    files: t,
    onProgressCallback: n,
    root: r
  }) {
    const o = `${this.http_url}upload/`, i = new FormData(), s = Array.isArray(t) ? t : Array.from(t);
    for (const u of s) {
      const c = u.webkitRelativePath || u.name, d = r ? `${r}/${c}` : c;
      i.append("file", u, d);
    }
    try {
      return (await nn.post(o, i, {
        headers: {
          "Content-Type": "multipart/form-data"
        },
        onUploadProgress: (u) => {
          n && n(u.loaded, u.total);
        }
      })).data.file;
    } catch {
      throw new Error("Failed to upload file");
    }
  }
  async handle_large_message_hint({ msg_id: t }) {
    const n = this.http_url + "message/" + t, r = await (await fetch(n, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*"
      }
    })).json();
    this.receive(r);
  }
  onopen() {
    var t;
    (t = this._zustand) == null || t.logger.info("Websocket opened"), this.is_open = !0, this._zustand && this._zustand.auto_progress(), this.reconnectAttempts = 0, this.stepwise_fullsync();
  }
  onclose() {
    var t, n;
    (t = this._zustand) == null || t.logger.info("Websocket closed"), super.onclose(), this._reconnect && ((n = this._zustand) == null || n.logger.info("Websocket closed,reconnecting"), this.auto_reconnect());
  }
  on_ws_error() {
    var t;
    (t = this._zustand) == null || t.logger.warn("Websocket error"), this._websocket ? this._websocket.close() : this.auto_reconnect();
  }
  async send_large_message(t) {
    const n = `${this.http_url}message/`;
    await fetch(n, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: t
    });
  }
  async send(t) {
    var n, r, o;
    if (!this._websocket || this._websocket.readyState !== WebSocket.OPEN) {
      (n = this._zustand) == null || n.logger.warn("Websocket not connected");
      return;
    }
    const i = JSON.stringify(t);
    if (new Blob([i]).size > 1e6)
      return (r = this._zustand) == null || r.logger.info("Data too large, sending via http"), await this.send_large_message(i);
    (o = this._zustand) == null || o.logger.debug("Sending data", t), this._websocket.send(i);
  }
  async stop() {
    await super.stop(), this._reconnect = !1;
  }
  close() {
    this._websocket && this._websocket.close();
  }
  disconnect() {
    super.disconnect(), this._reconnect = !1, this._reconnect_timeout && (clearTimeout(this._reconnect_timeout), this._reconnect_timeout = void 0), this.close();
  }
  async reconnect() {
    var t;
    if (await super.reconnect(), this._reconnect = !0, this._websocket && ((t = this._zustand) == null || t.logger.info("Reconnecting"), (this._websocket.readyState === WebSocket.OPEN || this._websocket.readyState === WebSocket.CONNECTING) && (this._websocket.readyState === WebSocket.CONNECTING && await new Promise((n, r) => {
      if (this._websocket === null) return;
      let o = setTimeout(() => {
        r("Timeout@reconnect");
      }, 2e3);
      this._websocket.addEventListener(
        "open",
        () => {
          clearTimeout(o), n(null);
        },
        { once: !0 }
      ), this._websocket.readyState === WebSocket.OPEN && (clearTimeout(o), n(null));
    }), this._websocket.readyState === WebSocket.OPEN))) {
      this.stepwise_fullsync();
      return;
    }
    this.connect();
  }
}
class P$ {
  constructor(t, n) {
    this.ws = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 2e3, this.wsuri = t, this.zustand = n, this.workers = {}, this.on_setWorker = (r) => {
      this.zustand.set_worker(r);
    }, this.connectionTimeout = setTimeout(() => {
      this.connect();
    }, 200);
  }
  get open() {
    var t;
    return ((t = this.ws) == null ? void 0 : t.readyState) === WebSocket.OPEN;
  }
  connect() {
    this.zustand.set_progress({
      progress: 0,
      message: "connecting to worker manager",
      status: "info",
      blocking: !0
    }), this.zustand.logger.info("Connecting to websocket:", this.wsuri), this.ws = new WebSocket(this.wsuri), this.ws.onopen = () => {
      this.onopen();
    }, this.ws.onclose = () => {
      this.onclose();
    }, this.ws.onerror = () => {
      this.on_ws_error();
    }, this.ws.onmessage = (t) => {
      typeof t.data == "string" ? this.onmessage(t.data) : console.error(
        "WorkerManager: onmessage event.data is not a string",
        typeof t.data
      );
    }, this.connectionTimeout = setTimeout(() => {
      var t;
      ((t = this.ws) == null ? void 0 : t.readyState) !== WebSocket.OPEN && this.on_ws_error();
    }, 5e3);
  }
  on_ws_error() {
    console.warn("Websocket error"), this.ws ? this.ws.close() : this.reconnect();
  }
  onopen() {
    this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.zustand.auto_progress(), this.ws && this.ws.send("worker_status");
    const t = window.localStorage.getItem(
      "funcnodes__active_worker"
    );
    t && this.set_active(t);
  }
  onmessage(t) {
    try {
      let n = JSON.parse(t);
      if (n.type === "worker_status") {
        const r = {};
        for (let o of n.active)
          o.active = !0, r[o.uuid] = o;
        for (let o of n.inactive)
          o.active = !1, r[o.uuid] = o;
        this.zustand.workers.setState(r);
        return;
      } else if (n.type === "set_worker") {
        if (n.data.type === "WSWorker") {
          let r = "ws" + (n.data.ssl ? "s" : "") + "://" + n.data.host + ":" + n.data.port;
          this.setWorker(
            this.workers[n.data.uuid] || new AM({
              url: r,
              zustand: this.zustand,
              uuid: n.data.uuid,
              on_sync_complete: this.zustand.options.on_sync_complete
            })
          );
        } else
          this.zustand.logger.error("WorkerManager: unknown worker type", n);
        return;
      } else if (n.type === "progress") {
        this.zustand.set_progress(n);
        return;
      }
      this.zustand.logger.error("WorkerManager: unknown message", n);
    } catch (n) {
      console.error("WorkerManager: onmessage JSON.parse error", n, t);
      return;
    }
  }
  setWorker(t) {
    for (let n in this.workers)
      n !== t?.uuid && this.workers[n].disconnect();
    t !== void 0 && (this.workers[t.uuid] = t, t.reconnect()), t != null && t.uuid && window.localStorage.setItem("funcnodes__active_worker", t?.uuid), this.zustand.worker !== void 0 && this.zustand.clear_all(), this.zustand.set_worker(t), this.on_setWorker(t);
  }
  async restart_worker(t) {
    var n;
    (n = this.ws) == null || n.send(JSON.stringify({ type: "restart_worker", workerid: t }));
  }
  calculateReconnectTimeout() {
    return Math.min(
      this.initialTimeout * Math.pow(2, this.reconnectAttempts),
      this.maxTimeout
    );
  }
  reconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      let t = this.calculateReconnectTimeout();
      this.zustand.logger.info(`Attempting to reconnect in ${t} ms`), setTimeout(() => {
        this.ws && this.ws.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
      }, t);
    } else
      this.zustand.logger.warn(
        "Maximum reconnect attempts reached. Giving up."
      );
  }
  onclose() {
    this.zustand.logger.warn("WorkerManager: onclose"), this.reconnect();
  }
  set_active(t) {
    this.ws && this.ws.send(JSON.stringify({ type: "set_active", workerid: t }));
  }
  new_worker({
    name: t,
    reference: n,
    copyLib: r,
    copyNS: o
  }) {
    t || (t = void 0), r || (r = !1), o || (o = !1), n || (n = void 0, r = !1, o = !1), this.ws && this.ws.send(
      JSON.stringify({
        type: "new_worker",
        kwargs: {
          name: t,
          reference: n,
          copyLib: r,
          copyNS: o
        }
      })
    );
  }
  remove() {
    for (let t in this.workers)
      this.workers[t].disconnect();
    this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.ws && (this.ws.onclose = () => {
    }, this.ws.onerror = () => {
    }, this.ws.onmessage = () => {
    }, this.ws.onopen = () => {
    }, this.ws.close());
  }
}
function L$(e) {
  const t = window.atob(e), n = t.length, r = new Uint8Array(n);
  for (let o = 0; o < n; o++)
    r[o] = t.charCodeAt(o);
  return r;
}
function I$(e, t) {
  return new Blob([e], { type: t });
}
function V$(e, t) {
  return I$(L$(e), t);
}
function B$(e, t, n) {
  const r = V$(e, n), o = URL.createObjectURL(r), i = document.createElement("a");
  i.href = o, i.download = t, i.click(), URL.revokeObjectURL(o), i.remove();
}
function F$(e, t = !0) {
  return new Promise((n) => {
    const r = new FileReader();
    r.onload = () => {
      const o = r.result;
      t && n(o.split(",")[1]), n(o);
    }, r.readAsDataURL(e);
  });
}
function U$(e) {
  return new Promise((t) => {
    const n = document.createElement("input");
    n.type = "file", n.accept = e, n.onchange = () => {
      var r;
      const o = (r = n.files) == null ? void 0 : r[0];
      o && t(o);
    }, n.click();
  });
}
function H$(e) {
  return U$(e).then(F$);
}
async function $$(e, t = !0) {
  try {
    const n = await fetch(e);
    if (!n.ok)
      throw new Error(
        `Failed to fetch from URL: ${n.status} ${n.statusText}`
      );
    const r = await n.blob();
    return await new Promise((o, i) => {
      const s = new FileReader();
      s.onload = () => {
        const u = s.result;
        typeof u != "string" && (i("Failed to convert URL to Base64: No result from FileReader"), i(s.error)), o(t ? u.split(",")[1] : u);
      }, s.onerror = () => i(s.error), s.readAsDataURL(r);
    });
  } catch (n) {
    throw console.error("Error converting URL to Base64:", n), n;
  }
}
function Ue(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(r) {
    if (e?.(r), n === !1 || !r.defaultPrevented)
      return t?.(r);
  };
}
function BO(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function eg(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((o) => {
      const i = BO(o, t);
      return !n && typeof i == "function" && (n = !0), i;
    });
    if (n)
      return () => {
        for (let o = 0; o < r.length; o++) {
          const i = r[o];
          typeof i == "function" ? i() : BO(e[o], null);
        }
      };
  };
}
function Ut(...e) {
  return S.useCallback(eg(...e), e);
}
function Y$(e, t) {
  const n = S.createContext(t), r = (i) => {
    const { children: s, ...u } = i, c = S.useMemo(() => u, Object.values(u));
    return /* @__PURE__ */ E.jsx(n.Provider, { value: c, children: s });
  };
  r.displayName = e + "Provider";
  function o(i) {
    const s = S.useContext(n);
    if (s) return s;
    if (t !== void 0) return t;
    throw new Error(`\`${i}\` must be used within \`${e}\``);
  }
  return [r, o];
}
function us(e, t = []) {
  let n = [];
  function r(i, s) {
    const u = S.createContext(s), c = n.length;
    n = [...n, s];
    const d = (h) => {
      var g;
      const { scope: y, children: b, ...v } = h, x = ((g = y?.[e]) == null ? void 0 : g[c]) || u, _ = S.useMemo(() => v, Object.values(v));
      return /* @__PURE__ */ E.jsx(x.Provider, { value: _, children: b });
    };
    d.displayName = i + "Provider";
    function p(h, g) {
      var y;
      const b = ((y = g?.[e]) == null ? void 0 : y[c]) || u, v = S.useContext(b);
      if (v) return v;
      if (s !== void 0) return s;
      throw new Error(`\`${h}\` must be used within \`${i}\``);
    }
    return [d, p];
  }
  const o = () => {
    const i = n.map((s) => S.createContext(s));
    return function(s) {
      const u = s?.[e] || i;
      return S.useMemo(
        () => ({ [`__scope${e}`]: { ...s, [e]: u } }),
        [s, u]
      );
    };
  };
  return o.scopeName = e, [r, q$(o, ...t)];
}
function q$(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((o) => ({
      useScope: o(),
      scopeName: o.scopeName
    }));
    return function(o) {
      const i = r.reduce((s, { useScope: u, scopeName: c }) => {
        const d = u(o)[`__scope${c}`];
        return { ...s, ...d };
      }, {});
      return S.useMemo(() => ({ [`__scope${t.scopeName}`]: i }), [i]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
var Qs = globalThis != null && globalThis.document ? S.useLayoutEffect : () => {
}, X$ = uN[" useId ".trim().toString()] || (() => {
}), W$ = 0;
function qi(e) {
  const [t, n] = S.useState(X$());
  return Qs(() => {
    n((r) => r ?? String(W$++));
  }, [e]), t ? `radix-${t}` : "";
}
function fo(e) {
  const t = S.useRef(e);
  return S.useEffect(() => {
    t.current = e;
  }), S.useMemo(() => (...n) => {
    var r;
    return (r = t.current) == null ? void 0 : r.call(t, ...n);
  }, []);
}
function Uu({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  }
}) {
  const [r, o] = G$({ defaultProp: t, onChange: n }), i = e !== void 0, s = i ? e : r, u = fo(n), c = S.useCallback(
    (d) => {
      if (i) {
        const p = typeof d == "function" ? d(e) : d;
        p !== e && u(p);
      } else
        o(d);
    },
    [i, e, o, u]
  );
  return [s, c];
}
function G$({
  defaultProp: e,
  onChange: t
}) {
  const n = S.useState(e), [r] = n, o = S.useRef(r), i = fo(t);
  return S.useEffect(() => {
    o.current !== r && (i(r), o.current = r);
  }, [r, o, i]), n;
}
// @__NO_SIDE_EFFECTS__
function ju(e) {
  const t = /* @__PURE__ */ Z$(e), n = S.forwardRef((r, o) => {
    const { children: i, ...s } = r, u = S.Children.toArray(i), c = u.find(Q$);
    if (c) {
      const d = c.props.children, p = u.map((h) => h === c ? S.Children.count(d) > 1 ? S.Children.only(null) : S.isValidElement(d) ? d.props.children : null : h);
      return /* @__PURE__ */ E.jsx(t, { ...s, ref: o, children: S.isValidElement(d) ? S.cloneElement(d, void 0, p) : null });
    }
    return /* @__PURE__ */ E.jsx(t, { ...s, ref: o, children: i });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function Z$(e) {
  const t = S.forwardRef((n, r) => {
    const { children: o, ...i } = n;
    if (S.isValidElement(o)) {
      const s = eY(o), u = J$(i, o.props);
      return o.type !== S.Fragment && (u.ref = r ? eg(r, s) : s), S.cloneElement(o, u);
    }
    return S.Children.count(o) > 1 ? S.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var K$ = Symbol("radix.slottable");
function Q$(e) {
  return S.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === K$;
}
function J$(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], i = t[r];
    /^on[A-Z]/.test(r) ? o && i ? n[r] = (...s) => {
      i(...s), o(...s);
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...i } : r === "className" && (n[r] = [o, i].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function eY(e) {
  var t, n;
  let r = (t = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : t.get, o = r && "isReactWarning" in r && r.isReactWarning;
  return o ? e.ref : (r = (n = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : n.get, o = r && "isReactWarning" in r && r.isReactWarning, o ? e.props.ref : e.props.ref || e.ref);
}
var tY = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], zt = tY.reduce((e, t) => {
  const n = /* @__PURE__ */ ju(`Primitive.${t}`), r = S.forwardRef((o, i) => {
    const { asChild: s, ...u } = o, c = s ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ E.jsx(c, { ...u, ref: i });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function NM(e, t) {
  e && rf.flushSync(() => e.dispatchEvent(t));
}
function nY(e, t = globalThis?.document) {
  const n = fo(e);
  S.useEffect(() => {
    const r = (o) => {
      o.key === "Escape" && n(o);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var rY = "DismissableLayer", Jw = "dismissableLayer.update", oY = "dismissableLayer.pointerDownOutside", iY = "dismissableLayer.focusOutside", FO, MM = S.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), tg = S.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: o,
      onFocusOutside: i,
      onInteractOutside: s,
      onDismiss: u,
      ...c
    } = e, d = S.useContext(MM), [p, h] = S.useState(null), g = p?.ownerDocument ?? globalThis?.document, [, y] = S.useState({}), b = Ut(t, (j) => h(j)), v = Array.from(d.layers), [x] = [...d.layersWithOutsidePointerEventsDisabled].slice(-1), _ = v.indexOf(x), O = p ? v.indexOf(p) : -1, C = d.layersWithOutsidePointerEventsDisabled.size > 0, N = O >= _, R = lY((j) => {
      const I = j.target, $ = [...d.branches].some((A) => A.contains(I));
      !N || $ || (o?.(j), s?.(j), j.defaultPrevented || u == null || u());
    }, g), z = uY((j) => {
      const I = j.target;
      [...d.branches].some(($) => $.contains(I)) || (i?.(j), s?.(j), j.defaultPrevented || u == null || u());
    }, g);
    return nY((j) => {
      O === d.layers.size - 1 && (r?.(j), !j.defaultPrevented && u && (j.preventDefault(), u()));
    }, g), S.useEffect(() => {
      if (p)
        return n && (d.layersWithOutsidePointerEventsDisabled.size === 0 && (FO = g.body.style.pointerEvents, g.body.style.pointerEvents = "none"), d.layersWithOutsidePointerEventsDisabled.add(p)), d.layers.add(p), UO(), () => {
          n && d.layersWithOutsidePointerEventsDisabled.size === 1 && (g.body.style.pointerEvents = FO);
        };
    }, [p, g, n, d]), S.useEffect(() => () => {
      p && (d.layers.delete(p), d.layersWithOutsidePointerEventsDisabled.delete(p), UO());
    }, [p, d]), S.useEffect(() => {
      const j = () => y({});
      return document.addEventListener(Jw, j), () => document.removeEventListener(Jw, j);
    }, []), /* @__PURE__ */ E.jsx(
      zt.div,
      {
        ...c,
        ref: b,
        style: {
          pointerEvents: C ? N ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: Ue(e.onFocusCapture, z.onFocusCapture),
        onBlurCapture: Ue(e.onBlurCapture, z.onBlurCapture),
        onPointerDownCapture: Ue(
          e.onPointerDownCapture,
          R.onPointerDownCapture
        )
      }
    );
  }
);
tg.displayName = rY;
var aY = "DismissableLayerBranch", sY = S.forwardRef((e, t) => {
  const n = S.useContext(MM), r = S.useRef(null), o = Ut(t, r);
  return S.useEffect(() => {
    const i = r.current;
    if (i)
      return n.branches.add(i), () => {
        n.branches.delete(i);
      };
  }, [n.branches]), /* @__PURE__ */ E.jsx(zt.div, { ...e, ref: o });
});
sY.displayName = aY;
function lY(e, t = globalThis?.document) {
  const n = fo(e), r = S.useRef(!1), o = S.useRef(() => {
  });
  return S.useEffect(() => {
    const i = (u) => {
      if (u.target && !r.current) {
        let c = function() {
          RM(
            oY,
            n,
            d,
            { discrete: !0 }
          );
        };
        const d = { originalEvent: u };
        u.pointerType === "touch" ? (t.removeEventListener("click", o.current), o.current = c, t.addEventListener("click", o.current, { once: !0 })) : c();
      } else
        t.removeEventListener("click", o.current);
      r.current = !1;
    }, s = window.setTimeout(() => {
      t.addEventListener("pointerdown", i);
    }, 0);
    return () => {
      window.clearTimeout(s), t.removeEventListener("pointerdown", i), t.removeEventListener("click", o.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function uY(e, t = globalThis?.document) {
  const n = fo(e), r = S.useRef(!1);
  return S.useEffect(() => {
    const o = (i) => {
      i.target && !r.current && RM(iY, n, { originalEvent: i }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", o), () => t.removeEventListener("focusin", o);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function UO() {
  const e = new CustomEvent(Jw);
  document.dispatchEvent(e);
}
function RM(e, t, n, { discrete: r }) {
  const o = n.originalEvent.target, i = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && o.addEventListener(e, t, { once: !0 }), r ? NM(o, i) : o.dispatchEvent(i);
}
var hb = "focusScope.autoFocusOnMount", mb = "focusScope.autoFocusOnUnmount", HO = { bubbles: !1, cancelable: !0 }, cY = "FocusScope", ng = S.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: o,
    onUnmountAutoFocus: i,
    ...s
  } = e, [u, c] = S.useState(null), d = fo(o), p = fo(i), h = S.useRef(null), g = Ut(t, (v) => c(v)), y = S.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  S.useEffect(() => {
    if (r) {
      let v = function(C) {
        if (y.paused || !u) return;
        const N = C.target;
        u.contains(N) ? h.current = N : Ha(h.current, { select: !0 });
      }, x = function(C) {
        if (y.paused || !u) return;
        const N = C.relatedTarget;
        N !== null && (u.contains(N) || Ha(h.current, { select: !0 }));
      }, _ = function(C) {
        if (document.activeElement === document.body)
          for (const N of C)
            N.removedNodes.length > 0 && Ha(u);
      };
      document.addEventListener("focusin", v), document.addEventListener("focusout", x);
      const O = new MutationObserver(_);
      return u && O.observe(u, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", v), document.removeEventListener("focusout", x), O.disconnect();
      };
    }
  }, [r, u, y.paused]), S.useEffect(() => {
    if (u) {
      YO.add(y);
      const v = document.activeElement;
      if (!u.contains(v)) {
        const x = new CustomEvent(hb, HO);
        u.addEventListener(hb, d), u.dispatchEvent(x), x.defaultPrevented || (dY(gY(jM(u)), { select: !0 }), document.activeElement === v && Ha(u));
      }
      return () => {
        u.removeEventListener(hb, d), setTimeout(() => {
          const x = new CustomEvent(mb, HO);
          u.addEventListener(mb, p), u.dispatchEvent(x), x.defaultPrevented || Ha(v ?? document.body, { select: !0 }), u.removeEventListener(mb, p), YO.remove(y);
        }, 0);
      };
    }
  }, [u, d, p, y]);
  const b = S.useCallback(
    (v) => {
      if (!n && !r || y.paused) return;
      const x = v.key === "Tab" && !v.altKey && !v.ctrlKey && !v.metaKey, _ = document.activeElement;
      if (x && _) {
        const O = v.currentTarget, [C, N] = fY(O);
        C && N ? !v.shiftKey && _ === N ? (v.preventDefault(), n && Ha(C, { select: !0 })) : v.shiftKey && _ === C && (v.preventDefault(), n && Ha(N, { select: !0 })) : _ === O && v.preventDefault();
      }
    },
    [n, r, y.paused]
  );
  return /* @__PURE__ */ E.jsx(zt.div, { tabIndex: -1, ...s, ref: g, onKeyDown: b });
});
ng.displayName = cY;
function dY(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (Ha(r, { select: t }), document.activeElement !== n) return;
}
function fY(e) {
  const t = jM(e), n = $O(t, e), r = $O(t.reverse(), e);
  return [n, r];
}
function jM(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const o = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function $O(e, t) {
  for (const n of e)
    if (!pY(n, { upTo: t })) return n;
}
function pY(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function hY(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Ha(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && hY(e) && t && e.select();
  }
}
var YO = mY();
function mY() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && n?.pause(), e = qO(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = qO(e, t), (n = e[0]) == null || n.resume();
    }
  };
}
function qO(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function gY(e) {
  return e.filter((t) => t.tagName !== "A");
}
var yY = "Portal", BS = S.forwardRef((e, t) => {
  var n;
  const { container: r, ...o } = e, [i, s] = S.useState(!1);
  Qs(() => s(!0), []);
  const u = r || i && ((n = globalThis?.document) == null ? void 0 : n.body);
  return u ? E9.createPortal(/* @__PURE__ */ E.jsx(zt.div, { ...o, ref: t }), u) : null;
});
BS.displayName = yY;
function vY(e, t) {
  return S.useReducer((n, r) => t[n][r] ?? n, e);
}
var oa = (e) => {
  const { present: t, children: n } = e, r = bY(t), o = typeof n == "function" ? n({ present: r.isPresent }) : S.Children.only(n), i = Ut(r.ref, wY(o));
  return typeof n == "function" || r.isPresent ? S.cloneElement(o, { ref: i }) : null;
};
oa.displayName = "Presence";
function bY(e) {
  const [t, n] = S.useState(), r = S.useRef({}), o = S.useRef(e), i = S.useRef("none"), s = e ? "mounted" : "unmounted", [u, c] = vY(s, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return S.useEffect(() => {
    const d = Wp(r.current);
    i.current = u === "mounted" ? d : "none";
  }, [u]), Qs(() => {
    const d = r.current, p = o.current;
    if (p !== e) {
      const h = i.current, g = Wp(d);
      e ? c("MOUNT") : g === "none" || d?.display === "none" ? c("UNMOUNT") : c(p && h !== g ? "ANIMATION_OUT" : "UNMOUNT"), o.current = e;
    }
  }, [e, c]), Qs(() => {
    if (t) {
      let d;
      const p = t.ownerDocument.defaultView ?? window, h = (y) => {
        const b = Wp(r.current).includes(y.animationName);
        if (y.target === t && b && (c("ANIMATION_END"), !o.current)) {
          const v = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", d = p.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = v);
          });
        }
      }, g = (y) => {
        y.target === t && (i.current = Wp(r.current));
      };
      return t.addEventListener("animationstart", g), t.addEventListener("animationcancel", h), t.addEventListener("animationend", h), () => {
        p.clearTimeout(d), t.removeEventListener("animationstart", g), t.removeEventListener("animationcancel", h), t.removeEventListener("animationend", h);
      };
    } else
      c("ANIMATION_END");
  }, [t, c]), {
    isPresent: ["mounted", "unmountSuspended"].includes(u),
    ref: S.useCallback((d) => {
      d && (r.current = getComputedStyle(d)), n(d);
    }, [])
  };
}
function Wp(e) {
  return e?.animationName || "none";
}
function wY(e) {
  var t, n;
  let r = (t = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : t.get, o = r && "isReactWarning" in r && r.isReactWarning;
  return o ? e.ref : (r = (n = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : n.get, o = r && "isReactWarning" in r && r.isReactWarning, o ? e.props.ref : e.props.ref || e.ref);
}
var gb = 0;
function FS() {
  S.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? XO()), document.body.insertAdjacentElement("beforeend", e[1] ?? XO()), gb++, () => {
      gb === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), gb--;
    };
  }, []);
}
function XO() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var oi = function() {
  return oi = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, oi.apply(this, arguments);
};
function zM(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function Nh(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, o = t.length, i; r < o; r++)
    (i || !(r in t)) && (i || (i = Array.prototype.slice.call(t, 0, r)), i[r] = t[r]);
  return e.concat(i || Array.prototype.slice.call(t));
}
var Mh = "right-scroll-bar-position", Rh = "width-before-scroll-bar", xY = "with-scroll-bars-hidden", SY = "--removed-body-scroll-bar-size";
function yb(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function _Y(e, t) {
  var n = S.useState(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var o = n.value;
          o !== r && (n.value = r, n.callback(r, o));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var kY = typeof window < "u" ? S.useLayoutEffect : S.useEffect, WO = /* @__PURE__ */ new WeakMap();
function EY(e, t) {
  var n = _Y(null, function(r) {
    return e.forEach(function(o) {
      return yb(o, r);
    });
  });
  return kY(function() {
    var r = WO.get(n);
    if (r) {
      var o = new Set(r), i = new Set(e), s = n.current;
      o.forEach(function(u) {
        i.has(u) || yb(u, null);
      }), i.forEach(function(u) {
        o.has(u) || yb(u, s);
      });
    }
    WO.set(n, e);
  }, [e]), n;
}
function CY(e) {
  return e;
}
function OY(e, t) {
  t === void 0 && (t = CY);
  var n = [], r = !1, o = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(i) {
      var s = t(i, r);
      return n.push(s), function() {
        n = n.filter(function(u) {
          return u !== s;
        });
      };
    },
    assignSyncMedium: function(i) {
      for (r = !0; n.length; ) {
        var s = n;
        n = [], s.forEach(i);
      }
      n = {
        push: function(u) {
          return i(u);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(i) {
      r = !0;
      var s = [];
      if (n.length) {
        var u = n;
        n = [], u.forEach(i), s = n;
      }
      var c = function() {
        var p = s;
        s = [], p.forEach(i);
      }, d = function() {
        return Promise.resolve().then(c);
      };
      d(), n = {
        push: function(p) {
          s.push(p), d();
        },
        filter: function(p) {
          return s = s.filter(p), n;
        }
      };
    }
  };
  return o;
}
function AY(e) {
  e === void 0 && (e = {});
  var t = OY(null);
  return t.options = oi({ async: !0, ssr: !1 }, e), t;
}
var TM = function(e) {
  var t = e.sideCar, n = zM(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return S.createElement(r, oi({}, n));
};
TM.isSideCarExport = !0;
function NY(e, t) {
  return e.useMedium(t), TM;
}
var DM = AY(), vb = function() {
}, rg = S.forwardRef(function(e, t) {
  var n = S.useRef(null), r = S.useState({
    onScrollCapture: vb,
    onWheelCapture: vb,
    onTouchMoveCapture: vb
  }), o = r[0], i = r[1], s = e.forwardProps, u = e.children, c = e.className, d = e.removeScrollBar, p = e.enabled, h = e.shards, g = e.sideCar, y = e.noIsolation, b = e.inert, v = e.allowPinchZoom, x = e.as, _ = x === void 0 ? "div" : x, O = e.gapMode, C = zM(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), N = g, R = EY([n, t]), z = oi(oi({}, C), o);
  return S.createElement(
    S.Fragment,
    null,
    p && S.createElement(N, { sideCar: DM, removeScrollBar: d, shards: h, noIsolation: y, inert: b, setCallbacks: i, allowPinchZoom: !!v, lockRef: n, gapMode: O }),
    s ? S.cloneElement(S.Children.only(u), oi(oi({}, z), { ref: R })) : S.createElement(_, oi({}, z, { className: c, ref: R }), u)
  );
});
rg.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
rg.classNames = {
  fullWidth: Rh,
  zeroRight: Mh
};
var MY = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function RY() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = MY();
  return t && e.setAttribute("nonce", t), e;
}
function jY(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function zY(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var TY = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = RY()) && (jY(t, n), zY(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, DY = function() {
  var e = TY();
  return function(t, n) {
    S.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, PM = function() {
  var e = DY(), t = function(n) {
    var r = n.styles, o = n.dynamic;
    return e(r, o), null;
  };
  return t;
}, PY = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, bb = function(e) {
  return parseInt(e || "", 10) || 0;
}, LY = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], o = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [bb(n), bb(r), bb(o)];
}, IY = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return PY;
  var t = LY(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, VY = PM(), yu = "data-scroll-locked", BY = function(e, t, n, r) {
  var o = e.left, i = e.top, s = e.right, u = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(xY, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(u, "px ").concat(r, `;
  }
  body[`).concat(yu, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(i, `px;
    padding-right: `).concat(s, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(u, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(u, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(Mh, ` {
    right: `).concat(u, "px ").concat(r, `;
  }
  
  .`).concat(Rh, ` {
    margin-right: `).concat(u, "px ").concat(r, `;
  }
  
  .`).concat(Mh, " .").concat(Mh, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Rh, " .").concat(Rh, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(yu, `] {
    `).concat(SY, ": ").concat(u, `px;
  }
`);
}, GO = function() {
  var e = parseInt(document.body.getAttribute(yu) || "0", 10);
  return isFinite(e) ? e : 0;
}, FY = function() {
  S.useEffect(function() {
    return document.body.setAttribute(yu, (GO() + 1).toString()), function() {
      var e = GO() - 1;
      e <= 0 ? document.body.removeAttribute(yu) : document.body.setAttribute(yu, e.toString());
    };
  }, []);
}, UY = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, o = r === void 0 ? "margin" : r;
  FY();
  var i = S.useMemo(function() {
    return IY(o);
  }, [o]);
  return S.createElement(VY, { styles: BY(i, !t, o, n ? "" : "!important") });
}, ex = !1;
if (typeof window < "u")
  try {
    var Gp = Object.defineProperty({}, "passive", {
      get: function() {
        return ex = !0, !0;
      }
    });
    window.addEventListener("test", Gp, Gp), window.removeEventListener("test", Gp, Gp);
  } catch {
    ex = !1;
  }
var Wl = ex ? { passive: !1 } : !1, HY = function(e) {
  return e.tagName === "TEXTAREA";
}, LM = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !HY(e) && n[t] === "visible")
  );
}, $Y = function(e) {
  return LM(e, "overflowY");
}, YY = function(e) {
  return LM(e, "overflowX");
}, ZO = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var o = IM(e, r);
    if (o) {
      var i = VM(e, r), s = i[1], u = i[2];
      if (s > u)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, qY = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, XY = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, IM = function(e, t) {
  return e === "v" ? $Y(t) : YY(t);
}, VM = function(e, t) {
  return e === "v" ? qY(t) : XY(t);
}, WY = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, GY = function(e, t, n, r, o) {
  var i = WY(e, window.getComputedStyle(t).direction), s = i * r, u = n.target, c = t.contains(u), d = !1, p = s > 0, h = 0, g = 0;
  do {
    var y = VM(e, u), b = y[0], v = y[1], x = y[2], _ = v - x - i * b;
    (b || _) && IM(e, u) && (h += _, g += b), u instanceof ShadowRoot ? u = u.host : u = u.parentNode;
  } while (
    // portaled content
    !c && u !== document.body || // self content
    c && (t.contains(u) || t === u)
  );
  return (p && Math.abs(h) < 1 || !p && Math.abs(g) < 1) && (d = !0), d;
}, Zp = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, KO = function(e) {
  return [e.deltaX, e.deltaY];
}, QO = function(e) {
  return e && "current" in e ? e.current : e;
}, ZY = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, KY = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, QY = 0, Gl = [];
function JY(e) {
  var t = S.useRef([]), n = S.useRef([0, 0]), r = S.useRef(), o = S.useState(QY++)[0], i = S.useState(PM)[0], s = S.useRef(e);
  S.useEffect(function() {
    s.current = e;
  }, [e]), S.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(o));
      var v = Nh([e.lockRef.current], (e.shards || []).map(QO), !0).filter(Boolean);
      return v.forEach(function(x) {
        return x.classList.add("allow-interactivity-".concat(o));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(o)), v.forEach(function(x) {
          return x.classList.remove("allow-interactivity-".concat(o));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var u = S.useCallback(function(v, x) {
    if ("touches" in v && v.touches.length === 2 || v.type === "wheel" && v.ctrlKey)
      return !s.current.allowPinchZoom;
    var _ = Zp(v), O = n.current, C = "deltaX" in v ? v.deltaX : O[0] - _[0], N = "deltaY" in v ? v.deltaY : O[1] - _[1], R, z = v.target, j = Math.abs(C) > Math.abs(N) ? "h" : "v";
    if ("touches" in v && j === "h" && z.type === "range")
      return !1;
    var I = ZO(j, z);
    if (!I)
      return !0;
    if (I ? R = j : (R = j === "v" ? "h" : "v", I = ZO(j, z)), !I)
      return !1;
    if (!r.current && "changedTouches" in v && (C || N) && (r.current = R), !R)
      return !0;
    var $ = r.current || R;
    return GY($, x, v, $ === "h" ? C : N);
  }, []), c = S.useCallback(function(v) {
    var x = v;
    if (!(!Gl.length || Gl[Gl.length - 1] !== i)) {
      var _ = "deltaY" in x ? KO(x) : Zp(x), O = t.current.filter(function(R) {
        return R.name === x.type && (R.target === x.target || x.target === R.shadowParent) && ZY(R.delta, _);
      })[0];
      if (O && O.should) {
        x.cancelable && x.preventDefault();
        return;
      }
      if (!O) {
        var C = (s.current.shards || []).map(QO).filter(Boolean).filter(function(R) {
          return R.contains(x.target);
        }), N = C.length > 0 ? u(x, C[0]) : !s.current.noIsolation;
        N && x.cancelable && x.preventDefault();
      }
    }
  }, []), d = S.useCallback(function(v, x, _, O) {
    var C = { name: v, delta: x, target: _, should: O, shadowParent: eq(_) };
    t.current.push(C), setTimeout(function() {
      t.current = t.current.filter(function(N) {
        return N !== C;
      });
    }, 1);
  }, []), p = S.useCallback(function(v) {
    n.current = Zp(v), r.current = void 0;
  }, []), h = S.useCallback(function(v) {
    d(v.type, KO(v), v.target, u(v, e.lockRef.current));
  }, []), g = S.useCallback(function(v) {
    d(v.type, Zp(v), v.target, u(v, e.lockRef.current));
  }, []);
  S.useEffect(function() {
    return Gl.push(i), e.setCallbacks({
      onScrollCapture: h,
      onWheelCapture: h,
      onTouchMoveCapture: g
    }), document.addEventListener("wheel", c, Wl), document.addEventListener("touchmove", c, Wl), document.addEventListener("touchstart", p, Wl), function() {
      Gl = Gl.filter(function(v) {
        return v !== i;
      }), document.removeEventListener("wheel", c, Wl), document.removeEventListener("touchmove", c, Wl), document.removeEventListener("touchstart", p, Wl);
    };
  }, []);
  var y = e.removeScrollBar, b = e.inert;
  return S.createElement(
    S.Fragment,
    null,
    b ? S.createElement(i, { styles: KY(o) }) : null,
    y ? S.createElement(UY, { gapMode: e.gapMode }) : null
  );
}
function eq(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const tq = NY(DM, JY);
var og = S.forwardRef(function(e, t) {
  return S.createElement(rg, oi({}, e, { ref: t, sideCar: tq }));
});
og.classNames = rg.classNames;
var nq = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, Zl = /* @__PURE__ */ new WeakMap(), Kp = /* @__PURE__ */ new WeakMap(), Qp = {}, wb = 0, BM = function(e) {
  return e && (e.host || BM(e.parentNode));
}, rq = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = BM(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, oq = function(e, t, n, r) {
  var o = rq(t, Array.isArray(e) ? e : [e]);
  Qp[n] || (Qp[n] = /* @__PURE__ */ new WeakMap());
  var i = Qp[n], s = [], u = /* @__PURE__ */ new Set(), c = new Set(o), d = function(h) {
    !h || u.has(h) || (u.add(h), d(h.parentNode));
  };
  o.forEach(d);
  var p = function(h) {
    !h || c.has(h) || Array.prototype.forEach.call(h.children, function(g) {
      if (u.has(g))
        p(g);
      else
        try {
          var y = g.getAttribute(r), b = y !== null && y !== "false", v = (Zl.get(g) || 0) + 1, x = (i.get(g) || 0) + 1;
          Zl.set(g, v), i.set(g, x), s.push(g), v === 1 && b && Kp.set(g, !0), x === 1 && g.setAttribute(n, "true"), b || g.setAttribute(r, "true");
        } catch (_) {
          console.error("aria-hidden: cannot operate on ", g, _);
        }
    });
  };
  return p(t), u.clear(), wb++, function() {
    s.forEach(function(h) {
      var g = Zl.get(h) - 1, y = i.get(h) - 1;
      Zl.set(h, g), i.set(h, y), g || (Kp.has(h) || h.removeAttribute(r), Kp.delete(h)), y || h.removeAttribute(n);
    }), wb--, wb || (Zl = /* @__PURE__ */ new WeakMap(), Zl = /* @__PURE__ */ new WeakMap(), Kp = /* @__PURE__ */ new WeakMap(), Qp = {});
  };
}, US = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), o = nq(e);
  return o ? (r.push.apply(r, Array.from(o.querySelectorAll("[aria-live]"))), oq(r, o, n, "aria-hidden")) : function() {
    return null;
  };
}, HS = "Dialog", [FM, Lve] = us(HS), [iq, Po] = FM(HS), UM = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: o,
    onOpenChange: i,
    modal: s = !0
  } = e, u = S.useRef(null), c = S.useRef(null), [d = !1, p] = Uu({
    prop: r,
    defaultProp: o,
    onChange: i
  });
  return /* @__PURE__ */ E.jsx(
    iq,
    {
      scope: t,
      triggerRef: u,
      contentRef: c,
      contentId: qi(),
      titleId: qi(),
      descriptionId: qi(),
      open: d,
      onOpenChange: p,
      onOpenToggle: S.useCallback(() => p((h) => !h), [p]),
      modal: s,
      children: n
    }
  );
};
UM.displayName = HS;
var HM = "DialogTrigger", $M = S.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Po(HM, n), i = Ut(t, o.triggerRef);
    return /* @__PURE__ */ E.jsx(
      zt.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": o.open,
        "aria-controls": o.contentId,
        "data-state": qS(o.open),
        ...r,
        ref: i,
        onClick: Ue(e.onClick, o.onOpenToggle)
      }
    );
  }
);
$M.displayName = HM;
var $S = "DialogPortal", [aq, YM] = FM($S, {
  forceMount: void 0
}), qM = (e) => {
  const { __scopeDialog: t, forceMount: n, children: r, container: o } = e, i = Po($S, t);
  return /* @__PURE__ */ E.jsx(aq, { scope: t, forceMount: n, children: S.Children.map(r, (s) => /* @__PURE__ */ E.jsx(oa, { present: n || i.open, children: /* @__PURE__ */ E.jsx(BS, { asChild: !0, container: o, children: s }) })) });
};
qM.displayName = $S;
var rm = "DialogOverlay", XM = S.forwardRef(
  (e, t) => {
    const n = YM(rm, e.__scopeDialog), { forceMount: r = n.forceMount, ...o } = e, i = Po(rm, e.__scopeDialog);
    return i.modal ? /* @__PURE__ */ E.jsx(oa, { present: r || i.open, children: /* @__PURE__ */ E.jsx(lq, { ...o, ref: t }) }) : null;
  }
);
XM.displayName = rm;
var sq = /* @__PURE__ */ ju("DialogOverlay.RemoveScroll"), lq = S.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Po(rm, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ E.jsx(og, { as: sq, allowPinchZoom: !0, shards: [o.contentRef], children: /* @__PURE__ */ E.jsx(
        zt.div,
        {
          "data-state": qS(o.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), Js = "DialogContent", WM = S.forwardRef(
  (e, t) => {
    const n = YM(Js, e.__scopeDialog), { forceMount: r = n.forceMount, ...o } = e, i = Po(Js, e.__scopeDialog);
    return /* @__PURE__ */ E.jsx(oa, { present: r || i.open, children: i.modal ? /* @__PURE__ */ E.jsx(uq, { ...o, ref: t }) : /* @__PURE__ */ E.jsx(cq, { ...o, ref: t }) });
  }
);
WM.displayName = Js;
var uq = S.forwardRef(
  (e, t) => {
    const n = Po(Js, e.__scopeDialog), r = S.useRef(null), o = Ut(t, n.contentRef, r);
    return S.useEffect(() => {
      const i = r.current;
      if (i) return US(i);
    }, []), /* @__PURE__ */ E.jsx(
      GM,
      {
        ...e,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Ue(e.onCloseAutoFocus, (i) => {
          var s;
          i.preventDefault(), (s = n.triggerRef.current) == null || s.focus();
        }),
        onPointerDownOutside: Ue(e.onPointerDownOutside, (i) => {
          const s = i.detail.originalEvent, u = s.button === 0 && s.ctrlKey === !0;
          (s.button === 2 || u) && i.preventDefault();
        }),
        onFocusOutside: Ue(
          e.onFocusOutside,
          (i) => i.preventDefault()
        )
      }
    );
  }
), cq = S.forwardRef(
  (e, t) => {
    const n = Po(Js, e.__scopeDialog), r = S.useRef(!1), o = S.useRef(!1);
    return /* @__PURE__ */ E.jsx(
      GM,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (i) => {
          var s, u;
          (s = e.onCloseAutoFocus) == null || s.call(e, i), i.defaultPrevented || (r.current || (u = n.triggerRef.current) == null || u.focus(), i.preventDefault()), r.current = !1, o.current = !1;
        },
        onInteractOutside: (i) => {
          var s, u;
          (s = e.onInteractOutside) == null || s.call(e, i), i.defaultPrevented || (r.current = !0, i.detail.originalEvent.type === "pointerdown" && (o.current = !0));
          const c = i.target;
          (u = n.triggerRef.current) != null && u.contains(c) && i.preventDefault(), i.detail.originalEvent.type === "focusin" && o.current && i.preventDefault();
        }
      }
    );
  }
), GM = S.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: o, onCloseAutoFocus: i, ...s } = e, u = Po(Js, n), c = S.useRef(null), d = Ut(t, c);
    return FS(), /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(
        ng,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: o,
          onUnmountAutoFocus: i,
          children: /* @__PURE__ */ E.jsx(
            tg,
            {
              role: "dialog",
              id: u.contentId,
              "aria-describedby": u.descriptionId,
              "aria-labelledby": u.titleId,
              "data-state": qS(u.open),
              ...s,
              ref: d,
              onDismiss: () => u.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
        /* @__PURE__ */ E.jsx(dq, { titleId: u.titleId }),
        /* @__PURE__ */ E.jsx(pq, { contentRef: c, descriptionId: u.descriptionId })
      ] })
    ] });
  }
), YS = "DialogTitle", ZM = S.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Po(YS, n);
    return /* @__PURE__ */ E.jsx(zt.h2, { id: o.titleId, ...r, ref: t });
  }
);
ZM.displayName = YS;
var KM = "DialogDescription", QM = S.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Po(KM, n);
    return /* @__PURE__ */ E.jsx(zt.p, { id: o.descriptionId, ...r, ref: t });
  }
);
QM.displayName = KM;
var JM = "DialogClose", eR = S.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Po(JM, n);
    return /* @__PURE__ */ E.jsx(
      zt.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Ue(e.onClick, () => o.onOpenChange(!1))
      }
    );
  }
);
eR.displayName = JM;
function qS(e) {
  return e ? "open" : "closed";
}
var tR = "DialogTitleWarning", [Ive, nR] = Y$(tR, {
  contentName: Js,
  titleName: YS,
  docsSlug: "dialog"
}), dq = ({ titleId: e }) => {
  const t = nR(tR), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return S.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, fq = "DialogDescriptionWarning", pq = ({ contentRef: e, descriptionId: t }) => {
  const n = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${nR(fq).contentName}}.`;
  return S.useEffect(() => {
    var r;
    const o = (r = e.current) == null ? void 0 : r.getAttribute("aria-describedby");
    t && o && (document.getElementById(t) || console.warn(n));
  }, [n, e, t]), null;
}, hq = UM, mq = $M, gq = qM, yq = XM, vq = WM, bq = ZM, wq = QM, JO = eR;
/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */
function xq(e, t, n) {
  return (t = _q(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function e5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ve(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? e5(Object(n), !0).forEach(function(r) {
      xq(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : e5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Sq(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function _q(e) {
  var t = Sq(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
const t5 = () => {
};
let XS = {}, rR = {}, oR = null, iR = {
  mark: t5,
  measure: t5
};
try {
  typeof window < "u" && (XS = window), typeof document < "u" && (rR = document), typeof MutationObserver < "u" && (oR = MutationObserver), typeof performance < "u" && (iR = performance);
} catch {
}
const {
  userAgent: n5 = ""
} = XS.navigator || {}, Ja = XS, Dt = rR, r5 = oR, Jp = iR;
Ja.document;
const ia = !!Dt.documentElement && !!Dt.head && typeof Dt.addEventListener == "function" && typeof Dt.createElement == "function", aR = ~n5.indexOf("MSIE") || ~n5.indexOf("Trident/");
var kq = /fa(s|r|l|t|d|dr|dl|dt|b|k|kd|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/, Eq = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit)?.*/i, sR = {
  classic: {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fab: "brands",
    "fa-brands": "brands"
  },
  duotone: {
    fa: "solid",
    fad: "solid",
    "fa-solid": "solid",
    "fa-duotone": "solid",
    fadr: "regular",
    "fa-regular": "regular",
    fadl: "light",
    "fa-light": "light",
    fadt: "thin",
    "fa-thin": "thin"
  },
  sharp: {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular",
    fasl: "light",
    "fa-light": "light",
    fast: "thin",
    "fa-thin": "thin"
  },
  "sharp-duotone": {
    fa: "solid",
    fasds: "solid",
    "fa-solid": "solid",
    fasdr: "regular",
    "fa-regular": "regular",
    fasdl: "light",
    "fa-light": "light",
    fasdt: "thin",
    "fa-thin": "thin"
  }
}, Cq = {
  GROUP: "duotone-group",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, lR = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"], Hn = "classic", ig = "duotone", Oq = "sharp", Aq = "sharp-duotone", uR = [Hn, ig, Oq, Aq], Nq = {
  classic: {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  duotone: {
    900: "fad",
    400: "fadr",
    300: "fadl",
    100: "fadt"
  },
  sharp: {
    900: "fass",
    400: "fasr",
    300: "fasl",
    100: "fast"
  },
  "sharp-duotone": {
    900: "fasds",
    400: "fasdr",
    300: "fasdl",
    100: "fasdt"
  }
}, Mq = {
  "Font Awesome 6 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 6 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  "Font Awesome 6 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 6 Duotone": {
    900: "fad",
    400: "fadr",
    normal: "fadr",
    300: "fadl",
    100: "fadt"
  },
  "Font Awesome 6 Sharp": {
    900: "fass",
    400: "fasr",
    normal: "fasr",
    300: "fasl",
    100: "fast"
  },
  "Font Awesome 6 Sharp Duotone": {
    900: "fasds",
    400: "fasdr",
    normal: "fasdr",
    300: "fasdl",
    100: "fasdt"
  }
}, Rq = /* @__PURE__ */ new Map([["classic", {
  defaultShortPrefixId: "fas",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin", "brands"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp", {
  defaultShortPrefixId: "fass",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["duotone", {
  defaultShortPrefixId: "fad",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp-duotone", {
  defaultShortPrefixId: "fasds",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}]]), jq = {
  classic: {
    solid: "fas",
    regular: "far",
    light: "fal",
    thin: "fat",
    brands: "fab"
  },
  duotone: {
    solid: "fad",
    regular: "fadr",
    light: "fadl",
    thin: "fadt"
  },
  sharp: {
    solid: "fass",
    regular: "fasr",
    light: "fasl",
    thin: "fast"
  },
  "sharp-duotone": {
    solid: "fasds",
    regular: "fasdr",
    light: "fasdl",
    thin: "fasdt"
  }
}, zq = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], o5 = {
  kit: {
    fak: "kit",
    "fa-kit": "kit"
  },
  "kit-duotone": {
    fakd: "kit-duotone",
    "fa-kit-duotone": "kit-duotone"
  }
}, Tq = ["kit"], Dq = {
  kit: {
    "fa-kit": "fak"
  }
}, Pq = ["fak", "fakd"], Lq = {
  kit: {
    fak: "fa-kit"
  }
}, i5 = {
  kit: {
    kit: "fak"
  },
  "kit-duotone": {
    "kit-duotone": "fakd"
  }
}, eh = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, Iq = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"], Vq = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], Bq = {
  "Font Awesome Kit": {
    400: "fak",
    normal: "fak"
  },
  "Font Awesome Kit Duotone": {
    400: "fakd",
    normal: "fakd"
  }
}, Fq = {
  classic: {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
  },
  duotone: {
    "fa-regular": "fadr",
    "fa-light": "fadl",
    "fa-thin": "fadt"
  },
  sharp: {
    "fa-solid": "fass",
    "fa-regular": "fasr",
    "fa-light": "fasl",
    "fa-thin": "fast"
  },
  "sharp-duotone": {
    "fa-solid": "fasds",
    "fa-regular": "fasdr",
    "fa-light": "fasdl",
    "fa-thin": "fasdt"
  }
}, Uq = {
  classic: ["fas", "far", "fal", "fat", "fad"],
  duotone: ["fadr", "fadl", "fadt"],
  sharp: ["fass", "fasr", "fasl", "fast"],
  "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"]
}, tx = {
  classic: {
    fab: "fa-brands",
    fad: "fa-duotone",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
  },
  duotone: {
    fadr: "fa-regular",
    fadl: "fa-light",
    fadt: "fa-thin"
  },
  sharp: {
    fass: "fa-solid",
    fasr: "fa-regular",
    fasl: "fa-light",
    fast: "fa-thin"
  },
  "sharp-duotone": {
    fasds: "fa-solid",
    fasdr: "fa-regular",
    fasdl: "fa-light",
    fasdt: "fa-thin"
  }
}, Hq = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands"], nx = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", ...Iq, ...Hq], $q = ["solid", "regular", "light", "thin", "duotone", "brands"], cR = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], Yq = cR.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), qq = [...Object.keys(Uq), ...$q, "2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", eh.GROUP, eh.SWAP_OPACITY, eh.PRIMARY, eh.SECONDARY].concat(cR.map((e) => "".concat(e, "x"))).concat(Yq.map((e) => "w-".concat(e))), Xq = {
  "Font Awesome 5 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 5 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal"
  },
  "Font Awesome 5 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 5 Duotone": {
    900: "fad"
  }
};
const Zi = "___FONT_AWESOME___", rx = 16, dR = "fa", fR = "svg-inline--fa", el = "data-fa-i2svg", ox = "data-fa-pseudo-element", Wq = "data-fa-pseudo-element-pending", WS = "data-prefix", GS = "data-icon", a5 = "fontawesome-i2svg", Gq = "async", Zq = ["HTML", "HEAD", "STYLE", "SCRIPT"], pR = (() => {
  try {
    return !0;
  } catch {
    return !1;
  }
})();
function mf(e) {
  return new Proxy(e, {
    get(t, n) {
      return n in t ? t[n] : t[Hn];
    }
  });
}
const hR = ve({}, sR);
hR[Hn] = ve(ve(ve(ve({}, {
  "fa-duotone": "duotone"
}), sR[Hn]), o5.kit), o5["kit-duotone"]);
const Kq = mf(hR), ix = ve({}, jq);
ix[Hn] = ve(ve(ve(ve({}, {
  duotone: "fad"
}), ix[Hn]), i5.kit), i5["kit-duotone"]);
const s5 = mf(ix), ax = ve({}, tx);
ax[Hn] = ve(ve({}, ax[Hn]), Lq.kit);
const ZS = mf(ax), sx = ve({}, Fq);
sx[Hn] = ve(ve({}, sx[Hn]), Dq.kit);
mf(sx);
const Qq = kq, mR = "fa-layers-text", Jq = Eq, eX = ve({}, Nq);
mf(eX);
const tX = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], xb = Cq, nX = [...Tq, ...qq], yd = Ja.FontAwesomeConfig || {};
function rX(e) {
  var t = Dt.querySelector("script[" + e + "]");
  if (t)
    return t.getAttribute(e);
}
function oX(e) {
  return e === "" ? !0 : e === "false" ? !1 : e === "true" ? !0 : e;
}
Dt && typeof Dt.querySelector == "function" && [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]].forEach((e) => {
  let [t, n] = e;
  const r = oX(rX(t));
  r != null && (yd[n] = r);
});
const gR = {
  styleDefault: "solid",
  familyDefault: Hn,
  cssPrefix: dR,
  replacementClass: fR,
  autoReplaceSvg: !0,
  autoAddCss: !0,
  autoA11y: !0,
  searchPseudoElements: !1,
  observeMutations: !0,
  mutateApproach: "async",
  keepOriginalSource: !0,
  measurePerformance: !1,
  showMissingIcons: !0
};
yd.familyPrefix && (yd.cssPrefix = yd.familyPrefix);
const zu = ve(ve({}, gR), yd);
zu.autoReplaceSvg || (zu.observeMutations = !1);
const Ne = {};
Object.keys(gR).forEach((e) => {
  Object.defineProperty(Ne, e, {
    enumerable: !0,
    set: function(t) {
      zu[e] = t, vd.forEach((n) => n(Ne));
    },
    get: function() {
      return zu[e];
    }
  });
});
Object.defineProperty(Ne, "familyPrefix", {
  enumerable: !0,
  set: function(e) {
    zu.cssPrefix = e, vd.forEach((t) => t(Ne));
  },
  get: function() {
    return zu.cssPrefix;
  }
});
Ja.FontAwesomeConfig = Ne;
const vd = [];
function iX(e) {
  return vd.push(e), () => {
    vd.splice(vd.indexOf(e), 1);
  };
}
const Ba = rx, ii = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: !1,
  flipY: !1
};
function aX(e) {
  if (!e || !ia)
    return;
  const t = Dt.createElement("style");
  t.setAttribute("type", "text/css"), t.innerHTML = e;
  const n = Dt.head.childNodes;
  let r = null;
  for (let o = n.length - 1; o > -1; o--) {
    const i = n[o], s = (i.tagName || "").toUpperCase();
    ["STYLE", "LINK"].indexOf(s) > -1 && (r = i);
  }
  return Dt.head.insertBefore(t, r), e;
}
const sX = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function Vd() {
  let e = 12, t = "";
  for (; e-- > 0; )
    t += sX[Math.random() * 62 | 0];
  return t;
}
function Hu(e) {
  const t = [];
  for (let n = (e || []).length >>> 0; n--; )
    t[n] = e[n];
  return t;
}
function KS(e) {
  return e.classList ? Hu(e.classList) : (e.getAttribute("class") || "").split(" ").filter((t) => t);
}
function yR(e) {
  return "".concat(e).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function lX(e) {
  return Object.keys(e || {}).reduce((t, n) => t + "".concat(n, '="').concat(yR(e[n]), '" '), "").trim();
}
function ag(e) {
  return Object.keys(e || {}).reduce((t, n) => t + "".concat(n, ": ").concat(e[n].trim(), ";"), "");
}
function QS(e) {
  return e.size !== ii.size || e.x !== ii.x || e.y !== ii.y || e.rotate !== ii.rotate || e.flipX || e.flipY;
}
function uX(e) {
  let {
    transform: t,
    containerWidth: n,
    iconWidth: r
  } = e;
  const o = {
    transform: "translate(".concat(n / 2, " 256)")
  }, i = "translate(".concat(t.x * 32, ", ").concat(t.y * 32, ") "), s = "scale(".concat(t.size / 16 * (t.flipX ? -1 : 1), ", ").concat(t.size / 16 * (t.flipY ? -1 : 1), ") "), u = "rotate(".concat(t.rotate, " 0 0)"), c = {
    transform: "".concat(i, " ").concat(s, " ").concat(u)
  }, d = {
    transform: "translate(".concat(r / 2 * -1, " -256)")
  };
  return {
    outer: o,
    inner: c,
    path: d
  };
}
function cX(e) {
  let {
    transform: t,
    width: n = rx,
    height: r = rx,
    startCentered: o = !1
  } = e, i = "";
  return o && aR ? i += "translate(".concat(t.x / Ba - n / 2, "em, ").concat(t.y / Ba - r / 2, "em) ") : o ? i += "translate(calc(-50% + ".concat(t.x / Ba, "em), calc(-50% + ").concat(t.y / Ba, "em)) ") : i += "translate(".concat(t.x / Ba, "em, ").concat(t.y / Ba, "em) "), i += "scale(".concat(t.size / Ba * (t.flipX ? -1 : 1), ", ").concat(t.size / Ba * (t.flipY ? -1 : 1), ") "), i += "rotate(".concat(t.rotate, "deg) "), i;
}
var dX = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 6 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 6 Sharp Duotone";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    animation-delay: -1ms;
    animation-duration: 1ms;
    animation-iteration-count: 1;
    transition-delay: 0s;
    transition-duration: 0s;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}`;
function vR() {
  const e = dR, t = fR, n = Ne.cssPrefix, r = Ne.replacementClass;
  let o = dX;
  if (n !== e || r !== t) {
    const i = new RegExp("\\.".concat(e, "\\-"), "g"), s = new RegExp("\\--".concat(e, "\\-"), "g"), u = new RegExp("\\.".concat(t), "g");
    o = o.replace(i, ".".concat(n, "-")).replace(s, "--".concat(n, "-")).replace(u, ".".concat(r));
  }
  return o;
}
let l5 = !1;
function Sb() {
  Ne.autoAddCss && !l5 && (aX(vR()), l5 = !0);
}
var fX = {
  mixout() {
    return {
      dom: {
        css: vR,
        insertCss: Sb
      }
    };
  },
  hooks() {
    return {
      beforeDOMElementCreation() {
        Sb();
      },
      beforeI2svg() {
        Sb();
      }
    };
  }
};
const Ki = Ja || {};
Ki[Zi] || (Ki[Zi] = {});
Ki[Zi].styles || (Ki[Zi].styles = {});
Ki[Zi].hooks || (Ki[Zi].hooks = {});
Ki[Zi].shims || (Ki[Zi].shims = []);
var ai = Ki[Zi];
const bR = [], wR = function() {
  Dt.removeEventListener("DOMContentLoaded", wR), om = 1, bR.map((e) => e());
};
let om = !1;
ia && (om = (Dt.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(Dt.readyState), om || Dt.addEventListener("DOMContentLoaded", wR));
function pX(e) {
  ia && (om ? setTimeout(e, 0) : bR.push(e));
}
function gf(e) {
  const {
    tag: t,
    attributes: n = {},
    children: r = []
  } = e;
  return typeof e == "string" ? yR(e) : "<".concat(t, " ").concat(lX(n), ">").concat(r.map(gf).join(""), "</").concat(t, ">");
}
function u5(e, t, n) {
  if (e && e[t] && e[t][n])
    return {
      prefix: t,
      iconName: n,
      icon: e[t][n]
    };
}
var _b = function(e, t, n, r) {
  var o = Object.keys(e), i = o.length, s = t, u, c, d;
  for (n === void 0 ? (u = 1, d = e[o[0]]) : (u = 0, d = n); u < i; u++)
    c = o[u], d = s(d, e[c], c, e);
  return d;
};
function hX(e) {
  const t = [];
  let n = 0;
  const r = e.length;
  for (; n < r; ) {
    const o = e.charCodeAt(n++);
    if (o >= 55296 && o <= 56319 && n < r) {
      const i = e.charCodeAt(n++);
      (i & 64512) == 56320 ? t.push(((o & 1023) << 10) + (i & 1023) + 65536) : (t.push(o), n--);
    } else
      t.push(o);
  }
  return t;
}
function xR(e) {
  const t = hX(e);
  return t.length === 1 ? t[0].toString(16) : null;
}
function mX(e, t) {
  const n = e.length;
  let r = e.charCodeAt(t), o;
  return r >= 55296 && r <= 56319 && n > t + 1 && (o = e.charCodeAt(t + 1), o >= 56320 && o <= 57343) ? (r - 55296) * 1024 + o - 56320 + 65536 : r;
}
function c5(e) {
  return Object.keys(e).reduce((t, n) => {
    const r = e[n];
    return r.icon ? t[r.iconName] = r.icon : t[n] = r, t;
  }, {});
}
function lx(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    skipHooks: r = !1
  } = n, o = c5(t);
  typeof ai.hooks.addPack == "function" && !r ? ai.hooks.addPack(e, c5(t)) : ai.styles[e] = ve(ve({}, ai.styles[e] || {}), o), e === "fas" && lx("fa", t);
}
const {
  styles: Bd,
  shims: gX
} = ai, SR = Object.keys(ZS), yX = SR.reduce((e, t) => (e[t] = Object.keys(ZS[t]), e), {});
let JS = null, _R = {}, kR = {}, ER = {}, CR = {}, OR = {};
function vX(e) {
  return ~nX.indexOf(e);
}
function bX(e, t) {
  const n = t.split("-"), r = n[0], o = n.slice(1).join("-");
  return r === e && o !== "" && !vX(o) ? o : null;
}
const AR = () => {
  const e = (r) => _b(Bd, (o, i, s) => (o[s] = _b(i, r, {}), o), {});
  _R = e((r, o, i) => (o[3] && (r[o[3]] = i), o[2] && o[2].filter((s) => typeof s == "number").forEach((s) => {
    r[s.toString(16)] = i;
  }), r)), kR = e((r, o, i) => (r[i] = i, o[2] && o[2].filter((s) => typeof s == "string").forEach((s) => {
    r[s] = i;
  }), r)), OR = e((r, o, i) => {
    const s = o[2];
    return r[i] = i, s.forEach((u) => {
      r[u] = i;
    }), r;
  });
  const t = "far" in Bd || Ne.autoFetchSvg, n = _b(gX, (r, o) => {
    const i = o[0];
    let s = o[1];
    const u = o[2];
    return s === "far" && !t && (s = "fas"), typeof i == "string" && (r.names[i] = {
      prefix: s,
      iconName: u
    }), typeof i == "number" && (r.unicodes[i.toString(16)] = {
      prefix: s,
      iconName: u
    }), r;
  }, {
    names: {},
    unicodes: {}
  });
  ER = n.names, CR = n.unicodes, JS = sg(Ne.styleDefault, {
    family: Ne.familyDefault
  });
};
iX((e) => {
  JS = sg(e.styleDefault, {
    family: Ne.familyDefault
  });
});
AR();
function e0(e, t) {
  return (_R[e] || {})[t];
}
function wX(e, t) {
  return (kR[e] || {})[t];
}
function Us(e, t) {
  return (OR[e] || {})[t];
}
function NR(e) {
  return ER[e] || {
    prefix: null,
    iconName: null
  };
}
function xX(e) {
  const t = CR[e], n = e0("fas", e);
  return t || (n ? {
    prefix: "fas",
    iconName: n
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function es() {
  return JS;
}
const MR = () => ({
  prefix: null,
  iconName: null,
  rest: []
});
function SX(e) {
  let t = Hn;
  const n = SR.reduce((r, o) => (r[o] = "".concat(Ne.cssPrefix, "-").concat(o), r), {});
  return uR.forEach((r) => {
    (e.includes(n[r]) || e.some((o) => yX[r].includes(o))) && (t = r);
  }), t;
}
function sg(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    family: n = Hn
  } = t, r = Kq[n][e];
  if (n === ig && !e)
    return "fad";
  const o = s5[n][e] || s5[n][r], i = e in ai.styles ? e : null;
  return o || i || null;
}
function _X(e) {
  let t = [], n = null;
  return e.forEach((r) => {
    const o = bX(Ne.cssPrefix, r);
    o ? n = o : r && t.push(r);
  }), {
    iconName: n,
    rest: t
  };
}
function d5(e) {
  return e.sort().filter((t, n, r) => r.indexOf(t) === n);
}
function lg(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    skipLookups: n = !1
  } = t;
  let r = null;
  const o = nx.concat(Vq), i = d5(e.filter((h) => o.includes(h))), s = d5(e.filter((h) => !nx.includes(h))), u = i.filter((h) => (r = h, !lR.includes(h))), [c = null] = u, d = SX(i), p = ve(ve({}, _X(s)), {}, {
    prefix: sg(c, {
      family: d
    })
  });
  return ve(ve(ve({}, p), OX({
    values: e,
    family: d,
    styles: Bd,
    config: Ne,
    canonical: p,
    givenPrefix: r
  })), kX(n, r, p));
}
function kX(e, t, n) {
  let {
    prefix: r,
    iconName: o
  } = n;
  if (e || !r || !o)
    return {
      prefix: r,
      iconName: o
    };
  const i = t === "fa" ? NR(o) : {}, s = Us(r, o);
  return o = i.iconName || s || o, r = i.prefix || r, r === "far" && !Bd.far && Bd.fas && !Ne.autoFetchSvg && (r = "fas"), {
    prefix: r,
    iconName: o
  };
}
const EX = uR.filter((e) => e !== Hn || e !== ig), CX = Object.keys(tx).filter((e) => e !== Hn).map((e) => Object.keys(tx[e])).flat();
function OX(e) {
  const {
    values: t,
    family: n,
    canonical: r,
    givenPrefix: o = "",
    styles: i = {},
    config: s = {}
  } = e, u = n === ig, c = t.includes("fa-duotone") || t.includes("fad"), d = s.familyDefault === "duotone", p = r.prefix === "fad" || r.prefix === "fa-duotone";
  if (!u && (c || d || p) && (r.prefix = "fad"), (t.includes("fa-brands") || t.includes("fab")) && (r.prefix = "fab"), !r.prefix && EX.includes(n) && (Object.keys(i).find((h) => CX.includes(h)) || s.autoFetchSvg)) {
    const h = Rq.get(n).defaultShortPrefixId;
    r.prefix = h, r.iconName = Us(r.prefix, r.iconName) || r.iconName;
  }
  return (r.prefix === "fa" || o === "fa") && (r.prefix = es() || "fas"), r;
}
let AX = class {
  constructor() {
    this.definitions = {};
  }
  add() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    const r = t.reduce(this._pullDefinitions, {});
    Object.keys(r).forEach((o) => {
      this.definitions[o] = ve(ve({}, this.definitions[o] || {}), r[o]), lx(o, r[o]);
      const i = ZS[Hn][o];
      i && lx(i, r[o]), AR();
    });
  }
  reset() {
    this.definitions = {};
  }
  _pullDefinitions(e, t) {
    const n = t.prefix && t.iconName && t.icon ? {
      0: t
    } : t;
    return Object.keys(n).map((r) => {
      const {
        prefix: o,
        iconName: i,
        icon: s
      } = n[r], u = s[2];
      e[o] || (e[o] = {}), u.length > 0 && u.forEach((c) => {
        typeof c == "string" && (e[o][c] = s);
      }), e[o][i] = s;
    }), e;
  }
}, f5 = [], cu = {};
const vu = {}, NX = Object.keys(vu);
function MX(e, t) {
  let {
    mixoutsTo: n
  } = t;
  return f5 = e, cu = {}, Object.keys(vu).forEach((r) => {
    NX.indexOf(r) === -1 && delete vu[r];
  }), f5.forEach((r) => {
    const o = r.mixout ? r.mixout() : {};
    if (Object.keys(o).forEach((i) => {
      typeof o[i] == "function" && (n[i] = o[i]), typeof o[i] == "object" && Object.keys(o[i]).forEach((s) => {
        n[i] || (n[i] = {}), n[i][s] = o[i][s];
      });
    }), r.hooks) {
      const i = r.hooks();
      Object.keys(i).forEach((s) => {
        cu[s] || (cu[s] = []), cu[s].push(i[s]);
      });
    }
    r.provides && r.provides(vu);
  }), n;
}
function ux(e, t) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
    r[o - 2] = arguments[o];
  return (cu[e] || []).forEach((i) => {
    t = i.apply(null, [t, ...r]);
  }), t;
}
function tl(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  (cu[e] || []).forEach((o) => {
    o.apply(null, n);
  });
}
function ts() {
  const e = arguments[0], t = Array.prototype.slice.call(arguments, 1);
  return vu[e] ? vu[e].apply(null, t) : void 0;
}
function cx(e) {
  e.prefix === "fa" && (e.prefix = "fas");
  let {
    iconName: t
  } = e;
  const n = e.prefix || es();
  if (t)
    return t = Us(n, t) || t, u5(RR.definitions, n, t) || u5(ai.styles, n, t);
}
const RR = new AX(), RX = () => {
  Ne.autoReplaceSvg = !1, Ne.observeMutations = !1, tl("noAuto");
}, jX = {
  i2svg: function() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return ia ? (tl("beforeI2svg", e), ts("pseudoElements2svg", e), ts("i2svg", e)) : Promise.reject(new Error("Operation requires a DOM of some kind."));
  },
  watch: function() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      autoReplaceSvgRoot: t
    } = e;
    Ne.autoReplaceSvg === !1 && (Ne.autoReplaceSvg = !0), Ne.observeMutations = !0, pX(() => {
      TX({
        autoReplaceSvgRoot: t
      }), tl("watch", e);
    });
  }
}, zX = {
  icon: (e) => {
    if (e === null)
      return null;
    if (typeof e == "object" && e.prefix && e.iconName)
      return {
        prefix: e.prefix,
        iconName: Us(e.prefix, e.iconName) || e.iconName
      };
    if (Array.isArray(e) && e.length === 2) {
      const t = e[1].indexOf("fa-") === 0 ? e[1].slice(3) : e[1], n = sg(e[0]);
      return {
        prefix: n,
        iconName: Us(n, t) || t
      };
    }
    if (typeof e == "string" && (e.indexOf("".concat(Ne.cssPrefix, "-")) > -1 || e.match(Qq))) {
      const t = lg(e.split(" "), {
        skipLookups: !0
      });
      return {
        prefix: t.prefix || es(),
        iconName: Us(t.prefix, t.iconName) || t.iconName
      };
    }
    if (typeof e == "string") {
      const t = es();
      return {
        prefix: t,
        iconName: Us(t, e) || e
      };
    }
  }
}, $r = {
  noAuto: RX,
  config: Ne,
  dom: jX,
  parse: zX,
  library: RR,
  findIconDefinition: cx,
  toHtml: gf
}, TX = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    autoReplaceSvgRoot: t = Dt
  } = e;
  (Object.keys(ai.styles).length > 0 || Ne.autoFetchSvg) && ia && Ne.autoReplaceSvg && $r.dom.i2svg({
    node: t
  });
};
function ug(e, t) {
  return Object.defineProperty(e, "abstract", {
    get: t
  }), Object.defineProperty(e, "html", {
    get: function() {
      return e.abstract.map((n) => gf(n));
    }
  }), Object.defineProperty(e, "node", {
    get: function() {
      if (!ia) return;
      const n = Dt.createElement("div");
      return n.innerHTML = e.html, n.children;
    }
  }), e;
}
function DX(e) {
  let {
    children: t,
    main: n,
    mask: r,
    attributes: o,
    styles: i,
    transform: s
  } = e;
  if (QS(s) && n.found && !r.found) {
    const {
      width: u,
      height: c
    } = n, d = {
      x: u / c / 2,
      y: 0.5
    };
    o.style = ag(ve(ve({}, i), {}, {
      "transform-origin": "".concat(d.x + s.x / 16, "em ").concat(d.y + s.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes: o,
    children: t
  }];
}
function PX(e) {
  let {
    prefix: t,
    iconName: n,
    children: r,
    attributes: o,
    symbol: i
  } = e;
  const s = i === !0 ? "".concat(t, "-").concat(Ne.cssPrefix, "-").concat(n) : i;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: ve(ve({}, o), {}, {
        id: s
      }),
      children: r
    }]
  }];
}
function t0(e) {
  const {
    icons: {
      main: t,
      mask: n
    },
    prefix: r,
    iconName: o,
    transform: i,
    symbol: s,
    title: u,
    maskId: c,
    titleId: d,
    extra: p,
    watchable: h = !1
  } = e, {
    width: g,
    height: y
  } = n.found ? n : t, b = Pq.includes(r), v = [Ne.replacementClass, o ? "".concat(Ne.cssPrefix, "-").concat(o) : ""].filter((R) => p.classes.indexOf(R) === -1).filter((R) => R !== "" || !!R).concat(p.classes).join(" ");
  let x = {
    children: [],
    attributes: ve(ve({}, p.attributes), {}, {
      "data-prefix": r,
      "data-icon": o,
      class: v,
      role: p.attributes.role || "img",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 ".concat(g, " ").concat(y)
    })
  };
  const _ = b && !~p.classes.indexOf("fa-fw") ? {
    width: "".concat(g / y * 16 * 0.0625, "em")
  } : {};
  h && (x.attributes[el] = ""), u && (x.children.push({
    tag: "title",
    attributes: {
      id: x.attributes["aria-labelledby"] || "title-".concat(d || Vd())
    },
    children: [u]
  }), delete x.attributes.title);
  const O = ve(ve({}, x), {}, {
    prefix: r,
    iconName: o,
    main: t,
    mask: n,
    maskId: c,
    transform: i,
    symbol: s,
    styles: ve(ve({}, _), p.styles)
  }), {
    children: C,
    attributes: N
  } = n.found && t.found ? ts("generateAbstractMask", O) || {
    children: [],
    attributes: {}
  } : ts("generateAbstractIcon", O) || {
    children: [],
    attributes: {}
  };
  return O.children = C, O.attributes = N, s ? PX(O) : DX(O);
}
function p5(e) {
  const {
    content: t,
    width: n,
    height: r,
    transform: o,
    title: i,
    extra: s,
    watchable: u = !1
  } = e, c = ve(ve(ve({}, s.attributes), i ? {
    title: i
  } : {}), {}, {
    class: s.classes.join(" ")
  });
  u && (c[el] = "");
  const d = ve({}, s.styles);
  QS(o) && (d.transform = cX({
    transform: o,
    startCentered: !0,
    width: n,
    height: r
  }), d["-webkit-transform"] = d.transform);
  const p = ag(d);
  p.length > 0 && (c.style = p);
  const h = [];
  return h.push({
    tag: "span",
    attributes: c,
    children: [t]
  }), i && h.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [i]
  }), h;
}
function LX(e) {
  const {
    content: t,
    title: n,
    extra: r
  } = e, o = ve(ve(ve({}, r.attributes), n ? {
    title: n
  } : {}), {}, {
    class: r.classes.join(" ")
  }), i = ag(r.styles);
  i.length > 0 && (o.style = i);
  const s = [];
  return s.push({
    tag: "span",
    attributes: o,
    children: [t]
  }), n && s.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [n]
  }), s;
}
const {
  styles: kb
} = ai;
function dx(e) {
  const t = e[0], n = e[1], [r] = e.slice(4);
  let o = null;
  return Array.isArray(r) ? o = {
    tag: "g",
    attributes: {
      class: "".concat(Ne.cssPrefix, "-").concat(xb.GROUP)
    },
    children: [{
      tag: "path",
      attributes: {
        class: "".concat(Ne.cssPrefix, "-").concat(xb.SECONDARY),
        fill: "currentColor",
        d: r[0]
      }
    }, {
      tag: "path",
      attributes: {
        class: "".concat(Ne.cssPrefix, "-").concat(xb.PRIMARY),
        fill: "currentColor",
        d: r[1]
      }
    }]
  } : o = {
    tag: "path",
    attributes: {
      fill: "currentColor",
      d: r
    }
  }, {
    found: !0,
    width: t,
    height: n,
    icon: o
  };
}
const IX = {
  found: !1,
  width: 512,
  height: 512
};
function VX(e, t) {
  !pR && !Ne.showMissingIcons && e && console.error('Icon with name "'.concat(e, '" and prefix "').concat(t, '" is missing.'));
}
function fx(e, t) {
  let n = t;
  return t === "fa" && Ne.styleDefault !== null && (t = es()), new Promise((r, o) => {
    if (n === "fa") {
      const i = NR(e) || {};
      e = i.iconName || e, t = i.prefix || t;
    }
    if (e && t && kb[t] && kb[t][e]) {
      const i = kb[t][e];
      return r(dx(i));
    }
    VX(e, t), r(ve(ve({}, IX), {}, {
      icon: Ne.showMissingIcons && e ? ts("missingIconAbstract") || {} : {}
    }));
  });
}
const h5 = () => {
}, px = Ne.measurePerformance && Jp && Jp.mark && Jp.measure ? Jp : {
  mark: h5,
  measure: h5
}, ld = 'FA "6.7.2"', BX = (e) => (px.mark("".concat(ld, " ").concat(e, " begins")), () => jR(e)), jR = (e) => {
  px.mark("".concat(ld, " ").concat(e, " ends")), px.measure("".concat(ld, " ").concat(e), "".concat(ld, " ").concat(e, " begins"), "".concat(ld, " ").concat(e, " ends"));
};
var n0 = {
  begin: BX,
  end: jR
};
const jh = () => {
};
function m5(e) {
  return typeof (e.getAttribute ? e.getAttribute(el) : null) == "string";
}
function FX(e) {
  const t = e.getAttribute ? e.getAttribute(WS) : null, n = e.getAttribute ? e.getAttribute(GS) : null;
  return t && n;
}
function UX(e) {
  return e && e.classList && e.classList.contains && e.classList.contains(Ne.replacementClass);
}
function HX() {
  return Ne.autoReplaceSvg === !0 ? zh.replace : zh[Ne.autoReplaceSvg] || zh.replace;
}
function $X(e) {
  return Dt.createElementNS("http://www.w3.org/2000/svg", e);
}
function YX(e) {
  return Dt.createElement(e);
}
function zR(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    ceFn: n = e.tag === "svg" ? $X : YX
  } = t;
  if (typeof e == "string")
    return Dt.createTextNode(e);
  const r = n(e.tag);
  return Object.keys(e.attributes || []).forEach(function(o) {
    r.setAttribute(o, e.attributes[o]);
  }), (e.children || []).forEach(function(o) {
    r.appendChild(zR(o, {
      ceFn: n
    }));
  }), r;
}
function qX(e) {
  let t = " ".concat(e.outerHTML, " ");
  return t = "".concat(t, "Font Awesome fontawesome.com "), t;
}
const zh = {
  replace: function(e) {
    const t = e[0];
    if (t.parentNode)
      if (e[1].forEach((n) => {
        t.parentNode.insertBefore(zR(n), t);
      }), t.getAttribute(el) === null && Ne.keepOriginalSource) {
        let n = Dt.createComment(qX(t));
        t.parentNode.replaceChild(n, t);
      } else
        t.remove();
  },
  nest: function(e) {
    const t = e[0], n = e[1];
    if (~KS(t).indexOf(Ne.replacementClass))
      return zh.replace(e);
    const r = new RegExp("".concat(Ne.cssPrefix, "-.*"));
    if (delete n[0].attributes.id, n[0].attributes.class) {
      const i = n[0].attributes.class.split(" ").reduce((s, u) => (u === Ne.replacementClass || u.match(r) ? s.toSvg.push(u) : s.toNode.push(u), s), {
        toNode: [],
        toSvg: []
      });
      n[0].attributes.class = i.toSvg.join(" "), i.toNode.length === 0 ? t.removeAttribute("class") : t.setAttribute("class", i.toNode.join(" "));
    }
    const o = n.map((i) => gf(i)).join(`
`);
    t.setAttribute(el, ""), t.innerHTML = o;
  }
};
function g5(e) {
  e();
}
function TR(e, t) {
  const n = typeof t == "function" ? t : jh;
  if (e.length === 0)
    n();
  else {
    let r = g5;
    Ne.mutateApproach === Gq && (r = Ja.requestAnimationFrame || g5), r(() => {
      const o = HX(), i = n0.begin("mutate");
      e.map(o), i(), n();
    });
  }
}
let r0 = !1;
function DR() {
  r0 = !0;
}
function hx() {
  r0 = !1;
}
let im = null;
function y5(e) {
  if (!r5 || !Ne.observeMutations)
    return;
  const {
    treeCallback: t = jh,
    nodeCallback: n = jh,
    pseudoElementsCallback: r = jh,
    observeMutationsRoot: o = Dt
  } = e;
  im = new r5((i) => {
    if (r0) return;
    const s = es();
    Hu(i).forEach((u) => {
      if (u.type === "childList" && u.addedNodes.length > 0 && !m5(u.addedNodes[0]) && (Ne.searchPseudoElements && r(u.target), t(u.target)), u.type === "attributes" && u.target.parentNode && Ne.searchPseudoElements && r(u.target.parentNode), u.type === "attributes" && m5(u.target) && ~tX.indexOf(u.attributeName))
        if (u.attributeName === "class" && FX(u.target)) {
          const {
            prefix: c,
            iconName: d
          } = lg(KS(u.target));
          u.target.setAttribute(WS, c || s), d && u.target.setAttribute(GS, d);
        } else UX(u.target) && n(u.target);
    });
  }), ia && im.observe(o, {
    childList: !0,
    attributes: !0,
    characterData: !0,
    subtree: !0
  });
}
function XX() {
  im && im.disconnect();
}
function WX(e) {
  const t = e.getAttribute("style");
  let n = [];
  return t && (n = t.split(";").reduce((r, o) => {
    const i = o.split(":"), s = i[0], u = i.slice(1);
    return s && u.length > 0 && (r[s] = u.join(":").trim()), r;
  }, {})), n;
}
function GX(e) {
  const t = e.getAttribute("data-prefix"), n = e.getAttribute("data-icon"), r = e.innerText !== void 0 ? e.innerText.trim() : "";
  let o = lg(KS(e));
  return o.prefix || (o.prefix = es()), t && n && (o.prefix = t, o.iconName = n), o.iconName && o.prefix || (o.prefix && r.length > 0 && (o.iconName = wX(o.prefix, e.innerText) || e0(o.prefix, xR(e.innerText))), !o.iconName && Ne.autoFetchSvg && e.firstChild && e.firstChild.nodeType === Node.TEXT_NODE && (o.iconName = e.firstChild.data)), o;
}
function ZX(e) {
  const t = Hu(e.attributes).reduce((o, i) => (o.name !== "class" && o.name !== "style" && (o[i.name] = i.value), o), {}), n = e.getAttribute("title"), r = e.getAttribute("data-fa-title-id");
  return Ne.autoA11y && (n ? t["aria-labelledby"] = "".concat(Ne.replacementClass, "-title-").concat(r || Vd()) : (t["aria-hidden"] = "true", t.focusable = "false")), t;
}
function KX() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: ii,
    symbol: !1,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function v5(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: !0
  };
  const {
    iconName: n,
    prefix: r,
    rest: o
  } = GX(e), i = ZX(e), s = ux("parseNodeAttributes", {}, e);
  let u = t.styleParser ? WX(e) : [];
  return ve({
    iconName: n,
    title: e.getAttribute("title"),
    titleId: e.getAttribute("data-fa-title-id"),
    prefix: r,
    transform: ii,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: !1,
    extra: {
      classes: o,
      styles: u,
      attributes: i
    }
  }, s);
}
const {
  styles: QX
} = ai;
function PR(e) {
  const t = Ne.autoReplaceSvg === "nest" ? v5(e, {
    styleParser: !1
  }) : v5(e);
  return ~t.extra.classes.indexOf(mR) ? ts("generateLayersText", e, t) : ts("generateSvgReplacementMutation", e, t);
}
function JX() {
  return [...zq, ...nx];
}
function b5(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!ia) return Promise.resolve();
  const n = Dt.documentElement.classList, r = (p) => n.add("".concat(a5, "-").concat(p)), o = (p) => n.remove("".concat(a5, "-").concat(p)), i = Ne.autoFetchSvg ? JX() : lR.concat(Object.keys(QX));
  i.includes("fa") || i.push("fa");
  const s = [".".concat(mR, ":not([").concat(el, "])")].concat(i.map((p) => ".".concat(p, ":not([").concat(el, "])"))).join(", ");
  if (s.length === 0)
    return Promise.resolve();
  let u = [];
  try {
    u = Hu(e.querySelectorAll(s));
  } catch {
  }
  if (u.length > 0)
    r("pending"), o("complete");
  else
    return Promise.resolve();
  const c = n0.begin("onTree"), d = u.reduce((p, h) => {
    try {
      const g = PR(h);
      g && p.push(g);
    } catch (g) {
      pR || g.name === "MissingIcon" && console.error(g);
    }
    return p;
  }, []);
  return new Promise((p, h) => {
    Promise.all(d).then((g) => {
      TR(g, () => {
        r("active"), r("complete"), o("pending"), typeof t == "function" && t(), c(), p();
      });
    }).catch((g) => {
      c(), h(g);
    });
  });
}
function eW(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  PR(e).then((n) => {
    n && TR([n], t);
  });
}
function tW(e) {
  return function(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = (t || {}).icon ? t : cx(t || {});
    let {
      mask: o
    } = n;
    return o && (o = (o || {}).icon ? o : cx(o || {})), e(r, ve(ve({}, n), {}, {
      mask: o
    }));
  };
}
const nW = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    transform: n = ii,
    symbol: r = !1,
    mask: o = null,
    maskId: i = null,
    title: s = null,
    titleId: u = null,
    classes: c = [],
    attributes: d = {},
    styles: p = {}
  } = t;
  if (!e) return;
  const {
    prefix: h,
    iconName: g,
    icon: y
  } = e;
  return ug(ve({
    type: "icon"
  }, e), () => (tl("beforeDOMElementCreation", {
    iconDefinition: e,
    params: t
  }), Ne.autoA11y && (s ? d["aria-labelledby"] = "".concat(Ne.replacementClass, "-title-").concat(u || Vd()) : (d["aria-hidden"] = "true", d.focusable = "false")), t0({
    icons: {
      main: dx(y),
      mask: o ? dx(o.icon) : {
        found: !1,
        width: null,
        height: null,
        icon: {}
      }
    },
    prefix: h,
    iconName: g,
    transform: ve(ve({}, ii), n),
    symbol: r,
    title: s,
    maskId: i,
    titleId: u,
    extra: {
      attributes: d,
      styles: p,
      classes: c
    }
  })));
};
var rW = {
  mixout() {
    return {
      icon: tW(nW)
    };
  },
  hooks() {
    return {
      mutationObserverCallbacks(e) {
        return e.treeCallback = b5, e.nodeCallback = eW, e;
      }
    };
  },
  provides(e) {
    e.i2svg = function(t) {
      const {
        node: n = Dt,
        callback: r = () => {
        }
      } = t;
      return b5(n, r);
    }, e.generateSvgReplacementMutation = function(t, n) {
      const {
        iconName: r,
        title: o,
        titleId: i,
        prefix: s,
        transform: u,
        symbol: c,
        mask: d,
        maskId: p,
        extra: h
      } = n;
      return new Promise((g, y) => {
        Promise.all([fx(r, s), d.iconName ? fx(d.iconName, d.prefix) : Promise.resolve({
          found: !1,
          width: 512,
          height: 512,
          icon: {}
        })]).then((b) => {
          let [v, x] = b;
          g([t, t0({
            icons: {
              main: v,
              mask: x
            },
            prefix: s,
            iconName: r,
            transform: u,
            symbol: c,
            maskId: p,
            title: o,
            titleId: i,
            extra: h,
            watchable: !0
          })]);
        }).catch(y);
      });
    }, e.generateAbstractIcon = function(t) {
      let {
        children: n,
        attributes: r,
        main: o,
        transform: i,
        styles: s
      } = t;
      const u = ag(s);
      u.length > 0 && (r.style = u);
      let c;
      return QS(i) && (c = ts("generateAbstractTransformGrouping", {
        main: o,
        transform: i,
        containerWidth: o.width,
        iconWidth: o.width
      })), n.push(c || o.icon), {
        children: n,
        attributes: r
      };
    };
  }
}, oW = {
  mixout() {
    return {
      layer(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          classes: n = []
        } = t;
        return ug({
          type: "layer"
        }, () => {
          tl("beforeDOMElementCreation", {
            assembler: e,
            params: t
          });
          let r = [];
          return e((o) => {
            Array.isArray(o) ? o.map((i) => {
              r = r.concat(i.abstract);
            }) : r = r.concat(o.abstract);
          }), [{
            tag: "span",
            attributes: {
              class: ["".concat(Ne.cssPrefix, "-layers"), ...n].join(" ")
            },
            children: r
          }];
        });
      }
    };
  }
}, iW = {
  mixout() {
    return {
      counter(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          title: n = null,
          classes: r = [],
          attributes: o = {},
          styles: i = {}
        } = t;
        return ug({
          type: "counter",
          content: e
        }, () => (tl("beforeDOMElementCreation", {
          content: e,
          params: t
        }), LX({
          content: e.toString(),
          title: n,
          extra: {
            attributes: o,
            styles: i,
            classes: ["".concat(Ne.cssPrefix, "-layers-counter"), ...r]
          }
        })));
      }
    };
  }
}, aW = {
  mixout() {
    return {
      text(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          transform: n = ii,
          title: r = null,
          classes: o = [],
          attributes: i = {},
          styles: s = {}
        } = t;
        return ug({
          type: "text",
          content: e
        }, () => (tl("beforeDOMElementCreation", {
          content: e,
          params: t
        }), p5({
          content: e,
          transform: ve(ve({}, ii), n),
          title: r,
          extra: {
            attributes: i,
            styles: s,
            classes: ["".concat(Ne.cssPrefix, "-layers-text"), ...o]
          }
        })));
      }
    };
  },
  provides(e) {
    e.generateLayersText = function(t, n) {
      const {
        title: r,
        transform: o,
        extra: i
      } = n;
      let s = null, u = null;
      if (aR) {
        const c = parseInt(getComputedStyle(t).fontSize, 10), d = t.getBoundingClientRect();
        s = d.width / c, u = d.height / c;
      }
      return Ne.autoA11y && !r && (i.attributes["aria-hidden"] = "true"), Promise.resolve([t, p5({
        content: t.innerHTML,
        width: s,
        height: u,
        transform: o,
        title: r,
        extra: i,
        watchable: !0
      })]);
    };
  }
};
const sW = new RegExp('"', "ug"), w5 = [1105920, 1112319], x5 = ve(ve(ve(ve({}, {
  FontAwesome: {
    normal: "fas",
    400: "fas"
  }
}), Mq), Xq), Bq), mx = Object.keys(x5).reduce((e, t) => (e[t.toLowerCase()] = x5[t], e), {}), lW = Object.keys(mx).reduce((e, t) => {
  const n = mx[t];
  return e[t] = n[900] || [...Object.entries(n)][0][1], e;
}, {});
function uW(e) {
  const t = e.replace(sW, ""), n = mX(t, 0), r = n >= w5[0] && n <= w5[1], o = t.length === 2 ? t[0] === t[1] : !1;
  return {
    value: xR(o ? t[0] : t),
    isSecondary: r || o
  };
}
function cW(e, t) {
  const n = e.replace(/^['"]|['"]$/g, "").toLowerCase(), r = parseInt(t), o = isNaN(r) ? "normal" : r;
  return (mx[n] || {})[o] || lW[n];
}
function S5(e, t) {
  const n = "".concat(Wq).concat(t.replace(":", "-"));
  return new Promise((r, o) => {
    if (e.getAttribute(n) !== null)
      return r();
    const i = Hu(e.children).filter((h) => h.getAttribute(ox) === t)[0], s = Ja.getComputedStyle(e, t), u = s.getPropertyValue("font-family"), c = u.match(Jq), d = s.getPropertyValue("font-weight"), p = s.getPropertyValue("content");
    if (i && !c)
      return e.removeChild(i), r();
    if (c && p !== "none" && p !== "") {
      const h = s.getPropertyValue("content");
      let g = cW(u, d);
      const {
        value: y,
        isSecondary: b
      } = uW(h), v = c[0].startsWith("FontAwesome");
      let x = e0(g, y), _ = x;
      if (v) {
        const O = xX(y);
        O.iconName && O.prefix && (x = O.iconName, g = O.prefix);
      }
      if (x && !b && (!i || i.getAttribute(WS) !== g || i.getAttribute(GS) !== _)) {
        e.setAttribute(n, _), i && e.removeChild(i);
        const O = KX(), {
          extra: C
        } = O;
        C.attributes[ox] = t, fx(x, g).then((N) => {
          const R = t0(ve(ve({}, O), {}, {
            icons: {
              main: N,
              mask: MR()
            },
            prefix: g,
            iconName: _,
            extra: C,
            watchable: !0
          })), z = Dt.createElementNS("http://www.w3.org/2000/svg", "svg");
          t === "::before" ? e.insertBefore(z, e.firstChild) : e.appendChild(z), z.outerHTML = R.map((j) => gf(j)).join(`
`), e.removeAttribute(n), r();
        }).catch(o);
      } else
        r();
    } else
      r();
  });
}
function dW(e) {
  return Promise.all([S5(e, "::before"), S5(e, "::after")]);
}
function fW(e) {
  return e.parentNode !== document.head && !~Zq.indexOf(e.tagName.toUpperCase()) && !e.getAttribute(ox) && (!e.parentNode || e.parentNode.tagName !== "svg");
}
function _5(e) {
  if (ia)
    return new Promise((t, n) => {
      const r = Hu(e.querySelectorAll("*")).filter(fW).map(dW), o = n0.begin("searchPseudoElements");
      DR(), Promise.all(r).then(() => {
        o(), hx(), t();
      }).catch(() => {
        o(), hx(), n();
      });
    });
}
var pW = {
  hooks() {
    return {
      mutationObserverCallbacks(e) {
        return e.pseudoElementsCallback = _5, e;
      }
    };
  },
  provides(e) {
    e.pseudoElements2svg = function(t) {
      const {
        node: n = Dt
      } = t;
      Ne.searchPseudoElements && _5(n);
    };
  }
};
let k5 = !1;
var hW = {
  mixout() {
    return {
      dom: {
        unwatch() {
          DR(), k5 = !0;
        }
      }
    };
  },
  hooks() {
    return {
      bootstrap() {
        y5(ux("mutationObserverCallbacks", {}));
      },
      noAuto() {
        XX();
      },
      watch(e) {
        const {
          observeMutationsRoot: t
        } = e;
        k5 ? hx() : y5(ux("mutationObserverCallbacks", {
          observeMutationsRoot: t
        }));
      }
    };
  }
};
const E5 = (e) => {
  let t = {
    size: 16,
    x: 0,
    y: 0,
    flipX: !1,
    flipY: !1,
    rotate: 0
  };
  return e.toLowerCase().split(" ").reduce((n, r) => {
    const o = r.toLowerCase().split("-"), i = o[0];
    let s = o.slice(1).join("-");
    if (i && s === "h")
      return n.flipX = !0, n;
    if (i && s === "v")
      return n.flipY = !0, n;
    if (s = parseFloat(s), isNaN(s))
      return n;
    switch (i) {
      case "grow":
        n.size = n.size + s;
        break;
      case "shrink":
        n.size = n.size - s;
        break;
      case "left":
        n.x = n.x - s;
        break;
      case "right":
        n.x = n.x + s;
        break;
      case "up":
        n.y = n.y - s;
        break;
      case "down":
        n.y = n.y + s;
        break;
      case "rotate":
        n.rotate = n.rotate + s;
        break;
    }
    return n;
  }, t);
};
var mW = {
  mixout() {
    return {
      parse: {
        transform: (e) => E5(e)
      }
    };
  },
  hooks() {
    return {
      parseNodeAttributes(e, t) {
        const n = t.getAttribute("data-fa-transform");
        return n && (e.transform = E5(n)), e;
      }
    };
  },
  provides(e) {
    e.generateAbstractTransformGrouping = function(t) {
      let {
        main: n,
        transform: r,
        containerWidth: o,
        iconWidth: i
      } = t;
      const s = {
        transform: "translate(".concat(o / 2, " 256)")
      }, u = "translate(".concat(r.x * 32, ", ").concat(r.y * 32, ") "), c = "scale(".concat(r.size / 16 * (r.flipX ? -1 : 1), ", ").concat(r.size / 16 * (r.flipY ? -1 : 1), ") "), d = "rotate(".concat(r.rotate, " 0 0)"), p = {
        transform: "".concat(u, " ").concat(c, " ").concat(d)
      }, h = {
        transform: "translate(".concat(i / 2 * -1, " -256)")
      }, g = {
        outer: s,
        inner: p,
        path: h
      };
      return {
        tag: "g",
        attributes: ve({}, g.outer),
        children: [{
          tag: "g",
          attributes: ve({}, g.inner),
          children: [{
            tag: n.icon.tag,
            children: n.icon.children,
            attributes: ve(ve({}, n.icon.attributes), g.path)
          }]
        }]
      };
    };
  }
};
const Eb = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function C5(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return e.attributes && (e.attributes.fill || t) && (e.attributes.fill = "black"), e;
}
function gW(e) {
  return e.tag === "g" ? e.children : [e];
}
var yW = {
  hooks() {
    return {
      parseNodeAttributes(e, t) {
        const n = t.getAttribute("data-fa-mask"), r = n ? lg(n.split(" ").map((o) => o.trim())) : MR();
        return r.prefix || (r.prefix = es()), e.mask = r, e.maskId = t.getAttribute("data-fa-mask-id"), e;
      }
    };
  },
  provides(e) {
    e.generateAbstractMask = function(t) {
      let {
        children: n,
        attributes: r,
        main: o,
        mask: i,
        maskId: s,
        transform: u
      } = t;
      const {
        width: c,
        icon: d
      } = o, {
        width: p,
        icon: h
      } = i, g = uX({
        transform: u,
        containerWidth: p,
        iconWidth: c
      }), y = {
        tag: "rect",
        attributes: ve(ve({}, Eb), {}, {
          fill: "white"
        })
      }, b = d.children ? {
        children: d.children.map(C5)
      } : {}, v = {
        tag: "g",
        attributes: ve({}, g.inner),
        children: [C5(ve({
          tag: d.tag,
          attributes: ve(ve({}, d.attributes), g.path)
        }, b))]
      }, x = {
        tag: "g",
        attributes: ve({}, g.outer),
        children: [v]
      }, _ = "mask-".concat(s || Vd()), O = "clip-".concat(s || Vd()), C = {
        tag: "mask",
        attributes: ve(ve({}, Eb), {}, {
          id: _,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        }),
        children: [y, x]
      }, N = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: O
          },
          children: gW(h)
        }, C]
      };
      return n.push(N, {
        tag: "rect",
        attributes: ve({
          fill: "currentColor",
          "clip-path": "url(#".concat(O, ")"),
          mask: "url(#".concat(_, ")")
        }, Eb)
      }), {
        children: n,
        attributes: r
      };
    };
  }
}, vW = {
  provides(e) {
    let t = !1;
    Ja.matchMedia && (t = Ja.matchMedia("(prefers-reduced-motion: reduce)").matches), e.missingIconAbstract = function() {
      const n = [], r = {
        fill: "currentColor"
      }, o = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      n.push({
        tag: "path",
        attributes: ve(ve({}, r), {}, {
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        })
      });
      const i = ve(ve({}, o), {}, {
        attributeName: "opacity"
      }), s = {
        tag: "circle",
        attributes: ve(ve({}, r), {}, {
          cx: "256",
          cy: "364",
          r: "28"
        }),
        children: []
      };
      return t || s.children.push({
        tag: "animate",
        attributes: ve(ve({}, o), {}, {
          attributeName: "r",
          values: "28;14;28;28;14;28;"
        })
      }, {
        tag: "animate",
        attributes: ve(ve({}, i), {}, {
          values: "1;0;1;1;0;1;"
        })
      }), n.push(s), n.push({
        tag: "path",
        attributes: ve(ve({}, r), {}, {
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        }),
        children: t ? [] : [{
          tag: "animate",
          attributes: ve(ve({}, i), {}, {
            values: "1;0;0;0;0;1;"
          })
        }]
      }), t || n.push({
        tag: "path",
        attributes: ve(ve({}, r), {}, {
          opacity: "0",
          d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
        }),
        children: [{
          tag: "animate",
          attributes: ve(ve({}, i), {}, {
            values: "0;0;1;1;0;0;"
          })
        }]
      }), {
        tag: "g",
        attributes: {
          class: "missing"
        },
        children: n
      };
    };
  }
}, bW = {
  hooks() {
    return {
      parseNodeAttributes(e, t) {
        const n = t.getAttribute("data-fa-symbol"), r = n === null ? !1 : n === "" ? !0 : n;
        return e.symbol = r, e;
      }
    };
  }
}, wW = [fX, rW, oW, iW, aW, pW, hW, mW, yW, vW, bW];
MX(wW, {
  mixoutsTo: $r
});
$r.noAuto;
const xW = $r.config;
$r.library;
$r.dom;
const gx = $r.parse;
$r.findIconDefinition;
$r.toHtml;
const SW = $r.icon;
$r.layer;
$r.text;
$r.counter;
var Cb = { exports: {} }, O5 = { exports: {} }, yt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var A5;
function _W() {
  if (A5) return yt;
  A5 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, u = e ? Symbol.for("react.context") : 60110, c = e ? Symbol.for("react.async_mode") : 60111, d = e ? Symbol.for("react.concurrent_mode") : 60111, p = e ? Symbol.for("react.forward_ref") : 60112, h = e ? Symbol.for("react.suspense") : 60113, g = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, b = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, x = e ? Symbol.for("react.fundamental") : 60117, _ = e ? Symbol.for("react.responder") : 60118, O = e ? Symbol.for("react.scope") : 60119;
  function C(R) {
    if (typeof R == "object" && R !== null) {
      var z = R.$$typeof;
      switch (z) {
        case t:
          switch (R = R.type, R) {
            case c:
            case d:
            case r:
            case i:
            case o:
            case h:
              return R;
            default:
              switch (R = R && R.$$typeof, R) {
                case u:
                case p:
                case b:
                case y:
                case s:
                  return R;
                default:
                  return z;
              }
          }
        case n:
          return z;
      }
    }
  }
  function N(R) {
    return C(R) === d;
  }
  return yt.AsyncMode = c, yt.ConcurrentMode = d, yt.ContextConsumer = u, yt.ContextProvider = s, yt.Element = t, yt.ForwardRef = p, yt.Fragment = r, yt.Lazy = b, yt.Memo = y, yt.Portal = n, yt.Profiler = i, yt.StrictMode = o, yt.Suspense = h, yt.isAsyncMode = function(R) {
    return N(R) || C(R) === c;
  }, yt.isConcurrentMode = N, yt.isContextConsumer = function(R) {
    return C(R) === u;
  }, yt.isContextProvider = function(R) {
    return C(R) === s;
  }, yt.isElement = function(R) {
    return typeof R == "object" && R !== null && R.$$typeof === t;
  }, yt.isForwardRef = function(R) {
    return C(R) === p;
  }, yt.isFragment = function(R) {
    return C(R) === r;
  }, yt.isLazy = function(R) {
    return C(R) === b;
  }, yt.isMemo = function(R) {
    return C(R) === y;
  }, yt.isPortal = function(R) {
    return C(R) === n;
  }, yt.isProfiler = function(R) {
    return C(R) === i;
  }, yt.isStrictMode = function(R) {
    return C(R) === o;
  }, yt.isSuspense = function(R) {
    return C(R) === h;
  }, yt.isValidElementType = function(R) {
    return typeof R == "string" || typeof R == "function" || R === r || R === d || R === i || R === o || R === h || R === g || typeof R == "object" && R !== null && (R.$$typeof === b || R.$$typeof === y || R.$$typeof === s || R.$$typeof === u || R.$$typeof === p || R.$$typeof === x || R.$$typeof === _ || R.$$typeof === O || R.$$typeof === v);
  }, yt.typeOf = C, yt;
}
var N5;
function kW() {
  return N5 || (N5 = 1, O5.exports = _W()), O5.exports;
}
var Ob, M5;
function EW() {
  if (M5) return Ob;
  M5 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Ob = e, Ob;
}
var Ab, R5;
function CW() {
  if (R5) return Ab;
  R5 = 1;
  var e = /* @__PURE__ */ EW();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Ab = function() {
    function r(s, u, c, d, p, h) {
      if (h !== e) {
        var g = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw g.name = "Invariant Violation", g;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Ab;
}
var j5;
function OW() {
  return j5 || (j5 = 1, Cb.exports = /* @__PURE__ */ CW()()), Cb.exports;
}
var cn = /* @__PURE__ */ OW();
const Ge = /* @__PURE__ */ Dm(cn);
function z5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ei(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? z5(Object(n), !0).forEach(function(r) {
      du(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : z5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function am(e) {
  "@babel/helpers - typeof";
  return am = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, am(e);
}
function du(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function AW(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function NW(e, t) {
  if (e == null) return {};
  var n = AW(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function yx(e) {
  return MW(e) || RW(e) || jW(e) || zW();
}
function MW(e) {
  if (Array.isArray(e)) return vx(e);
}
function RW(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function jW(e, t) {
  if (e) {
    if (typeof e == "string") return vx(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return vx(e, t);
  }
}
function vx(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function zW() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function TW(e) {
  var t, n = e.beat, r = e.fade, o = e.beatFade, i = e.bounce, s = e.shake, u = e.flash, c = e.spin, d = e.spinPulse, p = e.spinReverse, h = e.pulse, g = e.fixedWidth, y = e.inverse, b = e.border, v = e.listItem, x = e.flip, _ = e.size, O = e.rotation, C = e.pull, N = (t = {
    "fa-beat": n,
    "fa-fade": r,
    "fa-beat-fade": o,
    "fa-bounce": i,
    "fa-shake": s,
    "fa-flash": u,
    "fa-spin": c,
    "fa-spin-reverse": p,
    "fa-spin-pulse": d,
    "fa-pulse": h,
    "fa-fw": g,
    "fa-inverse": y,
    "fa-border": b,
    "fa-li": v,
    "fa-flip": x === !0,
    "fa-flip-horizontal": x === "horizontal" || x === "both",
    "fa-flip-vertical": x === "vertical" || x === "both"
  }, du(t, "fa-".concat(_), typeof _ < "u" && _ !== null), du(t, "fa-rotate-".concat(O), typeof O < "u" && O !== null && O !== 0), du(t, "fa-pull-".concat(C), typeof C < "u" && C !== null), du(t, "fa-swap-opacity", e.swapOpacity), t);
  return Object.keys(N).map(function(R) {
    return N[R] ? R : null;
  }).filter(function(R) {
    return R;
  });
}
function DW(e) {
  return e = e - 0, e === e;
}
function LR(e) {
  return DW(e) ? e : (e = e.replace(/[\-_\s]+(.)?/g, function(t, n) {
    return n ? n.toUpperCase() : "";
  }), e.substr(0, 1).toLowerCase() + e.substr(1));
}
var PW = ["style"];
function LW(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function IW(e) {
  return e.split(";").map(function(t) {
    return t.trim();
  }).filter(function(t) {
    return t;
  }).reduce(function(t, n) {
    var r = n.indexOf(":"), o = LR(n.slice(0, r)), i = n.slice(r + 1).trim();
    return o.startsWith("webkit") ? t[LW(o)] = i : t[o] = i, t;
  }, {});
}
function IR(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof t == "string")
    return t;
  var r = (t.children || []).map(function(c) {
    return IR(e, c);
  }), o = Object.keys(t.attributes || {}).reduce(function(c, d) {
    var p = t.attributes[d];
    switch (d) {
      case "class":
        c.attrs.className = p, delete t.attributes.class;
        break;
      case "style":
        c.attrs.style = IW(p);
        break;
      default:
        d.indexOf("aria-") === 0 || d.indexOf("data-") === 0 ? c.attrs[d.toLowerCase()] = p : c.attrs[LR(d)] = p;
    }
    return c;
  }, {
    attrs: {}
  }), i = n.style, s = i === void 0 ? {} : i, u = NW(n, PW);
  return o.attrs.style = ei(ei({}, o.attrs.style), s), e.apply(void 0, [t.tag, ei(ei({}, o.attrs), u)].concat(yx(r)));
}
var VR = !1;
try {
  VR = !0;
} catch {
}
function VW() {
  if (!VR && console && typeof console.error == "function") {
    var e;
    (e = console).error.apply(e, arguments);
  }
}
function T5(e) {
  if (e && am(e) === "object" && e.prefix && e.iconName && e.icon)
    return e;
  if (gx.icon)
    return gx.icon(e);
  if (e === null)
    return null;
  if (e && am(e) === "object" && e.prefix && e.iconName)
    return e;
  if (Array.isArray(e) && e.length === 2)
    return {
      prefix: e[0],
      iconName: e[1]
    };
  if (typeof e == "string")
    return {
      prefix: "fas",
      iconName: e
    };
}
function Nb(e, t) {
  return Array.isArray(t) && t.length > 0 || !Array.isArray(t) && t ? du({}, e, t) : {};
}
var D5 = {
  border: !1,
  className: "",
  mask: null,
  maskId: null,
  fixedWidth: !1,
  inverse: !1,
  flip: !1,
  icon: null,
  listItem: !1,
  pull: null,
  pulse: !1,
  rotation: null,
  size: null,
  spin: !1,
  spinPulse: !1,
  spinReverse: !1,
  beat: !1,
  fade: !1,
  beatFade: !1,
  bounce: !1,
  shake: !1,
  symbol: !1,
  title: "",
  titleId: null,
  transform: null,
  swapOpacity: !1
}, o0 = /* @__PURE__ */ Qe.forwardRef(function(e, t) {
  var n = ei(ei({}, D5), e), r = n.icon, o = n.mask, i = n.symbol, s = n.className, u = n.title, c = n.titleId, d = n.maskId, p = T5(r), h = Nb("classes", [].concat(yx(TW(n)), yx((s || "").split(" ")))), g = Nb("transform", typeof n.transform == "string" ? gx.transform(n.transform) : n.transform), y = Nb("mask", T5(o)), b = SW(p, ei(ei(ei(ei({}, h), g), y), {}, {
    symbol: i,
    title: u,
    titleId: c,
    maskId: d
  }));
  if (!b)
    return VW("Could not find icon", p), null;
  var v = b.abstract, x = {
    ref: t
  };
  return Object.keys(n).forEach(function(_) {
    D5.hasOwnProperty(_) || (x[_] = n[_]);
  }), BW(v[0], x);
});
o0.displayName = "FontAwesomeIcon";
o0.propTypes = {
  beat: Ge.bool,
  border: Ge.bool,
  beatFade: Ge.bool,
  bounce: Ge.bool,
  className: Ge.string,
  fade: Ge.bool,
  flash: Ge.bool,
  mask: Ge.oneOfType([Ge.object, Ge.array, Ge.string]),
  maskId: Ge.string,
  fixedWidth: Ge.bool,
  inverse: Ge.bool,
  flip: Ge.oneOf([!0, !1, "horizontal", "vertical", "both"]),
  icon: Ge.oneOfType([Ge.object, Ge.array, Ge.string]),
  listItem: Ge.bool,
  pull: Ge.oneOf(["right", "left"]),
  pulse: Ge.bool,
  rotation: Ge.oneOf([0, 90, 180, 270]),
  shake: Ge.bool,
  size: Ge.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
  spin: Ge.bool,
  spinPulse: Ge.bool,
  spinReverse: Ge.bool,
  symbol: Ge.oneOfType([Ge.bool, Ge.string]),
  title: Ge.string,
  titleId: Ge.string,
  transform: Ge.oneOfType([Ge.string, Ge.object]),
  swapOpacity: Ge.bool
};
var BW = IR.bind(null, Qe.createElement);
/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */
const FW = {
  prefix: "fas",
  iconName: "down-left-and-up-right-to-center",
  icon: [512, 512, ["compress-alt"], "f422", "M439 7c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2s-12.5 14.8-22.2 14.8l-144 0c-13.3 0-24-10.7-24-24l0-144c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2l39 39L439 7zM72 272l144 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39L73 505c-9.4 9.4-24.6 9.4-33.9 0L7 473c-9.4-9.4-9.4-24.6 0-33.9l87-87L55 313c-6.9-6.9-8.9-17.2-5.2-26.2s12.5-14.8 22.2-14.8z"]
}, UW = {
  prefix: "fas",
  iconName: "bars",
  icon: [448, 512, ["navicon"], "f0c9", "M0 96C0 78.3 14.3 64 32 64l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 128C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 288c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32L32 448c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"]
}, HW = {
  prefix: "fas",
  iconName: "compress",
  icon: [448, 512, [], "f066", "M160 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96zM32 320c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM352 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 320c-17.7 0-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0z"]
}, $W = {
  prefix: "fas",
  iconName: "lock",
  icon: [448, 512, [128274], "f023", "M144 144l0 48 160 0 0-48c0-44.2-35.8-80-80-80s-80 35.8-80 80zM80 192l0-48C80 64.5 144.5 0 224 0s144 64.5 144 144l0 48 16 0c35.3 0 64 28.7 64 64l0 192c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 256c0-35.3 28.7-64 64-64l16 0z"]
}, YW = {
  prefix: "fas",
  iconName: "chevron-up",
  icon: [512, 512, [], "f077", "M233.4 105.4c12.5-12.5 32.8-12.5 45.3 0l192 192c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L256 173.3 86.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l192-192z"]
}, qW = {
  prefix: "fas",
  iconName: "circle-play",
  icon: [512, 512, [61469, "play-circle"], "f144", "M0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256zM188.3 147.1c-7.6 4.2-12.3 12.3-12.3 20.9l0 176c0 8.7 4.7 16.7 12.3 20.9s16.8 4.1 24.3-.5l144-88c7.1-4.4 11.5-12.1 11.5-20.5s-4.4-16.1-11.5-20.5l-144-88c-7.4-4.5-16.7-4.7-24.3-.5z"]
}, XW = {
  prefix: "fas",
  iconName: "lock-open",
  icon: [576, 512, [], "f3c1", "M352 144c0-44.2 35.8-80 80-80s80 35.8 80 80l0 48c0 17.7 14.3 32 32 32s32-14.3 32-32l0-48C576 64.5 511.5 0 432 0S288 64.5 288 144l0 48L64 192c-35.3 0-64 28.7-64 64L0 448c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-192c0-35.3-28.7-64-64-64l-32 0 0-48z"]
}, WW = {
  prefix: "fas",
  iconName: "network-wired",
  icon: [640, 512, [], "f6ff", "M256 64l128 0 0 64-128 0 0-64zM240 0c-26.5 0-48 21.5-48 48l0 96c0 26.5 21.5 48 48 48l48 0 0 32L32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0 0 32-48 0c-26.5 0-48 21.5-48 48l0 96c0 26.5 21.5 48 48 48l160 0c26.5 0 48-21.5 48-48l0-96c0-26.5-21.5-48-48-48l-48 0 0-32 256 0 0 32-48 0c-26.5 0-48 21.5-48 48l0 96c0 26.5 21.5 48 48 48l160 0c26.5 0 48-21.5 48-48l0-96c0-26.5-21.5-48-48-48l-48 0 0-32 96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-256 0 0-32 48 0c26.5 0 48-21.5 48-48l0-96c0-26.5-21.5-48-48-48L240 0zM96 448l0-64 128 0 0 64L96 448zm320-64l128 0 0 64-128 0 0-64z"]
}, GW = {
  prefix: "fas",
  iconName: "magnifying-glass",
  icon: [512, 512, [128269, "search"], "f002", "M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"]
}, ZW = {
  prefix: "fas",
  iconName: "chevron-down",
  icon: [512, 512, [], "f078", "M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"]
}, KW = {
  prefix: "fas",
  iconName: "expand",
  icon: [448, 512, [], "f065", "M32 32C14.3 32 0 46.3 0 64l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 32zM64 352c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 32c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM448 352c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96z"]
}, QW = {
  prefix: "fas",
  iconName: "xmark",
  icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"]
}, JW = {
  prefix: "fas",
  iconName: "chevron-left",
  icon: [320, 512, [9001], "f053", "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z"]
}, eG = {
  prefix: "fas",
  iconName: "chevron-right",
  icon: [320, 512, [9002], "f054", "M310.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L242.7 256 73.4 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z"]
}, tG = {
  prefix: "fas",
  iconName: "up-right-and-down-left-from-center",
  icon: [512, 512, ["expand-alt"], "f424", "M344 0L488 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39-87 87c-9.4 9.4-24.6 9.4-33.9 0l-32-32c-9.4-9.4-9.4-24.6 0-33.9l87-87L327 41c-6.9-6.9-8.9-17.2-5.2-26.2S334.3 0 344 0zM168 512L24 512c-13.3 0-24-10.7-24-24L0 344c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2l39 39 87-87c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2s-12.5 14.8-22.2 14.8z"]
};
xW.autoAddCss = !1;
const nr = (e) => {
  const { style: t, ...n } = e;
  return /* @__PURE__ */ E.jsx("span", { style: { marginLeft: "5px", ...t }, children: /* @__PURE__ */ E.jsx(o0, { ...n }) });
}, BR = (e) => /* @__PURE__ */ E.jsx(nr, { ...e, icon: UW }), bx = (e) => /* @__PURE__ */ E.jsx(nr, { ...e, icon: eG }), P5 = (e) => /* @__PURE__ */ E.jsx(nr, { ...e, icon: JW }), FR = (e) => /* @__PURE__ */ E.jsx(nr, { ...e, icon: KW }), nG = (e) => /* @__PURE__ */ E.jsx(nr, { ...e, icon: HW }), rG = (e) => /* @__PURE__ */ E.jsx(nr, { ...e, icon: FW }), oG = (e) => /* @__PURE__ */ E.jsx(nr, { ...e, icon: tG }), L5 = (e) => /* @__PURE__ */ E.jsx(nr, { ...e, icon: ZW }), wx = (e) => /* @__PURE__ */ E.jsx(nr, { ...e, icon: YW }), yf = wx, UR = (e) => /* @__PURE__ */ E.jsx(nr, { ...e, icon: QW }), iG = (e) => /* @__PURE__ */ E.jsx(nr, { ...e, icon: XW }), aG = (e) => /* @__PURE__ */ E.jsx(nr, { ...e, icon: $W }), sG = (e) => /* @__PURE__ */ E.jsx(nr, { ...e, icon: WW }), lG = (e) => /* @__PURE__ */ E.jsx(nr, { ...e, icon: qW }), uG = (e) => /* @__PURE__ */ E.jsx(nr, { ...e, icon: GW }), $u = ({
  trigger: e,
  title: t,
  description: n,
  children: r,
  closebutton: o = !0,
  onOpenChange: i,
  buttons: s = [],
  open: u,
  setOpen: c,
  modal: d = !0
}) => {
  const p = (y) => {
    c && c(y), i && i(y);
  }, h = S.useContext(it).local_state((y) => y.funcnodescontainerRef), g = /* @__PURE__ */ E.jsx(vq, { asChild: !0, children: /* @__PURE__ */ E.jsxs("div", { className: "dialogconent funcnodescontainer", children: [
    t && /* @__PURE__ */ E.jsx(bq, { className: "dialogtitle", children: t }),
    /* @__PURE__ */ E.jsx(wq, { className: "dialogdescription", children: n }),
    /* @__PURE__ */ E.jsx("div", { className: "dialogchildren", children: r }),
    /* @__PURE__ */ E.jsx(
      "div",
      {
        style: {
          display: "flex",
          marginTop: 25,
          justifyContent: "flex-end"
        },
        children: (s || []).map((y, b) => /* @__PURE__ */ E.jsx(JO, { asChild: !0, children: /* @__PURE__ */ E.jsx("button", { className: "dialogsendbutton", onClick: y.onClick, children: y.text }) }, b))
      }
    ),
    o && /* @__PURE__ */ E.jsx(JO, { asChild: !0, children: /* @__PURE__ */ E.jsx("button", { className: "dialogclosebutton", "aria-label": "Close", children: /* @__PURE__ */ E.jsx(UR, {}) }) })
  ] }) });
  return /* @__PURE__ */ E.jsxs(hq, { open: u, onOpenChange: p, modal: d, children: [
    e && /* @__PURE__ */ E.jsx(mq, { asChild: !0, children: e }),
    /* @__PURE__ */ E.jsxs(gq, { container: h, children: [
      /* @__PURE__ */ E.jsx(yq, { className: "dialogoverlay funcnodescontainer" }),
      g
    ] })
  ] });
};
function i0(e) {
  const t = e + "CollectionProvider", [n, r] = us(t), [o, i] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), s = (v) => {
    const { scope: x, children: _ } = v, O = Qe.useRef(null), C = Qe.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ E.jsx(o, { scope: x, itemMap: C, collectionRef: O, children: _ });
  };
  s.displayName = t;
  const u = e + "CollectionSlot", c = /* @__PURE__ */ ju(u), d = Qe.forwardRef(
    (v, x) => {
      const { scope: _, children: O } = v, C = i(u, _), N = Ut(x, C.collectionRef);
      return /* @__PURE__ */ E.jsx(c, { ref: N, children: O });
    }
  );
  d.displayName = u;
  const p = e + "CollectionItemSlot", h = "data-radix-collection-item", g = /* @__PURE__ */ ju(p), y = Qe.forwardRef(
    (v, x) => {
      const { scope: _, children: O, ...C } = v, N = Qe.useRef(null), R = Ut(x, N), z = i(p, _);
      return Qe.useEffect(() => (z.itemMap.set(N, { ref: N, ...C }), () => void z.itemMap.delete(N))), /* @__PURE__ */ E.jsx(g, { [h]: "", ref: R, children: O });
    }
  );
  y.displayName = p;
  function b(v) {
    const x = i(e + "CollectionConsumer", v);
    return Qe.useCallback(() => {
      const _ = x.collectionRef.current;
      if (!_) return [];
      const O = Array.from(_.querySelectorAll(`[${h}]`));
      return Array.from(x.itemMap.values()).sort(
        (C, N) => O.indexOf(C.ref.current) - O.indexOf(N.ref.current)
      );
    }, [x.collectionRef, x.itemMap]);
  }
  return [
    { Provider: s, Slot: d, ItemSlot: y },
    b,
    r
  ];
}
var cG = S.createContext(void 0);
function a0(e) {
  const t = S.useContext(cG);
  return e || t || "ltr";
}
const dG = ["top", "right", "bottom", "left"], ns = Math.min, Dr = Math.max, sm = Math.round, th = Math.floor, ci = (e) => ({
  x: e,
  y: e
}), fG = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, pG = {
  start: "end",
  end: "start"
};
function xx(e, t, n) {
  return Dr(e, ns(t, n));
}
function Qi(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Ji(e) {
  return e.split("-")[0];
}
function Yu(e) {
  return e.split("-")[1];
}
function s0(e) {
  return e === "x" ? "y" : "x";
}
function l0(e) {
  return e === "y" ? "height" : "width";
}
function rs(e) {
  return ["top", "bottom"].includes(Ji(e)) ? "y" : "x";
}
function u0(e) {
  return s0(rs(e));
}
function hG(e, t, n) {
  n === void 0 && (n = !1);
  const r = Yu(e), o = u0(e), i = l0(o);
  let s = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[i] > t.floating[i] && (s = lm(s)), [s, lm(s)];
}
function mG(e) {
  const t = lm(e);
  return [Sx(e), t, Sx(t)];
}
function Sx(e) {
  return e.replace(/start|end/g, (t) => pG[t]);
}
function gG(e, t, n) {
  const r = ["left", "right"], o = ["right", "left"], i = ["top", "bottom"], s = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? o : r : t ? r : o;
    case "left":
    case "right":
      return t ? i : s;
    default:
      return [];
  }
}
function yG(e, t, n, r) {
  const o = Yu(e);
  let i = gG(Ji(e), n === "start", r);
  return o && (i = i.map((s) => s + "-" + o), t && (i = i.concat(i.map(Sx)))), i;
}
function lm(e) {
  return e.replace(/left|right|bottom|top/g, (t) => fG[t]);
}
function vG(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function HR(e) {
  return typeof e != "number" ? vG(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function um(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: o
  } = e;
  return {
    width: r,
    height: o,
    top: n,
    left: t,
    right: t + r,
    bottom: n + o,
    x: t,
    y: n
  };
}
function I5(e, t, n) {
  let {
    reference: r,
    floating: o
  } = e;
  const i = rs(t), s = u0(t), u = l0(s), c = Ji(t), d = i === "y", p = r.x + r.width / 2 - o.width / 2, h = r.y + r.height / 2 - o.height / 2, g = r[u] / 2 - o[u] / 2;
  let y;
  switch (c) {
    case "top":
      y = {
        x: p,
        y: r.y - o.height
      };
      break;
    case "bottom":
      y = {
        x: p,
        y: r.y + r.height
      };
      break;
    case "right":
      y = {
        x: r.x + r.width,
        y: h
      };
      break;
    case "left":
      y = {
        x: r.x - o.width,
        y: h
      };
      break;
    default:
      y = {
        x: r.x,
        y: r.y
      };
  }
  switch (Yu(t)) {
    case "start":
      y[s] -= g * (n && d ? -1 : 1);
      break;
    case "end":
      y[s] += g * (n && d ? -1 : 1);
      break;
  }
  return y;
}
const bG = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: o = "absolute",
    middleware: i = [],
    platform: s
  } = n, u = i.filter(Boolean), c = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let d = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: o
  }), {
    x: p,
    y: h
  } = I5(d, r, c), g = r, y = {}, b = 0;
  for (let v = 0; v < u.length; v++) {
    const {
      name: x,
      fn: _
    } = u[v], {
      x: O,
      y: C,
      data: N,
      reset: R
    } = await _({
      x: p,
      y: h,
      initialPlacement: r,
      placement: g,
      strategy: o,
      middlewareData: y,
      rects: d,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    p = O ?? p, h = C ?? h, y = {
      ...y,
      [x]: {
        ...y[x],
        ...N
      }
    }, R && b <= 50 && (b++, typeof R == "object" && (R.placement && (g = R.placement), R.rects && (d = R.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: o
    }) : R.rects), {
      x: p,
      y: h
    } = I5(d, g, c)), v = -1);
  }
  return {
    x: p,
    y: h,
    placement: g,
    strategy: o,
    middlewareData: y
  };
};
async function Fd(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: o,
    platform: i,
    rects: s,
    elements: u,
    strategy: c
  } = e, {
    boundary: d = "clippingAncestors",
    rootBoundary: p = "viewport",
    elementContext: h = "floating",
    altBoundary: g = !1,
    padding: y = 0
  } = Qi(t, e), b = HR(y), v = u[g ? h === "floating" ? "reference" : "floating" : h], x = um(await i.getClippingRect({
    element: (n = await (i.isElement == null ? void 0 : i.isElement(v))) == null || n ? v : v.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(u.floating)),
    boundary: d,
    rootBoundary: p,
    strategy: c
  })), _ = h === "floating" ? {
    x: r,
    y: o,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, O = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(u.floating)), C = await (i.isElement == null ? void 0 : i.isElement(O)) ? await (i.getScale == null ? void 0 : i.getScale(O)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, N = um(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: u,
    rect: _,
    offsetParent: O,
    strategy: c
  }) : _);
  return {
    top: (x.top - N.top + b.top) / C.y,
    bottom: (N.bottom - x.bottom + b.bottom) / C.y,
    left: (x.left - N.left + b.left) / C.x,
    right: (N.right - x.right + b.right) / C.x
  };
}
const wG = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: o,
      rects: i,
      platform: s,
      elements: u,
      middlewareData: c
    } = t, {
      element: d,
      padding: p = 0
    } = Qi(e, t) || {};
    if (d == null)
      return {};
    const h = HR(p), g = {
      x: n,
      y: r
    }, y = u0(o), b = l0(y), v = await s.getDimensions(d), x = y === "y", _ = x ? "top" : "left", O = x ? "bottom" : "right", C = x ? "clientHeight" : "clientWidth", N = i.reference[b] + i.reference[y] - g[y] - i.floating[b], R = g[y] - i.reference[y], z = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(d));
    let j = z ? z[C] : 0;
    (!j || !await (s.isElement == null ? void 0 : s.isElement(z))) && (j = u.floating[C] || i.floating[b]);
    const I = N / 2 - R / 2, $ = j / 2 - v[b] / 2 - 1, A = ns(h[_], $), V = ns(h[O], $), U = A, W = j - v[b] - V, D = j / 2 - v[b] / 2 + I, F = xx(U, D, W), P = !c.arrow && Yu(o) != null && D !== F && i.reference[b] / 2 - (D < U ? A : V) - v[b] / 2 < 0, H = P ? D < U ? D - U : D - W : 0;
    return {
      [y]: g[y] + H,
      data: {
        [y]: F,
        centerOffset: D - F - H,
        ...P && {
          alignmentOffset: H
        }
      },
      reset: P
    };
  }
}), xG = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: o,
        middlewareData: i,
        rects: s,
        initialPlacement: u,
        platform: c,
        elements: d
      } = t, {
        mainAxis: p = !0,
        crossAxis: h = !0,
        fallbackPlacements: g,
        fallbackStrategy: y = "bestFit",
        fallbackAxisSideDirection: b = "none",
        flipAlignment: v = !0,
        ...x
      } = Qi(e, t);
      if ((n = i.arrow) != null && n.alignmentOffset)
        return {};
      const _ = Ji(o), O = rs(u), C = Ji(u) === u, N = await (c.isRTL == null ? void 0 : c.isRTL(d.floating)), R = g || (C || !v ? [lm(u)] : mG(u)), z = b !== "none";
      !g && z && R.push(...yG(u, v, b, N));
      const j = [u, ...R], I = await Fd(t, x), $ = [];
      let A = ((r = i.flip) == null ? void 0 : r.overflows) || [];
      if (p && $.push(I[_]), h) {
        const D = hG(o, s, N);
        $.push(I[D[0]], I[D[1]]);
      }
      if (A = [...A, {
        placement: o,
        overflows: $
      }], !$.every((D) => D <= 0)) {
        var V, U;
        const D = (((V = i.flip) == null ? void 0 : V.index) || 0) + 1, F = j[D];
        if (F)
          return {
            data: {
              index: D,
              overflows: A
            },
            reset: {
              placement: F
            }
          };
        let P = (U = A.filter((H) => H.overflows[0] <= 0).sort((H, Y) => H.overflows[1] - Y.overflows[1])[0]) == null ? void 0 : U.placement;
        if (!P)
          switch (y) {
            case "bestFit": {
              var W;
              const H = (W = A.filter((Y) => {
                if (z) {
                  const q = rs(Y.placement);
                  return q === O || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  q === "y";
                }
                return !0;
              }).map((Y) => [Y.placement, Y.overflows.filter((q) => q > 0).reduce((q, M) => q + M, 0)]).sort((Y, q) => Y[1] - q[1])[0]) == null ? void 0 : W[0];
              H && (P = H);
              break;
            }
            case "initialPlacement":
              P = u;
              break;
          }
        if (o !== P)
          return {
            reset: {
              placement: P
            }
          };
      }
      return {};
    }
  };
};
function V5(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function B5(e) {
  return dG.some((t) => e[t] >= 0);
}
const SG = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...o
      } = Qi(e, t);
      switch (r) {
        case "referenceHidden": {
          const i = await Fd(t, {
            ...o,
            elementContext: "reference"
          }), s = V5(i, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: B5(s)
            }
          };
        }
        case "escaped": {
          const i = await Fd(t, {
            ...o,
            altBoundary: !0
          }), s = V5(i, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: B5(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function _G(e, t) {
  const {
    placement: n,
    platform: r,
    elements: o
  } = e, i = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), s = Ji(n), u = Yu(n), c = rs(n) === "y", d = ["left", "top"].includes(s) ? -1 : 1, p = i && c ? -1 : 1, h = Qi(t, e);
  let {
    mainAxis: g,
    crossAxis: y,
    alignmentAxis: b
  } = typeof h == "number" ? {
    mainAxis: h,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: h.mainAxis || 0,
    crossAxis: h.crossAxis || 0,
    alignmentAxis: h.alignmentAxis
  };
  return u && typeof b == "number" && (y = u === "end" ? b * -1 : b), c ? {
    x: y * p,
    y: g * d
  } : {
    x: g * d,
    y: y * p
  };
}
const kG = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: o,
        y: i,
        placement: s,
        middlewareData: u
      } = t, c = await _G(t, e);
      return s === ((n = u.offset) == null ? void 0 : n.placement) && (r = u.arrow) != null && r.alignmentOffset ? {} : {
        x: o + c.x,
        y: i + c.y,
        data: {
          ...c,
          placement: s
        }
      };
    }
  };
}, EG = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: o
      } = t, {
        mainAxis: i = !0,
        crossAxis: s = !1,
        limiter: u = {
          fn: (x) => {
            let {
              x: _,
              y: O
            } = x;
            return {
              x: _,
              y: O
            };
          }
        },
        ...c
      } = Qi(e, t), d = {
        x: n,
        y: r
      }, p = await Fd(t, c), h = rs(Ji(o)), g = s0(h);
      let y = d[g], b = d[h];
      if (i) {
        const x = g === "y" ? "top" : "left", _ = g === "y" ? "bottom" : "right", O = y + p[x], C = y - p[_];
        y = xx(O, y, C);
      }
      if (s) {
        const x = h === "y" ? "top" : "left", _ = h === "y" ? "bottom" : "right", O = b + p[x], C = b - p[_];
        b = xx(O, b, C);
      }
      const v = u.fn({
        ...t,
        [g]: y,
        [h]: b
      });
      return {
        ...v,
        data: {
          x: v.x - n,
          y: v.y - r,
          enabled: {
            [g]: i,
            [h]: s
          }
        }
      };
    }
  };
}, CG = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: o,
        rects: i,
        middlewareData: s
      } = t, {
        offset: u = 0,
        mainAxis: c = !0,
        crossAxis: d = !0
      } = Qi(e, t), p = {
        x: n,
        y: r
      }, h = rs(o), g = s0(h);
      let y = p[g], b = p[h];
      const v = Qi(u, t), x = typeof v == "number" ? {
        mainAxis: v,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...v
      };
      if (c) {
        const C = g === "y" ? "height" : "width", N = i.reference[g] - i.floating[C] + x.mainAxis, R = i.reference[g] + i.reference[C] - x.mainAxis;
        y < N ? y = N : y > R && (y = R);
      }
      if (d) {
        var _, O;
        const C = g === "y" ? "width" : "height", N = ["top", "left"].includes(Ji(o)), R = i.reference[h] - i.floating[C] + (N && ((_ = s.offset) == null ? void 0 : _[h]) || 0) + (N ? 0 : x.crossAxis), z = i.reference[h] + i.reference[C] + (N ? 0 : ((O = s.offset) == null ? void 0 : O[h]) || 0) - (N ? x.crossAxis : 0);
        b < R ? b = R : b > z && (b = z);
      }
      return {
        [g]: y,
        [h]: b
      };
    }
  };
}, OG = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: o,
        rects: i,
        platform: s,
        elements: u
      } = t, {
        apply: c = () => {
        },
        ...d
      } = Qi(e, t), p = await Fd(t, d), h = Ji(o), g = Yu(o), y = rs(o) === "y", {
        width: b,
        height: v
      } = i.floating;
      let x, _;
      h === "top" || h === "bottom" ? (x = h, _ = g === (await (s.isRTL == null ? void 0 : s.isRTL(u.floating)) ? "start" : "end") ? "left" : "right") : (_ = h, x = g === "end" ? "top" : "bottom");
      const O = v - p.top - p.bottom, C = b - p.left - p.right, N = ns(v - p[x], O), R = ns(b - p[_], C), z = !t.middlewareData.shift;
      let j = N, I = R;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (I = C), (r = t.middlewareData.shift) != null && r.enabled.y && (j = O), z && !g) {
        const A = Dr(p.left, 0), V = Dr(p.right, 0), U = Dr(p.top, 0), W = Dr(p.bottom, 0);
        y ? I = b - 2 * (A !== 0 || V !== 0 ? A + V : Dr(p.left, p.right)) : j = v - 2 * (U !== 0 || W !== 0 ? U + W : Dr(p.top, p.bottom));
      }
      await c({
        ...t,
        availableWidth: I,
        availableHeight: j
      });
      const $ = await s.getDimensions(u.floating);
      return b !== $.width || v !== $.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function cg() {
  return typeof window < "u";
}
function qu(e) {
  return $R(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Vr(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function mi(e) {
  var t;
  return (t = ($R(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function $R(e) {
  return cg() ? e instanceof Node || e instanceof Vr(e).Node : !1;
}
function jo(e) {
  return cg() ? e instanceof Element || e instanceof Vr(e).Element : !1;
}
function pi(e) {
  return cg() ? e instanceof HTMLElement || e instanceof Vr(e).HTMLElement : !1;
}
function F5(e) {
  return !cg() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Vr(e).ShadowRoot;
}
function vf(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: o
  } = zo(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(o);
}
function AG(e) {
  return ["table", "td", "th"].includes(qu(e));
}
function dg(e) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function c0(e) {
  const t = d0(), n = jo(e) ? zo(e) : e;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function NG(e) {
  let t = os(e);
  for (; pi(t) && !Tu(t); ) {
    if (c0(t))
      return t;
    if (dg(t))
      return null;
    t = os(t);
  }
  return null;
}
function d0() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function Tu(e) {
  return ["html", "body", "#document"].includes(qu(e));
}
function zo(e) {
  return Vr(e).getComputedStyle(e);
}
function fg(e) {
  return jo(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function os(e) {
  if (qu(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    F5(e) && e.host || // Fallback.
    mi(e)
  );
  return F5(t) ? t.host : t;
}
function YR(e) {
  const t = os(e);
  return Tu(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : pi(t) && vf(t) ? t : YR(t);
}
function Ud(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const o = YR(e), i = o === ((r = e.ownerDocument) == null ? void 0 : r.body), s = Vr(o);
  if (i) {
    const u = _x(s);
    return t.concat(s, s.visualViewport || [], vf(o) ? o : [], u && n ? Ud(u) : []);
  }
  return t.concat(o, Ud(o, [], n));
}
function _x(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function qR(e) {
  const t = zo(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const o = pi(e), i = o ? e.offsetWidth : n, s = o ? e.offsetHeight : r, u = sm(n) !== i || sm(r) !== s;
  return u && (n = i, r = s), {
    width: n,
    height: r,
    $: u
  };
}
function f0(e) {
  return jo(e) ? e : e.contextElement;
}
function bu(e) {
  const t = f0(e);
  if (!pi(t))
    return ci(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: o,
    $: i
  } = qR(t);
  let s = (i ? sm(n.width) : n.width) / r, u = (i ? sm(n.height) : n.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!u || !Number.isFinite(u)) && (u = 1), {
    x: s,
    y: u
  };
}
const MG = /* @__PURE__ */ ci(0);
function XR(e) {
  const t = Vr(e);
  return !d0() || !t.visualViewport ? MG : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function RG(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== Vr(e) ? !1 : t;
}
function nl(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const o = e.getBoundingClientRect(), i = f0(e);
  let s = ci(1);
  t && (r ? jo(r) && (s = bu(r)) : s = bu(e));
  const u = RG(i, n, r) ? XR(i) : ci(0);
  let c = (o.left + u.x) / s.x, d = (o.top + u.y) / s.y, p = o.width / s.x, h = o.height / s.y;
  if (i) {
    const g = Vr(i), y = r && jo(r) ? Vr(r) : r;
    let b = g, v = _x(b);
    for (; v && r && y !== b; ) {
      const x = bu(v), _ = v.getBoundingClientRect(), O = zo(v), C = _.left + (v.clientLeft + parseFloat(O.paddingLeft)) * x.x, N = _.top + (v.clientTop + parseFloat(O.paddingTop)) * x.y;
      c *= x.x, d *= x.y, p *= x.x, h *= x.y, c += C, d += N, b = Vr(v), v = _x(b);
    }
  }
  return um({
    width: p,
    height: h,
    x: c,
    y: d
  });
}
function p0(e, t) {
  const n = fg(e).scrollLeft;
  return t ? t.left + n : nl(mi(e)).left + n;
}
function WR(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), o = r.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    p0(e, r)
  )), i = r.top + t.scrollTop;
  return {
    x: o,
    y: i
  };
}
function jG(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: o
  } = e;
  const i = o === "fixed", s = mi(r), u = t ? dg(t.floating) : !1;
  if (r === s || u && i)
    return n;
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  }, d = ci(1);
  const p = ci(0), h = pi(r);
  if ((h || !h && !i) && ((qu(r) !== "body" || vf(s)) && (c = fg(r)), pi(r))) {
    const y = nl(r);
    d = bu(r), p.x = y.x + r.clientLeft, p.y = y.y + r.clientTop;
  }
  const g = s && !h && !i ? WR(s, c, !0) : ci(0);
  return {
    width: n.width * d.x,
    height: n.height * d.y,
    x: n.x * d.x - c.scrollLeft * d.x + p.x + g.x,
    y: n.y * d.y - c.scrollTop * d.y + p.y + g.y
  };
}
function zG(e) {
  return Array.from(e.getClientRects());
}
function TG(e) {
  const t = mi(e), n = fg(e), r = e.ownerDocument.body, o = Dr(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), i = Dr(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + p0(e);
  const u = -n.scrollTop;
  return zo(r).direction === "rtl" && (s += Dr(t.clientWidth, r.clientWidth) - o), {
    width: o,
    height: i,
    x: s,
    y: u
  };
}
function DG(e, t) {
  const n = Vr(e), r = mi(e), o = n.visualViewport;
  let i = r.clientWidth, s = r.clientHeight, u = 0, c = 0;
  if (o) {
    i = o.width, s = o.height;
    const d = d0();
    (!d || d && t === "fixed") && (u = o.offsetLeft, c = o.offsetTop);
  }
  return {
    width: i,
    height: s,
    x: u,
    y: c
  };
}
function PG(e, t) {
  const n = nl(e, !0, t === "fixed"), r = n.top + e.clientTop, o = n.left + e.clientLeft, i = pi(e) ? bu(e) : ci(1), s = e.clientWidth * i.x, u = e.clientHeight * i.y, c = o * i.x, d = r * i.y;
  return {
    width: s,
    height: u,
    x: c,
    y: d
  };
}
function U5(e, t, n) {
  let r;
  if (t === "viewport")
    r = DG(e, n);
  else if (t === "document")
    r = TG(mi(e));
  else if (jo(t))
    r = PG(t, n);
  else {
    const o = XR(e);
    r = {
      x: t.x - o.x,
      y: t.y - o.y,
      width: t.width,
      height: t.height
    };
  }
  return um(r);
}
function GR(e, t) {
  const n = os(e);
  return n === t || !jo(n) || Tu(n) ? !1 : zo(n).position === "fixed" || GR(n, t);
}
function LG(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = Ud(e, [], !1).filter((u) => jo(u) && qu(u) !== "body"), o = null;
  const i = zo(e).position === "fixed";
  let s = i ? os(e) : e;
  for (; jo(s) && !Tu(s); ) {
    const u = zo(s), c = c0(s);
    !c && u.position === "fixed" && (o = null), (i ? !c && !o : !c && u.position === "static" && o && ["absolute", "fixed"].includes(o.position) || vf(s) && !c && GR(e, s)) ? r = r.filter((d) => d !== s) : o = u, s = os(s);
  }
  return t.set(e, r), r;
}
function IG(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: o
  } = e;
  const i = [...n === "clippingAncestors" ? dg(t) ? [] : LG(t, this._c) : [].concat(n), r], s = i[0], u = i.reduce((c, d) => {
    const p = U5(t, d, o);
    return c.top = Dr(p.top, c.top), c.right = ns(p.right, c.right), c.bottom = ns(p.bottom, c.bottom), c.left = Dr(p.left, c.left), c;
  }, U5(t, s, o));
  return {
    width: u.right - u.left,
    height: u.bottom - u.top,
    x: u.left,
    y: u.top
  };
}
function VG(e) {
  const {
    width: t,
    height: n
  } = qR(e);
  return {
    width: t,
    height: n
  };
}
function BG(e, t, n) {
  const r = pi(t), o = mi(t), i = n === "fixed", s = nl(e, !0, i, t);
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const c = ci(0);
  if (r || !r && !i)
    if ((qu(t) !== "body" || vf(o)) && (u = fg(t)), r) {
      const g = nl(t, !0, i, t);
      c.x = g.x + t.clientLeft, c.y = g.y + t.clientTop;
    } else o && (c.x = p0(o));
  const d = o && !r && !i ? WR(o, u) : ci(0), p = s.left + u.scrollLeft - c.x - d.x, h = s.top + u.scrollTop - c.y - d.y;
  return {
    x: p,
    y: h,
    width: s.width,
    height: s.height
  };
}
function Mb(e) {
  return zo(e).position === "static";
}
function H5(e, t) {
  if (!pi(e) || zo(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return mi(e) === n && (n = n.ownerDocument.body), n;
}
function ZR(e, t) {
  const n = Vr(e);
  if (dg(e))
    return n;
  if (!pi(e)) {
    let o = os(e);
    for (; o && !Tu(o); ) {
      if (jo(o) && !Mb(o))
        return o;
      o = os(o);
    }
    return n;
  }
  let r = H5(e, t);
  for (; r && AG(r) && Mb(r); )
    r = H5(r, t);
  return r && Tu(r) && Mb(r) && !c0(r) ? n : r || NG(e) || n;
}
const FG = async function(e) {
  const t = this.getOffsetParent || ZR, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: BG(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function UG(e) {
  return zo(e).direction === "rtl";
}
const HG = {
  convertOffsetParentRelativeRectToViewportRelativeRect: jG,
  getDocumentElement: mi,
  getClippingRect: IG,
  getOffsetParent: ZR,
  getElementRects: FG,
  getClientRects: zG,
  getDimensions: VG,
  getScale: bu,
  isElement: jo,
  isRTL: UG
};
function KR(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function $G(e, t) {
  let n = null, r;
  const o = mi(e);
  function i() {
    var u;
    clearTimeout(r), (u = n) == null || u.disconnect(), n = null;
  }
  function s(u, c) {
    u === void 0 && (u = !1), c === void 0 && (c = 1), i();
    const d = e.getBoundingClientRect(), {
      left: p,
      top: h,
      width: g,
      height: y
    } = d;
    if (u || t(), !g || !y)
      return;
    const b = th(h), v = th(o.clientWidth - (p + g)), x = th(o.clientHeight - (h + y)), _ = th(p), O = {
      rootMargin: -b + "px " + -v + "px " + -x + "px " + -_ + "px",
      threshold: Dr(0, ns(1, c)) || 1
    };
    let C = !0;
    function N(R) {
      const z = R[0].intersectionRatio;
      if (z !== c) {
        if (!C)
          return s();
        z ? s(!1, z) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      z === 1 && !KR(d, e.getBoundingClientRect()) && s(), C = !1;
    }
    try {
      n = new IntersectionObserver(N, {
        ...O,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(N, O);
    }
    n.observe(e);
  }
  return s(!0), i;
}
function QR(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: i = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: u = typeof IntersectionObserver == "function",
    animationFrame: c = !1
  } = r, d = f0(e), p = o || i ? [...d ? Ud(d) : [], ...Ud(t)] : [];
  p.forEach((_) => {
    o && _.addEventListener("scroll", n, {
      passive: !0
    }), i && _.addEventListener("resize", n);
  });
  const h = d && u ? $G(d, n) : null;
  let g = -1, y = null;
  s && (y = new ResizeObserver((_) => {
    let [O] = _;
    O && O.target === d && y && (y.unobserve(t), cancelAnimationFrame(g), g = requestAnimationFrame(() => {
      var C;
      (C = y) == null || C.observe(t);
    })), n();
  }), d && !c && y.observe(d), y.observe(t));
  let b, v = c ? nl(e) : null;
  c && x();
  function x() {
    const _ = nl(e);
    v && !KR(v, _) && n(), v = _, b = requestAnimationFrame(x);
  }
  return n(), () => {
    var _;
    p.forEach((O) => {
      o && O.removeEventListener("scroll", n), i && O.removeEventListener("resize", n);
    }), h?.(), (_ = y) == null || _.disconnect(), y = null, c && cancelAnimationFrame(b);
  };
}
const YG = kG, qG = EG, XG = xG, WG = OG, GG = SG, $5 = wG, ZG = CG, KG = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), o = {
    platform: HG,
    ...n
  }, i = {
    ...o.platform,
    _c: r
  };
  return bG(e, t, {
    ...o,
    platform: i
  });
};
var Th = typeof document < "u" ? S.useLayoutEffect : S.useEffect;
function cm(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, o;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!cm(e[r], t[r]))
          return !1;
      return !0;
    }
    if (o = Object.keys(e), n = o.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, o[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const i = o[r];
      if (!(i === "_owner" && e.$$typeof) && !cm(e[i], t[i]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function JR(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Y5(e, t) {
  const n = JR(e);
  return Math.round(t * n) / n;
}
function Rb(e) {
  const t = S.useRef(e);
  return Th(() => {
    t.current = e;
  }), t;
}
function QG(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: o,
    elements: {
      reference: i,
      floating: s
    } = {},
    transform: u = !0,
    whileElementsMounted: c,
    open: d
  } = e, [p, h] = S.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [g, y] = S.useState(r);
  cm(g, r) || y(r);
  const [b, v] = S.useState(null), [x, _] = S.useState(null), O = S.useCallback((Y) => {
    Y !== z.current && (z.current = Y, v(Y));
  }, []), C = S.useCallback((Y) => {
    Y !== j.current && (j.current = Y, _(Y));
  }, []), N = i || b, R = s || x, z = S.useRef(null), j = S.useRef(null), I = S.useRef(p), $ = c != null, A = Rb(c), V = Rb(o), U = Rb(d), W = S.useCallback(() => {
    if (!z.current || !j.current)
      return;
    const Y = {
      placement: t,
      strategy: n,
      middleware: g
    };
    V.current && (Y.platform = V.current), KG(z.current, j.current, Y).then((q) => {
      const M = {
        ...q,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: U.current !== !1
      };
      D.current && !cm(I.current, M) && (I.current = M, rf.flushSync(() => {
        h(M);
      }));
    });
  }, [g, t, n, V, U]);
  Th(() => {
    d === !1 && I.current.isPositioned && (I.current.isPositioned = !1, h((Y) => ({
      ...Y,
      isPositioned: !1
    })));
  }, [d]);
  const D = S.useRef(!1);
  Th(() => (D.current = !0, () => {
    D.current = !1;
  }), []), Th(() => {
    if (N && (z.current = N), R && (j.current = R), N && R) {
      if (A.current)
        return A.current(N, R, W);
      W();
    }
  }, [N, R, W, A, $]);
  const F = S.useMemo(() => ({
    reference: z,
    floating: j,
    setReference: O,
    setFloating: C
  }), [O, C]), P = S.useMemo(() => ({
    reference: N,
    floating: R
  }), [N, R]), H = S.useMemo(() => {
    const Y = {
      position: n,
      left: 0,
      top: 0
    };
    if (!P.floating)
      return Y;
    const q = Y5(P.floating, p.x), M = Y5(P.floating, p.y);
    return u ? {
      ...Y,
      transform: "translate(" + q + "px, " + M + "px)",
      ...JR(P.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: q,
      top: M
    };
  }, [n, u, P.floating, p.x, p.y]);
  return S.useMemo(() => ({
    ...p,
    update: W,
    refs: F,
    elements: P,
    floatingStyles: H
  }), [p, W, F, P, H]);
}
const JG = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: o
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? $5({
        element: r.current,
        padding: o
      }).fn(n) : {} : r ? $5({
        element: r,
        padding: o
      }).fn(n) : {};
    }
  };
}, eZ = (e, t) => ({
  ...YG(e),
  options: [e, t]
}), tZ = (e, t) => ({
  ...qG(e),
  options: [e, t]
}), nZ = (e, t) => ({
  ...ZG(e),
  options: [e, t]
}), rZ = (e, t) => ({
  ...XG(e),
  options: [e, t]
}), oZ = (e, t) => ({
  ...WG(e),
  options: [e, t]
}), iZ = (e, t) => ({
  ...GG(e),
  options: [e, t]
}), aZ = (e, t) => ({
  ...JG(e),
  options: [e, t]
});
var sZ = "Arrow", ej = S.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: o = 5, ...i } = e;
  return /* @__PURE__ */ E.jsx(
    zt.svg,
    {
      ...i,
      ref: t,
      width: r,
      height: o,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ E.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
ej.displayName = sZ;
var lZ = ej;
function tj(e) {
  const [t, n] = S.useState(void 0);
  return Qs(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((o) => {
        if (!Array.isArray(o) || !o.length)
          return;
        const i = o[0];
        let s, u;
        if ("borderBoxSize" in i) {
          const c = i.borderBoxSize, d = Array.isArray(c) ? c[0] : c;
          s = d.inlineSize, u = d.blockSize;
        } else
          s = e.offsetWidth, u = e.offsetHeight;
        n({ width: s, height: u });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var h0 = "Popper", [nj, pg] = us(h0), [uZ, rj] = nj(h0), oj = (e) => {
  const { __scopePopper: t, children: n } = e, [r, o] = S.useState(null);
  return /* @__PURE__ */ E.jsx(uZ, { scope: t, anchor: r, onAnchorChange: o, children: n });
};
oj.displayName = h0;
var ij = "PopperAnchor", aj = S.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...o } = e, i = rj(ij, n), s = S.useRef(null), u = Ut(t, s);
    return S.useEffect(() => {
      i.onAnchorChange(r?.current || s.current);
    }), r ? null : /* @__PURE__ */ E.jsx(zt.div, { ...o, ref: u });
  }
);
aj.displayName = ij;
var m0 = "PopperContent", [cZ, dZ] = nj(m0), sj = S.forwardRef(
  (e, t) => {
    var n, r, o, i, s, u;
    const {
      __scopePopper: c,
      side: d = "bottom",
      sideOffset: p = 0,
      align: h = "center",
      alignOffset: g = 0,
      arrowPadding: y = 0,
      avoidCollisions: b = !0,
      collisionBoundary: v = [],
      collisionPadding: x = 0,
      sticky: _ = "partial",
      hideWhenDetached: O = !1,
      updatePositionStrategy: C = "optimized",
      onPlaced: N,
      ...R
    } = e, z = rj(m0, c), [j, I] = S.useState(null), $ = Ut(t, (Ie) => I(Ie)), [A, V] = S.useState(null), U = tj(A), W = U?.width ?? 0, D = U?.height ?? 0, F = d + (h !== "center" ? "-" + h : ""), P = typeof x == "number" ? x : { top: 0, right: 0, bottom: 0, left: 0, ...x }, H = Array.isArray(v) ? v : [v], Y = H.length > 0, q = {
      padding: P,
      boundary: H.filter(pZ),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: Y
    }, { refs: M, floatingStyles: X, placement: K, isPositioned: L, middlewareData: ee } = QG({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: F,
      whileElementsMounted: (...Ie) => QR(...Ie, {
        animationFrame: C === "always"
      }),
      elements: {
        reference: z.anchor
      },
      middleware: [
        eZ({ mainAxis: p + D, alignmentAxis: g }),
        b && tZ({
          mainAxis: !0,
          crossAxis: !1,
          limiter: _ === "partial" ? nZ() : void 0,
          ...q
        }),
        b && rZ({ ...q }),
        oZ({
          ...q,
          apply: ({ elements: Ie, rects: $e, availableWidth: ct, availableHeight: $t }) => {
            const { width: ft, height: br } = $e.reference, on = Ie.floating.style;
            on.setProperty("--radix-popper-available-width", `${ct}px`), on.setProperty("--radix-popper-available-height", `${$t}px`), on.setProperty("--radix-popper-anchor-width", `${ft}px`), on.setProperty("--radix-popper-anchor-height", `${br}px`);
          }
        }),
        A && aZ({ element: A, padding: y }),
        hZ({ arrowWidth: W, arrowHeight: D }),
        O && iZ({ strategy: "referenceHidden", ...q })
      ]
    }), [ae, le] = cj(K), me = fo(N);
    Qs(() => {
      L && me?.();
    }, [L, me]);
    const se = (n = ee.arrow) == null ? void 0 : n.x, he = (r = ee.arrow) == null ? void 0 : r.y, _e = ((o = ee.arrow) == null ? void 0 : o.centerOffset) !== 0, [Se, Ee] = S.useState();
    return Qs(() => {
      j && Ee(window.getComputedStyle(j).zIndex);
    }, [j]), /* @__PURE__ */ E.jsx(
      "div",
      {
        ref: M.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...X,
          transform: L ? X.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: Se,
          "--radix-popper-transform-origin": [
            (i = ee.transformOrigin) == null ? void 0 : i.x,
            (s = ee.transformOrigin) == null ? void 0 : s.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((u = ee.hide) == null ? void 0 : u.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ E.jsx(
          cZ,
          {
            scope: c,
            placedSide: ae,
            onArrowChange: V,
            arrowX: se,
            arrowY: he,
            shouldHideArrow: _e,
            children: /* @__PURE__ */ E.jsx(
              zt.div,
              {
                "data-side": ae,
                "data-align": le,
                ...R,
                ref: $,
                style: {
                  ...R.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: L ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
sj.displayName = m0;
var lj = "PopperArrow", fZ = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, uj = S.forwardRef(function(e, t) {
  const { __scopePopper: n, ...r } = e, o = dZ(lj, n), i = fZ[o.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ E.jsx(
      "span",
      {
        ref: o.onArrowChange,
        style: {
          position: "absolute",
          left: o.arrowX,
          top: o.arrowY,
          [i]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[o.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[o.placedSide],
          visibility: o.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ E.jsx(
          lZ,
          {
            ...r,
            ref: t,
            style: {
              ...r.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
uj.displayName = lj;
function pZ(e) {
  return e !== null;
}
var hZ = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    var n, r, o;
    const { placement: i, rects: s, middlewareData: u } = t, c = ((n = u.arrow) == null ? void 0 : n.centerOffset) !== 0, d = c ? 0 : e.arrowWidth, p = c ? 0 : e.arrowHeight, [h, g] = cj(i), y = { start: "0%", center: "50%", end: "100%" }[g], b = (((r = u.arrow) == null ? void 0 : r.x) ?? 0) + d / 2, v = (((o = u.arrow) == null ? void 0 : o.y) ?? 0) + p / 2;
    let x = "", _ = "";
    return h === "bottom" ? (x = c ? y : `${b}px`, _ = `${-p}px`) : h === "top" ? (x = c ? y : `${b}px`, _ = `${s.floating.height + p}px`) : h === "right" ? (x = `${-p}px`, _ = c ? y : `${v}px`) : h === "left" && (x = `${s.floating.width + p}px`, _ = c ? y : `${v}px`), { data: { x, y: _ } };
  }
});
function cj(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var g0 = oj, y0 = aj, dj = sj, fj = uj, jb = "rovingFocusGroup.onEntryFocus", mZ = { bubbles: !1, cancelable: !0 }, hg = "RovingFocusGroup", [kx, pj, gZ] = i0(hg), [yZ, hj] = us(
  hg,
  [gZ]
), [vZ, bZ] = yZ(hg), mj = S.forwardRef(
  (e, t) => /* @__PURE__ */ E.jsx(kx.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ E.jsx(kx.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ E.jsx(wZ, { ...e, ref: t }) }) })
);
mj.displayName = hg;
var wZ = S.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: o = !1,
    dir: i,
    currentTabStopId: s,
    defaultCurrentTabStopId: u,
    onCurrentTabStopIdChange: c,
    onEntryFocus: d,
    preventScrollOnEntryFocus: p = !1,
    ...h
  } = e, g = S.useRef(null), y = Ut(t, g), b = a0(i), [v = null, x] = Uu({
    prop: s,
    defaultProp: u,
    onChange: c
  }), [_, O] = S.useState(!1), C = fo(d), N = pj(n), R = S.useRef(!1), [z, j] = S.useState(0);
  return S.useEffect(() => {
    const I = g.current;
    if (I)
      return I.addEventListener(jb, C), () => I.removeEventListener(jb, C);
  }, [C]), /* @__PURE__ */ E.jsx(
    vZ,
    {
      scope: n,
      orientation: r,
      dir: b,
      loop: o,
      currentTabStopId: v,
      onItemFocus: S.useCallback(
        (I) => x(I),
        [x]
      ),
      onItemShiftTab: S.useCallback(() => O(!0), []),
      onFocusableItemAdd: S.useCallback(
        () => j((I) => I + 1),
        []
      ),
      onFocusableItemRemove: S.useCallback(
        () => j((I) => I - 1),
        []
      ),
      children: /* @__PURE__ */ E.jsx(
        zt.div,
        {
          tabIndex: _ || z === 0 ? -1 : 0,
          "data-orientation": r,
          ...h,
          ref: y,
          style: { outline: "none", ...e.style },
          onMouseDown: Ue(e.onMouseDown, () => {
            R.current = !0;
          }),
          onFocus: Ue(e.onFocus, (I) => {
            const $ = !R.current;
            if (I.target === I.currentTarget && $ && !_) {
              const A = new CustomEvent(jb, mZ);
              if (I.currentTarget.dispatchEvent(A), !A.defaultPrevented) {
                const V = N().filter((F) => F.focusable), U = V.find((F) => F.active), W = V.find((F) => F.id === v), D = [U, W, ...V].filter(
                  Boolean
                ).map((F) => F.ref.current);
                vj(D, p);
              }
            }
            R.current = !1;
          }),
          onBlur: Ue(e.onBlur, () => O(!1))
        }
      )
    }
  );
}), gj = "RovingFocusGroupItem", yj = S.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: o = !1,
      tabStopId: i,
      ...s
    } = e, u = qi(), c = i || u, d = bZ(gj, n), p = d.currentTabStopId === c, h = pj(n), { onFocusableItemAdd: g, onFocusableItemRemove: y } = d;
    return S.useEffect(() => {
      if (r)
        return g(), () => y();
    }, [r, g, y]), /* @__PURE__ */ E.jsx(
      kx.ItemSlot,
      {
        scope: n,
        id: c,
        focusable: r,
        active: o,
        children: /* @__PURE__ */ E.jsx(
          zt.span,
          {
            tabIndex: p ? 0 : -1,
            "data-orientation": d.orientation,
            ...s,
            ref: t,
            onMouseDown: Ue(e.onMouseDown, (b) => {
              r ? d.onItemFocus(c) : b.preventDefault();
            }),
            onFocus: Ue(e.onFocus, () => d.onItemFocus(c)),
            onKeyDown: Ue(e.onKeyDown, (b) => {
              if (b.key === "Tab" && b.shiftKey) {
                d.onItemShiftTab();
                return;
              }
              if (b.target !== b.currentTarget) return;
              const v = _Z(b, d.orientation, d.dir);
              if (v !== void 0) {
                if (b.metaKey || b.ctrlKey || b.altKey || b.shiftKey) return;
                b.preventDefault();
                let x = h().filter((_) => _.focusable).map((_) => _.ref.current);
                if (v === "last") x.reverse();
                else if (v === "prev" || v === "next") {
                  v === "prev" && x.reverse();
                  const _ = x.indexOf(b.currentTarget);
                  x = d.loop ? kZ(x, _ + 1) : x.slice(_ + 1);
                }
                setTimeout(() => vj(x));
              }
            })
          }
        )
      }
    );
  }
);
yj.displayName = gj;
var xZ = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function SZ(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function _Z(e, t, n) {
  const r = SZ(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return xZ[r];
}
function vj(e, t = !1) {
  const n = document.activeElement;
  for (const r of e)
    if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return;
}
function kZ(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var EZ = mj, CZ = yj, Ex = ["Enter", " "], OZ = ["ArrowDown", "PageUp", "Home"], bj = ["ArrowUp", "PageDown", "End"], AZ = [...OZ, ...bj], NZ = {
  ltr: [...Ex, "ArrowRight"],
  rtl: [...Ex, "ArrowLeft"]
}, MZ = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, bf = "Menu", [Hd, RZ, jZ] = i0(bf), [ll, wj] = us(bf, [
  jZ,
  pg,
  hj
]), wf = pg(), xj = hj(), [Sj, ul] = ll(bf), [zZ, xf] = ll(bf), _j = (e) => {
  const { __scopeMenu: t, open: n = !1, children: r, dir: o, onOpenChange: i, modal: s = !0 } = e, u = wf(t), [c, d] = S.useState(null), p = S.useRef(!1), h = fo(i), g = a0(o);
  return S.useEffect(() => {
    const y = () => {
      p.current = !0, document.addEventListener("pointerdown", b, { capture: !0, once: !0 }), document.addEventListener("pointermove", b, { capture: !0, once: !0 });
    }, b = () => p.current = !1;
    return document.addEventListener("keydown", y, { capture: !0 }), () => {
      document.removeEventListener("keydown", y, { capture: !0 }), document.removeEventListener("pointerdown", b, { capture: !0 }), document.removeEventListener("pointermove", b, { capture: !0 });
    };
  }, []), /* @__PURE__ */ E.jsx(g0, { ...u, children: /* @__PURE__ */ E.jsx(
    Sj,
    {
      scope: t,
      open: n,
      onOpenChange: h,
      content: c,
      onContentChange: d,
      children: /* @__PURE__ */ E.jsx(
        zZ,
        {
          scope: t,
          onClose: S.useCallback(() => h(!1), [h]),
          isUsingKeyboardRef: p,
          dir: g,
          modal: s,
          children: r
        }
      )
    }
  ) });
};
_j.displayName = bf;
var TZ = "MenuAnchor", v0 = S.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, o = wf(n);
    return /* @__PURE__ */ E.jsx(y0, { ...o, ...r, ref: t });
  }
);
v0.displayName = TZ;
var DZ = "MenuPortal", [Vve, kj] = ll(DZ, {
  forceMount: void 0
}), co = "MenuContent", [PZ, b0] = ll(co), Ej = S.forwardRef(
  (e, t) => {
    const n = kj(co, e.__scopeMenu), { forceMount: r = n.forceMount, ...o } = e, i = ul(co, e.__scopeMenu), s = xf(co, e.__scopeMenu);
    return /* @__PURE__ */ E.jsx(Hd.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ E.jsx(oa, { present: r || i.open, children: /* @__PURE__ */ E.jsx(Hd.Slot, { scope: e.__scopeMenu, children: s.modal ? /* @__PURE__ */ E.jsx(LZ, { ...o, ref: t }) : /* @__PURE__ */ E.jsx(IZ, { ...o, ref: t }) }) }) });
  }
), LZ = S.forwardRef(
  (e, t) => {
    const n = ul(co, e.__scopeMenu), r = S.useRef(null), o = Ut(t, r);
    return S.useEffect(() => {
      const i = r.current;
      if (i) return US(i);
    }, []), /* @__PURE__ */ E.jsx(
      w0,
      {
        ...e,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: Ue(
          e.onFocusOutside,
          (i) => i.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), IZ = S.forwardRef((e, t) => {
  const n = ul(co, e.__scopeMenu);
  return /* @__PURE__ */ E.jsx(
    w0,
    {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), VZ = /* @__PURE__ */ ju("MenuContent.ScrollLock"), w0 = S.forwardRef(
  (e, t) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: o,
      onOpenAutoFocus: i,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: u,
      onEntryFocus: c,
      onEscapeKeyDown: d,
      onPointerDownOutside: p,
      onFocusOutside: h,
      onInteractOutside: g,
      onDismiss: y,
      disableOutsideScroll: b,
      ...v
    } = e, x = ul(co, n), _ = xf(co, n), O = wf(n), C = xj(n), N = RZ(n), [R, z] = S.useState(null), j = S.useRef(null), I = Ut(t, j, x.onContentChange), $ = S.useRef(0), A = S.useRef(""), V = S.useRef(0), U = S.useRef(null), W = S.useRef("right"), D = S.useRef(0), F = b ? og : S.Fragment, P = b ? { as: VZ, allowPinchZoom: !0 } : void 0, H = (q) => {
      var M, X;
      const K = A.current + q, L = N().filter((he) => !he.disabled), ee = document.activeElement, ae = (M = L.find((he) => he.ref.current === ee)) == null ? void 0 : M.textValue, le = L.map((he) => he.textValue), me = KZ(le, K, ae), se = (X = L.find((he) => he.textValue === me)) == null ? void 0 : X.ref.current;
      (function he(_e) {
        A.current = _e, window.clearTimeout($.current), _e !== "" && ($.current = window.setTimeout(() => he(""), 1e3));
      })(K), se && setTimeout(() => se.focus());
    };
    S.useEffect(() => () => window.clearTimeout($.current), []), FS();
    const Y = S.useCallback((q) => {
      var M, X;
      return W.current === ((M = U.current) == null ? void 0 : M.side) && JZ(q, (X = U.current) == null ? void 0 : X.area);
    }, []);
    return /* @__PURE__ */ E.jsx(
      PZ,
      {
        scope: n,
        searchRef: A,
        onItemEnter: S.useCallback(
          (q) => {
            Y(q) && q.preventDefault();
          },
          [Y]
        ),
        onItemLeave: S.useCallback(
          (q) => {
            var M;
            Y(q) || ((M = j.current) == null || M.focus(), z(null));
          },
          [Y]
        ),
        onTriggerLeave: S.useCallback(
          (q) => {
            Y(q) && q.preventDefault();
          },
          [Y]
        ),
        pointerGraceTimerRef: V,
        onPointerGraceIntentChange: S.useCallback((q) => {
          U.current = q;
        }, []),
        children: /* @__PURE__ */ E.jsx(F, { ...P, children: /* @__PURE__ */ E.jsx(
          ng,
          {
            asChild: !0,
            trapped: o,
            onMountAutoFocus: Ue(i, (q) => {
              var M;
              q.preventDefault(), (M = j.current) == null || M.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: s,
            children: /* @__PURE__ */ E.jsx(
              tg,
              {
                asChild: !0,
                disableOutsidePointerEvents: u,
                onEscapeKeyDown: d,
                onPointerDownOutside: p,
                onFocusOutside: h,
                onInteractOutside: g,
                onDismiss: y,
                children: /* @__PURE__ */ E.jsx(
                  EZ,
                  {
                    asChild: !0,
                    ...C,
                    dir: _.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: R,
                    onCurrentTabStopIdChange: z,
                    onEntryFocus: Ue(c, (q) => {
                      _.isUsingKeyboardRef.current || q.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ E.jsx(
                      dj,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": Uj(x.open),
                        "data-radix-menu-content": "",
                        dir: _.dir,
                        ...O,
                        ...v,
                        ref: I,
                        style: { outline: "none", ...v.style },
                        onKeyDown: Ue(v.onKeyDown, (q) => {
                          const M = q.target.closest("[data-radix-menu-content]") === q.currentTarget, X = q.ctrlKey || q.altKey || q.metaKey, K = q.key.length === 1;
                          M && (q.key === "Tab" && q.preventDefault(), !X && K && H(q.key));
                          const L = j.current;
                          if (q.target !== L || !AZ.includes(q.key)) return;
                          q.preventDefault();
                          const ee = N().filter((ae) => !ae.disabled).map((ae) => ae.ref.current);
                          bj.includes(q.key) && ee.reverse(), GZ(ee);
                        }),
                        onBlur: Ue(e.onBlur, (q) => {
                          q.currentTarget.contains(q.target) || (window.clearTimeout($.current), A.current = "");
                        }),
                        onPointerMove: Ue(
                          e.onPointerMove,
                          $d((q) => {
                            const M = q.target, X = D.current !== q.clientX;
                            if (q.currentTarget.contains(M) && X) {
                              const K = q.clientX > D.current ? "right" : "left";
                              W.current = K, D.current = q.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
Ej.displayName = co;
var BZ = "MenuGroup", x0 = S.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ E.jsx(zt.div, { role: "group", ...r, ref: t });
  }
);
x0.displayName = BZ;
var FZ = "MenuLabel", Cj = S.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ E.jsx(zt.div, { ...r, ref: t });
  }
);
Cj.displayName = FZ;
var dm = "MenuItem", q5 = "menu.itemSelect", mg = S.forwardRef(
  (e, t) => {
    const { disabled: n = !1, onSelect: r, ...o } = e, i = S.useRef(null), s = xf(dm, e.__scopeMenu), u = b0(dm, e.__scopeMenu), c = Ut(t, i), d = S.useRef(!1), p = () => {
      const h = i.current;
      if (!n && h) {
        const g = new CustomEvent(q5, { bubbles: !0, cancelable: !0 });
        h.addEventListener(q5, (y) => r?.(y), { once: !0 }), NM(h, g), g.defaultPrevented ? d.current = !1 : s.onClose();
      }
    };
    return /* @__PURE__ */ E.jsx(
      Oj,
      {
        ...o,
        ref: c,
        disabled: n,
        onClick: Ue(e.onClick, p),
        onPointerDown: (h) => {
          var g;
          (g = e.onPointerDown) == null || g.call(e, h), d.current = !0;
        },
        onPointerUp: Ue(e.onPointerUp, (h) => {
          var g;
          d.current || (g = h.currentTarget) == null || g.click();
        }),
        onKeyDown: Ue(e.onKeyDown, (h) => {
          const g = u.searchRef.current !== "";
          n || g && h.key === " " || Ex.includes(h.key) && (h.currentTarget.click(), h.preventDefault());
        })
      }
    );
  }
);
mg.displayName = dm;
var Oj = S.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: o, ...i } = e, s = b0(dm, n), u = xj(n), c = S.useRef(null), d = Ut(t, c), [p, h] = S.useState(!1), [g, y] = S.useState("");
    return S.useEffect(() => {
      const b = c.current;
      b && y((b.textContent ?? "").trim());
    }, [i.children]), /* @__PURE__ */ E.jsx(
      Hd.ItemSlot,
      {
        scope: n,
        disabled: r,
        textValue: o ?? g,
        children: /* @__PURE__ */ E.jsx(CZ, { asChild: !0, ...u, focusable: !r, children: /* @__PURE__ */ E.jsx(
          zt.div,
          {
            role: "menuitem",
            "data-highlighted": p ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...i,
            ref: d,
            onPointerMove: Ue(
              e.onPointerMove,
              $d((b) => {
                r ? s.onItemLeave(b) : (s.onItemEnter(b), b.defaultPrevented || b.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: Ue(
              e.onPointerLeave,
              $d((b) => s.onItemLeave(b))
            ),
            onFocus: Ue(e.onFocus, () => h(!0)),
            onBlur: Ue(e.onBlur, () => h(!1))
          }
        ) })
      }
    );
  }
), UZ = "MenuCheckboxItem", Aj = S.forwardRef(
  (e, t) => {
    const { checked: n = !1, onCheckedChange: r, ...o } = e;
    return /* @__PURE__ */ E.jsx(zj, { scope: e.__scopeMenu, checked: n, children: /* @__PURE__ */ E.jsx(
      mg,
      {
        role: "menuitemcheckbox",
        "aria-checked": fm(n) ? "mixed" : n,
        ...o,
        ref: t,
        "data-state": k0(n),
        onSelect: Ue(
          o.onSelect,
          () => r?.(fm(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
Aj.displayName = UZ;
var Nj = "MenuRadioGroup", [HZ, $Z] = ll(
  Nj,
  { value: void 0, onValueChange: () => {
  } }
), Mj = S.forwardRef(
  (e, t) => {
    const { value: n, onValueChange: r, ...o } = e, i = fo(r);
    return /* @__PURE__ */ E.jsx(HZ, { scope: e.__scopeMenu, value: n, onValueChange: i, children: /* @__PURE__ */ E.jsx(x0, { ...o, ref: t }) });
  }
);
Mj.displayName = Nj;
var Rj = "MenuRadioItem", jj = S.forwardRef(
  (e, t) => {
    const { value: n, ...r } = e, o = $Z(Rj, e.__scopeMenu), i = n === o.value;
    return /* @__PURE__ */ E.jsx(zj, { scope: e.__scopeMenu, checked: i, children: /* @__PURE__ */ E.jsx(
      mg,
      {
        role: "menuitemradio",
        "aria-checked": i,
        ...r,
        ref: t,
        "data-state": k0(i),
        onSelect: Ue(
          r.onSelect,
          () => {
            var s;
            return (s = o.onValueChange) == null ? void 0 : s.call(o, n);
          },
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
jj.displayName = Rj;
var S0 = "MenuItemIndicator", [zj, YZ] = ll(
  S0,
  { checked: !1 }
), Tj = S.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, forceMount: r, ...o } = e, i = YZ(S0, n);
    return /* @__PURE__ */ E.jsx(
      oa,
      {
        present: r || fm(i.checked) || i.checked === !0,
        children: /* @__PURE__ */ E.jsx(
          zt.span,
          {
            ...o,
            ref: t,
            "data-state": k0(i.checked)
          }
        )
      }
    );
  }
);
Tj.displayName = S0;
var qZ = "MenuSeparator", Dj = S.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ E.jsx(
      zt.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: t
      }
    );
  }
);
Dj.displayName = qZ;
var XZ = "MenuArrow", Pj = S.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, o = wf(n);
    return /* @__PURE__ */ E.jsx(fj, { ...o, ...r, ref: t });
  }
);
Pj.displayName = XZ;
var _0 = "MenuSub", [WZ, Lj] = ll(_0), Ij = (e) => {
  const { __scopeMenu: t, children: n, open: r = !1, onOpenChange: o } = e, i = ul(_0, t), s = wf(t), [u, c] = S.useState(null), [d, p] = S.useState(null), h = fo(o);
  return S.useEffect(() => (i.open === !1 && h(!1), () => h(!1)), [i.open, h]), /* @__PURE__ */ E.jsx(g0, { ...s, children: /* @__PURE__ */ E.jsx(
    Sj,
    {
      scope: t,
      open: r,
      onOpenChange: h,
      content: d,
      onContentChange: p,
      children: /* @__PURE__ */ E.jsx(
        WZ,
        {
          scope: t,
          contentId: qi(),
          triggerId: qi(),
          trigger: u,
          onTriggerChange: c,
          children: n
        }
      )
    }
  ) });
};
Ij.displayName = _0;
var ud = "MenuSubTrigger", Vj = S.forwardRef(
  (e, t) => {
    const n = ul(ud, e.__scopeMenu), r = xf(ud, e.__scopeMenu), o = Lj(ud, e.__scopeMenu), i = b0(ud, e.__scopeMenu), s = S.useRef(null), { pointerGraceTimerRef: u, onPointerGraceIntentChange: c } = i, d = { __scopeMenu: e.__scopeMenu }, p = S.useCallback(() => {
      s.current && window.clearTimeout(s.current), s.current = null;
    }, []);
    return S.useEffect(() => p, [p]), S.useEffect(() => {
      const h = u.current;
      return () => {
        window.clearTimeout(h), c(null);
      };
    }, [u, c]), /* @__PURE__ */ E.jsx(v0, { asChild: !0, ...d, children: /* @__PURE__ */ E.jsx(
      Oj,
      {
        id: o.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": o.contentId,
        "data-state": Uj(n.open),
        ...e,
        ref: eg(t, o.onTriggerChange),
        onClick: (h) => {
          var g;
          (g = e.onClick) == null || g.call(e, h), !(e.disabled || h.defaultPrevented) && (h.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: Ue(
          e.onPointerMove,
          $d((h) => {
            i.onItemEnter(h), !h.defaultPrevented && !e.disabled && !n.open && !s.current && (i.onPointerGraceIntentChange(null), s.current = window.setTimeout(() => {
              n.onOpenChange(!0), p();
            }, 100));
          })
        ),
        onPointerLeave: Ue(
          e.onPointerLeave,
          $d((h) => {
            var g, y;
            p();
            const b = (g = n.content) == null ? void 0 : g.getBoundingClientRect();
            if (b) {
              const v = (y = n.content) == null ? void 0 : y.dataset.side, x = v === "right", _ = x ? -5 : 5, O = b[x ? "left" : "right"], C = b[x ? "right" : "left"];
              i.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: h.clientX + _, y: h.clientY },
                  { x: O, y: b.top },
                  { x: C, y: b.top },
                  { x: C, y: b.bottom },
                  { x: O, y: b.bottom }
                ],
                side: v
              }), window.clearTimeout(u.current), u.current = window.setTimeout(
                () => i.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (i.onTriggerLeave(h), h.defaultPrevented) return;
              i.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: Ue(e.onKeyDown, (h) => {
          var g;
          const y = i.searchRef.current !== "";
          e.disabled || y && h.key === " " || NZ[r.dir].includes(h.key) && (n.onOpenChange(!0), (g = n.content) == null || g.focus(), h.preventDefault());
        })
      }
    ) });
  }
);
Vj.displayName = ud;
var Bj = "MenuSubContent", Fj = S.forwardRef(
  (e, t) => {
    const n = kj(co, e.__scopeMenu), { forceMount: r = n.forceMount, ...o } = e, i = ul(co, e.__scopeMenu), s = xf(co, e.__scopeMenu), u = Lj(Bj, e.__scopeMenu), c = S.useRef(null), d = Ut(t, c);
    return /* @__PURE__ */ E.jsx(Hd.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ E.jsx(oa, { present: r || i.open, children: /* @__PURE__ */ E.jsx(Hd.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ E.jsx(
      w0,
      {
        id: u.contentId,
        "aria-labelledby": u.triggerId,
        ...o,
        ref: d,
        align: "start",
        side: s.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (p) => {
          var h;
          s.isUsingKeyboardRef.current && ((h = c.current) == null || h.focus()), p.preventDefault();
        },
        onCloseAutoFocus: (p) => p.preventDefault(),
        onFocusOutside: Ue(e.onFocusOutside, (p) => {
          p.target !== u.trigger && i.onOpenChange(!1);
        }),
        onEscapeKeyDown: Ue(e.onEscapeKeyDown, (p) => {
          s.onClose(), p.preventDefault();
        }),
        onKeyDown: Ue(e.onKeyDown, (p) => {
          var h;
          const g = p.currentTarget.contains(p.target), y = MZ[s.dir].includes(p.key);
          g && y && (i.onOpenChange(!1), (h = u.trigger) == null || h.focus(), p.preventDefault());
        })
      }
    ) }) }) });
  }
);
Fj.displayName = Bj;
function Uj(e) {
  return e ? "open" : "closed";
}
function fm(e) {
  return e === "indeterminate";
}
function k0(e) {
  return fm(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function GZ(e) {
  const t = document.activeElement;
  for (const n of e)
    if (n === t || (n.focus(), document.activeElement !== t)) return;
}
function ZZ(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
function KZ(e, t, n) {
  const r = t.length > 1 && Array.from(t).every((u) => u === t[0]) ? t[0] : t, o = n ? e.indexOf(n) : -1;
  let i = ZZ(e, Math.max(o, 0));
  r.length === 1 && (i = i.filter((u) => u !== n));
  const s = i.find(
    (u) => u.toLowerCase().startsWith(r.toLowerCase())
  );
  return s !== n ? s : void 0;
}
function QZ(e, t) {
  const { x: n, y: r } = e;
  let o = !1;
  for (let i = 0, s = t.length - 1; i < t.length; s = i++) {
    const u = t[i].x, c = t[i].y, d = t[s].x, p = t[s].y;
    c > r != p > r && n < (d - u) * (r - c) / (p - c) + u && (o = !o);
  }
  return o;
}
function JZ(e, t) {
  if (!t) return !1;
  const n = { x: e.clientX, y: e.clientY };
  return QZ(n, t);
}
function $d(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
var eK = _j, tK = v0, nK = Ej, rK = x0, oK = Cj, iK = mg, aK = Aj, sK = Mj, lK = jj, uK = Tj, cK = Dj, dK = Pj, fK = Ij, pK = Vj, hK = Fj, E0 = "DropdownMenu", [mK, Bve] = us(
  E0,
  [wj]
), rr = wj(), [gK, Hj] = mK(E0), $j = (e) => {
  const {
    __scopeDropdownMenu: t,
    children: n,
    dir: r,
    open: o,
    defaultOpen: i,
    onOpenChange: s,
    modal: u = !0
  } = e, c = rr(t), d = S.useRef(null), [p = !1, h] = Uu({
    prop: o,
    defaultProp: i,
    onChange: s
  });
  return /* @__PURE__ */ E.jsx(
    gK,
    {
      scope: t,
      triggerId: qi(),
      triggerRef: d,
      contentId: qi(),
      open: p,
      onOpenChange: h,
      onOpenToggle: S.useCallback(() => h((g) => !g), [h]),
      modal: u,
      children: /* @__PURE__ */ E.jsx(eK, { ...c, open: p, onOpenChange: h, dir: r, modal: u, children: n })
    }
  );
};
$j.displayName = E0;
var Yj = "DropdownMenuTrigger", qj = S.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...o } = e, i = Hj(Yj, n), s = rr(n);
    return /* @__PURE__ */ E.jsx(tK, { asChild: !0, ...s, children: /* @__PURE__ */ E.jsx(
      zt.button,
      {
        type: "button",
        id: i.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": i.open,
        "aria-controls": i.open ? i.contentId : void 0,
        "data-state": i.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...o,
        ref: eg(t, i.triggerRef),
        onPointerDown: Ue(e.onPointerDown, (u) => {
          !r && u.button === 0 && u.ctrlKey === !1 && (i.onOpenToggle(), i.open || u.preventDefault());
        }),
        onKeyDown: Ue(e.onKeyDown, (u) => {
          r || (["Enter", " "].includes(u.key) && i.onOpenToggle(), u.key === "ArrowDown" && i.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(u.key) && u.preventDefault());
        })
      }
    ) });
  }
);
qj.displayName = Yj;
var Xj = "DropdownMenuContent", Wj = S.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Hj(Xj, n), i = rr(n), s = S.useRef(!1);
    return /* @__PURE__ */ E.jsx(
      nK,
      {
        id: o.contentId,
        "aria-labelledby": o.triggerId,
        ...i,
        ...r,
        ref: t,
        onCloseAutoFocus: Ue(e.onCloseAutoFocus, (u) => {
          var c;
          s.current || (c = o.triggerRef.current) == null || c.focus(), s.current = !1, u.preventDefault();
        }),
        onInteractOutside: Ue(e.onInteractOutside, (u) => {
          const c = u.detail.originalEvent, d = c.button === 0 && c.ctrlKey === !0, p = c.button === 2 || d;
          (!o.modal || p) && (s.current = !0);
        }),
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
Wj.displayName = Xj;
var yK = "DropdownMenuGroup", Gj = S.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = rr(n);
    return /* @__PURE__ */ E.jsx(rK, { ...o, ...r, ref: t });
  }
);
Gj.displayName = yK;
var vK = "DropdownMenuLabel", bK = S.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = rr(n);
    return /* @__PURE__ */ E.jsx(oK, { ...o, ...r, ref: t });
  }
);
bK.displayName = vK;
var wK = "DropdownMenuItem", Zj = S.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = rr(n);
    return /* @__PURE__ */ E.jsx(iK, { ...o, ...r, ref: t });
  }
);
Zj.displayName = wK;
var xK = "DropdownMenuCheckboxItem", SK = S.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = rr(n);
  return /* @__PURE__ */ E.jsx(aK, { ...o, ...r, ref: t });
});
SK.displayName = xK;
var _K = "DropdownMenuRadioGroup", Kj = S.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = rr(n);
  return /* @__PURE__ */ E.jsx(sK, { ...o, ...r, ref: t });
});
Kj.displayName = _K;
var kK = "DropdownMenuRadioItem", Qj = S.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = rr(n);
  return /* @__PURE__ */ E.jsx(lK, { ...o, ...r, ref: t });
});
Qj.displayName = kK;
var EK = "DropdownMenuItemIndicator", CK = S.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = rr(n);
  return /* @__PURE__ */ E.jsx(uK, { ...o, ...r, ref: t });
});
CK.displayName = EK;
var OK = "DropdownMenuSeparator", AK = S.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = rr(n);
  return /* @__PURE__ */ E.jsx(cK, { ...o, ...r, ref: t });
});
AK.displayName = OK;
var NK = "DropdownMenuArrow", MK = S.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = rr(n);
    return /* @__PURE__ */ E.jsx(dK, { ...o, ...r, ref: t });
  }
);
MK.displayName = NK;
var RK = (e) => {
  const { __scopeDropdownMenu: t, children: n, open: r, onOpenChange: o, defaultOpen: i } = e, s = rr(t), [u = !1, c] = Uu({
    prop: r,
    defaultProp: i,
    onChange: o
  });
  return /* @__PURE__ */ E.jsx(fK, { ...s, open: u, onOpenChange: c, children: n });
}, jK = "DropdownMenuSubTrigger", Jj = S.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = rr(n);
  return /* @__PURE__ */ E.jsx(pK, { ...o, ...r, ref: t });
});
Jj.displayName = jK;
var zK = "DropdownMenuSubContent", e6 = S.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = rr(n);
  return /* @__PURE__ */ E.jsx(
    hK,
    {
      ...o,
      ...r,
      ref: t,
      style: {
        ...e.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
e6.displayName = zK;
var t6 = $j, n6 = qj, r6 = Wj, o6 = Gj, qa = Zj, TK = Kj, DK = Qj, PK = RK, LK = Jj, IK = e6;
const Cx = {
  xxs: 0,
  xs: 320,
  s: 480,
  m: 768,
  l: 960,
  xl: 1280,
  xxl: 1920
}, i6 = S.createContext(void 0), VK = S.forwardRef((e, t) => {
  const { className: n, children: r, ...o } = e, [i, s] = S.useState("m"), [u, c] = S.useState(0), [d, p] = S.useState(0), h = S.useRef(null);
  S.useImperativeHandle(
    t,
    () => h.current,
    []
  );
  const g = S.useCallback((y) => {
    const b = y.width, v = y.height;
    let x = "xxs";
    Object.entries(Cx).forEach(([_, O]) => {
      b >= O && (x = _);
    }), s((_) => _ !== x ? x : _), c(b), p(v);
  }, []);
  return S.useEffect(() => {
    const y = h.current;
    if (!y)
      return;
    const b = new ResizeObserver((v) => {
      for (let x of v)
        g(x.contentRect);
    });
    return b.observe(y), g(y.getBoundingClientRect()), () => {
      b.disconnect();
    };
  }, []), /* @__PURE__ */ E.jsx(i6.Provider, { value: { wKey: i, w: u, h: d }, children: /* @__PURE__ */ E.jsx(
    "div",
    {
      ref: h,
      className: `size-context w-${i} ${n || ""}`.trim(),
      ...o,
      children: r
    }
  ) });
}), BK = () => {
  const e = S.useContext(i6);
  if (!e)
    throw new Error(
      "useSizeContext must be used within a SizeContextContainerContext"
    );
  return e;
}, FK = (e, t) => e == t ? !1 : e == "" ? !0 : Cx[e] < Cx[t], UK = (e) => FK(BK().wKey, e), wu = ({
  direction: e,
  className: t = "",
  children: n,
  wrap: r = !1,
  grow: o = !1,
  ...i
}) => {
  const s = "float-container";
  let u = "";
  typeof e == "string" ? u = `direction-${e} ` : typeof e == "object" && e !== null && Object.entries(e).forEach(([p, h]) => {
    p === "" ? u += `direction-${h} ` : u += `${p}-direction-${h} `;
  });
  let c = "";
  typeof o == "boolean" ? c = o ? "grow " : "" : typeof o == "object" && o !== null && Object.entries(o).forEach(([p, h]) => {
    p === "" ? c += h ? "grow " : "no-grow" : c += h ? `${p}-grow ` : `${p}-no-grow`;
  }), u += c, r && (u += "flex-wrap "), u = u.trim();
  const d = `${s} ${u} ${t}`.trim();
  return /* @__PURE__ */ E.jsx("div", { className: d, ...i, children: n });
}, a6 = ({
  direction: e,
  expanded: t = !0,
  children: n,
  className: r,
  maxSize: o = "18.75rem",
  expanderSize: i = "2rem",
  containerStyle: s,
  style: u,
  containerClassName: c,
  onExpandChange: d,
  ...p
}) => {
  const h = {
    up: wx,
    down: L5,
    left: P5,
    right: bx
  }[e], g = {
    up: L5,
    down: wx,
    left: bx,
    right: P5
  }[e], [y, b] = S.useState(t), v = (I) => {
    y !== I && (b(I), d && d(I));
  }, x = `${e} ${y ? "expanded" : "collapsed"}`, _ = e === "right" || e === "left" ? { width: y ? o : i } : { height: y ? o : i }, O = e === "right" || e === "left" ? { width: y ? o : 0 } : { height: y ? o : 0 }, C = e === "right" || e === "left" ? { width: i } : { height: i }, N = /* @__PURE__ */ E.jsx(
    "div",
    {
      className: `expanding_container_content ${x} ${r || ""}`.trim(),
      style: { ...u, ...O },
      ...p,
      children: n
    }
  ), R = /* @__PURE__ */ E.jsx(
    "div",
    {
      className: `expanding_container_expander ${x}`,
      onClick: () => v(!y),
      style: C,
      children: y ? /* @__PURE__ */ E.jsx(g, {}) : /* @__PURE__ */ E.jsx(h, {})
    }
  ), z = e === "right" || e === "down" ? N : R, j = e === "left" || e === "up" ? N : R;
  return /* @__PURE__ */ E.jsxs(
    "div",
    {
      className: `expanding_container ${x} ${c || ""}`,
      style: { ...s, ..._ },
      children: [
        z,
        j
      ]
    }
  );
}, HK = ({
  trigger: e,
  setOpen: t,
  open: n
}) => {
  const [r, o] = S.useState(""), i = S.useContext(it);
  return i.options.useWorkerManager ? /* @__PURE__ */ E.jsxs(
    $u,
    {
      setOpen: t,
      open: n,
      trigger: e,
      title: "New Worker",
      description: "Create a new worker",
      children: [
        /* @__PURE__ */ E.jsxs("div", { children: [
          "Name:",
          /* @__PURE__ */ E.jsx("br", {}),
          /* @__PURE__ */ E.jsx(
            "input",
            {
              className: "styledinput",
              onChange: (s) => {
                o(s.currentTarget.value);
              },
              value: r
            }
          )
        ] }),
        /* @__PURE__ */ E.jsx("div", { children: r && /* @__PURE__ */ E.jsx("div", { children: /* @__PURE__ */ E.jsx(
          "button",
          {
            className: "styledbtn",
            onClick: () => {
              var s;
              (s = i.workermanager) == null || s.new_worker({
                name: r
                // reference: reference.uuid,
                // copyLib,
                // copyNS,
              }), t(!1);
            },
            children: "Create"
          }
        ) }) })
      ]
    }
  ) : null;
}, $K = ({
  trigger: e,
  setOpen: t,
  open: n
}) => {
  var r, o;
  const i = S.useContext(it), [s, u] = S.useState(!1), c = i.workers(), d = (r = i.worker) == null ? void 0 : r.uuid, p = (d ? (o = c[d]) == null ? void 0 : o.name : void 0) || d || "worker", h = async () => {
    if (!i.worker) return;
    const g = await i.worker.export({ withFiles: s });
    B$(g, p + ".fnw", "application/zip"), t(!1);
  };
  return /* @__PURE__ */ E.jsx(
    $u,
    {
      setOpen: t,
      open: n,
      trigger: e,
      title: "Export Worker",
      description: "Export the worker as a .fnw file",
      children: /* @__PURE__ */ E.jsxs("div", { children: [
        /* @__PURE__ */ E.jsxs("div", { children: [
          /* @__PURE__ */ E.jsx(
            "input",
            {
              type: "checkbox",
              className: "styledcheckbox",
              checked: s,
              onChange: (g) => {
                u(g.currentTarget.checked);
              }
            }
          ),
          "Include Files"
        ] }),
        /* @__PURE__ */ E.jsx("button", { className: "styledbtn", onClick: h, children: "Export" })
      ] })
    }
  );
}, YK = () => {
  const e = S.useContext(it).progress_state();
  return /* @__PURE__ */ E.jsxs("div", { className: "statusbar", children: [
    /* @__PURE__ */ E.jsx(
      "span",
      {
        className: "statusbar-progressbar",
        style: { width: Math.min(100, 100 * e.progress) + "%" }
      }
    ),
    /* @__PURE__ */ E.jsx("span", { className: "statusbar-message", children: e.message })
  ] });
}, qK = () => {
  var e;
  const t = S.useContext(it), n = t.workers(), [r, o] = S.useState(!1), [i, s] = S.useState(!1), u = (y) => {
    y !== "__select__" && t.workers && t.workermanager && n[y] && (!n[y].active && !window.confirm(
      "this is an inactive worker, selecting it will start it, continue?"
    ) || t.workermanager.set_active(y));
  }, c = async () => {
    if (!t.worker || !window.confirm(
      "Updateing the worker might replace the current nodespace, continue?"
    )) return;
    const y = await H$(".fnw");
    t.worker.update_from_export(y);
  }, d = t.options.useWorkerManager && t.workermanager && t.workermanager.open || qw, p = d && Object.keys(n).length > 0, h = t.worker && t.worker.is_open, g = h && d;
  return d || h ? /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsxs(t6, { children: [
      /* @__PURE__ */ E.jsx(n6, { asChild: !0, children: /* @__PURE__ */ E.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ E.jsxs(wu, { direction: "row", children: [
        "Worker ",
        /* @__PURE__ */ E.jsx(BR, {})
      ] }) }) }),
      /* @__PURE__ */ E.jsx(r6, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ E.jsxs(o6, { children: [
        p && /* @__PURE__ */ E.jsxs(PK, { children: [
          /* @__PURE__ */ E.jsx(LK, { className: "headermenuitem submenuitem", children: /* @__PURE__ */ E.jsxs(wu, { direction: "row", children: [
            "Select",
            /* @__PURE__ */ E.jsx(bx, {})
          ] }) }),
          /* @__PURE__ */ E.jsx(
            IK,
            {
              className: "headermenucontent funcnodescontainer",
              sideOffset: 2,
              alignOffset: -5,
              children: /* @__PURE__ */ E.jsx(
                TK,
                {
                  value: (e = t.worker) == null ? void 0 : e.uuid,
                  onValueChange: (y) => {
                    u(y);
                  },
                  children: Object.keys(n).sort((y, b) => {
                    if (n[y].active && !n[b].active)
                      return -1;
                    if (!n[y].active && n[b].active)
                      return 1;
                    const v = n[y].name || y, x = n[b].name || b;
                    return v.localeCompare(x);
                  }).map((y) => {
                    var b, v, x;
                    return /* @__PURE__ */ E.jsx(
                      DK,
                      {
                        className: "headermenuitem workerselectoption" + ((b = n[y]) != null && b.active ? " active" : " inactive") + " headermenuitem",
                        value: y,
                        disabled: y === ((v = t.worker) == null ? void 0 : v.uuid),
                        children: ((x = n[y]) == null ? void 0 : x.name) || y
                      },
                      y
                    );
                  })
                }
              )
            }
          )
        ] }),
        h && /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
          g && /* @__PURE__ */ E.jsx(
            qa,
            {
              className: "headermenuitem",
              onClick: () => {
                var y;
                if (t.worker) {
                  if (!t.workermanager)
                    return t.logger.error("no workermanager");
                  (y = t.workermanager) == null || y.restart_worker(
                    t.worker.uuid
                  );
                }
              },
              children: "Restart"
            }
          ),
          /* @__PURE__ */ E.jsx(
            qa,
            {
              className: "headermenuitem",
              onClick: () => {
                t.worker && t.worker.stop();
              },
              children: "Stop"
            }
          ),
          /* @__PURE__ */ E.jsx(
            qa,
            {
              className: "headermenuitem",
              onClick: () => s(!0),
              children: "Export"
            }
          ),
          /* @__PURE__ */ E.jsx(
            qa,
            {
              className: "headermenuitem",
              onClick: c,
              children: "Update"
            }
          )
        ] }),
        d && /* @__PURE__ */ E.jsx(E.Fragment, { children: /* @__PURE__ */ E.jsx(
          qa,
          {
            className: "headermenuitem",
            onClick: () => o(!0),
            children: "New"
          }
        ) })
      ] }) })
    ] }),
    /* @__PURE__ */ E.jsx(
      HK,
      {
        open: r,
        setOpen: o
      }
    ),
    /* @__PURE__ */ E.jsx(
      $K,
      {
        open: i,
        setOpen: s
      }
    )
  ] }) : null;
}, XK = () => {
  const e = S.useContext(it), t = () => {
    var o;
    window.confirm("Are you sure you want to start a new flow?") && ((o = e.worker) == null || o.clear());
  }, n = async () => {
    var o;
    const i = await ((o = e.worker) == null ? void 0 : o.save());
    if (!i) return;
    const s = new Blob([JSON.stringify(i)], {
      type: "application/json"
    }), u = URL.createObjectURL(s), c = document.createElement("a");
    c.href = u, c.download = "flow.json", c.click(), URL.revokeObjectURL(u), c.remove();
  }, r = async () => {
    const o = document.createElement("input");
    o.type = "file", o.accept = ".json", o.onchange = async (i) => {
      var s;
      const u = (s = i.target.files) == null ? void 0 : s[0];
      if (!u) return;
      const c = new FileReader();
      c.onload = async (d) => {
        var p, h;
        const g = (p = d.target) == null ? void 0 : p.result;
        if (!g) return;
        const y = JSON.parse(g);
        await ((h = e.worker) == null ? void 0 : h.load(y));
      }, c.readAsText(u);
    }, o.click();
  };
  return /* @__PURE__ */ E.jsx(E.Fragment, { children: /* @__PURE__ */ E.jsxs(t6, { children: [
    /* @__PURE__ */ E.jsx(n6, { asChild: !0, children: /* @__PURE__ */ E.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ E.jsxs(wu, { direction: "row", children: [
      "Nodespace ",
      /* @__PURE__ */ E.jsx(BR, {})
    ] }) }) }),
    /* @__PURE__ */ E.jsx(r6, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ E.jsxs(o6, { children: [
      /* @__PURE__ */ E.jsx(qa, { className: "headermenuitem", onClick: t, children: "New" }),
      /* @__PURE__ */ E.jsx(qa, { className: "headermenuitem", onClick: n, children: "Save" }),
      /* @__PURE__ */ E.jsx(qa, { className: "headermenuitem", onClick: r, children: "Load" })
    ] }) })
  ] }) });
}, WK = ({ ...e }) => {
  const t = S.useContext(it), n = t.workerstate();
  return Object.keys(e).length > 0 && t.logger.debug("headerprops", e), /* @__PURE__ */ E.jsxs(wu, { className: "funcnodesreactflowheader", direction: "row", wrap: !0, children: [
    /* @__PURE__ */ E.jsx(
      wu,
      {
        className: "headerelement m-w-6",
        grow: {
          "": !0,
          m: !1
        },
        children: /* @__PURE__ */ E.jsx(YK, {})
      }
    ),
    (e.showmenu || qw) && /* @__PURE__ */ E.jsxs(wu, { direction: "row", wrap: !0, children: [
      /* @__PURE__ */ E.jsx("div", { className: "headerelement", children: /* @__PURE__ */ E.jsx(qK, {}) }),
      (t.worker && n.is_open || qw) && /* @__PURE__ */ E.jsx("div", { className: "headerelement", children: /* @__PURE__ */ E.jsx(XK, {}) })
    ] })
  ] });
};
function GK(e, t) {
  const n = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const ZK = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, KK = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, QK = {};
function X5(e, t) {
  return (QK.jsx ? KK : ZK).test(e);
}
const JK = /[ \t\n\f\r]/g;
function eQ(e) {
  return typeof e == "object" ? e.type === "text" ? W5(e.value) : !1 : W5(e);
}
function W5(e) {
  return e.replace(JK, "") === "";
}
class Sf {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, n, r) {
    this.normal = n, this.property = t, r && (this.space = r);
  }
}
Sf.prototype.normal = {};
Sf.prototype.property = {};
Sf.prototype.space = void 0;
function s6(e, t) {
  const n = {}, r = {};
  for (const o of e)
    Object.assign(n, o.property), Object.assign(r, o.normal);
  return new Sf(n, r, t);
}
function Ox(e) {
  return e.toLowerCase();
}
class vr {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(t, n) {
    this.attribute = n, this.property = t;
  }
}
vr.prototype.attribute = "";
vr.prototype.booleanish = !1;
vr.prototype.boolean = !1;
vr.prototype.commaOrSpaceSeparated = !1;
vr.prototype.commaSeparated = !1;
vr.prototype.defined = !1;
vr.prototype.mustUseProperty = !1;
vr.prototype.number = !1;
vr.prototype.overloadedBoolean = !1;
vr.prototype.property = "";
vr.prototype.spaceSeparated = !1;
vr.prototype.space = void 0;
let tQ = 0;
const qe = cl(), fn = cl(), l6 = cl(), we = cl(), jt = cl(), xu = cl(), jr = cl();
function cl() {
  return 2 ** ++tQ;
}
const Ax = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: qe,
  booleanish: fn,
  commaOrSpaceSeparated: jr,
  commaSeparated: xu,
  number: we,
  overloadedBoolean: l6,
  spaceSeparated: jt
}, Symbol.toStringTag, { value: "Module" })), zb = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(Ax)
);
class C0 extends vr {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(t, n, r, o) {
    let i = -1;
    if (super(t, n), G5(this, "space", o), typeof r == "number")
      for (; ++i < zb.length; ) {
        const s = zb[i];
        G5(this, zb[i], (r & Ax[s]) === Ax[s]);
      }
  }
}
C0.prototype.defined = !0;
function G5(e, t, n) {
  n && (e[t] = n);
}
function Xu(e) {
  const t = {}, n = {};
  for (const [r, o] of Object.entries(e.properties)) {
    const i = new C0(
      r,
      e.transform(e.attributes || {}, r),
      o,
      e.space
    );
    e.mustUseProperty && e.mustUseProperty.includes(r) && (i.mustUseProperty = !0), t[r] = i, n[Ox(r)] = r, n[Ox(i.attribute)] = r;
  }
  return new Sf(t, n, e.space);
}
const u6 = Xu({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: fn,
    ariaAutoComplete: null,
    ariaBusy: fn,
    ariaChecked: fn,
    ariaColCount: we,
    ariaColIndex: we,
    ariaColSpan: we,
    ariaControls: jt,
    ariaCurrent: null,
    ariaDescribedBy: jt,
    ariaDetails: null,
    ariaDisabled: fn,
    ariaDropEffect: jt,
    ariaErrorMessage: null,
    ariaExpanded: fn,
    ariaFlowTo: jt,
    ariaGrabbed: fn,
    ariaHasPopup: null,
    ariaHidden: fn,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: jt,
    ariaLevel: we,
    ariaLive: null,
    ariaModal: fn,
    ariaMultiLine: fn,
    ariaMultiSelectable: fn,
    ariaOrientation: null,
    ariaOwns: jt,
    ariaPlaceholder: null,
    ariaPosInSet: we,
    ariaPressed: fn,
    ariaReadOnly: fn,
    ariaRelevant: null,
    ariaRequired: fn,
    ariaRoleDescription: jt,
    ariaRowCount: we,
    ariaRowIndex: we,
    ariaRowSpan: we,
    ariaSelected: fn,
    ariaSetSize: we,
    ariaSort: null,
    ariaValueMax: we,
    ariaValueMin: we,
    ariaValueNow: we,
    ariaValueText: null,
    role: null
  },
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  }
});
function c6(e, t) {
  return t in e ? e[t] : t;
}
function d6(e, t) {
  return c6(e, t.toLowerCase());
}
const nQ = Xu({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: xu,
    acceptCharset: jt,
    accessKey: jt,
    action: null,
    allow: null,
    allowFullScreen: qe,
    allowPaymentRequest: qe,
    allowUserMedia: qe,
    alt: null,
    as: null,
    async: qe,
    autoCapitalize: null,
    autoComplete: jt,
    autoFocus: qe,
    autoPlay: qe,
    blocking: jt,
    capture: null,
    charSet: null,
    checked: qe,
    cite: null,
    className: jt,
    cols: we,
    colSpan: null,
    content: null,
    contentEditable: fn,
    controls: qe,
    controlsList: jt,
    coords: we | xu,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: qe,
    defer: qe,
    dir: null,
    dirName: null,
    disabled: qe,
    download: l6,
    draggable: fn,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: qe,
    formTarget: null,
    headers: jt,
    height: we,
    hidden: qe,
    high: we,
    href: null,
    hrefLang: null,
    htmlFor: jt,
    httpEquiv: jt,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: qe,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: qe,
    itemId: null,
    itemProp: jt,
    itemRef: jt,
    itemScope: qe,
    itemType: jt,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: qe,
    low: we,
    manifest: null,
    max: null,
    maxLength: we,
    media: null,
    method: null,
    min: null,
    minLength: we,
    multiple: qe,
    muted: qe,
    name: null,
    nonce: null,
    noModule: qe,
    noValidate: qe,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: qe,
    optimum: we,
    pattern: null,
    ping: jt,
    placeholder: null,
    playsInline: qe,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: qe,
    referrerPolicy: null,
    rel: jt,
    required: qe,
    reversed: qe,
    rows: we,
    rowSpan: we,
    sandbox: jt,
    scope: null,
    scoped: qe,
    seamless: qe,
    selected: qe,
    shadowRootClonable: qe,
    shadowRootDelegatesFocus: qe,
    shadowRootMode: null,
    shape: null,
    size: we,
    sizes: null,
    slot: null,
    span: we,
    spellCheck: fn,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: we,
    step: null,
    style: null,
    tabIndex: we,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: qe,
    useMap: null,
    value: fn,
    width: we,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: jt,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: we,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: we,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: qe,
    // Lists. Use CSS to reduce space between items instead
    declare: qe,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: we,
    // `<img>` and `<object>`
    leftMargin: we,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: we,
    // `<body>`
    marginWidth: we,
    // `<body>`
    noResize: qe,
    // `<frame>`
    noHref: qe,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: qe,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: qe,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: we,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: fn,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: we,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: we,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: qe,
    disableRemotePlayback: qe,
    prefix: null,
    property: null,
    results: we,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: d6
}), rQ = Xu({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: jr,
    accentHeight: we,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: we,
    amplitude: we,
    arabicForm: null,
    ascent: we,
    attributeName: null,
    attributeType: null,
    azimuth: we,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: we,
    by: null,
    calcMode: null,
    capHeight: we,
    className: jt,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: we,
    diffuseConstant: we,
    direction: null,
    display: null,
    dur: null,
    divisor: we,
    dominantBaseline: null,
    download: qe,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: we,
    enableBackground: null,
    end: null,
    event: null,
    exponent: we,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: we,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: xu,
    g2: xu,
    glyphName: xu,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: we,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: we,
    horizOriginX: we,
    horizOriginY: we,
    id: null,
    ideographic: we,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: we,
    k: we,
    k1: we,
    k2: we,
    k3: we,
    k4: we,
    kernelMatrix: jr,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: we,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: we,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: we,
    overlineThickness: we,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: we,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: jt,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: we,
    pointsAtY: we,
    pointsAtZ: we,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: jr,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: jr,
    rev: jr,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: jr,
    requiredFeatures: jr,
    requiredFonts: jr,
    requiredFormats: jr,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: we,
    specularExponent: we,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: we,
    strikethroughThickness: we,
    string: null,
    stroke: null,
    strokeDashArray: jr,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: we,
    strokeOpacity: we,
    strokeWidth: null,
    style: null,
    surfaceScale: we,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: jr,
    tabIndex: we,
    tableValues: null,
    target: null,
    targetX: we,
    targetY: we,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: jr,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: we,
    underlineThickness: we,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: we,
    values: null,
    vAlphabetic: we,
    vMathematical: we,
    vectorEffect: null,
    vHanging: we,
    vIdeographic: we,
    version: null,
    vertAdvY: we,
    vertOriginX: we,
    vertOriginY: we,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: we,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: c6
}), f6 = Xu({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  }
}), p6 = Xu({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: d6
}), h6 = Xu({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  }
}), oQ = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, iQ = /[A-Z]/g, Z5 = /-[a-z]/g, aQ = /^data[-\w.:]+$/i;
function sQ(e, t) {
  const n = Ox(t);
  let r = t, o = vr;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && aQ.test(t)) {
    if (t.charAt(4) === "-") {
      const i = t.slice(5).replace(Z5, uQ);
      r = "data" + i.charAt(0).toUpperCase() + i.slice(1);
    } else {
      const i = t.slice(4);
      if (!Z5.test(i)) {
        let s = i.replace(iQ, lQ);
        s.charAt(0) !== "-" && (s = "-" + s), t = "data" + s;
      }
    }
    o = C0;
  }
  return new o(r, t);
}
function lQ(e) {
  return "-" + e.toLowerCase();
}
function uQ(e) {
  return e.charAt(1).toUpperCase();
}
const cQ = s6([u6, nQ, f6, p6, h6], "html"), O0 = s6([u6, rQ, f6, p6, h6], "svg");
function dQ(e) {
  return e.join(" ").trim();
}
var Kl = {}, Tb, K5;
function fQ() {
  if (K5) return Tb;
  K5 = 1;
  var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, n = /^\s*/, r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, o = /^:\s*/, i = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, s = /^[;\s]*/, u = /^\s+|\s+$/g, c = `
`, d = "/", p = "*", h = "", g = "comment", y = "declaration";
  Tb = function(v, x) {
    if (typeof v != "string")
      throw new TypeError("First argument must be a string");
    if (!v) return [];
    x = x || {};
    var _ = 1, O = 1;
    function C(W) {
      var D = W.match(t);
      D && (_ += D.length);
      var F = W.lastIndexOf(c);
      O = ~F ? W.length - F : O + W.length;
    }
    function N() {
      var W = { line: _, column: O };
      return function(D) {
        return D.position = new R(W), I(), D;
      };
    }
    function R(W) {
      this.start = W, this.end = { line: _, column: O }, this.source = x.source;
    }
    R.prototype.content = v;
    function z(W) {
      var D = new Error(
        x.source + ":" + _ + ":" + O + ": " + W
      );
      if (D.reason = W, D.filename = x.source, D.line = _, D.column = O, D.source = v, !x.silent) throw D;
    }
    function j(W) {
      var D = W.exec(v);
      if (D) {
        var F = D[0];
        return C(F), v = v.slice(F.length), D;
      }
    }
    function I() {
      j(n);
    }
    function $(W) {
      var D;
      for (W = W || []; D = A(); )
        D !== !1 && W.push(D);
      return W;
    }
    function A() {
      var W = N();
      if (!(d != v.charAt(0) || p != v.charAt(1))) {
        for (var D = 2; h != v.charAt(D) && (p != v.charAt(D) || d != v.charAt(D + 1)); )
          ++D;
        if (D += 2, h === v.charAt(D - 1))
          return z("End of comment missing");
        var F = v.slice(2, D - 2);
        return O += 2, C(F), v = v.slice(D), O += 2, W({
          type: g,
          comment: F
        });
      }
    }
    function V() {
      var W = N(), D = j(r);
      if (D) {
        if (A(), !j(o)) return z("property missing ':'");
        var F = j(i), P = W({
          type: y,
          property: b(D[0].replace(e, h)),
          value: F ? b(F[0].replace(e, h)) : h
        });
        return j(s), P;
      }
    }
    function U() {
      var W = [];
      $(W);
      for (var D; D = V(); )
        D !== !1 && (W.push(D), $(W));
      return W;
    }
    return I(), U();
  };
  function b(v) {
    return v ? v.replace(u, h) : h;
  }
  return Tb;
}
var Q5;
function pQ() {
  if (Q5) return Kl;
  Q5 = 1;
  var e = Kl && Kl.__importDefault || function(r) {
    return r && r.__esModule ? r : { default: r };
  };
  Object.defineProperty(Kl, "__esModule", { value: !0 }), Kl.default = n;
  var t = e(fQ());
  function n(r, o) {
    var i = null;
    if (!r || typeof r != "string")
      return i;
    var s = (0, t.default)(r), u = typeof o == "function";
    return s.forEach(function(c) {
      if (c.type === "declaration") {
        var d = c.property, p = c.value;
        u ? o(d, p, c) : p && (i = i || {}, i[d] = p);
      }
    }), i;
  }
  return Kl;
}
var Qc = {}, J5;
function hQ() {
  if (J5) return Qc;
  J5 = 1, Object.defineProperty(Qc, "__esModule", { value: !0 }), Qc.camelCase = void 0;
  var e = /^--[a-zA-Z0-9_-]+$/, t = /-([a-z])/g, n = /^[^-]+$/, r = /^-(webkit|moz|ms|o|khtml)-/, o = /^-(ms)-/, i = function(d) {
    return !d || n.test(d) || e.test(d);
  }, s = function(d, p) {
    return p.toUpperCase();
  }, u = function(d, p) {
    return "".concat(p, "-");
  }, c = function(d, p) {
    return p === void 0 && (p = {}), i(d) ? d : (d = d.toLowerCase(), p.reactCompat ? d = d.replace(o, u) : d = d.replace(r, u), d.replace(t, s));
  };
  return Qc.camelCase = c, Qc;
}
var Jc, eA;
function mQ() {
  if (eA) return Jc;
  eA = 1;
  var e = Jc && Jc.__importDefault || function(o) {
    return o && o.__esModule ? o : { default: o };
  }, t = e(pQ()), n = hQ();
  function r(o, i) {
    var s = {};
    return !o || typeof o != "string" || (0, t.default)(o, function(u, c) {
      u && c && (s[(0, n.camelCase)(u, i)] = c);
    }), s;
  }
  return r.default = r, Jc = r, Jc;
}
var gQ = mQ();
const yQ = /* @__PURE__ */ Dm(gQ), m6 = g6("end"), A0 = g6("start");
function g6(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function vQ(e) {
  const t = A0(e), n = m6(e);
  if (t && n)
    return { start: t, end: n };
}
function bd(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? tA(e.position) : "start" in e || "end" in e ? tA(e) : "line" in e || "column" in e ? Nx(e) : "";
}
function Nx(e) {
  return nA(e && e.line) + ":" + nA(e && e.column);
}
function tA(e) {
  return Nx(e && e.start) + "-" + Nx(e && e.end);
}
function nA(e) {
  return e && typeof e == "number" ? e : 1;
}
class Yn extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let o = "", i = {}, s = !1;
    if (n && ("line" in n && "column" in n ? i = { place: n } : "start" in n && "end" in n ? i = { place: n } : "type" in n ? i = {
      ancestors: [n],
      place: n.position
    } : i = { ...n }), typeof t == "string" ? o = t : !i.cause && t && (s = !0, o = t.message, i.cause = t), !i.ruleId && !i.source && typeof r == "string") {
      const c = r.indexOf(":");
      c === -1 ? i.ruleId = r : (i.source = r.slice(0, c), i.ruleId = r.slice(c + 1));
    }
    if (!i.place && i.ancestors && i.ancestors) {
      const c = i.ancestors[i.ancestors.length - 1];
      c && (i.place = c.position);
    }
    const u = i.place && "start" in i.place ? i.place.start : i.place;
    this.ancestors = i.ancestors || void 0, this.cause = i.cause || void 0, this.column = u ? u.column : void 0, this.fatal = void 0, this.file, this.message = o, this.line = u ? u.line : void 0, this.name = bd(i.place) || "1:1", this.place = i.place || void 0, this.reason = this.message, this.ruleId = i.ruleId || void 0, this.source = i.source || void 0, this.stack = s && i.cause && typeof i.cause.stack == "string" ? i.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
Yn.prototype.file = "";
Yn.prototype.name = "";
Yn.prototype.reason = "";
Yn.prototype.message = "";
Yn.prototype.stack = "";
Yn.prototype.column = void 0;
Yn.prototype.line = void 0;
Yn.prototype.ancestors = void 0;
Yn.prototype.cause = void 0;
Yn.prototype.fatal = void 0;
Yn.prototype.place = void 0;
Yn.prototype.ruleId = void 0;
Yn.prototype.source = void 0;
const N0 = {}.hasOwnProperty, bQ = /* @__PURE__ */ new Map(), wQ = /[A-Z]/g, xQ = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), SQ = /* @__PURE__ */ new Set(["td", "th"]), y6 = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function _Q(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = RQ(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = MQ(n, t.jsx, t.jsxs);
  }
  const o = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? O0 : cQ,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, i = v6(o, e, void 0);
  return i && typeof i != "string" ? i : o.create(
    e,
    o.Fragment,
    { children: i || void 0 },
    void 0
  );
}
function v6(e, t, n) {
  if (t.type === "element")
    return kQ(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return EQ(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return OQ(e, t, n);
  if (t.type === "mdxjsEsm")
    return CQ(e, t);
  if (t.type === "root")
    return AQ(e, t, n);
  if (t.type === "text")
    return NQ(e, t);
}
function kQ(e, t, n) {
  const r = e.schema;
  let o = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (o = O0, e.schema = o), e.ancestors.push(t);
  const i = w6(e, t.tagName, !1), s = jQ(e, t);
  let u = R0(e, t);
  return xQ.has(t.tagName) && (u = u.filter(function(c) {
    return typeof c == "string" ? !eQ(c) : !0;
  })), b6(e, s, i, t), M0(s, u), e.ancestors.pop(), e.schema = r, e.create(t, i, s, n);
}
function EQ(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const n = t.data.estree.body[0];
    return n.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(n.expression);
  }
  Yd(e, t.position);
}
function CQ(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  Yd(e, t.position);
}
function OQ(e, t, n) {
  const r = e.schema;
  let o = r;
  t.name === "svg" && r.space === "html" && (o = O0, e.schema = o), e.ancestors.push(t);
  const i = t.name === null ? e.Fragment : w6(e, t.name, !0), s = zQ(e, t), u = R0(e, t);
  return b6(e, s, i, t), M0(s, u), e.ancestors.pop(), e.schema = r, e.create(t, i, s, n);
}
function AQ(e, t, n) {
  const r = {};
  return M0(r, R0(e, t)), e.create(t, e.Fragment, r, n);
}
function NQ(e, t) {
  return t.value;
}
function b6(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function M0(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function MQ(e, t, n) {
  return r;
  function r(o, i, s, u) {
    const c = Array.isArray(s.children) ? n : t;
    return u ? c(i, s, u) : c(i, s);
  }
}
function RQ(e, t) {
  return n;
  function n(r, o, i, s) {
    const u = Array.isArray(i.children), c = A0(r);
    return t(
      o,
      i,
      s,
      u,
      {
        columnNumber: c ? c.column - 1 : void 0,
        fileName: e,
        lineNumber: c ? c.line : void 0
      },
      void 0
    );
  }
}
function jQ(e, t) {
  const n = {};
  let r, o;
  for (o in t.properties)
    if (o !== "children" && N0.call(t.properties, o)) {
      const i = TQ(e, o, t.properties[o]);
      if (i) {
        const [s, u] = i;
        e.tableCellAlignToStyle && s === "align" && typeof u == "string" && SQ.has(t.tagName) ? r = u : n[s] = u;
      }
    }
  if (r) {
    const i = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    i[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function zQ(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const o = r.data.estree.body[0];
        o.type;
        const i = o.expression;
        i.type;
        const s = i.properties[0];
        s.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(s.argument)
        );
      } else
        Yd(e, t.position);
    else {
      const o = r.name;
      let i;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const s = r.value.data.estree.body[0];
          s.type, i = e.evaluater.evaluateExpression(s.expression);
        } else
          Yd(e, t.position);
      else
        i = r.value === null ? !0 : r.value;
      n[o] = /** @type {Props[keyof Props]} */
      i;
    }
  return n;
}
function R0(e, t) {
  const n = [];
  let r = -1;
  const o = e.passKeys ? /* @__PURE__ */ new Map() : bQ;
  for (; ++r < t.children.length; ) {
    const i = t.children[r];
    let s;
    if (e.passKeys) {
      const c = i.type === "element" ? i.tagName : i.type === "mdxJsxFlowElement" || i.type === "mdxJsxTextElement" ? i.name : void 0;
      if (c) {
        const d = o.get(c) || 0;
        s = c + "-" + d, o.set(c, d + 1);
      }
    }
    const u = v6(e, i, s);
    u !== void 0 && n.push(u);
  }
  return n;
}
function TQ(e, t, n) {
  const r = sQ(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? GK(n) : dQ(n)), r.property === "style") {
      let o = typeof n == "object" ? n : DQ(e, String(n));
      return e.stylePropertyNameCase === "css" && (o = PQ(o)), ["style", o];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? oQ[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function DQ(e, t) {
  try {
    return yQ(t, { reactCompat: !0 });
  } catch (n) {
    if (e.ignoreInvalidStyle)
      return {};
    const r = (
      /** @type {Error} */
      n
    ), o = new Yn("Cannot parse `style` attribute", {
      ancestors: e.ancestors,
      cause: r,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    throw o.file = e.filePath || void 0, o.url = y6 + "#cannot-parse-style-attribute", o;
  }
}
function w6(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const o = t.split(".");
    let i = -1, s;
    for (; ++i < o.length; ) {
      const u = X5(o[i]) ? { type: "Identifier", name: o[i] } : { type: "Literal", value: o[i] };
      s = s ? {
        type: "MemberExpression",
        object: s,
        property: u,
        computed: !!(i && u.type === "Literal"),
        optional: !1
      } : u;
    }
    r = s;
  } else
    r = X5(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const o = (
      /** @type {string | number} */
      r.value
    );
    return N0.call(e.components, o) ? e.components[o] : o;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  Yd(e);
}
function Yd(e, t) {
  const n = new Yn(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = y6 + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function PQ(e) {
  const t = {};
  let n;
  for (n in e)
    N0.call(e, n) && (t[LQ(n)] = e[n]);
  return t;
}
function LQ(e) {
  let t = e.replace(wQ, IQ);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function IQ(e) {
  return "-" + e.toLowerCase();
}
const Db = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, VQ = {};
function j0(e, t) {
  const n = VQ, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, o = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return x6(e, r, o);
}
function x6(e, t, n) {
  if (BQ(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return rA(e.children, t, n);
  }
  return Array.isArray(e) ? rA(e, t, n) : "";
}
function rA(e, t, n) {
  const r = [];
  let o = -1;
  for (; ++o < e.length; )
    r[o] = x6(e[o], t, n);
  return r.join("");
}
function BQ(e) {
  return !!(e && typeof e == "object");
}
const oA = document.createElement("i");
function z0(e) {
  const t = "&" + e + ";";
  oA.innerHTML = t;
  const n = oA.textContent;
  return (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n
  );
}
function Br(e, t, n, r) {
  const o = e.length;
  let i = 0, s;
  if (t < 0 ? t = -t > o ? 0 : o + t : t = t > o ? o : t, n = n > 0 ? n : 0, r.length < 1e4)
    s = Array.from(r), s.unshift(t, n), e.splice(...s);
  else
    for (n && e.splice(t, n); i < r.length; )
      s = r.slice(i, i + 1e4), s.unshift(t, 0), e.splice(...s), i += 1e4, t += 1e4;
}
function so(e, t) {
  return e.length > 0 ? (Br(e, e.length, 0, t), e) : t;
}
const iA = {}.hasOwnProperty;
function S6(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    FQ(t, e[n]);
  return t;
}
function FQ(e, t) {
  let n;
  for (n in t) {
    const r = (iA.call(e, n) ? e[n] : void 0) || (e[n] = {}), o = t[n];
    let i;
    if (o)
      for (i in o) {
        iA.call(r, i) || (r[i] = []);
        const s = o[i];
        UQ(
          // @ts-expect-error Looks like a list.
          r[i],
          Array.isArray(s) ? s : s ? [s] : []
        );
      }
  }
}
function UQ(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  Br(e, 0, 0, r);
}
function _6(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function Ro(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const er = cs(/[A-Za-z]/), Un = cs(/[\dA-Za-z]/), HQ = cs(/[#-'*+\--9=?A-Z^-~]/);
function pm(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const Mx = cs(/\d/), $Q = cs(/[\dA-Fa-f]/), YQ = cs(/[!-/:-@[-`{-~]/);
function Pe(e) {
  return e !== null && e < -2;
}
function Mt(e) {
  return e !== null && (e < 0 || e === 32);
}
function rt(e) {
  return e === -2 || e === -1 || e === 32;
}
const gg = cs(new RegExp("\\p{P}|\\p{S}", "u")), rl = cs(/\s/);
function cs(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function Wu(e) {
  const t = [];
  let n = -1, r = 0, o = 0;
  for (; ++n < e.length; ) {
    const i = e.charCodeAt(n);
    let s = "";
    if (i === 37 && Un(e.charCodeAt(n + 1)) && Un(e.charCodeAt(n + 2)))
      o = 2;
    else if (i < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(i)) || (s = String.fromCharCode(i));
    else if (i > 55295 && i < 57344) {
      const u = e.charCodeAt(n + 1);
      i < 56320 && u > 56319 && u < 57344 ? (s = String.fromCharCode(i, u), o = 1) : s = "";
    } else
      s = String.fromCharCode(i);
    s && (t.push(e.slice(r, n), encodeURIComponent(s)), r = n + o + 1, s = ""), o && (n += o, o = 0);
  }
  return t.join("") + e.slice(r);
}
function lt(e, t, n, r) {
  const o = r ? r - 1 : Number.POSITIVE_INFINITY;
  let i = 0;
  return s;
  function s(c) {
    return rt(c) ? (e.enter(n), u(c)) : t(c);
  }
  function u(c) {
    return rt(c) && i++ < o ? (e.consume(c), u) : (e.exit(n), t(c));
  }
}
const qQ = {
  tokenize: XQ
};
function XQ(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, r, o);
  let n;
  return t;
  function r(u) {
    if (u === null) {
      e.consume(u);
      return;
    }
    return e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), lt(e, t, "linePrefix");
  }
  function o(u) {
    return e.enter("paragraph"), i(u);
  }
  function i(u) {
    const c = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = c), n = c, s(u);
  }
  function s(u) {
    if (u === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(u);
      return;
    }
    return Pe(u) ? (e.consume(u), e.exit("chunkText"), i) : (e.consume(u), s);
  }
}
const WQ = {
  tokenize: GQ
}, aA = {
  tokenize: ZQ
};
function GQ(e) {
  const t = this, n = [];
  let r = 0, o, i, s;
  return u;
  function u(C) {
    if (r < n.length) {
      const N = n[r];
      return t.containerState = N[1], e.attempt(N[0].continuation, c, d)(C);
    }
    return d(C);
  }
  function c(C) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, o && O();
      const N = t.events.length;
      let R = N, z;
      for (; R--; )
        if (t.events[R][0] === "exit" && t.events[R][1].type === "chunkFlow") {
          z = t.events[R][1].end;
          break;
        }
      _(r);
      let j = N;
      for (; j < t.events.length; )
        t.events[j][1].end = {
          ...z
        }, j++;
      return Br(t.events, R + 1, 0, t.events.slice(N)), t.events.length = j, d(C);
    }
    return u(C);
  }
  function d(C) {
    if (r === n.length) {
      if (!o)
        return g(C);
      if (o.currentConstruct && o.currentConstruct.concrete)
        return b(C);
      t.interrupt = !!(o.currentConstruct && !o._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(aA, p, h)(C);
  }
  function p(C) {
    return o && O(), _(r), g(C);
  }
  function h(C) {
    return t.parser.lazy[t.now().line] = r !== n.length, s = t.now().offset, b(C);
  }
  function g(C) {
    return t.containerState = {}, e.attempt(aA, y, b)(C);
  }
  function y(C) {
    return r++, n.push([t.currentConstruct, t.containerState]), g(C);
  }
  function b(C) {
    if (C === null) {
      o && O(), _(0), e.consume(C);
      return;
    }
    return o = o || t.parser.flow(t.now()), e.enter("chunkFlow", {
      _tokenizer: o,
      contentType: "flow",
      previous: i
    }), v(C);
  }
  function v(C) {
    if (C === null) {
      x(e.exit("chunkFlow"), !0), _(0), e.consume(C);
      return;
    }
    return Pe(C) ? (e.consume(C), x(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, u) : (e.consume(C), v);
  }
  function x(C, N) {
    const R = t.sliceStream(C);
    if (N && R.push(null), C.previous = i, i && (i.next = C), i = C, o.defineSkip(C.start), o.write(R), t.parser.lazy[C.start.line]) {
      let z = o.events.length;
      for (; z--; )
        if (
          // The token starts before the line ending
          o.events[z][1].start.offset < s && // and either is not ended yet
          (!o.events[z][1].end || // or ends after it.
          o.events[z][1].end.offset > s)
        )
          return;
      const j = t.events.length;
      let I = j, $, A;
      for (; I--; )
        if (t.events[I][0] === "exit" && t.events[I][1].type === "chunkFlow") {
          if ($) {
            A = t.events[I][1].end;
            break;
          }
          $ = !0;
        }
      for (_(r), z = j; z < t.events.length; )
        t.events[z][1].end = {
          ...A
        }, z++;
      Br(t.events, I + 1, 0, t.events.slice(j)), t.events.length = z;
    }
  }
  function _(C) {
    let N = n.length;
    for (; N-- > C; ) {
      const R = n[N];
      t.containerState = R[1], R[0].exit.call(t, e);
    }
    n.length = C;
  }
  function O() {
    o.write([null]), i = void 0, o = void 0, t.containerState._closeFlow = void 0;
  }
}
function ZQ(e, t, n) {
  return lt(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function Du(e) {
  if (e === null || Mt(e) || rl(e))
    return 1;
  if (gg(e))
    return 2;
}
function yg(e, t, n) {
  const r = [];
  let o = -1;
  for (; ++o < e.length; ) {
    const i = e[o].resolveAll;
    i && !r.includes(i) && (t = i(t, n), r.push(i));
  }
  return t;
}
const Rx = {
  name: "attention",
  resolveAll: KQ,
  tokenize: QQ
};
function KQ(e, t) {
  let n = -1, r, o, i, s, u, c, d, p;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          c = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const h = {
            ...e[r][1].end
          }, g = {
            ...e[n][1].start
          };
          sA(h, -c), sA(g, c), s = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: h,
            end: {
              ...e[r][1].end
            }
          }, u = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...e[n][1].start
            },
            end: g
          }, i = {
            type: c > 1 ? "strongText" : "emphasisText",
            start: {
              ...e[r][1].end
            },
            end: {
              ...e[n][1].start
            }
          }, o = {
            type: c > 1 ? "strong" : "emphasis",
            start: {
              ...s.start
            },
            end: {
              ...u.end
            }
          }, e[r][1].end = {
            ...s.start
          }, e[n][1].start = {
            ...u.end
          }, d = [], e[r][1].end.offset - e[r][1].start.offset && (d = so(d, [["enter", e[r][1], t], ["exit", e[r][1], t]])), d = so(d, [["enter", o, t], ["enter", s, t], ["exit", s, t], ["enter", i, t]]), d = so(d, yg(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), d = so(d, [["exit", i, t], ["enter", u, t], ["exit", u, t], ["exit", o, t]]), e[n][1].end.offset - e[n][1].start.offset ? (p = 2, d = so(d, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : p = 0, Br(e, r - 1, n - r + 3, d), n = r + d.length - p - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function QQ(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, o = Du(r);
  let i;
  return s;
  function s(c) {
    return i = c, e.enter("attentionSequence"), u(c);
  }
  function u(c) {
    if (c === i)
      return e.consume(c), u;
    const d = e.exit("attentionSequence"), p = Du(c), h = !p || p === 2 && o || n.includes(c), g = !o || o === 2 && p || n.includes(r);
    return d._open = !!(i === 42 ? h : h && (o || !g)), d._close = !!(i === 42 ? g : g && (p || !h)), t(c);
  }
}
function sA(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const JQ = {
  name: "autolink",
  tokenize: eJ
};
function eJ(e, t, n) {
  let r = 0;
  return o;
  function o(y) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), i;
  }
  function i(y) {
    return er(y) ? (e.consume(y), s) : y === 64 ? n(y) : d(y);
  }
  function s(y) {
    return y === 43 || y === 45 || y === 46 || Un(y) ? (r = 1, u(y)) : d(y);
  }
  function u(y) {
    return y === 58 ? (e.consume(y), r = 0, c) : (y === 43 || y === 45 || y === 46 || Un(y)) && r++ < 32 ? (e.consume(y), u) : (r = 0, d(y));
  }
  function c(y) {
    return y === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.exit("autolink"), t) : y === null || y === 32 || y === 60 || pm(y) ? n(y) : (e.consume(y), c);
  }
  function d(y) {
    return y === 64 ? (e.consume(y), p) : HQ(y) ? (e.consume(y), d) : n(y);
  }
  function p(y) {
    return Un(y) ? h(y) : n(y);
  }
  function h(y) {
    return y === 46 ? (e.consume(y), r = 0, p) : y === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.exit("autolink"), t) : g(y);
  }
  function g(y) {
    if ((y === 45 || Un(y)) && r++ < 63) {
      const b = y === 45 ? g : h;
      return e.consume(y), b;
    }
    return n(y);
  }
}
const _f = {
  partial: !0,
  tokenize: tJ
};
function tJ(e, t, n) {
  return r;
  function r(i) {
    return rt(i) ? lt(e, o, "linePrefix")(i) : o(i);
  }
  function o(i) {
    return i === null || Pe(i) ? t(i) : n(i);
  }
}
const k6 = {
  continuation: {
    tokenize: rJ
  },
  exit: oJ,
  name: "blockQuote",
  tokenize: nJ
};
function nJ(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    if (s === 62) {
      const u = r.containerState;
      return u.open || (e.enter("blockQuote", {
        _container: !0
      }), u.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(s), e.exit("blockQuoteMarker"), i;
    }
    return n(s);
  }
  function i(s) {
    return rt(s) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(s), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(s));
  }
}
function rJ(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return rt(s) ? lt(e, i, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s) : i(s);
  }
  function i(s) {
    return e.attempt(k6, t, n)(s);
  }
}
function oJ(e) {
  e.exit("blockQuote");
}
const E6 = {
  name: "characterEscape",
  tokenize: iJ
};
function iJ(e, t, n) {
  return r;
  function r(i) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(i), e.exit("escapeMarker"), o;
  }
  function o(i) {
    return YQ(i) ? (e.enter("characterEscapeValue"), e.consume(i), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(i);
  }
}
const C6 = {
  name: "characterReference",
  tokenize: aJ
};
function aJ(e, t, n) {
  const r = this;
  let o = 0, i, s;
  return u;
  function u(h) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(h), e.exit("characterReferenceMarker"), c;
  }
  function c(h) {
    return h === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(h), e.exit("characterReferenceMarkerNumeric"), d) : (e.enter("characterReferenceValue"), i = 31, s = Un, p(h));
  }
  function d(h) {
    return h === 88 || h === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(h), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), i = 6, s = $Q, p) : (e.enter("characterReferenceValue"), i = 7, s = Mx, p(h));
  }
  function p(h) {
    if (h === 59 && o) {
      const g = e.exit("characterReferenceValue");
      return s === Un && !z0(r.sliceSerialize(g)) ? n(h) : (e.enter("characterReferenceMarker"), e.consume(h), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return s(h) && o++ < i ? (e.consume(h), p) : n(h);
  }
}
const lA = {
  partial: !0,
  tokenize: lJ
}, uA = {
  concrete: !0,
  name: "codeFenced",
  tokenize: sJ
};
function sJ(e, t, n) {
  const r = this, o = {
    partial: !0,
    tokenize: R
  };
  let i = 0, s = 0, u;
  return c;
  function c(z) {
    return d(z);
  }
  function d(z) {
    const j = r.events[r.events.length - 1];
    return i = j && j[1].type === "linePrefix" ? j[2].sliceSerialize(j[1], !0).length : 0, u = z, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), p(z);
  }
  function p(z) {
    return z === u ? (s++, e.consume(z), p) : s < 3 ? n(z) : (e.exit("codeFencedFenceSequence"), rt(z) ? lt(e, h, "whitespace")(z) : h(z));
  }
  function h(z) {
    return z === null || Pe(z) ? (e.exit("codeFencedFence"), r.interrupt ? t(z) : e.check(lA, v, N)(z)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), g(z));
  }
  function g(z) {
    return z === null || Pe(z) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), h(z)) : rt(z) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), lt(e, y, "whitespace")(z)) : z === 96 && z === u ? n(z) : (e.consume(z), g);
  }
  function y(z) {
    return z === null || Pe(z) ? h(z) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), b(z));
  }
  function b(z) {
    return z === null || Pe(z) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), h(z)) : z === 96 && z === u ? n(z) : (e.consume(z), b);
  }
  function v(z) {
    return e.attempt(o, N, x)(z);
  }
  function x(z) {
    return e.enter("lineEnding"), e.consume(z), e.exit("lineEnding"), _;
  }
  function _(z) {
    return i > 0 && rt(z) ? lt(e, O, "linePrefix", i + 1)(z) : O(z);
  }
  function O(z) {
    return z === null || Pe(z) ? e.check(lA, v, N)(z) : (e.enter("codeFlowValue"), C(z));
  }
  function C(z) {
    return z === null || Pe(z) ? (e.exit("codeFlowValue"), O(z)) : (e.consume(z), C);
  }
  function N(z) {
    return e.exit("codeFenced"), t(z);
  }
  function R(z, j, I) {
    let $ = 0;
    return A;
    function A(F) {
      return z.enter("lineEnding"), z.consume(F), z.exit("lineEnding"), V;
    }
    function V(F) {
      return z.enter("codeFencedFence"), rt(F) ? lt(z, U, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(F) : U(F);
    }
    function U(F) {
      return F === u ? (z.enter("codeFencedFenceSequence"), W(F)) : I(F);
    }
    function W(F) {
      return F === u ? ($++, z.consume(F), W) : $ >= s ? (z.exit("codeFencedFenceSequence"), rt(F) ? lt(z, D, "whitespace")(F) : D(F)) : I(F);
    }
    function D(F) {
      return F === null || Pe(F) ? (z.exit("codeFencedFence"), j(F)) : I(F);
    }
  }
}
function lJ(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return s === null ? n(s) : (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), i);
  }
  function i(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
const Pb = {
  name: "codeIndented",
  tokenize: cJ
}, uJ = {
  partial: !0,
  tokenize: dJ
};
function cJ(e, t, n) {
  const r = this;
  return o;
  function o(d) {
    return e.enter("codeIndented"), lt(e, i, "linePrefix", 5)(d);
  }
  function i(d) {
    const p = r.events[r.events.length - 1];
    return p && p[1].type === "linePrefix" && p[2].sliceSerialize(p[1], !0).length >= 4 ? s(d) : n(d);
  }
  function s(d) {
    return d === null ? c(d) : Pe(d) ? e.attempt(uJ, s, c)(d) : (e.enter("codeFlowValue"), u(d));
  }
  function u(d) {
    return d === null || Pe(d) ? (e.exit("codeFlowValue"), s(d)) : (e.consume(d), u);
  }
  function c(d) {
    return e.exit("codeIndented"), t(d);
  }
}
function dJ(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return r.parser.lazy[r.now().line] ? n(s) : Pe(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), o) : lt(e, i, "linePrefix", 5)(s);
  }
  function i(s) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? t(s) : Pe(s) ? o(s) : n(s);
  }
}
const fJ = {
  name: "codeText",
  previous: hJ,
  resolve: pJ,
  tokenize: mJ
};
function pJ(e) {
  let t = e.length - 4, n = 3, r, o;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    o === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (o = r) : (r === t || e[r][1].type === "lineEnding") && (e[o][1].type = "codeTextData", r !== o + 2 && (e[o][1].end = e[r - 1][1].end, e.splice(o + 2, r - o - 2), t -= r - o - 2, r = o + 2), o = void 0);
  return e;
}
function hJ(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function mJ(e, t, n) {
  let r = 0, o, i;
  return s;
  function s(h) {
    return e.enter("codeText"), e.enter("codeTextSequence"), u(h);
  }
  function u(h) {
    return h === 96 ? (e.consume(h), r++, u) : (e.exit("codeTextSequence"), c(h));
  }
  function c(h) {
    return h === null ? n(h) : h === 32 ? (e.enter("space"), e.consume(h), e.exit("space"), c) : h === 96 ? (i = e.enter("codeTextSequence"), o = 0, p(h)) : Pe(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), c) : (e.enter("codeTextData"), d(h));
  }
  function d(h) {
    return h === null || h === 32 || h === 96 || Pe(h) ? (e.exit("codeTextData"), c(h)) : (e.consume(h), d);
  }
  function p(h) {
    return h === 96 ? (e.consume(h), o++, p) : o === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(h)) : (i.type = "codeTextData", d(h));
  }
}
class gJ {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, r) {
    const o = n || 0;
    this.setCursor(Math.trunc(t));
    const i = this.right.splice(this.right.length - o, Number.POSITIVE_INFINITY);
    return r && ed(this.left, r), i.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), ed(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), ed(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        ed(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        ed(this.left, n.reverse());
      }
  }
}
function ed(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function O6(e) {
  const t = {};
  let n = -1, r, o, i, s, u, c, d;
  const p = new gJ(e);
  for (; ++n < p.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = p.get(n), n && r[1].type === "chunkFlow" && p.get(n - 1)[1].type === "listItemPrefix" && (c = r[1]._tokenizer.events, i = 0, i < c.length && c[i][1].type === "lineEndingBlank" && (i += 2), i < c.length && c[i][1].type === "content"))
      for (; ++i < c.length && c[i][1].type !== "content"; )
        c[i][1].type === "chunkText" && (c[i][1]._isInFirstContentOfListItem = !0, i++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, yJ(p, n)), n = t[n], d = !0);
    else if (r[1]._container) {
      for (i = n, o = void 0; i--; )
        if (s = p.get(i), s[1].type === "lineEnding" || s[1].type === "lineEndingBlank")
          s[0] === "enter" && (o && (p.get(o)[1].type = "lineEndingBlank"), s[1].type = "lineEnding", o = i);
        else if (!(s[1].type === "linePrefix" || s[1].type === "listItemIndent")) break;
      o && (r[1].end = {
        ...p.get(o)[1].start
      }, u = p.slice(o, n), u.unshift(r), p.splice(o, n - o + 1, u));
    }
  }
  return Br(e, 0, Number.POSITIVE_INFINITY, p.slice(0)), !d;
}
function yJ(e, t) {
  const n = e.get(t)[1], r = e.get(t)[2];
  let o = t - 1;
  const i = [];
  let s = n._tokenizer;
  s || (s = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (s._contentTypeTextTrailing = !0));
  const u = s.events, c = [], d = {};
  let p, h, g = -1, y = n, b = 0, v = 0;
  const x = [v];
  for (; y; ) {
    for (; e.get(++o)[1] !== y; )
      ;
    i.push(o), y._tokenizer || (p = r.sliceStream(y), y.next || p.push(null), h && s.defineSkip(y.start), y._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = !0), s.write(p), y._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = void 0)), h = y, y = y.next;
  }
  for (y = n; ++g < u.length; )
    u[g][0] === "exit" && u[g - 1][0] === "enter" && u[g][1].type === u[g - 1][1].type && u[g][1].start.line !== u[g][1].end.line && (v = g + 1, x.push(v), y._tokenizer = void 0, y.previous = void 0, y = y.next);
  for (s.events = [], y ? (y._tokenizer = void 0, y.previous = void 0) : x.pop(), g = x.length; g--; ) {
    const _ = u.slice(x[g], x[g + 1]), O = i.pop();
    c.push([O, O + _.length - 1]), e.splice(O, 2, _);
  }
  for (c.reverse(), g = -1; ++g < c.length; )
    d[b + c[g][0]] = b + c[g][1], b += c[g][1] - c[g][0] - 1;
  return d;
}
const vJ = {
  resolve: wJ,
  tokenize: xJ
}, bJ = {
  partial: !0,
  tokenize: SJ
};
function wJ(e) {
  return O6(e), e;
}
function xJ(e, t) {
  let n;
  return r;
  function r(u) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), o(u);
  }
  function o(u) {
    return u === null ? i(u) : Pe(u) ? e.check(bJ, s, i)(u) : (e.consume(u), o);
  }
  function i(u) {
    return e.exit("chunkContent"), e.exit("content"), t(u);
  }
  function s(u) {
    return e.consume(u), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, o;
  }
}
function SJ(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), lt(e, i, "linePrefix");
  }
  function i(s) {
    if (s === null || Pe(s))
      return n(s);
    const u = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? t(s) : e.interrupt(r.parser.constructs.flow, n, t)(s);
  }
}
function A6(e, t, n, r, o, i, s, u, c) {
  const d = c || Number.POSITIVE_INFINITY;
  let p = 0;
  return h;
  function h(_) {
    return _ === 60 ? (e.enter(r), e.enter(o), e.enter(i), e.consume(_), e.exit(i), g) : _ === null || _ === 32 || _ === 41 || pm(_) ? n(_) : (e.enter(r), e.enter(s), e.enter(u), e.enter("chunkString", {
      contentType: "string"
    }), v(_));
  }
  function g(_) {
    return _ === 62 ? (e.enter(i), e.consume(_), e.exit(i), e.exit(o), e.exit(r), t) : (e.enter(u), e.enter("chunkString", {
      contentType: "string"
    }), y(_));
  }
  function y(_) {
    return _ === 62 ? (e.exit("chunkString"), e.exit(u), g(_)) : _ === null || _ === 60 || Pe(_) ? n(_) : (e.consume(_), _ === 92 ? b : y);
  }
  function b(_) {
    return _ === 60 || _ === 62 || _ === 92 ? (e.consume(_), y) : y(_);
  }
  function v(_) {
    return !p && (_ === null || _ === 41 || Mt(_)) ? (e.exit("chunkString"), e.exit(u), e.exit(s), e.exit(r), t(_)) : p < d && _ === 40 ? (e.consume(_), p++, v) : _ === 41 ? (e.consume(_), p--, v) : _ === null || _ === 32 || _ === 40 || pm(_) ? n(_) : (e.consume(_), _ === 92 ? x : v);
  }
  function x(_) {
    return _ === 40 || _ === 41 || _ === 92 ? (e.consume(_), v) : v(_);
  }
}
function N6(e, t, n, r, o, i) {
  const s = this;
  let u = 0, c;
  return d;
  function d(y) {
    return e.enter(r), e.enter(o), e.consume(y), e.exit(o), e.enter(i), p;
  }
  function p(y) {
    return u > 999 || y === null || y === 91 || y === 93 && !c || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    y === 94 && !u && "_hiddenFootnoteSupport" in s.parser.constructs ? n(y) : y === 93 ? (e.exit(i), e.enter(o), e.consume(y), e.exit(o), e.exit(r), t) : Pe(y) ? (e.enter("lineEnding"), e.consume(y), e.exit("lineEnding"), p) : (e.enter("chunkString", {
      contentType: "string"
    }), h(y));
  }
  function h(y) {
    return y === null || y === 91 || y === 93 || Pe(y) || u++ > 999 ? (e.exit("chunkString"), p(y)) : (e.consume(y), c || (c = !rt(y)), y === 92 ? g : h);
  }
  function g(y) {
    return y === 91 || y === 92 || y === 93 ? (e.consume(y), u++, h) : h(y);
  }
}
function M6(e, t, n, r, o, i) {
  let s;
  return u;
  function u(g) {
    return g === 34 || g === 39 || g === 40 ? (e.enter(r), e.enter(o), e.consume(g), e.exit(o), s = g === 40 ? 41 : g, c) : n(g);
  }
  function c(g) {
    return g === s ? (e.enter(o), e.consume(g), e.exit(o), e.exit(r), t) : (e.enter(i), d(g));
  }
  function d(g) {
    return g === s ? (e.exit(i), c(s)) : g === null ? n(g) : Pe(g) ? (e.enter("lineEnding"), e.consume(g), e.exit("lineEnding"), lt(e, d, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), p(g));
  }
  function p(g) {
    return g === s || g === null || Pe(g) ? (e.exit("chunkString"), d(g)) : (e.consume(g), g === 92 ? h : p);
  }
  function h(g) {
    return g === s || g === 92 ? (e.consume(g), p) : p(g);
  }
}
function wd(e, t) {
  let n;
  return r;
  function r(o) {
    return Pe(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), n = !0, r) : rt(o) ? lt(e, r, n ? "linePrefix" : "lineSuffix")(o) : t(o);
  }
}
const _J = {
  name: "definition",
  tokenize: EJ
}, kJ = {
  partial: !0,
  tokenize: CJ
};
function EJ(e, t, n) {
  const r = this;
  let o;
  return i;
  function i(y) {
    return e.enter("definition"), s(y);
  }
  function s(y) {
    return N6.call(
      r,
      e,
      u,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(y);
  }
  function u(y) {
    return o = Ro(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), y === 58 ? (e.enter("definitionMarker"), e.consume(y), e.exit("definitionMarker"), c) : n(y);
  }
  function c(y) {
    return Mt(y) ? wd(e, d)(y) : d(y);
  }
  function d(y) {
    return A6(
      e,
      p,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(y);
  }
  function p(y) {
    return e.attempt(kJ, h, h)(y);
  }
  function h(y) {
    return rt(y) ? lt(e, g, "whitespace")(y) : g(y);
  }
  function g(y) {
    return y === null || Pe(y) ? (e.exit("definition"), r.parser.defined.push(o), t(y)) : n(y);
  }
}
function CJ(e, t, n) {
  return r;
  function r(u) {
    return Mt(u) ? wd(e, o)(u) : n(u);
  }
  function o(u) {
    return M6(e, i, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(u);
  }
  function i(u) {
    return rt(u) ? lt(e, s, "whitespace")(u) : s(u);
  }
  function s(u) {
    return u === null || Pe(u) ? t(u) : n(u);
  }
}
const OJ = {
  name: "hardBreakEscape",
  tokenize: AJ
};
function AJ(e, t, n) {
  return r;
  function r(i) {
    return e.enter("hardBreakEscape"), e.consume(i), o;
  }
  function o(i) {
    return Pe(i) ? (e.exit("hardBreakEscape"), t(i)) : n(i);
  }
}
const NJ = {
  name: "headingAtx",
  resolve: MJ,
  tokenize: RJ
};
function MJ(e, t) {
  let n = e.length - 2, r = 3, o, i;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (o = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, i = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, Br(e, r, n - r + 1, [["enter", o, t], ["enter", i, t], ["exit", i, t], ["exit", o, t]])), e;
}
function RJ(e, t, n) {
  let r = 0;
  return o;
  function o(p) {
    return e.enter("atxHeading"), i(p);
  }
  function i(p) {
    return e.enter("atxHeadingSequence"), s(p);
  }
  function s(p) {
    return p === 35 && r++ < 6 ? (e.consume(p), s) : p === null || Mt(p) ? (e.exit("atxHeadingSequence"), u(p)) : n(p);
  }
  function u(p) {
    return p === 35 ? (e.enter("atxHeadingSequence"), c(p)) : p === null || Pe(p) ? (e.exit("atxHeading"), t(p)) : rt(p) ? lt(e, u, "whitespace")(p) : (e.enter("atxHeadingText"), d(p));
  }
  function c(p) {
    return p === 35 ? (e.consume(p), c) : (e.exit("atxHeadingSequence"), u(p));
  }
  function d(p) {
    return p === null || p === 35 || Mt(p) ? (e.exit("atxHeadingText"), u(p)) : (e.consume(p), d);
  }
}
const jJ = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], cA = ["pre", "script", "style", "textarea"], zJ = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: PJ,
  tokenize: LJ
}, TJ = {
  partial: !0,
  tokenize: VJ
}, DJ = {
  partial: !0,
  tokenize: IJ
};
function PJ(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function LJ(e, t, n) {
  const r = this;
  let o, i, s, u, c;
  return d;
  function d(L) {
    return p(L);
  }
  function p(L) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(L), h;
  }
  function h(L) {
    return L === 33 ? (e.consume(L), g) : L === 47 ? (e.consume(L), i = !0, v) : L === 63 ? (e.consume(L), o = 3, r.interrupt ? t : M) : er(L) ? (e.consume(L), s = String.fromCharCode(L), x) : n(L);
  }
  function g(L) {
    return L === 45 ? (e.consume(L), o = 2, y) : L === 91 ? (e.consume(L), o = 5, u = 0, b) : er(L) ? (e.consume(L), o = 4, r.interrupt ? t : M) : n(L);
  }
  function y(L) {
    return L === 45 ? (e.consume(L), r.interrupt ? t : M) : n(L);
  }
  function b(L) {
    const ee = "CDATA[";
    return L === ee.charCodeAt(u++) ? (e.consume(L), u === ee.length ? r.interrupt ? t : U : b) : n(L);
  }
  function v(L) {
    return er(L) ? (e.consume(L), s = String.fromCharCode(L), x) : n(L);
  }
  function x(L) {
    if (L === null || L === 47 || L === 62 || Mt(L)) {
      const ee = L === 47, ae = s.toLowerCase();
      return !ee && !i && cA.includes(ae) ? (o = 1, r.interrupt ? t(L) : U(L)) : jJ.includes(s.toLowerCase()) ? (o = 6, ee ? (e.consume(L), _) : r.interrupt ? t(L) : U(L)) : (o = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(L) : i ? O(L) : C(L));
    }
    return L === 45 || Un(L) ? (e.consume(L), s += String.fromCharCode(L), x) : n(L);
  }
  function _(L) {
    return L === 62 ? (e.consume(L), r.interrupt ? t : U) : n(L);
  }
  function O(L) {
    return rt(L) ? (e.consume(L), O) : A(L);
  }
  function C(L) {
    return L === 47 ? (e.consume(L), A) : L === 58 || L === 95 || er(L) ? (e.consume(L), N) : rt(L) ? (e.consume(L), C) : A(L);
  }
  function N(L) {
    return L === 45 || L === 46 || L === 58 || L === 95 || Un(L) ? (e.consume(L), N) : R(L);
  }
  function R(L) {
    return L === 61 ? (e.consume(L), z) : rt(L) ? (e.consume(L), R) : C(L);
  }
  function z(L) {
    return L === null || L === 60 || L === 61 || L === 62 || L === 96 ? n(L) : L === 34 || L === 39 ? (e.consume(L), c = L, j) : rt(L) ? (e.consume(L), z) : I(L);
  }
  function j(L) {
    return L === c ? (e.consume(L), c = null, $) : L === null || Pe(L) ? n(L) : (e.consume(L), j);
  }
  function I(L) {
    return L === null || L === 34 || L === 39 || L === 47 || L === 60 || L === 61 || L === 62 || L === 96 || Mt(L) ? R(L) : (e.consume(L), I);
  }
  function $(L) {
    return L === 47 || L === 62 || rt(L) ? C(L) : n(L);
  }
  function A(L) {
    return L === 62 ? (e.consume(L), V) : n(L);
  }
  function V(L) {
    return L === null || Pe(L) ? U(L) : rt(L) ? (e.consume(L), V) : n(L);
  }
  function U(L) {
    return L === 45 && o === 2 ? (e.consume(L), P) : L === 60 && o === 1 ? (e.consume(L), H) : L === 62 && o === 4 ? (e.consume(L), X) : L === 63 && o === 3 ? (e.consume(L), M) : L === 93 && o === 5 ? (e.consume(L), q) : Pe(L) && (o === 6 || o === 7) ? (e.exit("htmlFlowData"), e.check(TJ, K, W)(L)) : L === null || Pe(L) ? (e.exit("htmlFlowData"), W(L)) : (e.consume(L), U);
  }
  function W(L) {
    return e.check(DJ, D, K)(L);
  }
  function D(L) {
    return e.enter("lineEnding"), e.consume(L), e.exit("lineEnding"), F;
  }
  function F(L) {
    return L === null || Pe(L) ? W(L) : (e.enter("htmlFlowData"), U(L));
  }
  function P(L) {
    return L === 45 ? (e.consume(L), M) : U(L);
  }
  function H(L) {
    return L === 47 ? (e.consume(L), s = "", Y) : U(L);
  }
  function Y(L) {
    if (L === 62) {
      const ee = s.toLowerCase();
      return cA.includes(ee) ? (e.consume(L), X) : U(L);
    }
    return er(L) && s.length < 8 ? (e.consume(L), s += String.fromCharCode(L), Y) : U(L);
  }
  function q(L) {
    return L === 93 ? (e.consume(L), M) : U(L);
  }
  function M(L) {
    return L === 62 ? (e.consume(L), X) : L === 45 && o === 2 ? (e.consume(L), M) : U(L);
  }
  function X(L) {
    return L === null || Pe(L) ? (e.exit("htmlFlowData"), K(L)) : (e.consume(L), X);
  }
  function K(L) {
    return e.exit("htmlFlow"), t(L);
  }
}
function IJ(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return Pe(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), i) : n(s);
  }
  function i(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
function VJ(e, t, n) {
  return r;
  function r(o) {
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), e.attempt(_f, t, n);
  }
}
const BJ = {
  name: "htmlText",
  tokenize: FJ
};
function FJ(e, t, n) {
  const r = this;
  let o, i, s;
  return u;
  function u(M) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(M), c;
  }
  function c(M) {
    return M === 33 ? (e.consume(M), d) : M === 47 ? (e.consume(M), R) : M === 63 ? (e.consume(M), C) : er(M) ? (e.consume(M), I) : n(M);
  }
  function d(M) {
    return M === 45 ? (e.consume(M), p) : M === 91 ? (e.consume(M), i = 0, b) : er(M) ? (e.consume(M), O) : n(M);
  }
  function p(M) {
    return M === 45 ? (e.consume(M), y) : n(M);
  }
  function h(M) {
    return M === null ? n(M) : M === 45 ? (e.consume(M), g) : Pe(M) ? (s = h, H(M)) : (e.consume(M), h);
  }
  function g(M) {
    return M === 45 ? (e.consume(M), y) : h(M);
  }
  function y(M) {
    return M === 62 ? P(M) : M === 45 ? g(M) : h(M);
  }
  function b(M) {
    const X = "CDATA[";
    return M === X.charCodeAt(i++) ? (e.consume(M), i === X.length ? v : b) : n(M);
  }
  function v(M) {
    return M === null ? n(M) : M === 93 ? (e.consume(M), x) : Pe(M) ? (s = v, H(M)) : (e.consume(M), v);
  }
  function x(M) {
    return M === 93 ? (e.consume(M), _) : v(M);
  }
  function _(M) {
    return M === 62 ? P(M) : M === 93 ? (e.consume(M), _) : v(M);
  }
  function O(M) {
    return M === null || M === 62 ? P(M) : Pe(M) ? (s = O, H(M)) : (e.consume(M), O);
  }
  function C(M) {
    return M === null ? n(M) : M === 63 ? (e.consume(M), N) : Pe(M) ? (s = C, H(M)) : (e.consume(M), C);
  }
  function N(M) {
    return M === 62 ? P(M) : C(M);
  }
  function R(M) {
    return er(M) ? (e.consume(M), z) : n(M);
  }
  function z(M) {
    return M === 45 || Un(M) ? (e.consume(M), z) : j(M);
  }
  function j(M) {
    return Pe(M) ? (s = j, H(M)) : rt(M) ? (e.consume(M), j) : P(M);
  }
  function I(M) {
    return M === 45 || Un(M) ? (e.consume(M), I) : M === 47 || M === 62 || Mt(M) ? $(M) : n(M);
  }
  function $(M) {
    return M === 47 ? (e.consume(M), P) : M === 58 || M === 95 || er(M) ? (e.consume(M), A) : Pe(M) ? (s = $, H(M)) : rt(M) ? (e.consume(M), $) : P(M);
  }
  function A(M) {
    return M === 45 || M === 46 || M === 58 || M === 95 || Un(M) ? (e.consume(M), A) : V(M);
  }
  function V(M) {
    return M === 61 ? (e.consume(M), U) : Pe(M) ? (s = V, H(M)) : rt(M) ? (e.consume(M), V) : $(M);
  }
  function U(M) {
    return M === null || M === 60 || M === 61 || M === 62 || M === 96 ? n(M) : M === 34 || M === 39 ? (e.consume(M), o = M, W) : Pe(M) ? (s = U, H(M)) : rt(M) ? (e.consume(M), U) : (e.consume(M), D);
  }
  function W(M) {
    return M === o ? (e.consume(M), o = void 0, F) : M === null ? n(M) : Pe(M) ? (s = W, H(M)) : (e.consume(M), W);
  }
  function D(M) {
    return M === null || M === 34 || M === 39 || M === 60 || M === 61 || M === 96 ? n(M) : M === 47 || M === 62 || Mt(M) ? $(M) : (e.consume(M), D);
  }
  function F(M) {
    return M === 47 || M === 62 || Mt(M) ? $(M) : n(M);
  }
  function P(M) {
    return M === 62 ? (e.consume(M), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(M);
  }
  function H(M) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(M), e.exit("lineEnding"), Y;
  }
  function Y(M) {
    return rt(M) ? lt(e, q, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(M) : q(M);
  }
  function q(M) {
    return e.enter("htmlTextData"), s(M);
  }
}
const T0 = {
  name: "labelEnd",
  resolveAll: YJ,
  resolveTo: qJ,
  tokenize: XJ
}, UJ = {
  tokenize: WJ
}, HJ = {
  tokenize: GJ
}, $J = {
  tokenize: ZJ
};
function YJ(e) {
  let t = -1;
  const n = [];
  for (; ++t < e.length; ) {
    const r = e[t][1];
    if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const o = r.type === "labelImage" ? 4 : 2;
      r.type = "data", t += o;
    }
  }
  return e.length !== n.length && Br(e, 0, e.length, n), e;
}
function qJ(e, t) {
  let n = e.length, r = 0, o, i, s, u;
  for (; n--; )
    if (o = e[n][1], i) {
      if (o.type === "link" || o.type === "labelLink" && o._inactive)
        break;
      e[n][0] === "enter" && o.type === "labelLink" && (o._inactive = !0);
    } else if (s) {
      if (e[n][0] === "enter" && (o.type === "labelImage" || o.type === "labelLink") && !o._balanced && (i = n, o.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else o.type === "labelEnd" && (s = n);
  const c = {
    type: e[i][1].type === "labelLink" ? "link" : "image",
    start: {
      ...e[i][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  }, d = {
    type: "label",
    start: {
      ...e[i][1].start
    },
    end: {
      ...e[s][1].end
    }
  }, p = {
    type: "labelText",
    start: {
      ...e[i + r + 2][1].end
    },
    end: {
      ...e[s - 2][1].start
    }
  };
  return u = [["enter", c, t], ["enter", d, t]], u = so(u, e.slice(i + 1, i + r + 3)), u = so(u, [["enter", p, t]]), u = so(u, yg(t.parser.constructs.insideSpan.null, e.slice(i + r + 4, s - 3), t)), u = so(u, [["exit", p, t], e[s - 2], e[s - 1], ["exit", d, t]]), u = so(u, e.slice(s + 1)), u = so(u, [["exit", c, t]]), Br(e, i, e.length, u), e;
}
function XJ(e, t, n) {
  const r = this;
  let o = r.events.length, i, s;
  for (; o--; )
    if ((r.events[o][1].type === "labelImage" || r.events[o][1].type === "labelLink") && !r.events[o][1]._balanced) {
      i = r.events[o][1];
      break;
    }
  return u;
  function u(g) {
    return i ? i._inactive ? h(g) : (s = r.parser.defined.includes(Ro(r.sliceSerialize({
      start: i.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(g), e.exit("labelMarker"), e.exit("labelEnd"), c) : n(g);
  }
  function c(g) {
    return g === 40 ? e.attempt(UJ, p, s ? p : h)(g) : g === 91 ? e.attempt(HJ, p, s ? d : h)(g) : s ? p(g) : h(g);
  }
  function d(g) {
    return e.attempt($J, p, h)(g);
  }
  function p(g) {
    return t(g);
  }
  function h(g) {
    return i._balanced = !0, n(g);
  }
}
function WJ(e, t, n) {
  return r;
  function r(h) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(h), e.exit("resourceMarker"), o;
  }
  function o(h) {
    return Mt(h) ? wd(e, i)(h) : i(h);
  }
  function i(h) {
    return h === 41 ? p(h) : A6(e, s, u, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(h);
  }
  function s(h) {
    return Mt(h) ? wd(e, c)(h) : p(h);
  }
  function u(h) {
    return n(h);
  }
  function c(h) {
    return h === 34 || h === 39 || h === 40 ? M6(e, d, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(h) : p(h);
  }
  function d(h) {
    return Mt(h) ? wd(e, p)(h) : p(h);
  }
  function p(h) {
    return h === 41 ? (e.enter("resourceMarker"), e.consume(h), e.exit("resourceMarker"), e.exit("resource"), t) : n(h);
  }
}
function GJ(e, t, n) {
  const r = this;
  return o;
  function o(u) {
    return N6.call(r, e, i, s, "reference", "referenceMarker", "referenceString")(u);
  }
  function i(u) {
    return r.parser.defined.includes(Ro(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(u) : n(u);
  }
  function s(u) {
    return n(u);
  }
}
function ZJ(e, t, n) {
  return r;
  function r(i) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(i), e.exit("referenceMarker"), o;
  }
  function o(i) {
    return i === 93 ? (e.enter("referenceMarker"), e.consume(i), e.exit("referenceMarker"), e.exit("reference"), t) : n(i);
  }
}
const KJ = {
  name: "labelStartImage",
  resolveAll: T0.resolveAll,
  tokenize: QJ
};
function QJ(e, t, n) {
  const r = this;
  return o;
  function o(u) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(u), e.exit("labelImageMarker"), i;
  }
  function i(u) {
    return u === 91 ? (e.enter("labelMarker"), e.consume(u), e.exit("labelMarker"), e.exit("labelImage"), s) : n(u);
  }
  function s(u) {
    return u === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(u) : t(u);
  }
}
const JJ = {
  name: "labelStartLink",
  resolveAll: T0.resolveAll,
  tokenize: eee
};
function eee(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelLink"), i;
  }
  function i(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
  }
}
const Lb = {
  name: "lineEnding",
  tokenize: tee
};
function tee(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), lt(e, t, "linePrefix");
  }
}
const Dh = {
  name: "thematicBreak",
  tokenize: nee
};
function nee(e, t, n) {
  let r = 0, o;
  return i;
  function i(d) {
    return e.enter("thematicBreak"), s(d);
  }
  function s(d) {
    return o = d, u(d);
  }
  function u(d) {
    return d === o ? (e.enter("thematicBreakSequence"), c(d)) : r >= 3 && (d === null || Pe(d)) ? (e.exit("thematicBreak"), t(d)) : n(d);
  }
  function c(d) {
    return d === o ? (e.consume(d), r++, c) : (e.exit("thematicBreakSequence"), rt(d) ? lt(e, u, "whitespace")(d) : u(d));
  }
}
const pr = {
  continuation: {
    tokenize: aee
  },
  exit: lee,
  name: "list",
  tokenize: iee
}, ree = {
  partial: !0,
  tokenize: uee
}, oee = {
  partial: !0,
  tokenize: see
};
function iee(e, t, n) {
  const r = this, o = r.events[r.events.length - 1];
  let i = o && o[1].type === "linePrefix" ? o[2].sliceSerialize(o[1], !0).length : 0, s = 0;
  return u;
  function u(y) {
    const b = r.containerState.type || (y === 42 || y === 43 || y === 45 ? "listUnordered" : "listOrdered");
    if (b === "listUnordered" ? !r.containerState.marker || y === r.containerState.marker : Mx(y)) {
      if (r.containerState.type || (r.containerState.type = b, e.enter(b, {
        _container: !0
      })), b === "listUnordered")
        return e.enter("listItemPrefix"), y === 42 || y === 45 ? e.check(Dh, n, d)(y) : d(y);
      if (!r.interrupt || y === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), c(y);
    }
    return n(y);
  }
  function c(y) {
    return Mx(y) && ++s < 10 ? (e.consume(y), c) : (!r.interrupt || s < 2) && (r.containerState.marker ? y === r.containerState.marker : y === 41 || y === 46) ? (e.exit("listItemValue"), d(y)) : n(y);
  }
  function d(y) {
    return e.enter("listItemMarker"), e.consume(y), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || y, e.check(
      _f,
      // Cant be empty when interrupting.
      r.interrupt ? n : p,
      e.attempt(ree, g, h)
    );
  }
  function p(y) {
    return r.containerState.initialBlankLine = !0, i++, g(y);
  }
  function h(y) {
    return rt(y) ? (e.enter("listItemPrefixWhitespace"), e.consume(y), e.exit("listItemPrefixWhitespace"), g) : n(y);
  }
  function g(y) {
    return r.containerState.size = i + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(y);
  }
}
function aee(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(_f, o, i);
  function o(u) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, lt(e, t, "listItemIndent", r.containerState.size + 1)(u);
  }
  function i(u) {
    return r.containerState.furtherBlankLines || !rt(u) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, s(u)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(oee, t, s)(u));
  }
  function s(u) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, lt(e, e.attempt(pr, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(u);
  }
}
function see(e, t, n) {
  const r = this;
  return lt(e, o, "listItemIndent", r.containerState.size + 1);
  function o(i) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "listItemIndent" && s[2].sliceSerialize(s[1], !0).length === r.containerState.size ? t(i) : n(i);
  }
}
function lee(e) {
  e.exit(this.containerState.type);
}
function uee(e, t, n) {
  const r = this;
  return lt(e, o, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function o(i) {
    const s = r.events[r.events.length - 1];
    return !rt(i) && s && s[1].type === "listItemPrefixWhitespace" ? t(i) : n(i);
  }
}
const dA = {
  name: "setextUnderline",
  resolveTo: cee,
  tokenize: dee
};
function cee(e, t) {
  let n = e.length, r, o, i;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (o = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !i && e[n][1].type === "definition" && (i = n);
  const s = {
    type: "setextHeading",
    start: {
      ...e[r][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  };
  return e[o][1].type = "setextHeadingText", i ? (e.splice(o, 0, ["enter", s, t]), e.splice(i + 1, 0, ["exit", e[r][1], t]), e[r][1].end = {
    ...e[i][1].end
  }) : e[r][1] = s, e.push(["exit", s, t]), e;
}
function dee(e, t, n) {
  const r = this;
  let o;
  return i;
  function i(d) {
    let p = r.events.length, h;
    for (; p--; )
      if (r.events[p][1].type !== "lineEnding" && r.events[p][1].type !== "linePrefix" && r.events[p][1].type !== "content") {
        h = r.events[p][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || h) ? (e.enter("setextHeadingLine"), o = d, s(d)) : n(d);
  }
  function s(d) {
    return e.enter("setextHeadingLineSequence"), u(d);
  }
  function u(d) {
    return d === o ? (e.consume(d), u) : (e.exit("setextHeadingLineSequence"), rt(d) ? lt(e, c, "lineSuffix")(d) : c(d));
  }
  function c(d) {
    return d === null || Pe(d) ? (e.exit("setextHeadingLine"), t(d)) : n(d);
  }
}
const fee = {
  tokenize: pee
};
function pee(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    _f,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(this.parser.constructs.flowInitial, o, lt(e, e.attempt(this.parser.constructs.flow, o, e.attempt(vJ, o)), "linePrefix"))
  );
  return n;
  function r(i) {
    if (i === null) {
      e.consume(i);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(i), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function o(i) {
    if (i === null) {
      e.consume(i);
      return;
    }
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const hee = {
  resolveAll: j6()
}, mee = R6("string"), gee = R6("text");
function R6(e) {
  return {
    resolveAll: j6(e === "text" ? yee : void 0),
    tokenize: t
  };
  function t(n) {
    const r = this, o = this.parser.constructs[e], i = n.attempt(o, s, u);
    return s;
    function s(p) {
      return d(p) ? i(p) : u(p);
    }
    function u(p) {
      if (p === null) {
        n.consume(p);
        return;
      }
      return n.enter("data"), n.consume(p), c;
    }
    function c(p) {
      return d(p) ? (n.exit("data"), i(p)) : (n.consume(p), c);
    }
    function d(p) {
      if (p === null)
        return !0;
      const h = o[p];
      let g = -1;
      if (h)
        for (; ++g < h.length; ) {
          const y = h[g];
          if (!y.previous || y.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function j6(e) {
  return t;
  function t(n, r) {
    let o = -1, i;
    for (; ++o <= n.length; )
      i === void 0 ? n[o] && n[o][1].type === "data" && (i = o, o++) : (!n[o] || n[o][1].type !== "data") && (o !== i + 2 && (n[i][1].end = n[o - 1][1].end, n.splice(i + 2, o - i - 2), o = i + 2), i = void 0);
    return e ? e(n, r) : n;
  }
}
function yee(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], o = t.sliceStream(r);
      let i = o.length, s = -1, u = 0, c;
      for (; i--; ) {
        const d = o[i];
        if (typeof d == "string") {
          for (s = d.length; d.charCodeAt(s - 1) === 32; )
            u++, s--;
          if (s) break;
          s = -1;
        } else if (d === -2)
          c = !0, u++;
        else if (d !== -1) {
          i++;
          break;
        }
      }
      if (t._contentTypeTextTrailing && n === e.length && (u = 0), u) {
        const d = {
          type: n === e.length || c || u < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: i ? s : r.start._bufferIndex + s,
            _index: r.start._index + i,
            line: r.end.line,
            column: r.end.column - u,
            offset: r.end.offset - u
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...d.start
        }, r.start.offset === r.end.offset ? Object.assign(r, d) : (e.splice(n, 0, ["enter", d, t], ["exit", d, t]), n += 2);
      }
      n++;
    }
  return e;
}
const vee = {
  42: pr,
  43: pr,
  45: pr,
  48: pr,
  49: pr,
  50: pr,
  51: pr,
  52: pr,
  53: pr,
  54: pr,
  55: pr,
  56: pr,
  57: pr,
  62: k6
}, bee = {
  91: _J
}, wee = {
  [-2]: Pb,
  [-1]: Pb,
  32: Pb
}, xee = {
  35: NJ,
  42: Dh,
  45: [dA, Dh],
  60: zJ,
  61: dA,
  95: Dh,
  96: uA,
  126: uA
}, See = {
  38: C6,
  92: E6
}, _ee = {
  [-5]: Lb,
  [-4]: Lb,
  [-3]: Lb,
  33: KJ,
  38: C6,
  42: Rx,
  60: [JQ, BJ],
  91: JJ,
  92: [OJ, E6],
  93: T0,
  95: Rx,
  96: fJ
}, kee = {
  null: [Rx, hee]
}, Eee = {
  null: [42, 95]
}, Cee = {
  null: []
}, Oee = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: Eee,
  contentInitial: bee,
  disable: Cee,
  document: vee,
  flow: xee,
  flowInitial: wee,
  insideSpan: kee,
  string: See,
  text: _ee
}, Symbol.toStringTag, { value: "Module" }));
function Aee(e, t, n) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: n && n.line || 1,
    column: n && n.column || 1,
    offset: n && n.offset || 0
  };
  const o = {}, i = [];
  let s = [], u = [];
  const c = {
    attempt: j(R),
    check: j(z),
    consume: O,
    enter: C,
    exit: N,
    interrupt: j(z, {
      interrupt: !0
    })
  }, d = {
    code: null,
    containerState: {},
    defineSkip: v,
    events: [],
    now: b,
    parser: e,
    previous: null,
    sliceSerialize: g,
    sliceStream: y,
    write: h
  };
  let p = t.tokenize.call(d, c);
  return t.resolveAll && i.push(t), d;
  function h(V) {
    return s = so(s, V), x(), s[s.length - 1] !== null ? [] : (I(t, 0), d.events = yg(i, d.events, d), d.events);
  }
  function g(V, U) {
    return Mee(y(V), U);
  }
  function y(V) {
    return Nee(s, V);
  }
  function b() {
    const {
      _bufferIndex: V,
      _index: U,
      line: W,
      column: D,
      offset: F
    } = r;
    return {
      _bufferIndex: V,
      _index: U,
      line: W,
      column: D,
      offset: F
    };
  }
  function v(V) {
    o[V.line] = V.column, A();
  }
  function x() {
    let V;
    for (; r._index < s.length; ) {
      const U = s[r._index];
      if (typeof U == "string")
        for (V = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === V && r._bufferIndex < U.length; )
          _(U.charCodeAt(r._bufferIndex));
      else
        _(U);
    }
  }
  function _(V) {
    p = p(V);
  }
  function O(V) {
    Pe(V) ? (r.line++, r.column = 1, r.offset += V === -3 ? 2 : 1, A()) : V !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    s[r._index].length && (r._bufferIndex = -1, r._index++)), d.previous = V;
  }
  function C(V, U) {
    const W = U || {};
    return W.type = V, W.start = b(), d.events.push(["enter", W, d]), u.push(W), W;
  }
  function N(V) {
    const U = u.pop();
    return U.end = b(), d.events.push(["exit", U, d]), U;
  }
  function R(V, U) {
    I(V, U.from);
  }
  function z(V, U) {
    U.restore();
  }
  function j(V, U) {
    return W;
    function W(D, F, P) {
      let H, Y, q, M;
      return Array.isArray(D) ? (
        /* c8 ignore next 1 */
        K(D)
      ) : "tokenize" in D ? (
        // Looks like a construct.
        K([
          /** @type {Construct} */
          D
        ])
      ) : X(D);
      function X(le) {
        return me;
        function me(se) {
          const he = se !== null && le[se], _e = se !== null && le.null, Se = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(he) ? he : he ? [he] : [],
            ...Array.isArray(_e) ? _e : _e ? [_e] : []
          ];
          return K(Se)(se);
        }
      }
      function K(le) {
        return H = le, Y = 0, le.length === 0 ? P : L(le[Y]);
      }
      function L(le) {
        return me;
        function me(se) {
          return M = $(), q = le, le.partial || (d.currentConstruct = le), le.name && d.parser.constructs.disable.null.includes(le.name) ? ae() : le.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            U ? Object.assign(Object.create(d), U) : d,
            c,
            ee,
            ae
          )(se);
        }
      }
      function ee(le) {
        return V(q, M), F;
      }
      function ae(le) {
        return M.restore(), ++Y < H.length ? L(H[Y]) : P;
      }
    }
  }
  function I(V, U) {
    V.resolveAll && !i.includes(V) && i.push(V), V.resolve && Br(d.events, U, d.events.length - U, V.resolve(d.events.slice(U), d)), V.resolveTo && (d.events = V.resolveTo(d.events, d));
  }
  function $() {
    const V = b(), U = d.previous, W = d.currentConstruct, D = d.events.length, F = Array.from(u);
    return {
      from: D,
      restore: P
    };
    function P() {
      r = V, d.previous = U, d.currentConstruct = W, d.events.length = D, u = F, A();
    }
  }
  function A() {
    r.line in o && r.column < 2 && (r.column = o[r.line], r.offset += o[r.line] - 1);
  }
}
function Nee(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, o = t.end._index, i = t.end._bufferIndex;
  let s;
  if (n === o)
    s = [e[n].slice(r, i)];
  else {
    if (s = e.slice(n, o), r > -1) {
      const u = s[0];
      typeof u == "string" ? s[0] = u.slice(r) : s.shift();
    }
    i > 0 && s.push(e[o].slice(0, i));
  }
  return s;
}
function Mee(e, t) {
  let n = -1;
  const r = [];
  let o;
  for (; ++n < e.length; ) {
    const i = e[n];
    let s;
    if (typeof i == "string")
      s = i;
    else switch (i) {
      case -5: {
        s = "\r";
        break;
      }
      case -4: {
        s = `
`;
        break;
      }
      case -3: {
        s = `\r
`;
        break;
      }
      case -2: {
        s = t ? " " : "	";
        break;
      }
      case -1: {
        if (!t && o) continue;
        s = " ";
        break;
      }
      default:
        s = String.fromCharCode(i);
    }
    o = i === -2, r.push(s);
  }
  return r.join("");
}
function Ree(e) {
  const t = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      S6([Oee, ...(e || {}).extensions || []])
    ),
    content: n(qQ),
    defined: [],
    document: n(WQ),
    flow: n(fee),
    lazy: {},
    string: n(mee),
    text: n(gee)
  };
  return t;
  function n(r) {
    return o;
    function o(i) {
      return Aee(t, r, i);
    }
  }
}
function jee(e) {
  for (; !O6(e); )
    ;
  return e;
}
const fA = /[\0\t\n\r]/g;
function zee() {
  let e = 1, t = "", n = !0, r;
  return o;
  function o(i, s, u) {
    const c = [];
    let d, p, h, g, y;
    for (i = t + (typeof i == "string" ? i.toString() : new TextDecoder(s || void 0).decode(i)), h = 0, t = "", n && (i.charCodeAt(0) === 65279 && h++, n = void 0); h < i.length; ) {
      if (fA.lastIndex = h, d = fA.exec(i), g = d && d.index !== void 0 ? d.index : i.length, y = i.charCodeAt(g), !d) {
        t = i.slice(h);
        break;
      }
      if (y === 10 && h === g && r)
        c.push(-3), r = void 0;
      else
        switch (r && (c.push(-5), r = void 0), h < g && (c.push(i.slice(h, g)), e += g - h), y) {
          case 0: {
            c.push(65533), e++;
            break;
          }
          case 9: {
            for (p = Math.ceil(e / 4) * 4, c.push(-2); e++ < p; ) c.push(-1);
            break;
          }
          case 10: {
            c.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      h = g + 1;
    }
    return u && (r && c.push(-5), t && c.push(t), c.push(null)), c;
  }
}
const Tee = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function Dee(e) {
  return e.replace(Tee, Pee);
}
function Pee(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const r = n.charCodeAt(1), o = r === 120 || r === 88;
    return _6(n.slice(o ? 2 : 1), o ? 16 : 10);
  }
  return z0(n) || e;
}
const z6 = {}.hasOwnProperty;
function Lee(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), Iee(n)(jee(Ree(n).document().write(zee()(e, t, !0))));
}
function Iee(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: i(on),
      autolinkProtocol: $,
      autolinkEmail: $,
      atxHeading: i(ct),
      blockQuote: i(_e),
      characterEscape: $,
      characterReference: $,
      codeFenced: i(Se),
      codeFencedFenceInfo: s,
      codeFencedFenceMeta: s,
      codeIndented: i(Se, s),
      codeText: i(Ee, s),
      codeTextData: $,
      data: $,
      codeFlowValue: $,
      definition: i(Ie),
      definitionDestinationString: s,
      definitionLabelString: s,
      definitionTitleString: s,
      emphasis: i($e),
      hardBreakEscape: i($t),
      hardBreakTrailing: i($t),
      htmlFlow: i(ft, s),
      htmlFlowData: $,
      htmlText: i(ft, s),
      htmlTextData: $,
      image: i(br),
      label: s,
      link: i(on),
      listItem: i(De),
      listItemValue: g,
      listOrdered: i(vn, h),
      listUnordered: i(vn),
      paragraph: i(qr),
      reference: L,
      referenceString: s,
      resourceDestinationString: s,
      resourceTitleString: s,
      setextHeading: i(ct),
      strong: i(Xr),
      thematicBreak: i(Wr)
    },
    exit: {
      atxHeading: c(),
      atxHeadingSequence: R,
      autolink: c(),
      autolinkEmail: he,
      autolinkProtocol: se,
      blockQuote: c(),
      characterEscapeValue: A,
      characterReferenceMarkerHexadecimal: ae,
      characterReferenceMarkerNumeric: ae,
      characterReferenceValue: le,
      characterReference: me,
      codeFenced: c(x),
      codeFencedFence: v,
      codeFencedFenceInfo: y,
      codeFencedFenceMeta: b,
      codeFlowValue: A,
      codeIndented: c(_),
      codeText: c(F),
      codeTextData: A,
      data: A,
      definition: c(),
      definitionDestinationString: N,
      definitionLabelString: O,
      definitionTitleString: C,
      emphasis: c(),
      hardBreakEscape: c(U),
      hardBreakTrailing: c(U),
      htmlFlow: c(W),
      htmlFlowData: A,
      htmlText: c(D),
      htmlTextData: A,
      image: c(H),
      label: q,
      labelText: Y,
      lineEnding: V,
      link: c(P),
      listItem: c(),
      listOrdered: c(),
      listUnordered: c(),
      paragraph: c(),
      referenceString: ee,
      resourceDestinationString: M,
      resourceTitleString: X,
      resource: K,
      setextHeading: c(I),
      setextHeadingLineSequence: j,
      setextHeadingText: z,
      strong: c(),
      thematicBreak: c()
    }
  };
  T6(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(ce) {
    let ye = {
      type: "root",
      children: []
    };
    const Ae = {
      stack: [ye],
      tokenStack: [],
      config: t,
      enter: u,
      exit: d,
      buffer: s,
      resume: p,
      data: n
    }, Ve = [];
    let ut = -1;
    for (; ++ut < ce.length; )
      if (ce[ut][1].type === "listOrdered" || ce[ut][1].type === "listUnordered")
        if (ce[ut][0] === "enter")
          Ve.push(ut);
        else {
          const bn = Ve.pop();
          ut = o(ce, bn, ut);
        }
    for (ut = -1; ++ut < ce.length; ) {
      const bn = t[ce[ut][0]];
      z6.call(bn, ce[ut][1].type) && bn[ce[ut][1].type].call(Object.assign({
        sliceSerialize: ce[ut][2].sliceSerialize
      }, Ae), ce[ut][1]);
    }
    if (Ae.tokenStack.length > 0) {
      const bn = Ae.tokenStack[Ae.tokenStack.length - 1];
      (bn[1] || pA).call(Ae, void 0, bn[0]);
    }
    for (ye.position = {
      start: Fa(ce.length > 0 ? ce[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: Fa(ce.length > 0 ? ce[ce.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, ut = -1; ++ut < t.transforms.length; )
      ye = t.transforms[ut](ye) || ye;
    return ye;
  }
  function o(ce, ye, Ae) {
    let Ve = ye - 1, ut = -1, bn = !1, or, Xt, ir, kn;
    for (; ++Ve <= Ae; ) {
      const Wt = ce[Ve];
      switch (Wt[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Wt[0] === "enter" ? ut++ : ut--, kn = void 0;
          break;
        }
        case "lineEndingBlank": {
          Wt[0] === "enter" && (or && !kn && !ut && !ir && (ir = Ve), kn = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          kn = void 0;
      }
      if (!ut && Wt[0] === "enter" && Wt[1].type === "listItemPrefix" || ut === -1 && Wt[0] === "exit" && (Wt[1].type === "listUnordered" || Wt[1].type === "listOrdered")) {
        if (or) {
          let Dn = Ve;
          for (Xt = void 0; Dn--; ) {
            const Xn = ce[Dn];
            if (Xn[1].type === "lineEnding" || Xn[1].type === "lineEndingBlank") {
              if (Xn[0] === "exit") continue;
              Xt && (ce[Xt][1].type = "lineEndingBlank", bn = !0), Xn[1].type = "lineEnding", Xt = Dn;
            } else if (!(Xn[1].type === "linePrefix" || Xn[1].type === "blockQuotePrefix" || Xn[1].type === "blockQuotePrefixWhitespace" || Xn[1].type === "blockQuoteMarker" || Xn[1].type === "listItemIndent")) break;
          }
          ir && (!Xt || ir < Xt) && (or._spread = !0), or.end = Object.assign({}, Xt ? ce[Xt][1].start : Wt[1].end), ce.splice(Xt || Ve, 0, ["exit", or, Wt[2]]), Ve++, Ae++;
        }
        if (Wt[1].type === "listItemPrefix") {
          const Dn = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Wt[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          or = Dn, ce.splice(Ve, 0, ["enter", Dn, Wt[2]]), Ve++, Ae++, ir = void 0, kn = !0;
        }
      }
    }
    return ce[ye][1]._spread = bn, Ae;
  }
  function i(ce, ye) {
    return Ae;
    function Ae(Ve) {
      u.call(this, ce(Ve), Ve), ye && ye.call(this, Ve);
    }
  }
  function s() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function u(ce, ye, Ae) {
    this.stack[this.stack.length - 1].children.push(ce), this.stack.push(ce), this.tokenStack.push([ye, Ae || void 0]), ce.position = {
      start: Fa(ye.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function c(ce) {
    return ye;
    function ye(Ae) {
      ce && ce.call(this, Ae), d.call(this, Ae);
    }
  }
  function d(ce, ye) {
    const Ae = this.stack.pop(), Ve = this.tokenStack.pop();
    if (Ve)
      Ve[0].type !== ce.type && (ye ? ye.call(this, ce, Ve[0]) : (Ve[1] || pA).call(this, ce, Ve[0]));
    else throw new Error("Cannot close `" + ce.type + "` (" + bd({
      start: ce.start,
      end: ce.end
    }) + "): its not open");
    Ae.position.end = Fa(ce.end);
  }
  function p() {
    return j0(this.stack.pop());
  }
  function h() {
    this.data.expectingFirstListItemValue = !0;
  }
  function g(ce) {
    if (this.data.expectingFirstListItemValue) {
      const ye = this.stack[this.stack.length - 2];
      ye.start = Number.parseInt(this.sliceSerialize(ce), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function y() {
    const ce = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.lang = ce;
  }
  function b() {
    const ce = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.meta = ce;
  }
  function v() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function x() {
    const ce = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = ce.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function _() {
    const ce = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = ce.replace(/(\r?\n|\r)$/g, "");
  }
  function O(ce) {
    const ye = this.resume(), Ae = this.stack[this.stack.length - 1];
    Ae.label = ye, Ae.identifier = Ro(this.sliceSerialize(ce)).toLowerCase();
  }
  function C() {
    const ce = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.title = ce;
  }
  function N() {
    const ce = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.url = ce;
  }
  function R(ce) {
    const ye = this.stack[this.stack.length - 1];
    if (!ye.depth) {
      const Ae = this.sliceSerialize(ce).length;
      ye.depth = Ae;
    }
  }
  function z() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function j(ce) {
    const ye = this.stack[this.stack.length - 1];
    ye.depth = this.sliceSerialize(ce).codePointAt(0) === 61 ? 1 : 2;
  }
  function I() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function $(ce) {
    const ye = this.stack[this.stack.length - 1].children;
    let Ae = ye[ye.length - 1];
    (!Ae || Ae.type !== "text") && (Ae = qn(), Ae.position = {
      start: Fa(ce.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, ye.push(Ae)), this.stack.push(Ae);
  }
  function A(ce) {
    const ye = this.stack.pop();
    ye.value += this.sliceSerialize(ce), ye.position.end = Fa(ce.end);
  }
  function V(ce) {
    const ye = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const Ae = ye.children[ye.children.length - 1];
      Ae.position.end = Fa(ce.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(ye.type) && ($.call(this, ce), A.call(this, ce));
  }
  function U() {
    this.data.atHardBreak = !0;
  }
  function W() {
    const ce = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = ce;
  }
  function D() {
    const ce = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = ce;
  }
  function F() {
    const ce = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = ce;
  }
  function P() {
    const ce = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const ye = this.data.referenceType || "shortcut";
      ce.type += "Reference", ce.referenceType = ye, delete ce.url, delete ce.title;
    } else
      delete ce.identifier, delete ce.label;
    this.data.referenceType = void 0;
  }
  function H() {
    const ce = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const ye = this.data.referenceType || "shortcut";
      ce.type += "Reference", ce.referenceType = ye, delete ce.url, delete ce.title;
    } else
      delete ce.identifier, delete ce.label;
    this.data.referenceType = void 0;
  }
  function Y(ce) {
    const ye = this.sliceSerialize(ce), Ae = this.stack[this.stack.length - 2];
    Ae.label = Dee(ye), Ae.identifier = Ro(ye).toLowerCase();
  }
  function q() {
    const ce = this.stack[this.stack.length - 1], ye = this.resume(), Ae = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, Ae.type === "link") {
      const Ve = ce.children;
      Ae.children = Ve;
    } else
      Ae.alt = ye;
  }
  function M() {
    const ce = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.url = ce;
  }
  function X() {
    const ce = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.title = ce;
  }
  function K() {
    this.data.inReference = void 0;
  }
  function L() {
    this.data.referenceType = "collapsed";
  }
  function ee(ce) {
    const ye = this.resume(), Ae = this.stack[this.stack.length - 1];
    Ae.label = ye, Ae.identifier = Ro(this.sliceSerialize(ce)).toLowerCase(), this.data.referenceType = "full";
  }
  function ae(ce) {
    this.data.characterReferenceType = ce.type;
  }
  function le(ce) {
    const ye = this.sliceSerialize(ce), Ae = this.data.characterReferenceType;
    let Ve;
    Ae ? (Ve = _6(ye, Ae === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Ve = z0(ye);
    const ut = this.stack[this.stack.length - 1];
    ut.value += Ve;
  }
  function me(ce) {
    const ye = this.stack.pop();
    ye.position.end = Fa(ce.end);
  }
  function se(ce) {
    A.call(this, ce);
    const ye = this.stack[this.stack.length - 1];
    ye.url = this.sliceSerialize(ce);
  }
  function he(ce) {
    A.call(this, ce);
    const ye = this.stack[this.stack.length - 1];
    ye.url = "mailto:" + this.sliceSerialize(ce);
  }
  function _e() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function Se() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function Ee() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function Ie() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function $e() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function ct() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function $t() {
    return {
      type: "break"
    };
  }
  function ft() {
    return {
      type: "html",
      value: ""
    };
  }
  function br() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function on() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function vn(ce) {
    return {
      type: "list",
      ordered: ce.type === "listOrdered",
      start: null,
      spread: ce._spread,
      children: []
    };
  }
  function De(ce) {
    return {
      type: "listItem",
      spread: ce._spread,
      checked: null,
      children: []
    };
  }
  function qr() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function Xr() {
    return {
      type: "strong",
      children: []
    };
  }
  function qn() {
    return {
      type: "text",
      value: ""
    };
  }
  function Wr() {
    return {
      type: "thematicBreak"
    };
  }
}
function Fa(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function T6(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? T6(e, r) : Vee(e, r);
  }
}
function Vee(e, t) {
  let n;
  for (n in t)
    if (z6.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function pA(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + bd({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + bd({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + bd({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function Bee(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return Lee(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function Fee(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Uee(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function Hee(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let o = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (o.data = { meta: t.meta }), e.patch(t, o), o = e.applyData(t, o), o = { type: "element", tagName: "pre", properties: {}, children: [o] }, e.patch(t, o), o;
}
function $ee(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Yee(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function qee(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), o = Wu(r.toLowerCase()), i = e.footnoteOrder.indexOf(r);
  let s, u = e.footnoteCounts.get(r);
  u === void 0 ? (u = 0, e.footnoteOrder.push(r), s = e.footnoteOrder.length) : s = i + 1, u += 1, e.footnoteCounts.set(r, u);
  const c = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + o,
      id: n + "fnref-" + o + (u > 1 ? "-" + u : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(s) }]
  };
  e.patch(t, c);
  const d = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [c]
  };
  return e.patch(t, d), e.applyData(t, d);
}
function Xee(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Wee(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function D6(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const o = e.all(t), i = o[0];
  i && i.type === "text" ? i.value = "[" + i.value : o.unshift({ type: "text", value: "[" });
  const s = o[o.length - 1];
  return s && s.type === "text" ? s.value += r : o.push({ type: "text", value: r }), o;
}
function Gee(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return D6(e, t);
  const o = { src: Wu(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (o.title = r.title);
  const i = { type: "element", tagName: "img", properties: o, children: [] };
  return e.patch(t, i), e.applyData(t, i);
}
function Zee(e, t) {
  const n = { src: Wu(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function Kee(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Qee(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return D6(e, t);
  const o = { href: Wu(r.url || "") };
  r.title !== null && r.title !== void 0 && (o.title = r.title);
  const i = {
    type: "element",
    tagName: "a",
    properties: o,
    children: e.all(t)
  };
  return e.patch(t, i), e.applyData(t, i);
}
function Jee(e, t) {
  const n = { href: Wu(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function ete(e, t, n) {
  const r = e.all(t), o = n ? tte(n) : P6(t), i = {}, s = [];
  if (typeof t.checked == "boolean") {
    const p = r[0];
    let h;
    p && p.type === "element" && p.tagName === "p" ? h = p : (h = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(h)), h.children.length > 0 && h.children.unshift({ type: "text", value: " " }), h.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), i.className = ["task-list-item"];
  }
  let u = -1;
  for (; ++u < r.length; ) {
    const p = r[u];
    (o || u !== 0 || p.type !== "element" || p.tagName !== "p") && s.push({ type: "text", value: `
` }), p.type === "element" && p.tagName === "p" && !o ? s.push(...p.children) : s.push(p);
  }
  const c = r[r.length - 1];
  c && (o || c.type !== "element" || c.tagName !== "p") && s.push({ type: "text", value: `
` });
  const d = { type: "element", tagName: "li", properties: i, children: s };
  return e.patch(t, d), e.applyData(t, d);
}
function tte(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = P6(n[r]);
  }
  return t;
}
function P6(e) {
  return e.spread ?? e.children.length > 1;
}
function nte(e, t) {
  const n = {}, r = e.all(t);
  let o = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++o < r.length; ) {
    const s = r[o];
    if (s.type === "element" && s.tagName === "li" && s.properties && Array.isArray(s.properties.className) && s.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const i = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, i), e.applyData(t, i);
}
function rte(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function ote(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function ite(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function ate(e, t) {
  const n = e.all(t), r = n.shift(), o = [];
  if (r) {
    const s = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], s), o.push(s);
  }
  if (n.length > 0) {
    const s = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, u = A0(t.children[1]), c = m6(t.children[t.children.length - 1]);
    u && c && (s.position = { start: u, end: c }), o.push(s);
  }
  const i = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(o, !0)
  };
  return e.patch(t, i), e.applyData(t, i);
}
function ste(e, t, n) {
  const r = n ? n.children : void 0, o = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", i = n && n.type === "table" ? n.align : void 0, s = i ? i.length : t.children.length;
  let u = -1;
  const c = [];
  for (; ++u < s; ) {
    const p = t.children[u], h = {}, g = i ? i[u] : void 0;
    g && (h.align = g);
    let y = { type: "element", tagName: o, properties: h, children: [] };
    p && (y.children = e.all(p), e.patch(p, y), y = e.applyData(p, y)), c.push(y);
  }
  const d = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(c, !0)
  };
  return e.patch(t, d), e.applyData(t, d);
}
function lte(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const hA = 9, mA = 32;
function ute(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), o = 0;
  const i = [];
  for (; r; )
    i.push(
      gA(t.slice(o, r.index), o > 0, !0),
      r[0]
    ), o = r.index + r[0].length, r = n.exec(t);
  return i.push(gA(t.slice(o), o > 0, !1)), i.join("");
}
function gA(e, t, n) {
  let r = 0, o = e.length;
  if (t) {
    let i = e.codePointAt(r);
    for (; i === hA || i === mA; )
      r++, i = e.codePointAt(r);
  }
  if (n) {
    let i = e.codePointAt(o - 1);
    for (; i === hA || i === mA; )
      o--, i = e.codePointAt(o - 1);
  }
  return o > r ? e.slice(r, o) : "";
}
function cte(e, t) {
  const n = { type: "text", value: ute(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function dte(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const fte = {
  blockquote: Fee,
  break: Uee,
  code: Hee,
  delete: $ee,
  emphasis: Yee,
  footnoteReference: qee,
  heading: Xee,
  html: Wee,
  imageReference: Gee,
  image: Zee,
  inlineCode: Kee,
  linkReference: Qee,
  link: Jee,
  listItem: ete,
  list: nte,
  paragraph: rte,
  // @ts-expect-error: root is different, but hard to type.
  root: ote,
  strong: ite,
  table: ate,
  tableCell: lte,
  tableRow: ste,
  text: cte,
  thematicBreak: dte,
  toml: nh,
  yaml: nh,
  definition: nh,
  footnoteDefinition: nh
};
function nh() {
}
const L6 = -1, vg = 0, xd = 1, hm = 2, D0 = 3, P0 = 4, L0 = 5, I0 = 6, I6 = 7, V6 = 8, yA = typeof self == "object" ? self : globalThis, pte = (e, t) => {
  const n = (o, i) => (e.set(i, o), o), r = (o) => {
    if (e.has(o))
      return e.get(o);
    const [i, s] = t[o];
    switch (i) {
      case vg:
      case L6:
        return n(s, o);
      case xd: {
        const u = n([], o);
        for (const c of s)
          u.push(r(c));
        return u;
      }
      case hm: {
        const u = n({}, o);
        for (const [c, d] of s)
          u[r(c)] = r(d);
        return u;
      }
      case D0:
        return n(new Date(s), o);
      case P0: {
        const { source: u, flags: c } = s;
        return n(new RegExp(u, c), o);
      }
      case L0: {
        const u = n(/* @__PURE__ */ new Map(), o);
        for (const [c, d] of s)
          u.set(r(c), r(d));
        return u;
      }
      case I0: {
        const u = n(/* @__PURE__ */ new Set(), o);
        for (const c of s)
          u.add(r(c));
        return u;
      }
      case I6: {
        const { name: u, message: c } = s;
        return n(new yA[u](c), o);
      }
      case V6:
        return n(BigInt(s), o);
      case "BigInt":
        return n(Object(BigInt(s)), o);
      case "ArrayBuffer":
        return n(new Uint8Array(s).buffer, s);
      case "DataView": {
        const { buffer: u } = new Uint8Array(s);
        return n(new DataView(u), s);
      }
    }
    return n(new yA[i](s), o);
  };
  return r;
}, vA = (e) => pte(/* @__PURE__ */ new Map(), e)(0), Ql = "", { toString: hte } = {}, { keys: mte } = Object, td = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [vg, t];
  const n = hte.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [xd, Ql];
    case "Object":
      return [hm, Ql];
    case "Date":
      return [D0, Ql];
    case "RegExp":
      return [P0, Ql];
    case "Map":
      return [L0, Ql];
    case "Set":
      return [I0, Ql];
    case "DataView":
      return [xd, n];
  }
  return n.includes("Array") ? [xd, n] : n.includes("Error") ? [I6, n] : [hm, n];
}, rh = ([e, t]) => e === vg && (t === "function" || t === "symbol"), gte = (e, t, n, r) => {
  const o = (s, u) => {
    const c = r.push(s) - 1;
    return n.set(u, c), c;
  }, i = (s) => {
    if (n.has(s))
      return n.get(s);
    let [u, c] = td(s);
    switch (u) {
      case vg: {
        let p = s;
        switch (c) {
          case "bigint":
            u = V6, p = s.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + c);
            p = null;
            break;
          case "undefined":
            return o([L6], s);
        }
        return o([u, p], s);
      }
      case xd: {
        if (c) {
          let g = s;
          return c === "DataView" ? g = new Uint8Array(s.buffer) : c === "ArrayBuffer" && (g = new Uint8Array(s)), o([c, [...g]], s);
        }
        const p = [], h = o([u, p], s);
        for (const g of s)
          p.push(i(g));
        return h;
      }
      case hm: {
        if (c)
          switch (c) {
            case "BigInt":
              return o([c, s.toString()], s);
            case "Boolean":
            case "Number":
            case "String":
              return o([c, s.valueOf()], s);
          }
        if (t && "toJSON" in s)
          return i(s.toJSON());
        const p = [], h = o([u, p], s);
        for (const g of mte(s))
          (e || !rh(td(s[g]))) && p.push([i(g), i(s[g])]);
        return h;
      }
      case D0:
        return o([u, s.toISOString()], s);
      case P0: {
        const { source: p, flags: h } = s;
        return o([u, { source: p, flags: h }], s);
      }
      case L0: {
        const p = [], h = o([u, p], s);
        for (const [g, y] of s)
          (e || !(rh(td(g)) || rh(td(y)))) && p.push([i(g), i(y)]);
        return h;
      }
      case I0: {
        const p = [], h = o([u, p], s);
        for (const g of s)
          (e || !rh(td(g))) && p.push(i(g));
        return h;
      }
    }
    const { message: d } = s;
    return o([u, { name: c, message: d }], s);
  };
  return i;
}, bA = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return gte(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, mm = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? vA(bA(e, t)) : structuredClone(e)
) : (e, t) => vA(bA(e, t));
function yte(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function vte(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function bte(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || yte, r = e.options.footnoteBackLabel || vte, o = e.options.footnoteLabel || "Footnotes", i = e.options.footnoteLabelTagName || "h2", s = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, u = [];
  let c = -1;
  for (; ++c < e.footnoteOrder.length; ) {
    const d = e.footnoteById.get(
      e.footnoteOrder[c]
    );
    if (!d)
      continue;
    const p = e.all(d), h = String(d.identifier).toUpperCase(), g = Wu(h.toLowerCase());
    let y = 0;
    const b = [], v = e.footnoteCounts.get(h);
    for (; v !== void 0 && ++y <= v; ) {
      b.length > 0 && b.push({ type: "text", value: " " });
      let O = typeof n == "string" ? n : n(c, y);
      typeof O == "string" && (O = { type: "text", value: O }), b.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + g + (y > 1 ? "-" + y : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(c, y),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(O) ? O : [O]
      });
    }
    const x = p[p.length - 1];
    if (x && x.type === "element" && x.tagName === "p") {
      const O = x.children[x.children.length - 1];
      O && O.type === "text" ? O.value += " " : x.children.push({ type: "text", value: " " }), x.children.push(...b);
    } else
      p.push(...b);
    const _ = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + g },
      children: e.wrap(p, !0)
    };
    e.patch(d, _), u.push(_);
  }
  if (u.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: i,
          properties: {
            ...mm(s),
            id: "footnote-label"
          },
          children: [{ type: "text", value: o }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(u, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const bg = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return _te;
    if (typeof e == "function")
      return wg(e);
    if (typeof e == "object")
      return Array.isArray(e) ? wte(e) : xte(e);
    if (typeof e == "string")
      return Ste(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function wte(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = bg(e[n]);
  return wg(r);
  function r(...o) {
    let i = -1;
    for (; ++i < t.length; )
      if (t[i].apply(this, o)) return !0;
    return !1;
  }
}
function xte(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return wg(n);
  function n(r) {
    const o = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let i;
    for (i in e)
      if (o[i] !== t[i]) return !1;
    return !0;
  }
}
function Ste(e) {
  return wg(t);
  function t(n) {
    return n && n.type === e;
  }
}
function wg(e) {
  return t;
  function t(n, r, o) {
    return !!(kte(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      o || void 0
    ));
  }
}
function _te() {
  return !0;
}
function kte(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const B6 = [], Ete = !0, jx = !1, Cte = "skip";
function F6(e, t, n, r) {
  let o;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : o = t;
  const i = bg(o), s = r ? -1 : 1;
  u(e, void 0, [])();
  function u(c, d, p) {
    const h = (
      /** @type {Record<string, unknown>} */
      c && typeof c == "object" ? c : {}
    );
    if (typeof h.type == "string") {
      const y = (
        // `hast`
        typeof h.tagName == "string" ? h.tagName : (
          // `xast`
          typeof h.name == "string" ? h.name : void 0
        )
      );
      Object.defineProperty(g, "name", {
        value: "node (" + (c.type + (y ? "<" + y + ">" : "")) + ")"
      });
    }
    return g;
    function g() {
      let y = B6, b, v, x;
      if ((!t || i(c, d, p[p.length - 1] || void 0)) && (y = Ote(n(c, p)), y[0] === jx))
        return y;
      if ("children" in c && c.children) {
        const _ = (
          /** @type {UnistParent} */
          c
        );
        if (_.children && y[0] !== Cte)
          for (v = (r ? _.children.length : -1) + s, x = p.concat(_); v > -1 && v < _.children.length; ) {
            const O = _.children[v];
            if (b = u(O, v, x)(), b[0] === jx)
              return b;
            v = typeof b[1] == "number" ? b[1] : v + s;
          }
      }
      return y;
    }
  }
}
function Ote(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [Ete, e] : e == null ? B6 : [e];
}
function V0(e, t, n, r) {
  let o, i, s;
  typeof t == "function" ? (i = void 0, s = t, o = n) : (i = t, s = n, o = r), F6(e, i, u, o);
  function u(c, d) {
    const p = d[d.length - 1], h = p ? p.children.indexOf(c) : void 0;
    return s(c, h, p);
  }
}
const zx = {}.hasOwnProperty, Ate = {};
function Nte(e, t) {
  const n = t || Ate, r = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = { ...fte, ...n.handlers }, u = {
    all: d,
    applyData: Rte,
    definitionById: r,
    footnoteById: o,
    footnoteCounts: i,
    footnoteOrder: [],
    handlers: s,
    one: c,
    options: n,
    patch: Mte,
    wrap: zte
  };
  return V0(e, function(p) {
    if (p.type === "definition" || p.type === "footnoteDefinition") {
      const h = p.type === "definition" ? r : o, g = String(p.identifier).toUpperCase();
      h.has(g) || h.set(g, p);
    }
  }), u;
  function c(p, h) {
    const g = p.type, y = u.handlers[g];
    if (zx.call(u.handlers, g) && y)
      return y(u, p, h);
    if (u.options.passThrough && u.options.passThrough.includes(g)) {
      if ("children" in p) {
        const { children: b, ...v } = p, x = mm(v);
        return x.children = u.all(p), x;
      }
      return mm(p);
    }
    return (u.options.unknownHandler || jte)(u, p, h);
  }
  function d(p) {
    const h = [];
    if ("children" in p) {
      const g = p.children;
      let y = -1;
      for (; ++y < g.length; ) {
        const b = u.one(g[y], p);
        if (b) {
          if (y && g[y - 1].type === "break" && (!Array.isArray(b) && b.type === "text" && (b.value = wA(b.value)), !Array.isArray(b) && b.type === "element")) {
            const v = b.children[0];
            v && v.type === "text" && (v.value = wA(v.value));
          }
          Array.isArray(b) ? h.push(...b) : h.push(b);
        }
      }
    }
    return h;
  }
}
function Mte(e, t) {
  e.position && (t.position = vQ(e));
}
function Rte(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, o = e.data.hChildren, i = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const s = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: s };
      }
    n.type === "element" && i && Object.assign(n.properties, mm(i)), "children" in n && n.children && o !== null && o !== void 0 && (n.children = o);
  }
  return n;
}
function jte(e, t) {
  const n = t.data || {}, r = "value" in t && !(zx.call(n, "hProperties") || zx.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function zte(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function wA(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function xA(e, t) {
  const n = Nte(e, t), r = n.one(e, void 0), o = bte(n), i = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return o && i.children.push({ type: "text", value: `
` }, o), i;
}
function Tte(e, t) {
  return e && "run" in e ? async function(n, r) {
    const o = (
      /** @type {HastRoot} */
      xA(n, { file: r, ...t })
    );
    await e.run(o, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      xA(n, { file: r, ...e || t })
    );
  };
}
function SA(e) {
  if (e)
    throw e;
}
var Ib, _A;
function Dte() {
  if (_A) return Ib;
  _A = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, o = function(c) {
    return typeof Array.isArray == "function" ? Array.isArray(c) : t.call(c) === "[object Array]";
  }, i = function(c) {
    if (!c || t.call(c) !== "[object Object]")
      return !1;
    var d = e.call(c, "constructor"), p = c.constructor && c.constructor.prototype && e.call(c.constructor.prototype, "isPrototypeOf");
    if (c.constructor && !d && !p)
      return !1;
    var h;
    for (h in c)
      ;
    return typeof h > "u" || e.call(c, h);
  }, s = function(c, d) {
    n && d.name === "__proto__" ? n(c, d.name, {
      enumerable: !0,
      configurable: !0,
      value: d.newValue,
      writable: !0
    }) : c[d.name] = d.newValue;
  }, u = function(c, d) {
    if (d === "__proto__")
      if (e.call(c, d)) {
        if (r)
          return r(c, d).value;
      } else return;
    return c[d];
  };
  return Ib = function c() {
    var d, p, h, g, y, b, v = arguments[0], x = 1, _ = arguments.length, O = !1;
    for (typeof v == "boolean" && (O = v, v = arguments[1] || {}, x = 2), (v == null || typeof v != "object" && typeof v != "function") && (v = {}); x < _; ++x)
      if (d = arguments[x], d != null)
        for (p in d)
          h = u(v, p), g = u(d, p), v !== g && (O && g && (i(g) || (y = o(g))) ? (y ? (y = !1, b = h && o(h) ? h : []) : b = h && i(h) ? h : {}, s(v, { name: p, newValue: c(O, b, g) })) : typeof g < "u" && s(v, { name: p, newValue: g }));
    return v;
  }, Ib;
}
var Pte = Dte();
const Vb = /* @__PURE__ */ Dm(Pte);
function Tx(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function Lte() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...o) {
    let i = -1;
    const s = o.pop();
    if (typeof s != "function")
      throw new TypeError("Expected function as last argument, not " + s);
    u(null, ...o);
    function u(c, ...d) {
      const p = e[++i];
      let h = -1;
      if (c) {
        s(c);
        return;
      }
      for (; ++h < o.length; )
        (d[h] === null || d[h] === void 0) && (d[h] = o[h]);
      o = d, p ? Ite(p, u)(...d) : s(null, ...d);
    }
  }
  function r(o) {
    if (typeof o != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + o
      );
    return e.push(o), t;
  }
}
function Ite(e, t) {
  let n;
  return r;
  function r(...s) {
    const u = e.length > s.length;
    let c;
    u && s.push(o);
    try {
      c = e.apply(this, s);
    } catch (d) {
      const p = (
        /** @type {Error} */
        d
      );
      if (u && n)
        throw p;
      return o(p);
    }
    u || (c && c.then && typeof c.then == "function" ? c.then(i, o) : c instanceof Error ? o(c) : i(c));
  }
  function o(s, ...u) {
    n || (n = !0, t(s, ...u));
  }
  function i(s) {
    o(null, s);
  }
}
const Qo = { basename: Vte, dirname: Bte, extname: Fte, join: Ute, sep: "/" };
function Vte(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  kf(e);
  let n = 0, r = -1, o = e.length, i;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; o--; )
      if (e.codePointAt(o) === 47) {
        if (i) {
          n = o + 1;
          break;
        }
      } else r < 0 && (i = !0, r = o + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let s = -1, u = t.length - 1;
  for (; o--; )
    if (e.codePointAt(o) === 47) {
      if (i) {
        n = o + 1;
        break;
      }
    } else
      s < 0 && (i = !0, s = o + 1), u > -1 && (e.codePointAt(o) === t.codePointAt(u--) ? u < 0 && (r = o) : (u = -1, r = s));
  return n === r ? r = s : r < 0 && (r = e.length), e.slice(n, r);
}
function Bte(e) {
  if (kf(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function Fte(e) {
  kf(e);
  let t = e.length, n = -1, r = 0, o = -1, i = 0, s;
  for (; t--; ) {
    const u = e.codePointAt(t);
    if (u === 47) {
      if (s) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (s = !0, n = t + 1), u === 46 ? o < 0 ? o = t : i !== 1 && (i = 1) : o > -1 && (i = -1);
  }
  return o < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  i === 0 || // The (right-most) trimmed path component is exactly `..`.
  i === 1 && o === n - 1 && o === r + 1 ? "" : e.slice(o, n);
}
function Ute(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    kf(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : Hte(n);
}
function Hte(e) {
  kf(e);
  const t = e.codePointAt(0) === 47;
  let n = $te(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function $te(e, t) {
  let n = "", r = 0, o = -1, i = 0, s = -1, u, c;
  for (; ++s <= e.length; ) {
    if (s < e.length)
      u = e.codePointAt(s);
    else {
      if (u === 47)
        break;
      u = 47;
    }
    if (u === 47) {
      if (!(o === s - 1 || i === 1)) if (o !== s - 1 && i === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (c = n.lastIndexOf("/"), c !== n.length - 1) {
              c < 0 ? (n = "", r = 0) : (n = n.slice(0, c), r = n.length - 1 - n.lastIndexOf("/")), o = s, i = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, o = s, i = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(o + 1, s) : n = e.slice(o + 1, s), r = s - o - 1;
      o = s, i = 0;
    } else u === 46 && i > -1 ? i++ : i = -1;
  }
  return n;
}
function kf(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const Yte = { cwd: qte };
function qte() {
  return "/";
}
function Dx(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function Xte(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!Dx(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return Wte(e);
}
function Wte(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const o = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw o.code = "ERR_INVALID_FILE_URL_PATH", o;
      }
    }
  return decodeURIComponent(t);
}
const Bb = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class U6 {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? Dx(t) ? n = { path: t } : typeof t == "string" || Gte(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : Yte.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < Bb.length; ) {
      const i = Bb[r];
      i in n && n[i] !== void 0 && n[i] !== null && (this[i] = i === "history" ? [...n[i]] : n[i]);
    }
    let o;
    for (o in n)
      Bb.includes(o) || (this[o] = n[o]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Qo.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    Ub(t, "basename"), Fb(t, "basename"), this.path = Qo.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Qo.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    kA(this.basename, "dirname"), this.path = Qo.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Qo.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (Fb(t, "extname"), kA(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Qo.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    Dx(t) && (t = Xte(t)), Ub(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Qo.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    Ub(t, "stem"), Fb(t, "stem"), this.path = Qo.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const o = this.message(t, n, r);
    throw o.fatal = !0, o;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const o = this.message(t, n, r);
    return o.fatal = void 0, o;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const o = new Yn(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (o.name = this.path + ":" + o.name, o.file = this.path), o.fatal = !1, this.messages.push(o), o;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function Fb(e, t) {
  if (e && e.includes(Qo.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Qo.sep + "`"
    );
}
function Ub(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function kA(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function Gte(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const Zte = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const t = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), n = t[e], r = function() {
      return n.apply(r, arguments);
    };
    return Object.setPrototypeOf(r, t), r;
  }
), Kte = {}.hasOwnProperty;
class B0 extends Zte {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = Lte();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new B0()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(Vb(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (Yb("data", this.frozen), this.namespace[t] = n, this) : Kte.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (Yb("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const o = n.call(t, ...r);
      typeof o == "function" && this.transformers.use(o);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = oh(t), r = this.parser || this.Parser;
    return Hb("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), Hb("process", this.parser || this.Parser), $b("process", this.compiler || this.Compiler), n ? o(void 0, n) : new Promise(o);
    function o(i, s) {
      const u = oh(t), c = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(u)
      );
      r.run(c, u, function(p, h, g) {
        if (p || !h || !g)
          return d(p);
        const y = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          h
        ), b = r.stringify(y, g);
        ene(b) ? g.value = b : g.result = b, d(
          p,
          /** @type {VFileWithOutput<CompileResult>} */
          g
        );
      });
      function d(p, h) {
        p || !h ? s(p) : i ? i(h) : n(void 0, h);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), Hb("processSync", this.parser || this.Parser), $b("processSync", this.compiler || this.Compiler), this.process(t, o), CA("processSync", "process", n), r;
    function o(i, s) {
      n = !0, SA(i), r = s;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    EA(t), this.freeze();
    const o = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? i(void 0, r) : new Promise(i);
    function i(s, u) {
      const c = oh(n);
      o.run(t, c, d);
      function d(p, h, g) {
        const y = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          h || t
        );
        p ? u(p) : s ? s(y) : r(void 0, y, g);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, o;
    return this.run(t, n, i), CA("runSync", "run", r), o;
    function i(s, u) {
      SA(s), o = u, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = oh(n), o = this.compiler || this.Compiler;
    return $b("stringify", o), EA(t), o(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, o = this.namespace;
    if (Yb("use", this.frozen), t != null) if (typeof t == "function")
      c(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? u(t) : s(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function i(d) {
      if (typeof d == "function")
        c(d, []);
      else if (typeof d == "object")
        if (Array.isArray(d)) {
          const [p, ...h] = (
            /** @type {PluginTuple<Array<unknown>>} */
            d
          );
          c(p, h);
        } else
          s(d);
      else
        throw new TypeError("Expected usable value, not `" + d + "`");
    }
    function s(d) {
      if (!("plugins" in d) && !("settings" in d))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      u(d.plugins), d.settings && (o.settings = Vb(!0, o.settings, d.settings));
    }
    function u(d) {
      let p = -1;
      if (d != null) if (Array.isArray(d))
        for (; ++p < d.length; ) {
          const h = d[p];
          i(h);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + d + "`");
    }
    function c(d, p) {
      let h = -1, g = -1;
      for (; ++h < r.length; )
        if (r[h][0] === d) {
          g = h;
          break;
        }
      if (g === -1)
        r.push([d, ...p]);
      else if (p.length > 0) {
        let [y, ...b] = p;
        const v = r[g][1];
        Tx(v) && Tx(y) && (y = Vb(!0, v, y)), r[g] = [d, y, ...b];
      }
    }
  }
}
const Qte = new B0().freeze();
function Hb(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function $b(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function Yb(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function EA(e) {
  if (!Tx(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function CA(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function oh(e) {
  return Jte(e) ? e : new U6(e);
}
function Jte(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function ene(e) {
  return typeof e == "string" || tne(e);
}
function tne(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const nne = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", OA = [], AA = { allowDangerousHtml: !0 }, rne = /^(https?|ircs?|mailto|xmpp)$/i, one = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  { from: "className", id: "remove-classname" },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function ine(e) {
  const t = ane(e), n = sne(e);
  return lne(t.runSync(t.parse(n), n), e);
}
function ane(e) {
  const t = e.rehypePlugins || OA, n = e.remarkPlugins || OA, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...AA } : AA;
  return Qte().use(Bee).use(n).use(Tte, r).use(t);
}
function sne(e) {
  const t = e.children || "", n = new U6();
  return typeof t == "string" && (n.value = t), n;
}
function lne(e, t) {
  const n = t.allowedElements, r = t.allowElement, o = t.components, i = t.disallowedElements, s = t.skipHtml, u = t.unwrapDisallowed, c = t.urlTransform || une;
  for (const p of one)
    Object.hasOwn(t, p.from) && "" + p.from + (p.to ? "use `" + p.to + "` instead" : "remove it") + nne + p.id;
  return V0(e, d), _Q(e, {
    Fragment: E.Fragment,
    components: o,
    ignoreInvalidStyle: !0,
    jsx: E.jsx,
    jsxs: E.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function d(p, h, g) {
    if (p.type === "raw" && g && typeof h == "number")
      return s ? g.children.splice(h, 1) : g.children[h] = { type: "text", value: p.value }, h;
    if (p.type === "element") {
      let y;
      for (y in Db)
        if (Object.hasOwn(Db, y) && Object.hasOwn(p.properties, y)) {
          const b = p.properties[y], v = Db[y];
          (v === null || v.includes(p.tagName)) && (p.properties[y] = c(String(b || ""), y, p));
        }
    }
    if (p.type === "element") {
      let y = n ? !n.includes(p.tagName) : i ? i.includes(p.tagName) : !1;
      if (!y && r && typeof h == "number" && (y = !r(p, h, g)), y && g && typeof h == "number")
        return u && p.children ? g.children.splice(h, 1, ...p.children) : g.children.splice(h, 1), h;
    }
  }
}
function une(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), o = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    o !== -1 && t > o || n !== -1 && t > n || r !== -1 && t > r || // It is a protocol, it should be allowed.
    rne.test(e.slice(0, t)) ? e : ""
  );
}
function NA(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, o = n.indexOf(t);
  for (; o !== -1; )
    r++, o = n.indexOf(t, o + t.length);
  return r;
}
function cne(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function dne(e, t, n) {
  const r = bg((n || {}).ignore || []), o = fne(t);
  let i = -1;
  for (; ++i < o.length; )
    F6(e, "text", s);
  function s(c, d) {
    let p = -1, h;
    for (; ++p < d.length; ) {
      const g = d[p], y = h ? h.children : void 0;
      if (r(
        g,
        y ? y.indexOf(g) : void 0,
        h
      ))
        return;
      h = g;
    }
    if (h)
      return u(c, d);
  }
  function u(c, d) {
    const p = d[d.length - 1], h = o[i][0], g = o[i][1];
    let y = 0;
    const b = p.children.indexOf(c);
    let v = !1, x = [];
    h.lastIndex = 0;
    let _ = h.exec(c.value);
    for (; _; ) {
      const O = _.index, C = {
        index: _.index,
        input: _.input,
        stack: [...d, c]
      };
      let N = g(..._, C);
      if (typeof N == "string" && (N = N.length > 0 ? { type: "text", value: N } : void 0), N === !1 ? h.lastIndex = O + 1 : (y !== O && x.push({
        type: "text",
        value: c.value.slice(y, O)
      }), Array.isArray(N) ? x.push(...N) : N && x.push(N), y = O + _[0].length, v = !0), !h.global)
        break;
      _ = h.exec(c.value);
    }
    return v ? (y < c.value.length && x.push({ type: "text", value: c.value.slice(y) }), p.children.splice(b, 1, ...x)) : x = [c], b + x.length;
  }
}
function fne(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const o = n[r];
    t.push([pne(o[0]), hne(o[1])]);
  }
  return t;
}
function pne(e) {
  return typeof e == "string" ? new RegExp(cne(e), "g") : e;
}
function hne(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const qb = "phrasing", Xb = ["autolink", "link", "image", "label"];
function mne() {
  return {
    transforms: [Sne],
    enter: {
      literalAutolink: yne,
      literalAutolinkEmail: Wb,
      literalAutolinkHttp: Wb,
      literalAutolinkWww: Wb
    },
    exit: {
      literalAutolink: xne,
      literalAutolinkEmail: wne,
      literalAutolinkHttp: vne,
      literalAutolinkWww: bne
    }
  };
}
function gne() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: qb,
        notInConstruct: Xb
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: qb,
        notInConstruct: Xb
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: qb,
        notInConstruct: Xb
      }
    ]
  };
}
function yne(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function Wb(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function vne(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function bne(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function wne(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function xne(e) {
  this.exit(e);
}
function Sne(e) {
  dne(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, _ne],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), kne]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function _ne(e, t, n, r, o) {
  let i = "";
  if (!H6(o) || (/^w/i.test(t) && (n = t + n, t = "", i = "http://"), !Ene(n)))
    return !1;
  const s = Cne(n + r);
  if (!s[0]) return !1;
  const u = {
    type: "link",
    title: null,
    url: i + t + s[0],
    children: [{ type: "text", value: t + s[0] }]
  };
  return s[1] ? [u, { type: "text", value: s[1] }] : u;
}
function kne(e, t, n, r) {
  return (
    // Not an expected previous character.
    !H6(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function Ene(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function Cne(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const o = NA(e, "(");
  let i = NA(e, ")");
  for (; r !== -1 && o > i; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), i++;
  return [e, n];
}
function H6(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || rl(n) || gg(n)) && // If its an email, the previous character should not be a slash.
  (!t || n !== 47);
}
$6.peek = Dne;
function One() {
  this.buffer();
}
function Ane(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function Nne() {
  this.buffer();
}
function Mne(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function Rne(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = Ro(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function jne(e) {
  this.exit(e);
}
function zne(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = Ro(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function Tne(e) {
  this.exit(e);
}
function Dne() {
  return "[";
}
function $6(e, t, n, r) {
  const o = n.createTracker(r);
  let i = o.move("[^");
  const s = n.enter("footnoteReference"), u = n.enter("reference");
  return i += o.move(
    n.safe(n.associationId(e), { after: "]", before: i })
  ), u(), s(), i += o.move("]"), i;
}
function Pne() {
  return {
    enter: {
      gfmFootnoteCallString: One,
      gfmFootnoteCall: Ane,
      gfmFootnoteDefinitionLabelString: Nne,
      gfmFootnoteDefinition: Mne
    },
    exit: {
      gfmFootnoteCallString: Rne,
      gfmFootnoteCall: jne,
      gfmFootnoteDefinitionLabelString: zne,
      gfmFootnoteDefinition: Tne
    }
  };
}
function Lne(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: n, footnoteReference: $6 },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function n(r, o, i, s) {
    const u = i.createTracker(s);
    let c = u.move("[^");
    const d = i.enter("footnoteDefinition"), p = i.enter("label");
    return c += u.move(
      i.safe(i.associationId(r), { before: c, after: "]" })
    ), p(), c += u.move("]:"), r.children && r.children.length > 0 && (u.shift(4), c += u.move(
      (t ? `
` : " ") + i.indentLines(
        i.containerFlow(r, u.current()),
        t ? Y6 : Ine
      )
    )), d(), c;
  }
}
function Ine(e, t, n) {
  return t === 0 ? e : Y6(e, t, n);
}
function Y6(e, t, n) {
  return (n ? "" : "    ") + e;
}
const Vne = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
q6.peek = $ne;
function Bne() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: Une },
    exit: { strikethrough: Hne }
  };
}
function Fne() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: Vne
      }
    ],
    handlers: { delete: q6 }
  };
}
function Une(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function Hne(e) {
  this.exit(e);
}
function q6(e, t, n, r) {
  const o = n.createTracker(r), i = n.enter("strikethrough");
  let s = o.move("~~");
  return s += n.containerPhrasing(e, {
    ...o.current(),
    before: s,
    after: "~"
  }), s += o.move("~~"), i(), s;
}
function $ne() {
  return "~";
}
function Yne(e) {
  return e.length;
}
function qne(e, t) {
  const n = t || {}, r = (n.align || []).concat(), o = n.stringLength || Yne, i = [], s = [], u = [], c = [];
  let d = 0, p = -1;
  for (; ++p < e.length; ) {
    const v = [], x = [];
    let _ = -1;
    for (e[p].length > d && (d = e[p].length); ++_ < e[p].length; ) {
      const O = Xne(e[p][_]);
      if (n.alignDelimiters !== !1) {
        const C = o(O);
        x[_] = C, (c[_] === void 0 || C > c[_]) && (c[_] = C);
      }
      v.push(O);
    }
    s[p] = v, u[p] = x;
  }
  let h = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++h < d; )
      i[h] = MA(r[h]);
  else {
    const v = MA(r);
    for (; ++h < d; )
      i[h] = v;
  }
  h = -1;
  const g = [], y = [];
  for (; ++h < d; ) {
    const v = i[h];
    let x = "", _ = "";
    v === 99 ? (x = ":", _ = ":") : v === 108 ? x = ":" : v === 114 && (_ = ":");
    let O = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      c[h] - x.length - _.length
    );
    const C = x + "-".repeat(O) + _;
    n.alignDelimiters !== !1 && (O = x.length + O + _.length, O > c[h] && (c[h] = O), y[h] = O), g[h] = C;
  }
  s.splice(1, 0, g), u.splice(1, 0, y), p = -1;
  const b = [];
  for (; ++p < s.length; ) {
    const v = s[p], x = u[p];
    h = -1;
    const _ = [];
    for (; ++h < d; ) {
      const O = v[h] || "";
      let C = "", N = "";
      if (n.alignDelimiters !== !1) {
        const R = c[h] - (x[h] || 0), z = i[h];
        z === 114 ? C = " ".repeat(R) : z === 99 ? R % 2 ? (C = " ".repeat(R / 2 + 0.5), N = " ".repeat(R / 2 - 0.5)) : (C = " ".repeat(R / 2), N = C) : N = " ".repeat(R);
      }
      n.delimiterStart !== !1 && !h && _.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && O === "") && (n.delimiterStart !== !1 || h) && _.push(" "), n.alignDelimiters !== !1 && _.push(C), _.push(O), n.alignDelimiters !== !1 && _.push(N), n.padding !== !1 && _.push(" "), (n.delimiterEnd !== !1 || h !== d - 1) && _.push("|");
    }
    b.push(
      n.delimiterEnd === !1 ? _.join("").replace(/ +$/, "") : _.join("")
    );
  }
  return b.join(`
`);
}
function Xne(e) {
  return e == null ? "" : String(e);
}
function MA(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function Wne(e, t, n, r) {
  const o = n.enter("blockquote"), i = n.createTracker(r);
  i.move("> "), i.shift(2);
  const s = n.indentLines(
    n.containerFlow(e, i.current()),
    Gne
  );
  return o(), s;
}
function Gne(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function Zne(e, t) {
  return RA(e, t.inConstruct, !0) && !RA(e, t.notInConstruct, !1);
}
function RA(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function jA(e, t, n, r) {
  let o = -1;
  for (; ++o < n.unsafe.length; )
    if (n.unsafe[o].character === `
` && Zne(n.stack, n.unsafe[o]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function Kne(e, t) {
  const n = String(e);
  let r = n.indexOf(t), o = r, i = 0, s = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === o ? ++i > s && (s = i) : i = 1, o = r + t.length, r = n.indexOf(t, o);
  return s;
}
function Qne(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function Jne(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function ere(e, t, n, r) {
  const o = Jne(n), i = e.value || "", s = o === "`" ? "GraveAccent" : "Tilde";
  if (Qne(e, n)) {
    const h = n.enter("codeIndented"), g = n.indentLines(i, tre);
    return h(), g;
  }
  const u = n.createTracker(r), c = o.repeat(Math.max(Kne(i, o) + 1, 3)), d = n.enter("codeFenced");
  let p = u.move(c);
  if (e.lang) {
    const h = n.enter(`codeFencedLang${s}`);
    p += u.move(
      n.safe(e.lang, {
        before: p,
        after: " ",
        encode: ["`"],
        ...u.current()
      })
    ), h();
  }
  if (e.lang && e.meta) {
    const h = n.enter(`codeFencedMeta${s}`);
    p += u.move(" "), p += u.move(
      n.safe(e.meta, {
        before: p,
        after: `
`,
        encode: ["`"],
        ...u.current()
      })
    ), h();
  }
  return p += u.move(`
`), i && (p += u.move(i + `
`)), p += u.move(c), d(), p;
}
function tre(e, t, n) {
  return (n ? "" : "    ") + e;
}
function F0(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function nre(e, t, n, r) {
  const o = F0(n), i = o === '"' ? "Quote" : "Apostrophe", s = n.enter("definition");
  let u = n.enter("label");
  const c = n.createTracker(r);
  let d = c.move("[");
  return d += c.move(
    n.safe(n.associationId(e), {
      before: d,
      after: "]",
      ...c.current()
    })
  ), d += c.move("]: "), u(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (u = n.enter("destinationLiteral"), d += c.move("<"), d += c.move(
    n.safe(e.url, { before: d, after: ">", ...c.current() })
  ), d += c.move(">")) : (u = n.enter("destinationRaw"), d += c.move(
    n.safe(e.url, {
      before: d,
      after: e.title ? " " : `
`,
      ...c.current()
    })
  )), u(), e.title && (u = n.enter(`title${i}`), d += c.move(" " + o), d += c.move(
    n.safe(e.title, {
      before: d,
      after: o,
      ...c.current()
    })
  ), d += c.move(o), u()), s(), d;
}
function rre(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function qd(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function gm(e, t, n) {
  const r = Du(e), o = Du(t);
  return r === void 0 ? o === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : o === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? o === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : o === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : o === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : o === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
X6.peek = ore;
function X6(e, t, n, r) {
  const o = rre(n), i = n.enter("emphasis"), s = n.createTracker(r), u = s.move(o);
  let c = s.move(
    n.containerPhrasing(e, {
      after: o,
      before: u,
      ...s.current()
    })
  );
  const d = c.charCodeAt(0), p = gm(
    r.before.charCodeAt(r.before.length - 1),
    d,
    o
  );
  p.inside && (c = qd(d) + c.slice(1));
  const h = c.charCodeAt(c.length - 1), g = gm(r.after.charCodeAt(0), h, o);
  g.inside && (c = c.slice(0, -1) + qd(h));
  const y = s.move(o);
  return i(), n.attentionEncodeSurroundingInfo = {
    after: g.outside,
    before: p.outside
  }, u + c + y;
}
function ore(e, t, n) {
  return n.options.emphasis || "*";
}
function ire(e, t) {
  let n = !1;
  return V0(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, jx;
  }), !!((!e.depth || e.depth < 3) && j0(e) && (t.options.setext || n));
}
function are(e, t, n, r) {
  const o = Math.max(Math.min(6, e.depth || 1), 1), i = n.createTracker(r);
  if (ire(e, n)) {
    const p = n.enter("headingSetext"), h = n.enter("phrasing"), g = n.containerPhrasing(e, {
      ...i.current(),
      before: `
`,
      after: `
`
    });
    return h(), p(), g + `
` + (o === 1 ? "=" : "-").repeat(
      // The whole size
      g.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(g.lastIndexOf("\r"), g.lastIndexOf(`
`)) + 1)
    );
  }
  const s = "#".repeat(o), u = n.enter("headingAtx"), c = n.enter("phrasing");
  i.move(s + " ");
  let d = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...i.current()
  });
  return /^[\t ]/.test(d) && (d = qd(d.charCodeAt(0)) + d.slice(1)), d = d ? s + " " + d : s, n.options.closeAtx && (d += " " + s), c(), u(), d;
}
W6.peek = sre;
function W6(e) {
  return e.value || "";
}
function sre() {
  return "<";
}
G6.peek = lre;
function G6(e, t, n, r) {
  const o = F0(n), i = o === '"' ? "Quote" : "Apostrophe", s = n.enter("image");
  let u = n.enter("label");
  const c = n.createTracker(r);
  let d = c.move("![");
  return d += c.move(
    n.safe(e.alt, { before: d, after: "]", ...c.current() })
  ), d += c.move("]("), u(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (u = n.enter("destinationLiteral"), d += c.move("<"), d += c.move(
    n.safe(e.url, { before: d, after: ">", ...c.current() })
  ), d += c.move(">")) : (u = n.enter("destinationRaw"), d += c.move(
    n.safe(e.url, {
      before: d,
      after: e.title ? " " : ")",
      ...c.current()
    })
  )), u(), e.title && (u = n.enter(`title${i}`), d += c.move(" " + o), d += c.move(
    n.safe(e.title, {
      before: d,
      after: o,
      ...c.current()
    })
  ), d += c.move(o), u()), d += c.move(")"), s(), d;
}
function lre() {
  return "!";
}
Z6.peek = ure;
function Z6(e, t, n, r) {
  const o = e.referenceType, i = n.enter("imageReference");
  let s = n.enter("label");
  const u = n.createTracker(r);
  let c = u.move("![");
  const d = n.safe(e.alt, {
    before: c,
    after: "]",
    ...u.current()
  });
  c += u.move(d + "]["), s();
  const p = n.stack;
  n.stack = [], s = n.enter("reference");
  const h = n.safe(n.associationId(e), {
    before: c,
    after: "]",
    ...u.current()
  });
  return s(), n.stack = p, i(), o === "full" || !d || d !== h ? c += u.move(h + "]") : o === "shortcut" ? c = c.slice(0, -1) : c += u.move("]"), c;
}
function ure() {
  return "!";
}
K6.peek = cre;
function K6(e, t, n) {
  let r = e.value || "", o = "`", i = -1;
  for (; new RegExp("(^|[^`])" + o + "([^`]|$)").test(r); )
    o += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++i < n.unsafe.length; ) {
    const s = n.unsafe[i], u = n.compilePattern(s);
    let c;
    if (s.atBreak)
      for (; c = u.exec(r); ) {
        let d = c.index;
        r.charCodeAt(d) === 10 && r.charCodeAt(d - 1) === 13 && d--, r = r.slice(0, d) + " " + r.slice(c.index + 1);
      }
  }
  return o + r + o;
}
function cre() {
  return "`";
}
function Q6(e, t) {
  const n = j0(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
J6.peek = dre;
function J6(e, t, n, r) {
  const o = F0(n), i = o === '"' ? "Quote" : "Apostrophe", s = n.createTracker(r);
  let u, c;
  if (Q6(e, n)) {
    const p = n.stack;
    n.stack = [], u = n.enter("autolink");
    let h = s.move("<");
    return h += s.move(
      n.containerPhrasing(e, {
        before: h,
        after: ">",
        ...s.current()
      })
    ), h += s.move(">"), u(), n.stack = p, h;
  }
  u = n.enter("link"), c = n.enter("label");
  let d = s.move("[");
  return d += s.move(
    n.containerPhrasing(e, {
      before: d,
      after: "](",
      ...s.current()
    })
  ), d += s.move("]("), c(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (c = n.enter("destinationLiteral"), d += s.move("<"), d += s.move(
    n.safe(e.url, { before: d, after: ">", ...s.current() })
  ), d += s.move(">")) : (c = n.enter("destinationRaw"), d += s.move(
    n.safe(e.url, {
      before: d,
      after: e.title ? " " : ")",
      ...s.current()
    })
  )), c(), e.title && (c = n.enter(`title${i}`), d += s.move(" " + o), d += s.move(
    n.safe(e.title, {
      before: d,
      after: o,
      ...s.current()
    })
  ), d += s.move(o), c()), d += s.move(")"), u(), d;
}
function dre(e, t, n) {
  return Q6(e, n) ? "<" : "[";
}
ez.peek = fre;
function ez(e, t, n, r) {
  const o = e.referenceType, i = n.enter("linkReference");
  let s = n.enter("label");
  const u = n.createTracker(r);
  let c = u.move("[");
  const d = n.containerPhrasing(e, {
    before: c,
    after: "]",
    ...u.current()
  });
  c += u.move(d + "]["), s();
  const p = n.stack;
  n.stack = [], s = n.enter("reference");
  const h = n.safe(n.associationId(e), {
    before: c,
    after: "]",
    ...u.current()
  });
  return s(), n.stack = p, i(), o === "full" || !d || d !== h ? c += u.move(h + "]") : o === "shortcut" ? c = c.slice(0, -1) : c += u.move("]"), c;
}
function fre() {
  return "[";
}
function U0(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function pre(e) {
  const t = U0(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function hre(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function tz(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function mre(e, t, n, r) {
  const o = n.enter("list"), i = n.bulletCurrent;
  let s = e.ordered ? hre(n) : U0(n);
  const u = e.ordered ? s === "." ? ")" : "." : pre(n);
  let c = t && n.bulletLastUsed ? s === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const p = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (s === "*" || s === "-") && // Empty first list item:
      p && (!p.children || !p.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (c = !0), tz(n) === s && p
    ) {
      let h = -1;
      for (; ++h < e.children.length; ) {
        const g = e.children[h];
        if (g && g.type === "listItem" && g.children && g.children[0] && g.children[0].type === "thematicBreak") {
          c = !0;
          break;
        }
      }
    }
  }
  c && (s = u), n.bulletCurrent = s;
  const d = n.containerFlow(e, r);
  return n.bulletLastUsed = s, n.bulletCurrent = i, o(), d;
}
function gre(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function yre(e, t, n, r) {
  const o = gre(n);
  let i = n.bulletCurrent || U0(n);
  t && t.type === "list" && t.ordered && (i = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + i);
  let s = i.length + 1;
  (o === "tab" || o === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (s = Math.ceil(s / 4) * 4);
  const u = n.createTracker(r);
  u.move(i + " ".repeat(s - i.length)), u.shift(s);
  const c = n.enter("listItem"), d = n.indentLines(
    n.containerFlow(e, u.current()),
    p
  );
  return c(), d;
  function p(h, g, y) {
    return g ? (y ? "" : " ".repeat(s)) + h : (y ? i : i + " ".repeat(s - i.length)) + h;
  }
}
function vre(e, t, n, r) {
  const o = n.enter("paragraph"), i = n.enter("phrasing"), s = n.containerPhrasing(e, r);
  return i(), o(), s;
}
const bre = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  bg([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function wre(e, t, n, r) {
  return (e.children.some(function(o) {
    return bre(o);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function xre(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
nz.peek = Sre;
function nz(e, t, n, r) {
  const o = xre(n), i = n.enter("strong"), s = n.createTracker(r), u = s.move(o + o);
  let c = s.move(
    n.containerPhrasing(e, {
      after: o,
      before: u,
      ...s.current()
    })
  );
  const d = c.charCodeAt(0), p = gm(
    r.before.charCodeAt(r.before.length - 1),
    d,
    o
  );
  p.inside && (c = qd(d) + c.slice(1));
  const h = c.charCodeAt(c.length - 1), g = gm(r.after.charCodeAt(0), h, o);
  g.inside && (c = c.slice(0, -1) + qd(h));
  const y = s.move(o + o);
  return i(), n.attentionEncodeSurroundingInfo = {
    after: g.outside,
    before: p.outside
  }, u + c + y;
}
function Sre(e, t, n) {
  return n.options.strong || "*";
}
function _re(e, t, n, r) {
  return n.safe(e.value, r);
}
function kre(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function Ere(e, t, n) {
  const r = (tz(n) + (n.options.ruleSpaces ? " " : "")).repeat(kre(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const rz = {
  blockquote: Wne,
  break: jA,
  code: ere,
  definition: nre,
  emphasis: X6,
  hardBreak: jA,
  heading: are,
  html: W6,
  image: G6,
  imageReference: Z6,
  inlineCode: K6,
  link: J6,
  linkReference: ez,
  list: mre,
  listItem: yre,
  paragraph: vre,
  root: wre,
  strong: nz,
  text: _re,
  thematicBreak: Ere
};
function Cre() {
  return {
    enter: {
      table: Ore,
      tableData: zA,
      tableHeader: zA,
      tableRow: Nre
    },
    exit: {
      codeText: Mre,
      table: Are,
      tableData: Gb,
      tableHeader: Gb,
      tableRow: Gb
    }
  };
}
function Ore(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function Are(e) {
  this.exit(e), this.data.inTable = void 0;
}
function Nre(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function Gb(e) {
  this.exit(e);
}
function zA(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function Mre(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, Rre));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function Rre(e, t) {
  return t === "|" ? t : e;
}
function jre(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, o = t.stringLength, i = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: g,
      table: s,
      tableCell: c,
      tableRow: u
    }
  };
  function s(y, b, v, x) {
    return d(p(y, v, x), y.align);
  }
  function u(y, b, v, x) {
    const _ = h(y, v, x), O = d([_]);
    return O.slice(0, O.indexOf(`
`));
  }
  function c(y, b, v, x) {
    const _ = v.enter("tableCell"), O = v.enter("phrasing"), C = v.containerPhrasing(y, {
      ...x,
      before: i,
      after: i
    });
    return O(), _(), C;
  }
  function d(y, b) {
    return qne(y, {
      align: b,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: o
    });
  }
  function p(y, b, v) {
    const x = y.children;
    let _ = -1;
    const O = [], C = b.enter("table");
    for (; ++_ < x.length; )
      O[_] = h(x[_], b, v);
    return C(), O;
  }
  function h(y, b, v) {
    const x = y.children;
    let _ = -1;
    const O = [], C = b.enter("tableRow");
    for (; ++_ < x.length; )
      O[_] = c(x[_], y, b, v);
    return C(), O;
  }
  function g(y, b, v) {
    let x = rz.inlineCode(y, b, v);
    return v.stack.includes("tableCell") && (x = x.replace(/\|/g, "\\$&")), x;
  }
}
function zre() {
  return {
    exit: {
      taskListCheckValueChecked: TA,
      taskListCheckValueUnchecked: TA,
      paragraph: Dre
    }
  };
}
function Tre() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: Pre }
  };
}
function TA(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function Dre(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const o = t.children;
      let i = -1, s;
      for (; ++i < o.length; ) {
        const u = o[i];
        if (u.type === "paragraph") {
          s = u;
          break;
        }
      }
      s === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function Pre(e, t, n, r) {
  const o = e.children[0], i = typeof e.checked == "boolean" && o && o.type === "paragraph", s = "[" + (e.checked ? "x" : " ") + "] ", u = n.createTracker(r);
  i && u.move(s);
  let c = rz.listItem(e, t, n, {
    ...r,
    ...u.current()
  });
  return i && (c = c.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, d)), c;
  function d(p) {
    return p + s;
  }
}
function Lre() {
  return [
    mne(),
    Pne(),
    Bne(),
    Cre(),
    zre()
  ];
}
function Ire(e) {
  return {
    extensions: [
      gne(),
      Lne(e),
      Fne(),
      jre(e),
      Tre()
    ]
  };
}
const Vre = {
  tokenize: Yre,
  partial: !0
}, oz = {
  tokenize: qre,
  partial: !0
}, iz = {
  tokenize: Xre,
  partial: !0
}, az = {
  tokenize: Wre,
  partial: !0
}, Bre = {
  tokenize: Gre,
  partial: !0
}, sz = {
  name: "wwwAutolink",
  tokenize: Hre,
  previous: uz
}, lz = {
  name: "protocolAutolink",
  tokenize: $re,
  previous: cz
}, aa = {
  name: "emailAutolink",
  tokenize: Ure,
  previous: dz
}, gi = {};
function Fre() {
  return {
    text: gi
  };
}
let Ps = 48;
for (; Ps < 123; )
  gi[Ps] = aa, Ps++, Ps === 58 ? Ps = 65 : Ps === 91 && (Ps = 97);
gi[43] = aa;
gi[45] = aa;
gi[46] = aa;
gi[95] = aa;
gi[72] = [aa, lz];
gi[104] = [aa, lz];
gi[87] = [aa, sz];
gi[119] = [aa, sz];
function Ure(e, t, n) {
  const r = this;
  let o, i;
  return s;
  function s(h) {
    return !Px(h) || !dz.call(r, r.previous) || H0(r.events) ? n(h) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), u(h));
  }
  function u(h) {
    return Px(h) ? (e.consume(h), u) : h === 64 ? (e.consume(h), c) : n(h);
  }
  function c(h) {
    return h === 46 ? e.check(Bre, p, d)(h) : h === 45 || h === 95 || Un(h) ? (i = !0, e.consume(h), c) : p(h);
  }
  function d(h) {
    return e.consume(h), o = !0, c;
  }
  function p(h) {
    return i && o && er(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(h)) : n(h);
  }
}
function Hre(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return s !== 87 && s !== 119 || !uz.call(r, r.previous) || H0(r.events) ? n(s) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(Vre, e.attempt(oz, e.attempt(iz, i), n), n)(s));
  }
  function i(s) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(s);
  }
}
function $re(e, t, n) {
  const r = this;
  let o = "", i = !1;
  return s;
  function s(h) {
    return (h === 72 || h === 104) && cz.call(r, r.previous) && !H0(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), o += String.fromCodePoint(h), e.consume(h), u) : n(h);
  }
  function u(h) {
    if (er(h) && o.length < 5)
      return o += String.fromCodePoint(h), e.consume(h), u;
    if (h === 58) {
      const g = o.toLowerCase();
      if (g === "http" || g === "https")
        return e.consume(h), c;
    }
    return n(h);
  }
  function c(h) {
    return h === 47 ? (e.consume(h), i ? d : (i = !0, c)) : n(h);
  }
  function d(h) {
    return h === null || pm(h) || Mt(h) || rl(h) || gg(h) ? n(h) : e.attempt(oz, e.attempt(iz, p), n)(h);
  }
  function p(h) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(h);
  }
}
function Yre(e, t, n) {
  let r = 0;
  return o;
  function o(s) {
    return (s === 87 || s === 119) && r < 3 ? (r++, e.consume(s), o) : s === 46 && r === 3 ? (e.consume(s), i) : n(s);
  }
  function i(s) {
    return s === null ? n(s) : t(s);
  }
}
function qre(e, t, n) {
  let r, o, i;
  return s;
  function s(d) {
    return d === 46 || d === 95 ? e.check(az, c, u)(d) : d === null || Mt(d) || rl(d) || d !== 45 && gg(d) ? c(d) : (i = !0, e.consume(d), s);
  }
  function u(d) {
    return d === 95 ? r = !0 : (o = r, r = void 0), e.consume(d), s;
  }
  function c(d) {
    return o || r || !i ? n(d) : t(d);
  }
}
function Xre(e, t) {
  let n = 0, r = 0;
  return o;
  function o(s) {
    return s === 40 ? (n++, e.consume(s), o) : s === 41 && r < n ? i(s) : s === 33 || s === 34 || s === 38 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 60 || s === 63 || s === 93 || s === 95 || s === 126 ? e.check(az, t, i)(s) : s === null || Mt(s) || rl(s) ? t(s) : (e.consume(s), o);
  }
  function i(s) {
    return s === 41 && r++, e.consume(s), o;
  }
}
function Wre(e, t, n) {
  return r;
  function r(u) {
    return u === 33 || u === 34 || u === 39 || u === 41 || u === 42 || u === 44 || u === 46 || u === 58 || u === 59 || u === 63 || u === 95 || u === 126 ? (e.consume(u), r) : u === 38 ? (e.consume(u), i) : u === 93 ? (e.consume(u), o) : (
      // `<` is an end.
      u === 60 || // So is whitespace.
      u === null || Mt(u) || rl(u) ? t(u) : n(u)
    );
  }
  function o(u) {
    return u === null || u === 40 || u === 91 || Mt(u) || rl(u) ? t(u) : r(u);
  }
  function i(u) {
    return er(u) ? s(u) : n(u);
  }
  function s(u) {
    return u === 59 ? (e.consume(u), r) : er(u) ? (e.consume(u), s) : n(u);
  }
}
function Gre(e, t, n) {
  return r;
  function r(i) {
    return e.consume(i), o;
  }
  function o(i) {
    return Un(i) ? n(i) : t(i);
  }
}
function uz(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || Mt(e);
}
function cz(e) {
  return !er(e);
}
function dz(e) {
  return !(e === 47 || Px(e));
}
function Px(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || Un(e);
}
function H0(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const Zre = {
  tokenize: ooe,
  partial: !0
};
function Kre() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: toe,
        continuation: {
          tokenize: noe
        },
        exit: roe
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: eoe
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: Qre,
        resolveTo: Jre
      }
    }
  };
}
function Qre(e, t, n) {
  const r = this;
  let o = r.events.length;
  const i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s;
  for (; o--; ) {
    const c = r.events[o][1];
    if (c.type === "labelImage") {
      s = c;
      break;
    }
    if (c.type === "gfmFootnoteCall" || c.type === "labelLink" || c.type === "label" || c.type === "image" || c.type === "link")
      break;
  }
  return u;
  function u(c) {
    if (!s || !s._balanced)
      return n(c);
    const d = Ro(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }));
    return d.codePointAt(0) !== 94 || !i.includes(d.slice(1)) ? n(c) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(c), e.exit("gfmFootnoteCallLabelMarker"), t(c));
  }
}
function Jre(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, o = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  o.end.column++, o.end.offset++, o.end._bufferIndex++;
  const i = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, o.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, s = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, i.start),
    end: Object.assign({}, i.end)
  }, u = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", o, t],
    ["exit", o, t],
    // Everything in between.
    ["enter", i, t],
    ["enter", s, t],
    ["exit", s, t],
    ["exit", i, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...u), e;
}
function eoe(e, t, n) {
  const r = this, o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let i = 0, s;
  return u;
  function u(h) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(h), e.exit("gfmFootnoteCallLabelMarker"), c;
  }
  function c(h) {
    return h !== 94 ? n(h) : (e.enter("gfmFootnoteCallMarker"), e.consume(h), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", d);
  }
  function d(h) {
    if (
      // Too long.
      i > 999 || // Closing brace with nothing.
      h === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || Mt(h)
    )
      return n(h);
    if (h === 93) {
      e.exit("chunkString");
      const g = e.exit("gfmFootnoteCallString");
      return o.includes(Ro(r.sliceSerialize(g))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(h), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(h);
    }
    return Mt(h) || (s = !0), i++, e.consume(h), h === 92 ? p : d;
  }
  function p(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), i++, d) : d(h);
  }
}
function toe(e, t, n) {
  const r = this, o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let i, s = 0, u;
  return c;
  function c(b) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionLabelMarker"), d;
  }
  function d(b) {
    return b === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", p) : n(b);
  }
  function p(b) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      b === 93 && !u || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      b === null || b === 91 || Mt(b)
    )
      return n(b);
    if (b === 93) {
      e.exit("chunkString");
      const v = e.exit("gfmFootnoteDefinitionLabelString");
      return i = Ro(r.sliceSerialize(v)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), g;
    }
    return Mt(b) || (u = !0), s++, e.consume(b), b === 92 ? h : p;
  }
  function h(b) {
    return b === 91 || b === 92 || b === 93 ? (e.consume(b), s++, p) : p(b);
  }
  function g(b) {
    return b === 58 ? (e.enter("definitionMarker"), e.consume(b), e.exit("definitionMarker"), o.includes(i) || o.push(i), lt(e, y, "gfmFootnoteDefinitionWhitespace")) : n(b);
  }
  function y(b) {
    return t(b);
  }
}
function noe(e, t, n) {
  return e.check(_f, t, e.attempt(Zre, t, n));
}
function roe(e) {
  e.exit("gfmFootnoteDefinition");
}
function ooe(e, t, n) {
  const r = this;
  return lt(e, o, "gfmFootnoteDefinitionIndent", 5);
  function o(i) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "gfmFootnoteDefinitionIndent" && s[2].sliceSerialize(s[1], !0).length === 4 ? t(i) : n(i);
  }
}
function ioe(e) {
  let t = (e || {}).singleTilde;
  const n = {
    name: "strikethrough",
    tokenize: o,
    resolveAll: r
  };
  return t == null && (t = !0), {
    text: {
      126: n
    },
    insideSpan: {
      null: [n]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function r(i, s) {
    let u = -1;
    for (; ++u < i.length; )
      if (i[u][0] === "enter" && i[u][1].type === "strikethroughSequenceTemporary" && i[u][1]._close) {
        let c = u;
        for (; c--; )
          if (i[c][0] === "exit" && i[c][1].type === "strikethroughSequenceTemporary" && i[c][1]._open && // If the sizes are the same:
          i[u][1].end.offset - i[u][1].start.offset === i[c][1].end.offset - i[c][1].start.offset) {
            i[u][1].type = "strikethroughSequence", i[c][1].type = "strikethroughSequence";
            const d = {
              type: "strikethrough",
              start: Object.assign({}, i[c][1].start),
              end: Object.assign({}, i[u][1].end)
            }, p = {
              type: "strikethroughText",
              start: Object.assign({}, i[c][1].end),
              end: Object.assign({}, i[u][1].start)
            }, h = [["enter", d, s], ["enter", i[c][1], s], ["exit", i[c][1], s], ["enter", p, s]], g = s.parser.constructs.insideSpan.null;
            g && Br(h, h.length, 0, yg(g, i.slice(c + 1, u), s)), Br(h, h.length, 0, [["exit", p, s], ["enter", i[u][1], s], ["exit", i[u][1], s], ["exit", d, s]]), Br(i, c - 1, u - c + 3, h), u = c + h.length - 2;
            break;
          }
      }
    for (u = -1; ++u < i.length; )
      i[u][1].type === "strikethroughSequenceTemporary" && (i[u][1].type = "data");
    return i;
  }
  function o(i, s, u) {
    const c = this.previous, d = this.events;
    let p = 0;
    return h;
    function h(y) {
      return c === 126 && d[d.length - 1][1].type !== "characterEscape" ? u(y) : (i.enter("strikethroughSequenceTemporary"), g(y));
    }
    function g(y) {
      const b = Du(c);
      if (y === 126)
        return p > 1 ? u(y) : (i.consume(y), p++, g);
      if (p < 2 && !t) return u(y);
      const v = i.exit("strikethroughSequenceTemporary"), x = Du(y);
      return v._open = !x || x === 2 && !!b, v._close = !b || b === 2 && !!x, s(y);
    }
  }
}
class aoe {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    soe(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(i, s) {
      return i[0] - s[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push(t.slice()), t.length = 0;
    let o = r.pop();
    for (; o; ) {
      for (const i of o)
        t.push(i);
      o = r.pop();
    }
    this.map.length = 0;
  }
}
function soe(e, t, n, r) {
  let o = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; o < e.map.length; ) {
      if (e.map[o][0] === t) {
        e.map[o][1] += n, e.map[o][2].push(...r);
        return;
      }
      o += 1;
    }
    e.map.push([t, n, r]);
  }
}
function loe(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const o = e[t];
    if (n) {
      if (o[0] === "enter")
        o[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (o[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const i = r.length - 1;
          r[i] = r[i] === "left" ? "center" : "right";
        }
      } else if (o[1].type === "tableDelimiterRow")
        break;
    } else o[0] === "enter" && o[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function uoe() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: coe,
        resolveAll: doe
      }
    }
  };
}
function coe(e, t, n) {
  const r = this;
  let o = 0, i = 0, s;
  return u;
  function u(A) {
    let V = r.events.length - 1;
    for (; V > -1; ) {
      const D = r.events[V][1].type;
      if (D === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      D === "linePrefix") V--;
      else break;
    }
    const U = V > -1 ? r.events[V][1].type : null, W = U === "tableHead" || U === "tableRow" ? z : c;
    return W === z && r.parser.lazy[r.now().line] ? n(A) : W(A);
  }
  function c(A) {
    return e.enter("tableHead"), e.enter("tableRow"), d(A);
  }
  function d(A) {
    return A === 124 || (s = !0, i += 1), p(A);
  }
  function p(A) {
    return A === null ? n(A) : Pe(A) ? i > 1 ? (i = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(A), e.exit("lineEnding"), y) : n(A) : rt(A) ? lt(e, p, "whitespace")(A) : (i += 1, s && (s = !1, o += 1), A === 124 ? (e.enter("tableCellDivider"), e.consume(A), e.exit("tableCellDivider"), s = !0, p) : (e.enter("data"), h(A)));
  }
  function h(A) {
    return A === null || A === 124 || Mt(A) ? (e.exit("data"), p(A)) : (e.consume(A), A === 92 ? g : h);
  }
  function g(A) {
    return A === 92 || A === 124 ? (e.consume(A), h) : h(A);
  }
  function y(A) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(A) : (e.enter("tableDelimiterRow"), s = !1, rt(A) ? lt(e, b, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(A) : b(A));
  }
  function b(A) {
    return A === 45 || A === 58 ? x(A) : A === 124 ? (s = !0, e.enter("tableCellDivider"), e.consume(A), e.exit("tableCellDivider"), v) : R(A);
  }
  function v(A) {
    return rt(A) ? lt(e, x, "whitespace")(A) : x(A);
  }
  function x(A) {
    return A === 58 ? (i += 1, s = !0, e.enter("tableDelimiterMarker"), e.consume(A), e.exit("tableDelimiterMarker"), _) : A === 45 ? (i += 1, _(A)) : A === null || Pe(A) ? N(A) : R(A);
  }
  function _(A) {
    return A === 45 ? (e.enter("tableDelimiterFiller"), O(A)) : R(A);
  }
  function O(A) {
    return A === 45 ? (e.consume(A), O) : A === 58 ? (s = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(A), e.exit("tableDelimiterMarker"), C) : (e.exit("tableDelimiterFiller"), C(A));
  }
  function C(A) {
    return rt(A) ? lt(e, N, "whitespace")(A) : N(A);
  }
  function N(A) {
    return A === 124 ? b(A) : A === null || Pe(A) ? !s || o !== i ? R(A) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(A)) : R(A);
  }
  function R(A) {
    return n(A);
  }
  function z(A) {
    return e.enter("tableRow"), j(A);
  }
  function j(A) {
    return A === 124 ? (e.enter("tableCellDivider"), e.consume(A), e.exit("tableCellDivider"), j) : A === null || Pe(A) ? (e.exit("tableRow"), t(A)) : rt(A) ? lt(e, j, "whitespace")(A) : (e.enter("data"), I(A));
  }
  function I(A) {
    return A === null || A === 124 || Mt(A) ? (e.exit("data"), j(A)) : (e.consume(A), A === 92 ? $ : I);
  }
  function $(A) {
    return A === 92 || A === 124 ? (e.consume(A), I) : I(A);
  }
}
function doe(e, t) {
  let n = -1, r = !0, o = 0, i = [0, 0, 0, 0], s = [0, 0, 0, 0], u = !1, c = 0, d, p, h;
  const g = new aoe();
  for (; ++n < e.length; ) {
    const y = e[n], b = y[1];
    y[0] === "enter" ? b.type === "tableHead" ? (u = !1, c !== 0 && (DA(g, t, c, d, p), p = void 0, c = 0), d = {
      type: "table",
      start: Object.assign({}, b.start),
      // Note: correct end is set later.
      end: Object.assign({}, b.end)
    }, g.add(n, 0, [["enter", d, t]])) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (r = !0, h = void 0, i = [0, 0, 0, 0], s = [0, n + 1, 0, 0], u && (u = !1, p = {
      type: "tableBody",
      start: Object.assign({}, b.start),
      // Note: correct end is set later.
      end: Object.assign({}, b.end)
    }, g.add(n, 0, [["enter", p, t]])), o = b.type === "tableDelimiterRow" ? 2 : p ? 3 : 1) : o && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") ? (r = !1, s[2] === 0 && (i[1] !== 0 && (s[0] = s[1], h = ih(g, t, i, o, void 0, h), i = [0, 0, 0, 0]), s[2] = n)) : b.type === "tableCellDivider" && (r ? r = !1 : (i[1] !== 0 && (s[0] = s[1], h = ih(g, t, i, o, void 0, h)), i = s, s = [i[1], n, 0, 0])) : b.type === "tableHead" ? (u = !0, c = n) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (c = n, i[1] !== 0 ? (s[0] = s[1], h = ih(g, t, i, o, n, h)) : s[1] !== 0 && (h = ih(g, t, s, o, n, h)), o = 0) : o && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") && (s[3] = n);
  }
  for (c !== 0 && DA(g, t, c, d, p), g.consume(t.events), n = -1; ++n < t.events.length; ) {
    const y = t.events[n];
    y[0] === "enter" && y[1].type === "table" && (y[1]._align = loe(t.events, n));
  }
  return e;
}
function ih(e, t, n, r, o, i) {
  const s = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", u = "tableContent";
  n[0] !== 0 && (i.end = Object.assign({}, au(t.events, n[0])), e.add(n[0], 0, [["exit", i, t]]));
  const c = au(t.events, n[1]);
  if (i = {
    type: s,
    start: Object.assign({}, c),
    // Note: correct end is set later.
    end: Object.assign({}, c)
  }, e.add(n[1], 0, [["enter", i, t]]), n[2] !== 0) {
    const d = au(t.events, n[2]), p = au(t.events, n[3]), h = {
      type: u,
      start: Object.assign({}, d),
      end: Object.assign({}, p)
    };
    if (e.add(n[2], 0, [["enter", h, t]]), r !== 2) {
      const g = t.events[n[2]], y = t.events[n[3]];
      if (g[1].end = Object.assign({}, y[1].end), g[1].type = "chunkText", g[1].contentType = "text", n[3] > n[2] + 1) {
        const b = n[2] + 1, v = n[3] - n[2] - 1;
        e.add(b, v, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", h, t]]);
  }
  return o !== void 0 && (i.end = Object.assign({}, au(t.events, o)), e.add(o, 0, [["exit", i, t]]), i = void 0), i;
}
function DA(e, t, n, r, o) {
  const i = [], s = au(t.events, n);
  o && (o.end = Object.assign({}, s), i.push(["exit", o, t])), r.end = Object.assign({}, s), i.push(["exit", r, t]), e.add(n + 1, 0, i);
}
function au(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const foe = {
  name: "tasklistCheck",
  tokenize: hoe
};
function poe() {
  return {
    text: {
      91: foe
    }
  };
}
function hoe(e, t, n) {
  const r = this;
  return o;
  function o(c) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(c) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), i)
    );
  }
  function i(c) {
    return Mt(c) ? (e.enter("taskListCheckValueUnchecked"), e.consume(c), e.exit("taskListCheckValueUnchecked"), s) : c === 88 || c === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(c), e.exit("taskListCheckValueChecked"), s) : n(c);
  }
  function s(c) {
    return c === 93 ? (e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), u) : n(c);
  }
  function u(c) {
    return Pe(c) ? t(c) : rt(c) ? e.check({
      tokenize: moe
    }, t, n)(c) : n(c);
  }
}
function moe(e, t, n) {
  return lt(e, r, "whitespace");
  function r(o) {
    return o === null ? n(o) : t(o);
  }
}
function goe(e) {
  return S6([
    Fre(),
    Kre(),
    ioe(e),
    uoe(),
    poe()
  ]);
}
const yoe = {};
function voe(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), n = e || yoe, r = t.data(), o = r.micromarkExtensions || (r.micromarkExtensions = []), i = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), s = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  o.push(goe(n)), i.push(Lre()), s.push(Ire(n));
}
const fz = ({ item: e }) => {
  const t = S.useContext(it), n = () => {
    var o;
    (o = t.worker) == null || o.add_node(e.node_id);
  }, r = (o) => {
    o.detail === 2 && n();
  };
  return /* @__PURE__ */ E.jsx("div", { className: "libnodeentry", onClick: r, title: e.description, children: e.node_name || e.node_id });
}, pz = (e, t) => {
  var n, r;
  const o = ((n = e.nodes) == null ? void 0 : n.some(
    (s) => s.node_id.toLowerCase().includes(t.toLowerCase())
  )) ?? !1, i = ((r = e.subshelves) == null ? void 0 : r.some((s) => pz(s, t))) ?? !1;
  return o || i;
}, $0 = ({
  item: e,
  filter: t,
  parentkey: n
}) => {
  var r;
  const [o, i] = S.useState(!1), s = () => i(!o), u = (r = e.nodes) == null ? void 0 : r.filter(
    (d) => d.node_id.toLowerCase().includes(t.toLowerCase())
  ), c = o || t.length > 0;
  return pz(e, t) ? /* @__PURE__ */ E.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ E.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: s,
        style: { cursor: "pointer" },
        title: e.description,
        children: [
          /* @__PURE__ */ E.jsx("div", { className: "shelftitle_text", children: e.name }),
          /* @__PURE__ */ E.jsx("div", { className: "expandicon " + (c ? "open" : "close"), children: /* @__PURE__ */ E.jsx(yf, {}) })
        ]
      }
    ),
    /* @__PURE__ */ E.jsx("div", { className: "libnodecontainer " + (c ? "open" : "close"), children: /* @__PURE__ */ E.jsxs("div", { className: "libnodecontainer_inner", children: [
      u && /* @__PURE__ */ E.jsx(E.Fragment, { children: u.map((d) => /* @__PURE__ */ E.jsx(fz, { item: d }, d.node_id)) }),
      e.subshelves && /* @__PURE__ */ E.jsx(E.Fragment, { children: e.subshelves.map((d) => /* @__PURE__ */ E.jsx(
        $0,
        {
          item: d,
          filter: t,
          parentkey: n + d.name
        },
        n + d.name
      )) })
    ] }) }),
    /* @__PURE__ */ E.jsx("hr", {})
  ] }) : /* @__PURE__ */ E.jsx(E.Fragment, {});
}, boe = ({
  filter: e,
  setFilter: t
}) => /* @__PURE__ */ E.jsxs("div", { className: "libfilter", children: [
  /* @__PURE__ */ E.jsx(uG, { fontSize: "inherit" }),
  /* @__PURE__ */ E.jsx(
    "input",
    {
      type: "text",
      placeholder: "Filter",
      value: e,
      onChange: (n) => {
        t(n.target.value);
      }
    }
  ),
  e && /* @__PURE__ */ E.jsx(
    UR,
    {
      fontSize: "inherit",
      onClick: () => {
        t("");
      }
    }
  )
] }), PA = [">=", "==", "<=", "<", ">"], xg = ">=", Y0 = ({
  availableModule: e
}) => /* @__PURE__ */ E.jsxs("div", { className: "module-links", children: [
  e.homepage && /* @__PURE__ */ E.jsx(E.Fragment, { children: /* @__PURE__ */ E.jsx(
    "a",
    {
      href: e.homepage,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Homepage"
    }
  ) }),
  e.source && e.homepage && " | ",
  e.source && /* @__PURE__ */ E.jsx(E.Fragment, { children: /* @__PURE__ */ E.jsx(
    "a",
    {
      href: e.source,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Source"
    }
  ) })
] }), q0 = ({
  availableModule: e
}) => {
  const [t, n] = S.useState(!1), r = () => n(!t), o = 150, i = e.description.length > o ? e.description.substring(0, o) + "..." : e.description;
  return /* @__PURE__ */ E.jsxs("div", { className: "module-description", children: [
    /* @__PURE__ */ E.jsx(ine, { remarkPlugins: [voe], children: t ? e.description.replace(/\\n/g, `  
`) : i.replace(/\\n/g, `  
`) }),
    e.description.length > o && /* @__PURE__ */ E.jsx("button", { onClick: r, className: "toggle-description", children: t ? "Show less" : "Show more" })
  ] });
}, X0 = ({
  availableModule: e,
  on_change: t
}) => {
  const [n, r] = S.useState(
    e.version || "latest"
  ), [o, i] = S.useState(xg), s = (c) => {
    const d = c.target.value;
    r(d), t(d !== "latest" ? o + d : d);
  }, u = (c) => {
    c.target.value !== o && PA.includes(c.target.value) && (i(c.target.value), n !== "latest" && t(c.target.value + n));
  };
  return e.releases && !e.releases.includes(n) && e.releases.unshift(n), /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx("select", { value: o, onChange: u, children: PA.map((c) => /* @__PURE__ */ E.jsx("option", { value: c, children: c }, c)) }),
    /* @__PURE__ */ E.jsx("select", { onChange: s, value: n, children: e.releases && e.releases.map((c) => /* @__PURE__ */ E.jsx("option", { value: c, children: c }, c)) })
  ] });
}, woe = ({
  availableModule: e,
  on_remove: t,
  on_update: n
}) => {
  const [r, o] = S.useState(
    xg + e.version || "latest"
  );
  return /* @__PURE__ */ E.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ E.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
    /* @__PURE__ */ E.jsx(Y0, { availableModule: e }),
    /* @__PURE__ */ E.jsx(q0, { availableModule: e }),
    /* @__PURE__ */ E.jsxs("div", { children: [
      /* @__PURE__ */ E.jsx(
        X0,
        {
          availableModule: e,
          on_change: o
        }
      ),
      /* @__PURE__ */ E.jsx(
        "button",
        {
          className: "update-button",
          disabled: r === e.version,
          onClick: () => {
            n(e, r);
          },
          children: "Update"
        }
      ),
      /* @__PURE__ */ E.jsx(
        "button",
        {
          className: "remove-button",
          onClick: () => {
            t(e);
          },
          children: "Remove"
        }
      )
    ] })
  ] });
}, xoe = ({
  availableModule: e,
  on_add: t
}) => {
  const [n, r] = S.useState(
    xg + e.version || "latest"
  );
  return /* @__PURE__ */ E.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ E.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
    /* @__PURE__ */ E.jsx(Y0, { availableModule: e }),
    /* @__PURE__ */ E.jsx(q0, { availableModule: e }),
    /* @__PURE__ */ E.jsxs("div", { children: [
      /* @__PURE__ */ E.jsx(
        X0,
        {
          availableModule: e,
          on_change: r
        }
      ),
      /* @__PURE__ */ E.jsx(
        "button",
        {
          className: "add-button",
          onClick: () => {
            t(e, n);
          },
          children: "Add"
        }
      )
    ] })
  ] });
}, Soe = ({
  availableModule: e,
  on_add: t
}) => {
  const [n, r] = S.useState(
    xg + e.version || "latest"
  );
  return /* @__PURE__ */ E.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ E.jsx("div", { className: "module-name", children: e.name }),
    /* @__PURE__ */ E.jsx(Y0, { availableModule: e }),
    /* @__PURE__ */ E.jsx(q0, { availableModule: e }),
    /* @__PURE__ */ E.jsxs("div", { children: [
      /* @__PURE__ */ E.jsx(
        X0,
        {
          availableModule: e,
          on_change: r
        }
      ),
      /* @__PURE__ */ E.jsx(
        "button",
        {
          className: "add-button",
          onClick: () => {
            t(e, n);
          },
          children: "Add"
        }
      )
    ] })
  ] });
}, _oe = ({ children: e }) => {
  const [t, n] = S.useState(""), r = S.useContext(it), [o, i] = S.useState(!0), [s, u] = S.useState(!0), [c, d] = S.useState(!0), [p, h] = S.useState({
    installed: [],
    available: [],
    active: []
  }), [g, y] = S.useState(!1), b = (j) => {
    j && (r.worker === void 0 || !r.worker.is_open || r.worker.get_available_modules().then((I) => {
      h(I);
    }));
  };
  if (!r.worker)
    return /* @__PURE__ */ E.jsx(E.Fragment, {});
  const v = (j, I) => {
    y(!1), r.worker !== void 0 && r.worker.add_lib(j.name, I);
  }, x = (j, I) => {
    y(!1), r.worker !== void 0 && r.worker.add_lib(j.name, I);
  }, _ = (j) => {
    y(!1), r.worker !== void 0 && r.worker.remove_lib(j.name);
  }, O = (j, I) => {
    y(!1), r.worker !== void 0 && r.worker.add_lib(j.name, I);
  }, C = (j) => j.filter(
    (I) => I.name.toLowerCase().includes(t.toLowerCase()) || I.description.toLowerCase().includes(t.toLowerCase())
  ), N = C(p.available), R = C(p.installed), z = C(p.active);
  return /* @__PURE__ */ E.jsxs(
    $u,
    {
      title: "Manage Library",
      trigger: e,
      description: "Add or remove libraries to the current worker.",
      onOpenChange: b,
      open: g,
      setOpen: y,
      children: [
        /* @__PURE__ */ E.jsx(
          "input",
          {
            className: "filter-input styledinput",
            type: "text",
            placeholder: "Filter modules...",
            value: t,
            onChange: (j) => n(j.target.value)
          }
        ),
        /* @__PURE__ */ E.jsxs(
          "div",
          {
            className: "packagelist",
            style: { maxHeight: "70%", overflow: "auto" },
            children: [
              R.length > 0 && /* @__PURE__ */ E.jsx(
                "h3",
                {
                  onClick: () => {
                    d(!c);
                  },
                  children: "Installed"
                }
              ),
              c && R.map((j) => /* @__PURE__ */ E.jsx(
                xoe,
                {
                  availableModule: j,
                  on_add: v
                },
                j.name + j.source
              )),
              N.length > 0 && /* @__PURE__ */ E.jsx(
                "h3",
                {
                  onClick: () => {
                    u(!s);
                  },
                  children: "Available"
                }
              ),
              s && N.map((j) => /* @__PURE__ */ E.jsx(
                Soe,
                {
                  availableModule: j,
                  on_add: x
                },
                j.name + j.source
              )),
              z.length > 0 && /* @__PURE__ */ E.jsx(
                "h3",
                {
                  onClick: () => {
                    i(!o);
                  },
                  children: "Active"
                }
              ),
              o && z.map((j) => /* @__PURE__ */ E.jsx(
                woe,
                {
                  availableModule: j,
                  on_remove: _,
                  on_update: O
                },
                j.name + j.source
              ))
            ]
          }
        )
      ]
    }
  );
}, koe = ({
  ins: e
}) => {
  const [t, n] = S.useState(e.name), r = S.useContext(it), o = () => {
    r.worker && r.worker.remove_external_worker(e.uuid, e.nodeclassid);
  }, i = () => {
    r.worker && (r.worker.update_external_worker(e.uuid, e.nodeclassid, {
      name: t
    }), e.name = t);
  };
  return /* @__PURE__ */ E.jsx(E.Fragment, { children: /* @__PURE__ */ E.jsx(
    $u,
    {
      title: e.name,
      description: "Settings for" + e.name,
      trigger: /* @__PURE__ */ E.jsx("div", { children: "Settings" }),
      buttons: [
        {
          text: "Save",
          onClick: i,
          close: !0
        },
        {
          text: "Delete",
          onClick: o,
          close: !0
        }
      ],
      children: /* @__PURE__ */ E.jsx("div", { children: /* @__PURE__ */ E.jsxs("div", { children: [
        /* @__PURE__ */ E.jsx("label", { htmlFor: "name", children: "Name: " }),
        /* @__PURE__ */ E.jsx(
          "input",
          {
            type: "text",
            name: "name",
            value: t,
            onChange: (s) => n(s.target.value),
            className: "styledinput"
          }
        )
      ] }) })
    }
  ) });
}, Eoe = ({
  ins: e,
  lib: t,
  filter: n = "",
  parentkey: r
}) => {
  var o;
  const [i, s] = S.useState(!1), u = () => s(!i), c = (o = t?.nodes) == null ? void 0 : o.filter(
    (d) => d.node_id.toLowerCase().includes(n.toLowerCase())
  );
  return /* @__PURE__ */ E.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ E.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: u,
        style: { cursor: "pointer" },
        title: e.name,
        children: [
          /* @__PURE__ */ E.jsx("div", { className: "shelftitle_text", children: e.name }),
          /* @__PURE__ */ E.jsx("div", { className: "expandicon " + (i ? "open" : "close"), children: /* @__PURE__ */ E.jsx(yf, {}) })
        ]
      }
    ),
    /* @__PURE__ */ E.jsx("div", { className: "libnodecontainer " + (i ? "open" : "close"), children: /* @__PURE__ */ E.jsx("div", { className: "libnodecontainer_inner", children: i && /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx("div", { className: "libnodeentry", title: e.uuid, children: /* @__PURE__ */ E.jsx(koe, { ins: e }) }),
      t && /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
        c && /* @__PURE__ */ E.jsx(E.Fragment, { children: c.map((d) => /* @__PURE__ */ E.jsx(
          fz,
          {
            item: d
          },
          r + d.node_id
        )) }),
        t.subshelves.map((d) => /* @__PURE__ */ E.jsx(
          $0,
          {
            item: d,
            filter: n,
            parentkey: r + d.name
          },
          r + d.name
        ))
      ] })
    ] }) }) })
  ] });
}, Coe = ({
  item: e,
  mod: t,
  lib: n
}) => {
  const r = S.useContext(it), [o, i] = S.useState(!1), s = () => i(!o), u = () => {
    var p;
    (p = r.worker) == null || p.add_external_worker({
      module: t,
      cls_module: e.module,
      cls_name: e.class_name
    });
  }, c = (p) => {
    p.detail === 2 && u();
  }, d = e.name || e.module + "." + e.class_name;
  return /* @__PURE__ */ E.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ E.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: s,
        style: { cursor: "pointer" },
        title: d,
        children: [
          /* @__PURE__ */ E.jsx("div", { className: "shelftitle_text", children: d }),
          /* @__PURE__ */ E.jsx("div", { className: "expandicon " + (o ? "open" : "close"), children: /* @__PURE__ */ E.jsx(yf, {}) })
        ]
      }
    ),
    /* @__PURE__ */ E.jsx("div", { className: "libnodecontainer " + (o ? "open" : "close"), children: /* @__PURE__ */ E.jsx("div", { className: "libnodecontainer_inner", children: o && /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(
        "div",
        {
          className: "libnodeentry",
          onClick: c,
          title: e.name,
          children: "New Instance"
        }
      ),
      e.instances.map((p) => /* @__PURE__ */ E.jsx(
        Eoe,
        {
          ins: p,
          lib: n?.subshelves.find(
            (h) => h.name === p.uuid
          ),
          parentkey: p.uuid
        },
        p.uuid
      ))
    ] }) }) })
  ] });
}, Ooe = ({
  externalworkermod: e,
  lib: t
}) => {
  const [n, r] = S.useState(!1), o = () => r(!n), i = n;
  return /* @__PURE__ */ E.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ E.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: o,
        style: { cursor: "pointer" },
        title: e.module,
        children: [
          /* @__PURE__ */ E.jsx("div", { className: "shelftitle_text", children: e.module }),
          /* @__PURE__ */ E.jsx("div", { className: "expandicon " + (i ? "open" : "close"), children: /* @__PURE__ */ E.jsx(yf, {}) })
        ]
      }
    ),
    /* @__PURE__ */ E.jsx("div", { className: "libnodecontainer " + (i ? "open" : "close"), children: /* @__PURE__ */ E.jsx("div", { className: "libnodecontainer_inner", children: e.worker_classes.map((s) => /* @__PURE__ */ E.jsx(
      Coe,
      {
        item: s,
        mod: e.module,
        lib: t
      },
      s.module + s.class_name
    )) }) }),
    /* @__PURE__ */ E.jsx("hr", {})
  ] });
}, Aoe = () => {
  var e, t;
  const n = S.useContext(it), r = n.lib.libstate(), o = S.useContext(it), i = o.local_settings(
    (g) => g.view_settings.expand_lib
  ), s = o.local_settings(
    (g) => g.update_view_settings
  ), u = (g) => {
    s({ expand_lib: g });
  }, c = UK("m"), [d, p] = S.useState(""), h = ((e = n.worker) == null ? void 0 : e.state((g) => g.is_open)) ?? !1;
  return /* @__PURE__ */ E.jsx(
    a6,
    {
      maxSize: c ? "100%" : "18.75rem",
      direction: c ? "down" : "right",
      containerClassName: "pos-left pos-top bg1 h-12",
      onExpandChange: u,
      expanded: i === void 0 ? !0 : i,
      children: /* @__PURE__ */ E.jsxs("div", { className: "libcontainer", children: [
        /* @__PURE__ */ E.jsxs("div", { className: "library", children: [
          /* @__PURE__ */ E.jsx("div", { className: "libtitle", children: "Lib" }),
          /* @__PURE__ */ E.jsx("hr", { className: "hr_prominent" }),
          /* @__PURE__ */ E.jsx(boe, { filter: d, setFilter: p }),
          /* @__PURE__ */ E.jsx("div", { className: "vscrollcontainer", children: r.lib.shelves.filter((g) => g.name !== "_external_worker").map((g) => /* @__PURE__ */ E.jsx(
            $0,
            {
              item: g,
              filter: d,
              parentkey: g.name
            },
            g.name
          )) }),
          /* @__PURE__ */ E.jsx("hr", {}),
          /* @__PURE__ */ E.jsx("div", { className: "libtitle", children: "External Worker" }),
          /* @__PURE__ */ E.jsx("hr", { className: "hr_prominent" }),
          /* @__PURE__ */ E.jsx("div", { className: "vscrollcontainer", children: (t = r.external_worker) == null ? void 0 : t.map((g) => /* @__PURE__ */ E.jsx(
            Ooe,
            {
              externalworkermod: g,
              lib: r.lib.shelves.find(
                (y) => y.name === "_external_worker"
              )
            },
            g.module
          )) }),
          /* @__PURE__ */ E.jsx("hr", {})
        ] }),
        /* @__PURE__ */ E.jsx("div", { style: { paddingTop: "0.5rem" } }),
        h && /* @__PURE__ */ E.jsx("div", { className: "addlib", children: /* @__PURE__ */ E.jsx(_oe, { children: /* @__PURE__ */ E.jsx("button", { children: "Manage Libraries" }) }) })
      ] })
    }
  );
};
function Noe(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1;
    for (const [r, o] of e)
      if (!Object.is(o, t.get(r)))
        return !1;
    return !0;
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1;
    for (const r of e)
      if (!t.has(r))
        return !1;
    return !0;
  }
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !1;
  for (const r of n)
    if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
      return !1;
  return !0;
}
const { useRef: Moe } = Qe;
function Roe(e) {
  const t = Moe();
  return (n) => {
    const r = e(n);
    return Noe(t.current, r) ? t.current : t.current = r;
  };
}
var W0 = "Popover", [hz, Fve] = us(W0, [
  pg
]), Ef = pg(), [joe, ds] = hz(W0), mz = (e) => {
  const {
    __scopePopover: t,
    children: n,
    open: r,
    defaultOpen: o,
    onOpenChange: i,
    modal: s = !1
  } = e, u = Ef(t), c = S.useRef(null), [d, p] = S.useState(!1), [h = !1, g] = Uu({
    prop: r,
    defaultProp: o,
    onChange: i
  });
  return /* @__PURE__ */ E.jsx(g0, { ...u, children: /* @__PURE__ */ E.jsx(
    joe,
    {
      scope: t,
      contentId: qi(),
      triggerRef: c,
      open: h,
      onOpenChange: g,
      onOpenToggle: S.useCallback(() => g((y) => !y), [g]),
      hasCustomAnchor: d,
      onCustomAnchorAdd: S.useCallback(() => p(!0), []),
      onCustomAnchorRemove: S.useCallback(() => p(!1), []),
      modal: s,
      children: n
    }
  ) });
};
mz.displayName = W0;
var gz = "PopoverAnchor", zoe = S.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = ds(gz, n), i = Ef(n), { onCustomAnchorAdd: s, onCustomAnchorRemove: u } = o;
    return S.useEffect(() => (s(), () => u()), [s, u]), /* @__PURE__ */ E.jsx(y0, { ...i, ...r, ref: t });
  }
);
zoe.displayName = gz;
var yz = "PopoverTrigger", vz = S.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = ds(yz, n), i = Ef(n), s = Ut(t, o.triggerRef), u = /* @__PURE__ */ E.jsx(
      zt.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": o.open,
        "aria-controls": o.contentId,
        "data-state": kz(o.open),
        ...r,
        ref: s,
        onClick: Ue(e.onClick, o.onOpenToggle)
      }
    );
    return o.hasCustomAnchor ? u : /* @__PURE__ */ E.jsx(y0, { asChild: !0, ...i, children: u });
  }
);
vz.displayName = yz;
var G0 = "PopoverPortal", [Toe, Doe] = hz(G0, {
  forceMount: void 0
}), bz = (e) => {
  const { __scopePopover: t, forceMount: n, children: r, container: o } = e, i = ds(G0, t);
  return /* @__PURE__ */ E.jsx(Toe, { scope: t, forceMount: n, children: /* @__PURE__ */ E.jsx(oa, { present: n || i.open, children: /* @__PURE__ */ E.jsx(BS, { asChild: !0, container: o, children: r }) }) });
};
bz.displayName = G0;
var Pu = "PopoverContent", wz = S.forwardRef(
  (e, t) => {
    const n = Doe(Pu, e.__scopePopover), { forceMount: r = n.forceMount, ...o } = e, i = ds(Pu, e.__scopePopover);
    return /* @__PURE__ */ E.jsx(oa, { present: r || i.open, children: i.modal ? /* @__PURE__ */ E.jsx(Loe, { ...o, ref: t }) : /* @__PURE__ */ E.jsx(Ioe, { ...o, ref: t }) });
  }
);
wz.displayName = Pu;
var Poe = /* @__PURE__ */ ju("PopoverContent.RemoveScroll"), Loe = S.forwardRef(
  (e, t) => {
    const n = ds(Pu, e.__scopePopover), r = S.useRef(null), o = Ut(t, r), i = S.useRef(!1);
    return S.useEffect(() => {
      const s = r.current;
      if (s) return US(s);
    }, []), /* @__PURE__ */ E.jsx(og, { as: Poe, allowPinchZoom: !0, children: /* @__PURE__ */ E.jsx(
      xz,
      {
        ...e,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Ue(e.onCloseAutoFocus, (s) => {
          var u;
          s.preventDefault(), i.current || (u = n.triggerRef.current) == null || u.focus();
        }),
        onPointerDownOutside: Ue(
          e.onPointerDownOutside,
          (s) => {
            const u = s.detail.originalEvent, c = u.button === 0 && u.ctrlKey === !0, d = u.button === 2 || c;
            i.current = d;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: Ue(
          e.onFocusOutside,
          (s) => s.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), Ioe = S.forwardRef(
  (e, t) => {
    const n = ds(Pu, e.__scopePopover), r = S.useRef(!1), o = S.useRef(!1);
    return /* @__PURE__ */ E.jsx(
      xz,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (i) => {
          var s, u;
          (s = e.onCloseAutoFocus) == null || s.call(e, i), i.defaultPrevented || (r.current || (u = n.triggerRef.current) == null || u.focus(), i.preventDefault()), r.current = !1, o.current = !1;
        },
        onInteractOutside: (i) => {
          var s, u;
          (s = e.onInteractOutside) == null || s.call(e, i), i.defaultPrevented || (r.current = !0, i.detail.originalEvent.type === "pointerdown" && (o.current = !0));
          const c = i.target;
          (u = n.triggerRef.current) != null && u.contains(c) && i.preventDefault(), i.detail.originalEvent.type === "focusin" && o.current && i.preventDefault();
        }
      }
    );
  }
), xz = S.forwardRef(
  (e, t) => {
    const {
      __scopePopover: n,
      trapFocus: r,
      onOpenAutoFocus: o,
      onCloseAutoFocus: i,
      disableOutsidePointerEvents: s,
      onEscapeKeyDown: u,
      onPointerDownOutside: c,
      onFocusOutside: d,
      onInteractOutside: p,
      ...h
    } = e, g = ds(Pu, n), y = Ef(n);
    return FS(), /* @__PURE__ */ E.jsx(
      ng,
      {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: o,
        onUnmountAutoFocus: i,
        children: /* @__PURE__ */ E.jsx(
          tg,
          {
            asChild: !0,
            disableOutsidePointerEvents: s,
            onInteractOutside: p,
            onEscapeKeyDown: u,
            onPointerDownOutside: c,
            onFocusOutside: d,
            onDismiss: () => g.onOpenChange(!1),
            children: /* @__PURE__ */ E.jsx(
              dj,
              {
                "data-state": kz(g.open),
                role: "dialog",
                id: g.contentId,
                ...y,
                ...h,
                ref: t,
                style: {
                  ...h.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), Sz = "PopoverClose", Voe = S.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = ds(Sz, n);
    return /* @__PURE__ */ E.jsx(
      zt.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Ue(e.onClick, () => o.onOpenChange(!1))
      }
    );
  }
);
Voe.displayName = Sz;
var Boe = "PopoverArrow", _z = S.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = Ef(n);
    return /* @__PURE__ */ E.jsx(fj, { ...o, ...r, ref: t });
  }
);
_z.displayName = Boe;
function kz(e) {
  return e ? "open" : "closed";
}
var Ez = mz, Cz = vz, Oz = bz, Az = wz, Foe = _z;
const Uoe = ({
  iostore: e
}) => {
  const { full: t, preview: n } = e.valuestore(), r = JSON.stringify(t?.value || n?.value) || "";
  return `Bytes(${Math.round(3 * r.length / 4)})`;
}, Hoe = {
  bytes: Uoe
}, $oe = (e) => typeof e == "boolean" || e instanceof Boolean, Yoe = (e) => typeof e == "number" || e instanceof Number, qoe = (e) => typeof e == "bigint" || e instanceof BigInt, Nz = (e) => !!e && e instanceof Date, Xoe = (e) => typeof e == "string" || e instanceof String, Woe = (e) => Array.isArray(e), Goe = (e) => typeof e == "object" && e !== null, Mz = (e) => !!e && e instanceof Object && typeof e == "function";
function ym(e, t) {
  return t === void 0 && (t = !1), !e || t ? `"${e}"` : e;
}
function Zoe(e, t, n) {
  return n ? JSON.stringify(e) : t ? `"${e}"` : e;
}
function Rz(e) {
  let {
    field: t,
    value: n,
    data: r,
    lastElement: o,
    openBracket: i,
    closeBracket: s,
    level: u,
    style: c,
    shouldExpandNode: d,
    clickToExpandNode: p,
    outerRef: h,
    beforeExpandChange: g
  } = e;
  const y = S.useRef(!1), [b, v] = S.useState(() => d(u, n, t)), x = S.useRef(null);
  S.useEffect(() => {
    y.current ? v(d(u, n, t)) : y.current = !0;
  }, [d]);
  const _ = S.useId();
  if (r.length === 0)
    return Koe({
      field: t,
      openBracket: i,
      closeBracket: s,
      lastElement: o,
      style: c
    });
  const O = b ? c.collapseIcon : c.expandIcon, C = b ? c.ariaLables.collapseJson : c.ariaLables.expandJson, N = u + 1, R = r.length - 1, z = ($) => {
    b !== $ && (!g || g({
      level: u,
      value: n,
      field: t,
      newExpandValue: $
    })) && v($);
  }, j = ($) => {
    if ($.key === "ArrowRight" || $.key === "ArrowLeft")
      $.preventDefault(), z($.key === "ArrowRight");
    else if ($.key === "ArrowUp" || $.key === "ArrowDown") {
      $.preventDefault();
      const A = $.key === "ArrowUp" ? -1 : 1;
      if (!h.current) return;
      const V = h.current.querySelectorAll("[role=button]");
      let U = -1;
      for (let D = 0; D < V.length; D++)
        if (V[D].tabIndex === 0) {
          U = D;
          break;
        }
      if (U < 0)
        return;
      const W = (U + A + V.length) % V.length;
      V[U].tabIndex = -1, V[W].tabIndex = 0, V[W].focus();
    }
  }, I = () => {
    var $;
    z(!b);
    const A = x.current;
    if (!A) return;
    const V = ($ = h.current) === null || $ === void 0 ? void 0 : $.querySelector('[role=button][tabindex="0"]');
    V && (V.tabIndex = -1), A.tabIndex = 0, A.focus();
  };
  return /* @__PURE__ */ S.createElement("div", {
    className: c.basicChildStyle,
    role: "treeitem",
    "aria-expanded": b,
    "aria-selected": void 0
  }, /* @__PURE__ */ S.createElement("span", {
    className: O,
    onClick: I,
    onKeyDown: j,
    role: "button",
    "aria-label": C,
    "aria-expanded": b,
    "aria-controls": b ? _ : void 0,
    ref: x,
    tabIndex: u === 0 ? 0 : -1
  }), (t || t === "") && (p ? /* @__PURE__ */ S.createElement("span", {
    className: c.clickableLabel,
    onClick: I,
    onKeyDown: j
  }, ym(t, c.quotesForFieldNames), ":") : /* @__PURE__ */ S.createElement("span", {
    className: c.label
  }, ym(t, c.quotesForFieldNames), ":")), /* @__PURE__ */ S.createElement("span", {
    className: c.punctuation
  }, i), b ? /* @__PURE__ */ S.createElement("ul", {
    id: _,
    role: "group",
    className: c.childFieldsContainer
  }, r.map(($, A) => /* @__PURE__ */ S.createElement(jz, {
    key: $[0] || A,
    field: $[0],
    value: $[1],
    style: c,
    lastElement: A === R,
    level: N,
    shouldExpandNode: d,
    clickToExpandNode: p,
    outerRef: h
  }))) : /* @__PURE__ */ S.createElement("span", {
    className: c.collapsedContent,
    onClick: I,
    onKeyDown: j
  }), /* @__PURE__ */ S.createElement("span", {
    className: c.punctuation
  }, s), !o && /* @__PURE__ */ S.createElement("span", {
    className: c.punctuation
  }, ","));
}
function Koe(e) {
  let {
    field: t,
    openBracket: n,
    closeBracket: r,
    lastElement: o,
    style: i
  } = e;
  return /* @__PURE__ */ S.createElement("div", {
    className: i.basicChildStyle,
    role: "treeitem",
    "aria-selected": void 0
  }, (t || t === "") && /* @__PURE__ */ S.createElement("span", {
    className: i.label
  }, ym(t, i.quotesForFieldNames), ":"), /* @__PURE__ */ S.createElement("span", {
    className: i.punctuation
  }, n), /* @__PURE__ */ S.createElement("span", {
    className: i.punctuation
  }, r), !o && /* @__PURE__ */ S.createElement("span", {
    className: i.punctuation
  }, ","));
}
function Qoe(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: o,
    shouldExpandNode: i,
    clickToExpandNode: s,
    level: u,
    outerRef: c,
    beforeExpandChange: d
  } = e;
  return Rz({
    field: t,
    value: n,
    lastElement: o || !1,
    level: u,
    openBracket: "{",
    closeBracket: "}",
    style: r,
    shouldExpandNode: i,
    clickToExpandNode: s,
    data: Object.keys(n).map((p) => [p, n[p]]),
    outerRef: c,
    beforeExpandChange: d
  });
}
function Joe(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: o,
    level: i,
    shouldExpandNode: s,
    clickToExpandNode: u,
    outerRef: c,
    beforeExpandChange: d
  } = e;
  return Rz({
    field: t,
    value: n,
    lastElement: o || !1,
    level: i,
    openBracket: "[",
    closeBracket: "]",
    style: r,
    shouldExpandNode: s,
    clickToExpandNode: u,
    data: n.map((p) => [void 0, p]),
    outerRef: c,
    beforeExpandChange: d
  });
}
function eie(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: o
  } = e, i, s = r.otherValue;
  return n === null ? (i = "null", s = r.nullValue) : n === void 0 ? (i = "undefined", s = r.undefinedValue) : Xoe(n) ? (i = Zoe(n, !r.noQuotesForStringValues, r.stringifyStringValues), s = r.stringValue) : $oe(n) ? (i = n ? "true" : "false", s = r.booleanValue) : Yoe(n) ? (i = n.toString(), s = r.numberValue) : qoe(n) ? (i = `${n.toString()}n`, s = r.numberValue) : Nz(n) ? i = n.toISOString() : Mz(n) ? i = "function() { }" : i = n.toString(), /* @__PURE__ */ S.createElement("div", {
    className: r.basicChildStyle,
    role: "treeitem",
    "aria-selected": void 0
  }, (t || t === "") && /* @__PURE__ */ S.createElement("span", {
    className: r.label
  }, ym(t, r.quotesForFieldNames), ":"), /* @__PURE__ */ S.createElement("span", {
    className: s
  }, i), !o && /* @__PURE__ */ S.createElement("span", {
    className: r.punctuation
  }, ","));
}
function jz(e) {
  const t = e.value;
  return Woe(t) ? /* @__PURE__ */ S.createElement(Joe, Object.assign({}, e)) : Goe(t) && !Nz(t) && !Mz(t) ? /* @__PURE__ */ S.createElement(Qoe, Object.assign({}, e)) : /* @__PURE__ */ S.createElement(eie, Object.assign({}, e));
}
var vt = { "container-light": "_2IvMF _GzYRV", "basic-element-style": "_2bkNM", "child-fields-container": "_1BXBN", "label-light": "_1MGIk", "clickable-label-light": "_2YKJg _1MGIk _1MFti", "punctuation-light": "_3uHL6 _3eOF8", "value-null-light": "_2T6PJ", "value-undefined-light": "_1Gho6", "value-string-light": "_vGjyY", "value-number-light": "_1bQdo", "value-boolean-light": "_3zQKs", "value-other-light": "_1xvuR", "collapse-icon-light": "_oLqym _f10Tu _1MFti _1LId0", "expand-icon-light": "_2AXVT _f10Tu _1MFti _1UmXx", "collapsed-content-light": "_2KJWg _1pNG9 _1MFti", "container-dark": "_11RoI _GzYRV", "expand-icon-dark": "_17H2C _f10Tu _1MFti _1UmXx", "collapse-icon-dark": "_3QHg2 _f10Tu _1MFti _1LId0", "collapsed-content-dark": "_3fDAz _1pNG9 _1MFti", "label-dark": "_2bSDX", "clickable-label-dark": "_1RQEj _2bSDX _1MFti", "punctuation-dark": "_gsbQL _3eOF8", "value-null-dark": "_LaAZe", "value-undefined-dark": "_GTKgm", "value-string-dark": "_Chy1W", "value-number-dark": "_2bveF", "value-boolean-dark": "_2vRm-", "value-other-dark": "_1prJR" };
const zz = {
  collapseJson: "collapse JSON",
  expandJson: "expand JSON"
}, LA = {
  container: vt["container-light"],
  basicChildStyle: vt["basic-element-style"],
  childFieldsContainer: vt["child-fields-container"],
  label: vt["label-light"],
  clickableLabel: vt["clickable-label-light"],
  nullValue: vt["value-null-light"],
  undefinedValue: vt["value-undefined-light"],
  stringValue: vt["value-string-light"],
  booleanValue: vt["value-boolean-light"],
  numberValue: vt["value-number-light"],
  otherValue: vt["value-other-light"],
  punctuation: vt["punctuation-light"],
  collapseIcon: vt["collapse-icon-light"],
  expandIcon: vt["expand-icon-light"],
  collapsedContent: vt["collapsed-content-light"],
  noQuotesForStringValues: !1,
  quotesForFieldNames: !1,
  ariaLables: zz,
  stringifyStringValues: !1
}, tie = {
  container: vt["container-dark"],
  basicChildStyle: vt["basic-element-style"],
  childFieldsContainer: vt["child-fields-container"],
  label: vt["label-dark"],
  clickableLabel: vt["clickable-label-dark"],
  nullValue: vt["value-null-dark"],
  undefinedValue: vt["value-undefined-dark"],
  stringValue: vt["value-string-dark"],
  booleanValue: vt["value-boolean-dark"],
  numberValue: vt["value-number-dark"],
  otherValue: vt["value-other-dark"],
  punctuation: vt["punctuation-dark"],
  collapseIcon: vt["collapse-icon-dark"],
  expandIcon: vt["expand-icon-dark"],
  collapsedContent: vt["collapsed-content-dark"],
  noQuotesForStringValues: !1,
  quotesForFieldNames: !1,
  ariaLables: zz,
  stringifyStringValues: !1
}, nie = () => !0, rie = (e) => e < 1, oie = (e) => {
  let {
    data: t,
    style: n = LA,
    shouldExpandNode: r = nie,
    clickToExpandNode: o = !1,
    beforeExpandChange: i,
    ...s
  } = e;
  const u = S.useRef(null);
  return /* @__PURE__ */ S.createElement("div", Object.assign({
    "aria-label": "JSON view"
  }, s, {
    className: n.container,
    ref: u,
    role: "tree"
  }), /* @__PURE__ */ S.createElement(jz, {
    value: t,
    style: {
      ...LA,
      ...n
    },
    lastElement: !0,
    level: 0,
    shouldExpandNode: r,
    clickToExpandNode: o,
    outerRef: u,
    beforeExpandChange: i
  }));
};
function iie(e) {
  for (const t in e)
    if (Object.hasOwn(e, t))
      return !1;
  return !0;
}
function aie(e) {
  if (e == null || typeof e != "object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t !== null && t !== Object.prototype ? !1 : iie(e);
}
const sie = ({ data: e }) => /* @__PURE__ */ E.jsx(
  oie,
  {
    data: aie(e) ? "" : e,
    style: tie,
    shouldExpandNode: rie
  }
);
function Tz(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (n = Tz(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function pn() {
  for (var e, t, n = 0, r = "", o = arguments.length; n < o; n++) (e = arguments[n]) && (t = Tz(e)) && (r && (r += " "), r += t);
  return r;
}
function sa(e, t, n = void 0) {
  const r = {};
  for (const o in e) {
    const i = e[o];
    let s = "", u = !0;
    for (let c = 0; c < i.length; c += 1) {
      const d = i[c];
      d && (s += (u === !0 ? "" : " ") + t(d), u = !1, n && n[d] && (s += " " + n[d]));
    }
    r[o] = s;
  }
  return r;
}
const Dz = /* @__PURE__ */ S.createContext();
function ol(e, ...t) {
  const n = new URL(`https://mui.com/production-error/?code=${e}`);
  return t.forEach((r) => n.searchParams.append("args[]", r)), `Minified MUI error #${e}; visit ${n} for the full message.`;
}
function tr(e) {
  if (typeof e != "string")
    throw new Error(ol(7));
  return e.charAt(0).toUpperCase() + e.slice(1);
}
var IA = { exports: {} }, Ct = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var VA;
function lie() {
  if (VA) return Ct;
  VA = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), i = Symbol.for("react.consumer"), s = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), g = Symbol.for("react.view_transition"), y = Symbol.for("react.client.reference");
  function b(v) {
    if (typeof v == "object" && v !== null) {
      var x = v.$$typeof;
      switch (x) {
        case e:
          switch (v = v.type, v) {
            case n:
            case o:
            case r:
            case c:
            case d:
            case g:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case u:
                case h:
                case p:
                  return v;
                case i:
                  return v;
                default:
                  return x;
              }
          }
        case t:
          return x;
      }
    }
  }
  return Ct.ContextConsumer = i, Ct.ContextProvider = s, Ct.Element = e, Ct.ForwardRef = u, Ct.Fragment = n, Ct.Lazy = h, Ct.Memo = p, Ct.Portal = t, Ct.Profiler = o, Ct.StrictMode = r, Ct.Suspense = c, Ct.SuspenseList = d, Ct.isContextConsumer = function(v) {
    return b(v) === i;
  }, Ct.isContextProvider = function(v) {
    return b(v) === s;
  }, Ct.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === e;
  }, Ct.isForwardRef = function(v) {
    return b(v) === u;
  }, Ct.isFragment = function(v) {
    return b(v) === n;
  }, Ct.isLazy = function(v) {
    return b(v) === h;
  }, Ct.isMemo = function(v) {
    return b(v) === p;
  }, Ct.isPortal = function(v) {
    return b(v) === t;
  }, Ct.isProfiler = function(v) {
    return b(v) === o;
  }, Ct.isStrictMode = function(v) {
    return b(v) === r;
  }, Ct.isSuspense = function(v) {
    return b(v) === c;
  }, Ct.isSuspenseList = function(v) {
    return b(v) === d;
  }, Ct.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === n || v === o || v === r || v === c || v === d || typeof v == "object" && v !== null && (v.$$typeof === h || v.$$typeof === p || v.$$typeof === s || v.$$typeof === i || v.$$typeof === u || v.$$typeof === y || v.getModuleId !== void 0);
  }, Ct.typeOf = b, Ct;
}
var BA;
function uie() {
  return BA || (BA = 1, IA.exports = /* @__PURE__ */ lie()), IA.exports;
}
var Pz = /* @__PURE__ */ uie();
function Ui(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function Lz(e) {
  if (/* @__PURE__ */ S.isValidElement(e) || Pz.isValidElementType(e) || !Ui(e))
    return e;
  const t = {};
  return Object.keys(e).forEach((n) => {
    t[n] = Lz(e[n]);
  }), t;
}
function Fr(e, t, n = {
  clone: !0
}) {
  const r = n.clone ? {
    ...e
  } : e;
  return Ui(e) && Ui(t) && Object.keys(t).forEach((o) => {
    /* @__PURE__ */ S.isValidElement(t[o]) || Pz.isValidElementType(t[o]) ? r[o] = t[o] : Ui(t[o]) && // Avoid prototype pollution
    Object.prototype.hasOwnProperty.call(e, o) && Ui(e[o]) ? r[o] = Fr(e[o], t[o], n) : n.clone ? r[o] = Ui(t[o]) ? Lz(t[o]) : t[o] : r[o] = t[o];
  }), r;
}
function Sd(e, t) {
  return t ? Fr(e, t, {
    clone: !1
    // No need to clone deep, it's way faster.
  }) : e;
}
function cie(e, t) {
  if (!e.containerQueries)
    return t;
  const n = Object.keys(t).filter((r) => r.startsWith("@container")).sort((r, o) => {
    var i, s;
    const u = /min-width:\s*([0-9.]+)/;
    return +(((i = r.match(u)) == null ? void 0 : i[1]) || 0) - +(((s = o.match(u)) == null ? void 0 : s[1]) || 0);
  });
  return n.length ? n.reduce((r, o) => {
    const i = t[o];
    return delete r[o], r[o] = i, r;
  }, {
    ...t
  }) : t;
}
function die(e, t) {
  return t === "@" || t.startsWith("@") && (e.some((n) => t.startsWith(`@${n}`)) || !!t.match(/^@\d/));
}
function fie(e, t) {
  const n = t.match(/^@([^/]+)?\/?(.+)?$/);
  if (!n)
    return null;
  const [, r, o] = n, i = Number.isNaN(+r) ? r || 0 : +r;
  return e.containerQueries(o).up(i);
}
function pie(e) {
  const t = (i, s) => i.replace("@media", s ? `@container ${s}` : "@container");
  function n(i, s) {
    i.up = (...u) => t(e.breakpoints.up(...u), s), i.down = (...u) => t(e.breakpoints.down(...u), s), i.between = (...u) => t(e.breakpoints.between(...u), s), i.only = (...u) => t(e.breakpoints.only(...u), s), i.not = (...u) => {
      const c = t(e.breakpoints.not(...u), s);
      return c.includes("not all and") ? c.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or") : c;
    };
  }
  const r = {}, o = (i) => (n(r, i), r);
  return n(o), {
    ...e,
    containerQueries: o
  };
}
const Sg = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
}, FA = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (e) => `@media (min-width:${Sg[e]}px)`
}, hie = {
  containerQueries: (e) => ({
    up: (t) => {
      let n = typeof t == "number" ? t : Sg[t] || t;
      return typeof n == "number" && (n = `${n}px`), e ? `@container ${e} (min-width:${n})` : `@container (min-width:${n})`;
    }
  })
};
function ea(e, t, n) {
  const r = e.theme || {};
  if (Array.isArray(t)) {
    const o = r.breakpoints || FA;
    return t.reduce((i, s, u) => (i[o.up(o.keys[u])] = n(t[u]), i), {});
  }
  if (typeof t == "object") {
    const o = r.breakpoints || FA;
    return Object.keys(t).reduce((i, s) => {
      if (die(o.keys, s)) {
        const u = fie(r.containerQueries ? r : hie, s);
        u && (i[u] = n(t[s], s));
      } else if (Object.keys(o.values || Sg).includes(s)) {
        const u = o.up(s);
        i[u] = n(t[s], s);
      } else {
        const u = s;
        i[u] = t[u];
      }
      return i;
    }, {});
  }
  return n(t);
}
function mie(e = {}) {
  var t;
  return ((t = e.keys) == null ? void 0 : t.reduce((n, r) => {
    const o = e.up(r);
    return n[o] = {}, n;
  }, {})) || {};
}
function gie(e, t) {
  return e.reduce((n, r) => {
    const o = n[r];
    return (!o || Object.keys(o).length === 0) && delete n[r], n;
  }, t);
}
function _g(e, t, n = !0) {
  if (!t || typeof t != "string")
    return null;
  if (e && e.vars && n) {
    const r = `vars.${t}`.split(".").reduce((o, i) => o && o[i] ? o[i] : null, e);
    if (r != null)
      return r;
  }
  return t.split(".").reduce((r, o) => r && r[o] != null ? r[o] : null, e);
}
function vm(e, t, n, r = n) {
  let o;
  return typeof e == "function" ? o = e(n) : Array.isArray(e) ? o = e[n] || r : o = _g(e, n) || r, t && (o = t(o, r, e)), o;
}
function rn(e) {
  const {
    prop: t,
    cssProperty: n = e.prop,
    themeKey: r,
    transform: o
  } = e, i = (s) => {
    if (s[t] == null)
      return null;
    const u = s[t], c = s.theme, d = _g(c, r) || {};
    return ea(s, u, (p) => {
      let h = vm(d, o, p);
      return p === h && typeof p == "string" && (h = vm(d, o, `${t}${p === "default" ? "" : tr(p)}`, p)), n === !1 ? h : {
        [n]: h
      };
    });
  };
  return i.propTypes = {}, i.filterProps = [t], i;
}
function yie(e) {
  const t = {};
  return (n) => (t[n] === void 0 && (t[n] = e(n)), t[n]);
}
const vie = {
  m: "margin",
  p: "padding"
}, bie = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
}, UA = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
}, wie = yie((e) => {
  if (e.length > 2)
    if (UA[e])
      e = UA[e];
    else
      return [e];
  const [t, n] = e.split(""), r = vie[t], o = bie[n] || "";
  return Array.isArray(o) ? o.map((i) => r + i) : [r + o];
}), Z0 = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], K0 = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...Z0, ...K0];
function Cf(e, t, n, r) {
  const o = _g(e, t, !0) ?? n;
  return typeof o == "number" || typeof o == "string" ? (i) => typeof i == "string" ? i : typeof o == "string" ? o.startsWith("var(") && i === 0 ? 0 : o.startsWith("var(") && i === 1 ? o : `calc(${i} * ${o})` : o * i : Array.isArray(o) ? (i) => {
    if (typeof i == "string")
      return i;
    const s = Math.abs(i), u = o[s];
    return i >= 0 ? u : typeof u == "number" ? -u : typeof u == "string" && u.startsWith("var(") ? `calc(-1 * ${u})` : `-${u}`;
  } : typeof o == "function" ? o : () => {
  };
}
function Q0(e) {
  return Cf(e, "spacing", 8);
}
function Of(e, t) {
  return typeof t == "string" || t == null ? t : e(t);
}
function xie(e, t) {
  return (n) => e.reduce((r, o) => (r[o] = Of(t, n), r), {});
}
function Sie(e, t, n, r) {
  if (!t.includes(n))
    return null;
  const o = wie(n), i = xie(o, r), s = e[n];
  return ea(e, s, i);
}
function Iz(e, t) {
  const n = Q0(e.theme);
  return Object.keys(e).map((r) => Sie(e, t, r, n)).reduce(Sd, {});
}
function Kt(e) {
  return Iz(e, Z0);
}
Kt.propTypes = {};
Kt.filterProps = Z0;
function Qt(e) {
  return Iz(e, K0);
}
Qt.propTypes = {};
Qt.filterProps = K0;
function kg(...e) {
  const t = e.reduce((r, o) => (o.filterProps.forEach((i) => {
    r[i] = o;
  }), r), {}), n = (r) => Object.keys(r).reduce((o, i) => t[i] ? Sd(o, t[i](r)) : o, {});
  return n.propTypes = {}, n.filterProps = e.reduce((r, o) => r.concat(o.filterProps), []), n;
}
function lo(e) {
  return typeof e != "number" ? e : `${e}px solid`;
}
function po(e, t) {
  return rn({
    prop: e,
    themeKey: "borders",
    transform: t
  });
}
const _ie = po("border", lo), kie = po("borderTop", lo), Eie = po("borderRight", lo), Cie = po("borderBottom", lo), Oie = po("borderLeft", lo), Aie = po("borderColor"), Nie = po("borderTopColor"), Mie = po("borderRightColor"), Rie = po("borderBottomColor"), jie = po("borderLeftColor"), zie = po("outline", lo), Tie = po("outlineColor"), Eg = (e) => {
  if (e.borderRadius !== void 0 && e.borderRadius !== null) {
    const t = Cf(e.theme, "shape.borderRadius", 4), n = (r) => ({
      borderRadius: Of(t, r)
    });
    return ea(e, e.borderRadius, n);
  }
  return null;
};
Eg.propTypes = {};
Eg.filterProps = ["borderRadius"];
kg(_ie, kie, Eie, Cie, Oie, Aie, Nie, Mie, Rie, jie, Eg, zie, Tie);
const Cg = (e) => {
  if (e.gap !== void 0 && e.gap !== null) {
    const t = Cf(e.theme, "spacing", 8), n = (r) => ({
      gap: Of(t, r)
    });
    return ea(e, e.gap, n);
  }
  return null;
};
Cg.propTypes = {};
Cg.filterProps = ["gap"];
const Og = (e) => {
  if (e.columnGap !== void 0 && e.columnGap !== null) {
    const t = Cf(e.theme, "spacing", 8), n = (r) => ({
      columnGap: Of(t, r)
    });
    return ea(e, e.columnGap, n);
  }
  return null;
};
Og.propTypes = {};
Og.filterProps = ["columnGap"];
const Ag = (e) => {
  if (e.rowGap !== void 0 && e.rowGap !== null) {
    const t = Cf(e.theme, "spacing", 8), n = (r) => ({
      rowGap: Of(t, r)
    });
    return ea(e, e.rowGap, n);
  }
  return null;
};
Ag.propTypes = {};
Ag.filterProps = ["rowGap"];
const Die = rn({
  prop: "gridColumn"
}), Pie = rn({
  prop: "gridRow"
}), Lie = rn({
  prop: "gridAutoFlow"
}), Iie = rn({
  prop: "gridAutoColumns"
}), Vie = rn({
  prop: "gridAutoRows"
}), Bie = rn({
  prop: "gridTemplateColumns"
}), Fie = rn({
  prop: "gridTemplateRows"
}), Uie = rn({
  prop: "gridTemplateAreas"
}), Hie = rn({
  prop: "gridArea"
});
kg(Cg, Og, Ag, Die, Pie, Lie, Iie, Vie, Bie, Fie, Uie, Hie);
function Su(e, t) {
  return t === "grey" ? t : e;
}
const $ie = rn({
  prop: "color",
  themeKey: "palette",
  transform: Su
}), Yie = rn({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: Su
}), qie = rn({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: Su
});
kg($ie, Yie, qie);
function Lr(e) {
  return e <= 1 && e !== 0 ? `${e * 100}%` : e;
}
const Xie = rn({
  prop: "width",
  transform: Lr
}), J0 = (e) => {
  if (e.maxWidth !== void 0 && e.maxWidth !== null) {
    const t = (n) => {
      var r, o, i, s, u;
      const c = ((i = (o = (r = e.theme) == null ? void 0 : r.breakpoints) == null ? void 0 : o.values) == null ? void 0 : i[n]) || Sg[n];
      return c ? ((u = (s = e.theme) == null ? void 0 : s.breakpoints) == null ? void 0 : u.unit) !== "px" ? {
        maxWidth: `${c}${e.theme.breakpoints.unit}`
      } : {
        maxWidth: c
      } : {
        maxWidth: Lr(n)
      };
    };
    return ea(e, e.maxWidth, t);
  }
  return null;
};
J0.filterProps = ["maxWidth"];
const Wie = rn({
  prop: "minWidth",
  transform: Lr
}), Gie = rn({
  prop: "height",
  transform: Lr
}), Zie = rn({
  prop: "maxHeight",
  transform: Lr
}), Kie = rn({
  prop: "minHeight",
  transform: Lr
});
rn({
  prop: "size",
  cssProperty: "width",
  transform: Lr
});
rn({
  prop: "size",
  cssProperty: "height",
  transform: Lr
});
const Qie = rn({
  prop: "boxSizing"
});
kg(Xie, J0, Wie, Gie, Zie, Kie, Qie);
const Ng = {
  // borders
  border: {
    themeKey: "borders",
    transform: lo
  },
  borderTop: {
    themeKey: "borders",
    transform: lo
  },
  borderRight: {
    themeKey: "borders",
    transform: lo
  },
  borderBottom: {
    themeKey: "borders",
    transform: lo
  },
  borderLeft: {
    themeKey: "borders",
    transform: lo
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: lo
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: Eg
  },
  // palette
  color: {
    themeKey: "palette",
    transform: Su
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: Su
  },
  backgroundColor: {
    themeKey: "palette",
    transform: Su
  },
  // spacing
  p: {
    style: Qt
  },
  pt: {
    style: Qt
  },
  pr: {
    style: Qt
  },
  pb: {
    style: Qt
  },
  pl: {
    style: Qt
  },
  px: {
    style: Qt
  },
  py: {
    style: Qt
  },
  padding: {
    style: Qt
  },
  paddingTop: {
    style: Qt
  },
  paddingRight: {
    style: Qt
  },
  paddingBottom: {
    style: Qt
  },
  paddingLeft: {
    style: Qt
  },
  paddingX: {
    style: Qt
  },
  paddingY: {
    style: Qt
  },
  paddingInline: {
    style: Qt
  },
  paddingInlineStart: {
    style: Qt
  },
  paddingInlineEnd: {
    style: Qt
  },
  paddingBlock: {
    style: Qt
  },
  paddingBlockStart: {
    style: Qt
  },
  paddingBlockEnd: {
    style: Qt
  },
  m: {
    style: Kt
  },
  mt: {
    style: Kt
  },
  mr: {
    style: Kt
  },
  mb: {
    style: Kt
  },
  ml: {
    style: Kt
  },
  mx: {
    style: Kt
  },
  my: {
    style: Kt
  },
  margin: {
    style: Kt
  },
  marginTop: {
    style: Kt
  },
  marginRight: {
    style: Kt
  },
  marginBottom: {
    style: Kt
  },
  marginLeft: {
    style: Kt
  },
  marginX: {
    style: Kt
  },
  marginY: {
    style: Kt
  },
  marginInline: {
    style: Kt
  },
  marginInlineStart: {
    style: Kt
  },
  marginInlineEnd: {
    style: Kt
  },
  marginBlock: {
    style: Kt
  },
  marginBlockStart: {
    style: Kt
  },
  marginBlockEnd: {
    style: Kt
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: (e) => ({
      "@media print": {
        display: e
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: Cg
  },
  rowGap: {
    style: Ag
  },
  columnGap: {
    style: Og
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: Lr
  },
  maxWidth: {
    style: J0
  },
  minWidth: {
    transform: Lr
  },
  height: {
    transform: Lr
  },
  maxHeight: {
    transform: Lr
  },
  minHeight: {
    transform: Lr
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: "typography"
  }
};
function Jie(...e) {
  const t = e.reduce((r, o) => r.concat(Object.keys(o)), []), n = new Set(t);
  return e.every((r) => n.size === Object.keys(r).length);
}
function eae(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function tae() {
  function e(n, r, o, i) {
    const s = {
      [n]: r,
      theme: o
    }, u = i[n];
    if (!u)
      return {
        [n]: r
      };
    const {
      cssProperty: c = n,
      themeKey: d,
      transform: p,
      style: h
    } = u;
    if (r == null)
      return null;
    if (d === "typography" && r === "inherit")
      return {
        [n]: r
      };
    const g = _g(o, d) || {};
    return h ? h(s) : ea(s, r, (y) => {
      let b = vm(g, p, y);
      return y === b && typeof y == "string" && (b = vm(g, p, `${n}${y === "default" ? "" : tr(y)}`, y)), c === !1 ? b : {
        [c]: b
      };
    });
  }
  function t(n) {
    const {
      sx: r,
      theme: o = {}
    } = n || {};
    if (!r)
      return null;
    const i = o.unstable_sxConfig ?? Ng;
    function s(u) {
      let c = u;
      if (typeof u == "function")
        c = u(o);
      else if (typeof u != "object")
        return u;
      if (!c)
        return null;
      const d = mie(o.breakpoints), p = Object.keys(d);
      let h = d;
      return Object.keys(c).forEach((g) => {
        const y = eae(c[g], o);
        if (y != null)
          if (typeof y == "object")
            if (i[g])
              h = Sd(h, e(g, y, o, i));
            else {
              const b = ea({
                theme: o
              }, y, (v) => ({
                [g]: v
              }));
              Jie(b, y) ? h[g] = t({
                sx: y,
                theme: o
              }) : h = Sd(h, b);
            }
          else
            h = Sd(h, e(g, y, o, i));
      }), cie(o, gie(p, h));
    }
    return Array.isArray(r) ? r.map(s) : s(r);
  }
  return t;
}
const Lu = tae();
Lu.filterProps = ["sx"];
function Te() {
  return Te = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Te.apply(null, arguments);
}
function nae(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function rae(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var oae = /* @__PURE__ */ function() {
  function e(n) {
    var r = this;
    this._insertTag = function(o) {
      var i;
      r.tags.length === 0 ? r.insertionPoint ? i = r.insertionPoint.nextSibling : r.prepend ? i = r.container.firstChild : i = r.before : i = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(o, i), r.tags.push(o);
    }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(n) {
    n.forEach(this._insertTag);
  }, t.insert = function(n) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(rae(this));
    var r = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var o = nae(r);
      try {
        o.insertRule(n, o.cssRules.length);
      } catch {
      }
    } else
      r.appendChild(document.createTextNode(n));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(n) {
      var r;
      return (r = n.parentNode) == null ? void 0 : r.removeChild(n);
    }), this.tags = [], this.ctr = 0;
  }, e;
}(), Vn = "-ms-", bm = "-moz-", mt = "-webkit-", Vz = "comm", e_ = "rule", t_ = "decl", iae = "@import", Bz = "@keyframes", aae = "@layer", sae = Math.abs, Mg = String.fromCharCode, lae = Object.assign;
function uae(e, t) {
  return Tn(e, 0) ^ 45 ? (((t << 2 ^ Tn(e, 0)) << 2 ^ Tn(e, 1)) << 2 ^ Tn(e, 2)) << 2 ^ Tn(e, 3) : 0;
}
function Fz(e) {
  return e.trim();
}
function cae(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function gt(e, t, n) {
  return e.replace(t, n);
}
function Lx(e, t) {
  return e.indexOf(t);
}
function Tn(e, t) {
  return e.charCodeAt(t) | 0;
}
function Xd(e, t, n) {
  return e.slice(t, n);
}
function ti(e) {
  return e.length;
}
function n_(e) {
  return e.length;
}
function ah(e, t) {
  return t.push(e), e;
}
function dae(e, t) {
  return e.map(t).join("");
}
var Rg = 1, Iu = 1, Uz = 0, yr = 0, hn = 0, Gu = "";
function jg(e, t, n, r, o, i, s) {
  return { value: e, root: t, parent: n, type: r, props: o, children: i, line: Rg, column: Iu, length: s, return: "" };
}
function nd(e, t) {
  return lae(jg("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function fae() {
  return hn;
}
function pae() {
  return hn = yr > 0 ? Tn(Gu, --yr) : 0, Iu--, hn === 10 && (Iu = 1, Rg--), hn;
}
function Ur() {
  return hn = yr < Uz ? Tn(Gu, yr++) : 0, Iu++, hn === 10 && (Iu = 1, Rg++), hn;
}
function di() {
  return Tn(Gu, yr);
}
function Ph() {
  return yr;
}
function Af(e, t) {
  return Xd(Gu, e, t);
}
function Wd(e) {
  switch (e) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function Hz(e) {
  return Rg = Iu = 1, Uz = ti(Gu = e), yr = 0, [];
}
function $z(e) {
  return Gu = "", e;
}
function Lh(e) {
  return Fz(Af(yr - 1, Ix(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function hae(e) {
  for (; (hn = di()) && hn < 33; )
    Ur();
  return Wd(e) > 2 || Wd(hn) > 3 ? "" : " ";
}
function mae(e, t) {
  for (; --t && Ur() && !(hn < 48 || hn > 102 || hn > 57 && hn < 65 || hn > 70 && hn < 97); )
    ;
  return Af(e, Ph() + (t < 6 && di() == 32 && Ur() == 32));
}
function Ix(e) {
  for (; Ur(); )
    switch (hn) {
      // ] ) " '
      case e:
        return yr;
      // " '
      case 34:
      case 39:
        e !== 34 && e !== 39 && Ix(hn);
        break;
      // (
      case 40:
        e === 41 && Ix(e);
        break;
      // \
      case 92:
        Ur();
        break;
    }
  return yr;
}
function gae(e, t) {
  for (; Ur() && e + hn !== 57 && !(e + hn === 84 && di() === 47); )
    ;
  return "/*" + Af(t, yr - 1) + "*" + Mg(e === 47 ? e : Ur());
}
function yae(e) {
  for (; !Wd(di()); )
    Ur();
  return Af(e, yr);
}
function vae(e) {
  return $z(Ih("", null, null, null, [""], e = Hz(e), 0, [0], e));
}
function Ih(e, t, n, r, o, i, s, u, c) {
  for (var d = 0, p = 0, h = s, g = 0, y = 0, b = 0, v = 1, x = 1, _ = 1, O = 0, C = "", N = o, R = i, z = r, j = C; x; )
    switch (b = O, O = Ur()) {
      // (
      case 40:
        if (b != 108 && Tn(j, h - 1) == 58) {
          Lx(j += gt(Lh(O), "&", "&\f"), "&\f") != -1 && (_ = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        j += Lh(O);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        j += hae(b);
        break;
      // \
      case 92:
        j += mae(Ph() - 1, 7);
        continue;
      // /
      case 47:
        switch (di()) {
          case 42:
          case 47:
            ah(bae(gae(Ur(), Ph()), t, n), c);
            break;
          default:
            j += "/";
        }
        break;
      // {
      case 123 * v:
        u[d++] = ti(j) * _;
      // } ; \0
      case 125 * v:
      case 59:
      case 0:
        switch (O) {
          // \0 }
          case 0:
          case 125:
            x = 0;
          // ;
          case 59 + p:
            _ == -1 && (j = gt(j, /\f/g, "")), y > 0 && ti(j) - h && ah(y > 32 ? $A(j + ";", r, n, h - 1) : $A(gt(j, " ", "") + ";", r, n, h - 2), c);
            break;
          // @ ;
          case 59:
            j += ";";
          // { rule/at-rule
          default:
            if (ah(z = HA(j, t, n, d, p, o, u, C, N = [], R = [], h), i), O === 123)
              if (p === 0)
                Ih(j, t, z, z, N, i, h, u, R);
              else
                switch (g === 99 && Tn(j, 3) === 110 ? 100 : g) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Ih(e, z, z, r && ah(HA(e, z, z, 0, 0, o, u, C, o, N = [], h), R), o, R, h, u, r ? N : R);
                    break;
                  default:
                    Ih(j, z, z, z, [""], R, 0, u, R);
                }
        }
        d = p = y = 0, v = _ = 1, C = j = "", h = s;
        break;
      // :
      case 58:
        h = 1 + ti(j), y = b;
      default:
        if (v < 1) {
          if (O == 123)
            --v;
          else if (O == 125 && v++ == 0 && pae() == 125)
            continue;
        }
        switch (j += Mg(O), O * v) {
          // &
          case 38:
            _ = p > 0 ? 1 : (j += "\f", -1);
            break;
          // ,
          case 44:
            u[d++] = (ti(j) - 1) * _, _ = 1;
            break;
          // @
          case 64:
            di() === 45 && (j += Lh(Ur())), g = di(), p = h = ti(C = j += yae(Ph())), O++;
            break;
          // -
          case 45:
            b === 45 && ti(j) == 2 && (v = 0);
        }
    }
  return i;
}
function HA(e, t, n, r, o, i, s, u, c, d, p) {
  for (var h = o - 1, g = o === 0 ? i : [""], y = n_(g), b = 0, v = 0, x = 0; b < r; ++b)
    for (var _ = 0, O = Xd(e, h + 1, h = sae(v = s[b])), C = e; _ < y; ++_)
      (C = Fz(v > 0 ? g[_] + " " + O : gt(O, /&\f/g, g[_]))) && (c[x++] = C);
  return jg(e, t, n, o === 0 ? e_ : u, c, d, p);
}
function bae(e, t, n) {
  return jg(e, t, n, Vz, Mg(fae()), Xd(e, 2, -2), 0);
}
function $A(e, t, n, r) {
  return jg(e, t, n, t_, Xd(e, 0, r), Xd(e, r + 1, -1), r);
}
function _u(e, t) {
  for (var n = "", r = n_(e), o = 0; o < r; o++)
    n += t(e[o], o, e, t) || "";
  return n;
}
function wae(e, t, n, r) {
  switch (e.type) {
    case aae:
      if (e.children.length) break;
    case iae:
    case t_:
      return e.return = e.return || e.value;
    case Vz:
      return "";
    case Bz:
      return e.return = e.value + "{" + _u(e.children, r) + "}";
    case e_:
      e.value = e.props.join(",");
  }
  return ti(n = _u(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function xae(e) {
  var t = n_(e);
  return function(n, r, o, i) {
    for (var s = "", u = 0; u < t; u++)
      s += e[u](n, r, o, i) || "";
    return s;
  };
}
function Sae(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function Yz(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var _ae = function(e, t, n) {
  for (var r = 0, o = 0; r = o, o = di(), r === 38 && o === 12 && (t[n] = 1), !Wd(o); )
    Ur();
  return Af(e, yr);
}, kae = function(e, t) {
  var n = -1, r = 44;
  do
    switch (Wd(r)) {
      case 0:
        r === 38 && di() === 12 && (t[n] = 1), e[n] += _ae(yr - 1, t, n);
        break;
      case 2:
        e[n] += Lh(r);
        break;
      case 4:
        if (r === 44) {
          e[++n] = di() === 58 ? "&\f" : "", t[n] = e[n].length;
          break;
        }
      // fallthrough
      default:
        e[n] += Mg(r);
    }
  while (r = Ur());
  return e;
}, Eae = function(e, t) {
  return $z(kae(Hz(e), t));
}, YA = /* @__PURE__ */ new WeakMap(), Cae = function(e) {
  if (!(e.type !== "rule" || !e.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  e.length < 1)) {
    for (var t = e.value, n = e.parent, r = e.column === n.column && e.line === n.line; n.type !== "rule"; )
      if (n = n.parent, !n) return;
    if (!(e.props.length === 1 && t.charCodeAt(0) !== 58 && !YA.get(n)) && !r) {
      YA.set(e, !0);
      for (var o = [], i = Eae(t, o), s = n.props, u = 0, c = 0; u < i.length; u++)
        for (var d = 0; d < s.length; d++, c++)
          e.props[c] = o[u] ? i[u].replace(/&\f/g, s[d]) : s[d] + " " + i[u];
    }
  }
}, Oae = function(e) {
  if (e.type === "decl") {
    var t = e.value;
    t.charCodeAt(0) === 108 && // charcode for b
    t.charCodeAt(2) === 98 && (e.return = "", e.value = "");
  }
};
function qz(e, t) {
  switch (uae(e, t)) {
    // color-adjust
    case 5103:
      return mt + "print-" + e + e;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return mt + e + e;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return mt + e + bm + e + Vn + e + e;
    // flex, flex-direction
    case 6828:
    case 4268:
      return mt + e + Vn + e + e;
    // order
    case 6165:
      return mt + e + Vn + "flex-" + e + e;
    // align-items
    case 5187:
      return mt + e + gt(e, /(\w+).+(:[^]+)/, mt + "box-$1$2" + Vn + "flex-$1$2") + e;
    // align-self
    case 5443:
      return mt + e + Vn + "flex-item-" + gt(e, /flex-|-self/, "") + e;
    // align-content
    case 4675:
      return mt + e + Vn + "flex-line-pack" + gt(e, /align-content|flex-|-self/, "") + e;
    // flex-shrink
    case 5548:
      return mt + e + Vn + gt(e, "shrink", "negative") + e;
    // flex-basis
    case 5292:
      return mt + e + Vn + gt(e, "basis", "preferred-size") + e;
    // flex-grow
    case 6060:
      return mt + "box-" + gt(e, "-grow", "") + mt + e + Vn + gt(e, "grow", "positive") + e;
    // transition
    case 4554:
      return mt + gt(e, /([^-])(transform)/g, "$1" + mt + "$2") + e;
    // cursor
    case 6187:
      return gt(gt(gt(e, /(zoom-|grab)/, mt + "$1"), /(image-set)/, mt + "$1"), e, "") + e;
    // background, background-image
    case 5495:
    case 3959:
      return gt(e, /(image-set\([^]*)/, mt + "$1$`$1");
    // justify-content
    case 4968:
      return gt(gt(e, /(.+:)(flex-)?(.*)/, mt + "box-pack:$3" + Vn + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + mt + e + e;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return gt(e, /(.+)-inline(.+)/, mt + "$1$2") + e;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (ti(e) - 1 - t > 6) switch (Tn(e, t + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (Tn(e, t + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return gt(e, /(.+:)(.+)-([^]+)/, "$1" + mt + "$2-$3$1" + bm + (Tn(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        // (s)tretch
        case 115:
          return ~Lx(e, "stretch") ? qz(gt(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    // position: sticky
    case 4949:
      if (Tn(e, t + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (Tn(e, ti(e) - 3 - (~Lx(e, "!important") && 10))) {
        // stic(k)y
        case 107:
          return gt(e, ":", ":" + mt) + e;
        // (inline-)?fl(e)x
        case 101:
          return gt(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + mt + (Tn(e, 14) === 45 ? "inline-" : "") + "box$3$1" + mt + "$2$3$1" + Vn + "$2box$3") + e;
      }
      break;
    // writing-mode
    case 5936:
      switch (Tn(e, t + 11)) {
        // vertical-l(r)
        case 114:
          return mt + e + Vn + gt(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        // vertical-r(l)
        case 108:
          return mt + e + Vn + gt(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        // horizontal(-)tb
        case 45:
          return mt + e + Vn + gt(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return mt + e + Vn + e + e;
  }
  return e;
}
var Aae = function(e, t, n, r) {
  if (e.length > -1 && !e.return) switch (e.type) {
    case t_:
      e.return = qz(e.value, e.length);
      break;
    case Bz:
      return _u([nd(e, {
        value: gt(e.value, "@", "@" + mt)
      })], r);
    case e_:
      if (e.length) return dae(e.props, function(o) {
        switch (cae(o, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ":read-only":
          case ":read-write":
            return _u([nd(e, {
              props: [gt(o, /:(read-\w+)/, ":" + bm + "$1")]
            })], r);
          // :placeholder
          case "::placeholder":
            return _u([nd(e, {
              props: [gt(o, /:(plac\w+)/, ":" + mt + "input-$1")]
            }), nd(e, {
              props: [gt(o, /:(plac\w+)/, ":" + bm + "$1")]
            }), nd(e, {
              props: [gt(o, /:(plac\w+)/, Vn + "input-$1")]
            })], r);
        }
        return "";
      });
  }
}, Nae = [Aae], Mae = function(e) {
  var t = e.key;
  if (t === "css") {
    var n = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(n, function(b) {
      var v = b.getAttribute("data-emotion");
      v.indexOf(" ") !== -1 && (document.head.appendChild(b), b.setAttribute("data-s", ""));
    });
  }
  var r = e.stylisPlugins || Nae, o = {}, i, s = [];
  i = e.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + t + ' "]'),
    function(b) {
      for (var v = b.getAttribute("data-emotion").split(" "), x = 1; x < v.length; x++)
        o[v[x]] = !0;
      s.push(b);
    }
  );
  var u, c = [Cae, Oae];
  {
    var d, p = [wae, Sae(function(b) {
      d.insert(b);
    })], h = xae(c.concat(r, p)), g = function(b) {
      return _u(vae(b), h);
    };
    u = function(b, v, x, _) {
      d = x, g(b ? b + "{" + v.styles + "}" : v.styles), _ && (y.inserted[v.name] = !0);
    };
  }
  var y = {
    key: t,
    sheet: new oae({
      key: t,
      container: i,
      nonce: e.nonce,
      speedy: e.speedy,
      prepend: e.prepend,
      insertionPoint: e.insertionPoint
    }),
    nonce: e.nonce,
    inserted: o,
    registered: {},
    insert: u
  };
  return y.sheet.hydrate(s), y;
}, Zb, qA;
function Rae() {
  if (qA) return Zb;
  qA = 1;
  var e = kW(), t = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, n = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, r = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, o = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, i = {};
  i[e.ForwardRef] = r, i[e.Memo] = o;
  function s(b) {
    return e.isMemo(b) ? o : i[b.$$typeof] || t;
  }
  var u = Object.defineProperty, c = Object.getOwnPropertyNames, d = Object.getOwnPropertySymbols, p = Object.getOwnPropertyDescriptor, h = Object.getPrototypeOf, g = Object.prototype;
  function y(b, v, x) {
    if (typeof v != "string") {
      if (g) {
        var _ = h(v);
        _ && _ !== g && y(b, _, x);
      }
      var O = c(v);
      d && (O = O.concat(d(v)));
      for (var C = s(b), N = s(v), R = 0; R < O.length; ++R) {
        var z = O[R];
        if (!n[z] && !(x && x[z]) && !(N && N[z]) && !(C && C[z])) {
          var j = p(v, z);
          try {
            u(b, z, j);
          } catch {
          }
        }
      }
    }
    return b;
  }
  return Zb = y, Zb;
}
Rae();
var jae = !0;
function Xz(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function(o) {
    e[o] !== void 0 ? t.push(e[o] + ";") : o && (r += o + " ");
  }), r;
}
var r_ = function(e, t, n) {
  var r = e.key + "-" + t.name;
  (n === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  jae === !1) && e.registered[r] === void 0 && (e.registered[r] = t.styles);
}, Wz = function(e, t, n) {
  r_(e, t, n);
  var r = e.key + "-" + t.name;
  if (e.inserted[t.name] === void 0) {
    var o = t;
    do
      e.insert(t === o ? "." + r : "", o, e.sheet, !0), o = o.next;
    while (o !== void 0);
  }
};
function zae(e) {
  for (var t = 0, n, r = 0, o = e.length; o >= 4; ++r, o -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (o) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var Tae = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, Dae = /[A-Z]|^ms/g, Pae = /_EMO_([^_]+?)_([^]*?)_EMO_/g, Gz = function(e) {
  return e.charCodeAt(1) === 45;
}, XA = function(e) {
  return e != null && typeof e != "boolean";
}, Kb = /* @__PURE__ */ Yz(function(e) {
  return Gz(e) ? e : e.replace(Dae, "-$&").toLowerCase();
}), WA = function(e, t) {
  switch (e) {
    case "animation":
    case "animationName":
      if (typeof t == "string")
        return t.replace(Pae, function(n, r, o) {
          return ni = {
            name: r,
            styles: o,
            next: ni
          }, r;
        });
  }
  return Tae[e] !== 1 && !Gz(e) && typeof t == "number" && t !== 0 ? t + "px" : t;
};
function Gd(e, t, n) {
  if (n == null)
    return "";
  var r = n;
  if (r.__emotion_styles !== void 0)
    return r;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var o = n;
      if (o.anim === 1)
        return ni = {
          name: o.name,
          styles: o.styles,
          next: ni
        }, o.name;
      var i = n;
      if (i.styles !== void 0) {
        var s = i.next;
        if (s !== void 0)
          for (; s !== void 0; )
            ni = {
              name: s.name,
              styles: s.styles,
              next: ni
            }, s = s.next;
        var u = i.styles + ";";
        return u;
      }
      return Lae(e, t, n);
    }
    case "function": {
      if (e !== void 0) {
        var c = ni, d = n(e);
        return ni = c, Gd(e, t, d);
      }
      break;
    }
  }
  var p = n;
  if (t == null)
    return p;
  var h = t[p];
  return h !== void 0 ? h : p;
}
function Lae(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var o = 0; o < n.length; o++)
      r += Gd(e, t, n[o]) + ";";
  else
    for (var i in n) {
      var s = n[i];
      if (typeof s != "object") {
        var u = s;
        t != null && t[u] !== void 0 ? r += i + "{" + t[u] + "}" : XA(u) && (r += Kb(i) + ":" + WA(i, u) + ";");
      } else if (Array.isArray(s) && typeof s[0] == "string" && (t == null || t[s[0]] === void 0))
        for (var c = 0; c < s.length; c++)
          XA(s[c]) && (r += Kb(i) + ":" + WA(i, s[c]) + ";");
      else {
        var d = Gd(e, t, s);
        switch (i) {
          case "animation":
          case "animationName": {
            r += Kb(i) + ":" + d + ";";
            break;
          }
          default:
            r += i + "{" + d + "}";
        }
      }
    }
  return r;
}
var GA = /label:\s*([^\s;{]+)\s*(;|$)/g, ni;
function zg(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var r = !0, o = "";
  ni = void 0;
  var i = e[0];
  if (i == null || i.raw === void 0)
    r = !1, o += Gd(n, t, i);
  else {
    var s = i;
    o += s[0];
  }
  for (var u = 1; u < e.length; u++)
    if (o += Gd(n, t, e[u]), r) {
      var c = i;
      o += c[u];
    }
  GA.lastIndex = 0;
  for (var d = "", p; (p = GA.exec(o)) !== null; )
    d += "-" + p[1];
  var h = zae(o) + d;
  return {
    name: h,
    styles: o,
    next: ni
  };
}
var Iae = function(e) {
  return e();
}, Vae = S.useInsertionEffect ? S.useInsertionEffect : !1, Zz = Vae || Iae, Kz = /* @__PURE__ */ S.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ Mae({
    key: "css"
  }) : null
);
Kz.Provider;
var Qz = function(e) {
  return /* @__PURE__ */ S.forwardRef(function(t, n) {
    var r = S.useContext(Kz);
    return e(t, r, n);
  });
}, Jz = /* @__PURE__ */ S.createContext({}), o_ = {}.hasOwnProperty, Vx = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", Bae = function(e, t) {
  var n = {};
  for (var r in t)
    o_.call(t, r) && (n[r] = t[r]);
  return n[Vx] = e, n;
}, Fae = function(e) {
  var t = e.cache, n = e.serialized, r = e.isStringTag;
  return r_(t, n, r), Zz(function() {
    return Wz(t, n, r);
  }), null;
}, Uae = /* @__PURE__ */ Qz(function(e, t, n) {
  var r = e.css;
  typeof r == "string" && t.registered[r] !== void 0 && (r = t.registered[r]);
  var o = e[Vx], i = [r], s = "";
  typeof e.className == "string" ? s = Xz(t.registered, i, e.className) : e.className != null && (s = e.className + " ");
  var u = zg(i, void 0, S.useContext(Jz));
  s += t.key + "-" + u.name;
  var c = {};
  for (var d in e)
    o_.call(e, d) && d !== "css" && d !== Vx && (c[d] = e[d]);
  return c.className = s, n && (c.ref = n), /* @__PURE__ */ S.createElement(S.Fragment, null, /* @__PURE__ */ S.createElement(Fae, {
    cache: t,
    serialized: u,
    isStringTag: typeof o == "string"
  }), /* @__PURE__ */ S.createElement(o, c));
}), Hae = Uae, ze = function(e, t) {
  var n = arguments;
  if (t == null || !o_.call(t, "css"))
    return S.createElement.apply(void 0, n);
  var r = n.length, o = new Array(r);
  o[0] = Hae, o[1] = Bae(e, t);
  for (var i = 2; i < r; i++)
    o[i] = n[i];
  return S.createElement.apply(null, o);
};
(function(e) {
  var t;
  t || (t = e.JSX || (e.JSX = {}));
})(ze || (ze = {}));
function i_() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return zg(t);
}
function Tg() {
  var e = i_.apply(void 0, arguments), t = "animation-" + e.name;
  return {
    name: t,
    styles: "@keyframes " + t + "{" + e.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var $ae = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, Yae = /* @__PURE__ */ Yz(
  function(e) {
    return $ae.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
), qae = Yae, Xae = function(e) {
  return e !== "theme";
}, ZA = function(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96 ? qae : Xae;
}, KA = function(e, t, n) {
  var r;
  if (t) {
    var o = t.shouldForwardProp;
    r = e.__emotion_forwardProp && o ? function(i) {
      return e.__emotion_forwardProp(i) && o(i);
    } : o;
  }
  return typeof r != "function" && n && (r = e.__emotion_forwardProp), r;
}, Wae = function(e) {
  var t = e.cache, n = e.serialized, r = e.isStringTag;
  return r_(t, n, r), Zz(function() {
    return Wz(t, n, r);
  }), null;
}, Gae = function e(t, n) {
  var r = t.__emotion_real === t, o = r && t.__emotion_base || t, i, s;
  n !== void 0 && (i = n.label, s = n.target);
  var u = KA(t, n, r), c = u || ZA(o), d = !c("as");
  return function() {
    var p = arguments, h = r && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
    if (i !== void 0 && h.push("label:" + i + ";"), p[0] == null || p[0].raw === void 0)
      h.push.apply(h, p);
    else {
      var g = p[0];
      h.push(g[0]);
      for (var y = p.length, b = 1; b < y; b++)
        h.push(p[b], g[b]);
    }
    var v = Qz(function(x, _, O) {
      var C = d && x.as || o, N = "", R = [], z = x;
      if (x.theme == null) {
        z = {};
        for (var j in x)
          z[j] = x[j];
        z.theme = S.useContext(Jz);
      }
      typeof x.className == "string" ? N = Xz(_.registered, R, x.className) : x.className != null && (N = x.className + " ");
      var I = zg(h.concat(R), _.registered, z);
      N += _.key + "-" + I.name, s !== void 0 && (N += " " + s);
      var $ = d && u === void 0 ? ZA(C) : c, A = {};
      for (var V in x)
        d && V === "as" || $(V) && (A[V] = x[V]);
      return A.className = N, O && (A.ref = O), /* @__PURE__ */ S.createElement(S.Fragment, null, /* @__PURE__ */ S.createElement(Wae, {
        cache: _,
        serialized: I,
        isStringTag: typeof C == "string"
      }), /* @__PURE__ */ S.createElement(C, A));
    });
    return v.displayName = i !== void 0 ? i : "Styled(" + (typeof o == "string" ? o : o.displayName || o.name || "Component") + ")", v.defaultProps = t.defaultProps, v.__emotion_real = v, v.__emotion_base = o, v.__emotion_styles = h, v.__emotion_forwardProp = u, Object.defineProperty(v, "toString", {
      value: function() {
        return "." + s;
      }
    }), v.withComponent = function(x, _) {
      var O = e(x, Te({}, n, _, {
        shouldForwardProp: KA(v, _, !0)
      }));
      return O.apply(void 0, h);
    }, v;
  };
}, Zae = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], Bx = Gae.bind(null);
Zae.forEach(function(e) {
  Bx[e] = Bx(e);
});
/**
 * @mui/styled-engine v7.0.2
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function Kae(e, t) {
  return Bx(e, t);
}
function Qae(e, t) {
  Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));
}
const QA = [];
function JA(e) {
  return QA[0] = e, zg(QA);
}
const Jae = (e) => {
  const t = Object.keys(e).map((n) => ({
    key: n,
    val: e[n]
  })) || [];
  return t.sort((n, r) => n.val - r.val), t.reduce((n, r) => ({
    ...n,
    [r.key]: r.val
  }), {});
};
function ese(e) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: t = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: n = "px",
    step: r = 5,
    ...o
  } = e, i = Jae(t), s = Object.keys(i);
  function u(g) {
    return `@media (min-width:${typeof t[g] == "number" ? t[g] : g}${n})`;
  }
  function c(g) {
    return `@media (max-width:${(typeof t[g] == "number" ? t[g] : g) - r / 100}${n})`;
  }
  function d(g, y) {
    const b = s.indexOf(y);
    return `@media (min-width:${typeof t[g] == "number" ? t[g] : g}${n}) and (max-width:${(b !== -1 && typeof t[s[b]] == "number" ? t[s[b]] : y) - r / 100}${n})`;
  }
  function p(g) {
    return s.indexOf(g) + 1 < s.length ? d(g, s[s.indexOf(g) + 1]) : u(g);
  }
  function h(g) {
    const y = s.indexOf(g);
    return y === 0 ? u(s[1]) : y === s.length - 1 ? c(s[y]) : d(g, s[s.indexOf(g) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys: s,
    values: i,
    up: u,
    down: c,
    between: d,
    only: p,
    not: h,
    unit: n,
    ...o
  };
}
const tse = {
  borderRadius: 4
};
function eT(e = 8, t = Q0({
  spacing: e
})) {
  if (e.mui)
    return e;
  const n = (...r) => (r.length === 0 ? [1] : r).map((o) => {
    const i = t(o);
    return typeof i == "number" ? `${i}px` : i;
  }).join(" ");
  return n.mui = !0, n;
}
function nse(e, t) {
  var n;
  const r = this;
  if (r.vars) {
    if (!((n = r.colorSchemes) != null && n[e]) || typeof r.getColorSchemeSelector != "function")
      return {};
    let o = r.getColorSchemeSelector(e);
    return o === "&" ? t : ((o.includes("data-") || o.includes(".")) && (o = `*:where(${o.replace(/\s*&$/, "")}) &`), {
      [o]: t
    });
  }
  return r.palette.mode === e ? t : {};
}
function tT(e = {}, ...t) {
  const {
    breakpoints: n = {},
    palette: r = {},
    spacing: o,
    shape: i = {},
    ...s
  } = e, u = ese(n), c = eT(o);
  let d = Fr({
    breakpoints: u,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...r
    },
    spacing: c,
    shape: {
      ...tse,
      ...i
    }
  }, s);
  return d = pie(d), d.applyStyles = nse, d = t.reduce((p, h) => Fr(p, h), d), d.unstable_sxConfig = {
    ...Ng,
    ...s?.unstable_sxConfig
  }, d.unstable_sx = function(p) {
    return Lu({
      sx: p,
      theme: this
    });
  }, d;
}
const e3 = (e) => e, rse = () => {
  let e = e3;
  return {
    configure(t) {
      e = t;
    },
    generate(t) {
      return e(t);
    },
    reset() {
      e = e3;
    }
  };
}, ose = rse(), ise = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function yi(e, t, n = "Mui") {
  const r = ise[t];
  return r ? `${n}-${r}` : `${ose.generate(e)}-${t}`;
}
function vi(e, t, n = "Mui") {
  const r = {};
  return t.forEach((o) => {
    r[o] = yi(e, o, n);
  }), r;
}
function nT(e) {
  const {
    variants: t,
    ...n
  } = e, r = {
    variants: t,
    style: JA(n),
    isProcessed: !0
  };
  return r.style === n || t && t.forEach((o) => {
    typeof o.style != "function" && (o.style = JA(o.style));
  }), r;
}
const ase = tT();
function Qb(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
function sse(e) {
  return e ? (t, n) => n[e] : null;
}
function lse(e, t, n) {
  e.theme = dse(e.theme) ? n : e.theme[t] || e.theme;
}
function Vh(e, t) {
  const n = typeof t == "function" ? t(e) : t;
  if (Array.isArray(n))
    return n.flatMap((r) => Vh(e, r));
  if (Array.isArray(n?.variants)) {
    let r;
    if (n.isProcessed)
      r = n.style;
    else {
      const {
        variants: o,
        ...i
      } = n;
      r = i;
    }
    return rT(e, n.variants, [r]);
  }
  return n != null && n.isProcessed ? n.style : n;
}
function rT(e, t, n = []) {
  var r;
  let o;
  e: for (let i = 0; i < t.length; i += 1) {
    const s = t[i];
    if (typeof s.props == "function") {
      if (o ?? (o = {
        ...e,
        ...e.ownerState,
        ownerState: e.ownerState
      }), !s.props(o))
        continue;
    } else
      for (const u in s.props)
        if (e[u] !== s.props[u] && ((r = e.ownerState) == null ? void 0 : r[u]) !== s.props[u])
          continue e;
    typeof s.style == "function" ? (o ?? (o = {
      ...e,
      ...e.ownerState,
      ownerState: e.ownerState
    }), n.push(s.style(o))) : n.push(s.style);
  }
  return n;
}
function use(e = {}) {
  const {
    themeId: t,
    defaultTheme: n = ase,
    rootShouldForwardProp: r = Qb,
    slotShouldForwardProp: o = Qb
  } = e;
  function i(s) {
    lse(s, t, n);
  }
  return (s, u = {}) => {
    Qae(s, (N) => N.filter((R) => R !== Lu));
    const {
      name: c,
      slot: d,
      skipVariantsResolver: p,
      skipSx: h,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: g = sse(pse(d)),
      ...y
    } = u, b = p !== void 0 ? p : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      d && d !== "Root" && d !== "root" || !1
    ), v = h || !1;
    let x = Qb;
    d === "Root" || d === "root" ? x = r : d ? x = o : fse(s) && (x = void 0);
    const _ = Kae(s, {
      shouldForwardProp: x,
      label: cse(),
      ...y
    }), O = (N) => {
      if (typeof N == "function" && N.__emotion_real !== N)
        return function(R) {
          return Vh(R, N);
        };
      if (Ui(N)) {
        const R = nT(N);
        return R.variants ? function(z) {
          return Vh(z, R);
        } : R.style;
      }
      return N;
    }, C = (...N) => {
      const R = [], z = N.map(O), j = [];
      if (R.push(i), c && g && j.push(function(A) {
        var V, U;
        const W = (U = (V = A.theme.components) == null ? void 0 : V[c]) == null ? void 0 : U.styleOverrides;
        if (!W)
          return null;
        const D = {};
        for (const F in W)
          D[F] = Vh(A, W[F]);
        return g(A, D);
      }), c && !b && j.push(function(A) {
        var V, U;
        const W = A.theme, D = (U = (V = W?.components) == null ? void 0 : V[c]) == null ? void 0 : U.variants;
        return D ? rT(A, D) : null;
      }), v || j.push(Lu), Array.isArray(z[0])) {
        const A = z.shift(), V = new Array(R.length).fill(""), U = new Array(j.length).fill("");
        let W;
        W = [...V, ...A, ...U], W.raw = [...V, ...A.raw, ...U], R.unshift(W);
      }
      const I = [...R, ...z, ...j], $ = _(...I);
      return s.muiName && ($.muiName = s.muiName), $;
    };
    return _.withConfig && (C.withConfig = _.withConfig), C;
  };
}
function cse(e, t) {
  return void 0;
}
function dse(e) {
  for (const t in e)
    return !1;
  return !0;
}
function fse(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96;
}
function pse(e) {
  return e && e.charAt(0).toLowerCase() + e.slice(1);
}
function Fx(e, t) {
  const n = {
    ...t
  };
  for (const r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      const o = r;
      if (o === "components" || o === "slots")
        n[o] = {
          ...e[o],
          ...n[o]
        };
      else if (o === "componentsProps" || o === "slotProps") {
        const i = e[o], s = t[o];
        if (!s)
          n[o] = i || {};
        else if (!i)
          n[o] = s;
        else {
          n[o] = {
            ...s
          };
          for (const u in i)
            if (Object.prototype.hasOwnProperty.call(i, u)) {
              const c = u;
              n[o][c] = Fx(i[c], s[c]);
            }
        }
      } else n[o] === void 0 && (n[o] = e[o]);
    }
  return n;
}
const hse = typeof window < "u" ? S.useLayoutEffect : S.useEffect;
function mse(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
  return Math.max(t, Math.min(e, n));
}
function a_(e, t = 0, n = 1) {
  return mse(e, t, n);
}
function gse(e) {
  e = e.slice(1);
  const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g");
  let n = e.match(t);
  return n && n[0].length === 1 && (n = n.map((r) => r + r)), n ? `rgb${n.length === 4 ? "a" : ""}(${n.map((r, o) => o < 3 ? parseInt(r, 16) : Math.round(parseInt(r, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function is(e) {
  if (e.type)
    return e;
  if (e.charAt(0) === "#")
    return is(gse(e));
  const t = e.indexOf("("), n = e.substring(0, t);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(n))
    throw new Error(ol(9, e));
  let r = e.substring(t + 1, e.length - 1), o;
  if (n === "color") {
    if (r = r.split(" "), o = r.shift(), r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)), !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(o))
      throw new Error(ol(10, o));
  } else
    r = r.split(",");
  return r = r.map((i) => parseFloat(i)), {
    type: n,
    values: r,
    colorSpace: o
  };
}
const yse = (e) => {
  const t = is(e);
  return t.values.slice(0, 3).map((n, r) => t.type.includes("hsl") && r !== 0 ? `${n}%` : n).join(" ");
}, cd = (e, t) => {
  try {
    return yse(e);
  } catch {
    return e;
  }
};
function Dg(e) {
  const {
    type: t,
    colorSpace: n
  } = e;
  let {
    values: r
  } = e;
  return t.includes("rgb") ? r = r.map((o, i) => i < 3 ? parseInt(o, 10) : o) : t.includes("hsl") && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), t.includes("color") ? r = `${n} ${r.join(" ")}` : r = `${r.join(", ")}`, `${t}(${r})`;
}
function oT(e) {
  e = is(e);
  const {
    values: t
  } = e, n = t[0], r = t[1] / 100, o = t[2] / 100, i = r * Math.min(o, 1 - o), s = (d, p = (d + n / 30) % 12) => o - i * Math.max(Math.min(p - 3, 9 - p, 1), -1);
  let u = "rgb";
  const c = [Math.round(s(0) * 255), Math.round(s(8) * 255), Math.round(s(4) * 255)];
  return e.type === "hsla" && (u += "a", c.push(t[3])), Dg({
    type: u,
    values: c
  });
}
function Ux(e) {
  e = is(e);
  let t = e.type === "hsl" || e.type === "hsla" ? is(oT(e)).values : e.values;
  return t = t.map((n) => (e.type !== "color" && (n /= 255), n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));
}
function vse(e, t) {
  const n = Ux(e), r = Ux(t);
  return (Math.max(n, r) + 0.05) / (Math.min(n, r) + 0.05);
}
function Zd(e, t) {
  return e = is(e), t = a_(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, Dg(e);
}
function sh(e, t, n) {
  try {
    return Zd(e, t);
  } catch {
    return e;
  }
}
function Pg(e, t) {
  if (e = is(e), t = a_(t), e.type.includes("hsl"))
    e.values[2] *= 1 - t;
  else if (e.type.includes("rgb") || e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] *= 1 - t;
  return Dg(e);
}
function At(e, t, n) {
  try {
    return Pg(e, t);
  } catch {
    return e;
  }
}
function Lg(e, t) {
  if (e = is(e), t = a_(t), e.type.includes("hsl"))
    e.values[2] += (100 - e.values[2]) * t;
  else if (e.type.includes("rgb"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (255 - e.values[n]) * t;
  else if (e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (1 - e.values[n]) * t;
  return Dg(e);
}
function Nt(e, t, n) {
  try {
    return Lg(e, t);
  } catch {
    return e;
  }
}
function bse(e, t = 0.15) {
  return Ux(e) > 0.5 ? Pg(e, t) : Lg(e, t);
}
function lh(e, t, n) {
  try {
    return bse(e, t);
  } catch {
    return e;
  }
}
function wse(e, t) {
  return () => null;
}
wse(Ge.elementType);
Ge.oneOfType([Ge.func, Ge.object]);
function Bh(e) {
  const t = S.useRef(e);
  return hse(() => {
    t.current = e;
  }), S.useRef((...n) => (
    // @ts-expect-error hide `this`
    (0, t.current)(...n)
  )).current;
}
function Hx(...e) {
  const t = S.useRef(void 0), n = S.useCallback((r) => {
    const o = e.map((i) => {
      if (i == null)
        return null;
      if (typeof i == "function") {
        const s = i, u = s(r);
        return typeof u == "function" ? u : () => {
          s(null);
        };
      }
      return i.current = r, () => {
        i.current = null;
      };
    });
    return () => {
      o.forEach((i) => i?.());
    };
  }, e);
  return S.useMemo(() => e.every((r) => r == null) ? null : (r) => {
    t.current && (t.current(), t.current = void 0), r != null && (t.current = n(r));
  }, e);
}
const t3 = {};
function iT(e, t) {
  const n = S.useRef(t3);
  return n.current === t3 && (n.current = e(t)), n;
}
const xse = [];
function Sse(e) {
  S.useEffect(e, xse);
}
class s_ {
  constructor() {
    xh(this, "currentId", null), xh(this, "clear", () => {
      this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);
    }), xh(this, "disposeEffect", () => this.clear);
  }
  static create() {
    return new s_();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(t, n) {
    this.clear(), this.currentId = setTimeout(() => {
      this.currentId = null, n();
    }, t);
  }
}
function _se() {
  const e = iT(s_.create).current;
  return Sse(e.disposeEffect), e;
}
function n3(e) {
  try {
    return e.matches(":focus-visible");
  } catch {
  }
  return !1;
}
function kse(e) {
  return typeof e == "string";
}
function Ese(e, t, n) {
  return e === void 0 || kse(e) ? t : {
    ...t,
    ownerState: {
      ...t.ownerState,
      ...n
    }
  };
}
function Cse(e, t = []) {
  if (e === void 0)
    return {};
  const n = {};
  return Object.keys(e).filter((r) => r.match(/^on[A-Z]/) && typeof e[r] == "function" && !t.includes(r)).forEach((r) => {
    n[r] = e[r];
  }), n;
}
function r3(e) {
  if (e === void 0)
    return {};
  const t = {};
  return Object.keys(e).filter((n) => !(n.match(/^on[A-Z]/) && typeof e[n] == "function")).forEach((n) => {
    t[n] = e[n];
  }), t;
}
function Ose(e) {
  const {
    getSlotProps: t,
    additionalProps: n,
    externalSlotProps: r,
    externalForwardedProps: o,
    className: i
  } = e;
  if (!t) {
    const y = pn(n?.className, i, o?.className, r?.className), b = {
      ...n?.style,
      ...o?.style,
      ...r?.style
    }, v = {
      ...n,
      ...o,
      ...r
    };
    return y.length > 0 && (v.className = y), Object.keys(b).length > 0 && (v.style = b), {
      props: v,
      internalRef: void 0
    };
  }
  const s = Cse({
    ...o,
    ...r
  }), u = r3(r), c = r3(o), d = t(s), p = pn(d?.className, n?.className, i, o?.className, r?.className), h = {
    ...d?.style,
    ...n?.style,
    ...o?.style,
    ...r?.style
  }, g = {
    ...d,
    ...n,
    ...c,
    ...u
  };
  return p.length > 0 && (g.className = p), Object.keys(h).length > 0 && (g.style = h), {
    props: g,
    internalRef: d.ref
  };
}
function Ase(e, t, n) {
  return typeof e == "function" ? e(t, n) : e;
}
const Nse = /* @__PURE__ */ S.createContext(void 0);
function Mse(e) {
  const {
    theme: t,
    name: n,
    props: r
  } = e;
  if (!t || !t.components || !t.components[n])
    return r;
  const o = t.components[n];
  return o.defaultProps ? Fx(o.defaultProps, r) : !o.styleOverrides && !o.variants ? Fx(o, r) : r;
}
function Rse({
  props: e,
  name: t
}) {
  const n = S.useContext(Nse);
  return Mse({
    props: e,
    name: t,
    theme: {
      components: n
    }
  });
}
const o3 = {
  theme: void 0
};
function jse(e) {
  let t, n;
  return function(r) {
    let o = t;
    return (o === void 0 || r.theme !== n) && (o3.theme = r.theme, o = nT(e(o3)), t = o, n = r.theme), o;
  };
}
function zse(e = "") {
  function t(...n) {
    if (!n.length)
      return "";
    const r = n[0];
    return typeof r == "string" && !r.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/) ? `, var(--${e ? `${e}-` : ""}${r}${t(...n.slice(1))})` : `, ${r}`;
  }
  return (n, ...r) => `var(--${e ? `${e}-` : ""}${n}${t(...r)})`;
}
const i3 = (e, t, n, r = []) => {
  let o = e;
  t.forEach((i, s) => {
    s === t.length - 1 ? Array.isArray(o) ? o[Number(i)] = n : o && typeof o == "object" && (o[i] = n) : o && typeof o == "object" && (o[i] || (o[i] = r.includes(i) ? [] : {}), o = o[i]);
  });
}, Tse = (e, t, n) => {
  function r(o, i = [], s = []) {
    Object.entries(o).forEach(([u, c]) => {
      (!n || n && !n([...i, u])) && c != null && (typeof c == "object" && Object.keys(c).length > 0 ? r(c, [...i, u], Array.isArray(c) ? [...s, u] : s) : t([...i, u], c, s));
    });
  }
  r(e);
}, Dse = (e, t) => typeof t == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((n) => e.includes(n)) || e[e.length - 1].toLowerCase().includes("opacity") ? t : `${t}px` : t;
function Jb(e, t) {
  const {
    prefix: n,
    shouldSkipGeneratingVar: r
  } = t || {}, o = {}, i = {}, s = {};
  return Tse(
    e,
    (u, c, d) => {
      if ((typeof c == "string" || typeof c == "number") && (!r || !r(u, c))) {
        const p = `--${n ? `${n}-` : ""}${u.join("-")}`, h = Dse(u, c);
        Object.assign(o, {
          [p]: h
        }), i3(i, u, `var(${p})`, d), i3(s, u, `var(${p}, ${h})`, d);
      }
    },
    (u) => u[0] === "vars"
    // skip 'vars/*' paths
  ), {
    css: o,
    vars: i,
    varsWithDefaults: s
  };
}
function Pse(e, t = {}) {
  const {
    getSelector: n = x,
    disableCssColorScheme: r,
    colorSchemeSelector: o
  } = t, {
    colorSchemes: i = {},
    components: s,
    defaultColorScheme: u = "light",
    ...c
  } = e, {
    vars: d,
    css: p,
    varsWithDefaults: h
  } = Jb(c, t);
  let g = h;
  const y = {}, {
    [u]: b,
    ...v
  } = i;
  if (Object.entries(v || {}).forEach(([_, O]) => {
    const {
      vars: C,
      css: N,
      varsWithDefaults: R
    } = Jb(O, t);
    g = Fr(g, R), y[_] = {
      css: N,
      vars: C
    };
  }), b) {
    const {
      css: _,
      vars: O,
      varsWithDefaults: C
    } = Jb(b, t);
    g = Fr(g, C), y[u] = {
      css: _,
      vars: O
    };
  }
  function x(_, O) {
    var C, N;
    let R = o;
    if (o === "class" && (R = ".%s"), o === "data" && (R = "[data-%s]"), o != null && o.startsWith("data-") && !o.includes("%s") && (R = `[${o}="%s"]`), _) {
      if (R === "media")
        return e.defaultColorScheme === _ ? ":root" : {
          [`@media (prefers-color-scheme: ${((N = (C = i[_]) == null ? void 0 : C.palette) == null ? void 0 : N.mode) || _})`]: {
            ":root": O
          }
        };
      if (R)
        return e.defaultColorScheme === _ ? `:root, ${R.replace("%s", String(_))}` : R.replace("%s", String(_));
    }
    return ":root";
  }
  return {
    vars: g,
    generateThemeVars: () => {
      let _ = {
        ...d
      };
      return Object.entries(y).forEach(([, {
        vars: O
      }]) => {
        _ = Fr(_, O);
      }), _;
    },
    generateStyleSheets: () => {
      var _, O;
      const C = [], N = e.defaultColorScheme || "light";
      function R(I, $) {
        Object.keys($).length && C.push(typeof I == "string" ? {
          [I]: {
            ...$
          }
        } : I);
      }
      R(n(void 0, {
        ...p
      }), p);
      const {
        [N]: z,
        ...j
      } = y;
      if (z) {
        const {
          css: I
        } = z, $ = (O = (_ = i[N]) == null ? void 0 : _.palette) == null ? void 0 : O.mode, A = !r && $ ? {
          colorScheme: $,
          ...I
        } : {
          ...I
        };
        R(n(N, {
          ...A
        }), A);
      }
      return Object.entries(j).forEach(([I, {
        css: $
      }]) => {
        var A, V;
        const U = (V = (A = i[I]) == null ? void 0 : A.palette) == null ? void 0 : V.mode, W = !r && U ? {
          colorScheme: U,
          ...$
        } : {
          ...$
        };
        R(n(I, {
          ...W
        }), W);
      }), C;
    }
  };
}
function Lse(e) {
  return function(t) {
    return e === "media" ? `@media (prefers-color-scheme: ${t})` : e ? e.startsWith("data-") && !e.includes("%s") ? `[${e}="${t}"] &` : e === "class" ? `.${t} &` : e === "data" ? `[data-${t}] &` : `${e.replace("%s", t)} &` : "&";
  };
}
const Kd = {
  black: "#000",
  white: "#fff"
}, Ise = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
}, Jl = {
  50: "#f3e5f5",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  700: "#7b1fa2"
}, eu = {
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  700: "#d32f2f",
  800: "#c62828"
}, rd = {
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  700: "#f57c00",
  900: "#e65100"
}, tu = {
  50: "#e3f2fd",
  200: "#90caf9",
  400: "#42a5f5",
  700: "#1976d2",
  800: "#1565c0"
}, nu = {
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  700: "#0288d1",
  900: "#01579b"
}, ru = {
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20"
};
function aT() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: Kd.white,
      default: Kd.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const Vse = aT();
function sT() {
  return {
    text: {
      primary: Kd.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: Kd.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const a3 = sT();
function s3(e, t, n, r) {
  const o = r.light || r, i = r.dark || r * 1.5;
  e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : t === "light" ? e.light = Lg(e.main, o) : t === "dark" && (e.dark = Pg(e.main, i)));
}
function Bse(e = "light") {
  return e === "dark" ? {
    main: tu[200],
    light: tu[50],
    dark: tu[400]
  } : {
    main: tu[700],
    light: tu[400],
    dark: tu[800]
  };
}
function Fse(e = "light") {
  return e === "dark" ? {
    main: Jl[200],
    light: Jl[50],
    dark: Jl[400]
  } : {
    main: Jl[500],
    light: Jl[300],
    dark: Jl[700]
  };
}
function Use(e = "light") {
  return e === "dark" ? {
    main: eu[500],
    light: eu[300],
    dark: eu[700]
  } : {
    main: eu[700],
    light: eu[400],
    dark: eu[800]
  };
}
function Hse(e = "light") {
  return e === "dark" ? {
    main: nu[400],
    light: nu[300],
    dark: nu[700]
  } : {
    main: nu[700],
    light: nu[500],
    dark: nu[900]
  };
}
function $se(e = "light") {
  return e === "dark" ? {
    main: ru[400],
    light: ru[300],
    dark: ru[700]
  } : {
    main: ru[800],
    light: ru[500],
    dark: ru[900]
  };
}
function Yse(e = "light") {
  return e === "dark" ? {
    main: rd[400],
    light: rd[300],
    dark: rd[700]
  } : {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: rd[500],
    dark: rd[900]
  };
}
function l_(e) {
  const {
    mode: t = "light",
    contrastThreshold: n = 3,
    tonalOffset: r = 0.2,
    ...o
  } = e, i = e.primary || Bse(t), s = e.secondary || Fse(t), u = e.error || Use(t), c = e.info || Hse(t), d = e.success || $se(t), p = e.warning || Yse(t);
  function h(b) {
    return vse(b, a3.text.primary) >= n ? a3.text.primary : Vse.text.primary;
  }
  const g = ({
    color: b,
    name: v,
    mainShade: x = 500,
    lightShade: _ = 300,
    darkShade: O = 700
  }) => {
    if (b = {
      ...b
    }, !b.main && b[x] && (b.main = b[x]), !b.hasOwnProperty("main"))
      throw new Error(ol(11, v ? ` (${v})` : "", x));
    if (typeof b.main != "string")
      throw new Error(ol(12, v ? ` (${v})` : "", JSON.stringify(b.main)));
    return s3(b, "light", _, r), s3(b, "dark", O, r), b.contrastText || (b.contrastText = h(b.main)), b;
  };
  let y;
  return t === "light" ? y = aT() : t === "dark" && (y = sT()), Fr({
    // A collection of common colors.
    common: {
      ...Kd
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: t,
    // The colors used to represent primary interface elements for a user.
    primary: g({
      color: i,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: g({
      color: s,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: g({
      color: u,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: g({
      color: p,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: g({
      color: c,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: g({
      color: d,
      name: "success"
    }),
    // The grey colors.
    grey: Ise,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: n,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: h,
    // Generate a rich color object.
    augmentColor: g,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: r,
    // The light and dark mode object.
    ...y
  }, o);
}
function qse(e) {
  const t = {};
  return Object.entries(e).forEach((n) => {
    const [r, o] = n;
    typeof o == "object" && (t[r] = `${o.fontStyle ? `${o.fontStyle} ` : ""}${o.fontVariant ? `${o.fontVariant} ` : ""}${o.fontWeight ? `${o.fontWeight} ` : ""}${o.fontStretch ? `${o.fontStretch} ` : ""}${o.fontSize || ""}${o.lineHeight ? `/${o.lineHeight} ` : ""}${o.fontFamily || ""}`);
  }), t;
}
function Xse(e, t) {
  return {
    toolbar: {
      minHeight: 56,
      [e.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [e.up("sm")]: {
        minHeight: 64
      }
    },
    ...t
  };
}
function Wse(e) {
  return Math.round(e * 1e5) / 1e5;
}
const l3 = {
  textTransform: "uppercase"
}, u3 = '"Roboto", "Helvetica", "Arial", sans-serif';
function Gse(e, t) {
  const {
    fontFamily: n = u3,
    // The default font size of the Material Specification.
    fontSize: r = 14,
    // px
    fontWeightLight: o = 300,
    fontWeightRegular: i = 400,
    fontWeightMedium: s = 500,
    fontWeightBold: u = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize: c = 16,
    // Apply the CSS properties to all the variants.
    allVariants: d,
    pxToRem: p,
    ...h
  } = typeof t == "function" ? t(e) : t, g = r / 14, y = p || ((x) => `${x / c * g}rem`), b = (x, _, O, C, N) => ({
    fontFamily: n,
    fontWeight: x,
    fontSize: y(_),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: O,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...n === u3 ? {
      letterSpacing: `${Wse(C / _)}em`
    } : {},
    ...N,
    ...d
  }), v = {
    h1: b(o, 96, 1.167, -1.5),
    h2: b(o, 60, 1.2, -0.5),
    h3: b(i, 48, 1.167, 0),
    h4: b(i, 34, 1.235, 0.25),
    h5: b(i, 24, 1.334, 0),
    h6: b(s, 20, 1.6, 0.15),
    subtitle1: b(i, 16, 1.75, 0.15),
    subtitle2: b(s, 14, 1.57, 0.1),
    body1: b(i, 16, 1.5, 0.15),
    body2: b(i, 14, 1.43, 0.15),
    button: b(s, 14, 1.75, 0.4, l3),
    caption: b(i, 12, 1.66, 0.4),
    overline: b(i, 12, 2.66, 1, l3),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return Fr({
    htmlFontSize: c,
    pxToRem: y,
    fontFamily: n,
    fontSize: r,
    fontWeightLight: o,
    fontWeightRegular: i,
    fontWeightMedium: s,
    fontWeightBold: u,
    ...v
  }, h, {
    clone: !1
    // No need to clone deep
  });
}
const Zse = 0.2, Kse = 0.14, Qse = 0.12;
function Bt(...e) {
  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${Zse})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${Kse})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${Qse})`].join(",");
}
const Jse = ["none", Bt(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), Bt(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), Bt(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), Bt(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), Bt(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), Bt(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), Bt(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), Bt(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), Bt(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), Bt(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), Bt(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), Bt(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), Bt(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), Bt(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), Bt(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), Bt(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), Bt(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), Bt(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), Bt(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), Bt(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), Bt(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), Bt(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), Bt(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), Bt(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], ele = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}, tle = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function c3(e) {
  return `${Math.round(e)}ms`;
}
function nle(e) {
  if (!e)
    return 0;
  const t = e / 36;
  return Math.min(Math.round((4 + 15 * t ** 0.25 + t / 5) * 10), 3e3);
}
function rle(e) {
  const t = {
    ...ele,
    ...e.easing
  }, n = {
    ...tle,
    ...e.duration
  };
  return {
    getAutoHeightDuration: nle,
    create: (r = ["all"], o = {}) => {
      const {
        duration: i = n.standard,
        easing: s = t.easeInOut,
        delay: u = 0,
        ...c
      } = o;
      return (Array.isArray(r) ? r : [r]).map((d) => `${d} ${typeof i == "string" ? i : c3(i)} ${s} ${typeof u == "string" ? u : c3(u)}`).join(",");
    },
    ...e,
    easing: t,
    duration: n
  };
}
const ole = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function ile(e) {
  return Ui(e) || typeof e > "u" || typeof e == "string" || typeof e == "boolean" || typeof e == "number" || Array.isArray(e);
}
function lT(e = {}) {
  const t = {
    ...e
  };
  function n(r) {
    const o = Object.entries(r);
    for (let i = 0; i < o.length; i++) {
      const [s, u] = o[i];
      !ile(u) || s.startsWith("unstable_") ? delete r[s] : Ui(u) && (r[s] = {
        ...u
      }, n(r[s]));
    }
  }
  return n(t), `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(t, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function $x(e = {}, ...t) {
  const {
    breakpoints: n,
    mixins: r = {},
    spacing: o,
    palette: i = {},
    transitions: s = {},
    typography: u = {},
    shape: c,
    ...d
  } = e;
  if (e.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  e.generateThemeVars === void 0)
    throw new Error(ol(20));
  const p = l_(i), h = tT(e);
  let g = Fr(h, {
    mixins: Xse(h.breakpoints, r),
    palette: p,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: Jse.slice(),
    typography: Gse(p, u),
    transitions: rle(s),
    zIndex: {
      ...ole
    }
  });
  return g = Fr(g, d), g = t.reduce((y, b) => Fr(y, b), g), g.unstable_sxConfig = {
    ...Ng,
    ...d?.unstable_sxConfig
  }, g.unstable_sx = function(y) {
    return Lu({
      sx: y,
      theme: this
    });
  }, g.toRuntimeSource = lT, g;
}
function ale(e) {
  let t;
  return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, Math.round(t * 10) / 1e3;
}
const sle = [...Array(25)].map((e, t) => {
  if (t === 0)
    return "none";
  const n = ale(t);
  return `linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`;
});
function uT(e) {
  return {
    inputPlaceholder: e === "dark" ? 0.5 : 0.42,
    inputUnderline: e === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: e === "dark" ? 0.2 : 0.12,
    switchTrack: e === "dark" ? 0.3 : 0.38
  };
}
function cT(e) {
  return e === "dark" ? sle : [];
}
function lle(e) {
  const {
    palette: t = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity: n,
    overlays: r,
    ...o
  } = e, i = l_(t);
  return {
    palette: i,
    opacity: {
      ...uT(i.mode),
      ...n
    },
    overlays: r || cT(i.mode),
    ...o
  };
}
function ule(e) {
  var t;
  return !!e[0].match(/(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!e[0].match(/sxConfig$/) || // ends with sxConfig
  e[0] === "palette" && !!((t = e[1]) != null && t.match(/(mode|contrastThreshold|tonalOffset)/));
}
const cle = (e) => [...[...Array(25)].map((t, n) => `--${e ? `${e}-` : ""}overlays-${n}`), `--${e ? `${e}-` : ""}palette-AppBar-darkBg`, `--${e ? `${e}-` : ""}palette-AppBar-darkColor`], dle = (e) => (t, n) => {
  const r = e.rootSelector || ":root", o = e.colorSchemeSelector;
  let i = o;
  if (o === "class" && (i = ".%s"), o === "data" && (i = "[data-%s]"), o != null && o.startsWith("data-") && !o.includes("%s") && (i = `[${o}="%s"]`), e.defaultColorScheme === t) {
    if (t === "dark") {
      const s = {};
      return cle(e.cssVarPrefix).forEach((u) => {
        s[u] = n[u], delete n[u];
      }), i === "media" ? {
        [r]: n,
        "@media (prefers-color-scheme: dark)": {
          [r]: s
        }
      } : i ? {
        [i.replace("%s", t)]: s,
        [`${r}, ${i.replace("%s", t)}`]: n
      } : {
        [r]: {
          ...n,
          ...s
        }
      };
    }
    if (i && i !== "media")
      return `${r}, ${i.replace("%s", String(t))}`;
  } else if (t) {
    if (i === "media")
      return {
        [`@media (prefers-color-scheme: ${String(t)})`]: {
          [r]: n
        }
      };
    if (i)
      return i.replace("%s", String(t));
  }
  return r;
};
function fle(e, t) {
  t.forEach((n) => {
    e[n] || (e[n] = {});
  });
}
function de(e, t, n) {
  !e[t] && n && (e[t] = n);
}
function dd(e) {
  return typeof e != "string" || !e.startsWith("hsl") ? e : oT(e);
}
function Vi(e, t) {
  `${t}Channel` in e || (e[`${t}Channel`] = cd(dd(e[t])));
}
function ple(e) {
  return typeof e == "number" ? `${e}px` : typeof e == "string" || typeof e == "function" || Array.isArray(e) ? e : "8px";
}
const Zo = (e) => {
  try {
    return e();
  } catch {
  }
}, hle = (e = "mui") => zse(e);
function ew(e, t, n, r) {
  if (!t)
    return;
  t = t === !0 ? {} : t;
  const o = r === "dark" ? "dark" : "light";
  if (!n) {
    e[r] = lle({
      ...t,
      palette: {
        mode: o,
        ...t?.palette
      }
    });
    return;
  }
  const {
    palette: i,
    ...s
  } = $x({
    ...n,
    palette: {
      mode: o,
      ...t?.palette
    }
  });
  return e[r] = {
    ...t,
    palette: i,
    opacity: {
      ...uT(o),
      ...t?.opacity
    },
    overlays: t?.overlays || cT(o)
  }, s;
}
function mle(e = {}, ...t) {
  const {
    colorSchemes: n = {
      light: !0
    },
    defaultColorScheme: r,
    disableCssColorScheme: o = !1,
    cssVarPrefix: i = "mui",
    shouldSkipGeneratingVar: s = ule,
    colorSchemeSelector: u = n.light && n.dark ? "media" : void 0,
    rootSelector: c = ":root",
    ...d
  } = e, p = Object.keys(n)[0], h = r || (n.light && p !== "light" ? "light" : p), g = hle(i), {
    [h]: y,
    light: b,
    dark: v,
    ...x
  } = n, _ = {
    ...x
  };
  let O = y;
  if ((h === "dark" && !("dark" in n) || h === "light" && !("light" in n)) && (O = !0), !O)
    throw new Error(ol(21, h));
  const C = ew(_, O, d, h);
  b && !_.light && ew(_, b, void 0, "light"), v && !_.dark && ew(_, v, void 0, "dark");
  let N = {
    defaultColorScheme: h,
    ...C,
    cssVarPrefix: i,
    colorSchemeSelector: u,
    rootSelector: c,
    getCssVar: g,
    colorSchemes: _,
    font: {
      ...qse(C.typography),
      ...C.font
    },
    spacing: ple(d.spacing)
  };
  Object.keys(N.colorSchemes).forEach(($) => {
    const A = N.colorSchemes[$].palette, V = (U) => {
      const W = U.split("-"), D = W[1], F = W[2];
      return g(U, A[D][F]);
    };
    if (A.mode === "light" && (de(A.common, "background", "#fff"), de(A.common, "onBackground", "#000")), A.mode === "dark" && (de(A.common, "background", "#000"), de(A.common, "onBackground", "#fff")), fle(A, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]), A.mode === "light") {
      de(A.Alert, "errorColor", At(A.error.light, 0.6)), de(A.Alert, "infoColor", At(A.info.light, 0.6)), de(A.Alert, "successColor", At(A.success.light, 0.6)), de(A.Alert, "warningColor", At(A.warning.light, 0.6)), de(A.Alert, "errorFilledBg", V("palette-error-main")), de(A.Alert, "infoFilledBg", V("palette-info-main")), de(A.Alert, "successFilledBg", V("palette-success-main")), de(A.Alert, "warningFilledBg", V("palette-warning-main")), de(A.Alert, "errorFilledColor", Zo(() => A.getContrastText(A.error.main))), de(A.Alert, "infoFilledColor", Zo(() => A.getContrastText(A.info.main))), de(A.Alert, "successFilledColor", Zo(() => A.getContrastText(A.success.main))), de(A.Alert, "warningFilledColor", Zo(() => A.getContrastText(A.warning.main))), de(A.Alert, "errorStandardBg", Nt(A.error.light, 0.9)), de(A.Alert, "infoStandardBg", Nt(A.info.light, 0.9)), de(A.Alert, "successStandardBg", Nt(A.success.light, 0.9)), de(A.Alert, "warningStandardBg", Nt(A.warning.light, 0.9)), de(A.Alert, "errorIconColor", V("palette-error-main")), de(A.Alert, "infoIconColor", V("palette-info-main")), de(A.Alert, "successIconColor", V("palette-success-main")), de(A.Alert, "warningIconColor", V("palette-warning-main")), de(A.AppBar, "defaultBg", V("palette-grey-100")), de(A.Avatar, "defaultBg", V("palette-grey-400")), de(A.Button, "inheritContainedBg", V("palette-grey-300")), de(A.Button, "inheritContainedHoverBg", V("palette-grey-A100")), de(A.Chip, "defaultBorder", V("palette-grey-400")), de(A.Chip, "defaultAvatarColor", V("palette-grey-700")), de(A.Chip, "defaultIconColor", V("palette-grey-700")), de(A.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"), de(A.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"), de(A.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"), de(A.LinearProgress, "primaryBg", Nt(A.primary.main, 0.62)), de(A.LinearProgress, "secondaryBg", Nt(A.secondary.main, 0.62)), de(A.LinearProgress, "errorBg", Nt(A.error.main, 0.62)), de(A.LinearProgress, "infoBg", Nt(A.info.main, 0.62)), de(A.LinearProgress, "successBg", Nt(A.success.main, 0.62)), de(A.LinearProgress, "warningBg", Nt(A.warning.main, 0.62)), de(A.Skeleton, "bg", `rgba(${V("palette-text-primaryChannel")} / 0.11)`), de(A.Slider, "primaryTrack", Nt(A.primary.main, 0.62)), de(A.Slider, "secondaryTrack", Nt(A.secondary.main, 0.62)), de(A.Slider, "errorTrack", Nt(A.error.main, 0.62)), de(A.Slider, "infoTrack", Nt(A.info.main, 0.62)), de(A.Slider, "successTrack", Nt(A.success.main, 0.62)), de(A.Slider, "warningTrack", Nt(A.warning.main, 0.62));
      const U = lh(A.background.default, 0.8);
      de(A.SnackbarContent, "bg", U), de(A.SnackbarContent, "color", Zo(() => A.getContrastText(U))), de(A.SpeedDialAction, "fabHoverBg", lh(A.background.paper, 0.15)), de(A.StepConnector, "border", V("palette-grey-400")), de(A.StepContent, "border", V("palette-grey-400")), de(A.Switch, "defaultColor", V("palette-common-white")), de(A.Switch, "defaultDisabledColor", V("palette-grey-100")), de(A.Switch, "primaryDisabledColor", Nt(A.primary.main, 0.62)), de(A.Switch, "secondaryDisabledColor", Nt(A.secondary.main, 0.62)), de(A.Switch, "errorDisabledColor", Nt(A.error.main, 0.62)), de(A.Switch, "infoDisabledColor", Nt(A.info.main, 0.62)), de(A.Switch, "successDisabledColor", Nt(A.success.main, 0.62)), de(A.Switch, "warningDisabledColor", Nt(A.warning.main, 0.62)), de(A.TableCell, "border", Nt(sh(A.divider, 1), 0.88)), de(A.Tooltip, "bg", sh(A.grey[700], 0.92));
    }
    if (A.mode === "dark") {
      de(A.Alert, "errorColor", Nt(A.error.light, 0.6)), de(A.Alert, "infoColor", Nt(A.info.light, 0.6)), de(A.Alert, "successColor", Nt(A.success.light, 0.6)), de(A.Alert, "warningColor", Nt(A.warning.light, 0.6)), de(A.Alert, "errorFilledBg", V("palette-error-dark")), de(A.Alert, "infoFilledBg", V("palette-info-dark")), de(A.Alert, "successFilledBg", V("palette-success-dark")), de(A.Alert, "warningFilledBg", V("palette-warning-dark")), de(A.Alert, "errorFilledColor", Zo(() => A.getContrastText(A.error.dark))), de(A.Alert, "infoFilledColor", Zo(() => A.getContrastText(A.info.dark))), de(A.Alert, "successFilledColor", Zo(() => A.getContrastText(A.success.dark))), de(A.Alert, "warningFilledColor", Zo(() => A.getContrastText(A.warning.dark))), de(A.Alert, "errorStandardBg", At(A.error.light, 0.9)), de(A.Alert, "infoStandardBg", At(A.info.light, 0.9)), de(A.Alert, "successStandardBg", At(A.success.light, 0.9)), de(A.Alert, "warningStandardBg", At(A.warning.light, 0.9)), de(A.Alert, "errorIconColor", V("palette-error-main")), de(A.Alert, "infoIconColor", V("palette-info-main")), de(A.Alert, "successIconColor", V("palette-success-main")), de(A.Alert, "warningIconColor", V("palette-warning-main")), de(A.AppBar, "defaultBg", V("palette-grey-900")), de(A.AppBar, "darkBg", V("palette-background-paper")), de(A.AppBar, "darkColor", V("palette-text-primary")), de(A.Avatar, "defaultBg", V("palette-grey-600")), de(A.Button, "inheritContainedBg", V("palette-grey-800")), de(A.Button, "inheritContainedHoverBg", V("palette-grey-700")), de(A.Chip, "defaultBorder", V("palette-grey-700")), de(A.Chip, "defaultAvatarColor", V("palette-grey-300")), de(A.Chip, "defaultIconColor", V("palette-grey-300")), de(A.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"), de(A.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"), de(A.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"), de(A.LinearProgress, "primaryBg", At(A.primary.main, 0.5)), de(A.LinearProgress, "secondaryBg", At(A.secondary.main, 0.5)), de(A.LinearProgress, "errorBg", At(A.error.main, 0.5)), de(A.LinearProgress, "infoBg", At(A.info.main, 0.5)), de(A.LinearProgress, "successBg", At(A.success.main, 0.5)), de(A.LinearProgress, "warningBg", At(A.warning.main, 0.5)), de(A.Skeleton, "bg", `rgba(${V("palette-text-primaryChannel")} / 0.13)`), de(A.Slider, "primaryTrack", At(A.primary.main, 0.5)), de(A.Slider, "secondaryTrack", At(A.secondary.main, 0.5)), de(A.Slider, "errorTrack", At(A.error.main, 0.5)), de(A.Slider, "infoTrack", At(A.info.main, 0.5)), de(A.Slider, "successTrack", At(A.success.main, 0.5)), de(A.Slider, "warningTrack", At(A.warning.main, 0.5));
      const U = lh(A.background.default, 0.98);
      de(A.SnackbarContent, "bg", U), de(A.SnackbarContent, "color", Zo(() => A.getContrastText(U))), de(A.SpeedDialAction, "fabHoverBg", lh(A.background.paper, 0.15)), de(A.StepConnector, "border", V("palette-grey-600")), de(A.StepContent, "border", V("palette-grey-600")), de(A.Switch, "defaultColor", V("palette-grey-300")), de(A.Switch, "defaultDisabledColor", V("palette-grey-600")), de(A.Switch, "primaryDisabledColor", At(A.primary.main, 0.55)), de(A.Switch, "secondaryDisabledColor", At(A.secondary.main, 0.55)), de(A.Switch, "errorDisabledColor", At(A.error.main, 0.55)), de(A.Switch, "infoDisabledColor", At(A.info.main, 0.55)), de(A.Switch, "successDisabledColor", At(A.success.main, 0.55)), de(A.Switch, "warningDisabledColor", At(A.warning.main, 0.55)), de(A.TableCell, "border", At(sh(A.divider, 1), 0.68)), de(A.Tooltip, "bg", sh(A.grey[700], 0.92));
    }
    Vi(A.background, "default"), Vi(A.background, "paper"), Vi(A.common, "background"), Vi(A.common, "onBackground"), Vi(A, "divider"), Object.keys(A).forEach((U) => {
      const W = A[U];
      U !== "tonalOffset" && W && typeof W == "object" && (W.main && de(A[U], "mainChannel", cd(dd(W.main))), W.light && de(A[U], "lightChannel", cd(dd(W.light))), W.dark && de(A[U], "darkChannel", cd(dd(W.dark))), W.contrastText && de(A[U], "contrastTextChannel", cd(dd(W.contrastText))), U === "text" && (Vi(A[U], "primary"), Vi(A[U], "secondary")), U === "action" && (W.active && Vi(A[U], "active"), W.selected && Vi(A[U], "selected")));
    });
  }), N = t.reduce(($, A) => Fr($, A), N);
  const R = {
    prefix: i,
    disableCssColorScheme: o,
    shouldSkipGeneratingVar: s,
    getSelector: dle(N)
  }, {
    vars: z,
    generateThemeVars: j,
    generateStyleSheets: I
  } = Pse(N, R);
  return N.vars = z, Object.entries(N.colorSchemes[N.defaultColorScheme]).forEach(([$, A]) => {
    N[$] = A;
  }), N.generateThemeVars = j, N.generateStyleSheets = I, N.generateSpacing = function() {
    return eT(d.spacing, Q0(this));
  }, N.getColorSchemeSelector = Lse(u), N.spacing = N.generateSpacing(), N.shouldSkipGeneratingVar = s, N.unstable_sxConfig = {
    ...Ng,
    ...d?.unstable_sxConfig
  }, N.unstable_sx = function($) {
    return Lu({
      sx: $,
      theme: this
    });
  }, N.toRuntimeSource = lT, N;
}
function d3(e, t, n) {
  e.colorSchemes && n && (e.colorSchemes[t] = {
    ...n !== !0 && n,
    palette: l_({
      ...n === !0 ? {} : n.palette,
      mode: t
    })
    // cast type to skip module augmentation test
  });
}
function gle(e = {}, ...t) {
  const {
    palette: n,
    cssVariables: r = !1,
    colorSchemes: o = n ? void 0 : {
      light: !0
    },
    defaultColorScheme: i = n?.mode,
    ...s
  } = e, u = i || "light", c = o?.[u], d = {
    ...o,
    ...n ? {
      [u]: {
        ...typeof c != "boolean" && c,
        palette: n
      }
    } : void 0
  };
  if (r === !1) {
    if (!("colorSchemes" in e))
      return $x(e, ...t);
    let p = n;
    "palette" in e || d[u] && (d[u] !== !0 ? p = d[u].palette : u === "dark" && (p = {
      mode: "dark"
    }));
    const h = $x({
      ...e,
      palette: p
    }, ...t);
    return h.defaultColorScheme = u, h.colorSchemes = d, h.palette.mode === "light" && (h.colorSchemes.light = {
      ...d.light !== !0 && d.light,
      palette: h.palette
    }, d3(h, "dark", d.dark)), h.palette.mode === "dark" && (h.colorSchemes.dark = {
      ...d.dark !== !0 && d.dark,
      palette: h.palette
    }, d3(h, "light", d.light)), h;
  }
  return !n && !("light" in d) && u === "light" && (d.light = !0), mle({
    ...s,
    colorSchemes: d,
    defaultColorScheme: u,
    ...typeof r != "boolean" && r
  }, ...t);
}
const yle = gle(), vle = "$$material";
function ble(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
const wle = (e) => ble(e) && e !== "classes", ho = use({
  themeId: vle,
  defaultTheme: yle,
  rootShouldForwardProp: wle
}), Zu = jse;
function bi(e) {
  return Rse(e);
}
function xle(e) {
  return yi("MuiTable", e);
}
vi("MuiTable", ["root", "stickyHeader"]);
const Sle = (e) => {
  const {
    classes: t,
    stickyHeader: n
  } = e;
  return sa({
    root: ["root", n && "stickyHeader"]
  }, xle, t);
}, _le = ho("table", {
  name: "MuiTable",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.stickyHeader && t.stickyHeader];
  }
})(Zu(({
  theme: e
}) => ({
  display: "table",
  width: "100%",
  borderCollapse: "collapse",
  borderSpacing: 0,
  "& caption": {
    ...e.typography.body2,
    padding: e.spacing(2),
    color: (e.vars || e).palette.text.secondary,
    textAlign: "left",
    captionSide: "bottom"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.stickyHeader,
    style: {
      borderCollapse: "separate"
    }
  }]
}))), f3 = "table", kle = /* @__PURE__ */ S.forwardRef(function(e, t) {
  const n = bi({
    props: e,
    name: "MuiTable"
  }), {
    className: r,
    component: o = f3,
    padding: i = "normal",
    size: s = "medium",
    stickyHeader: u = !1,
    ...c
  } = n, d = {
    ...n,
    component: o,
    padding: i,
    size: s,
    stickyHeader: u
  }, p = Sle(d), h = S.useMemo(() => ({
    padding: i,
    size: s,
    stickyHeader: u
  }), [i, s, u]);
  return /* @__PURE__ */ E.jsx(Dz.Provider, {
    value: h,
    children: /* @__PURE__ */ E.jsx(_le, {
      as: o,
      role: o === f3 ? null : "table",
      ref: t,
      className: pn(p.root, r),
      ownerState: d,
      ...c
    })
  });
}), Ig = /* @__PURE__ */ S.createContext();
function Ele(e) {
  return yi("MuiTableBody", e);
}
vi("MuiTableBody", ["root"]);
const Cle = (e) => {
  const {
    classes: t
  } = e;
  return sa({
    root: ["root"]
  }, Ele, t);
}, Ole = ho("tbody", {
  name: "MuiTableBody",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "table-row-group"
}), Ale = {
  variant: "body"
}, p3 = "tbody", Nle = /* @__PURE__ */ S.forwardRef(function(e, t) {
  const n = bi({
    props: e,
    name: "MuiTableBody"
  }), {
    className: r,
    component: o = p3,
    ...i
  } = n, s = {
    ...n,
    component: o
  }, u = Cle(s);
  return /* @__PURE__ */ E.jsx(Ig.Provider, {
    value: Ale,
    children: /* @__PURE__ */ E.jsx(Ole, {
      className: pn(u.root, r),
      as: o,
      ref: t,
      role: o === p3 ? null : "rowgroup",
      ownerState: s,
      ...i
    })
  });
});
function Mle(e) {
  return yi("MuiTableCell", e);
}
const Rle = vi("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]), jle = (e) => {
  const {
    classes: t,
    variant: n,
    align: r,
    padding: o,
    size: i,
    stickyHeader: s
  } = e, u = {
    root: ["root", n, s && "stickyHeader", r !== "inherit" && `align${tr(r)}`, o !== "normal" && `padding${tr(o)}`, `size${tr(i)}`]
  };
  return sa(u, Mle, t);
}, zle = ho("td", {
  name: "MuiTableCell",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], t[`size${tr(n.size)}`], n.padding !== "normal" && t[`padding${tr(n.padding)}`], n.align !== "inherit" && t[`align${tr(n.align)}`], n.stickyHeader && t.stickyHeader];
  }
})(Zu(({
  theme: e
}) => ({
  ...e.typography.body2,
  display: "table-cell",
  verticalAlign: "inherit",
  // Workaround for a rendering bug with spanned columns in Chrome 62.0.
  // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
  borderBottom: e.vars ? `1px solid ${e.vars.palette.TableCell.border}` : `1px solid
    ${e.palette.mode === "light" ? Lg(Zd(e.palette.divider, 1), 0.88) : Pg(Zd(e.palette.divider, 1), 0.68)}`,
  textAlign: "left",
  padding: 16,
  variants: [{
    props: {
      variant: "head"
    },
    style: {
      color: (e.vars || e).palette.text.primary,
      lineHeight: e.typography.pxToRem(24),
      fontWeight: e.typography.fontWeightMedium
    }
  }, {
    props: {
      variant: "body"
    },
    style: {
      color: (e.vars || e).palette.text.primary
    }
  }, {
    props: {
      variant: "footer"
    },
    style: {
      color: (e.vars || e).palette.text.secondary,
      lineHeight: e.typography.pxToRem(21),
      fontSize: e.typography.pxToRem(12)
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      padding: "6px 16px",
      [`&.${Rle.paddingCheckbox}`]: {
        width: 24,
        // prevent the checkbox column from growing
        padding: "0 12px 0 16px",
        "& > *": {
          padding: 0
        }
      }
    }
  }, {
    props: {
      padding: "checkbox"
    },
    style: {
      width: 48,
      // prevent the checkbox column from growing
      padding: "0 0 0 4px"
    }
  }, {
    props: {
      padding: "none"
    },
    style: {
      padding: 0
    }
  }, {
    props: {
      align: "left"
    },
    style: {
      textAlign: "left"
    }
  }, {
    props: {
      align: "center"
    },
    style: {
      textAlign: "center"
    }
  }, {
    props: {
      align: "right"
    },
    style: {
      textAlign: "right",
      flexDirection: "row-reverse"
    }
  }, {
    props: {
      align: "justify"
    },
    style: {
      textAlign: "justify"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.stickyHeader,
    style: {
      position: "sticky",
      top: 0,
      zIndex: 2,
      backgroundColor: (e.vars || e).palette.background.default
    }
  }]
}))), h3 = /* @__PURE__ */ S.forwardRef(function(e, t) {
  const n = bi({
    props: e,
    name: "MuiTableCell"
  }), {
    align: r = "inherit",
    className: o,
    component: i,
    padding: s,
    scope: u,
    size: c,
    sortDirection: d,
    variant: p,
    ...h
  } = n, g = S.useContext(Dz), y = S.useContext(Ig), b = y && y.variant === "head";
  let v;
  i ? v = i : v = b ? "th" : "td";
  let x = u;
  v === "td" ? x = void 0 : !x && b && (x = "col");
  const _ = p || y && y.variant, O = {
    ...n,
    align: r,
    component: v,
    padding: s || (g && g.padding ? g.padding : "normal"),
    size: c || (g && g.size ? g.size : "medium"),
    sortDirection: d,
    stickyHeader: _ === "head" && g && g.stickyHeader,
    variant: _
  }, C = jle(O);
  let N = null;
  return d && (N = d === "asc" ? "ascending" : "descending"), /* @__PURE__ */ E.jsx(zle, {
    as: v,
    ref: t,
    className: pn(C.root, o),
    "aria-sort": N,
    scope: x,
    ownerState: O,
    ...h
  });
});
function Tle(e) {
  return yi("MuiTableContainer", e);
}
vi("MuiTableContainer", ["root"]);
const Dle = (e) => {
  const {
    classes: t
  } = e;
  return sa({
    root: ["root"]
  }, Tle, t);
}, Ple = ho("div", {
  name: "MuiTableContainer",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  width: "100%",
  overflowX: "auto"
}), Lle = /* @__PURE__ */ S.forwardRef(function(e, t) {
  const n = bi({
    props: e,
    name: "MuiTableContainer"
  }), {
    className: r,
    component: o = "div",
    ...i
  } = n, s = {
    ...n,
    component: o
  }, u = Dle(s);
  return /* @__PURE__ */ E.jsx(Ple, {
    ref: t,
    as: o,
    className: pn(u.root, r),
    ownerState: s,
    ...i
  });
});
function Ile(e) {
  return yi("MuiTableHead", e);
}
vi("MuiTableHead", ["root"]);
const Vle = (e) => {
  const {
    classes: t
  } = e;
  return sa({
    root: ["root"]
  }, Ile, t);
}, Ble = ho("thead", {
  name: "MuiTableHead",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "table-header-group"
}), Fle = {
  variant: "head"
}, m3 = "thead", Ule = /* @__PURE__ */ S.forwardRef(function(e, t) {
  const n = bi({
    props: e,
    name: "MuiTableHead"
  }), {
    className: r,
    component: o = m3,
    ...i
  } = n, s = {
    ...n,
    component: o
  }, u = Vle(s);
  return /* @__PURE__ */ E.jsx(Ig.Provider, {
    value: Fle,
    children: /* @__PURE__ */ E.jsx(Ble, {
      as: o,
      className: pn(u.root, r),
      ref: t,
      role: o === m3 ? null : "rowgroup",
      ownerState: s,
      ...i
    })
  });
});
function Hle(e) {
  return yi("MuiTableRow", e);
}
const g3 = vi("MuiTableRow", ["root", "selected", "hover", "head", "footer"]), $le = (e) => {
  const {
    classes: t,
    selected: n,
    hover: r,
    head: o,
    footer: i
  } = e;
  return sa({
    root: ["root", n && "selected", r && "hover", o && "head", i && "footer"]
  }, Hle, t);
}, Yle = ho("tr", {
  name: "MuiTableRow",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.head && t.head, n.footer && t.footer];
  }
})(Zu(({
  theme: e
}) => ({
  color: "inherit",
  display: "table-row",
  verticalAlign: "middle",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  [`&.${g3.hover}:hover`]: {
    backgroundColor: (e.vars || e).palette.action.hover
  },
  [`&.${g3.selected}`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Zd(e.palette.primary.main, e.palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : Zd(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity)
    }
  }
}))), y3 = "tr", v3 = /* @__PURE__ */ S.forwardRef(function(e, t) {
  const n = bi({
    props: e,
    name: "MuiTableRow"
  }), {
    className: r,
    component: o = y3,
    hover: i = !1,
    selected: s = !1,
    ...u
  } = n, c = S.useContext(Ig), d = {
    ...n,
    component: o,
    hover: i,
    selected: s,
    head: c && c.variant === "head",
    footer: c && c.variant === "footer"
  }, p = $le(d);
  return /* @__PURE__ */ E.jsx(Yle, {
    as: o,
    ref: t,
    className: pn(p.root, r),
    role: o === y3 ? null : "row",
    ownerState: d,
    ...u
  });
});
class wm {
  constructor() {
    xh(this, "mountEffect", () => {
      this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0, this.mounted.resolve());
    }), this.ref = {
      current: null
    }, this.mounted = null, this.didMount = !1, this.shouldMount = !1, this.setShouldMount = null;
  }
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new wm();
  }
  static use() {
    const t = iT(wm.create).current, [n, r] = S.useState(!1);
    return t.shouldMount = n, t.setShouldMount = r, S.useEffect(t.mountEffect, [n]), t;
  }
  mount() {
    return this.mounted || (this.mounted = Xle(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted;
  }
  /* Ripple API */
  start(...t) {
    this.mount().then(() => {
      var n;
      return (n = this.ref.current) == null ? void 0 : n.start(...t);
    });
  }
  stop(...t) {
    this.mount().then(() => {
      var n;
      return (n = this.ref.current) == null ? void 0 : n.stop(...t);
    });
  }
  pulsate(...t) {
    this.mount().then(() => {
      var n;
      return (n = this.ref.current) == null ? void 0 : n.pulsate(...t);
    });
  }
}
function qle() {
  return wm.use();
}
function Xle() {
  let e, t;
  const n = new Promise((r, o) => {
    e = r, t = o;
  });
  return n.resolve = e, n.reject = t, n;
}
function u_(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function xm(e, t) {
  return xm = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, xm(e, t);
}
function dT(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, xm(e, t);
}
const b3 = Qe.createContext(null);
function fT(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function c_(e, t) {
  var n = function(o) {
    return t && S.isValidElement(o) ? t(o) : o;
  }, r = /* @__PURE__ */ Object.create(null);
  return e && S.Children.map(e, function(o) {
    return o;
  }).forEach(function(o) {
    r[o.key] = n(o);
  }), r;
}
function Wle(e, t) {
  e = e || {}, t = t || {};
  function n(p) {
    return p in t ? t[p] : e[p];
  }
  var r = /* @__PURE__ */ Object.create(null), o = [];
  for (var i in e)
    i in t ? o.length && (r[i] = o, o = []) : o.push(i);
  var s, u = {};
  for (var c in t) {
    if (r[c])
      for (s = 0; s < r[c].length; s++) {
        var d = r[c][s];
        u[r[c][s]] = n(d);
      }
    u[c] = n(c);
  }
  for (s = 0; s < o.length; s++)
    u[o[s]] = n(o[s]);
  return u;
}
function Hs(e, t, n) {
  return n[t] != null ? n[t] : e.props[t];
}
function Gle(e, t) {
  return c_(e.children, function(n) {
    return S.cloneElement(n, {
      onExited: t.bind(null, n),
      in: !0,
      appear: Hs(n, "appear", e),
      enter: Hs(n, "enter", e),
      exit: Hs(n, "exit", e)
    });
  });
}
function Zle(e, t, n) {
  var r = c_(e.children), o = Wle(t, r);
  return Object.keys(o).forEach(function(i) {
    var s = o[i];
    if (S.isValidElement(s)) {
      var u = i in t, c = i in r, d = t[i], p = S.isValidElement(d) && !d.props.in;
      c && (!u || p) ? o[i] = S.cloneElement(s, {
        onExited: n.bind(null, s),
        in: !0,
        exit: Hs(s, "exit", e),
        enter: Hs(s, "enter", e)
      }) : !c && u && !p ? o[i] = S.cloneElement(s, {
        in: !1
      }) : c && u && S.isValidElement(d) && (o[i] = S.cloneElement(s, {
        onExited: n.bind(null, s),
        in: d.props.in,
        exit: Hs(s, "exit", e),
        enter: Hs(s, "enter", e)
      }));
    }
  }), o;
}
var Kle = Object.values || function(e) {
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}, Qle = {
  component: "div",
  childFactory: function(e) {
    return e;
  }
}, d_ = /* @__PURE__ */ function(e) {
  dT(t, e);
  function t(r, o) {
    var i;
    i = e.call(this, r, o) || this;
    var s = i.handleExited.bind(fT(i));
    return i.state = {
      contextValue: {
        isMounting: !0
      },
      handleExited: s,
      firstRender: !0
    }, i;
  }
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.mounted = !0, this.setState({
      contextValue: {
        isMounting: !1
      }
    });
  }, n.componentWillUnmount = function() {
    this.mounted = !1;
  }, t.getDerivedStateFromProps = function(r, o) {
    var i = o.children, s = o.handleExited, u = o.firstRender;
    return {
      children: u ? Gle(r, s) : Zle(r, i, s),
      firstRender: !1
    };
  }, n.handleExited = function(r, o) {
    var i = c_(this.props.children);
    r.key in i || (r.props.onExited && r.props.onExited(o), this.mounted && this.setState(function(s) {
      var u = Te({}, s.children);
      return delete u[r.key], {
        children: u
      };
    }));
  }, n.render = function() {
    var r = this.props, o = r.component, i = r.childFactory, s = u_(r, ["component", "childFactory"]), u = this.state.contextValue, c = Kle(this.state.children).map(i);
    return delete s.appear, delete s.enter, delete s.exit, o === null ? /* @__PURE__ */ Qe.createElement(b3.Provider, {
      value: u
    }, c) : /* @__PURE__ */ Qe.createElement(b3.Provider, {
      value: u
    }, /* @__PURE__ */ Qe.createElement(o, s, c));
  }, t;
}(Qe.Component);
d_.propTypes = {};
d_.defaultProps = Qle;
function Jle(e) {
  const {
    className: t,
    classes: n,
    pulsate: r = !1,
    rippleX: o,
    rippleY: i,
    rippleSize: s,
    in: u,
    onExited: c,
    timeout: d
  } = e, [p, h] = S.useState(!1), g = pn(t, n.ripple, n.rippleVisible, r && n.ripplePulsate), y = {
    width: s,
    height: s,
    top: -(s / 2) + i,
    left: -(s / 2) + o
  }, b = pn(n.child, p && n.childLeaving, r && n.childPulsate);
  return !u && !p && h(!0), S.useEffect(() => {
    if (!u && c != null) {
      const v = setTimeout(c, d);
      return () => {
        clearTimeout(v);
      };
    }
  }, [c, u, d]), /* @__PURE__ */ E.jsx("span", {
    className: g,
    style: y,
    children: /* @__PURE__ */ E.jsx("span", {
      className: b
    })
  });
}
const ao = vi("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), Yx = 550, eue = 80, tue = Tg`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`, nue = Tg`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`, rue = Tg`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`, oue = ho("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
}), iue = ho(Jle, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${ao.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${tue};
    animation-duration: ${Yx}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  &.${ao.ripplePulsate} {
    animation-duration: ${({
  theme: e
}) => e.transitions.duration.shorter}ms;
  }

  & .${ao.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${ao.childLeaving} {
    opacity: 0;
    animation-name: ${nue};
    animation-duration: ${Yx}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  & .${ao.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${rue};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`, aue = /* @__PURE__ */ S.forwardRef(function(e, t) {
  const n = bi({
    props: e,
    name: "MuiTouchRipple"
  }), {
    center: r = !1,
    classes: o = {},
    className: i,
    ...s
  } = n, [u, c] = S.useState([]), d = S.useRef(0), p = S.useRef(null);
  S.useEffect(() => {
    p.current && (p.current(), p.current = null);
  }, [u]);
  const h = S.useRef(!1), g = _se(), y = S.useRef(null), b = S.useRef(null), v = S.useCallback((C) => {
    const {
      pulsate: N,
      rippleX: R,
      rippleY: z,
      rippleSize: j,
      cb: I
    } = C;
    c(($) => [...$, /* @__PURE__ */ E.jsx(iue, {
      classes: {
        ripple: pn(o.ripple, ao.ripple),
        rippleVisible: pn(o.rippleVisible, ao.rippleVisible),
        ripplePulsate: pn(o.ripplePulsate, ao.ripplePulsate),
        child: pn(o.child, ao.child),
        childLeaving: pn(o.childLeaving, ao.childLeaving),
        childPulsate: pn(o.childPulsate, ao.childPulsate)
      },
      timeout: Yx,
      pulsate: N,
      rippleX: R,
      rippleY: z,
      rippleSize: j
    }, d.current)]), d.current += 1, p.current = I;
  }, [o]), x = S.useCallback((C = {}, N = {}, R = () => {
  }) => {
    const {
      pulsate: z = !1,
      center: j = r || N.pulsate,
      fakeElement: I = !1
      // For test purposes
    } = N;
    if (C?.type === "mousedown" && h.current) {
      h.current = !1;
      return;
    }
    C?.type === "touchstart" && (h.current = !0);
    const $ = I ? null : b.current, A = $ ? $.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let V, U, W;
    if (j || C === void 0 || C.clientX === 0 && C.clientY === 0 || !C.clientX && !C.touches)
      V = Math.round(A.width / 2), U = Math.round(A.height / 2);
    else {
      const {
        clientX: D,
        clientY: F
      } = C.touches && C.touches.length > 0 ? C.touches[0] : C;
      V = Math.round(D - A.left), U = Math.round(F - A.top);
    }
    if (j)
      W = Math.sqrt((2 * A.width ** 2 + A.height ** 2) / 3), W % 2 === 0 && (W += 1);
    else {
      const D = Math.max(Math.abs(($ ? $.clientWidth : 0) - V), V) * 2 + 2, F = Math.max(Math.abs(($ ? $.clientHeight : 0) - U), U) * 2 + 2;
      W = Math.sqrt(D ** 2 + F ** 2);
    }
    C != null && C.touches ? y.current === null && (y.current = () => {
      v({
        pulsate: z,
        rippleX: V,
        rippleY: U,
        rippleSize: W,
        cb: R
      });
    }, g.start(eue, () => {
      y.current && (y.current(), y.current = null);
    })) : v({
      pulsate: z,
      rippleX: V,
      rippleY: U,
      rippleSize: W,
      cb: R
    });
  }, [r, v, g]), _ = S.useCallback(() => {
    x({}, {
      pulsate: !0
    });
  }, [x]), O = S.useCallback((C, N) => {
    if (g.clear(), C?.type === "touchend" && y.current) {
      y.current(), y.current = null, g.start(0, () => {
        O(C, N);
      });
      return;
    }
    y.current = null, c((R) => R.length > 0 ? R.slice(1) : R), p.current = N;
  }, [g]);
  return S.useImperativeHandle(t, () => ({
    pulsate: _,
    start: x,
    stop: O
  }), [_, x, O]), /* @__PURE__ */ E.jsx(oue, {
    className: pn(ao.root, o.root, i),
    ref: b,
    ...s,
    children: /* @__PURE__ */ E.jsx(d_, {
      component: null,
      exit: !0,
      children: u
    })
  });
});
function sue(e) {
  return yi("MuiButtonBase", e);
}
const lue = vi("MuiButtonBase", ["root", "disabled", "focusVisible"]), uue = (e) => {
  const {
    disabled: t,
    focusVisible: n,
    focusVisibleClassName: r,
    classes: o
  } = e, i = sa({
    root: ["root", t && "disabled", n && "focusVisible"]
  }, sue, o);
  return n && r && (i.root += ` ${r}`), i;
}, cue = ho("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${lue.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
}), due = /* @__PURE__ */ S.forwardRef(function(e, t) {
  const n = bi({
    props: e,
    name: "MuiButtonBase"
  }), {
    action: r,
    centerRipple: o = !1,
    children: i,
    className: s,
    component: u = "button",
    disabled: c = !1,
    disableRipple: d = !1,
    disableTouchRipple: p = !1,
    focusRipple: h = !1,
    focusVisibleClassName: g,
    LinkComponent: y = "a",
    onBlur: b,
    onClick: v,
    onContextMenu: x,
    onDragLeave: _,
    onFocus: O,
    onFocusVisible: C,
    onKeyDown: N,
    onKeyUp: R,
    onMouseDown: z,
    onMouseLeave: j,
    onMouseUp: I,
    onTouchEnd: $,
    onTouchMove: A,
    onTouchStart: V,
    tabIndex: U = 0,
    TouchRippleProps: W,
    touchRippleRef: D,
    type: F,
    ...P
  } = n, H = S.useRef(null), Y = qle(), q = Hx(Y.ref, D), [M, X] = S.useState(!1);
  c && M && X(!1), S.useImperativeHandle(r, () => ({
    focusVisible: () => {
      X(!0), H.current.focus();
    }
  }), []);
  const K = Y.shouldMount && !d && !c;
  S.useEffect(() => {
    M && h && !d && Y.pulsate();
  }, [d, h, M, Y]);
  const L = Bi(Y, "start", z, p), ee = Bi(Y, "stop", x, p), ae = Bi(Y, "stop", _, p), le = Bi(Y, "stop", I, p), me = Bi(Y, "stop", (De) => {
    M && De.preventDefault(), j && j(De);
  }, p), se = Bi(Y, "start", V, p), he = Bi(Y, "stop", $, p), _e = Bi(Y, "stop", A, p), Se = Bi(Y, "stop", (De) => {
    n3(De.target) || X(!1), b && b(De);
  }, !1), Ee = Bh((De) => {
    H.current || (H.current = De.currentTarget), n3(De.target) && (X(!0), C && C(De)), O && O(De);
  }), Ie = () => {
    const De = H.current;
    return u && u !== "button" && !(De.tagName === "A" && De.href);
  }, $e = Bh((De) => {
    h && !De.repeat && M && De.key === " " && Y.stop(De, () => {
      Y.start(De);
    }), De.target === De.currentTarget && Ie() && De.key === " " && De.preventDefault(), N && N(De), De.target === De.currentTarget && Ie() && De.key === "Enter" && !c && (De.preventDefault(), v && v(De));
  }), ct = Bh((De) => {
    h && De.key === " " && M && !De.defaultPrevented && Y.stop(De, () => {
      Y.pulsate(De);
    }), R && R(De), v && De.target === De.currentTarget && Ie() && De.key === " " && !De.defaultPrevented && v(De);
  });
  let $t = u;
  $t === "button" && (P.href || P.to) && ($t = y);
  const ft = {};
  $t === "button" ? (ft.type = F === void 0 ? "button" : F, ft.disabled = c) : (!P.href && !P.to && (ft.role = "button"), c && (ft["aria-disabled"] = c));
  const br = Hx(t, H), on = {
    ...n,
    centerRipple: o,
    component: u,
    disabled: c,
    disableRipple: d,
    disableTouchRipple: p,
    focusRipple: h,
    tabIndex: U,
    focusVisible: M
  }, vn = uue(on);
  return /* @__PURE__ */ E.jsxs(cue, {
    as: $t,
    className: pn(vn.root, s),
    ownerState: on,
    onBlur: Se,
    onClick: v,
    onContextMenu: ee,
    onFocus: Ee,
    onKeyDown: $e,
    onKeyUp: ct,
    onMouseDown: L,
    onMouseLeave: me,
    onMouseUp: le,
    onDragLeave: ae,
    onTouchEnd: he,
    onTouchMove: _e,
    onTouchStart: se,
    ref: br,
    tabIndex: c ? -1 : U,
    type: F,
    ...ft,
    ...P,
    children: [i, K ? /* @__PURE__ */ E.jsx(aue, {
      ref: q,
      center: o,
      ...W
    }) : null]
  });
});
function Bi(e, t, n, r = !1) {
  return Bh((o) => (n && n(o), r || e[t](o), !0));
}
function fue(e) {
  return yi("MuiSvgIcon", e);
}
vi("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const pue = (e) => {
  const {
    color: t,
    fontSize: n,
    classes: r
  } = e, o = {
    root: ["root", t !== "inherit" && `color${tr(t)}`, `fontSize${tr(n)}`]
  };
  return sa(o, fue, r);
}, hue = ho("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color !== "inherit" && t[`color${tr(n.color)}`], t[`fontSize${tr(n.fontSize)}`]];
  }
})(Zu(({
  theme: e
}) => {
  var t, n, r, o, i, s, u, c, d, p, h, g, y, b;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    flexShrink: 0,
    transition: (o = (t = e.transitions) == null ? void 0 : t.create) == null ? void 0 : o.call(t, "fill", {
      duration: (r = (n = (e.vars ?? e).transitions) == null ? void 0 : n.duration) == null ? void 0 : r.shorter
    }),
    variants: [
      {
        props: (v) => !v.hasSvgAsChild,
        style: {
          // the <svg> will define the property that has `currentColor`
          // for example heroicons uses fill="none" and stroke="currentColor"
          fill: "currentColor"
        }
      },
      {
        props: {
          fontSize: "inherit"
        },
        style: {
          fontSize: "inherit"
        }
      },
      {
        props: {
          fontSize: "small"
        },
        style: {
          fontSize: ((s = (i = e.typography) == null ? void 0 : i.pxToRem) == null ? void 0 : s.call(i, 20)) || "1.25rem"
        }
      },
      {
        props: {
          fontSize: "medium"
        },
        style: {
          fontSize: ((c = (u = e.typography) == null ? void 0 : u.pxToRem) == null ? void 0 : c.call(u, 24)) || "1.5rem"
        }
      },
      {
        props: {
          fontSize: "large"
        },
        style: {
          fontSize: ((p = (d = e.typography) == null ? void 0 : d.pxToRem) == null ? void 0 : p.call(d, 35)) || "2.1875rem"
        }
      },
      // TODO v5 deprecate color prop, v6 remove for sx
      ...Object.entries((e.vars ?? e).palette).filter(([, v]) => v && v.main).map(([v]) => {
        var x, _;
        return {
          props: {
            color: v
          },
          style: {
            color: (_ = (x = (e.vars ?? e).palette) == null ? void 0 : x[v]) == null ? void 0 : _.main
          }
        };
      }),
      {
        props: {
          color: "action"
        },
        style: {
          color: (g = (h = (e.vars ?? e).palette) == null ? void 0 : h.action) == null ? void 0 : g.active
        }
      },
      {
        props: {
          color: "disabled"
        },
        style: {
          color: (b = (y = (e.vars ?? e).palette) == null ? void 0 : y.action) == null ? void 0 : b.disabled
        }
      },
      {
        props: {
          color: "inherit"
        },
        style: {
          color: void 0
        }
      }
    ]
  };
})), qx = /* @__PURE__ */ S.forwardRef(function(e, t) {
  const n = bi({
    props: e,
    name: "MuiSvgIcon"
  }), {
    children: r,
    className: o,
    color: i = "inherit",
    component: s = "svg",
    fontSize: u = "medium",
    htmlColor: c,
    inheritViewBox: d = !1,
    titleAccess: p,
    viewBox: h = "0 0 24 24",
    ...g
  } = n, y = /* @__PURE__ */ S.isValidElement(r) && r.type === "svg", b = {
    ...n,
    color: i,
    component: s,
    fontSize: u,
    instanceFontSize: e.fontSize,
    inheritViewBox: d,
    viewBox: h,
    hasSvgAsChild: y
  }, v = {};
  d || (v.viewBox = h);
  const x = pue(b);
  return /* @__PURE__ */ E.jsxs(hue, {
    as: s,
    className: pn(x.root, o),
    focusable: "false",
    color: c,
    "aria-hidden": p ? void 0 : !0,
    role: p ? "img" : void 0,
    ref: t,
    ...v,
    ...g,
    ...y && r.props,
    ownerState: b,
    children: [y ? r.props.children : r, p ? /* @__PURE__ */ E.jsx("title", {
      children: p
    }) : null]
  });
});
qx.muiName = "SvgIcon";
function mue(e, t) {
  function n(r, o) {
    return /* @__PURE__ */ E.jsx(qx, {
      "data-testid": void 0,
      ref: o,
      ...r,
      children: e
    });
  }
  return n.muiName = qx.muiName, /* @__PURE__ */ S.memo(/* @__PURE__ */ S.forwardRef(n));
}
const gue = mue(/* @__PURE__ */ E.jsx("path", {
  d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
}));
function yue(e) {
  return yi("MuiTableSortLabel", e);
}
const tw = vi("MuiTableSortLabel", ["root", "active", "icon", "iconDirectionDesc", "iconDirectionAsc", "directionDesc", "directionAsc"]);
function w3(e, t) {
  const {
    className: n,
    elementType: r,
    ownerState: o,
    externalForwardedProps: i,
    internalForwardedProps: s,
    shouldForwardComponentProp: u = !1,
    ...c
  } = t, {
    component: d,
    slots: p = {
      [e]: void 0
    },
    slotProps: h = {
      [e]: void 0
    },
    ...g
  } = i, y = p[e] || r, b = Ase(h[e], o), {
    props: {
      component: v,
      ...x
    },
    internalRef: _
  } = Ose({
    className: n,
    ...c,
    externalForwardedProps: e === "root" ? g : void 0,
    externalSlotProps: b
  }), O = Hx(_, b?.ref, t.ref), C = e === "root" ? v || d : v, N = Ese(y, {
    ...e === "root" && !d && !p[e] && s,
    ...e !== "root" && !p[e] && s,
    ...x,
    ...C && !u && {
      as: C
    },
    ...C && u && {
      component: C
    },
    ref: O
  }, o);
  return [y, N];
}
const vue = (e) => {
  const {
    classes: t,
    direction: n,
    active: r
  } = e, o = {
    root: ["root", r && "active", `direction${tr(n)}`],
    icon: ["icon", `iconDirection${tr(n)}`]
  };
  return sa(o, yue, t);
}, bue = ho(due, {
  name: "MuiTableSortLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.active && t.active];
  }
})(Zu(({
  theme: e
}) => ({
  cursor: "pointer",
  display: "inline-flex",
  justifyContent: "flex-start",
  flexDirection: "inherit",
  alignItems: "center",
  "&:focus": {
    color: (e.vars || e).palette.text.secondary
  },
  "&:hover": {
    color: (e.vars || e).palette.text.secondary,
    [`& .${tw.icon}`]: {
      opacity: 0.5
    }
  },
  [`&.${tw.active}`]: {
    color: (e.vars || e).palette.text.primary,
    [`& .${tw.icon}`]: {
      opacity: 1,
      color: (e.vars || e).palette.text.secondary
    }
  }
}))), wue = ho("span", {
  name: "MuiTableSortLabel",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, t[`iconDirection${tr(n.direction)}`]];
  }
})(Zu(({
  theme: e
}) => ({
  fontSize: 18,
  marginRight: 4,
  marginLeft: 4,
  opacity: 0,
  transition: e.transitions.create(["opacity", "transform"], {
    duration: e.transitions.duration.shorter
  }),
  userSelect: "none",
  variants: [{
    props: {
      direction: "desc"
    },
    style: {
      transform: "rotate(0deg)"
    }
  }, {
    props: {
      direction: "asc"
    },
    style: {
      transform: "rotate(180deg)"
    }
  }]
}))), xue = /* @__PURE__ */ S.forwardRef(function(e, t) {
  const n = bi({
    props: e,
    name: "MuiTableSortLabel"
  }), {
    active: r = !1,
    children: o,
    className: i,
    direction: s = "asc",
    hideSortIcon: u = !1,
    IconComponent: c = gue,
    slots: d = {},
    slotProps: p = {},
    ...h
  } = n, g = {
    ...n,
    active: r,
    direction: s,
    hideSortIcon: u,
    IconComponent: c
  }, y = vue(g), b = {
    slots: d,
    slotProps: p
  }, [v, x] = w3("root", {
    elementType: bue,
    externalForwardedProps: b,
    ownerState: g,
    className: pn(y.root, i),
    ref: t
  }), [_, O] = w3("icon", {
    elementType: wue,
    externalForwardedProps: b,
    ownerState: g,
    className: y.icon
  });
  return /* @__PURE__ */ E.jsxs(v, {
    disableRipple: !0,
    component: "span",
    ...x,
    ...h,
    children: [o, u && !r ? null : /* @__PURE__ */ E.jsx(_, {
      as: c,
      ...O
    })]
  });
}), Sue = (e) => {
  const t = [];
  if (e === void 0)
    return {
      header: [],
      rows: []
    };
  e.data === void 0 && (e.data = []), e.columns === void 0 && (e.data.length === 0 ? e.columns = [] : e.columns = e.data[0].map((n, r) => `col${r}`)), e.index === void 0 && (e.index = e.data.map((n, r) => `row${r}`));
  for (let n = 0; n < e.index.length; n++) {
    const r = [e.index[n]];
    for (let o = 0; o < e.columns.length; o++)
      r.push(e.data[n][o]);
    t.push(r);
  }
  return {
    header: ["index", ...e.columns],
    rows: t
  };
}, _ue = ({ tabledata: e }) => {
  const t = S.useMemo(
    () => Sue(e),
    [e]
  ), [n, r] = S.useState("asc"), [o, i] = S.useState("index");
  let s = t.header.indexOf(o);
  s === -1 && (s = 0);
  const u = (h) => {
    r(o === h && n === "asc" ? "desc" : "asc"), i(h);
  }, c = (h, g) => {
    const y = h.map((b, v) => [
      b,
      v
    ]);
    return y.sort((b, v) => g(b[0], v[0])), y.map((b) => b[0]);
  }, d = (h, g) => h === "desc" ? (y, b) => b[s] < y[s] ? -1 : 1 : (y, b) => y[s] < b[s] ? -1 : 1, p = c(
    t.rows,
    d(n)
  );
  return /* @__PURE__ */ E.jsx(Lle, { className: "tablecontainer", children: /* @__PURE__ */ E.jsxs(kle, { size: "small", children: [
    /* @__PURE__ */ E.jsx(Ule, { className: "tableHead", children: /* @__PURE__ */ E.jsx(v3, { className: "tableheadercolor", children: t.header.map((h) => /* @__PURE__ */ E.jsx(
      h3,
      {
        sortDirection: o === h ? n : !1,
        className: "tableheadercolor",
        children: /* @__PURE__ */ E.jsx(
          xue,
          {
            active: o === h,
            direction: o === h ? n : "asc",
            onClick: () => u(h),
            className: "tableheadercolor",
            sx: {
              "& .MuiTableSortLabel-icon": {
                color: "inherit !important"
              }
            },
            children: h
          }
        )
      },
      h
    )) }) }),
    /* @__PURE__ */ E.jsx(Nle, { children: p.map((h, g) => /* @__PURE__ */ E.jsx(v3, { children: h.map((y, b) => /* @__PURE__ */ E.jsx(h3, { className: b == 0 ? "indexcol" : "datacol", children: y }, b)) }, e.index[g])) })
  ] }) });
};
var uh = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var x3;
function kue() {
  if (x3) return uh;
  x3 = 1;
  var e = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, t = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, n = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, r = /\\([\u000b\u0020-\u00ff])/g, o = /([\\"])/g, i = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  uh.format = s, uh.parse = u;
  function s(h) {
    if (!h || typeof h != "object")
      throw new TypeError("argument obj is required");
    var g = h.parameters, y = h.type;
    if (!y || !i.test(y))
      throw new TypeError("invalid type");
    var b = y;
    if (g && typeof g == "object")
      for (var v, x = Object.keys(g).sort(), _ = 0; _ < x.length; _++) {
        if (v = x[_], !n.test(v))
          throw new TypeError("invalid parameter name");
        b += "; " + v + "=" + d(g[v]);
      }
    return b;
  }
  function u(h) {
    if (!h)
      throw new TypeError("argument string is required");
    var g = typeof h == "object" ? c(h) : h;
    if (typeof g != "string")
      throw new TypeError("argument string is required to be a string");
    var y = g.indexOf(";"), b = y !== -1 ? g.slice(0, y).trim() : g.trim();
    if (!i.test(b))
      throw new TypeError("invalid media type");
    var v = new p(b.toLowerCase());
    if (y !== -1) {
      var x, _, O;
      for (e.lastIndex = y; _ = e.exec(g); ) {
        if (_.index !== y)
          throw new TypeError("invalid parameter format");
        y += _[0].length, x = _[1].toLowerCase(), O = _[2], O.charCodeAt(0) === 34 && (O = O.slice(1, -1), O.indexOf("\\") !== -1 && (O = O.replace(r, "$1"))), v.parameters[x] = O;
      }
      if (y !== g.length)
        throw new TypeError("invalid parameter format");
    }
    return v;
  }
  function c(h) {
    var g;
    if (typeof h.getHeader == "function" ? g = h.getHeader("content-type") : typeof h.headers == "object" && (g = h.headers && h.headers["content-type"]), typeof g != "string")
      throw new TypeError("content-type header is missing from object");
    return g;
  }
  function d(h) {
    var g = String(h);
    if (n.test(g))
      return g;
    if (g.length > 0 && !t.test(g))
      throw new TypeError("invalid parameter value");
    return '"' + g.replace(o, "\\$1") + '"';
  }
  function p(h) {
    this.parameters = /* @__PURE__ */ Object.create(null), this.type = h;
  }
  return uh;
}
var Eue = kue(), su = /* @__PURE__ */ new Map(), pT = function(e) {
  return e.cloneNode(!0);
}, S3 = function() {
  return window.location.protocol === "file:";
}, hT = function(e, t, n) {
  var r = new XMLHttpRequest();
  r.onreadystatechange = function() {
    try {
      if (!/\.svg/i.test(e) && r.readyState === 2) {
        var o = r.getResponseHeader("Content-Type");
        if (!o)
          throw new Error("Content type not found");
        var i = Eue.parse(o).type;
        if (!(i === "image/svg+xml" || i === "text/plain"))
          throw new Error("Invalid content type: ".concat(i));
      }
      if (r.readyState === 4) {
        if (r.status === 404 || r.responseXML === null)
          throw new Error(S3() ? "Note: SVG injection ajax calls do not work locally without adjusting security settings in your browser. Or consider using a local webserver." : "Unable to load SVG file: " + e);
        if (r.status === 200 || S3() && r.status === 0)
          n(null, r);
        else
          throw new Error("There was a problem injecting the SVG: " + r.status + " " + r.statusText);
      }
    } catch (s) {
      if (r.abort(), s instanceof Error)
        n(s, r);
      else
        throw s;
    }
  }, r.open("GET", e), r.withCredentials = t, r.overrideMimeType && r.overrideMimeType("text/xml"), r.send();
}, Xa = {}, _3 = function(e, t) {
  Xa[e] = Xa[e] || [], Xa[e].push(t);
}, Cue = function(e) {
  for (var t = function(o, i) {
    setTimeout(function() {
      if (Array.isArray(Xa[e])) {
        var s = su.get(e), u = Xa[e][o];
        s instanceof SVGSVGElement && u(null, pT(s)), s instanceof Error && u(s), o === Xa[e].length - 1 && delete Xa[e];
      }
    }, 0);
  }, n = 0, r = Xa[e].length; n < r; n++)
    t(n);
}, Oue = function(e, t, n) {
  if (su.has(e)) {
    var r = su.get(e);
    if (r === void 0) {
      _3(e, n);
      return;
    }
    if (r instanceof SVGSVGElement) {
      n(null, pT(r));
      return;
    }
  }
  su.set(e, void 0), _3(e, n), hT(e, t, function(o, i) {
    var s;
    o ? su.set(e, o) : ((s = i.responseXML) === null || s === void 0 ? void 0 : s.documentElement) instanceof SVGSVGElement && su.set(e, i.responseXML.documentElement), Cue(e);
  });
}, Aue = function(e, t, n) {
  hT(e, t, function(r, o) {
    var i;
    r ? n(r) : ((i = o.responseXML) === null || i === void 0 ? void 0 : i.documentElement) instanceof SVGSVGElement && n(null, o.responseXML.documentElement);
  });
}, Nue = 0, Mue = function() {
  return ++Nue;
}, Ko = [], k3 = {}, Rue = "http://www.w3.org/2000/svg", nw = "http://www.w3.org/1999/xlink", E3 = function(e, t, n, r, o, i, s) {
  var u = e.getAttribute("data-src") || e.getAttribute("src");
  if (!u) {
    s(new Error("Invalid data-src or src attribute"));
    return;
  }
  if (Ko.indexOf(e) !== -1) {
    Ko.splice(Ko.indexOf(e), 1), e = null;
    return;
  }
  Ko.push(e), e.setAttribute("src", "");
  var c = r ? Oue : Aue;
  c(u, o, function(d, p) {
    if (!p) {
      Ko.splice(Ko.indexOf(e), 1), e = null, s(d);
      return;
    }
    var h = e.getAttribute("id");
    h && p.setAttribute("id", h);
    var g = e.getAttribute("title");
    g && p.setAttribute("title", g);
    var y = e.getAttribute("width");
    y && p.setAttribute("width", y);
    var b = e.getAttribute("height");
    b && p.setAttribute("height", b);
    var v = Array.from(new Set(Nh(Nh(Nh([], (p.getAttribute("class") || "").split(" "), !0), ["injected-svg"], !1), (e.getAttribute("class") || "").split(" "), !0))).join(" ").trim();
    p.setAttribute("class", v);
    var x = e.getAttribute("style");
    x && p.setAttribute("style", x), p.setAttribute("data-src", u);
    var _ = [].filter.call(e.attributes, function(H) {
      return /^data-\w[\w-]*$/.test(H.name);
    });
    if (Array.prototype.forEach.call(_, function(H) {
      H.name && H.value && p.setAttribute(H.name, H.value);
    }), n) {
      var O = {
        clipPath: ["clip-path"],
        "color-profile": ["color-profile"],
        cursor: ["cursor"],
        filter: ["filter"],
        linearGradient: ["fill", "stroke"],
        marker: ["marker", "marker-start", "marker-mid", "marker-end"],
        mask: ["mask"],
        path: [],
        pattern: ["fill", "stroke"],
        radialGradient: ["fill", "stroke"]
      }, C, N, R, z, j;
      Object.keys(O).forEach(function(H) {
        C = H, R = O[H], N = p.querySelectorAll(C + "[id]");
        for (var Y = function(X, K) {
          z = N[X].id, j = z + "-" + Mue();
          var L;
          Array.prototype.forEach.call(R, function(Se) {
            L = p.querySelectorAll("[" + Se + '*="' + z + '"]');
            for (var Ee = 0, Ie = L.length; Ee < Ie; Ee++) {
              var $e = L[Ee].getAttribute(Se);
              $e && !$e.match(new RegExp('url\\("?#' + z + '"?\\)')) || L[Ee].setAttribute(Se, "url(#" + j + ")");
            }
          });
          for (var ee = p.querySelectorAll("[*|href]"), ae = [], le = 0, me = ee.length; le < me; le++) {
            var se = ee[le].getAttributeNS(nw, "href");
            se && se.toString() === "#" + N[X].id && ae.push(ee[le]);
          }
          for (var he = 0, _e = ae.length; he < _e; he++)
            ae[he].setAttributeNS(nw, "href", "#" + j);
          N[X].id = j;
        }, q = 0, M = N.length; q < M; q++)
          Y(q);
      });
    }
    p.removeAttribute("xmlns:a");
    for (var I = p.querySelectorAll("script"), $ = [], A, V, U = 0, W = I.length; U < W; U++)
      V = I[U].getAttribute("type"), (!V || V === "application/ecmascript" || V === "application/javascript" || V === "text/javascript") && (A = I[U].innerText || I[U].textContent, A && $.push(A), p.removeChild(I[U]));
    if ($.length > 0 && (t === "always" || t === "once" && !k3[u])) {
      for (var D = 0, F = $.length; D < F; D++)
        new Function($[D])(window);
      k3[u] = !0;
    }
    var P = p.querySelectorAll("style");
    if (Array.prototype.forEach.call(P, function(H) {
      H.textContent += "";
    }), p.setAttribute("xmlns", Rue), p.setAttribute("xmlns:xlink", nw), i(p), !e.parentNode) {
      Ko.splice(Ko.indexOf(e), 1), e = null, s(new Error("Parent node is null"));
      return;
    }
    e.parentNode.replaceChild(p, e), Ko.splice(Ko.indexOf(e), 1), e = null, s(null, p);
  });
}, jue = function(e, t) {
  var n = t === void 0 ? {} : t, r = n.afterAll, o = r === void 0 ? function() {
  } : r, i = n.afterEach, s = i === void 0 ? function() {
  } : i, u = n.beforeEach, c = u === void 0 ? function() {
  } : u, d = n.cacheRequests, p = d === void 0 ? !0 : d, h = n.evalScripts, g = h === void 0 ? "never" : h, y = n.httpRequestWithCredentials, b = y === void 0 ? !1 : y, v = n.renumerateIRIElements, x = v === void 0 ? !0 : v;
  if (e && "length" in e)
    for (var _ = 0, O = 0, C = e.length; O < C; O++)
      E3(e[O], g, x, p, b, c, function(N, R) {
        s(N, R), e && "length" in e && e.length === ++_ && o(_);
      });
  else e ? E3(e, g, x, p, b, c, function(N, R) {
    s(N, R), o(1), e = null;
  }) : o(0);
}, zue = function(e) {
  var t = e?.ownerDocument || document;
  return t.defaultView || window;
}, Tue = function(e, t) {
  for (var n in e)
    if (!(n in t))
      return !0;
  for (var r in t)
    if (e[r] !== t[r])
      return !0;
  return !1;
}, Due = ["afterInjection", "beforeInjection", "desc", "evalScripts", "fallback", "httpRequestWithCredentials", "loading", "renumerateIRIElements", "src", "title", "useRequestCache", "wrapper"], ch = "http://www.w3.org/2000/svg", C3 = "http://www.w3.org/1999/xlink", f_ = /* @__PURE__ */ function(e) {
  function t() {
    for (var r, o = arguments.length, i = new Array(o), s = 0; s < o; s++)
      i[s] = arguments[s];
    return r = e.call.apply(e, [this].concat(i)) || this, r.initialState = {
      hasError: !1,
      isLoading: !0
    }, r.state = r.initialState, r._isMounted = !1, r.reactWrapper = void 0, r.nonReactWrapper = void 0, r.refCallback = function(u) {
      r.reactWrapper = u;
    }, r;
  }
  dT(t, e);
  var n = t.prototype;
  return n.renderSVG = function() {
    var r = this;
    if (this.reactWrapper instanceof zue(this.reactWrapper).Node) {
      var o = this.props, i = o.desc, s = o.evalScripts, u = o.httpRequestWithCredentials, c = o.renumerateIRIElements, d = o.src, p = o.title, h = o.useRequestCache, g = this.props.onError, y = this.props.beforeInjection, b = this.props.afterInjection, v = this.props.wrapper, x, _;
      v === "svg" ? (x = document.createElementNS(ch, v), x.setAttribute("xmlns", ch), x.setAttribute("xmlns:xlink", C3), _ = document.createElementNS(ch, v)) : (x = document.createElement(v), _ = document.createElement(v)), x.appendChild(_), _.dataset.src = d, this.nonReactWrapper = this.reactWrapper.appendChild(x);
      var O = function(R) {
        if (r.removeSVG(), !r._isMounted) {
          g(R);
          return;
        }
        r.setState(function() {
          return {
            hasError: !0,
            isLoading: !1
          };
        }, function() {
          g(R);
        });
      }, C = function(R, z) {
        if (R) {
          O(R);
          return;
        }
        r._isMounted && r.setState(function() {
          return {
            isLoading: !1
          };
        }, function() {
          try {
            b(z);
          } catch (j) {
            O(j);
          }
        });
      }, N = function(R) {
        if (R.setAttribute("role", "img"), i) {
          var z = R.querySelector(":scope > desc");
          z && R.removeChild(z);
          var j = document.createElement("desc");
          j.innerHTML = i, R.prepend(j);
        }
        if (p) {
          var I = R.querySelector(":scope > title");
          I && R.removeChild(I);
          var $ = document.createElement("title");
          $.innerHTML = p, R.prepend($);
        }
        try {
          y(R);
        } catch (A) {
          O(A);
        }
      };
      jue(_, {
        afterEach: C,
        beforeEach: N,
        cacheRequests: h,
        evalScripts: s,
        httpRequestWithCredentials: u,
        renumerateIRIElements: c
      });
    }
  }, n.removeSVG = function() {
    var r;
    (r = this.nonReactWrapper) != null && r.parentNode && (this.nonReactWrapper.parentNode.removeChild(this.nonReactWrapper), this.nonReactWrapper = null);
  }, n.componentDidMount = function() {
    this._isMounted = !0, this.renderSVG();
  }, n.componentDidUpdate = function(r) {
    var o = this;
    Tue(Te({}, r), this.props) && this.setState(function() {
      return o.initialState;
    }, function() {
      o.removeSVG(), o.renderSVG();
    });
  }, n.componentWillUnmount = function() {
    this._isMounted = !1, this.removeSVG();
  }, n.render = function() {
    var r = this.props;
    r.afterInjection, r.beforeInjection, r.desc, r.evalScripts;
    var o = r.fallback;
    r.httpRequestWithCredentials;
    var i = r.loading;
    r.renumerateIRIElements, r.src, r.title, r.useRequestCache;
    var s = r.wrapper, u = u_(r, Due), c = s;
    return /* @__PURE__ */ S.createElement(c, Te({}, u, {
      ref: this.refCallback
    }, s === "svg" ? {
      xmlns: ch,
      xmlnsXlink: C3
    } : {}), this.state.isLoading && i && /* @__PURE__ */ S.createElement(i, null), this.state.hasError && o && /* @__PURE__ */ S.createElement(o, null));
  }, t;
}(S.Component);
f_.defaultProps = {
  afterInjection: function() {
  },
  beforeInjection: function() {
  },
  desc: "",
  evalScripts: "never",
  fallback: null,
  httpRequestWithCredentials: !1,
  loading: null,
  onError: function() {
  },
  renumerateIRIElements: !0,
  title: "",
  useRequestCache: !0,
  wrapper: "div"
};
f_.propTypes = {
  afterInjection: cn.func,
  beforeInjection: cn.func,
  desc: cn.string,
  evalScripts: cn.oneOf(["always", "once", "never"]),
  fallback: cn.oneOfType([cn.func, cn.object, cn.string]),
  httpRequestWithCredentials: cn.bool,
  loading: cn.oneOfType([cn.func, cn.object, cn.string]),
  onError: cn.func,
  renumerateIRIElements: cn.bool,
  src: cn.string.isRequired,
  title: cn.string,
  useRequestCache: cn.bool,
  wrapper: cn.oneOf(["div", "span", "svg"])
};
const Pue = ({ value: e }) => /* @__PURE__ */ E.jsx(
  f_,
  {
    src: `data:image/svg+xml;base64,${btoa(e)}`,
    style: {
      maxWidth: "100%",
      maxHeight: "100%"
    },
    beforeInjection: (t) => {
      t.classList.add("svg-class-name"), t.setAttribute("style", "max-width: 100%; max-height: 100%;"), t.setAttribute("width", "100%"), t.setAttribute("height", "100%");
    }
  }
), mT = ({
  value: e,
  preValue: t,
  onLoaded: n
}) => {
  const [r, o] = S.useState(t || e);
  if (S.useEffect(() => {
    if (e === t) return;
    const u = new Image();
    return u.onload = () => {
      n?.(), o(e);
    }, u.src = e, () => {
      u.onload = null;
    };
  }, [e, t, n]), r === void 0)
    return /* @__PURE__ */ E.jsx(E.Fragment, {});
  if (typeof r != "string")
    return console.error("ImageRenderer: value is not a string", r), /* @__PURE__ */ E.jsx(E.Fragment, {});
  const i = r.startsWith("data:") || r.startsWith("blob:");
  let s = r;
  return i || (s = "data:image/jpeg;base64," + r), /* @__PURE__ */ E.jsx("img", { src: s, style: { maxWidth: "100%", maxHeight: "100%" } });
}, gT = ({
  value: e
}) => /* @__PURE__ */ E.jsx(Pue, { value: e }), yT = ({
  value: e
}) => {
  let t = "";
  try {
    t = JSON.stringify(e);
  } catch {
  }
  return /* @__PURE__ */ E.jsx("div", { children: /* @__PURE__ */ E.jsx("pre", { children: t }) });
}, p_ = ({
  value: e
}) => {
  if (typeof e != "string" || e.length % 4 !== 0)
    return /* @__PURE__ */ E.jsx("div", { children: e });
  const t = Math.round(3 * e.length / 4);
  return /* @__PURE__ */ E.jsx("div", { children: /* @__PURE__ */ E.jsxs("pre", { children: [
    "Bytes(",
    t,
    ")"
  ] }) });
}, vT = ({
  value: e
}) => /* @__PURE__ */ E.jsx(
  _ue,
  {
    tabledata: e || {
      columns: [],
      index: [],
      data: []
    }
  }
), Vg = ({
  value: e
}) => /* @__PURE__ */ E.jsx(sie, { data: e }), Sm = Vg, Lue = {
  string: yT,
  table: vT,
  image: mT,
  svg: gT,
  dict: Vg,
  bytes: p_
};
function bT(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
function Iue(e) {
  const t = S.useRef({ value: e, previous: e });
  return S.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
}
var wT = ["PageUp", "PageDown"], xT = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], ST = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, Ku = "Slider", [Xx, Vue, Bue] = i0(Ku), [_T, Uve] = us(Ku, [
  Bue
]), [Fue, Bg] = _T(Ku), kT = S.forwardRef(
  (e, t) => {
    const {
      name: n,
      min: r = 0,
      max: o = 100,
      step: i = 1,
      orientation: s = "horizontal",
      disabled: u = !1,
      minStepsBetweenThumbs: c = 0,
      defaultValue: d = [r],
      value: p,
      onValueChange: h = () => {
      },
      onValueCommit: g = () => {
      },
      inverted: y = !1,
      form: b,
      ...v
    } = e, x = S.useRef(/* @__PURE__ */ new Set()), _ = S.useRef(0), O = s === "horizontal" ? Uue : Hue, [C = [], N] = Uu({
      prop: p,
      defaultProp: d,
      onChange: (A) => {
        var V;
        (V = [...x.current][_.current]) == null || V.focus(), h(A);
      }
    }), R = S.useRef(C);
    function z(A) {
      const V = Wue(C, A);
      $(A, V);
    }
    function j(A) {
      $(A, _.current);
    }
    function I() {
      const A = R.current[_.current];
      C[_.current] !== A && g(C);
    }
    function $(A, V, { commit: U } = { commit: !1 }) {
      const W = Que(i), D = Jue(Math.round((A - r) / i) * i + r, W), F = bT(D, [r, o]);
      N((P = []) => {
        const H = que(P, F, V);
        if (Kue(H, c * i)) {
          _.current = H.indexOf(F);
          const Y = String(H) !== String(P);
          return Y && U && g(H), Y ? H : P;
        } else
          return P;
      });
    }
    return /* @__PURE__ */ E.jsx(
      Fue,
      {
        scope: e.__scopeSlider,
        name: n,
        disabled: u,
        min: r,
        max: o,
        valueIndexToChangeRef: _,
        thumbs: x.current,
        values: C,
        orientation: s,
        form: b,
        children: /* @__PURE__ */ E.jsx(Xx.Provider, { scope: e.__scopeSlider, children: /* @__PURE__ */ E.jsx(Xx.Slot, { scope: e.__scopeSlider, children: /* @__PURE__ */ E.jsx(
          O,
          {
            "aria-disabled": u,
            "data-disabled": u ? "" : void 0,
            ...v,
            ref: t,
            onPointerDown: Ue(v.onPointerDown, () => {
              u || (R.current = C);
            }),
            min: r,
            max: o,
            inverted: y,
            onSlideStart: u ? void 0 : z,
            onSlideMove: u ? void 0 : j,
            onSlideEnd: u ? void 0 : I,
            onHomeKeyDown: () => !u && $(r, 0, { commit: !0 }),
            onEndKeyDown: () => !u && $(o, C.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: A, direction: V }) => {
              if (!u) {
                const U = wT.includes(A.key) || A.shiftKey && xT.includes(A.key) ? 10 : 1, W = _.current, D = C[W], F = i * U * V;
                $(D + F, W, { commit: !0 });
              }
            }
          }
        ) }) })
      }
    );
  }
);
kT.displayName = Ku;
var [ET, CT] = _T(Ku, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), Uue = S.forwardRef(
  (e, t) => {
    const {
      min: n,
      max: r,
      dir: o,
      inverted: i,
      onSlideStart: s,
      onSlideMove: u,
      onSlideEnd: c,
      onStepKeyDown: d,
      ...p
    } = e, [h, g] = S.useState(null), y = Ut(t, (C) => g(C)), b = S.useRef(void 0), v = a0(o), x = v === "ltr", _ = x && !i || !x && i;
    function O(C) {
      const N = b.current || h.getBoundingClientRect(), R = [0, N.width], z = h_(R, _ ? [n, r] : [r, n]);
      return b.current = N, z(C - N.left);
    }
    return /* @__PURE__ */ E.jsx(
      ET,
      {
        scope: e.__scopeSlider,
        startEdge: _ ? "left" : "right",
        endEdge: _ ? "right" : "left",
        direction: _ ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ E.jsx(
          OT,
          {
            dir: v,
            "data-orientation": "horizontal",
            ...p,
            ref: y,
            style: {
              ...p.style,
              "--radix-slider-thumb-transform": "translateX(-50%)"
            },
            onSlideStart: (C) => {
              const N = O(C.clientX);
              s?.(N);
            },
            onSlideMove: (C) => {
              const N = O(C.clientX);
              u?.(N);
            },
            onSlideEnd: () => {
              b.current = void 0, c?.();
            },
            onStepKeyDown: (C) => {
              const N = ST[_ ? "from-left" : "from-right"].includes(C.key);
              d?.({ event: C, direction: N ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), Hue = S.forwardRef(
  (e, t) => {
    const {
      min: n,
      max: r,
      inverted: o,
      onSlideStart: i,
      onSlideMove: s,
      onSlideEnd: u,
      onStepKeyDown: c,
      ...d
    } = e, p = S.useRef(null), h = Ut(t, p), g = S.useRef(void 0), y = !o;
    function b(v) {
      const x = g.current || p.current.getBoundingClientRect(), _ = [0, x.height], O = h_(_, y ? [r, n] : [n, r]);
      return g.current = x, O(v - x.top);
    }
    return /* @__PURE__ */ E.jsx(
      ET,
      {
        scope: e.__scopeSlider,
        startEdge: y ? "bottom" : "top",
        endEdge: y ? "top" : "bottom",
        size: "height",
        direction: y ? 1 : -1,
        children: /* @__PURE__ */ E.jsx(
          OT,
          {
            "data-orientation": "vertical",
            ...d,
            ref: h,
            style: {
              ...d.style,
              "--radix-slider-thumb-transform": "translateY(50%)"
            },
            onSlideStart: (v) => {
              const x = b(v.clientY);
              i?.(x);
            },
            onSlideMove: (v) => {
              const x = b(v.clientY);
              s?.(x);
            },
            onSlideEnd: () => {
              g.current = void 0, u?.();
            },
            onStepKeyDown: (v) => {
              const x = ST[y ? "from-bottom" : "from-top"].includes(v.key);
              c?.({ event: v, direction: x ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), OT = S.forwardRef(
  (e, t) => {
    const {
      __scopeSlider: n,
      onSlideStart: r,
      onSlideMove: o,
      onSlideEnd: i,
      onHomeKeyDown: s,
      onEndKeyDown: u,
      onStepKeyDown: c,
      ...d
    } = e, p = Bg(Ku, n);
    return /* @__PURE__ */ E.jsx(
      zt.span,
      {
        ...d,
        ref: t,
        onKeyDown: Ue(e.onKeyDown, (h) => {
          h.key === "Home" ? (s(h), h.preventDefault()) : h.key === "End" ? (u(h), h.preventDefault()) : wT.concat(xT).includes(h.key) && (c(h), h.preventDefault());
        }),
        onPointerDown: Ue(e.onPointerDown, (h) => {
          const g = h.target;
          g.setPointerCapture(h.pointerId), h.preventDefault(), p.thumbs.has(g) ? g.focus() : r(h);
        }),
        onPointerMove: Ue(e.onPointerMove, (h) => {
          h.target.hasPointerCapture(h.pointerId) && o(h);
        }),
        onPointerUp: Ue(e.onPointerUp, (h) => {
          const g = h.target;
          g.hasPointerCapture(h.pointerId) && (g.releasePointerCapture(h.pointerId), i(h));
        })
      }
    );
  }
), AT = "SliderTrack", NT = S.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, ...r } = e, o = Bg(AT, n);
    return /* @__PURE__ */ E.jsx(
      zt.span,
      {
        "data-disabled": o.disabled ? "" : void 0,
        "data-orientation": o.orientation,
        ...r,
        ref: t
      }
    );
  }
);
NT.displayName = AT;
var Wx = "SliderRange", MT = S.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, ...r } = e, o = Bg(Wx, n), i = CT(Wx, n), s = S.useRef(null), u = Ut(t, s), c = o.values.length, d = o.values.map(
      (g) => jT(g, o.min, o.max)
    ), p = c > 1 ? Math.min(...d) : 0, h = 100 - Math.max(...d);
    return /* @__PURE__ */ E.jsx(
      zt.span,
      {
        "data-orientation": o.orientation,
        "data-disabled": o.disabled ? "" : void 0,
        ...r,
        ref: u,
        style: {
          ...e.style,
          [i.startEdge]: p + "%",
          [i.endEdge]: h + "%"
        }
      }
    );
  }
);
MT.displayName = Wx;
var Gx = "SliderThumb", RT = S.forwardRef(
  (e, t) => {
    const n = Vue(e.__scopeSlider), [r, o] = S.useState(null), i = Ut(t, (u) => o(u)), s = S.useMemo(
      () => r ? n().findIndex((u) => u.ref.current === r) : -1,
      [n, r]
    );
    return /* @__PURE__ */ E.jsx($ue, { ...e, ref: i, index: s });
  }
), $ue = S.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, index: r, name: o, ...i } = e, s = Bg(Gx, n), u = CT(Gx, n), [c, d] = S.useState(null), p = Ut(t, (O) => d(O)), h = c ? s.form || !!c.closest("form") : !0, g = tj(c), y = s.values[r], b = y === void 0 ? 0 : jT(y, s.min, s.max), v = Xue(r, s.values.length), x = g?.[u.size], _ = x ? Gue(x, b, u.direction) : 0;
    return S.useEffect(() => {
      if (c)
        return s.thumbs.add(c), () => {
          s.thumbs.delete(c);
        };
    }, [c, s.thumbs]), /* @__PURE__ */ E.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [u.startEdge]: `calc(${b}% + ${_}px)`
        },
        children: [
          /* @__PURE__ */ E.jsx(Xx.ItemSlot, { scope: e.__scopeSlider, children: /* @__PURE__ */ E.jsx(
            zt.span,
            {
              role: "slider",
              "aria-label": e["aria-label"] || v,
              "aria-valuemin": s.min,
              "aria-valuenow": y,
              "aria-valuemax": s.max,
              "aria-orientation": s.orientation,
              "data-orientation": s.orientation,
              "data-disabled": s.disabled ? "" : void 0,
              tabIndex: s.disabled ? void 0 : 0,
              ...i,
              ref: p,
              style: y === void 0 ? { display: "none" } : e.style,
              onFocus: Ue(e.onFocus, () => {
                s.valueIndexToChangeRef.current = r;
              })
            }
          ) }),
          h && /* @__PURE__ */ E.jsx(
            Yue,
            {
              name: o ?? (s.name ? s.name + (s.values.length > 1 ? "[]" : "") : void 0),
              form: s.form,
              value: y
            },
            r
          )
        ]
      }
    );
  }
);
RT.displayName = Gx;
var Yue = (e) => {
  const { value: t, ...n } = e, r = S.useRef(null), o = Iue(t);
  return S.useEffect(() => {
    const i = r.current, s = window.HTMLInputElement.prototype, u = Object.getOwnPropertyDescriptor(s, "value").set;
    if (o !== t && u) {
      const c = new Event("input", { bubbles: !0 });
      u.call(i, t), i.dispatchEvent(c);
    }
  }, [o, t]), /* @__PURE__ */ E.jsx("input", { style: { display: "none" }, ...n, ref: r, defaultValue: t });
};
function que(e = [], t, n) {
  const r = [...e];
  return r[n] = t, r.sort((o, i) => o - i);
}
function jT(e, t, n) {
  const r = 100 / (n - t) * (e - t);
  return bT(r, [0, 100]);
}
function Xue(e, t) {
  return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][e] : void 0;
}
function Wue(e, t) {
  if (e.length === 1) return 0;
  const n = e.map((o) => Math.abs(o - t)), r = Math.min(...n);
  return n.indexOf(r);
}
function Gue(e, t, n) {
  const r = e / 2, o = h_([0, 50], [0, r]);
  return (r - o(t) * n) * n;
}
function Zue(e) {
  return e.slice(0, -1).map((t, n) => e[n + 1] - t);
}
function Kue(e, t) {
  if (t > 0) {
    const n = Zue(e);
    return Math.min(...n) >= t;
  }
  return !0;
}
function h_(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const r = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + r * (n - e[0]);
  };
}
function Que(e) {
  return (String(e).split(".")[1] || "").length;
}
function Jue(e, t) {
  const n = Math.pow(10, t);
  return Math.round(e * n) / n;
}
var ece = kT, tce = NT, nce = MT, rce = RT;
const Qd = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
}, zT = {};
for (const e of Object.keys(Qd))
  zT[Qd[e]] = e;
const ke = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
}, Xi = (6 / 29) ** 3;
for (const e of Object.keys(ke)) {
  if (!("channels" in ke[e]))
    throw new Error("missing channels property: " + e);
  if (!("labels" in ke[e]))
    throw new Error("missing channel labels property: " + e);
  if (ke[e].labels.length !== ke[e].channels)
    throw new Error("channel and label counts mismatch: " + e);
  const { channels: t, labels: n } = ke[e];
  delete ke[e].channels, delete ke[e].labels, Object.defineProperty(ke[e], "channels", { value: t }), Object.defineProperty(ke[e], "labels", { value: n });
}
ke.rgb.hsl = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.min(t, n, r), i = Math.max(t, n, r), s = i - o;
  let u, c;
  switch (i) {
    case o: {
      u = 0;
      break;
    }
    case t: {
      u = (n - r) / s;
      break;
    }
    case n: {
      u = 2 + (r - t) / s;
      break;
    }
    case r: {
      u = 4 + (t - n) / s;
      break;
    }
  }
  u = Math.min(u * 60, 360), u < 0 && (u += 360);
  const d = (o + i) / 2;
  return i === o ? c = 0 : d <= 0.5 ? c = s / (i + o) : c = s / (2 - i - o), [u, c * 100, d * 100];
};
ke.rgb.hsv = function(e) {
  let t, n, r, o, i;
  const s = e[0] / 255, u = e[1] / 255, c = e[2] / 255, d = Math.max(s, u, c), p = d - Math.min(s, u, c), h = function(g) {
    return (d - g) / 6 / p + 1 / 2;
  };
  if (p === 0)
    o = 0, i = 0;
  else {
    switch (i = p / d, t = h(s), n = h(u), r = h(c), d) {
      case s: {
        o = r - n;
        break;
      }
      case u: {
        o = 1 / 3 + t - r;
        break;
      }
      case c: {
        o = 2 / 3 + n - t;
        break;
      }
    }
    o < 0 ? o += 1 : o > 1 && (o -= 1);
  }
  return [
    o * 360,
    i * 100,
    d * 100
  ];
};
ke.rgb.hwb = function(e) {
  const t = e[0], n = e[1];
  let r = e[2];
  const o = ke.rgb.hsl(e)[0], i = 1 / 255 * Math.min(t, Math.min(n, r));
  return r = 1 - 1 / 255 * Math.max(t, Math.max(n, r)), [o, i * 100, r * 100];
};
ke.rgb.cmyk = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.min(1 - t, 1 - n, 1 - r), i = (1 - t - o) / (1 - o) || 0, s = (1 - n - o) / (1 - o) || 0, u = (1 - r - o) / (1 - o) || 0;
  return [i * 100, s * 100, u * 100, o * 100];
};
function oce(e, t) {
  return (e[0] - t[0]) ** 2 + (e[1] - t[1]) ** 2 + (e[2] - t[2]) ** 2;
}
ke.rgb.keyword = function(e) {
  const t = zT[e];
  if (t)
    return t;
  let n = Number.POSITIVE_INFINITY, r;
  for (const o of Object.keys(Qd)) {
    const i = Qd[o], s = oce(e, i);
    s < n && (n = s, r = o);
  }
  return r;
};
ke.keyword.rgb = function(e) {
  return Qd[e];
};
ke.rgb.xyz = function(e) {
  let t = e[0] / 255, n = e[1] / 255, r = e[2] / 255;
  t = t > 0.04045 ? ((t + 0.055) / 1.055) ** 2.4 : t / 12.92, n = n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92, r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
  const o = t * 0.4124564 + n * 0.3575761 + r * 0.1804375, i = t * 0.2126729 + n * 0.7151522 + r * 0.072175, s = t * 0.0193339 + n * 0.119192 + r * 0.9503041;
  return [o * 100, i * 100, s * 100];
};
ke.rgb.lab = function(e) {
  const t = ke.rgb.xyz(e);
  let n = t[0], r = t[1], o = t[2];
  n /= 95.047, r /= 100, o /= 108.883, n = n > Xi ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > Xi ? r ** (1 / 3) : 7.787 * r + 16 / 116, o = o > Xi ? o ** (1 / 3) : 7.787 * o + 16 / 116;
  const i = 116 * r - 16, s = 500 * (n - r), u = 200 * (r - o);
  return [i, s, u];
};
ke.hsl.rgb = function(e) {
  const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
  let o, i;
  if (n === 0)
    return i = r * 255, [i, i, i];
  const s = r < 0.5 ? r * (1 + n) : r + n - r * n, u = 2 * r - s, c = [0, 0, 0];
  for (let d = 0; d < 3; d++)
    o = t + 1 / 3 * -(d - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? i = u + (s - u) * 6 * o : 2 * o < 1 ? i = s : 3 * o < 2 ? i = u + (s - u) * (2 / 3 - o) * 6 : i = u, c[d] = i * 255;
  return c;
};
ke.hsl.hsv = function(e) {
  const t = e[0];
  let n = e[1] / 100, r = e[2] / 100, o = n;
  const i = Math.max(r, 0.01);
  r *= 2, n *= r <= 1 ? r : 2 - r, o *= i <= 1 ? i : 2 - i;
  const s = (r + n) / 2, u = r === 0 ? 2 * o / (i + o) : 2 * n / (r + n);
  return [t, u * 100, s * 100];
};
ke.hsv.rgb = function(e) {
  const t = e[0] / 60, n = e[1] / 100;
  let r = e[2] / 100;
  const o = Math.floor(t) % 6, i = t - Math.floor(t), s = 255 * r * (1 - n), u = 255 * r * (1 - n * i), c = 255 * r * (1 - n * (1 - i));
  switch (r *= 255, o) {
    case 0:
      return [r, c, s];
    case 1:
      return [u, r, s];
    case 2:
      return [s, r, c];
    case 3:
      return [s, u, r];
    case 4:
      return [c, s, r];
    case 5:
      return [r, s, u];
  }
};
ke.hsv.hsl = function(e) {
  const t = e[0], n = e[1] / 100, r = e[2] / 100, o = Math.max(r, 0.01);
  let i, s;
  s = (2 - n) * r;
  const u = (2 - n) * o;
  return i = n * o, i /= u <= 1 ? u : 2 - u, i = i || 0, s /= 2, [t, i * 100, s * 100];
};
ke.hwb.rgb = function(e) {
  const t = e[0] / 360;
  let n = e[1] / 100, r = e[2] / 100;
  const o = n + r;
  let i;
  o > 1 && (n /= o, r /= o);
  const s = Math.floor(6 * t), u = 1 - r;
  i = 6 * t - s, (s & 1) !== 0 && (i = 1 - i);
  const c = n + i * (u - n);
  let d, p, h;
  switch (s) {
    default:
    case 6:
    case 0: {
      d = u, p = c, h = n;
      break;
    }
    case 1: {
      d = c, p = u, h = n;
      break;
    }
    case 2: {
      d = n, p = u, h = c;
      break;
    }
    case 3: {
      d = n, p = c, h = u;
      break;
    }
    case 4: {
      d = c, p = n, h = u;
      break;
    }
    case 5: {
      d = u, p = n, h = c;
      break;
    }
  }
  return [d * 255, p * 255, h * 255];
};
ke.cmyk.rgb = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = e[3] / 100, i = 1 - Math.min(1, t * (1 - o) + o), s = 1 - Math.min(1, n * (1 - o) + o), u = 1 - Math.min(1, r * (1 - o) + o);
  return [i * 255, s * 255, u * 255];
};
ke.xyz.rgb = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100;
  let o, i, s;
  return o = t * 3.2404542 + n * -1.5371385 + r * -0.4985314, i = t * -0.969266 + n * 1.8760108 + r * 0.041556, s = t * 0.0556434 + n * -0.2040259 + r * 1.0572252, o = o > 31308e-7 ? 1.055 * o ** (1 / 2.4) - 0.055 : o * 12.92, i = i > 31308e-7 ? 1.055 * i ** (1 / 2.4) - 0.055 : i * 12.92, s = s > 31308e-7 ? 1.055 * s ** (1 / 2.4) - 0.055 : s * 12.92, o = Math.min(Math.max(0, o), 1), i = Math.min(Math.max(0, i), 1), s = Math.min(Math.max(0, s), 1), [o * 255, i * 255, s * 255];
};
ke.xyz.lab = function(e) {
  let t = e[0], n = e[1], r = e[2];
  t /= 95.047, n /= 100, r /= 108.883, t = t > Xi ? t ** (1 / 3) : 7.787 * t + 16 / 116, n = n > Xi ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > Xi ? r ** (1 / 3) : 7.787 * r + 16 / 116;
  const o = 116 * n - 16, i = 500 * (t - n), s = 200 * (n - r);
  return [o, i, s];
};
ke.lab.xyz = function(e) {
  const t = e[0], n = e[1], r = e[2];
  let o, i, s;
  i = (t + 16) / 116, o = n / 500 + i, s = i - r / 200;
  const u = i ** 3, c = o ** 3, d = s ** 3;
  return i = u > Xi ? u : (i - 16 / 116) / 7.787, o = c > Xi ? c : (o - 16 / 116) / 7.787, s = d > Xi ? d : (s - 16 / 116) / 7.787, o *= 95.047, i *= 100, s *= 108.883, [o, i, s];
};
ke.lab.lch = function(e) {
  const t = e[0], n = e[1], r = e[2];
  let o;
  o = Math.atan2(r, n) * 360 / 2 / Math.PI, o < 0 && (o += 360);
  const i = Math.sqrt(n * n + r * r);
  return [t, i, o];
};
ke.lch.lab = function(e) {
  const t = e[0], n = e[1], r = e[2] / 360 * 2 * Math.PI, o = n * Math.cos(r), i = n * Math.sin(r);
  return [t, o, i];
};
ke.rgb.ansi16 = function(e, t = null) {
  const [n, r, o] = e;
  let i = t === null ? ke.rgb.hsv(e)[2] : t;
  if (i = Math.round(i / 50), i === 0)
    return 30;
  let s = 30 + (Math.round(o / 255) << 2 | Math.round(r / 255) << 1 | Math.round(n / 255));
  return i === 2 && (s += 60), s;
};
ke.hsv.ansi16 = function(e) {
  return ke.rgb.ansi16(ke.hsv.rgb(e), e[2]);
};
ke.rgb.ansi256 = function(e) {
  const t = e[0], n = e[1], r = e[2];
  return t >> 4 === n >> 4 && n >> 4 === r >> 4 ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5);
};
ke.ansi16.rgb = function(e) {
  e = e[0];
  let t = e % 10;
  if (t === 0 || t === 7)
    return e > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t];
  const n = (Math.trunc(e > 50) + 1) * 0.5, r = (t & 1) * n * 255, o = (t >> 1 & 1) * n * 255, i = (t >> 2 & 1) * n * 255;
  return [r, o, i];
};
ke.ansi256.rgb = function(e) {
  if (e = e[0], e >= 232) {
    const i = (e - 232) * 10 + 8;
    return [i, i, i];
  }
  e -= 16;
  let t;
  const n = Math.floor(e / 36) / 5 * 255, r = Math.floor((t = e % 36) / 6) / 5 * 255, o = t % 6 / 5 * 255;
  return [n, r, o];
};
ke.rgb.hex = function(e) {
  const t = (((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255)).toString(16).toUpperCase();
  return "000000".slice(t.length) + t;
};
ke.hex.rgb = function(e) {
  const t = e.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i);
  if (!t)
    return [0, 0, 0];
  let n = t[0];
  t[0].length === 3 && (n = [...n].map((u) => u + u).join(""));
  const r = Number.parseInt(n, 16), o = r >> 16 & 255, i = r >> 8 & 255, s = r & 255;
  return [o, i, s];
};
ke.rgb.hcg = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.max(Math.max(t, n), r), i = Math.min(Math.min(t, n), r), s = o - i;
  let u;
  const c = s < 1 ? i / (1 - s) : 0;
  return s <= 0 ? u = 0 : o === t ? u = (n - r) / s % 6 : o === n ? u = 2 + (r - t) / s : u = 4 + (t - n) / s, u /= 6, u %= 1, [u * 360, s * 100, c * 100];
};
ke.hsl.hcg = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = n < 0.5 ? 2 * t * n : 2 * t * (1 - n);
  let o = 0;
  return r < 1 && (o = (n - 0.5 * r) / (1 - r)), [e[0], r * 100, o * 100];
};
ke.hsv.hcg = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t * n;
  let o = 0;
  return r < 1 && (o = (n - r) / (1 - r)), [e[0], r * 100, o * 100];
};
ke.hcg.rgb = function(e) {
  const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
  if (n === 0)
    return [r * 255, r * 255, r * 255];
  const o = [0, 0, 0], i = t % 1 * 6, s = i % 1, u = 1 - s;
  let c = 0;
  switch (Math.floor(i)) {
    case 0: {
      o[0] = 1, o[1] = s, o[2] = 0;
      break;
    }
    case 1: {
      o[0] = u, o[1] = 1, o[2] = 0;
      break;
    }
    case 2: {
      o[0] = 0, o[1] = 1, o[2] = s;
      break;
    }
    case 3: {
      o[0] = 0, o[1] = u, o[2] = 1;
      break;
    }
    case 4: {
      o[0] = s, o[1] = 0, o[2] = 1;
      break;
    }
    default:
      o[0] = 1, o[1] = 0, o[2] = u;
  }
  return c = (1 - n) * r, [
    (n * o[0] + c) * 255,
    (n * o[1] + c) * 255,
    (n * o[2] + c) * 255
  ];
};
ke.hcg.hsv = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
  let o = 0;
  return r > 0 && (o = t / r), [e[0], o * 100, r * 100];
};
ke.hcg.hsl = function(e) {
  const t = e[1] / 100, n = e[2] / 100 * (1 - t) + 0.5 * t;
  let r = 0;
  return n > 0 && n < 0.5 ? r = t / (2 * n) : n >= 0.5 && n < 1 && (r = t / (2 * (1 - n))), [e[0], r * 100, n * 100];
};
ke.hcg.hwb = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
  return [e[0], (r - t) * 100, (1 - r) * 100];
};
ke.hwb.hcg = function(e) {
  const t = e[1] / 100, n = 1 - e[2] / 100, r = n - t;
  let o = 0;
  return r < 1 && (o = (n - r) / (1 - r)), [e[0], r * 100, o * 100];
};
ke.apple.rgb = function(e) {
  return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255];
};
ke.rgb.apple = function(e) {
  return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535];
};
ke.gray.rgb = function(e) {
  return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255];
};
ke.gray.hsl = function(e) {
  return [0, 0, e[0]];
};
ke.gray.hsv = ke.gray.hsl;
ke.gray.hwb = function(e) {
  return [0, 100, e[0]];
};
ke.gray.cmyk = function(e) {
  return [0, 0, 0, e[0]];
};
ke.gray.lab = function(e) {
  return [e[0], 0, 0];
};
ke.gray.hex = function(e) {
  const t = Math.round(e[0] / 100 * 255) & 255, n = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
  return "000000".slice(n.length) + n;
};
ke.rgb.gray = function(e) {
  return [(e[0] + e[1] + e[2]) / 3 / 255 * 100];
};
function ice() {
  const e = {}, t = Object.keys(ke);
  for (let { length: n } = t, r = 0; r < n; r++)
    e[t[r]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  return e;
}
function ace(e) {
  const t = ice(), n = [e];
  for (t[e].distance = 0; n.length > 0; ) {
    const r = n.pop(), o = Object.keys(ke[r]);
    for (let { length: i } = o, s = 0; s < i; s++) {
      const u = o[s], c = t[u];
      c.distance === -1 && (c.distance = t[r].distance + 1, c.parent = r, n.unshift(u));
    }
  }
  return t;
}
function sce(e, t) {
  return function(n) {
    return t(e(n));
  };
}
function lce(e, t) {
  const n = [t[e].parent, e];
  let r = ke[t[e].parent][e], o = t[e].parent;
  for (; t[o].parent; )
    n.unshift(t[o].parent), r = sce(ke[t[o].parent][o], r), o = t[o].parent;
  return r.conversion = n, r;
}
function uce(e) {
  const t = ace(e), n = {}, r = Object.keys(t);
  for (let { length: o } = r, i = 0; i < o; i++) {
    const s = r[i];
    t[s].parent !== null && (n[s] = lce(s, t));
  }
  return n;
}
const Is = {}, cce = Object.keys(ke);
function dce(e) {
  const t = function(...n) {
    const r = n[0];
    return r == null ? r : (r.length > 1 && (n = r), e(n));
  };
  return "conversion" in e && (t.conversion = e.conversion), t;
}
function fce(e) {
  const t = function(...n) {
    const r = n[0];
    if (r == null)
      return r;
    r.length > 1 && (n = r);
    const o = e(n);
    if (typeof o == "object")
      for (let { length: i } = o, s = 0; s < i; s++)
        o[s] = Math.round(o[s]);
    return o;
  };
  return "conversion" in e && (t.conversion = e.conversion), t;
}
for (const e of cce) {
  Is[e] = {}, Object.defineProperty(Is[e], "channels", { value: ke[e].channels }), Object.defineProperty(Is[e], "labels", { value: ke[e].labels });
  const t = uce(e), n = Object.keys(t);
  for (const r of n) {
    const o = t[r];
    Is[e][r] = fce(o), Is[e][r].raw = dce(o);
  }
}
const pce = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Is
}, Symbol.toStringTag, { value: "Module" })), Bn = (e, t) => {
  const n = Array.isArray(t) ? t : [t];
  if (n[0] === void 0 || n[0] === null)
    return Bn("rgb", [0, 0, 0]);
  const r = Is[e];
  if (!r)
    throw new Error(
      `Unsupported color type: ${e} allowed are ${Object.keys(pce).join(
        ", "
      )}`
    );
  r[e] = () => n;
  const o = (s) => {
    const u = s(...n);
    return Array.isArray(u) ? u[0] != null : u;
  };
  if (!o(r.rgb) || !o(r.hsl))
    return Bn("rgb", [0, 0, 0]);
  const i = {};
  return Object.keys(r).forEach((s) => {
    const u = r[s];
    typeof u == "function" && (i[s] = () => s === e ? n : u(...n));
  }), i;
}, hce = ({
  onChange: e,
  colorconverter: t,
  allow_null: n = !1
}) => {
  if (t === null && !n)
    throw new Error("Color converter is null");
  const [r, o] = S.useState(t), [i, s] = S.useState([0, 0, 0]), [u, c] = S.useState([0, 0, 0]), [d, p] = S.useState([0, 0, 0]), [h, g] = S.useState("000");
  S.useEffect(() => {
    if (!r) {
      if (!n) throw new Error("Color converter is null");
      c([0, 0, 0]), s([0, 0, 0]), p([0, 0, 0]), g("");
      return;
    }
    s(r.hsl()), c(r.rgb()), p(r.hsv()), g(r.hex());
  }, [r]);
  const y = {
    backgroundColor: `hsl(${i[0]}, ${i[1]}%, ${i[2]}%)`,
    padding: "10px",
    margin: "10px 0"
  };
  return /* @__PURE__ */ E.jsxs("div", { style: { backgroundColor: "white" }, children: [
    /* @__PURE__ */ E.jsx("div", { style: y, children: "Color Preview" }),
    /* @__PURE__ */ E.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ E.jsx("div", { className: "colorspace_title", children: "RGB" }),
      /* @__PURE__ */ E.jsx("div", {}),
      /* @__PURE__ */ E.jsx("label", { children: "Red" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: u[0],
          onChange: (b) => {
            const v = [parseInt(b.target.value), u[1], u[2]], x = Bn("rgb", v);
            o(x), e(x);
          },
          style: { background: "linear-gradient(to right, #000, #f00)" }
        }
      ),
      /* @__PURE__ */ E.jsx("label", { children: "Green" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: u[1],
          onChange: (b) => {
            const v = [u[0], parseInt(b.target.value), u[2]], x = Bn("rgb", v);
            o(x), e(x);
          },
          style: { background: "linear-gradient(to right, #000, #0f0)" }
        }
      ),
      /* @__PURE__ */ E.jsx("label", { children: "Blue" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: u[2],
          onChange: (b) => {
            const v = [u[0], u[1], parseInt(b.target.value)], x = Bn("rgb", v);
            o(x), e(x);
          },
          style: { background: "linear-gradient(to right, #000, #00f)" }
        }
      )
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ E.jsx("div", { className: "colorspace_title", children: "HSL" }),
      /* @__PURE__ */ E.jsx("div", {}),
      /* @__PURE__ */ E.jsx("label", { children: "Hue" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "360",
          value: i[0],
          onChange: (b) => {
            const v = [parseInt(b.target.value), i[1], i[2]], x = Bn("hsl", v);
            o(x), e(x);
          },
          style: {
            background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
          }
        }
      ),
      /* @__PURE__ */ E.jsx("label", { children: "Saturation" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: i[1],
          onChange: (b) => {
            const v = [i[0], parseInt(b.target.value), i[2]], x = Bn("hsl", v);
            o(x), e(x);
          },
          style: {
            background: `linear-gradient(to right, #fff, hsl(${i[0]}, 100%, 50%))`
          }
        }
      ),
      /* @__PURE__ */ E.jsx("label", { children: "Lightness" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: i[2],
          onChange: (b) => {
            const v = [i[0], i[1], parseInt(b.target.value)], x = Bn("hsl", v);
            o(x), e(x);
          },
          style: {
            background: `linear-gradient(to right, #000, hsl(${i[0]}, 100%, 50%), #fff)`
          }
        }
      )
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ E.jsx("div", { className: "colorspace_title", children: "HSV" }),
      /* @__PURE__ */ E.jsx("div", {}),
      /* @__PURE__ */ E.jsx("label", { children: "Hue" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "360",
          value: d[0],
          onChange: (b) => {
            const v = [parseInt(b.target.value), d[1], d[2]], x = Bn("hsv", v);
            o(x), e(x);
          },
          style: {
            background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
          }
        }
      ),
      /* @__PURE__ */ E.jsx("label", { children: "Saturation" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: d[1],
          onChange: (b) => {
            const v = [d[0], parseInt(b.target.value), d[2]], x = Bn("hsv", v);
            o(x), e(x);
          },
          style: {
            background: `linear-gradient(to right, #fff, hsl(${i[0]}, 100%, 50%))`
          }
        }
      ),
      /* @__PURE__ */ E.jsx("label", { children: "Value" }),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: d[2],
          onChange: (b) => {
            const v = [d[0], d[1], parseInt(b.target.value)], x = Bn("hsv", v);
            o(x), e(x);
          },
          style: {
            background: `linear-gradient(to right, #000, hsl(${i[0]}, 100%, 50%))`
          }
        }
      )
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ E.jsx("div", { className: "colorspace_title", children: "HEX" }),
      /* @__PURE__ */ E.jsx("div", {}),
      /* @__PURE__ */ E.jsx(
        "input",
        {
          type: "text",
          value: h,
          onChange: (b) => {
            const v = b.target.value === "" ? null : Bn("hex", [b.target.value]);
            o(v), e(v);
          }
        }
      )
    ] })
  ] });
}, mce = ({
  inicolordata: e,
  inicolorspace: t,
  allow_null: n = !1,
  delay: r = 1e3,
  onChange: o
}) => {
  const i = e !== void 0 ? e : [0, 0, 0], s = e === void 0 ? "rgb" : t || "hex", u = Array.isArray(i) ? i : [i], c = S.useMemo(() => {
    let x = Bn(s, u);
    return x.rgb() === void 0 && (x = Bn("rgb", [0, 0, 0])), x;
  }, [s, u]), [d, p] = S.useState(c);
  S.useEffect(() => {
    const x = e !== void 0 ? e : [0, 0, 0], _ = e === void 0 ? "rgb" : t || "hex", O = Array.isArray(x) ? x : [x];
    let C = Bn(_, O);
    C.rgb() === void 0 && (C = Bn("rgb", [0, 0, 0])), p(C);
  }, [JSON.stringify(e), t]);
  const h = S.useContext(it), g = h.local_state(() => h.reactflowRef), y = S.useRef(null), b = S.useCallback(
    (x) => {
      if (x === null && !n)
        throw new Error("Color is null");
      x !== null && p(x), y.current && clearTimeout(y.current), o && (y.current = setTimeout(() => {
        o(x), y.current = null;
      }, r));
    },
    [n, o, r]
  );
  S.useEffect(() => () => {
    y.current && clearTimeout(y.current);
  }, []);
  const v = S.useMemo(
    () => ({
      background: "#" + d.hex(),
      borderRadius: "0.3rem",
      width: "2rem",
      height: "1rem"
    }),
    [d]
  );
  return /* @__PURE__ */ E.jsxs(Ez, { children: [
    /* @__PURE__ */ E.jsx(Cz, { asChild: !0, children: /* @__PURE__ */ E.jsx("button", { style: v }) }),
    /* @__PURE__ */ E.jsx(Oz, { container: g, children: /* @__PURE__ */ E.jsx(Az, { side: "left", className: "iotooltipcontent", children: /* @__PURE__ */ E.jsx(
      hce,
      {
        onChange: b,
        colorconverter: d,
        allow_null: n
      }
    ) }) })
  ] });
};
function il(e) {
  "@babel/helpers - typeof";
  return il = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, il(e);
}
function gce(e, t) {
  if (il(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (il(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function TT(e) {
  var t = gce(e, "string");
  return il(t) == "symbol" ? t : t + "";
}
function fd(e, t, n) {
  return (t = TT(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function O3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Le(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? O3(Object(n), !0).forEach(function(r) {
      fd(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : O3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function yce(e) {
  if (Array.isArray(e)) return e;
}
function vce(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, o, i, s, u = [], c = !0, d = !1;
    try {
      if (i = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n) return;
        c = !1;
      } else for (; !(c = (r = i.call(n)).done) && (u.push(r.value), u.length !== t); c = !0) ;
    } catch (p) {
      d = !0, o = p;
    } finally {
      try {
        if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return;
      } finally {
        if (d) throw o;
      }
    }
    return u;
  }
}
function Zx(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function DT(e, t) {
  if (e) {
    if (typeof e == "string") return Zx(e, t);
    var n = {}.toString.call(e).slice(8, -1);
    return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Zx(e, t) : void 0;
  }
}
function bce() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Wi(e, t) {
  return yce(e) || vce(e, t) || DT(e, t) || bce();
}
function la(e, t) {
  if (e == null) return {};
  var n, r, o = u_(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var wce = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function xce(e) {
  var t = e.defaultInputValue, n = t === void 0 ? "" : t, r = e.defaultMenuIsOpen, o = r === void 0 ? !1 : r, i = e.defaultValue, s = i === void 0 ? null : i, u = e.inputValue, c = e.menuIsOpen, d = e.onChange, p = e.onInputChange, h = e.onMenuClose, g = e.onMenuOpen, y = e.value, b = la(e, wce), v = S.useState(u !== void 0 ? u : n), x = Wi(v, 2), _ = x[0], O = x[1], C = S.useState(c !== void 0 ? c : o), N = Wi(C, 2), R = N[0], z = N[1], j = S.useState(y !== void 0 ? y : s), I = Wi(j, 2), $ = I[0], A = I[1], V = S.useCallback(function(Y, q) {
    typeof d == "function" && d(Y, q), A(Y);
  }, [d]), U = S.useCallback(function(Y, q) {
    var M;
    typeof p == "function" && (M = p(Y, q)), O(M !== void 0 ? M : Y);
  }, [p]), W = S.useCallback(function() {
    typeof g == "function" && g(), z(!0);
  }, [g]), D = S.useCallback(function() {
    typeof h == "function" && h(), z(!1);
  }, [h]), F = u !== void 0 ? u : _, P = c !== void 0 ? c : R, H = y !== void 0 ? y : $;
  return Le(Le({}, b), {}, {
    inputValue: F,
    menuIsOpen: P,
    onChange: V,
    onInputChange: U,
    onMenuClose: D,
    onMenuOpen: W,
    value: H
  });
}
function Sce(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function A3(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, TT(r.key), r);
  }
}
function _ce(e, t, n) {
  return t && A3(e.prototype, t), n && A3(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function kce(e, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && xm(e, t);
}
function _m(e) {
  return _m = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _m(e);
}
function PT() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (PT = function() {
    return !!e;
  })();
}
function Ece(e, t) {
  if (t && (il(t) == "object" || typeof t == "function")) return t;
  if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return fT(e);
}
function Cce(e) {
  var t = PT();
  return function() {
    var n, r = _m(e);
    if (t) {
      var o = _m(this).constructor;
      n = Reflect.construct(r, arguments, o);
    } else n = r.apply(this, arguments);
    return Ece(this, n);
  };
}
function Oce(e) {
  if (Array.isArray(e)) return Zx(e);
}
function Ace(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function Nce() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function m_(e) {
  return Oce(e) || Ace(e) || DT(e) || Nce();
}
function Mce(e, t) {
  return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
    raw: {
      value: Object.freeze(t)
    }
  }));
}
var Kx = S.useLayoutEffect, Rce = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"], km = function() {
};
function jce(e, t) {
  return t ? t[0] === "-" ? e + t : e + "__" + t : e;
}
function zce(e, t) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
    r[o - 2] = arguments[o];
  var i = [].concat(r);
  if (t && e)
    for (var s in t)
      t.hasOwnProperty(s) && t[s] && i.push("".concat(jce(e, s)));
  return i.filter(function(u) {
    return u;
  }).map(function(u) {
    return String(u).trim();
  }).join(" ");
}
var N3 = function(e) {
  return Uce(e) ? e.filter(Boolean) : il(e) === "object" && e !== null ? [e] : [];
}, LT = function(e) {
  e.className, e.clearValue, e.cx, e.getStyles, e.getClassNames, e.getValue, e.hasValue, e.isMulti, e.isRtl, e.options, e.selectOption, e.selectProps, e.setValue, e.theme;
  var t = la(e, Rce);
  return Le({}, t);
}, Jt = function(e, t, n) {
  var r = e.cx, o = e.getStyles, i = e.getClassNames, s = e.className;
  return {
    css: o(t, e),
    className: r(n ?? {}, i(t, e), s)
  };
};
function Fg(e) {
  return [document.documentElement, document.body, window].indexOf(e) > -1;
}
function Tce(e) {
  return Fg(e) ? window.innerHeight : e.clientHeight;
}
function IT(e) {
  return Fg(e) ? window.pageYOffset : e.scrollTop;
}
function Em(e, t) {
  if (Fg(e)) {
    window.scrollTo(0, t);
    return;
  }
  e.scrollTop = t;
}
function Dce(e) {
  var t = getComputedStyle(e), n = t.position === "absolute", r = /(auto|scroll)/;
  if (t.position === "fixed") return document.documentElement;
  for (var o = e; o = o.parentElement; )
    if (t = getComputedStyle(o), !(n && t.position === "static") && r.test(t.overflow + t.overflowY + t.overflowX))
      return o;
  return document.documentElement;
}
function Pce(e, t, n, r) {
  return n * ((e = e / r - 1) * e * e + 1) + t;
}
function dh(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : km, o = IT(e), i = t - o, s = 10, u = 0;
  function c() {
    u += s;
    var d = Pce(u, o, i, n);
    Em(e, d), u < n ? window.requestAnimationFrame(c) : r(e);
  }
  c();
}
function M3(e, t) {
  var n = e.getBoundingClientRect(), r = t.getBoundingClientRect(), o = t.offsetHeight / 3;
  r.bottom + o > n.bottom ? Em(e, Math.min(t.offsetTop + t.clientHeight - e.offsetHeight + o, e.scrollHeight)) : r.top - o < n.top && Em(e, Math.max(t.offsetTop - o, 0));
}
function Lce(e) {
  var t = e.getBoundingClientRect();
  return {
    bottom: t.bottom,
    height: t.height,
    left: t.left,
    right: t.right,
    top: t.top,
    width: t.width
  };
}
function R3() {
  try {
    return document.createEvent("TouchEvent"), !0;
  } catch {
    return !1;
  }
}
function Ice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch {
    return !1;
  }
}
var VT = !1, Vce = {
  get passive() {
    return VT = !0;
  }
}, fh = typeof window < "u" ? window : {};
fh.addEventListener && fh.removeEventListener && (fh.addEventListener("p", km, Vce), fh.removeEventListener("p", km, !1));
var Bce = VT;
function Fce(e) {
  return e != null;
}
function Uce(e) {
  return Array.isArray(e);
}
function ph(e, t, n) {
  return e ? t : n;
}
var Hce = function(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  var o = Object.entries(e).filter(function(i) {
    var s = Wi(i, 1), u = s[0];
    return !n.includes(u);
  });
  return o.reduce(function(i, s) {
    var u = Wi(s, 2), c = u[0], d = u[1];
    return i[c] = d, i;
  }, {});
}, $ce = ["children", "innerProps"], Yce = ["children", "innerProps"];
function qce(e) {
  var t = e.maxHeight, n = e.menuEl, r = e.minHeight, o = e.placement, i = e.shouldScroll, s = e.isFixedPosition, u = e.controlHeight, c = Dce(n), d = {
    placement: "bottom",
    maxHeight: t
  };
  if (!n || !n.offsetParent) return d;
  var p = c.getBoundingClientRect(), h = p.height, g = n.getBoundingClientRect(), y = g.bottom, b = g.height, v = g.top, x = n.offsetParent.getBoundingClientRect(), _ = x.top, O = s ? window.innerHeight : Tce(c), C = IT(c), N = parseInt(getComputedStyle(n).marginBottom, 10), R = parseInt(getComputedStyle(n).marginTop, 10), z = _ - R, j = O - v, I = z + C, $ = h - C - v, A = y - O + C + N, V = C + v - R, U = 160;
  switch (o) {
    case "auto":
    case "bottom":
      if (j >= b)
        return {
          placement: "bottom",
          maxHeight: t
        };
      if ($ >= b && !s)
        return i && dh(c, A, U), {
          placement: "bottom",
          maxHeight: t
        };
      if (!s && $ >= r || s && j >= r) {
        i && dh(c, A, U);
        var W = s ? j - N : $ - N;
        return {
          placement: "bottom",
          maxHeight: W
        };
      }
      if (o === "auto" || s) {
        var D = t, F = s ? z : I;
        return F >= r && (D = Math.min(F - N - u, t)), {
          placement: "top",
          maxHeight: D
        };
      }
      if (o === "bottom")
        return i && Em(c, A), {
          placement: "bottom",
          maxHeight: t
        };
      break;
    case "top":
      if (z >= b)
        return {
          placement: "top",
          maxHeight: t
        };
      if (I >= b && !s)
        return i && dh(c, V, U), {
          placement: "top",
          maxHeight: t
        };
      if (!s && I >= r || s && z >= r) {
        var P = t;
        return (!s && I >= r || s && z >= r) && (P = s ? z - R : I - R), i && dh(c, V, U), {
          placement: "top",
          maxHeight: P
        };
      }
      return {
        placement: "bottom",
        maxHeight: t
      };
    default:
      throw new Error('Invalid placement provided "'.concat(o, '".'));
  }
  return d;
}
function Xce(e) {
  var t = {
    bottom: "top",
    top: "bottom"
  };
  return e ? t[e] : "bottom";
}
var BT = function(e) {
  return e === "auto" ? "bottom" : e;
}, Wce = function(e, t) {
  var n, r = e.placement, o = e.theme, i = o.borderRadius, s = o.spacing, u = o.colors;
  return Le((n = {
    label: "menu"
  }, fd(n, Xce(r), "100%"), fd(n, "position", "absolute"), fd(n, "width", "100%"), fd(n, "zIndex", 1), n), t ? {} : {
    backgroundColor: u.neutral0,
    borderRadius: i,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: s.menuGutter,
    marginTop: s.menuGutter
  });
}, FT = /* @__PURE__ */ S.createContext(null), Gce = function(e) {
  var t = e.children, n = e.minMenuHeight, r = e.maxMenuHeight, o = e.menuPlacement, i = e.menuPosition, s = e.menuShouldScrollIntoView, u = e.theme, c = S.useContext(FT) || {}, d = c.setPortalPlacement, p = S.useRef(null), h = S.useState(r), g = Wi(h, 2), y = g[0], b = g[1], v = S.useState(null), x = Wi(v, 2), _ = x[0], O = x[1], C = u.spacing.controlHeight;
  return Kx(function() {
    var N = p.current;
    if (N) {
      var R = i === "fixed", z = s && !R, j = qce({
        maxHeight: r,
        menuEl: N,
        minHeight: n,
        placement: o,
        shouldScroll: z,
        isFixedPosition: R,
        controlHeight: C
      });
      b(j.maxHeight), O(j.placement), d?.(j.placement);
    }
  }, [r, o, i, s, n, d, C]), t({
    ref: p,
    placerProps: Le(Le({}, e), {}, {
      placement: _ || BT(o),
      maxHeight: y
    })
  });
}, Zce = function(e) {
  var t = e.children, n = e.innerRef, r = e.innerProps;
  return ze("div", Te({}, Jt(e, "menu", {
    menu: !0
  }), {
    ref: n
  }, r), t);
}, Kce = Zce, Qce = function(e, t) {
  var n = e.maxHeight, r = e.theme.spacing.baseUnit;
  return Le({
    maxHeight: n,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, t ? {} : {
    paddingBottom: r,
    paddingTop: r
  });
}, Jce = function(e) {
  var t = e.children, n = e.innerProps, r = e.innerRef, o = e.isMulti;
  return ze("div", Te({}, Jt(e, "menuList", {
    "menu-list": !0,
    "menu-list--is-multi": o
  }), {
    ref: r
  }, n), t);
}, UT = function(e, t) {
  var n = e.theme, r = n.spacing.baseUnit, o = n.colors;
  return Le({
    textAlign: "center"
  }, t ? {} : {
    color: o.neutral40,
    padding: "".concat(r * 2, "px ").concat(r * 3, "px")
  });
}, ede = UT, tde = UT, nde = function(e) {
  var t = e.children, n = t === void 0 ? "No options" : t, r = e.innerProps, o = la(e, $ce);
  return ze("div", Te({}, Jt(Le(Le({}, o), {}, {
    children: n,
    innerProps: r
  }), "noOptionsMessage", {
    "menu-notice": !0,
    "menu-notice--no-options": !0
  }), r), n);
}, rde = function(e) {
  var t = e.children, n = t === void 0 ? "Loading..." : t, r = e.innerProps, o = la(e, Yce);
  return ze("div", Te({}, Jt(Le(Le({}, o), {}, {
    children: n,
    innerProps: r
  }), "loadingMessage", {
    "menu-notice": !0,
    "menu-notice--loading": !0
  }), r), n);
}, ode = function(e) {
  var t = e.rect, n = e.offset, r = e.position;
  return {
    left: t.left,
    position: r,
    top: n,
    width: t.width,
    zIndex: 1
  };
}, ide = function(e) {
  var t = e.appendTo, n = e.children, r = e.controlElement, o = e.innerProps, i = e.menuPlacement, s = e.menuPosition, u = S.useRef(null), c = S.useRef(null), d = S.useState(BT(i)), p = Wi(d, 2), h = p[0], g = p[1], y = S.useMemo(function() {
    return {
      setPortalPlacement: g
    };
  }, []), b = S.useState(null), v = Wi(b, 2), x = v[0], _ = v[1], O = S.useCallback(function() {
    if (r) {
      var z = Lce(r), j = s === "fixed" ? 0 : window.pageYOffset, I = z[h] + j;
      (I !== x?.offset || z.left !== x?.rect.left || z.width !== x?.rect.width) && _({
        offset: I,
        rect: z
      });
    }
  }, [r, s, h, x?.offset, x?.rect.left, x?.rect.width]);
  Kx(function() {
    O();
  }, [O]);
  var C = S.useCallback(function() {
    typeof c.current == "function" && (c.current(), c.current = null), r && u.current && (c.current = QR(r, u.current, O, {
      elementResize: "ResizeObserver" in window
    }));
  }, [r, O]);
  Kx(function() {
    C();
  }, [C]);
  var N = S.useCallback(function(z) {
    u.current = z, C();
  }, [C]);
  if (!t && s !== "fixed" || !x) return null;
  var R = ze("div", Te({
    ref: N
  }, Jt(Le(Le({}, e), {}, {
    offset: x.offset,
    position: s,
    rect: x.rect
  }), "menuPortal", {
    "menu-portal": !0
  }), o), n);
  return ze(FT.Provider, {
    value: y
  }, t ? /* @__PURE__ */ rf.createPortal(R, t) : R);
}, ade = function(e) {
  var t = e.isDisabled, n = e.isRtl;
  return {
    label: "container",
    direction: n ? "rtl" : void 0,
    pointerEvents: t ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
}, sde = function(e) {
  var t = e.children, n = e.innerProps, r = e.isDisabled, o = e.isRtl;
  return ze("div", Te({}, Jt(e, "container", {
    "--is-disabled": r,
    "--is-rtl": o
  }), n), t);
}, lde = function(e, t) {
  var n = e.theme.spacing, r = e.isMulti, o = e.hasValue, i = e.selectProps.controlShouldRenderValue;
  return Le({
    alignItems: "center",
    display: r && o && i ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, t ? {} : {
    padding: "".concat(n.baseUnit / 2, "px ").concat(n.baseUnit * 2, "px")
  });
}, ude = function(e) {
  var t = e.children, n = e.innerProps, r = e.isMulti, o = e.hasValue;
  return ze("div", Te({}, Jt(e, "valueContainer", {
    "value-container": !0,
    "value-container--is-multi": r,
    "value-container--has-value": o
  }), n), t);
}, cde = function() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
}, dde = function(e) {
  var t = e.children, n = e.innerProps;
  return ze("div", Te({}, Jt(e, "indicatorsContainer", {
    indicators: !0
  }), n), t);
}, j3, fde = ["size"], pde = ["innerProps", "isRtl", "size"], hde = {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
}, HT = function(e) {
  var t = e.size, n = la(e, fde);
  return ze("svg", Te({
    height: t,
    width: t,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: hde
  }, n));
}, g_ = function(e) {
  return ze(HT, Te({
    size: 20
  }, e), ze("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
}, $T = function(e) {
  return ze(HT, Te({
    size: 20
  }, e), ze("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
}, YT = function(e, t) {
  var n = e.isFocused, r = e.theme, o = r.spacing.baseUnit, i = r.colors;
  return Le({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, t ? {} : {
    color: n ? i.neutral60 : i.neutral20,
    padding: o * 2,
    ":hover": {
      color: n ? i.neutral80 : i.neutral40
    }
  });
}, mde = YT, gde = function(e) {
  var t = e.children, n = e.innerProps;
  return ze("div", Te({}, Jt(e, "dropdownIndicator", {
    indicator: !0,
    "dropdown-indicator": !0
  }), n), t || ze($T, null));
}, yde = YT, vde = function(e) {
  var t = e.children, n = e.innerProps;
  return ze("div", Te({}, Jt(e, "clearIndicator", {
    indicator: !0,
    "clear-indicator": !0
  }), n), t || ze(g_, null));
}, bde = function(e, t) {
  var n = e.isDisabled, r = e.theme, o = r.spacing.baseUnit, i = r.colors;
  return Le({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, t ? {} : {
    backgroundColor: n ? i.neutral10 : i.neutral20,
    marginBottom: o * 2,
    marginTop: o * 2
  });
}, wde = function(e) {
  var t = e.innerProps;
  return ze("span", Te({}, t, Jt(e, "indicatorSeparator", {
    "indicator-separator": !0
  })));
}, xde = Tg(j3 || (j3 = Mce([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`]))), Sde = function(e, t) {
  var n = e.isFocused, r = e.size, o = e.theme, i = o.colors, s = o.spacing.baseUnit;
  return Le({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: r,
    lineHeight: 1,
    marginRight: r,
    textAlign: "center",
    verticalAlign: "middle"
  }, t ? {} : {
    color: n ? i.neutral60 : i.neutral20,
    padding: s * 2
  });
}, rw = function(e) {
  var t = e.delay, n = e.offset;
  return ze("span", {
    css: /* @__PURE__ */ i_({
      animation: "".concat(xde, " 1s ease-in-out ").concat(t, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: n ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, "", "")
  });
}, _de = function(e) {
  var t = e.innerProps, n = e.isRtl, r = e.size, o = r === void 0 ? 4 : r, i = la(e, pde);
  return ze("div", Te({}, Jt(Le(Le({}, i), {}, {
    innerProps: t,
    isRtl: n,
    size: o
  }), "loadingIndicator", {
    indicator: !0,
    "loading-indicator": !0
  }), t), ze(rw, {
    delay: 0,
    offset: n
  }), ze(rw, {
    delay: 160,
    offset: !0
  }), ze(rw, {
    delay: 320,
    offset: !n
  }));
}, kde = function(e, t) {
  var n = e.isDisabled, r = e.isFocused, o = e.theme, i = o.colors, s = o.borderRadius, u = o.spacing;
  return Le({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: u.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, t ? {} : {
    backgroundColor: n ? i.neutral5 : i.neutral0,
    borderColor: n ? i.neutral10 : r ? i.primary : i.neutral20,
    borderRadius: s,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: r ? "0 0 0 1px ".concat(i.primary) : void 0,
    "&:hover": {
      borderColor: r ? i.primary : i.neutral30
    }
  });
}, Ede = function(e) {
  var t = e.children, n = e.isDisabled, r = e.isFocused, o = e.innerRef, i = e.innerProps, s = e.menuIsOpen;
  return ze("div", Te({
    ref: o
  }, Jt(e, "control", {
    control: !0,
    "control--is-disabled": n,
    "control--is-focused": r,
    "control--menu-is-open": s
  }), i, {
    "aria-disabled": n || void 0
  }), t);
}, Cde = Ede, Ode = ["data"], Ade = function(e, t) {
  var n = e.theme.spacing;
  return t ? {} : {
    paddingBottom: n.baseUnit * 2,
    paddingTop: n.baseUnit * 2
  };
}, Nde = function(e) {
  var t = e.children, n = e.cx, r = e.getStyles, o = e.getClassNames, i = e.Heading, s = e.headingProps, u = e.innerProps, c = e.label, d = e.theme, p = e.selectProps;
  return ze("div", Te({}, Jt(e, "group", {
    group: !0
  }), u), ze(i, Te({}, s, {
    selectProps: p,
    theme: d,
    getStyles: r,
    getClassNames: o,
    cx: n
  }), c), ze("div", null, t));
}, Mde = function(e, t) {
  var n = e.theme, r = n.colors, o = n.spacing;
  return Le({
    label: "group",
    cursor: "default",
    display: "block"
  }, t ? {} : {
    color: r.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: o.baseUnit * 3,
    paddingRight: o.baseUnit * 3,
    textTransform: "uppercase"
  });
}, Rde = function(e) {
  var t = LT(e);
  t.data;
  var n = la(t, Ode);
  return ze("div", Te({}, Jt(e, "groupHeading", {
    "group-heading": !0
  }), n));
}, jde = Nde, zde = ["innerRef", "isDisabled", "isHidden", "inputClassName"], Tde = function(e, t) {
  var n = e.isDisabled, r = e.value, o = e.theme, i = o.spacing, s = o.colors;
  return Le(Le({
    visibility: n ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: r ? "translateZ(0)" : ""
  }, Dde), t ? {} : {
    margin: i.baseUnit / 2,
    paddingBottom: i.baseUnit / 2,
    paddingTop: i.baseUnit / 2,
    color: s.neutral80
  });
}, qT = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
}, Dde = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": Le({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, qT)
}, Pde = function(e) {
  return Le({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: e ? 0 : 1,
    width: "100%"
  }, qT);
}, Lde = function(e) {
  var t = e.cx, n = e.value, r = LT(e), o = r.innerRef, i = r.isDisabled, s = r.isHidden, u = r.inputClassName, c = la(r, zde);
  return ze("div", Te({}, Jt(e, "input", {
    "input-container": !0
  }), {
    "data-value": n || ""
  }), ze("input", Te({
    className: t({
      input: !0
    }, u),
    ref: o,
    style: Pde(s),
    disabled: i
  }, c)));
}, Ide = Lde, Vde = function(e, t) {
  var n = e.theme, r = n.spacing, o = n.borderRadius, i = n.colors;
  return Le({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, t ? {} : {
    backgroundColor: i.neutral10,
    borderRadius: o / 2,
    margin: r.baseUnit / 2
  });
}, Bde = function(e, t) {
  var n = e.theme, r = n.borderRadius, o = n.colors, i = e.cropWithEllipsis;
  return Le({
    overflow: "hidden",
    textOverflow: i || i === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, t ? {} : {
    borderRadius: r / 2,
    color: o.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
}, Fde = function(e, t) {
  var n = e.theme, r = n.spacing, o = n.borderRadius, i = n.colors, s = e.isFocused;
  return Le({
    alignItems: "center",
    display: "flex"
  }, t ? {} : {
    borderRadius: o / 2,
    backgroundColor: s ? i.dangerLight : void 0,
    paddingLeft: r.baseUnit,
    paddingRight: r.baseUnit,
    ":hover": {
      backgroundColor: i.dangerLight,
      color: i.danger
    }
  });
}, XT = function(e) {
  var t = e.children, n = e.innerProps;
  return ze("div", n, t);
}, Ude = XT, Hde = XT;
function $de(e) {
  var t = e.children, n = e.innerProps;
  return ze("div", Te({
    role: "button"
  }, n), t || ze(g_, {
    size: 14
  }));
}
var Yde = function(e) {
  var t = e.children, n = e.components, r = e.data, o = e.innerProps, i = e.isDisabled, s = e.removeProps, u = e.selectProps, c = n.Container, d = n.Label, p = n.Remove;
  return ze(c, {
    data: r,
    innerProps: Le(Le({}, Jt(e, "multiValue", {
      "multi-value": !0,
      "multi-value--is-disabled": i
    })), o),
    selectProps: u
  }, ze(d, {
    data: r,
    innerProps: Le({}, Jt(e, "multiValueLabel", {
      "multi-value__label": !0
    })),
    selectProps: u
  }, t), ze(p, {
    data: r,
    innerProps: Le(Le({}, Jt(e, "multiValueRemove", {
      "multi-value__remove": !0
    })), {}, {
      "aria-label": "Remove ".concat(t || "option")
    }, s),
    selectProps: u
  }));
}, qde = Yde, Xde = function(e, t) {
  var n = e.isDisabled, r = e.isFocused, o = e.isSelected, i = e.theme, s = i.spacing, u = i.colors;
  return Le({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, t ? {} : {
    backgroundColor: o ? u.primary : r ? u.primary25 : "transparent",
    color: n ? u.neutral20 : o ? u.neutral0 : "inherit",
    padding: "".concat(s.baseUnit * 2, "px ").concat(s.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: n ? void 0 : o ? u.primary : u.primary50
    }
  });
}, Wde = function(e) {
  var t = e.children, n = e.isDisabled, r = e.isFocused, o = e.isSelected, i = e.innerRef, s = e.innerProps;
  return ze("div", Te({}, Jt(e, "option", {
    option: !0,
    "option--is-disabled": n,
    "option--is-focused": r,
    "option--is-selected": o
  }), {
    ref: i,
    "aria-disabled": n
  }, s), t);
}, Gde = Wde, Zde = function(e, t) {
  var n = e.theme, r = n.spacing, o = n.colors;
  return Le({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, t ? {} : {
    color: o.neutral50,
    marginLeft: r.baseUnit / 2,
    marginRight: r.baseUnit / 2
  });
}, Kde = function(e) {
  var t = e.children, n = e.innerProps;
  return ze("div", Te({}, Jt(e, "placeholder", {
    placeholder: !0
  }), n), t);
}, Qde = Kde, Jde = function(e, t) {
  var n = e.isDisabled, r = e.theme, o = r.spacing, i = r.colors;
  return Le({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, t ? {} : {
    color: n ? i.neutral40 : i.neutral80,
    marginLeft: o.baseUnit / 2,
    marginRight: o.baseUnit / 2
  });
}, efe = function(e) {
  var t = e.children, n = e.isDisabled, r = e.innerProps;
  return ze("div", Te({}, Jt(e, "singleValue", {
    "single-value": !0,
    "single-value--is-disabled": n
  }), r), t);
}, tfe = efe, nfe = {
  ClearIndicator: vde,
  Control: Cde,
  DropdownIndicator: gde,
  DownChevron: $T,
  CrossIcon: g_,
  Group: jde,
  GroupHeading: Rde,
  IndicatorsContainer: dde,
  IndicatorSeparator: wde,
  Input: Ide,
  LoadingIndicator: _de,
  Menu: Kce,
  MenuList: Jce,
  MenuPortal: ide,
  LoadingMessage: rde,
  NoOptionsMessage: nde,
  MultiValue: qde,
  MultiValueContainer: Ude,
  MultiValueLabel: Hde,
  MultiValueRemove: $de,
  Option: Gde,
  Placeholder: Qde,
  SelectContainer: sde,
  SingleValue: tfe,
  ValueContainer: ude
}, rfe = function(e) {
  return Le(Le({}, nfe), e.components);
}, z3 = Number.isNaN || function(e) {
  return typeof e == "number" && e !== e;
};
function ofe(e, t) {
  return !!(e === t || z3(e) && z3(t));
}
function ife(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++)
    if (!ofe(e[n], t[n]))
      return !1;
  return !0;
}
function afe(e, t) {
  t === void 0 && (t = ife);
  var n = null;
  function r() {
    for (var o = [], i = 0; i < arguments.length; i++)
      o[i] = arguments[i];
    if (n && n.lastThis === this && t(o, n.lastArgs))
      return n.lastResult;
    var s = e.apply(this, o);
    return n = {
      lastResult: s,
      lastArgs: o,
      lastThis: this
    }, s;
  }
  return r.clear = function() {
    n = null;
  }, r;
}
var sfe = {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
}, lfe = function(e) {
  return ze("span", Te({
    css: sfe
  }, e));
}, T3 = lfe, ufe = {
  guidance: function(e) {
    var t = e.isSearchable, n = e.isMulti, r = e.tabSelectsValue, o = e.context, i = e.isInitialFocus;
    switch (o) {
      case "menu":
        return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(r ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return i ? "".concat(e["aria-label"] || "Select", " is focused ").concat(t ? ",type to refine list" : "", ", press Down to open the menu, ").concat(n ? " press left to focus selected values" : "") : "";
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function(e) {
    var t = e.action, n = e.label, r = n === void 0 ? "" : n, o = e.labels, i = e.isDisabled;
    switch (t) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(r, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(o.length > 1 ? "s" : "", " ").concat(o.join(","), ", selected.");
      case "select-option":
        return i ? "option ".concat(r, " is disabled. Select another option.") : "option ".concat(r, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function(e) {
    var t = e.context, n = e.focused, r = e.options, o = e.label, i = o === void 0 ? "" : o, s = e.selectValue, u = e.isDisabled, c = e.isSelected, d = e.isAppleDevice, p = function(y, b) {
      return y && y.length ? "".concat(y.indexOf(b) + 1, " of ").concat(y.length) : "";
    };
    if (t === "value" && s)
      return "value ".concat(i, " focused, ").concat(p(s, n), ".");
    if (t === "menu" && d) {
      var h = u ? " disabled" : "", g = "".concat(c ? " selected" : "").concat(h);
      return "".concat(i).concat(g, ", ").concat(p(r, n), ".");
    }
    return "";
  },
  onFilter: function(e) {
    var t = e.inputValue, n = e.resultsMessage;
    return "".concat(n).concat(t ? " for search term " + t : "", ".");
  }
}, cfe = function(e) {
  var t = e.ariaSelection, n = e.focusedOption, r = e.focusedValue, o = e.focusableOptions, i = e.isFocused, s = e.selectValue, u = e.selectProps, c = e.id, d = e.isAppleDevice, p = u.ariaLiveMessages, h = u.getOptionLabel, g = u.inputValue, y = u.isMulti, b = u.isOptionDisabled, v = u.isSearchable, x = u.menuIsOpen, _ = u.options, O = u.screenReaderStatus, C = u.tabSelectsValue, N = u.isLoading, R = u["aria-label"], z = u["aria-live"], j = S.useMemo(function() {
    return Le(Le({}, ufe), p || {});
  }, [p]), I = S.useMemo(function() {
    var D = "";
    if (t && j.onChange) {
      var F = t.option, P = t.options, H = t.removedValue, Y = t.removedValues, q = t.value, M = function(le) {
        return Array.isArray(le) ? null : le;
      }, X = H || F || M(q), K = X ? h(X) : "", L = P || Y || void 0, ee = L ? L.map(h) : [], ae = Le({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: X && b(X, s),
        label: K,
        labels: ee
      }, t);
      D = j.onChange(ae);
    }
    return D;
  }, [t, j, b, s, h]), $ = S.useMemo(function() {
    var D = "", F = n || r, P = !!(n && s && s.includes(n));
    if (F && j.onFocus) {
      var H = {
        focused: F,
        label: h(F),
        isDisabled: b(F, s),
        isSelected: P,
        options: o,
        context: F === n ? "menu" : "value",
        selectValue: s,
        isAppleDevice: d
      };
      D = j.onFocus(H);
    }
    return D;
  }, [n, r, h, b, j, o, s, d]), A = S.useMemo(function() {
    var D = "";
    if (x && _.length && !N && j.onFilter) {
      var F = O({
        count: o.length
      });
      D = j.onFilter({
        inputValue: g,
        resultsMessage: F
      });
    }
    return D;
  }, [o, g, x, j, _, O, N]), V = t?.action === "initial-input-focus", U = S.useMemo(function() {
    var D = "";
    if (j.guidance) {
      var F = r ? "value" : x ? "menu" : "input";
      D = j.guidance({
        "aria-label": R,
        context: F,
        isDisabled: n && b(n, s),
        isMulti: y,
        isSearchable: v,
        tabSelectsValue: C,
        isInitialFocus: V
      });
    }
    return D;
  }, [R, n, r, y, b, v, x, j, s, C, V]), W = ze(S.Fragment, null, ze("span", {
    id: "aria-selection"
  }, I), ze("span", {
    id: "aria-focused"
  }, $), ze("span", {
    id: "aria-results"
  }, A), ze("span", {
    id: "aria-guidance"
  }, U));
  return ze(S.Fragment, null, ze(T3, {
    id: c
  }, V && W), ze(T3, {
    "aria-live": z,
    "aria-atomic": "false",
    "aria-relevant": "additions text",
    role: "log"
  }, i && !V && W));
}, dfe = cfe, Qx = [{
  base: "A",
  letters: "A"
}, {
  base: "AA",
  letters: ""
}, {
  base: "AE",
  letters: ""
}, {
  base: "AO",
  letters: ""
}, {
  base: "AU",
  letters: ""
}, {
  base: "AV",
  letters: ""
}, {
  base: "AY",
  letters: ""
}, {
  base: "B",
  letters: "B"
}, {
  base: "C",
  letters: "C"
}, {
  base: "D",
  letters: "D"
}, {
  base: "DZ",
  letters: ""
}, {
  base: "Dz",
  letters: ""
}, {
  base: "E",
  letters: "E"
}, {
  base: "F",
  letters: "F"
}, {
  base: "G",
  letters: "G"
}, {
  base: "H",
  letters: "H"
}, {
  base: "I",
  letters: "I"
}, {
  base: "J",
  letters: "J"
}, {
  base: "K",
  letters: "K"
}, {
  base: "L",
  letters: "L"
}, {
  base: "LJ",
  letters: ""
}, {
  base: "Lj",
  letters: ""
}, {
  base: "M",
  letters: "M"
}, {
  base: "N",
  letters: "N"
}, {
  base: "NJ",
  letters: ""
}, {
  base: "Nj",
  letters: ""
}, {
  base: "O",
  letters: "O"
}, {
  base: "OI",
  letters: ""
}, {
  base: "OO",
  letters: ""
}, {
  base: "OU",
  letters: ""
}, {
  base: "P",
  letters: "P"
}, {
  base: "Q",
  letters: "Q"
}, {
  base: "R",
  letters: "R"
}, {
  base: "S",
  letters: "S"
}, {
  base: "T",
  letters: "T"
}, {
  base: "TZ",
  letters: ""
}, {
  base: "U",
  letters: "U"
}, {
  base: "V",
  letters: "V"
}, {
  base: "VY",
  letters: ""
}, {
  base: "W",
  letters: "W"
}, {
  base: "X",
  letters: "X"
}, {
  base: "Y",
  letters: "Y"
}, {
  base: "Z",
  letters: "Z"
}, {
  base: "a",
  letters: "a"
}, {
  base: "aa",
  letters: ""
}, {
  base: "ae",
  letters: ""
}, {
  base: "ao",
  letters: ""
}, {
  base: "au",
  letters: ""
}, {
  base: "av",
  letters: ""
}, {
  base: "ay",
  letters: ""
}, {
  base: "b",
  letters: "b"
}, {
  base: "c",
  letters: "c"
}, {
  base: "d",
  letters: "d"
}, {
  base: "dz",
  letters: ""
}, {
  base: "e",
  letters: "e"
}, {
  base: "f",
  letters: "f"
}, {
  base: "g",
  letters: "g"
}, {
  base: "h",
  letters: "h"
}, {
  base: "hv",
  letters: ""
}, {
  base: "i",
  letters: "i"
}, {
  base: "j",
  letters: "j"
}, {
  base: "k",
  letters: "k"
}, {
  base: "l",
  letters: "l"
}, {
  base: "lj",
  letters: ""
}, {
  base: "m",
  letters: "m"
}, {
  base: "n",
  letters: "n"
}, {
  base: "nj",
  letters: ""
}, {
  base: "o",
  letters: "o"
}, {
  base: "oi",
  letters: ""
}, {
  base: "ou",
  letters: ""
}, {
  base: "oo",
  letters: ""
}, {
  base: "p",
  letters: "p"
}, {
  base: "q",
  letters: "q"
}, {
  base: "r",
  letters: "r"
}, {
  base: "s",
  letters: "s"
}, {
  base: "t",
  letters: "t"
}, {
  base: "tz",
  letters: ""
}, {
  base: "u",
  letters: "u"
}, {
  base: "v",
  letters: "v"
}, {
  base: "vy",
  letters: ""
}, {
  base: "w",
  letters: "w"
}, {
  base: "x",
  letters: "x"
}, {
  base: "y",
  letters: "y"
}, {
  base: "z",
  letters: "z"
}], ffe = new RegExp("[" + Qx.map(function(e) {
  return e.letters;
}).join("") + "]", "g"), WT = {};
for (var ow = 0; ow < Qx.length; ow++)
  for (var iw = Qx[ow], aw = 0; aw < iw.letters.length; aw++)
    WT[iw.letters[aw]] = iw.base;
var GT = function(e) {
  return e.replace(ffe, function(t) {
    return WT[t];
  });
}, pfe = afe(GT), D3 = function(e) {
  return e.replace(/^\s+|\s+$/g, "");
}, hfe = function(e) {
  return "".concat(e.label, " ").concat(e.value);
}, mfe = function(e) {
  return function(t, n) {
    if (t.data.__isNew__) return !0;
    var r = Le({
      ignoreCase: !0,
      ignoreAccents: !0,
      stringify: hfe,
      trim: !0,
      matchFrom: "any"
    }, e), o = r.ignoreCase, i = r.ignoreAccents, s = r.stringify, u = r.trim, c = r.matchFrom, d = u ? D3(n) : n, p = u ? D3(s(t)) : s(t);
    return o && (d = d.toLowerCase(), p = p.toLowerCase()), i && (d = pfe(d), p = GT(p)), c === "start" ? p.substr(0, d.length) === d : p.indexOf(d) > -1;
  };
}, gfe = ["innerRef"];
function yfe(e) {
  var t = e.innerRef, n = la(e, gfe), r = Hce(n, "onExited", "in", "enter", "exit", "appear");
  return ze("input", Te({
    ref: t
  }, r, {
    css: /* @__PURE__ */ i_({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, "", "")
  }));
}
var vfe = function(e) {
  e.cancelable && e.preventDefault(), e.stopPropagation();
};
function bfe(e) {
  var t = e.isEnabled, n = e.onBottomArrive, r = e.onBottomLeave, o = e.onTopArrive, i = e.onTopLeave, s = S.useRef(!1), u = S.useRef(!1), c = S.useRef(0), d = S.useRef(null), p = S.useCallback(function(x, _) {
    if (d.current !== null) {
      var O = d.current, C = O.scrollTop, N = O.scrollHeight, R = O.clientHeight, z = d.current, j = _ > 0, I = N - R - C, $ = !1;
      I > _ && s.current && (r && r(x), s.current = !1), j && u.current && (i && i(x), u.current = !1), j && _ > I ? (n && !s.current && n(x), z.scrollTop = N, $ = !0, s.current = !0) : !j && -_ > C && (o && !u.current && o(x), z.scrollTop = 0, $ = !0, u.current = !0), $ && vfe(x);
    }
  }, [n, r, o, i]), h = S.useCallback(function(x) {
    p(x, x.deltaY);
  }, [p]), g = S.useCallback(function(x) {
    c.current = x.changedTouches[0].clientY;
  }, []), y = S.useCallback(function(x) {
    var _ = c.current - x.changedTouches[0].clientY;
    p(x, _);
  }, [p]), b = S.useCallback(function(x) {
    if (x) {
      var _ = Bce ? {
        passive: !1
      } : !1;
      x.addEventListener("wheel", h, _), x.addEventListener("touchstart", g, _), x.addEventListener("touchmove", y, _);
    }
  }, [y, g, h]), v = S.useCallback(function(x) {
    x && (x.removeEventListener("wheel", h, !1), x.removeEventListener("touchstart", g, !1), x.removeEventListener("touchmove", y, !1));
  }, [y, g, h]);
  return S.useEffect(function() {
    if (t) {
      var x = d.current;
      return b(x), function() {
        v(x);
      };
    }
  }, [t, b, v]), function(x) {
    d.current = x;
  };
}
var P3 = ["boxSizing", "height", "overflow", "paddingRight", "position"], L3 = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function I3(e) {
  e.cancelable && e.preventDefault();
}
function V3(e) {
  e.stopPropagation();
}
function B3() {
  var e = this.scrollTop, t = this.scrollHeight, n = e + this.offsetHeight;
  e === 0 ? this.scrollTop = 1 : n === t && (this.scrollTop = e - 1);
}
function F3() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var U3 = !!(typeof window < "u" && window.document && window.document.createElement), od = 0, ou = {
  capture: !1,
  passive: !1
};
function wfe(e) {
  var t = e.isEnabled, n = e.accountForScrollbars, r = n === void 0 ? !0 : n, o = S.useRef({}), i = S.useRef(null), s = S.useCallback(function(c) {
    if (U3) {
      var d = document.body, p = d && d.style;
      if (r && P3.forEach(function(b) {
        var v = p && p[b];
        o.current[b] = v;
      }), r && od < 1) {
        var h = parseInt(o.current.paddingRight, 10) || 0, g = document.body ? document.body.clientWidth : 0, y = window.innerWidth - g + h || 0;
        Object.keys(L3).forEach(function(b) {
          var v = L3[b];
          p && (p[b] = v);
        }), p && (p.paddingRight = "".concat(y, "px"));
      }
      d && F3() && (d.addEventListener("touchmove", I3, ou), c && (c.addEventListener("touchstart", B3, ou), c.addEventListener("touchmove", V3, ou))), od += 1;
    }
  }, [r]), u = S.useCallback(function(c) {
    if (U3) {
      var d = document.body, p = d && d.style;
      od = Math.max(od - 1, 0), r && od < 1 && P3.forEach(function(h) {
        var g = o.current[h];
        p && (p[h] = g);
      }), d && F3() && (d.removeEventListener("touchmove", I3, ou), c && (c.removeEventListener("touchstart", B3, ou), c.removeEventListener("touchmove", V3, ou)));
    }
  }, [r]);
  return S.useEffect(function() {
    if (t) {
      var c = i.current;
      return s(c), function() {
        u(c);
      };
    }
  }, [t, s, u]), function(c) {
    i.current = c;
  };
}
var xfe = function(e) {
  var t = e.target;
  return t.ownerDocument.activeElement && t.ownerDocument.activeElement.blur();
}, Sfe = {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
};
function _fe(e) {
  var t = e.children, n = e.lockEnabled, r = e.captureEnabled, o = r === void 0 ? !0 : r, i = e.onBottomArrive, s = e.onBottomLeave, u = e.onTopArrive, c = e.onTopLeave, d = bfe({
    isEnabled: o,
    onBottomArrive: i,
    onBottomLeave: s,
    onTopArrive: u,
    onTopLeave: c
  }), p = wfe({
    isEnabled: n
  }), h = function(g) {
    d(g), p(g);
  };
  return ze(S.Fragment, null, n && ze("div", {
    onClick: xfe,
    css: Sfe
  }), t(h));
}
var kfe = {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
}, Efe = function(e) {
  var t = e.name, n = e.onFocus;
  return ze("input", {
    required: !0,
    name: t,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: n,
    css: kfe,
    value: "",
    onChange: function() {
    }
  });
}, Cfe = Efe;
function y_(e) {
  var t;
  return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1;
}
function Ofe() {
  return y_(/^iPhone/i);
}
function ZT() {
  return y_(/^Mac/i);
}
function Afe() {
  return y_(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  ZT() && navigator.maxTouchPoints > 1;
}
function Nfe() {
  return Ofe() || Afe();
}
function Mfe() {
  return ZT() || Nfe();
}
var Rfe = function(e) {
  return e.label;
}, jfe = function(e) {
  return e.label;
}, zfe = function(e) {
  return e.value;
}, Tfe = function(e) {
  return !!e.isDisabled;
}, Dfe = {
  clearIndicator: yde,
  container: ade,
  control: kde,
  dropdownIndicator: mde,
  group: Ade,
  groupHeading: Mde,
  indicatorsContainer: cde,
  indicatorSeparator: bde,
  input: Tde,
  loadingIndicator: Sde,
  loadingMessage: tde,
  menu: Wce,
  menuList: Qce,
  menuPortal: ode,
  multiValue: Vde,
  multiValueLabel: Bde,
  multiValueRemove: Fde,
  noOptionsMessage: ede,
  option: Xde,
  placeholder: Zde,
  singleValue: Jde,
  valueContainer: lde
}, Pfe = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
}, Lfe = 4, KT = 4, Ife = 38, Vfe = KT * 2, Bfe = {
  baseUnit: KT,
  controlHeight: Ife,
  menuGutter: Vfe
}, sw = {
  borderRadius: Lfe,
  colors: Pfe,
  spacing: Bfe
}, Ffe = {
  "aria-live": "polite",
  backspaceRemovesValue: !0,
  blurInputOnSelect: R3(),
  captureMenuScroll: !R3(),
  classNames: {},
  closeMenuOnSelect: !0,
  closeMenuOnScroll: !1,
  components: {},
  controlShouldRenderValue: !0,
  escapeClearsValue: !1,
  filterOption: mfe(),
  formatGroupLabel: Rfe,
  getOptionLabel: jfe,
  getOptionValue: zfe,
  isDisabled: !1,
  isLoading: !1,
  isMulti: !1,
  isRtl: !1,
  isSearchable: !0,
  isOptionDisabled: Tfe,
  loadingMessage: function() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: !1,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: !1,
  menuShouldScrollIntoView: !Ice(),
  noOptionsMessage: function() {
    return "No options";
  },
  openMenuOnFocus: !1,
  openMenuOnClick: !0,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function(e) {
    var t = e.count;
    return "".concat(t, " result").concat(t !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: !0,
  unstyled: !1
};
function H3(e, t, n, r) {
  var o = eD(e, t, n), i = tD(e, t, n), s = JT(e, t), u = Cm(e, t);
  return {
    type: "option",
    data: t,
    isDisabled: o,
    isSelected: i,
    label: s,
    value: u,
    index: r
  };
}
function Fh(e, t) {
  return e.options.map(function(n, r) {
    if ("options" in n) {
      var o = n.options.map(function(s, u) {
        return H3(e, s, t, u);
      }).filter(function(s) {
        return Y3(e, s);
      });
      return o.length > 0 ? {
        type: "group",
        data: n,
        options: o,
        index: r
      } : void 0;
    }
    var i = H3(e, n, t, r);
    return Y3(e, i) ? i : void 0;
  }).filter(Fce);
}
function QT(e) {
  return e.reduce(function(t, n) {
    return n.type === "group" ? t.push.apply(t, m_(n.options.map(function(r) {
      return r.data;
    }))) : t.push(n.data), t;
  }, []);
}
function $3(e, t) {
  return e.reduce(function(n, r) {
    return r.type === "group" ? n.push.apply(n, m_(r.options.map(function(o) {
      return {
        data: o.data,
        id: "".concat(t, "-").concat(r.index, "-").concat(o.index)
      };
    }))) : n.push({
      data: r.data,
      id: "".concat(t, "-").concat(r.index)
    }), n;
  }, []);
}
function Ufe(e, t) {
  return QT(Fh(e, t));
}
function Y3(e, t) {
  var n = e.inputValue, r = n === void 0 ? "" : n, o = t.data, i = t.isSelected, s = t.label, u = t.value;
  return (!rD(e) || !i) && nD(e, {
    label: s,
    value: u,
    data: o
  }, r);
}
function Hfe(e, t) {
  var n = e.focusedValue, r = e.selectValue, o = r.indexOf(n);
  if (o > -1) {
    var i = t.indexOf(n);
    if (i > -1)
      return n;
    if (o < t.length)
      return t[o];
  }
  return null;
}
function $fe(e, t) {
  var n = e.focusedOption;
  return n && t.indexOf(n) > -1 ? n : t[0];
}
var lw = function(e, t) {
  var n, r = (n = e.find(function(o) {
    return o.data === t;
  })) === null || n === void 0 ? void 0 : n.id;
  return r || null;
}, JT = function(e, t) {
  return e.getOptionLabel(t);
}, Cm = function(e, t) {
  return e.getOptionValue(t);
};
function eD(e, t, n) {
  return typeof e.isOptionDisabled == "function" ? e.isOptionDisabled(t, n) : !1;
}
function tD(e, t, n) {
  if (n.indexOf(t) > -1) return !0;
  if (typeof e.isOptionSelected == "function")
    return e.isOptionSelected(t, n);
  var r = Cm(e, t);
  return n.some(function(o) {
    return Cm(e, o) === r;
  });
}
function nD(e, t, n) {
  return e.filterOption ? e.filterOption(t, n) : !0;
}
var rD = function(e) {
  var t = e.hideSelectedOptions, n = e.isMulti;
  return t === void 0 ? n : t;
}, Yfe = 1, oD = /* @__PURE__ */ function(e) {
  kce(n, e);
  var t = Cce(n);
  function n(r) {
    var o;
    if (Sce(this, n), o = t.call(this, r), o.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedOptionId: null,
      focusableOptionsWithIds: [],
      focusedValue: null,
      inputIsHidden: !1,
      isFocused: !1,
      selectValue: [],
      clearFocusValueOnUpdate: !1,
      prevWasFocused: !1,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0,
      instancePrefix: ""
    }, o.blockOptionHover = !1, o.isComposing = !1, o.commonProps = void 0, o.initialTouchX = 0, o.initialTouchY = 0, o.openAfterFocus = !1, o.scrollToFocusedOptionOnUpdate = !1, o.userIsDragging = void 0, o.isAppleDevice = Mfe(), o.controlRef = null, o.getControlRef = function(c) {
      o.controlRef = c;
    }, o.focusedOptionRef = null, o.getFocusedOptionRef = function(c) {
      o.focusedOptionRef = c;
    }, o.menuListRef = null, o.getMenuListRef = function(c) {
      o.menuListRef = c;
    }, o.inputRef = null, o.getInputRef = function(c) {
      o.inputRef = c;
    }, o.focus = o.focusInput, o.blur = o.blurInput, o.onChange = function(c, d) {
      var p = o.props, h = p.onChange, g = p.name;
      d.name = g, o.ariaOnChange(c, d), h(c, d);
    }, o.setValue = function(c, d, p) {
      var h = o.props, g = h.closeMenuOnSelect, y = h.isMulti, b = h.inputValue;
      o.onInputChange("", {
        action: "set-value",
        prevInputValue: b
      }), g && (o.setState({
        inputIsHiddenAfterUpdate: !y
      }), o.onMenuClose()), o.setState({
        clearFocusValueOnUpdate: !0
      }), o.onChange(c, {
        action: d,
        option: p
      });
    }, o.selectOption = function(c) {
      var d = o.props, p = d.blurInputOnSelect, h = d.isMulti, g = d.name, y = o.state.selectValue, b = h && o.isOptionSelected(c, y), v = o.isOptionDisabled(c, y);
      if (b) {
        var x = o.getOptionValue(c);
        o.setValue(y.filter(function(_) {
          return o.getOptionValue(_) !== x;
        }), "deselect-option", c);
      } else if (!v)
        h ? o.setValue([].concat(m_(y), [c]), "select-option", c) : o.setValue(c, "select-option");
      else {
        o.ariaOnChange(c, {
          action: "select-option",
          option: c,
          name: g
        });
        return;
      }
      p && o.blurInput();
    }, o.removeValue = function(c) {
      var d = o.props.isMulti, p = o.state.selectValue, h = o.getOptionValue(c), g = p.filter(function(b) {
        return o.getOptionValue(b) !== h;
      }), y = ph(d, g, g[0] || null);
      o.onChange(y, {
        action: "remove-value",
        removedValue: c
      }), o.focusInput();
    }, o.clearValue = function() {
      var c = o.state.selectValue;
      o.onChange(ph(o.props.isMulti, [], null), {
        action: "clear",
        removedValues: c
      });
    }, o.popValue = function() {
      var c = o.props.isMulti, d = o.state.selectValue, p = d[d.length - 1], h = d.slice(0, d.length - 1), g = ph(c, h, h[0] || null);
      p && o.onChange(g, {
        action: "pop-value",
        removedValue: p
      });
    }, o.getFocusedOptionId = function(c) {
      return lw(o.state.focusableOptionsWithIds, c);
    }, o.getFocusableOptionsWithIds = function() {
      return $3(Fh(o.props, o.state.selectValue), o.getElementId("option"));
    }, o.getValue = function() {
      return o.state.selectValue;
    }, o.cx = function() {
      for (var c = arguments.length, d = new Array(c), p = 0; p < c; p++)
        d[p] = arguments[p];
      return zce.apply(void 0, [o.props.classNamePrefix].concat(d));
    }, o.getOptionLabel = function(c) {
      return JT(o.props, c);
    }, o.getOptionValue = function(c) {
      return Cm(o.props, c);
    }, o.getStyles = function(c, d) {
      var p = o.props.unstyled, h = Dfe[c](d, p);
      h.boxSizing = "border-box";
      var g = o.props.styles[c];
      return g ? g(h, d) : h;
    }, o.getClassNames = function(c, d) {
      var p, h;
      return (p = (h = o.props.classNames)[c]) === null || p === void 0 ? void 0 : p.call(h, d);
    }, o.getElementId = function(c) {
      return "".concat(o.state.instancePrefix, "-").concat(c);
    }, o.getComponents = function() {
      return rfe(o.props);
    }, o.buildCategorizedOptions = function() {
      return Fh(o.props, o.state.selectValue);
    }, o.getCategorizedOptions = function() {
      return o.props.menuIsOpen ? o.buildCategorizedOptions() : [];
    }, o.buildFocusableOptions = function() {
      return QT(o.buildCategorizedOptions());
    }, o.getFocusableOptions = function() {
      return o.props.menuIsOpen ? o.buildFocusableOptions() : [];
    }, o.ariaOnChange = function(c, d) {
      o.setState({
        ariaSelection: Le({
          value: c
        }, d)
      });
    }, o.onMenuMouseDown = function(c) {
      c.button === 0 && (c.stopPropagation(), c.preventDefault(), o.focusInput());
    }, o.onMenuMouseMove = function(c) {
      o.blockOptionHover = !1;
    }, o.onControlMouseDown = function(c) {
      if (!c.defaultPrevented) {
        var d = o.props.openMenuOnClick;
        o.state.isFocused ? o.props.menuIsOpen ? c.target.tagName !== "INPUT" && c.target.tagName !== "TEXTAREA" && o.onMenuClose() : d && o.openMenu("first") : (d && (o.openAfterFocus = !0), o.focusInput()), c.target.tagName !== "INPUT" && c.target.tagName !== "TEXTAREA" && c.preventDefault();
      }
    }, o.onDropdownIndicatorMouseDown = function(c) {
      if (!(c && c.type === "mousedown" && c.button !== 0) && !o.props.isDisabled) {
        var d = o.props, p = d.isMulti, h = d.menuIsOpen;
        o.focusInput(), h ? (o.setState({
          inputIsHiddenAfterUpdate: !p
        }), o.onMenuClose()) : o.openMenu("first"), c.preventDefault();
      }
    }, o.onClearIndicatorMouseDown = function(c) {
      c && c.type === "mousedown" && c.button !== 0 || (o.clearValue(), c.preventDefault(), o.openAfterFocus = !1, c.type === "touchend" ? o.focusInput() : setTimeout(function() {
        return o.focusInput();
      }));
    }, o.onScroll = function(c) {
      typeof o.props.closeMenuOnScroll == "boolean" ? c.target instanceof HTMLElement && Fg(c.target) && o.props.onMenuClose() : typeof o.props.closeMenuOnScroll == "function" && o.props.closeMenuOnScroll(c) && o.props.onMenuClose();
    }, o.onCompositionStart = function() {
      o.isComposing = !0;
    }, o.onCompositionEnd = function() {
      o.isComposing = !1;
    }, o.onTouchStart = function(c) {
      var d = c.touches, p = d && d.item(0);
      p && (o.initialTouchX = p.clientX, o.initialTouchY = p.clientY, o.userIsDragging = !1);
    }, o.onTouchMove = function(c) {
      var d = c.touches, p = d && d.item(0);
      if (p) {
        var h = Math.abs(p.clientX - o.initialTouchX), g = Math.abs(p.clientY - o.initialTouchY), y = 5;
        o.userIsDragging = h > y || g > y;
      }
    }, o.onTouchEnd = function(c) {
      o.userIsDragging || (o.controlRef && !o.controlRef.contains(c.target) && o.menuListRef && !o.menuListRef.contains(c.target) && o.blurInput(), o.initialTouchX = 0, o.initialTouchY = 0);
    }, o.onControlTouchEnd = function(c) {
      o.userIsDragging || o.onControlMouseDown(c);
    }, o.onClearIndicatorTouchEnd = function(c) {
      o.userIsDragging || o.onClearIndicatorMouseDown(c);
    }, o.onDropdownIndicatorTouchEnd = function(c) {
      o.userIsDragging || o.onDropdownIndicatorMouseDown(c);
    }, o.handleInputChange = function(c) {
      var d = o.props.inputValue, p = c.currentTarget.value;
      o.setState({
        inputIsHiddenAfterUpdate: !1
      }), o.onInputChange(p, {
        action: "input-change",
        prevInputValue: d
      }), o.props.menuIsOpen || o.onMenuOpen();
    }, o.onInputFocus = function(c) {
      o.props.onFocus && o.props.onFocus(c), o.setState({
        inputIsHiddenAfterUpdate: !1,
        isFocused: !0
      }), (o.openAfterFocus || o.props.openMenuOnFocus) && o.openMenu("first"), o.openAfterFocus = !1;
    }, o.onInputBlur = function(c) {
      var d = o.props.inputValue;
      if (o.menuListRef && o.menuListRef.contains(document.activeElement)) {
        o.inputRef.focus();
        return;
      }
      o.props.onBlur && o.props.onBlur(c), o.onInputChange("", {
        action: "input-blur",
        prevInputValue: d
      }), o.onMenuClose(), o.setState({
        focusedValue: null,
        isFocused: !1
      });
    }, o.onOptionHover = function(c) {
      if (!(o.blockOptionHover || o.state.focusedOption === c)) {
        var d = o.getFocusableOptions(), p = d.indexOf(c);
        o.setState({
          focusedOption: c,
          focusedOptionId: p > -1 ? o.getFocusedOptionId(c) : null
        });
      }
    }, o.shouldHideSelectedOptions = function() {
      return rD(o.props);
    }, o.onValueInputFocus = function(c) {
      c.preventDefault(), c.stopPropagation(), o.focus();
    }, o.onKeyDown = function(c) {
      var d = o.props, p = d.isMulti, h = d.backspaceRemovesValue, g = d.escapeClearsValue, y = d.inputValue, b = d.isClearable, v = d.isDisabled, x = d.menuIsOpen, _ = d.onKeyDown, O = d.tabSelectsValue, C = d.openMenuOnFocus, N = o.state, R = N.focusedOption, z = N.focusedValue, j = N.selectValue;
      if (!v && !(typeof _ == "function" && (_(c), c.defaultPrevented))) {
        switch (o.blockOptionHover = !0, c.key) {
          case "ArrowLeft":
            if (!p || y) return;
            o.focusValue("previous");
            break;
          case "ArrowRight":
            if (!p || y) return;
            o.focusValue("next");
            break;
          case "Delete":
          case "Backspace":
            if (y) return;
            if (z)
              o.removeValue(z);
            else {
              if (!h) return;
              p ? o.popValue() : b && o.clearValue();
            }
            break;
          case "Tab":
            if (o.isComposing || c.shiftKey || !x || !O || !R || // don't capture the event if the menu opens on focus and the focused
            // option is already selected; it breaks the flow of navigation
            C && o.isOptionSelected(R, j))
              return;
            o.selectOption(R);
            break;
          case "Enter":
            if (c.keyCode === 229)
              break;
            if (x) {
              if (!R || o.isComposing) return;
              o.selectOption(R);
              break;
            }
            return;
          case "Escape":
            x ? (o.setState({
              inputIsHiddenAfterUpdate: !1
            }), o.onInputChange("", {
              action: "menu-close",
              prevInputValue: y
            }), o.onMenuClose()) : b && g && o.clearValue();
            break;
          case " ":
            if (y)
              return;
            if (!x) {
              o.openMenu("first");
              break;
            }
            if (!R) return;
            o.selectOption(R);
            break;
          case "ArrowUp":
            x ? o.focusOption("up") : o.openMenu("last");
            break;
          case "ArrowDown":
            x ? o.focusOption("down") : o.openMenu("first");
            break;
          case "PageUp":
            if (!x) return;
            o.focusOption("pageup");
            break;
          case "PageDown":
            if (!x) return;
            o.focusOption("pagedown");
            break;
          case "Home":
            if (!x) return;
            o.focusOption("first");
            break;
          case "End":
            if (!x) return;
            o.focusOption("last");
            break;
          default:
            return;
        }
        c.preventDefault();
      }
    }, o.state.instancePrefix = "react-select-" + (o.props.instanceId || ++Yfe), o.state.selectValue = N3(r.value), r.menuIsOpen && o.state.selectValue.length) {
      var i = o.getFocusableOptionsWithIds(), s = o.buildFocusableOptions(), u = s.indexOf(o.state.selectValue[0]);
      o.state.focusableOptionsWithIds = i, o.state.focusedOption = s[u], o.state.focusedOptionId = lw(i, s[u]);
    }
    return o;
  }
  return _ce(n, [{
    key: "componentDidMount",
    value: function() {
      this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, !0), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && M3(this.menuListRef, this.focusedOptionRef);
    }
  }, {
    key: "componentDidUpdate",
    value: function(r) {
      var o = this.props, i = o.isDisabled, s = o.menuIsOpen, u = this.state.isFocused;
      (u && !i && r.isDisabled || // ensure focus is on the Input when the menu opens
      u && s && !r.menuIsOpen) && this.focusInput(), u && i && !r.isDisabled ? this.setState({
        isFocused: !1
      }, this.onMenuClose) : !u && !i && r.isDisabled && this.inputRef === document.activeElement && this.setState({
        isFocused: !0
      }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (M3(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = !1);
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, !0);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      }), this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function(r, o) {
      this.props.onInputChange(r, o);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function() {
      this.inputRef && this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function() {
      this.inputRef && this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function(r) {
      var o = this, i = this.state, s = i.selectValue, u = i.isFocused, c = this.buildFocusableOptions(), d = r === "first" ? 0 : c.length - 1;
      if (!this.props.isMulti) {
        var p = c.indexOf(s[0]);
        p > -1 && (d = p);
      }
      this.scrollToFocusedOptionOnUpdate = !(u && this.menuListRef), this.setState({
        inputIsHiddenAfterUpdate: !1,
        focusedValue: null,
        focusedOption: c[d],
        focusedOptionId: this.getFocusedOptionId(c[d])
      }, function() {
        return o.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function(r) {
      var o = this.state, i = o.selectValue, s = o.focusedValue;
      if (this.props.isMulti) {
        this.setState({
          focusedOption: null
        });
        var u = i.indexOf(s);
        s || (u = -1);
        var c = i.length - 1, d = -1;
        if (i.length) {
          switch (r) {
            case "previous":
              u === 0 ? d = 0 : u === -1 ? d = c : d = u - 1;
              break;
            case "next":
              u > -1 && u < c && (d = u + 1);
              break;
          }
          this.setState({
            inputIsHidden: d !== -1,
            focusedValue: i[d]
          });
        }
      }
    }
  }, {
    key: "focusOption",
    value: function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first", o = this.props.pageSize, i = this.state.focusedOption, s = this.getFocusableOptions();
      if (s.length) {
        var u = 0, c = s.indexOf(i);
        i || (c = -1), r === "up" ? u = c > 0 ? c - 1 : s.length - 1 : r === "down" ? u = (c + 1) % s.length : r === "pageup" ? (u = c - o, u < 0 && (u = 0)) : r === "pagedown" ? (u = c + o, u > s.length - 1 && (u = s.length - 1)) : r === "last" && (u = s.length - 1), this.scrollToFocusedOptionOnUpdate = !0, this.setState({
          focusedOption: s[u],
          focusedValue: null,
          focusedOptionId: this.getFocusedOptionId(s[u])
        });
      }
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      function() {
        return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(sw) : Le(Le({}, sw), this.props.theme) : sw;
      }
    )
  }, {
    key: "getCommonProps",
    value: function() {
      var r = this.clearValue, o = this.cx, i = this.getStyles, s = this.getClassNames, u = this.getValue, c = this.selectOption, d = this.setValue, p = this.props, h = p.isMulti, g = p.isRtl, y = p.options, b = this.hasValue();
      return {
        clearValue: r,
        cx: o,
        getStyles: i,
        getClassNames: s,
        getValue: u,
        hasValue: b,
        isMulti: h,
        isRtl: g,
        options: y,
        selectOption: c,
        selectProps: p,
        setValue: d,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function() {
      var r = this.state.selectValue;
      return r.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function() {
      var r = this.props, o = r.isClearable, i = r.isMulti;
      return o === void 0 ? i : o;
    }
  }, {
    key: "isOptionDisabled",
    value: function(r, o) {
      return eD(this.props, r, o);
    }
  }, {
    key: "isOptionSelected",
    value: function(r, o) {
      return tD(this.props, r, o);
    }
  }, {
    key: "filterOption",
    value: function(r, o) {
      return nD(this.props, r, o);
    }
  }, {
    key: "formatOptionLabel",
    value: function(r, o) {
      if (typeof this.props.formatOptionLabel == "function") {
        var i = this.props.inputValue, s = this.state.selectValue;
        return this.props.formatOptionLabel(r, {
          context: o,
          inputValue: i,
          selectValue: s
        });
      } else
        return this.getOptionLabel(r);
    }
  }, {
    key: "formatGroupLabel",
    value: function(r) {
      return this.props.formatGroupLabel(r);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, !1), document.addEventListener("compositionend", this.onCompositionEnd, !1));
      }
    )
  }, {
    key: "stopListeningComposition",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd));
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, !1), document.addEventListener("touchmove", this.onTouchMove, !1), document.addEventListener("touchend", this.onTouchEnd, !1));
      }
    )
  }, {
    key: "stopListeningToTouch",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd));
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      function() {
        var r = this.props, o = r.isDisabled, i = r.isSearchable, s = r.inputId, u = r.inputValue, c = r.tabIndex, d = r.form, p = r.menuIsOpen, h = r.required, g = this.getComponents(), y = g.Input, b = this.state, v = b.inputIsHidden, x = b.ariaSelection, _ = this.commonProps, O = s || this.getElementId("input"), C = Le(Le(Le({
          "aria-autocomplete": "list",
          "aria-expanded": p,
          "aria-haspopup": !0,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": h,
          role: "combobox",
          "aria-activedescendant": this.isAppleDevice ? void 0 : this.state.focusedOptionId || ""
        }, p && {
          "aria-controls": this.getElementId("listbox")
        }), !i && {
          "aria-readonly": !0
        }), this.hasValue() ? x?.action === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        return i ? /* @__PURE__ */ S.createElement(y, Te({}, _, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id: O,
          innerRef: this.getInputRef,
          isDisabled: o,
          isHidden: v,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex: c,
          form: d,
          type: "text",
          value: u
        }, C)) : /* @__PURE__ */ S.createElement(yfe, Te({
          id: O,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: km,
          onFocus: this.onInputFocus,
          disabled: o,
          tabIndex: c,
          inputMode: "none",
          form: d,
          value: ""
        }, C));
      }
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function() {
      var r = this, o = this.getComponents(), i = o.MultiValue, s = o.MultiValueContainer, u = o.MultiValueLabel, c = o.MultiValueRemove, d = o.SingleValue, p = o.Placeholder, h = this.commonProps, g = this.props, y = g.controlShouldRenderValue, b = g.isDisabled, v = g.isMulti, x = g.inputValue, _ = g.placeholder, O = this.state, C = O.selectValue, N = O.focusedValue, R = O.isFocused;
      if (!this.hasValue() || !y)
        return x ? null : /* @__PURE__ */ S.createElement(p, Te({}, h, {
          key: "placeholder",
          isDisabled: b,
          isFocused: R,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), _);
      if (v)
        return C.map(function(j, I) {
          var $ = j === N, A = "".concat(r.getOptionLabel(j), "-").concat(r.getOptionValue(j));
          return /* @__PURE__ */ S.createElement(i, Te({}, h, {
            components: {
              Container: s,
              Label: u,
              Remove: c
            },
            isFocused: $,
            isDisabled: b,
            key: A,
            index: I,
            removeProps: {
              onClick: function() {
                return r.removeValue(j);
              },
              onTouchEnd: function() {
                return r.removeValue(j);
              },
              onMouseDown: function(V) {
                V.preventDefault();
              }
            },
            data: j
          }), r.formatOptionLabel(j, "value"));
        });
      if (x)
        return null;
      var z = C[0];
      return /* @__PURE__ */ S.createElement(d, Te({}, h, {
        data: z,
        isDisabled: b
      }), this.formatOptionLabel(z, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function() {
      var r = this.getComponents(), o = r.ClearIndicator, i = this.commonProps, s = this.props, u = s.isDisabled, c = s.isLoading, d = this.state.isFocused;
      if (!this.isClearable() || !o || u || !this.hasValue() || c)
        return null;
      var p = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ S.createElement(o, Te({}, i, {
        innerProps: p,
        isFocused: d
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function() {
      var r = this.getComponents(), o = r.LoadingIndicator, i = this.commonProps, s = this.props, u = s.isDisabled, c = s.isLoading, d = this.state.isFocused;
      if (!o || !c) return null;
      var p = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ S.createElement(o, Te({}, i, {
        innerProps: p,
        isDisabled: u,
        isFocused: d
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function() {
      var r = this.getComponents(), o = r.DropdownIndicator, i = r.IndicatorSeparator;
      if (!o || !i) return null;
      var s = this.commonProps, u = this.props.isDisabled, c = this.state.isFocused;
      return /* @__PURE__ */ S.createElement(i, Te({}, s, {
        isDisabled: u,
        isFocused: c
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function() {
      var r = this.getComponents(), o = r.DropdownIndicator;
      if (!o) return null;
      var i = this.commonProps, s = this.props.isDisabled, u = this.state.isFocused, c = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ S.createElement(o, Te({}, i, {
        innerProps: c,
        isDisabled: s,
        isFocused: u
      }));
    }
  }, {
    key: "renderMenu",
    value: function() {
      var r = this, o = this.getComponents(), i = o.Group, s = o.GroupHeading, u = o.Menu, c = o.MenuList, d = o.MenuPortal, p = o.LoadingMessage, h = o.NoOptionsMessage, g = o.Option, y = this.commonProps, b = this.state.focusedOption, v = this.props, x = v.captureMenuScroll, _ = v.inputValue, O = v.isLoading, C = v.loadingMessage, N = v.minMenuHeight, R = v.maxMenuHeight, z = v.menuIsOpen, j = v.menuPlacement, I = v.menuPosition, $ = v.menuPortalTarget, A = v.menuShouldBlockScroll, V = v.menuShouldScrollIntoView, U = v.noOptionsMessage, W = v.onMenuScrollToTop, D = v.onMenuScrollToBottom;
      if (!z) return null;
      var F = function(X, K) {
        var L = X.type, ee = X.data, ae = X.isDisabled, le = X.isSelected, me = X.label, se = X.value, he = b === ee, _e = ae ? void 0 : function() {
          return r.onOptionHover(ee);
        }, Se = ae ? void 0 : function() {
          return r.selectOption(ee);
        }, Ee = "".concat(r.getElementId("option"), "-").concat(K), Ie = {
          id: Ee,
          onClick: Se,
          onMouseMove: _e,
          onMouseOver: _e,
          tabIndex: -1,
          role: "option",
          "aria-selected": r.isAppleDevice ? void 0 : le
          // is not supported on Apple devices
        };
        return /* @__PURE__ */ S.createElement(g, Te({}, y, {
          innerProps: Ie,
          data: ee,
          isDisabled: ae,
          isSelected: le,
          key: Ee,
          label: me,
          type: L,
          value: se,
          isFocused: he,
          innerRef: he ? r.getFocusedOptionRef : void 0
        }), r.formatOptionLabel(X.data, "menu"));
      }, P;
      if (this.hasOptions())
        P = this.getCategorizedOptions().map(function(X) {
          if (X.type === "group") {
            var K = X.data, L = X.options, ee = X.index, ae = "".concat(r.getElementId("group"), "-").concat(ee), le = "".concat(ae, "-heading");
            return /* @__PURE__ */ S.createElement(i, Te({}, y, {
              key: ae,
              data: K,
              options: L,
              Heading: s,
              headingProps: {
                id: le,
                data: X.data
              },
              label: r.formatGroupLabel(X.data)
            }), X.options.map(function(me) {
              return F(me, "".concat(ee, "-").concat(me.index));
            }));
          } else if (X.type === "option")
            return F(X, "".concat(X.index));
        });
      else if (O) {
        var H = C({
          inputValue: _
        });
        if (H === null) return null;
        P = /* @__PURE__ */ S.createElement(p, y, H);
      } else {
        var Y = U({
          inputValue: _
        });
        if (Y === null) return null;
        P = /* @__PURE__ */ S.createElement(h, y, Y);
      }
      var q = {
        minMenuHeight: N,
        maxMenuHeight: R,
        menuPlacement: j,
        menuPosition: I,
        menuShouldScrollIntoView: V
      }, M = /* @__PURE__ */ S.createElement(Gce, Te({}, y, q), function(X) {
        var K = X.ref, L = X.placerProps, ee = L.placement, ae = L.maxHeight;
        return /* @__PURE__ */ S.createElement(u, Te({}, y, q, {
          innerRef: K,
          innerProps: {
            onMouseDown: r.onMenuMouseDown,
            onMouseMove: r.onMenuMouseMove
          },
          isLoading: O,
          placement: ee
        }), /* @__PURE__ */ S.createElement(_fe, {
          captureEnabled: x,
          onTopArrive: W,
          onBottomArrive: D,
          lockEnabled: A
        }, function(le) {
          return /* @__PURE__ */ S.createElement(c, Te({}, y, {
            innerRef: function(me) {
              r.getMenuListRef(me), le(me);
            },
            innerProps: {
              role: "listbox",
              "aria-multiselectable": y.isMulti,
              id: r.getElementId("listbox")
            },
            isLoading: O,
            maxHeight: ae,
            focusedOption: b
          }), P);
        }));
      });
      return $ || I === "fixed" ? /* @__PURE__ */ S.createElement(d, Te({}, y, {
        appendTo: $,
        controlElement: this.controlRef,
        menuPlacement: j,
        menuPosition: I
      }), M) : M;
    }
  }, {
    key: "renderFormField",
    value: function() {
      var r = this, o = this.props, i = o.delimiter, s = o.isDisabled, u = o.isMulti, c = o.name, d = o.required, p = this.state.selectValue;
      if (d && !this.hasValue() && !s)
        return /* @__PURE__ */ S.createElement(Cfe, {
          name: c,
          onFocus: this.onValueInputFocus
        });
      if (!(!c || s))
        if (u)
          if (i) {
            var h = p.map(function(b) {
              return r.getOptionValue(b);
            }).join(i);
            return /* @__PURE__ */ S.createElement("input", {
              name: c,
              type: "hidden",
              value: h
            });
          } else {
            var g = p.length > 0 ? p.map(function(b, v) {
              return /* @__PURE__ */ S.createElement("input", {
                key: "i-".concat(v),
                name: c,
                type: "hidden",
                value: r.getOptionValue(b)
              });
            }) : /* @__PURE__ */ S.createElement("input", {
              name: c,
              type: "hidden",
              value: ""
            });
            return /* @__PURE__ */ S.createElement("div", null, g);
          }
        else {
          var y = p[0] ? this.getOptionValue(p[0]) : "";
          return /* @__PURE__ */ S.createElement("input", {
            name: c,
            type: "hidden",
            value: y
          });
        }
    }
  }, {
    key: "renderLiveRegion",
    value: function() {
      var r = this.commonProps, o = this.state, i = o.ariaSelection, s = o.focusedOption, u = o.focusedValue, c = o.isFocused, d = o.selectValue, p = this.getFocusableOptions();
      return /* @__PURE__ */ S.createElement(dfe, Te({}, r, {
        id: this.getElementId("live-region"),
        ariaSelection: i,
        focusedOption: s,
        focusedValue: u,
        isFocused: c,
        selectValue: d,
        focusableOptions: p,
        isAppleDevice: this.isAppleDevice
      }));
    }
  }, {
    key: "render",
    value: function() {
      var r = this.getComponents(), o = r.Control, i = r.IndicatorsContainer, s = r.SelectContainer, u = r.ValueContainer, c = this.props, d = c.className, p = c.id, h = c.isDisabled, g = c.menuIsOpen, y = this.state.isFocused, b = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ S.createElement(s, Te({}, b, {
        className: d,
        innerProps: {
          id: p,
          onKeyDown: this.onKeyDown
        },
        isDisabled: h,
        isFocused: y
      }), this.renderLiveRegion(), /* @__PURE__ */ S.createElement(o, Te({}, b, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled: h,
        isFocused: y,
        menuIsOpen: g
      }), /* @__PURE__ */ S.createElement(u, Te({}, b, {
        isDisabled: h
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ S.createElement(i, Te({}, b, {
        isDisabled: h
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(r, o) {
      var i = o.prevProps, s = o.clearFocusValueOnUpdate, u = o.inputIsHiddenAfterUpdate, c = o.ariaSelection, d = o.isFocused, p = o.prevWasFocused, h = o.instancePrefix, g = r.options, y = r.value, b = r.menuIsOpen, v = r.inputValue, x = r.isMulti, _ = N3(y), O = {};
      if (i && (y !== i.value || g !== i.options || b !== i.menuIsOpen || v !== i.inputValue)) {
        var C = b ? Ufe(r, _) : [], N = b ? $3(Fh(r, _), "".concat(h, "-option")) : [], R = s ? Hfe(o, _) : null, z = $fe(o, C), j = lw(N, z);
        O = {
          selectValue: _,
          focusedOption: z,
          focusedOptionId: j,
          focusableOptionsWithIds: N,
          focusedValue: R,
          clearFocusValueOnUpdate: !1
        };
      }
      var I = u != null && r !== i ? {
        inputIsHidden: u,
        inputIsHiddenAfterUpdate: void 0
      } : {}, $ = c, A = d && p;
      return d && !A && ($ = {
        value: ph(x, _, _[0] || null),
        options: _,
        action: "initial-input-focus"
      }, A = !p), c?.action === "initial-input-focus" && ($ = null), Le(Le(Le({}, O), I), {}, {
        prevProps: r,
        ariaSelection: $,
        prevWasFocused: A
      });
    }
  }]), n;
}(S.Component);
oD.defaultProps = Ffe;
var qfe = /* @__PURE__ */ S.forwardRef(function(e, t) {
  var n = xce(e);
  return /* @__PURE__ */ S.createElement(oD, Te({
    ref: t
  }, n));
}), Xfe = qfe;
const Wfe = ({
  options: e,
  items_per_page: t,
  className: n,
  defaultValue: r,
  onChange: o
}) => {
  const [i, s] = S.useState(""), [u, c] = S.useState(0), d = (y) => {
    s(y.toLowerCase()), c(0);
  }, p = e.filter((y) => y.label.toLowerCase().includes(i) || y.value.toLowerCase().includes(i));
  var h;
  t !== void 0 ? h = p.slice(
    u * t,
    (u + 1) * t
  ) : h = p;
  const g = {
    control: (y) => ({
      ...y,
      minHeight: void 0
    })
  };
  return /* @__PURE__ */ E.jsx(
    Xfe,
    {
      options: h,
      onInputChange: d,
      onChange: o,
      inputValue: i,
      isSearchable: !0,
      placeholder: "Select an option...",
      className: n,
      unstyled: !0,
      styles: g,
      classNamePrefix: "styled-select",
      defaultValue: r,
      value: r
    }
  );
};
function Gfe(e) {
  return e === 0 ? 0 : Math.abs(e) < 1e-12 ? e : Number(e.toPrecision(12));
}
const iD = ({
  iostore: e,
  inputconverter: t,
  parser: n = (r) => parseFloat(r)
}) => {
  var r, o, i, s, u, c, d, p, h, g, y, b, v, x;
  const _ = S.useContext(it), { preview: O } = e.valuestore(), C = e.use(), [N, R] = S.useState(
    t[1](O?.value)
  );
  S.useEffect(() => {
    R(t[1](O?.value));
  }, [O]);
  const z = (V) => {
    var U, W, D;
    V = n(
      parseFloat(V.toString()).toString()
      // parse float first for e notation
    ), isNaN(V) ? (V = "<NoValue>", R("")) : (((U = C.value_options) == null ? void 0 : U.min) !== void 0 && V < C.value_options.min && (V = C.value_options.min), ((W = C.value_options) == null ? void 0 : W.max) !== void 0 && V > C.value_options.max && (V = C.value_options.max), V = Gfe(V), R(V.toString()));
    try {
      V = t[0](V);
    } catch {
    }
    (D = _.worker) == null || D.set_io_value({
      nid: C.node,
      ioid: C.id,
      value: V,
      set_default: C.render_options.set_default
    });
  }, j = (V) => {
    z(V.target.value);
  };
  let I = C.connected ? t[1](O?.value) : N;
  I === void 0 && (I = (r = C.value_options) == null ? void 0 : r.min), I === void 0 && (I = (o = C.value_options) == null ? void 0 : o.max), I === void 0 && (I = ""), I === null && (I = "");
  let $ = null, A = 1;
  return ((i = C.value_options) == null ? void 0 : i.step) !== void 0 ? A = C.value_options.step : ((s = C.value_options) == null ? void 0 : s.max) !== void 0 && ((u = C.value_options) == null ? void 0 : u.min) !== void 0 && (A = (((c = C.value_options) == null ? void 0 : c.max) - ((d = C.value_options) == null ? void 0 : d.min)) / 1e3), ((p = C.value_options) == null ? void 0 : p.max) !== void 0 && ((h = C.value_options) == null ? void 0 : h.min) !== void 0 && !C.connected && ($ = /* @__PURE__ */ E.jsx("div", { style: { minWidth: "6.25rem" }, className: "SliderContainer", children: /* @__PURE__ */ E.jsxs(
    ece,
    {
      className: "SliderRoot",
      value: [I === void 0 ? (g = C.value_options) == null ? void 0 : g.min : I],
      min: (y = C.value_options) == null ? void 0 : y.min,
      max: (b = C.value_options) == null ? void 0 : b.max,
      step: A,
      disabled: C.connected,
      onValueCommit: (V) => {
        isNaN(V[0]) || z(V[0]);
      },
      onValueChange: (V) => {
        isNaN(V[0]) || R(V[0].toString());
      },
      onKeyDown: (V) => {
        ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(
          V.key
        ) && V.stopPropagation();
      },
      children: [
        /* @__PURE__ */ E.jsx(tce, { className: "SliderTrack", children: /* @__PURE__ */ E.jsx(nce, { className: "SliderRange" }) }),
        /* @__PURE__ */ E.jsx(rce, { className: "SliderThumb" })
      ]
    }
  ) })), /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    $,
    /* @__PURE__ */ E.jsx(
      "input",
      {
        type: "text",
        className: "nodedatainput styledinput numberinput",
        value: I,
        onChange: (V) => R(V.target.value),
        onBlur: j,
        step: A,
        onKeyDown: (V) => {
          if (!(V.ctrlKey || V.metaKey)) {
            if (V.key === "ArrowUp") {
              V.shiftKey && (A *= 10);
              let U = (parseFloat(I) || 0) + A;
              z(U);
              return;
            }
            if (V.key === "ArrowDown") {
              V.shiftKey && (A *= 10);
              let U = (parseFloat(I) || 0) - A;
              z(U);
              return;
            }
            !/^[0-9.eE+-]$/.test(V.key) && !["Backspace", "ArrowLeft", "ArrowRight", "Delete", "Tab"].includes(
              V.key
            ) && V.preventDefault();
          }
        },
        disabled: C.connected,
        min: (v = C.value_options) == null ? void 0 : v.min,
        max: (x = C.value_options) == null ? void 0 : x.max
      }
    )
  ] });
}, Zfe = ({
  iostore: e,
  inputconverter: t
}) => iD({ iostore: e, inputconverter: t, parser: parseFloat }), Kfe = ({
  iostore: e,
  inputconverter: t
}) => iD({ iostore: e, inputconverter: t, parser: parseInt }), Qfe = ({
  iostore: e,
  inputconverter: t
}) => {
  const n = S.useContext(it), { preview: r } = e.valuestore(), o = e.use(), i = r?.value === void 0, s = S.useRef(null);
  S.useEffect(() => {
    s.current && (s.current.indeterminate = i);
  }, [s, i]);
  const u = (c) => {
    var d;
    let p = c.target.checked;
    try {
      p = t[0](c.target.checked);
    } catch {
    }
    (d = n.worker) == null || d.set_io_value({
      nid: o.node,
      ioid: o.id,
      value: p,
      set_default: o.render_options.set_default
    });
  };
  return /* @__PURE__ */ E.jsx(
    "input",
    {
      ref: s,
      type: "checkbox",
      className: "styledcheckbox booleaninput",
      checked: !!t[1](r?.value),
      onChange: u,
      disabled: o.connected
    }
  );
}, q3 = ({
  iostore: e,
  inputconverter: t
}) => {
  const n = S.useContext(it), { preview: r, full: o } = e.valuestore(), i = e.use(), s = o === void 0 ? r?.value : o?.value, [u, c] = S.useState(t[1](s));
  S.useEffect(() => {
    c(t[1](s));
  }, [s]);
  const d = (h) => {
    var g;
    let y = h.target.value;
    y || (y = "<NoValue>");
    try {
      y = t[0](y);
    } catch {
    }
    (g = n.worker) == null || g.set_io_value({
      nid: i.node,
      ioid: i.id,
      value: y,
      set_default: i.render_options.set_default
    });
  };
  let p = i.connected ? t[1](s) : u;
  return p == null && (p = ""), /* @__PURE__ */ E.jsx(
    "input",
    {
      className: "nodedatainput styledinput stringinput",
      value: p,
      onChange: (h) => c(h.target.value),
      onBlur: d,
      disabled: i.connected
    }
  );
}, Jfe = ({ iostore: e }) => {
  var t;
  const n = S.useContext(it), r = e.use(), { preview: o, full: i } = e.valuestore(), s = i === void 0 ? o?.value : i.value, u = ((t = r.value_options) == null ? void 0 : t.colorspace) || "hex", c = (p) => {
    var h;
    let g = "<NoValue>";
    p && (p[u] ? g = p[u]() : g = p.hex()), p === null && (g = null);
    try {
      g = g;
    } catch {
    }
    (h = n.worker) == null || h.set_io_value({
      nid: r.node,
      ioid: r.id,
      value: g,
      set_default: r.render_options.set_default
    });
  };
  let d = !1;
  return typeof r.type != "string" && "anyOf" in r.type && r.type.anyOf !== void 0 && (d = r.type.anyOf.some((p) => p === "None")), /* @__PURE__ */ E.jsx(
    mce,
    {
      onChange: c,
      inicolordata: s,
      allow_null: d,
      inicolorspace: u
    }
  );
}, epe = (e) => e, tpe = (e) => parseFloat(e), npe = (e) => !!e, rpe = (e) => e === "null" ? null : e, ope = (e) => e === "nuinputconvertermber" ? tpe : e === "boolean" ? npe : e === "undefined" ? rpe : epe, Om = ({
  iostore: e,
  inputconverter: t,
  parser: n
}) => {
  var r;
  const o = e.use(), { preview: i, full: s } = e.valuestore(), u = s === void 0 ? i?.value : s.value;
  let c = ((r = o.value_options) == null ? void 0 : r.options) || [];
  Array.isArray(c) && (c = {
    type: "enum",
    values: c,
    keys: c.map((x) => x === null ? "None" : x.toString()),
    nullable: !1
  }), c.type !== "enum" && (c = {
    type: "enum",
    values: Object.values(c),
    keys: Object.keys(c),
    nullable: !1
  }), c = c, c.nullable && !c.values.includes(null) && !c.keys.includes("None") && (c.values.unshift(null), c.keys.unshift("None"));
  const d = [];
  for (let x = 0; x < c.values.length; x++) {
    const _ = c.values[x] === null || c.values[x] === void 0 ? "undefined" : typeof c.values[x];
    let O = c.values[x];
    O === null && (O = "null"), O === void 0 && (O = "undefined"), d.push([c.keys[x], O.toString(), _]);
  }
  const p = S.useContext(it), h = ({
    value: x,
    // label
    datatype: _
  }) => {
    var O;
    let C = (n || ope(_))(x);
    try {
      C = t[0](x);
    } catch {
    }
    (O = p.worker) == null || O.set_io_value({
      nid: o.node,
      ioid: o.id,
      value: C,
      set_default: o.render_options.set_default
    });
  };
  let g = u;
  g === null && (g = "null"), g === void 0 && (g = "undefined");
  const y = d.find((x) => x[1] === g.toString());
  let b;
  y !== void 0 && (b = {
    value: y[1],
    label: y[0],
    datatype: y[2]
  });
  const v = d.map(
    (x) => ({
      value: x[1],
      label: x[0],
      datatype: x[2]
    })
  );
  return (
    // <Suspense fallback={<select disabled={true}></select>}>
    /* @__PURE__ */ E.jsx(
      Wfe,
      {
        className: "nodedatainput styleddropdown",
        options: v,
        defaultValue: b,
        onChange: (x) => {
          if (x === null) {
            h({
              value: "<NoValue>",
              datatype: "string"
            });
            return;
          }
          h(x);
        }
      }
    )
  );
}, ipe = (e, t = void 0) => ({ iostore: n }) => {
  const { full: r, preview: o } = n.valuestore(), i = r === void 0 ? o : r, s = i?.value || t;
  return /* @__PURE__ */ E.jsx(e, { iostore: n, value: s });
}, ape = {
  float: Zfe,
  int: Kfe,
  bool: Qfe,
  string: q3,
  str: q3,
  color: Jfe,
  select: Om,
  enum: Om,
  bytes: ipe(p_, "")
}, spe = ({
  iostore: e,
  typestring: t
}) => {
  const { InLineRenderer: n } = S.useContext(ua), { preview: r, full: o } = e.valuestore();
  if (t && n[t])
    return /* @__PURE__ */ E.jsx("div", { children: n[t]({ iostore: e }) });
  let i = (JSON.stringify(o || r) || "").replace(/\\n/g, `
`);
  return i.length > 63 && (i = i.slice(0, 60) + "..."), /* @__PURE__ */ E.jsx("div", { children: i });
}, lpe = {}, Oo = (e, t = void 0) => ({ iostore: n }) => {
  const { full: r, preview: o } = n.valuestore(), i = r === void 0 ? o : r, s = i?.value || t;
  return /* @__PURE__ */ E.jsx(e, { iostore: n, value: s });
}, upe = {
  string: Oo(yT),
  table: Oo(vT),
  image: Oo(mT),
  svg: Oo(gT, ""),
  dict: Oo(Vg, "{}"),
  bytes: Oo(p_, "")
}, cpe = {}, aD = (e) => ({
  iostore: t,
  value: n,
  preValue: r,
  onLoaded: o
}) => /* @__PURE__ */ E.jsx(
  e,
  {
    iostore: t,
    value: n,
    preValue: r,
    onLoaded: o
  }
), X3 = aD(Vg), dpe = {
  // image: Base64FullImageOutput,
}, fpe = {}, ppe = {}, hpe = {}, ko = {
  Inputrenderer: ape,
  Outputrenderer: lpe,
  HandlePreviewRenderer: cpe,
  DataOverlayRenderer: dpe,
  DataPreviewViewRenderer: upe,
  DataViewRenderer: Lue,
  InLineRenderer: Hoe,
  NodeContextExtenders: hpe,
  NodeRenderer: fpe,
  NodeHooks: ppe
}, mpe = (e, t) => {
  const n = t.options || {}, r = n.overwrite === void 0 ? !0 : n.overwrite;
  switch (t.type) {
    case "EXTEND_INPUT_RENDER":
      return !r && e.Inputrenderer[t.payload.type] ? e : {
        ...e,
        Inputrenderer: {
          ...e.Inputrenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_OUTPUT_RENDER":
      return !r && e.Outputrenderer[t.payload.type] ? e : {
        ...e,
        Outputrenderer: {
          ...e.Outputrenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_HANDLE_PREVIEW_RENDER":
      return !r && e.HandlePreviewRenderer[t.payload.type] ? e : {
        ...e,
        HandlePreviewRenderer: {
          ...e.HandlePreviewRenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_DATA_OVERLAY_RENDER":
      return !r && e.DataOverlayRenderer[t.payload.type] ? e : {
        ...e,
        DataOverlayRenderer: {
          ...e.DataOverlayRenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_DATA_PREVIEW_RENDER":
      return !r && e.DataPreviewViewRenderer[t.payload.type] ? e : {
        ...e,
        DataPreviewViewRenderer: {
          ...e.DataPreviewViewRenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_DATA_VIEW_RENDER":
      return !r && e.DataViewRenderer[t.payload.type] ? e : {
        ...e,
        DataViewRenderer: {
          ...e.DataViewRenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_NODE_CONTEXT_EXTENDER":
      return !r && e.NodeContextExtenders[t.payload.type] ? e : {
        ...e,
        NodeContextExtenders: {
          ...e.NodeContextExtenders,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_NODE_RENDERER":
      return !r && e.NodeRenderer[t.payload.type] ? e : {
        ...e,
        NodeRenderer: {
          ...e.NodeRenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_NODE_HOOKS":
      return !r && e.NodeHooks[t.payload.type] ? e : {
        ...e,
        NodeHooks: {
          ...e.NodeHooks,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_FROM_PLUGIN":
      let o = !1;
      const i = [
        [t.payload.plugin.input_renderers || {}, e.Inputrenderer],
        [t.payload.plugin.output_renderers || {}, e.Outputrenderer],
        [
          t.payload.plugin.handle_preview_renderers || {},
          e.HandlePreviewRenderer
        ],
        [
          t.payload.plugin.data_overlay_renderers || {},
          e.DataOverlayRenderer
        ],
        [
          t.payload.plugin.data_preview_renderers || {},
          e.DataPreviewViewRenderer
        ],
        [
          t.payload.plugin.data_view_renderers || {},
          e.DataViewRenderer
        ],
        [
          t.payload.plugin.node_context_extenders || {},
          e.NodeContextExtenders
        ],
        [t.payload.plugin.node_renderers || {}, e.NodeRenderer],
        [t.payload.plugin.node_hooks || {}, e.NodeHooks]
      ];
      for (const [s, u] of i) {
        if (Object.keys(s).length > 0) {
          if (r)
            o = !0;
          else
            for (const c in s)
              if (!u[c]) {
                o = !0;
                break;
              }
        }
        if (o) break;
      }
      if (!o)
        return e;
      for (const [s, u] of i)
        for (const c in s)
          (r || !u[c]) && (u[c] = s[c]);
      return { ...e };
    default:
      return e;
  }
}, gpe = ({
  children: e,
  plugins: t,
  fnrf_zst: n
}) => {
  const [r, o] = S.useReducer(
    mpe,
    ko
  ), i = (v, x, _) => {
    o({
      type: "EXTEND_INPUT_RENDER",
      payload: { type: v, component: x },
      options: _
    });
  }, s = (v, x, _) => {
    o({
      type: "EXTEND_OUTPUT_RENDER",
      payload: { type: v, component: x },
      options: _
    });
  }, u = (v, x, _) => {
    o({
      type: "EXTEND_HANDLE_PREVIEW_RENDER",
      payload: { type: v, component: x },
      options: _
    });
  }, c = (v, x, _) => {
    o({
      type: "EXTEND_DATA_OVERLAY_RENDER",
      payload: { type: v, component: x },
      options: _
    });
  }, d = (v, x, _) => {
    o({
      type: "EXTEND_DATA_PREVIEW_RENDER",
      payload: { type: v, component: x },
      options: _
    });
  }, p = (v, x, _) => {
    o({
      type: "EXTEND_DATA_VIEW_RENDER",
      payload: { type: v, component: x },
      options: _
    });
  }, h = (v, x, _) => {
    o({
      type: "EXTEND_NODE_CONTEXT_EXTENDER",
      payload: { type: v, component: x },
      options: _
    });
  }, g = (v, x, _) => {
    o({
      type: "EXTEND_NODE_RENDERER",
      payload: { type: v, component: x },
      options: _
    });
  }, y = (v, x, _) => {
    o({
      type: "EXTEND_NODE_HOOKS",
      payload: { type: v, component: x },
      options: _
    });
  }, b = (v, x) => {
    o({
      type: "EXTEND_FROM_PLUGIN",
      payload: { plugin: v },
      options: x
    });
  };
  return S.useEffect(() => {
    for (const v in t) {
      const x = t[v];
      if (!x) continue;
      const _ = x.renderpluginfactory;
      _ && b(_({ React: uN, fnrf_zst: n, NodeContext: dD }));
    }
  }, [t]), /* @__PURE__ */ E.jsx(
    ua.Provider,
    {
      value: {
        Inputrenderer: r.Inputrenderer,
        Outputrenderer: r.Outputrenderer,
        HandlePreviewRenderer: r.HandlePreviewRenderer,
        DataOverlayRenderer: r.DataOverlayRenderer,
        DataPreviewViewRenderer: r.DataPreviewViewRenderer,
        DataViewRenderer: r.DataViewRenderer,
        InLineRenderer: r.InLineRenderer,
        NodeContextExtenders: r.NodeContextExtenders,
        NodeRenderer: r.NodeRenderer,
        NodeHooks: r.NodeHooks,
        extendInputRenderMapping: i,
        extendOutputRenderMapping: s,
        extendHandlePreviewRenderMapping: u,
        extendDataOverlayRenderMapping: c,
        extendDataPreviewRenderMapping: d,
        extendDataViewRenderMapping: p,
        extendNodeContextExtender: h,
        extendNodeRenderer: g,
        extendNodeHooks: y,
        extendFromPlugin: b
      },
      children: e
    }
  );
}, ua = S.createContext({
  Inputrenderer: ko.Inputrenderer,
  Outputrenderer: ko.Outputrenderer,
  HandlePreviewRenderer: ko.HandlePreviewRenderer,
  DataOverlayRenderer: ko.DataOverlayRenderer,
  DataPreviewViewRenderer: ko.DataPreviewViewRenderer,
  DataViewRenderer: ko.DataViewRenderer,
  InLineRenderer: ko.InLineRenderer,
  NodeContextExtenders: ko.NodeContextExtenders,
  NodeRenderer: ko.NodeRenderer,
  NodeHooks: ko.NodeHooks,
  extendInputRenderMapping: (e, t, n) => {
  },
  extendOutputRenderMapping: (e, t, n) => {
  },
  extendHandlePreviewRenderMapping: (e, t, n) => {
  },
  extendDataOverlayRenderMapping: (e, t, n) => {
  },
  extendDataPreviewRenderMapping: (e, t, n) => {
  },
  extendDataViewRenderMapping: (e, t, n) => {
  },
  extendNodeContextExtender: (e, t, n) => {
  },
  extendNodeRenderer: (e, t, n) => {
  },
  extendNodeHooks: (e, t, n) => {
  },
  extendFromPlugin: (e, t) => {
  }
}), sD = (e) => {
  const t = S.useContext(it), { DataOverlayRenderer: n, DataViewRenderer: r } = S.useContext(ua);
  if (e === void 0) return;
  const o = t.render_options(), [i] = dl(e.type, o.typemap || {});
  return i ? n[i] ? n[i] : r[i] ? aD(r[i]) : X3 : X3;
}, ype = (e) => {
  const t = S.useContext(it).render_options(), { HandlePreviewRenderer: n, DataPreviewViewRenderer: r } = S.useContext(ua), o = sD(e);
  let i;
  if (e) {
    const [s] = dl(e.type, t.typemap || {});
    s ? n[s] ? i = n[s] : r[s] ? i = r[s] : i = Oo(Sm) : i = Oo(Sm);
  }
  return [i, o];
}, lD = ({
  iostore: e,
  Component: t
}) => {
  const [n, r] = S.useState(void 0), [o, i] = S.useState(void 0), { full: s } = e.valuestore();
  S.useEffect(() => {
    s === void 0 ? e.getState().try_get_full_value() : i(s.value);
  }, [s]);
  const u = () => {
    o !== void 0 && r(o);
  };
  return /* @__PURE__ */ E.jsx(
    t,
    {
      iostore: e,
      value: o,
      preValue: n,
      onLoaded: u
    }
  );
}, uD = ({
  iostore: e,
  Component: t
}) => /* @__PURE__ */ E.jsx(t, { iostore: e }), dl = (e, t) => {
  if (typeof e == "string")
    return e in t ? [t[e], e] : [e, e];
  if ("allOf" in e && e.allOf !== void 0)
    return [void 0, void 0];
  if ("anyOf" in e && e.anyOf !== void 0) {
    const n = e.anyOf.map((r) => dl(r, t));
    for (const r of n)
      switch (r[0]) {
        case "bool":
          return ["bool", r[1]];
        case "enum":
          return ["enum", r[1]];
        case "float":
          return ["float", r[1]];
        case "int":
          return ["int", r[1]];
        case "string":
          return ["string", r[1]];
        case "str":
          return ["string", r[1]];
      }
    return [void 0, void 0];
  }
  return !("type" in e) || e.type === void 0 ? [void 0, void 0] : e.type === "enum" ? ["enum", "enum"] : [void 0, void 0];
}, Jx = ({
  iostore: e,
  typestring: t,
  preview: n,
  ...r
}) => {
  const [o, i] = S.useState(!1), [s, u] = S.useState(!1), c = S.useContext(it), d = e.use(), [p, h] = ype(d), g = c.local_state(() => c.reactflowRef);
  return (
    // <Tooltip.Provider>
    /* @__PURE__ */ E.jsxs(Ez, { open: o || s, onOpenChange: u, children: [
      /* @__PURE__ */ E.jsx(Cz, { asChild: !0, children: /* @__PURE__ */ E.jsx(Ld, { id: d.id, "data-type": t, ...r }) }),
      /* @__PURE__ */ E.jsx(Oz, { container: g, children: /* @__PURE__ */ E.jsxs(Az, { className: "iotooltipcontent", sideOffset: 5, children: [
        /* @__PURE__ */ E.jsxs("div", { className: "iotooltip_container", children: [
          /* @__PURE__ */ E.jsxs("div", { className: "iotooltip_header", children: [
            o ? /* @__PURE__ */ E.jsx(aG, { onClick: () => i(!1) }) : /* @__PURE__ */ E.jsx(iG, { onClick: () => i(!0) }),
            h && /* @__PURE__ */ E.jsx(
              $u,
              {
                title: d.full_id,
                trigger: /* @__PURE__ */ E.jsx(FR, {}),
                onOpenChange: (y) => {
                  y && d.try_get_full_value && d.try_get_full_value(), i(y);
                },
                children: /* @__PURE__ */ E.jsx(
                  lD,
                  {
                    Component: h,
                    iostore: e
                  }
                )
              }
            )
          ] }),
          p ? /* @__PURE__ */ E.jsx(uD, { Component: p, iostore: e }) : `no preview available for "${t}"`
        ] }),
        /* @__PURE__ */ E.jsx(Foe, { className: "iotooltipcontentarrow" })
      ] }) })
    ] })
  );
}, Am = {
  "": [(e) => e, (e) => e],
  str_to_json: [
    (e) => JSON.parse(e),
    (e) => typeof e == "string" ? e : JSON.stringify(e)
  ],
  str_to_list: [
    (e) => {
      try {
        const t = JSON.parse(e);
        return Array.isArray(t) ? t : [t];
      } catch {
        try {
          return JSON.parse("[" + e + "]");
        } catch {
        }
      }
      throw new Error("Invalid list");
    },
    (e) => JSON.stringify(e)
  ]
}, vpe = ({ iostore: e }) => {
  var t, n;
  const r = S.useContext(it).render_options(), o = e.use(), [i, s] = dl(
    o.render_options.type,
    r.typemap || {}
  ), { Inputrenderer: u } = S.useContext(ua), c = i ? (t = o.value_options) != null && t.options ? Om : u[i] : void 0, d = Am[(s && ((n = r.inputconverter) == null ? void 0 : n[s])) ?? ""] || Am[""];
  return o.hidden ? null : /* @__PURE__ */ E.jsxs("div", { className: "nodeinput", "data-type": i, children: [
    /* @__PURE__ */ E.jsx(
      Jx,
      {
        iostore: e,
        typestring: i,
        position: je.Left,
        type: "target"
      }
    ),
    c && /* @__PURE__ */ E.jsx("div", { className: "iovaluefield nodrag", "data-type": i, children: /* @__PURE__ */ E.jsx(c, { iostore: e, inputconverter: d }) }),
    /* @__PURE__ */ E.jsx("div", { className: "ioname", children: o.name }),
    /* @__PURE__ */ E.jsx(
      Jx,
      {
        iostore: e,
        typestring: i,
        position: je.Right,
        type: "source"
      }
    )
  ] });
}, bpe = ({ iostore: e }) => {
  const t = S.useContext(it).render_options(), n = e.use(), [r] = dl(n.type, t.typemap || {}), { Outputrenderer: o } = S.useContext(ua), i = r ? o[r] : void 0;
  return n.hidden ? null : /* @__PURE__ */ E.jsxs("div", { className: "nodeoutput", "data-type": r, children: [
    /* @__PURE__ */ E.jsx(
      Jx,
      {
        iostore: e,
        typestring: r,
        position: je.Right,
        type: "source"
      }
    ),
    /* @__PURE__ */ E.jsx("div", { className: "ioname", children: n.name }),
    i ? /* @__PURE__ */ E.jsx("div", { className: "iovaluefield nodrag", children: /* @__PURE__ */ E.jsx(i, { iostore: e }) }) : /* @__PURE__ */ E.jsx("div", { className: "iovaluefield", children: /* @__PURE__ */ E.jsx(spe, { iostore: e, typestring: r }) })
  ] });
}, wpe = (e) => {
  const t = S.useContext(it), n = sD(e), { DataPreviewViewRenderer: r, DataViewRenderer: o } = S.useContext(ua), i = t.render_options();
  if (e === void 0) return [void 0, n];
  const [s] = dl(e.type, i.typemap || {});
  return s ? r[s] ? [r[s], n] : o[s] ? [
    Oo(o[s]),
    n
  ] : [
    Oo(Sm),
    n
  ] : [
    Oo(Sm),
    n
  ];
};
function xpe(e, t, n = {}) {
  const {
    maxFontSize: r = 100,
    // default maximum font size
    minFontSize: o = 6,
    // default minimum font size
    decrementFactor: i = 0.9
    // font size decrement step
  } = n;
  if (!e || !t)
    return;
  if (i >= 1 || i <= 0)
    throw new Error("decrementFactor must be between 0 and 1");
  const s = e.getBoundingClientRect(), u = s.width, c = s.height;
  let d = r;
  t.style.whiteSpace = "nowrap", t.style.display = "inline-block", t.style.fontSize = d + "px";
  let p = t.getBoundingClientRect();
  for (; (p.width > u || p.height > c) && d > o; )
    d *= i, t.style.fontSize = d + "px", p = t.getBoundingClientRect();
}
function Spe(e = {
  n: 0,
  elapsed: 0,
  ascii: !1,
  unit: "it",
  unit_scale: !1,
  unit_divisor: 1e3
}) {
  let t = e.total ?? null;
  const {
    n,
    unit_scale: r,
    elapsed: o,
    // ascii,
    unit: i,
    unit_divisor: s,
    // ncols = undefined,
    prefix: u = "",
    rate: c = void 0,
    // bar_format = undefined,
    postfix: d = null,
    initial: p = 0
    // colour = undefined,
  } = e;
  t !== null && n >= t + 0.5 && (t = null);
  let h = n, g = t, y = c;
  r && r !== !0 && r !== 1 && (t !== null && (g = t * r), h = n * r, c !== void 0 && (y = c * r));
  const b = W3(o);
  y === void 0 && o > 0 && (y = (h - p) / o);
  const v = y ? 1 / y : void 0, [x, _] = y ? hh(y, s) : [void 0, ""], [O, C] = v ? hh(v, 1e3) : [void 0, ""], N = (x || "?") + `${_}${i}/s`, R = O ? `${O}${C}s/` + i : "?", z = v && v > 1 ? R : N, j = r ? hh(h, s).join("") : h.toString(), I = r && g !== null ? hh(g, s).join("") : g?.toString() ?? "?", $ = y && g !== null ? (g - h) / y : 0, A = y ? W3($) : "?", V = u ? `${u}: ` : "";
  if (t !== null) {
    const U = h / t * 100, W = ` ${j}/${I} [${b} < ${A}, ${z}${d ?? ""}]`;
    return `${V}${U.toFixed(0)}%${W}`;
  }
  return `${V}${j}${i} [${b}, ${z}${d ?? ""}]`;
}
function W3(e) {
  const t = Math.floor(e / 60), n = Math.floor(e % 60);
  return `${t}:${n.toString().padStart(2, "0")}`;
}
function hh(e, t) {
  const n = ["", "K", "M", "G", "T"];
  let r = 0;
  for (; e >= t && r < n.length - 1; )
    e /= t, r++;
  return [e.toFixed(2), n[r]];
}
const _pe = ({ state: e, className: t = "reacttqdm", ...n }) => {
  const r = S.useRef(null), o = S.useRef(null);
  S.useEffect(() => {
    const s = () => {
      !r.current || !o.current || xpe(r.current, o.current, {
        maxFontSize: 12,
        decrementFactor: 0.9
      });
    };
    return s(), window.addEventListener("resize", s), () => {
      window.removeEventListener("resize", s);
    };
  }, [e]);
  const i = e.total ? e.n / e.total * 100 : 0;
  return /* @__PURE__ */ E.jsx("div", { ref: r, className: t, ...n, children: /* @__PURE__ */ E.jsxs(
    "div",
    {
      style: {
        position: "relative",
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center"
      },
      children: [
        /* @__PURE__ */ E.jsx(
          "div",
          {
            className: t + "-bar",
            style: {
              position: "absolute",
              width: "100%",
              height: "100%",
              // Adjust height if needed
              overflow: "hidden"
            },
            children: /* @__PURE__ */ E.jsx(
              "div",
              {
                className: t + "-progress",
                style: {
                  width: `${i}%`,
                  height: "100%"
                }
              }
            )
          }
        ),
        /* @__PURE__ */ E.jsx("div", { className: t + "-text", ref: o, children: Spe(e) })
      ]
    }
  ) });
}, kpe = S.memo(({ node_data: e }) => {
  const t = S.useContext(it), n = () => {
    t.on_node_action({
      type: "trigger",
      from_remote: !1,
      id: e.id
    });
  };
  return /* @__PURE__ */ E.jsxs(
    "div",
    {
      className: "nodeheader",
      title: e.description || e.node_name,
      children: [
        /* @__PURE__ */ E.jsxs("div", { className: "nodeheader_element", children: [
          /* @__PURE__ */ E.jsx(
            lG,
            {
              fontSize: "inherit",
              className: "triggerbutton",
              onClick: n
            }
          ),
          /* @__PURE__ */ E.jsx(
            sG,
            {
              fontSize: "inherit",
              onClick: async () => {
                var r;
                console.log(
                  "nodestatus",
                  await ((r = t.worker) == null ? void 0 : r.get_node_status(e.id))
                );
              }
            }
          )
        ] }),
        /* @__PURE__ */ E.jsx("div", { className: "nodeheader_element nodeheader_title", children: /* @__PURE__ */ E.jsx("div", { className: "nodeheader_title_text", children: e.node_name }) }),
        /* @__PURE__ */ E.jsx("div", { className: "nodeheader_element", children: /* @__PURE__ */ E.jsx(yf, { fontSize: "inherit" }) })
      ]
    }
  );
}), Epe = ({
  iostore: e,
  node_data: t
}) => {
  var n, r;
  const o = e.use(), [i, s] = wpe(o);
  return /* @__PURE__ */ E.jsx(
    "div",
    {
      className: "nodrag nodedatabody",
      "data-src": ((r = (n = t.render_options) == null ? void 0 : n.data) == null ? void 0 : r.src) || "",
      children: i && o && /* @__PURE__ */ E.jsx(
        $u,
        {
          title: o.full_id,
          trigger: /* @__PURE__ */ E.jsx("div", { className: "nodedatabutton", children: /* @__PURE__ */ E.jsx(uD, { Component: i, iostore: e }) }),
          onOpenChange: (u) => {
            u && o != null && o.try_get_full_value && o?.try_get_full_value();
          },
          children: s && /* @__PURE__ */ E.jsx(lD, { Component: s, iostore: e })
        }
      )
    }
  );
}, Cpe = S.memo(({ node_data: e }) => {
  var t, n, r, o;
  const i = (n = (t = e.render_options) == null ? void 0 : t.data) != null && n.src ? e.io[(o = (r = e.render_options) == null ? void 0 : r.data) == null ? void 0 : o.src] : void 0;
  return /* @__PURE__ */ E.jsxs("div", { className: "nodebody", children: [
    e.outputs.map((s) => /* @__PURE__ */ E.jsx(bpe, { iostore: e.io[s] }, s)),
    i && /* @__PURE__ */ E.jsx(Epe, { node_data: e, iostore: i }),
    e.inputs.map((s) => /* @__PURE__ */ E.jsx(vpe, { iostore: e.io[s] }, s))
  ] });
}), cD = S.memo(({ node_data: e }) => {
  const [t, n] = S.useState(e.name);
  S.useEffect(() => {
    n(e.name);
  }, [e]);
  const r = S.useContext(it), o = (s) => {
    n(s.target.value);
  }, i = (s) => {
    const u = s.target.value;
    r.on_node_action({
      type: "update",
      from_remote: !1,
      id: e.id,
      node: { name: u }
    });
  };
  return /* @__PURE__ */ E.jsx(
    "input",
    {
      className: "nodename_input",
      value: t,
      onChange: o,
      onBlur: i
    }
  );
}), Ope = ({ node_data: e }) => {
  if (!e.progress) return null;
  const t = e.progress();
  return /* @__PURE__ */ E.jsx(
    _pe,
    {
      state: t,
      className: "nodeprogress"
    }
  );
}, Ape = S.memo(
  ({ node_data: e }) => /* @__PURE__ */ E.jsxs("div", { className: "nodefooter", children: [
    e.error && /* @__PURE__ */ E.jsx("div", { className: "nodeerror", children: e.error }),
    /* @__PURE__ */ E.jsx(Ope, { node_data: e })
  ] })
), Npe = (e) => {
  const t = S.useContext(it), [n, r] = S.useState(!1), o = e.in_trigger(), i = S.useContext(ua), s = i.NodeContextExtenders[e.node_id], u = S.useMemo(
    () => s?.({ node_data: e }) || {},
    [s, e]
  ), c = S.useMemo(
    () => ({ ...u, node_data: e }),
    [u, e]
  ), d = i.NodeHooks[e.node_id];
  for (const p of d || [])
    p({ nodecontext: c });
  return S.useEffect(() => {
    var p;
    (p = t.worker) == null || p.call_hooks("node_mounted", e.id);
  }, [t.worker, e.id]), S.useEffect(() => {
    let p;
    return o && !n ? r(!0) : n && (p = setTimeout(() => r(!1), 200)), () => clearTimeout(p);
  }, [o, n]), { visualTrigger: n, nodecontext: c };
}, dD = S.createContext(null), Mpe = ({ data: e }) => {
  const t = e.nodestore.use(), n = t.properties["frontend:collapsed"] || !1, { visualTrigger: r, nodecontext: o } = Npe(t);
  return /* @__PURE__ */ E.jsx(dD.Provider, { value: o, children: /* @__PURE__ */ E.jsxs(
    "div",
    {
      className: "innernode" + (r ? " intrigger" : "") + (t.error ? " error" : ""),
      children: [
        /* @__PURE__ */ E.jsx(kpe, { node_data: t }),
        /* @__PURE__ */ E.jsx(cD, { node_data: t }),
        n ? null : /* @__PURE__ */ E.jsx(Cpe, { node_data: t }),
        /* @__PURE__ */ E.jsx(Ape, { node_data: t })
      ]
    }
  ) });
}, Rpe = ({ iostore: e }) => {
  var t, n;
  const r = S.useContext(it).render_options(), o = e.use(), [i, s] = dl(
    o.render_options.type,
    r.typemap || {}
  ), { Inputrenderer: u } = S.useContext(ua), c = i ? (t = o.value_options) != null && t.options ? Om : u[i] : void 0, d = Am[(s && ((n = r.inputconverter) == null ? void 0 : n[s])) ?? ""] || Am[""];
  return /* @__PURE__ */ E.jsxs("div", { className: "nodesettings_component", children: [
    /* @__PURE__ */ E.jsx("div", { children: o.name }),
    c && /* @__PURE__ */ E.jsx(c, { iostore: e, inputconverter: d }),
    /* @__PURE__ */ E.jsx("div", { children: /* @__PURE__ */ E.jsxs("label", { children: [
      "hidden:",
      /* @__PURE__ */ E.jsx(
        "input",
        {
          className: "styledcheckbox",
          type: "checkbox",
          disabled: o.connected,
          onChange: (p) => {
            var h;
            (h = o.set_hidden) == null || h.call(o, p.target.checked);
          },
          checked: o.hidden
        }
      )
    ] }) })
  ] });
}, jpe = ({ iostore: e }) => {
  const t = e.use();
  return /* @__PURE__ */ E.jsxs("div", { className: "nodesettings_component", children: [
    /* @__PURE__ */ E.jsx("div", { children: t.name }),
    /* @__PURE__ */ E.jsx("div", { children: /* @__PURE__ */ E.jsxs("label", { children: [
      "hidden:",
      /* @__PURE__ */ E.jsx(
        "input",
        {
          className: "styledcheckbox",
          type: "checkbox",
          disabled: t.connected,
          onChange: (n) => {
            var r;
            (r = t.set_hidden) == null || r.call(t, n.target.checked);
          },
          checked: t.hidden
        }
      )
    ] }) })
  ] });
}, zpe = ({
  nodestore: e
}) => {
  const t = e.use();
  return /* @__PURE__ */ E.jsxs("div", { className: "nodesettings_content", children: [
    /* @__PURE__ */ E.jsx("div", { className: "nodesettings_section", children: /* @__PURE__ */ E.jsxs("div", { className: "nodesettings_component", children: [
      /* @__PURE__ */ E.jsx("div", { children: "Name" }),
      /* @__PURE__ */ E.jsx("div", { children: /* @__PURE__ */ E.jsx(cD, { node_data: t }) })
    ] }) }),
    /* @__PURE__ */ E.jsxs("div", { className: "nodesettings_section", children: [
      /* @__PURE__ */ E.jsx("div", { children: "Inputs" }),
      t.inputs.map((n) => /* @__PURE__ */ E.jsx(Rpe, { iostore: t.io[n] }, n))
    ] }),
    /* @__PURE__ */ E.jsxs("div", { className: "nodesettings_section", children: [
      /* @__PURE__ */ E.jsx("div", { children: "Outputs" }),
      t.outputs.map((n) => /* @__PURE__ */ E.jsx(jpe, { iostore: t.io[n] }, n))
    ] })
  ] });
}, Tpe = () => {
  const e = S.useContext(it), t = e.local_state((r) => r.selected_nodes);
  if (t.length === 0)
    return /* @__PURE__ */ E.jsx("div", { children: "Node Settings" });
  if (t.length > 1)
    return /* @__PURE__ */ E.jsx("div", { children: "Multiple Nodes Selected" });
  const n = e.nodespace.get_node(t[0]);
  return n ? /* @__PURE__ */ E.jsx(zpe, { nodestore: n }) : /* @__PURE__ */ E.jsx("div", { children: "Node not found" });
}, Dpe = () => {
  const e = S.useContext(it), t = e.local_settings(
    (o) => o.view_settings.expand_node_props
  ), n = e.local_settings(
    (o) => o.update_view_settings
  ), r = (o) => {
    n({ expand_node_props: o });
  };
  return /* @__PURE__ */ E.jsx(
    a6,
    {
      direction: "left",
      expanded: t === void 0 ? !1 : t,
      containerClassName: "pos-right pos-top bg1 h-12",
      className: "nodesettings_content",
      onExpandChange: r,
      children: /* @__PURE__ */ E.jsx(Tpe, {})
    }
  );
}, Ppe = ({
  id: e,
  sourceX: t,
  sourceY: n,
  targetX: r,
  targetY: o,
  sourcePosition: i,
  targetPosition: s,
  data: u,
  ...c
}) => {
  const [d] = RS({
    sourceX: t,
    sourceY: n,
    sourcePosition: i,
    targetX: r,
    targetY: o,
    targetPosition: s
  });
  return /* @__PURE__ */ E.jsx(E.Fragment, { children: /* @__PURE__ */ E.jsx(ff, { id: e, path: d, ...c }) });
}, Lpe = (e) => ({
  nodes: e.nodes,
  edges: e.edges,
  onNodesChange: e.onNodesChange,
  onEdgesChange: e.onEdgesChange,
  onConnect: e.onConnect
}), Ipe = { default: Mpe }, Vpe = {
  default: Ppe
}, Bpe = () => {
  const e = df(), t = S.useContext(it);
  return t.rf_instance = e, /* @__PURE__ */ E.jsx(E.Fragment, {});
}, Fpe = () => {
  const e = S.useContext(it), t = Ru("Delete"), n = wU(), r = vU();
  if (t) {
    for (const o of n)
      if (o.selected) {
        if (!e.worker) return /* @__PURE__ */ E.jsx(E.Fragment, {});
        if (!o.source || !o.target) return /* @__PURE__ */ E.jsx(E.Fragment, {});
        if (!o.sourceHandle || !o.targetHandle) return /* @__PURE__ */ E.jsx(E.Fragment, {});
        e.worker.remove_edge({
          src_nid: o.source,
          src_ioid: o.sourceHandle,
          trg_nid: o.target,
          trg_ioid: o.targetHandle
        });
      }
    for (const o of r)
      if (o.selected) {
        if (!e.worker) return /* @__PURE__ */ E.jsx(E.Fragment, {});
        e.worker.remove_node(o.id);
      }
  }
  return /* @__PURE__ */ E.jsx(E.Fragment, {});
}, Upe = ({
  id: e,
  top: t,
  left: n,
  right: r,
  bottom: o,
  ...i
}) => {
  const { getNode: s, setNodes: u, addNodes: c, setEdges: d } = df(), p = S.useContext(it), h = S.useCallback(() => {
    const v = s(e);
    if (!v) return;
    const x = {
      x: v.position.x + 50,
      y: v.position.y + 50
    };
    c({ ...v, id: `${v.id}-copy`, position: x });
  }, [e, s, c]), g = S.useCallback(() => {
    p.on_node_action({ type: "delete", id: e, from_remote: !1 });
  }, [e, u, d]), y = p.nodespace.get_node(e, !1);
  if (!y) return /* @__PURE__ */ E.jsx(E.Fragment, { children: " " });
  const b = y.use();
  return /* @__PURE__ */ E.jsxs(
    "div",
    {
      style: { top: t, left: n, right: r, bottom: o },
      className: "context-menu",
      ...i,
      children: [
        /* @__PURE__ */ E.jsx("p", { style: { fontWeight: "bold" }, children: /* @__PURE__ */ E.jsx("small", { children: b.name }) }),
        /* @__PURE__ */ E.jsx("button", { onClick: h, children: "duplicate" }),
        /* @__PURE__ */ E.jsx("button", { onClick: g, children: "delete" })
      ]
    }
  );
}, Hpe = (e) => {
  const t = S.useContext(it), n = S.useRef(null);
  S.useEffect(() => {
    t.reactflowRef = n.current;
  }, [n]);
  const [r, o] = S.useState(null), i = ({
    nodes: g,
    edges: y
  }) => {
    const b = t.local_state.getState();
    t.local_state.setState({
      ...b,
      selected_nodes: g.map((v) => v.id),
      selected_edges: y.map((v) => v.id)
    });
  }, s = S.useCallback(() => o(null), [o]), { nodes: u, edges: c, onNodesChange: d, onEdgesChange: p, onConnect: h } = t.useReactFlowStore(Roe(Lpe));
  return /* @__PURE__ */ E.jsx("div", { className: "reactflowlayer", children: /* @__PURE__ */ E.jsxs(
    gU,
    {
      nodes: u,
      edges: c,
      onNodesChange: d,
      onEdgesChange: p,
      onConnect: h,
      nodeTypes: Ipe,
      edgeTypes: Vpe,
      minZoom: e.minZoom,
      maxZoom: e.maxZoom,
      fitView: !0,
      onSelectionChange: i,
      ref: n,
      onPaneClick: s,
      panOnDrag: !e.static,
      children: [
        /* @__PURE__ */ E.jsx(Bpe, {}),
        /* @__PURE__ */ E.jsx(Fpe, {}),
        /* @__PURE__ */ E.jsx(
          EU,
          {
            color: "#888",
            gap: 16,
            size: 1
          }
        ),
        e.minimap && /* @__PURE__ */ E.jsx(
          $U,
          {
            nodeStrokeWidth: 3,
            pannable: !e.static,
            zoomable: !e.static,
            zoomStep: 3
          }
        ),
        r && /* @__PURE__ */ E.jsx(Upe, { onClick: s, ...r })
      ]
    }
  ) });
}, Ug = S.createContext(
  void 0
), $s = S.forwardRef((e, t) => {
  const { asChild: n, children: r, className: o, style: i, ...s } = e, [u, c] = S.useState(!1), d = S.useRef(null), [p, h] = S.useState(null), [g, y] = S.useState({}), b = e.htime || 300, v = e.vtime || 300, x = e.hdelay || 0, _ = e.vdelay || 200;
  S.useImperativeHandle(t, () => d.current, []);
  const O = async () => {
    if (!d.current) return;
    d.current.style.transition = "none", d.current.style.position = "", d.current.style.top = "", d.current.style.left = "", d.current.style.width = "", d.current.style.height = "";
    const j = d.current.getBoundingClientRect();
    h([j.left, j.top, j.width, j.height]), d.current.style.transition = "none", y({
      position: "absolute",
      top: `${j.top}px`,
      left: `${j.left}px`,
      width: `${j.width}px`,
      height: `${j.height}px`
    }), y((U) => ({
      ...U,
      transitionProperty: "width, left, height, top",
      transitionDuration: `${b}ms, ${b}ms, ${v}ms, ${v}ms`
    })), c(!0);
    const I = new Promise((U) => {
      setTimeout(() => {
        y((W) => ({
          ...W,
          left: "0px",
          width: "100vw"
        })), U();
      }, x);
    }), $ = new Promise((U) => {
      setTimeout(() => {
        y((W) => ({
          ...W,
          top: "0px",
          height: "100vh"
        })), U();
      }, _);
    }), A = Math.max(b + x, v + _), V = new Promise((U) => {
      setTimeout(() => {
        U();
      }, A);
    });
    await Promise.all([I, $, V]);
  }, C = async () => {
    if (!d.current || !p) return;
    const j = {
      transitionProperty: "width, left, height, top",
      transitionDuration: `${b}ms, ${b}ms, ${v}ms, ${v}ms`
    };
    y((P) => ({
      ...P,
      ...j
    }));
    const [I, $, A, V] = p, U = new Promise((P) => {
      setTimeout(() => {
        y((H) => ({
          ...H,
          left: `${I}px`,
          width: `${A}px`
        })), P();
      }, _);
    }), W = new Promise((P) => {
      setTimeout(() => {
        y((H) => ({
          ...H,
          top: `${$}px`,
          height: `${V}px`
        })), P();
      }, x);
    }), D = Math.max(b + x, v + _), F = new Promise((P) => {
      setTimeout(() => {
        P();
      }, D);
    });
    await Promise.all([U, W, F]), d.current.style.transition = "", y({}), c(!1);
  }, N = async () => {
    d.current && (u ? await C() : await O());
  };
  let R;
  if (n && S.isValidElement(r)) {
    const j = r, I = [
      j.props.className,
      o,
      "smooth-expand",
      u ? "smooth-expand-expanded" : ""
    ].filter(Boolean).join(" "), $ = {
      ...j.props.style,
      ...i,
      ...g
    };
    R = S.cloneElement(j, {
      ref: d,
      className: I,
      style: $,
      ...s
    });
  } else
    R = /* @__PURE__ */ E.jsx(
      "div",
      {
        ref: d,
        ...s,
        className: `smooth-expand ${u ? "smooth-expand-expanded" : ""} ${o || ""}`,
        style: { ...i, ...g },
        children: r
      }
    );
  const z = /* @__PURE__ */ E.jsx(Ug.Provider, { value: { isExpanded: u, toggleExpand: N }, children: R });
  return u ? rf.createPortal(z, document.body) : z;
});
$s.Trigger = function({
  children: e
}) {
  const t = S.useContext(Ug);
  if (!t)
    throw new Error(
      "SmoothExpandComponent.Trigger must be used within a SmoothExpandComponent"
    );
  return /* @__PURE__ */ E.jsx("div", { style: { cursor: "pointer" }, onClick: t.toggleExpand, children: e });
};
$s.Expanded = function({
  children: e
}) {
  const t = S.useContext(Ug);
  if (!t)
    throw new Error(
      "SmoothExpandComponent.Expanded must be used within a SmoothExpandComponent"
    );
  return t.isExpanded ? /* @__PURE__ */ E.jsx(E.Fragment, { children: e }) : null;
};
$s.Collapsed = function({
  children: e
}) {
  const t = S.useContext(Ug);
  if (!t)
    throw new Error(
      "SmoothExpandComponent.Collapsed must be used within a SmoothExpandComponent"
    );
  return t.isExpanded ? null : /* @__PURE__ */ E.jsx(E.Fragment, { children: e });
};
const Hg = S.createContext(void 0), Wa = S.forwardRef((e, t) => {
  const { asChild: n, children: r, className: o, style: i, ...s } = e, u = S.useRef(null);
  S.useImperativeHandle(
    t,
    () => u.current,
    []
  );
  const [c, d] = S.useState(!1), p = S.useCallback(async () => {
    try {
      const g = u.current;
      if (!g) return;
      if (!c)
        g.requestFullscreen ? await g.requestFullscreen() : g.mozRequestFullScreen ? await g.mozRequestFullScreen() : g.webkitRequestFullscreen ? await g.webkitRequestFullscreen() : g.msRequestFullscreen && await g.msRequestFullscreen(), d(!0);
      else {
        const y = document;
        y.exitFullscreen ? await y.exitFullscreen() : y.mozCancelFullScreen ? await y.mozCancelFullScreen() : y.webkitExitFullscreen ? await y.webkitExitFullscreen() : y.msExitFullscreen && await y.msExitFullscreen(), d(!1);
      }
    } catch (g) {
      console.error("Error toggling fullscreen", g);
    }
  }, [c]);
  S.useEffect(() => {
    const g = () => {
      const y = document.fullscreenElement;
      d(!!y);
    };
    return document.addEventListener("fullscreenchange", g), document.addEventListener("webkitfullscreenchange", g), document.addEventListener("mozfullscreenchange", g), document.addEventListener("MSFullscreenChange", g), () => {
      document.removeEventListener("fullscreenchange", g), document.removeEventListener(
        "webkitfullscreenchange",
        g
      ), document.removeEventListener(
        "mozfullscreenchange",
        g
      ), document.removeEventListener(
        "MSFullscreenChange",
        g
      );
    };
  }, []);
  let h;
  if (n && S.isValidElement(r)) {
    const g = r, y = [g.props.className, o].filter(Boolean).join(" "), b = { ...g.props.style, ...i };
    h = S.cloneElement(g, {
      ref: u,
      className: y,
      style: b,
      ...s
    });
  } else
    h = /* @__PURE__ */ E.jsx("div", { ref: u, ...s, className: o, style: i, children: r });
  return /* @__PURE__ */ E.jsx(Hg.Provider, { value: { isFullScreen: c, toggleFullscreen: p }, children: h });
});
Wa.Trigger = function({
  children: e
}) {
  const t = S.useContext(Hg);
  if (!t)
    throw new Error(
      "FullScreenComponent.Trigger must be used within a FullScreenComponent"
    );
  return /* @__PURE__ */ E.jsx("div", { style: { cursor: "pointer" }, onClick: t.toggleFullscreen, children: e });
};
Wa.InFullScreen = function({
  children: e
}) {
  const t = S.useContext(Hg);
  if (!t)
    throw new Error(
      "FullScreenComponent.Expanded must be used within a FullScreenComponent"
    );
  return t.isFullScreen ? /* @__PURE__ */ E.jsx(E.Fragment, { children: e }) : null;
};
Wa.OutFullScreen = function({
  children: e
}) {
  const t = S.useContext(Hg);
  if (!t)
    throw new Error(
      "FullScreenComponent.Collapsed must be used within a FullScreenComponent"
    );
  return t.isFullScreen ? null : /* @__PURE__ */ E.jsx(E.Fragment, { children: e });
};
const $pe = ({
  fnrf_zst: e,
  header: t,
  flow: n,
  library: r
}) => {
  const [o, i] = S.useState(
    e.options.worker
  ), s = S.useRef(null);
  e.workermanager && (e.workermanager.on_setWorker = i), e.set_worker(o), S.useEffect(() => {
    e.auto_progress();
  }, []), S.useEffect(() => {
    e.local_state.setState({ funcnodescontainerRef: s.current });
  }, [s]);
  const u = e.plugins();
  return /* @__PURE__ */ E.jsx(gpe, { plugins: u, fnrf_zst: e, children: /* @__PURE__ */ E.jsx(it.Provider, { value: e, children: /* @__PURE__ */ E.jsx($s, { asChild: !0, children: /* @__PURE__ */ E.jsx(Wa, { asChild: !0, children: /* @__PURE__ */ E.jsx(
    VK,
    {
      style: {
        height: "100%",
        width: "100%",
        display: "flex",
        flexDirection: "column",
        flex: 1
      },
      children: /* @__PURE__ */ E.jsxs(
        "div",
        {
          ref: s,
          className: "funcnodesreactflowcontainer funcnodescontainer",
          children: [
            t.show && /* @__PURE__ */ E.jsx(WK, { ...t }),
            /* @__PURE__ */ E.jsxs("div", { className: "funcnodesreactflowbody", children: [
              /* @__PURE__ */ E.jsx(Hpe, { ...n }),
              o && r.show && /* @__PURE__ */ E.jsx(Aoe, {}),
              o && n.showNodeSettings && /* @__PURE__ */ E.jsx(Dpe, {})
            ] }),
            /* @__PURE__ */ E.jsxs("div", { className: "funcnodesflaotingmenu", children: [
              /* @__PURE__ */ E.jsx(Wa.OutFullScreen, { children: n.allowExpand && /* @__PURE__ */ E.jsxs($s.Trigger, { children: [
                /* @__PURE__ */ E.jsx($s.Expanded, { children: /* @__PURE__ */ E.jsx(
                  rG,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) }),
                /* @__PURE__ */ E.jsx($s.Collapsed, { children: /* @__PURE__ */ E.jsx(
                  oG,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) })
              ] }) }),
              n.allowFullScreen && /* @__PURE__ */ E.jsxs(Wa.Trigger, { children: [
                /* @__PURE__ */ E.jsx(Wa.OutFullScreen, { children: /* @__PURE__ */ E.jsx(FR, { size: "xl", style: { padding: "4px" } }) }),
                /* @__PURE__ */ E.jsx(Wa.InFullScreen, { children: /* @__PURE__ */ E.jsx(
                  nG,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) })
              ] })
            ] })
          ]
        }
      )
    }
  ) }) }) }) });
}, eS = {};
window.fnrf_zst === void 0 && (window.fnrf_zst = eS);
const Ype = {
  show: !0
}, qpe = {
  show: !0,
  showmenu: !0
}, Xpe = {
  minimap: !0,
  static: !1,
  minZoom: 0.1,
  maxZoom: 5,
  allowFullScreen: !0,
  allowExpand: !0,
  showNodeSettings: !0
}, fD = {
  id: "",
  // required
  debug: !1,
  useWorkerManager: !0,
  show_library: !0,
  header: qpe,
  flow: Xpe,
  library: Ype
}, it = S.createContext(
  tM(fD)
), Wpe = (e) => {
  let t = of(e, {
    ...fD,
    id: CM()
  }).new_obj;
  if (!t.useWorkerManager && t.worker === void 0)
    return /* @__PURE__ */ E.jsx("div", { children: "Error: If you don't use a worker manager, you must provide a default worker." });
  if (e.useWorkerManager && e.workermanager_url === void 0)
    return /* @__PURE__ */ E.jsx("div", { children: "Error: If you use a worker manager, you must provide a worker manager url." });
  let n = eS[t.id];
  n === void 0 && (n = tM(t), eS[t.id] = n), n.options.debug = t.debug;
  const [r, o] = S.useState(t);
  return S.useEffect(() => {
    const i = [];
    if (r.worker === void 0 && r.worker_url !== void 0) {
      r.useWorkerManager = !1;
      const s = new AM({
        url: r.worker_url,
        uuid: r.id,
        on_sync_complete: r.on_sync_complete
      });
      r.worker = s, i.push(() => {
        s.disconnect();
      });
    }
    if (r.fnw_url !== void 0) {
      if (r.worker === void 0)
        throw new Error("defining fnw_url requires a worker to be defined");
      const s = $$(r.fnw_url), u = r.worker.on_sync_complete, c = async (d) => {
        const p = await s;
        d.on_sync_complete = u, await d.update_from_export(p);
      };
      r.worker.on_sync_complete = c;
    }
    if (r.worker !== void 0 && r.worker.set_zustand(n), t.useWorkerManager) {
      const s = new P$(
        t.workermanager_url,
        n
      );
      n.workermanager = s, i.push(() => {
        s.remove();
      });
    }
    return o({ ...r }), r.on_ready && typeof r.on_ready == "function" && r.on_ready({ fnrf_zst: n }), () => {
      for (const s of i)
        s();
    };
  }, []), /* @__PURE__ */ E.jsx(
    $pe,
    {
      fnrf_zst: n,
      header: r.header,
      library: r.library,
      flow: r.flow
    }
  );
}, Gpe = (e) => (new eM("FuncNodes", e.debug ? "debug" : "info").debug("Initalizing FuncNodes with props:", e), /* @__PURE__ */ E.jsx("div", { className: "FuncnodesApp", children: /* @__PURE__ */ E.jsx(Wpe, { ...e }) })), zn = [];
for (let e = 0; e < 256; ++e)
  zn.push((e + 256).toString(16).slice(1));
function Zpe(e, t = 0) {
  return (zn[e[t + 0]] + zn[e[t + 1]] + zn[e[t + 2]] + zn[e[t + 3]] + "-" + zn[e[t + 4]] + zn[e[t + 5]] + "-" + zn[e[t + 6]] + zn[e[t + 7]] + "-" + zn[e[t + 8]] + zn[e[t + 9]] + "-" + zn[e[t + 10]] + zn[e[t + 11]] + zn[e[t + 12]] + zn[e[t + 13]] + zn[e[t + 14]] + zn[e[t + 15]]).toLowerCase();
}
let uw;
const Kpe = new Uint8Array(16);
function Qpe() {
  if (!uw) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    uw = crypto.getRandomValues.bind(crypto);
  }
  return uw(Kpe);
}
const Jpe = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), G3 = { randomUUID: Jpe };
function ehe(e, t, n) {
  var r;
  if (G3.randomUUID && !e)
    return G3.randomUUID();
  e = e || {};
  const o = e.random ?? ((r = e.rng) == null ? void 0 : r.call(e)) ?? Qpe();
  if (o.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, Zpe(o);
}
const pD = '(function(){"use strict";const d="https://cdn.jsdelivr.net/pyodide/v0.27.2/full/pyodide.mjs",e=self;e.workerState={pyodide:null,pyodide_url:d,packages:[],state:{msg:"loading",loaded:!1,progress:0},micropip:null,worker:{},pyodideReady:!1,pyodideReadyPromise:null,debug:!1,interruptBuffer:null,receivepy:(r,t)=>{},receivepy_bytes:(r,t)=>{},handel_register:{},post_pyodide_ready:void 0},e.reset=async()=>{var r;for(const t in e.list_workers())try{const o=await e.get_worker(t);o.worker&&o.worker.stop(),(r=o.reject_promise)==null||r.call(o,"Worker reset")}catch{}e.workerState.pyodide&&e.interrupt(),e.workerState.pyodide=null,e.workerState.micropip=null,e.workerState.worker={},e.workerState.pyodideReady=!1;try{e.workerState.interruptBuffer=new Uint8Array(new SharedArrayBuffer(1)),e.workerState.interruptBuffer[0]=0}catch{}},e.initializePyodide=async()=>{var r,t;if(!e.workerState.pyodide){console.log("initializePyodide with: Debug:",e.workerState.debug,"Pyodide URL:",e.workerState.pyodide_url,"Packages:",e.workerState.packages),console.debug("Loading Pyodide..."),e.workerState.state.msg="Loading Pyodide...",e.workerState.state.progress=0,await e.reset(),console.debug("Loading Pyodide module..."),e.workerState.state.msg="Loading Pyodide module...",e.workerState.state.progress=.1;const o=await import(e.workerState.pyodide_url);console.debug("Loading Pyodide instance..."),e.workerState.state.msg="Loading Pyodide instance...",e.workerState.state.progress=.2;const i=o.loadPyodide,a=e.workerState.pyodide_url.split("/").slice(0,-1).join("/");console.log(a),e.workerState.pyodide=await i({packages:["micropip"],indexURL:a}),e.workerState.interruptBuffer&&e.workerState.pyodide.setInterruptBuffer(e.workerState.interruptBuffer)}e.workerState.micropip||(console.debug("Importing micropip..."),e.workerState.state.msg="Importing micropip...",e.workerState.state.progress=.3,e.workerState.micropip=e.workerState.pyodide.pyimport("micropip")),console.debug("Pyodide ready. Installing funcnodes...");for(const o of e.workerState.packages)console.log("Installing package:",o),e.workerState.state.msg=`Installing package: ${o}`,await e.workerState.micropip.install(o);return e.workerState.state.msg="Installing funcnodes",e.workerState.state.progress=.8,await e.workerState.micropip.install("funcnodes"),e.workerState.state.msg="Installing funcnodes-worker",await e.workerState.micropip.install("funcnodes-worker"),e.workerState.state.msg="Installing funcnodes-pyodide",await e.workerState.micropip.install("funcnodes-pyodide"),e.workerState.state.msg="Installing funcnodes-react-flow",await e.workerState.micropip.install("funcnodes-react-flow"),e.workerState.state.msg="Importing funcnodes",console.debug("Importing funcnodes..."),await e.workerState.pyodide.runPythonAsync("import funcnodes_pyodide"),console.debug("Running post_pyodide_ready..."),await((t=(r=e.workerState).post_pyodide_ready)==null?void 0:t.call(r,e.workerState)),console.debug("Pyodide ready"),e.workerState.state.msg="ready",e.workerState.state.progress=.1,e.workerState.pyodideReady=!0,{pyodide:e.workerState.pyodide,micropip:e.workerState.micropip}},e.interrupt=()=>{e.workerState.interruptBuffer&&(e.workerState.interruptBuffer[0]=1)},e.list_workers=()=>Object.keys(e.workerState.worker),e.get_worker=async r=>{if(!r)throw new Error("Worker id is required");if(!e.workerState.worker[r])throw new Error(`Worker with id ${r} not found`);return await e.workerState.worker[r].make_promise,e.workerState.worker[r]},e.has_worker=r=>{if(!r)throw new Error("Worker id is required");return!!e.workerState.worker[r]},e.get_or_create_worker=async r=>{if(!r)throw new Error("Worker id is required");return e.workerState.worker[r]||(console.log("Creating worker with id",r),await e.initializeFuncNodesWorker(r)),e.get_worker(r)},e.initializeFuncNodesWorker=async r=>{try{if(!e.workerState.pyodideReadyPromise)throw new Error("Pyodide newer initialized");const{pyodide:t}=await e.workerState.pyodideReadyPromise;if(!e.has_worker(r)){e.workerState.worker[r]={worker:null,make_promise:void 0};const o=new Promise(async(i,a)=>{e.workerState.worker[r].reject_promise=a,console.debug(`Creating worker (${r})...`);const s=await t.runPythonAsync(`funcnodes_pyodide.new_worker(debug=${e.workerState.debug?1:0}, uuid="${r}")`);if(console.debug("Worker created:",s),typeof s.set_receiver=="function")s.set_receiver(self);else throw new Error("Worker does not expose a \'set_receiver\' method.");e.workerState.worker[r].worker=s,console.debug("Worker ready"),i(s)});e.workerState.worker[r].make_promise=o}return e.get_worker(r)}catch(t){throw console.error("Error during worker initialization:",t),t}},e.receivepy=(r,t)=>{try{let o={};if(typeof r=="string"?o.msg=r:o=r,o.msg===void 0)return;typeof o.msg!="string"&&(o.msg=JSON.stringify(o.msg)),t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const i=o.worker_id;if(!i)throw new Error(`Worker id not provided in receivepy(${JSON.stringify(o)})`);if(!e.workerState.worker[i])throw new Error(`Worker with id ${i} not found in receivepy(${JSON.stringify(o)})`);e.workerState.receivepy(r,i)}catch(o){console.error("Error during receivepy:",o);return}},e.receivepy_bytes=(r,t)=>{r=r.toJs();try{let o={};if(r instanceof Uint8Array?o.msg=r:o=r,o.msg===void 0)return;t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const i=o.worker_id;if(!i)throw new Error("Worker id not provided in receivepy_bytes");if(!e.workerState.worker[i])throw new Error(`Worker with id ${i} not found in receivepy_bytes`);e.workerState.receivepy_bytes(r,i)}catch(o){console.error("Error during receivepy_bytes:",o);return}},e.startInitialization=({debug:r=!1,receivepy:t,receivepy_bytes:o,pyodide_url:i,post_pyodide_ready:a,packages:s})=>(e.workerState.debug=r,e.workerState.pyodide_url=i||d,e.workerState.packages=s,e.workerState.receivepy=t,e.workerState.receivepy_bytes=o,e.workerState.pyodideReadyPromise=null,e.workerState.post_pyodide_ready=a,e.workerState),e.register_cmd_message=(r,t)=>{if(e.workerState.handel_register[r])throw new Error(`Command ${r} already registered`);e.workerState.handel_register[r]=t},e.register_cmd_message("ping",async r=>"pong"),e.register_cmd_message("init",async r=>{if(e.workerState.pyodideReadyPromise)throw new Error("Pyodide is already initialized");r.data&&(r.data.pyodide_url&&(e.workerState.pyodide_url=r.data.pyodide_url),r.data.packages&&(e.workerState.packages=r.data.packages),r.data.debug&&(e.workerState.debug=r.data.debug)),e.workerState.pyodideReadyPromise=e.initializePyodide()}),e.register_cmd_message("_eval",async r=>{var t;try{const o=await((t=e.workerState.pyodide)==null?void 0:t.runPythonAsync(r.msg||"print(\'No code provided\')"));return console.log("Eval result:",o),o}catch(o){console.error("Error during _eval:",o)}}),e.register_cmd_message("state",async r=>({state:{...e.workerState.state,loaded:e.workerState.pyodideReady}})),e.register_cmd_message("worker:state",async r=>({state:{loaded:!!(await e.get_or_create_worker(r.worker_id)).worker}})),e.register_cmd_message("worker:stop",async r=>{var o;if(!e.has_worker(r.worker_id))return;const t=await e.get_or_create_worker(r.worker_id);return t.worker&&(t.worker.stop(),t.worker=null,(o=t.reject_promise)==null||o.call(t,"Worker stopped")),delete e.workerState.worker[r.worker_id],{state:{loaded:!1}}}),e.register_cmd_message("worker:send",async r=>{const t=await e.get_or_create_worker(r.worker_id);if(!t.worker)throw new Error("Worker is not initialized");if(typeof t.worker.receivejs!="function")throw new Error(`Worker does not support receivejs: ${typeof t.worker.receivejs}`);t.worker.receivejs(r.msg)}),e.handleMessage=async r=>{const t={original:r};r.id&&(t.id=r.id),r.toJs===void 0&&(r.toJs=!0);try{if(r.cmd){const o=r;if(e.workerState.handel_register[o.cmd])t.result=await e.workerState.handel_register[o.cmd](o);else throw new Error("Unknown command: "+o.cmd)}else throw new Error("Unknown message format: "+JSON.stringify(r))}catch(o){t.error=o.message}return t},e.read_url_params=()=>{var a,s;const r=new URLSearchParams(self.location.search),t=((a=r.get("debug"))==null?void 0:a.toLowerCase())==="true",o=r.get("pyodide_url")||void 0,i=((s=r.get("packages"))==null?void 0:s.split(","))||[];return{debug:t,pyodide_url:o,packages:i}};const n=e;n.general_initalization=r=>{const t=n.read_url_params();n.startInitialization({...r,...t})};const w=n,c=n;c.init_dedicated_worker=r=>{const t=e;t.onmessage=async i=>{const a=i.data,s=await t.handleMessage(a);t.postMessage(s)};const o={...r,receivepy:(i,a)=>{t.postMessage({cmd:"receive",msg:i,worker_id:a})},receivepy_bytes(i,a){t.postMessage({cmd:"receive_bytes",msg:i,worker_id:a})}};t.general_initalization(o)},w.init_shared_worker=r=>{const t=e;t.connectedPorts=[],t.onconnect=i=>{const a=i.ports[0];t.connectedPorts.push(a),a.start(),console.debug("Port connected in shared worker"),a.onmessage=async s=>{const k=s.data,p=await t.handleMessage(k);a.postMessage(p)}};const o={...r,receivepy:(i,a)=>{t.connectedPorts.forEach(s=>{s.postMessage({cmd:"receive",msg:i,worker_id:a})})},receivepy_bytes(i,a){t.connectedPorts.forEach(s=>{s.postMessage({cmd:"receive_bytes",msg:i,worker_id:a})})}};t.general_initalization(o)},(r=>{n.init_dedicated_worker(r)})({})})();\n', Z3 = typeof self < "u" && self.Blob && new Blob([pD], { type: "text/javascript;charset=utf-8" });
function the(e) {
  let t;
  try {
    if (t = Z3 && (self.URL || self.webkitURL).createObjectURL(Z3), !t) throw "";
    const n = new Worker(t, {
      name: e?.name
    });
    return n.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(t);
    }), n;
  } catch {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(pD),
      {
        name: e?.name
      }
    );
  } finally {
    t && (self.URL || self.webkitURL).revokeObjectURL(t);
  }
}
const nhe = '(function(){"use strict";const d="https://cdn.jsdelivr.net/pyodide/v0.27.2/full/pyodide.mjs",e=self;e.workerState={pyodide:null,pyodide_url:d,packages:[],state:{msg:"loading",loaded:!1,progress:0},micropip:null,worker:{},pyodideReady:!1,pyodideReadyPromise:null,debug:!1,interruptBuffer:null,receivepy:(r,t)=>{},receivepy_bytes:(r,t)=>{},handel_register:{},post_pyodide_ready:void 0},e.reset=async()=>{var r;for(const t in e.list_workers())try{const o=await e.get_worker(t);o.worker&&o.worker.stop(),(r=o.reject_promise)==null||r.call(o,"Worker reset")}catch{}e.workerState.pyodide&&e.interrupt(),e.workerState.pyodide=null,e.workerState.micropip=null,e.workerState.worker={},e.workerState.pyodideReady=!1;try{e.workerState.interruptBuffer=new Uint8Array(new SharedArrayBuffer(1)),e.workerState.interruptBuffer[0]=0}catch{}},e.initializePyodide=async()=>{var r,t;if(!e.workerState.pyodide){console.log("initializePyodide with: Debug:",e.workerState.debug,"Pyodide URL:",e.workerState.pyodide_url,"Packages:",e.workerState.packages),console.debug("Loading Pyodide..."),e.workerState.state.msg="Loading Pyodide...",e.workerState.state.progress=0,await e.reset(),console.debug("Loading Pyodide module..."),e.workerState.state.msg="Loading Pyodide module...",e.workerState.state.progress=.1;const o=await import(e.workerState.pyodide_url);console.debug("Loading Pyodide instance..."),e.workerState.state.msg="Loading Pyodide instance...",e.workerState.state.progress=.2;const i=o.loadPyodide,a=e.workerState.pyodide_url.split("/").slice(0,-1).join("/");console.log(a),e.workerState.pyodide=await i({packages:["micropip"],indexURL:a}),e.workerState.interruptBuffer&&e.workerState.pyodide.setInterruptBuffer(e.workerState.interruptBuffer)}e.workerState.micropip||(console.debug("Importing micropip..."),e.workerState.state.msg="Importing micropip...",e.workerState.state.progress=.3,e.workerState.micropip=e.workerState.pyodide.pyimport("micropip")),console.debug("Pyodide ready. Installing funcnodes...");for(const o of e.workerState.packages)console.log("Installing package:",o),e.workerState.state.msg=`Installing package: ${o}`,await e.workerState.micropip.install(o);return e.workerState.state.msg="Installing funcnodes",e.workerState.state.progress=.8,await e.workerState.micropip.install("funcnodes"),e.workerState.state.msg="Installing funcnodes-worker",await e.workerState.micropip.install("funcnodes-worker"),e.workerState.state.msg="Installing funcnodes-pyodide",await e.workerState.micropip.install("funcnodes-pyodide"),e.workerState.state.msg="Installing funcnodes-react-flow",await e.workerState.micropip.install("funcnodes-react-flow"),e.workerState.state.msg="Importing funcnodes",console.debug("Importing funcnodes..."),await e.workerState.pyodide.runPythonAsync("import funcnodes_pyodide"),console.debug("Running post_pyodide_ready..."),await((t=(r=e.workerState).post_pyodide_ready)==null?void 0:t.call(r,e.workerState)),console.debug("Pyodide ready"),e.workerState.state.msg="ready",e.workerState.state.progress=.1,e.workerState.pyodideReady=!0,{pyodide:e.workerState.pyodide,micropip:e.workerState.micropip}},e.interrupt=()=>{e.workerState.interruptBuffer&&(e.workerState.interruptBuffer[0]=1)},e.list_workers=()=>Object.keys(e.workerState.worker),e.get_worker=async r=>{if(!r)throw new Error("Worker id is required");if(!e.workerState.worker[r])throw new Error(`Worker with id ${r} not found`);return await e.workerState.worker[r].make_promise,e.workerState.worker[r]},e.has_worker=r=>{if(!r)throw new Error("Worker id is required");return!!e.workerState.worker[r]},e.get_or_create_worker=async r=>{if(!r)throw new Error("Worker id is required");return e.workerState.worker[r]||(console.log("Creating worker with id",r),await e.initializeFuncNodesWorker(r)),e.get_worker(r)},e.initializeFuncNodesWorker=async r=>{try{if(!e.workerState.pyodideReadyPromise)throw new Error("Pyodide newer initialized");const{pyodide:t}=await e.workerState.pyodideReadyPromise;if(!e.has_worker(r)){e.workerState.worker[r]={worker:null,make_promise:void 0};const o=new Promise(async(i,a)=>{e.workerState.worker[r].reject_promise=a,console.debug(`Creating worker (${r})...`);const s=await t.runPythonAsync(`funcnodes_pyodide.new_worker(debug=${e.workerState.debug?1:0}, uuid="${r}")`);if(console.debug("Worker created:",s),typeof s.set_receiver=="function")s.set_receiver(self);else throw new Error("Worker does not expose a \'set_receiver\' method.");e.workerState.worker[r].worker=s,console.debug("Worker ready"),i(s)});e.workerState.worker[r].make_promise=o}return e.get_worker(r)}catch(t){throw console.error("Error during worker initialization:",t),t}},e.receivepy=(r,t)=>{try{let o={};if(typeof r=="string"?o.msg=r:o=r,o.msg===void 0)return;typeof o.msg!="string"&&(o.msg=JSON.stringify(o.msg)),t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const i=o.worker_id;if(!i)throw new Error(`Worker id not provided in receivepy(${JSON.stringify(o)})`);if(!e.workerState.worker[i])throw new Error(`Worker with id ${i} not found in receivepy(${JSON.stringify(o)})`);e.workerState.receivepy(r,i)}catch(o){console.error("Error during receivepy:",o);return}},e.receivepy_bytes=(r,t)=>{r=r.toJs();try{let o={};if(r instanceof Uint8Array?o.msg=r:o=r,o.msg===void 0)return;t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const i=o.worker_id;if(!i)throw new Error("Worker id not provided in receivepy_bytes");if(!e.workerState.worker[i])throw new Error(`Worker with id ${i} not found in receivepy_bytes`);e.workerState.receivepy_bytes(r,i)}catch(o){console.error("Error during receivepy_bytes:",o);return}},e.startInitialization=({debug:r=!1,receivepy:t,receivepy_bytes:o,pyodide_url:i,post_pyodide_ready:a,packages:s})=>(e.workerState.debug=r,e.workerState.pyodide_url=i||d,e.workerState.packages=s,e.workerState.receivepy=t,e.workerState.receivepy_bytes=o,e.workerState.pyodideReadyPromise=null,e.workerState.post_pyodide_ready=a,e.workerState),e.register_cmd_message=(r,t)=>{if(e.workerState.handel_register[r])throw new Error(`Command ${r} already registered`);e.workerState.handel_register[r]=t},e.register_cmd_message("ping",async r=>"pong"),e.register_cmd_message("init",async r=>{if(e.workerState.pyodideReadyPromise)throw new Error("Pyodide is already initialized");r.data&&(r.data.pyodide_url&&(e.workerState.pyodide_url=r.data.pyodide_url),r.data.packages&&(e.workerState.packages=r.data.packages),r.data.debug&&(e.workerState.debug=r.data.debug)),e.workerState.pyodideReadyPromise=e.initializePyodide()}),e.register_cmd_message("_eval",async r=>{var t;try{const o=await((t=e.workerState.pyodide)==null?void 0:t.runPythonAsync(r.msg||"print(\'No code provided\')"));return console.log("Eval result:",o),o}catch(o){console.error("Error during _eval:",o)}}),e.register_cmd_message("state",async r=>({state:{...e.workerState.state,loaded:e.workerState.pyodideReady}})),e.register_cmd_message("worker:state",async r=>({state:{loaded:!!(await e.get_or_create_worker(r.worker_id)).worker}})),e.register_cmd_message("worker:stop",async r=>{var o;if(!e.has_worker(r.worker_id))return;const t=await e.get_or_create_worker(r.worker_id);return t.worker&&(t.worker.stop(),t.worker=null,(o=t.reject_promise)==null||o.call(t,"Worker stopped")),delete e.workerState.worker[r.worker_id],{state:{loaded:!1}}}),e.register_cmd_message("worker:send",async r=>{const t=await e.get_or_create_worker(r.worker_id);if(!t.worker)throw new Error("Worker is not initialized");if(typeof t.worker.receivejs!="function")throw new Error(`Worker does not support receivejs: ${typeof t.worker.receivejs}`);t.worker.receivejs(r.msg)}),e.handleMessage=async r=>{const t={original:r};r.id&&(t.id=r.id),r.toJs===void 0&&(r.toJs=!0);try{if(r.cmd){const o=r;if(e.workerState.handel_register[o.cmd])t.result=await e.workerState.handel_register[o.cmd](o);else throw new Error("Unknown command: "+o.cmd)}else throw new Error("Unknown message format: "+JSON.stringify(r))}catch(o){t.error=o.message}return t},e.read_url_params=()=>{var a,s;const r=new URLSearchParams(self.location.search),t=((a=r.get("debug"))==null?void 0:a.toLowerCase())==="true",o=r.get("pyodide_url")||void 0,i=((s=r.get("packages"))==null?void 0:s.split(","))||[];return{debug:t,pyodide_url:o,packages:i}};const n=e;n.general_initalization=r=>{const t=n.read_url_params();n.startInitialization({...r,...t})};const w=n,c=n;c.init_dedicated_worker=r=>{const t=e;t.onmessage=async i=>{const a=i.data,s=await t.handleMessage(a);t.postMessage(s)};const o={...r,receivepy:(i,a)=>{t.postMessage({cmd:"receive",msg:i,worker_id:a})},receivepy_bytes(i,a){t.postMessage({cmd:"receive_bytes",msg:i,worker_id:a})}};t.general_initalization(o)},w.init_shared_worker=r=>{const t=e;t.connectedPorts=[],t.onconnect=i=>{const a=i.ports[0];t.connectedPorts.push(a),a.start(),console.debug("Port connected in shared worker"),a.onmessage=async s=>{const k=s.data,p=await t.handleMessage(k);a.postMessage(p)}};const o={...r,receivepy:(i,a)=>{t.connectedPorts.forEach(s=>{s.postMessage({cmd:"receive",msg:i,worker_id:a})})},receivepy_bytes(i,a){t.connectedPorts.forEach(s=>{s.postMessage({cmd:"receive_bytes",msg:i,worker_id:a})})}};t.general_initalization(o)},(r=>{n.init_shared_worker(r)})({})})();\n';
function rhe(e) {
  return new SharedWorker(
    "data:text/javascript;charset=utf-8," + encodeURIComponent(nhe),
    {
      name: e?.name
    }
  );
}
const ohe = (e) => (e.worker || (e.worker_classes || (e.worker_classes = {
  Shared: rhe,
  Dedicated: the
}), e.shared_worker ? e.worker_url === void 0 ? e.worker = new e.worker_classes.Shared({
  name: e.uuid
}) : e.worker = new SharedWorker(e.worker_url, {
  name: e.uuid,
  type: "module"
}) : e.worker_url === void 0 ? e.worker = new e.worker_classes.Dedicated({
  name: e.uuid
}) : e.worker = new Worker(e.worker_url, {
  name: e.uuid,
  type: "module"
})), e.worker);
let hD = class extends OM {
  constructor(t) {
    const n = {
      uuid: ehe(),
      ...t
    };
    if (super(n), this._message_hooks = [], this._worker = ohe(n), this._worker instanceof SharedWorker)
      n.shared_worker = !0, this._port = this._worker.port, this._port.start(), this._port.addEventListener("message", this.onmessage.bind(this));
    else if (this._worker instanceof Worker)
      n.shared_worker = !1, this._worker.addEventListener("message", this.onmessage.bind(this));
    else
      throw new Error("worker must be an instance of Worker or SharedWorker");
    this.postMessage({
      cmd: "init",
      data: {
        debug: n.debug,
        pyodide_url: n.pyodide_url,
        packages: n.packages
      }
    });
    const r = setInterval(() => {
      this.postMessage({ cmd: "state" });
    }, 400);
    this._workerstate = { loaded: !1, msg: "loading", progress: 0 }, this.initPromise = new Promise(async (o) => {
      for (var i; !this._workerstate.loaded; )
        await new Promise((s) => setTimeout(s, 100));
      clearInterval(r), this.is_open = !0, (i = this._zustand) == null || i.auto_progress(), o();
    }), this.initPromise.then(() => {
      this.stepwise_fullsync();
    });
  }
  async send(t) {
    await this.initPromise, this.postMessage({
      cmd: "worker:send",
      msg: JSON.stringify(t),
      worker_id: this.uuid
    });
  }
  postMessage(t) {
    t.worker_id = this.uuid, this._port ? this._port.postMessage(t) : this._worker.postMessage(t);
  }
  registerMessageHook(t) {
    return this._message_hooks.push(t), () => {
      this._message_hooks = this._message_hooks.filter((n) => n !== t);
    };
  }
  onmessage(t) {
    var n;
    for (const r of this._message_hooks)
      r(t.data);
    if (t.data.result)
      t.data.result.state && (this._workerstate = {
        ...this._workerstate,
        ...t.data.result.state
      }, t.data.result.state.msg && t.data.result.state.msg !== "ready" && ((n = this._zustand) == null || n.set_progress({
        message: this._workerstate.msg,
        status: "info",
        progress: this._workerstate.progress,
        blocking: !0
      })));
    else if (t.data.cmd) {
      if (t.data.cmd === "receive") {
        if (t.data.worker_id === void 0)
          throw new Error("worker_id is undefined");
        t.data.worker_id === this.uuid && this.receive(JSON.parse(t.data.msg));
      } else if (t.data.cmd === "receive_bytes") {
        if (t.data.worker_id === void 0)
          throw new Error("worker_id is undefined");
        t.data.worker_id === this.uuid && this.onbytes(t.data.msg);
      }
    }
  }
  async upload_file({
    files: t,
    onProgressCallback: n,
    root: r
  }) {
    const o = [], i = t.length;
    let s = 0;
    if (t.length === 0)
      return "";
    for (let c = 0; c < t.length; c++) {
      const d = t[c], p = new FileReader(), h = new Promise((g, y) => {
        p.onload = async (b) => {
          var v;
          try {
            const x = (v = b.target.result) == null ? void 0 : v.replace(/^data:.+;base64,/, ""), _ = d.webkitRelativePath || d.name, O = r ? `${r}/${_}` : _, C = await this._send_cmd({
              cmd: "upload",
              kwargs: { data: x, filename: O },
              wait_for_response: !0
            });
            s++, n && n(s, i), g(C);
          } catch (x) {
            y(x);
          }
        }, p.readAsDataURL(d);
      });
      o.push(h);
    }
    const u = await Promise.all(o);
    return u.reduce((c, d) => {
      const p = d.split("/"), h = c.split("/"), g = [];
      for (let y = 0; y < p.length && p[y] === h[y]; y++)
        g.push(p[y]);
      return g.join("/");
    }, u[0]);
  }
  get ready() {
    return this._workerstate.loaded;
  }
};
const ihe = {}, K3 = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (p, h) => {
    const g = typeof p == "function" ? p(t) : p;
    if (!Object.is(g, t)) {
      const y = t;
      t = h ?? (typeof g != "object" || g === null) ? g : Object.assign({}, t, g), n.forEach((b) => b(t, y));
    }
  }, o = () => t, c = { setState: r, getState: o, getInitialState: () => d, subscribe: (p) => (n.add(p), () => n.delete(p)), destroy: () => {
    (ihe ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), n.clear();
  } }, d = t = e(r, o, c);
  return c;
}, ahe = (e) => e ? K3(e) : K3;
var cw = { exports: {} }, dw = {}, fw = { exports: {} }, pw = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Q3;
function she() {
  if (Q3) return pw;
  Q3 = 1;
  var e = nf();
  function t(h, g) {
    return h === g && (h !== 0 || 1 / h === 1 / g) || h !== h && g !== g;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, o = e.useEffect, i = e.useLayoutEffect, s = e.useDebugValue;
  function u(h, g) {
    var y = g(), b = r({ inst: { value: y, getSnapshot: g } }), v = b[0].inst, x = b[1];
    return i(
      function() {
        v.value = y, v.getSnapshot = g, c(v) && x({ inst: v });
      },
      [h, y, g]
    ), o(
      function() {
        return c(v) && x({ inst: v }), h(function() {
          c(v) && x({ inst: v });
        });
      },
      [h]
    ), s(y), y;
  }
  function c(h) {
    var g = h.getSnapshot;
    h = h.value;
    try {
      var y = g();
      return !n(h, y);
    } catch {
      return !0;
    }
  }
  function d(h, g) {
    return g();
  }
  var p = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? d : u;
  return pw.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : p, pw;
}
var J3;
function lhe() {
  return J3 || (J3 = 1, fw.exports = she()), fw.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e4;
function uhe() {
  if (e4) return dw;
  e4 = 1;
  var e = nf(), t = lhe();
  function n(d, p) {
    return d === p && (d !== 0 || 1 / d === 1 / p) || d !== d && p !== p;
  }
  var r = typeof Object.is == "function" ? Object.is : n, o = t.useSyncExternalStore, i = e.useRef, s = e.useEffect, u = e.useMemo, c = e.useDebugValue;
  return dw.useSyncExternalStoreWithSelector = function(d, p, h, g, y) {
    var b = i(null);
    if (b.current === null) {
      var v = { hasValue: !1, value: null };
      b.current = v;
    } else v = b.current;
    b = u(
      function() {
        function _(z) {
          if (!O) {
            if (O = !0, C = z, z = g(z), y !== void 0 && v.hasValue) {
              var j = v.value;
              if (y(j, z))
                return N = j;
            }
            return N = z;
          }
          if (j = N, r(C, z)) return j;
          var I = g(z);
          return y !== void 0 && y(j, I) ? (C = z, j) : (C = z, N = I);
        }
        var O = !1, C, N, R = h === void 0 ? null : h;
        return [
          function() {
            return _(p());
          },
          R === null ? void 0 : function() {
            return _(R());
          }
        ];
      },
      [p, h, g, y]
    );
    var x = o(d, b[0], b[1]);
    return s(
      function() {
        v.hasValue = !0, v.value = x;
      },
      [x]
    ), c(x), x;
  }, dw;
}
var t4;
function che() {
  return t4 || (t4 = 1, cw.exports = uhe()), cw.exports;
}
var dhe = che();
const fhe = /* @__PURE__ */ Tm(dhe), mD = {}, { useDebugValue: phe } = Qe, { useSyncExternalStoreWithSelector: hhe } = fhe;
let n4 = !1;
const mhe = (e) => e;
function ghe(e, t = mhe, n) {
  (mD ? "production" : void 0) !== "production" && n && !n4 && (console.warn(
    "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
  ), n4 = !0);
  const r = hhe(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return phe(r), r;
}
const r4 = (e) => {
  (mD ? "production" : void 0) !== "production" && typeof e != "function" && console.warn(
    "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
  );
  const t = typeof e == "function" ? ahe(e) : e, n = (r, o) => ghe(t, r, o);
  return Object.assign(n, t), n;
}, yhe = (e) => e ? r4(e) : r4, gD = '(function(){"use strict";const w="https://cdn.jsdelivr.net/pyodide/v0.27.2/full/pyodide.mjs",e=self;e.workerState={pyodide:null,pyodide_url:w,packages:[],state:{msg:"loading",loaded:!1,progress:0},micropip:null,worker:{},pyodideReady:!1,pyodideReadyPromise:null,debug:!1,interruptBuffer:null,receivepy:(r,t)=>{},receivepy_bytes:(r,t)=>{},handel_register:{},post_pyodide_ready:void 0},e.reset=async()=>{for(const r in e.list_workers())try{const t=await e.get_worker(r);t.worker&&t.worker.stop(),t.reject_promise?.("Worker reset")}catch{}e.workerState.pyodide&&e.interrupt(),e.workerState.pyodide=null,e.workerState.micropip=null,e.workerState.worker={},e.workerState.pyodideReady=!1;try{e.workerState.interruptBuffer=new Uint8Array(new SharedArrayBuffer(1)),e.workerState.interruptBuffer[0]=0}catch{}},e.initializePyodide=async()=>{if(!e.workerState.pyodide){console.log("initializePyodide with: Debug:",e.workerState.debug,"Pyodide URL:",e.workerState.pyodide_url,"Packages:",e.workerState.packages),console.debug("Loading Pyodide..."),e.workerState.state.msg="Loading Pyodide...",e.workerState.state.progress=0,await e.reset(),console.debug("Loading Pyodide module..."),e.workerState.state.msg="Loading Pyodide module...",e.workerState.state.progress=.1;const r=await import(e.workerState.pyodide_url);console.debug("Loading Pyodide instance..."),e.workerState.state.msg="Loading Pyodide instance...",e.workerState.state.progress=.2;const t=r.loadPyodide,o=e.workerState.pyodide_url.split("/").slice(0,-1).join("/");console.log(o),e.workerState.pyodide=await t({packages:["micropip"],indexURL:o}),e.workerState.interruptBuffer&&e.workerState.pyodide.setInterruptBuffer(e.workerState.interruptBuffer)}e.workerState.micropip||(console.debug("Importing micropip..."),e.workerState.state.msg="Importing micropip...",e.workerState.state.progress=.3,e.workerState.micropip=e.workerState.pyodide.pyimport("micropip")),console.debug("Pyodide ready. Installing funcnodes...");for(const r of e.workerState.packages)console.log("Installing package:",r),e.workerState.state.msg=`Installing package: ${r}`,await e.workerState.micropip.install(r);return e.workerState.state.msg="Installing funcnodes",e.workerState.state.progress=.8,await e.workerState.micropip.install("funcnodes"),e.workerState.state.msg="Installing funcnodes-worker",await e.workerState.micropip.install("funcnodes-worker"),e.workerState.state.msg="Installing funcnodes-pyodide",await e.workerState.micropip.install("funcnodes-pyodide"),e.workerState.state.msg="Installing funcnodes-react-flow",await e.workerState.micropip.install("funcnodes-react-flow"),e.workerState.state.msg="Importing funcnodes",console.debug("Importing funcnodes..."),await e.workerState.pyodide.runPythonAsync("import funcnodes_pyodide"),console.debug("Running post_pyodide_ready..."),await e.workerState.post_pyodide_ready?.(e.workerState),console.debug("Pyodide ready"),e.workerState.state.msg="ready",e.workerState.state.progress=.1,e.workerState.pyodideReady=!0,{pyodide:e.workerState.pyodide,micropip:e.workerState.micropip}},e.interrupt=()=>{e.workerState.interruptBuffer&&(e.workerState.interruptBuffer[0]=1)},e.list_workers=()=>Object.keys(e.workerState.worker),e.get_worker=async r=>{if(!r)throw new Error("Worker id is required");if(!e.workerState.worker[r])throw new Error(`Worker with id ${r} not found`);return await e.workerState.worker[r].make_promise,e.workerState.worker[r]},e.has_worker=r=>{if(!r)throw new Error("Worker id is required");return!!e.workerState.worker[r]},e.get_or_create_worker=async r=>{if(!r)throw new Error("Worker id is required");return e.workerState.worker[r]||(console.log("Creating worker with id",r),await e.initializeFuncNodesWorker(r)),e.get_worker(r)},e.initializeFuncNodesWorker=async r=>{try{if(!e.workerState.pyodideReadyPromise)throw new Error("Pyodide newer initialized");const{pyodide:t}=await e.workerState.pyodideReadyPromise;if(!e.has_worker(r)){e.workerState.worker[r]={worker:null,make_promise:void 0};const o=new Promise(async(i,a)=>{e.workerState.worker[r].reject_promise=a,console.debug(`Creating worker (${r})...`);const s=await t.runPythonAsync(`funcnodes_pyodide.new_worker(debug=${e.workerState.debug?1:0}, uuid="${r}")`);if(console.debug("Worker created:",s),typeof s.set_receiver=="function")s.set_receiver(self);else throw new Error("Worker does not expose a \'set_receiver\' method.");e.workerState.worker[r].worker=s,console.debug("Worker ready"),i(s)});e.workerState.worker[r].make_promise=o}return e.get_worker(r)}catch(t){throw console.error("Error during worker initialization:",t),t}},e.receivepy=(r,t)=>{try{let o={};if(typeof r=="string"?o.msg=r:o=r,o.msg===void 0)return;typeof o.msg!="string"&&(o.msg=JSON.stringify(o.msg)),t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const i=o.worker_id;if(!i)throw new Error(`Worker id not provided in receivepy(${JSON.stringify(o)})`);if(!e.workerState.worker[i])throw new Error(`Worker with id ${i} not found in receivepy(${JSON.stringify(o)})`);e.workerState.receivepy(r,i)}catch(o){console.error("Error during receivepy:",o);return}},e.receivepy_bytes=(r,t)=>{r=r.toJs();try{let o={};if(r instanceof Uint8Array?o.msg=r:o=r,o.msg===void 0)return;t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const i=o.worker_id;if(!i)throw new Error("Worker id not provided in receivepy_bytes");if(!e.workerState.worker[i])throw new Error(`Worker with id ${i} not found in receivepy_bytes`);e.workerState.receivepy_bytes(r,i)}catch(o){console.error("Error during receivepy_bytes:",o);return}},e.startInitialization=({debug:r=!1,receivepy:t,receivepy_bytes:o,pyodide_url:i,post_pyodide_ready:a,packages:s})=>(e.workerState.debug=r,e.workerState.pyodide_url=i||w,e.workerState.packages=s,e.workerState.receivepy=t,e.workerState.receivepy_bytes=o,e.workerState.pyodideReadyPromise=null,e.workerState.post_pyodide_ready=a,e.workerState),e.register_cmd_message=(r,t)=>{if(e.workerState.handel_register[r])throw new Error(`Command ${r} already registered`);e.workerState.handel_register[r]=t},e.register_cmd_message("ping",async r=>"pong"),e.register_cmd_message("init",async r=>{if(e.workerState.pyodideReadyPromise)throw new Error("Pyodide is already initialized");r.data&&(r.data.pyodide_url&&(e.workerState.pyodide_url=r.data.pyodide_url),r.data.packages&&(e.workerState.packages=r.data.packages),r.data.debug&&(e.workerState.debug=r.data.debug)),e.workerState.pyodideReadyPromise=e.initializePyodide()}),e.register_cmd_message("_eval",async r=>{try{const t=await e.workerState.pyodide?.runPythonAsync(r.msg||"print(\'No code provided\')");return console.log("Eval result:",t),t}catch(t){console.error("Error during _eval:",t)}}),e.register_cmd_message("state",async r=>({state:{...e.workerState.state,loaded:e.workerState.pyodideReady}})),e.register_cmd_message("worker:state",async r=>({state:{loaded:!!(await e.get_or_create_worker(r.worker_id)).worker}})),e.register_cmd_message("worker:stop",async r=>{if(!e.has_worker(r.worker_id))return;const t=await e.get_or_create_worker(r.worker_id);return t.worker&&(t.worker.stop(),t.worker=null,t.reject_promise?.("Worker stopped")),delete e.workerState.worker[r.worker_id],{state:{loaded:!1}}}),e.register_cmd_message("worker:send",async r=>{const t=await e.get_or_create_worker(r.worker_id);if(!t.worker)throw new Error("Worker is not initialized");if(typeof t.worker.receivejs!="function")throw new Error(`Worker does not support receivejs: ${typeof t.worker.receivejs}`);t.worker.receivejs(r.msg)}),e.handleMessage=async r=>{const t={original:r};r.id&&(t.id=r.id),r.toJs===void 0&&(r.toJs=!0);try{if(r.cmd){const o=r;if(e.workerState.handel_register[o.cmd])t.result=await e.workerState.handel_register[o.cmd](o);else throw new Error("Unknown command: "+o.cmd)}else throw new Error("Unknown message format: "+JSON.stringify(r))}catch(o){t.error=o.message}return t},e.read_url_params=()=>{const r=new URLSearchParams(self.location.search),t=r.get("debug")?.toLowerCase()==="true",o=r.get("pyodide_url")||void 0,i=r.get("packages")?.split(",")||[];return{debug:t,pyodide_url:o,packages:i}};const n=e;n.general_initalization=r=>{const t=n.read_url_params();n.startInitialization({...r,...t})};const k=n,p=n;p.init_dedicated_worker=r=>{const t=e;t.onmessage=async i=>{const a=i.data,s=await t.handleMessage(a);t.postMessage(s)};const o={...r,receivepy:(i,a)=>{t.postMessage({cmd:"receive",msg:i,worker_id:a})},receivepy_bytes(i,a){t.postMessage({cmd:"receive_bytes",msg:i,worker_id:a})}};t.general_initalization(o)},k.init_shared_worker=r=>{const t=e;t.connectedPorts=[],t.onconnect=i=>{const a=i.ports[0];t.connectedPorts.push(a),a.start(),console.debug("Port connected in shared worker"),a.onmessage=async s=>{const d=s.data,g=await t.handleMessage(d);a.postMessage(g)}};const o={...r,receivepy:(i,a)=>{t.connectedPorts.forEach(s=>{s.postMessage({cmd:"receive",msg:i,worker_id:a})})},receivepy_bytes(i,a){t.connectedPorts.forEach(s=>{s.postMessage({cmd:"receive_bytes",msg:i,worker_id:a})})}};t.general_initalization(o)};const y=r=>{n.init_dedicated_worker(r)};var l=`from __future__ import annotations\nimport funcnodes_core as fn\n\nfn.node.ALLOW_REGISTERED_NODES_OVERRIDE = True\n\n\ndef eval_node_code(code: str):\n    ns = {}  # dedicated namespace acting as globals\n    exec(code, ns)\n    _node = [\n        cls\n        for name, cls in ns.items()\n        if isinstance(cls, type) and issubclass(cls, fn.Node)\n    ][-1]\n    return _node\n`;const c=n;c.nodebuilder_post_pyodide_ready=async r=>{r.pyodide.runPythonAsync(l)},c.register_cmd_message("worker:evalnode",async r=>{const t=r.msg,o=t.match(/#\\s*requires\\s*(.*)/);if(o){const s=o[1].split(" ").map(d=>d.trim()).filter(d=>d.length>0);for(const d of s)await c.workerState.micropip.install(d)}const i=await c.workerState.pyodide?.runPythonAsync(`eval_node_code(${JSON.stringify(t)})`);if(!i)return;const a=await c.get_or_create_worker(r.worker_id);a.worker.clear(),a.worker.nodespace.lib.add_node(i,"demo"),a.worker.add_node(i.node_id)}),y({post_pyodide_ready:c.nodebuilder_post_pyodide_ready})})();\n', o4 = typeof self < "u" && self.Blob && new Blob([gD], { type: "text/javascript;charset=utf-8" });
function vhe(e) {
  let t;
  try {
    if (t = o4 && (self.URL || self.webkitURL).createObjectURL(o4), !t) throw "";
    const n = new Worker(t, {
      name: e?.name
    });
    return n.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(t);
    }), n;
  } catch {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(gD),
      {
        name: e?.name
      }
    );
  } finally {
    t && (self.URL || self.webkitURL).revokeObjectURL(t);
  }
}
const bhe = '(function(){"use strict";const w="https://cdn.jsdelivr.net/pyodide/v0.27.2/full/pyodide.mjs",e=self;e.workerState={pyodide:null,pyodide_url:w,packages:[],state:{msg:"loading",loaded:!1,progress:0},micropip:null,worker:{},pyodideReady:!1,pyodideReadyPromise:null,debug:!1,interruptBuffer:null,receivepy:(r,t)=>{},receivepy_bytes:(r,t)=>{},handel_register:{},post_pyodide_ready:void 0},e.reset=async()=>{for(const r in e.list_workers())try{const t=await e.get_worker(r);t.worker&&t.worker.stop(),t.reject_promise?.("Worker reset")}catch{}e.workerState.pyodide&&e.interrupt(),e.workerState.pyodide=null,e.workerState.micropip=null,e.workerState.worker={},e.workerState.pyodideReady=!1;try{e.workerState.interruptBuffer=new Uint8Array(new SharedArrayBuffer(1)),e.workerState.interruptBuffer[0]=0}catch{}},e.initializePyodide=async()=>{if(!e.workerState.pyodide){console.log("initializePyodide with: Debug:",e.workerState.debug,"Pyodide URL:",e.workerState.pyodide_url,"Packages:",e.workerState.packages),console.debug("Loading Pyodide..."),e.workerState.state.msg="Loading Pyodide...",e.workerState.state.progress=0,await e.reset(),console.debug("Loading Pyodide module..."),e.workerState.state.msg="Loading Pyodide module...",e.workerState.state.progress=.1;const r=await import(e.workerState.pyodide_url);console.debug("Loading Pyodide instance..."),e.workerState.state.msg="Loading Pyodide instance...",e.workerState.state.progress=.2;const t=r.loadPyodide,o=e.workerState.pyodide_url.split("/").slice(0,-1).join("/");console.log(o),e.workerState.pyodide=await t({packages:["micropip"],indexURL:o}),e.workerState.interruptBuffer&&e.workerState.pyodide.setInterruptBuffer(e.workerState.interruptBuffer)}e.workerState.micropip||(console.debug("Importing micropip..."),e.workerState.state.msg="Importing micropip...",e.workerState.state.progress=.3,e.workerState.micropip=e.workerState.pyodide.pyimport("micropip")),console.debug("Pyodide ready. Installing funcnodes...");for(const r of e.workerState.packages)console.log("Installing package:",r),e.workerState.state.msg=`Installing package: ${r}`,await e.workerState.micropip.install(r);return e.workerState.state.msg="Installing funcnodes",e.workerState.state.progress=.8,await e.workerState.micropip.install("funcnodes"),e.workerState.state.msg="Installing funcnodes-worker",await e.workerState.micropip.install("funcnodes-worker"),e.workerState.state.msg="Installing funcnodes-pyodide",await e.workerState.micropip.install("funcnodes-pyodide"),e.workerState.state.msg="Installing funcnodes-react-flow",await e.workerState.micropip.install("funcnodes-react-flow"),e.workerState.state.msg="Importing funcnodes",console.debug("Importing funcnodes..."),await e.workerState.pyodide.runPythonAsync("import funcnodes_pyodide"),console.debug("Running post_pyodide_ready..."),await e.workerState.post_pyodide_ready?.(e.workerState),console.debug("Pyodide ready"),e.workerState.state.msg="ready",e.workerState.state.progress=.1,e.workerState.pyodideReady=!0,{pyodide:e.workerState.pyodide,micropip:e.workerState.micropip}},e.interrupt=()=>{e.workerState.interruptBuffer&&(e.workerState.interruptBuffer[0]=1)},e.list_workers=()=>Object.keys(e.workerState.worker),e.get_worker=async r=>{if(!r)throw new Error("Worker id is required");if(!e.workerState.worker[r])throw new Error(`Worker with id ${r} not found`);return await e.workerState.worker[r].make_promise,e.workerState.worker[r]},e.has_worker=r=>{if(!r)throw new Error("Worker id is required");return!!e.workerState.worker[r]},e.get_or_create_worker=async r=>{if(!r)throw new Error("Worker id is required");return e.workerState.worker[r]||(console.log("Creating worker with id",r),await e.initializeFuncNodesWorker(r)),e.get_worker(r)},e.initializeFuncNodesWorker=async r=>{try{if(!e.workerState.pyodideReadyPromise)throw new Error("Pyodide newer initialized");const{pyodide:t}=await e.workerState.pyodideReadyPromise;if(!e.has_worker(r)){e.workerState.worker[r]={worker:null,make_promise:void 0};const o=new Promise(async(i,a)=>{e.workerState.worker[r].reject_promise=a,console.debug(`Creating worker (${r})...`);const s=await t.runPythonAsync(`funcnodes_pyodide.new_worker(debug=${e.workerState.debug?1:0}, uuid="${r}")`);if(console.debug("Worker created:",s),typeof s.set_receiver=="function")s.set_receiver(self);else throw new Error("Worker does not expose a \'set_receiver\' method.");e.workerState.worker[r].worker=s,console.debug("Worker ready"),i(s)});e.workerState.worker[r].make_promise=o}return e.get_worker(r)}catch(t){throw console.error("Error during worker initialization:",t),t}},e.receivepy=(r,t)=>{try{let o={};if(typeof r=="string"?o.msg=r:o=r,o.msg===void 0)return;typeof o.msg!="string"&&(o.msg=JSON.stringify(o.msg)),t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const i=o.worker_id;if(!i)throw new Error(`Worker id not provided in receivepy(${JSON.stringify(o)})`);if(!e.workerState.worker[i])throw new Error(`Worker with id ${i} not found in receivepy(${JSON.stringify(o)})`);e.workerState.receivepy(r,i)}catch(o){console.error("Error during receivepy:",o);return}},e.receivepy_bytes=(r,t)=>{r=r.toJs();try{let o={};if(r instanceof Uint8Array?o.msg=r:o=r,o.msg===void 0)return;t!==void 0&&(typeof t=="string"?o.worker_id||(o.worker_id=t):o={...t,...o});const i=o.worker_id;if(!i)throw new Error("Worker id not provided in receivepy_bytes");if(!e.workerState.worker[i])throw new Error(`Worker with id ${i} not found in receivepy_bytes`);e.workerState.receivepy_bytes(r,i)}catch(o){console.error("Error during receivepy_bytes:",o);return}},e.startInitialization=({debug:r=!1,receivepy:t,receivepy_bytes:o,pyodide_url:i,post_pyodide_ready:a,packages:s})=>(e.workerState.debug=r,e.workerState.pyodide_url=i||w,e.workerState.packages=s,e.workerState.receivepy=t,e.workerState.receivepy_bytes=o,e.workerState.pyodideReadyPromise=null,e.workerState.post_pyodide_ready=a,e.workerState),e.register_cmd_message=(r,t)=>{if(e.workerState.handel_register[r])throw new Error(`Command ${r} already registered`);e.workerState.handel_register[r]=t},e.register_cmd_message("ping",async r=>"pong"),e.register_cmd_message("init",async r=>{if(e.workerState.pyodideReadyPromise)throw new Error("Pyodide is already initialized");r.data&&(r.data.pyodide_url&&(e.workerState.pyodide_url=r.data.pyodide_url),r.data.packages&&(e.workerState.packages=r.data.packages),r.data.debug&&(e.workerState.debug=r.data.debug)),e.workerState.pyodideReadyPromise=e.initializePyodide()}),e.register_cmd_message("_eval",async r=>{try{const t=await e.workerState.pyodide?.runPythonAsync(r.msg||"print(\'No code provided\')");return console.log("Eval result:",t),t}catch(t){console.error("Error during _eval:",t)}}),e.register_cmd_message("state",async r=>({state:{...e.workerState.state,loaded:e.workerState.pyodideReady}})),e.register_cmd_message("worker:state",async r=>({state:{loaded:!!(await e.get_or_create_worker(r.worker_id)).worker}})),e.register_cmd_message("worker:stop",async r=>{if(!e.has_worker(r.worker_id))return;const t=await e.get_or_create_worker(r.worker_id);return t.worker&&(t.worker.stop(),t.worker=null,t.reject_promise?.("Worker stopped")),delete e.workerState.worker[r.worker_id],{state:{loaded:!1}}}),e.register_cmd_message("worker:send",async r=>{const t=await e.get_or_create_worker(r.worker_id);if(!t.worker)throw new Error("Worker is not initialized");if(typeof t.worker.receivejs!="function")throw new Error(`Worker does not support receivejs: ${typeof t.worker.receivejs}`);t.worker.receivejs(r.msg)}),e.handleMessage=async r=>{const t={original:r};r.id&&(t.id=r.id),r.toJs===void 0&&(r.toJs=!0);try{if(r.cmd){const o=r;if(e.workerState.handel_register[o.cmd])t.result=await e.workerState.handel_register[o.cmd](o);else throw new Error("Unknown command: "+o.cmd)}else throw new Error("Unknown message format: "+JSON.stringify(r))}catch(o){t.error=o.message}return t},e.read_url_params=()=>{const r=new URLSearchParams(self.location.search),t=r.get("debug")?.toLowerCase()==="true",o=r.get("pyodide_url")||void 0,i=r.get("packages")?.split(",")||[];return{debug:t,pyodide_url:o,packages:i}};const n=e;n.general_initalization=r=>{const t=n.read_url_params();n.startInitialization({...r,...t})};const k=n,p=n;p.init_dedicated_worker=r=>{const t=e;t.onmessage=async i=>{const a=i.data,s=await t.handleMessage(a);t.postMessage(s)};const o={...r,receivepy:(i,a)=>{t.postMessage({cmd:"receive",msg:i,worker_id:a})},receivepy_bytes(i,a){t.postMessage({cmd:"receive_bytes",msg:i,worker_id:a})}};t.general_initalization(o)},k.init_shared_worker=r=>{const t=e;t.connectedPorts=[],t.onconnect=i=>{const a=i.ports[0];t.connectedPorts.push(a),a.start(),console.debug("Port connected in shared worker"),a.onmessage=async s=>{const d=s.data,g=await t.handleMessage(d);a.postMessage(g)}};const o={...r,receivepy:(i,a)=>{t.connectedPorts.forEach(s=>{s.postMessage({cmd:"receive",msg:i,worker_id:a})})},receivepy_bytes(i,a){t.connectedPorts.forEach(s=>{s.postMessage({cmd:"receive_bytes",msg:i,worker_id:a})})}};t.general_initalization(o)};const y=r=>{n.init_shared_worker(r)};var l=`from __future__ import annotations\nimport funcnodes_core as fn\n\nfn.node.ALLOW_REGISTERED_NODES_OVERRIDE = True\n\n\ndef eval_node_code(code: str):\n    ns = {}  # dedicated namespace acting as globals\n    exec(code, ns)\n    _node = [\n        cls\n        for name, cls in ns.items()\n        if isinstance(cls, type) and issubclass(cls, fn.Node)\n    ][-1]\n    return _node\n`;const c=n;c.nodebuilder_post_pyodide_ready=async r=>{r.pyodide.runPythonAsync(l)},c.register_cmd_message("worker:evalnode",async r=>{const t=r.msg,o=t.match(/#\\s*requires\\s*(.*)/);if(o){const s=o[1].split(" ").map(d=>d.trim()).filter(d=>d.length>0);for(const d of s)await c.workerState.micropip.install(d)}const i=await c.workerState.pyodide?.runPythonAsync(`eval_node_code(${JSON.stringify(t)})`);if(!i)return;const a=await c.get_or_create_worker(r.worker_id);a.worker.clear(),a.worker.nodespace.lib.add_node(i,"demo"),a.worker.add_node(i.node_id)}),y({post_pyodide_ready:c.nodebuilder_post_pyodide_ready})})();\n';
function whe(e) {
  return new SharedWorker(
    "data:text/javascript;charset=utf-8," + encodeURIComponent(bhe),
    {
      name: e?.name
    }
  );
}
function xhe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function i4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function a4(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? i4(Object(n), !0).forEach(function(r) {
      xhe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : i4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function She(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function _he(e, t) {
  if (e == null) return {};
  var n = She(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function khe(e, t) {
  return Ehe(e) || Che(e, t) || Ohe(e, t) || Ahe();
}
function Ehe(e) {
  if (Array.isArray(e)) return e;
}
function Che(e, t) {
  if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(e)))) {
    var n = [], r = !0, o = !1, i = void 0;
    try {
      for (var s = e[Symbol.iterator](), u; !(r = (u = s.next()).done) && (n.push(u.value), !(t && n.length === t)); r = !0)
        ;
    } catch (c) {
      o = !0, i = c;
    } finally {
      try {
        !r && s.return != null && s.return();
      } finally {
        if (o) throw i;
      }
    }
    return n;
  }
}
function Ohe(e, t) {
  if (e) {
    if (typeof e == "string") return s4(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return s4(e, t);
  }
}
function s4(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function Ahe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Nhe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function l4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function u4(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? l4(Object(n), !0).forEach(function(r) {
      Nhe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : l4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Mhe() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return function(r) {
    return t.reduceRight(function(o, i) {
      return i(o);
    }, r);
  };
}
function pd(e) {
  return function t() {
    for (var n = this, r = arguments.length, o = new Array(r), i = 0; i < r; i++)
      o[i] = arguments[i];
    return o.length >= e.length ? e.apply(this, o) : function() {
      for (var s = arguments.length, u = new Array(s), c = 0; c < s; c++)
        u[c] = arguments[c];
      return t.apply(n, [].concat(o, u));
    };
  };
}
function Nm(e) {
  return {}.toString.call(e).includes("Object");
}
function Rhe(e) {
  return !Object.keys(e).length;
}
function Jd(e) {
  return typeof e == "function";
}
function jhe(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function zhe(e, t) {
  return Nm(t) || Qa("changeType"), Object.keys(t).some(function(n) {
    return !jhe(e, n);
  }) && Qa("changeField"), t;
}
function The(e) {
  Jd(e) || Qa("selectorType");
}
function Dhe(e) {
  Jd(e) || Nm(e) || Qa("handlerType"), Nm(e) && Object.values(e).some(function(t) {
    return !Jd(t);
  }) && Qa("handlersType");
}
function Phe(e) {
  e || Qa("initialIsRequired"), Nm(e) || Qa("initialType"), Rhe(e) && Qa("initialContent");
}
function Lhe(e, t) {
  throw new Error(e[t] || e.default);
}
var Ihe = {
  initialIsRequired: "initial state is required",
  initialType: "initial state should be an object",
  initialContent: "initial state shouldn't be an empty object",
  handlerType: "handler should be an object or a function",
  handlersType: "all handlers should be a functions",
  selectorType: "selector should be a function",
  changeType: "provided value of changes should be an object",
  changeField: 'it seams you want to change a field in the state which is not specified in the "initial" state',
  default: "an unknown error accured in `state-local` package"
}, Qa = pd(Lhe)(Ihe), mh = {
  changes: zhe,
  selector: The,
  handler: Dhe,
  initial: Phe
};
function Vhe(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  mh.initial(e), mh.handler(t);
  var n = {
    current: e
  }, r = pd(Uhe)(n, t), o = pd(Fhe)(n), i = pd(mh.changes)(e), s = pd(Bhe)(n);
  function u() {
    var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function(p) {
      return p;
    };
    return mh.selector(d), d(n.current);
  }
  function c(d) {
    Mhe(r, o, i, s)(d);
  }
  return [u, c];
}
function Bhe(e, t) {
  return Jd(t) ? t(e.current) : t;
}
function Fhe(e, t) {
  return e.current = u4(u4({}, e.current), t), t;
}
function Uhe(e, t, n) {
  return Jd(t) ? t(e.current) : Object.keys(n).forEach(function(r) {
    var o;
    return (o = t[r]) === null || o === void 0 ? void 0 : o.call(t, e.current[r]);
  }), n;
}
var Hhe = {
  create: Vhe
}, $he = {
  paths: {
    vs: "https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs"
  }
};
function Yhe(e) {
  return function t() {
    for (var n = this, r = arguments.length, o = new Array(r), i = 0; i < r; i++)
      o[i] = arguments[i];
    return o.length >= e.length ? e.apply(this, o) : function() {
      for (var s = arguments.length, u = new Array(s), c = 0; c < s; c++)
        u[c] = arguments[c];
      return t.apply(n, [].concat(o, u));
    };
  };
}
function qhe(e) {
  return {}.toString.call(e).includes("Object");
}
function Xhe(e) {
  return e || c4("configIsRequired"), qhe(e) || c4("configType"), e.urls ? (Whe(), {
    paths: {
      vs: e.urls.monacoBase
    }
  }) : e;
}
function Whe() {
  console.warn(yD.deprecation);
}
function Ghe(e, t) {
  throw new Error(e[t] || e.default);
}
var yD = {
  configIsRequired: "the configuration object is required",
  configType: "the configuration object should be an object",
  default: "an unknown error accured in `@monaco-editor/loader` package",
  deprecation: `Deprecation warning!
    You are using deprecated way of configuration.

    Instead of using
      monaco.config({ urls: { monacoBase: '...' } })
    use
      monaco.config({ paths: { vs: '...' } })

    For more please check the link https://github.com/suren-atoyan/monaco-loader#config
  `
}, c4 = Yhe(Ghe)(yD), Zhe = {
  config: Xhe
}, Khe = function() {
  for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
    n[r] = arguments[r];
  return function(o) {
    return n.reduceRight(function(i, s) {
      return s(i);
    }, o);
  };
};
function vD(e, t) {
  return Object.keys(t).forEach(function(n) {
    t[n] instanceof Object && e[n] && Object.assign(t[n], vD(e[n], t[n]));
  }), a4(a4({}, e), t);
}
var Qhe = {
  type: "cancelation",
  msg: "operation is manually canceled"
};
function hw(e) {
  var t = !1, n = new Promise(function(r, o) {
    e.then(function(i) {
      return t ? o(Qhe) : r(i);
    }), e.catch(o);
  });
  return n.cancel = function() {
    return t = !0;
  }, n;
}
var Jhe = Hhe.create({
  config: $he,
  isInitialized: !1,
  resolve: null,
  reject: null,
  monaco: null
}), bD = khe(Jhe, 2), Nf = bD[0], $g = bD[1];
function eme(e) {
  var t = Zhe.config(e), n = t.monaco, r = _he(t, ["monaco"]);
  $g(function(o) {
    return {
      config: vD(o.config, r),
      monaco: n
    };
  });
}
function tme() {
  var e = Nf(function(t) {
    var n = t.monaco, r = t.isInitialized, o = t.resolve;
    return {
      monaco: n,
      isInitialized: r,
      resolve: o
    };
  });
  if (!e.isInitialized) {
    if ($g({
      isInitialized: !0
    }), e.monaco)
      return e.resolve(e.monaco), hw(mw);
    if (window.monaco && window.monaco.editor)
      return wD(window.monaco), e.resolve(window.monaco), hw(mw);
    Khe(nme, ome)(ime);
  }
  return hw(mw);
}
function nme(e) {
  return document.body.appendChild(e);
}
function rme(e) {
  var t = document.createElement("script");
  return e && (t.src = e), t;
}
function ome(e) {
  var t = Nf(function(r) {
    var o = r.config, i = r.reject;
    return {
      config: o,
      reject: i
    };
  }), n = rme("".concat(t.config.paths.vs, "/loader.js"));
  return n.onload = function() {
    return e();
  }, n.onerror = t.reject, n;
}
function ime() {
  var e = Nf(function(n) {
    var r = n.config, o = n.resolve, i = n.reject;
    return {
      config: r,
      resolve: o,
      reject: i
    };
  }), t = window.require;
  t.config(e.config), t(["vs/editor/editor.main"], function(n) {
    wD(n), e.resolve(n);
  }, function(n) {
    e.reject(n);
  });
}
function wD(e) {
  Nf().monaco || $g({
    monaco: e
  });
}
function ame() {
  return Nf(function(e) {
    var t = e.monaco;
    return t;
  });
}
var mw = new Promise(function(e, t) {
  return $g({
    resolve: e,
    reject: t
  });
}), xD = {
  config: eme,
  init: tme,
  __getMonacoInstance: ame
}, sme = { wrapper: { display: "flex", position: "relative", textAlign: "initial" }, fullWidth: { width: "100%" }, hide: { display: "none" } }, gw = sme, lme = { container: { display: "flex", height: "100%", width: "100%", justifyContent: "center", alignItems: "center" } }, ume = lme;
function cme({ children: e }) {
  return Qe.createElement("div", { style: ume.container }, e);
}
var dme = cme, fme = dme;
function pme({ width: e, height: t, isEditorReady: n, loading: r, _ref: o, className: i, wrapperProps: s }) {
  return Qe.createElement("section", { style: { ...gw.wrapper, width: e, height: t }, ...s }, !n && Qe.createElement(fme, null, r), Qe.createElement("div", { ref: o, style: { ...gw.fullWidth, ...!n && gw.hide }, className: i }));
}
var hme = pme, SD = S.memo(hme);
function mme(e) {
  S.useEffect(e, []);
}
var _D = mme;
function gme(e, t, n = !0) {
  let r = S.useRef(!0);
  S.useEffect(r.current || !n ? () => {
    r.current = !1;
  } : e, t);
}
var zr = gme;
function _d() {
}
function fu(e, t, n, r) {
  return yme(e, r) || vme(e, t, n, r);
}
function yme(e, t) {
  return e.editor.getModel(kD(e, t));
}
function vme(e, t, n, r) {
  return e.editor.createModel(t, n, r ? kD(e, r) : void 0);
}
function kD(e, t) {
  return e.Uri.parse(t);
}
function bme({ original: e, modified: t, language: n, originalLanguage: r, modifiedLanguage: o, originalModelPath: i, modifiedModelPath: s, keepCurrentOriginalModel: u = !1, keepCurrentModifiedModel: c = !1, theme: d = "light", loading: p = "Loading...", options: h = {}, height: g = "100%", width: y = "100%", className: b, wrapperProps: v = {}, beforeMount: x = _d, onMount: _ = _d }) {
  let [O, C] = S.useState(!1), [N, R] = S.useState(!0), z = S.useRef(null), j = S.useRef(null), I = S.useRef(null), $ = S.useRef(_), A = S.useRef(x), V = S.useRef(!1);
  _D(() => {
    let F = xD.init();
    return F.then((P) => (j.current = P) && R(!1)).catch((P) => P?.type !== "cancelation" && console.error("Monaco initialization: error:", P)), () => z.current ? D() : F.cancel();
  }), zr(() => {
    if (z.current && j.current) {
      let F = z.current.getOriginalEditor(), P = fu(j.current, e || "", r || n || "text", i || "");
      P !== F.getModel() && F.setModel(P);
    }
  }, [i], O), zr(() => {
    if (z.current && j.current) {
      let F = z.current.getModifiedEditor(), P = fu(j.current, t || "", o || n || "text", s || "");
      P !== F.getModel() && F.setModel(P);
    }
  }, [s], O), zr(() => {
    let F = z.current.getModifiedEditor();
    F.getOption(j.current.editor.EditorOption.readOnly) ? F.setValue(t || "") : t !== F.getValue() && (F.executeEdits("", [{ range: F.getModel().getFullModelRange(), text: t || "", forceMoveMarkers: !0 }]), F.pushUndoStop());
  }, [t], O), zr(() => {
    z.current?.getModel()?.original.setValue(e || "");
  }, [e], O), zr(() => {
    let { original: F, modified: P } = z.current.getModel();
    j.current.editor.setModelLanguage(F, r || n || "text"), j.current.editor.setModelLanguage(P, o || n || "text");
  }, [n, r, o], O), zr(() => {
    j.current?.editor.setTheme(d);
  }, [d], O), zr(() => {
    z.current?.updateOptions(h);
  }, [h], O);
  let U = S.useCallback(() => {
    if (!j.current) return;
    A.current(j.current);
    let F = fu(j.current, e || "", r || n || "text", i || ""), P = fu(j.current, t || "", o || n || "text", s || "");
    z.current?.setModel({ original: F, modified: P });
  }, [n, t, o, e, r, i, s]), W = S.useCallback(() => {
    !V.current && I.current && (z.current = j.current.editor.createDiffEditor(I.current, { automaticLayout: !0, ...h }), U(), j.current?.editor.setTheme(d), C(!0), V.current = !0);
  }, [h, d, U]);
  S.useEffect(() => {
    O && $.current(z.current, j.current);
  }, [O]), S.useEffect(() => {
    !N && !O && W();
  }, [N, O, W]);
  function D() {
    let F = z.current?.getModel();
    u || F?.original?.dispose(), c || F?.modified?.dispose(), z.current?.dispose();
  }
  return Qe.createElement(SD, { width: y, height: g, isEditorReady: O, loading: p, _ref: I, className: b, wrapperProps: v });
}
var wme = bme;
S.memo(wme);
function xme(e) {
  let t = S.useRef();
  return S.useEffect(() => {
    t.current = e;
  }, [e]), t.current;
}
var Sme = xme, gh = /* @__PURE__ */ new Map();
function _me({ defaultValue: e, defaultLanguage: t, defaultPath: n, value: r, language: o, path: i, theme: s = "light", line: u, loading: c = "Loading...", options: d = {}, overrideServices: p = {}, saveViewState: h = !0, keepCurrentModel: g = !1, width: y = "100%", height: b = "100%", className: v, wrapperProps: x = {}, beforeMount: _ = _d, onMount: O = _d, onChange: C, onValidate: N = _d }) {
  let [R, z] = S.useState(!1), [j, I] = S.useState(!0), $ = S.useRef(null), A = S.useRef(null), V = S.useRef(null), U = S.useRef(O), W = S.useRef(_), D = S.useRef(), F = S.useRef(r), P = Sme(i), H = S.useRef(!1), Y = S.useRef(!1);
  _D(() => {
    let X = xD.init();
    return X.then((K) => ($.current = K) && I(!1)).catch((K) => K?.type !== "cancelation" && console.error("Monaco initialization: error:", K)), () => A.current ? M() : X.cancel();
  }), zr(() => {
    let X = fu($.current, e || r || "", t || o || "", i || n || "");
    X !== A.current?.getModel() && (h && gh.set(P, A.current?.saveViewState()), A.current?.setModel(X), h && A.current?.restoreViewState(gh.get(i)));
  }, [i], R), zr(() => {
    A.current?.updateOptions(d);
  }, [d], R), zr(() => {
    !A.current || r === void 0 || (A.current.getOption($.current.editor.EditorOption.readOnly) ? A.current.setValue(r) : r !== A.current.getValue() && (Y.current = !0, A.current.executeEdits("", [{ range: A.current.getModel().getFullModelRange(), text: r, forceMoveMarkers: !0 }]), A.current.pushUndoStop(), Y.current = !1));
  }, [r], R), zr(() => {
    let X = A.current?.getModel();
    X && o && $.current?.editor.setModelLanguage(X, o);
  }, [o], R), zr(() => {
    u !== void 0 && A.current?.revealLine(u);
  }, [u], R), zr(() => {
    $.current?.editor.setTheme(s);
  }, [s], R);
  let q = S.useCallback(() => {
    if (!(!V.current || !$.current) && !H.current) {
      W.current($.current);
      let X = i || n, K = fu($.current, r || e || "", t || o || "", X || "");
      A.current = $.current?.editor.create(V.current, { model: K, automaticLayout: !0, ...d }, p), h && A.current.restoreViewState(gh.get(X)), $.current.editor.setTheme(s), u !== void 0 && A.current.revealLine(u), z(!0), H.current = !0;
    }
  }, [e, t, n, r, o, i, d, p, h, s, u]);
  S.useEffect(() => {
    R && U.current(A.current, $.current);
  }, [R]), S.useEffect(() => {
    !j && !R && q();
  }, [j, R, q]), F.current = r, S.useEffect(() => {
    R && C && (D.current?.dispose(), D.current = A.current?.onDidChangeModelContent((X) => {
      Y.current || C(A.current.getValue(), X);
    }));
  }, [R, C]), S.useEffect(() => {
    if (R) {
      let X = $.current.editor.onDidChangeMarkers((K) => {
        let L = A.current.getModel()?.uri;
        if (L && K.find((ee) => ee.path === L.path)) {
          let ee = $.current.editor.getModelMarkers({ resource: L });
          N?.(ee);
        }
      });
      return () => {
        X?.dispose();
      };
    }
    return () => {
    };
  }, [R, N]);
  function M() {
    D.current?.dispose(), g ? h && gh.set(i, A.current.saveViewState()) : A.current.getModel()?.dispose(), A.current.dispose();
  }
  return Qe.createElement(SD, { width: y, height: b, isEditorReady: R, loading: c, _ref: V, className: v, wrapperProps: x });
}
var kme = _me, Eme = S.memo(kme);
function kd() {
  return kd = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, kd.apply(null, arguments);
}
var Za = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof jw < "u" ? jw : typeof self < "u" ? self : {};
function Mf(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var d4, f4 = {
  exports: {}
};
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
var yw, p4, h4, Cme = (d4 || (d4 = 1, yw = f4, function() {
  var e = {}.hasOwnProperty;
  function t() {
    for (var n = [], r = 0; r < arguments.length; r++) {
      var o = arguments[r];
      if (o) {
        var i = typeof o;
        if (i === "string" || i === "number") n.push(o);
        else if (Array.isArray(o)) {
          if (o.length) {
            var s = t.apply(null, o);
            s && n.push(s);
          }
        } else if (i === "object") if (o.toString === Object.prototype.toString) for (var u in o) e.call(o, u) && o[u] && n.push(u);
        else n.push(o.toString());
      }
    }
    return n.join(" ");
  }
  yw.exports ? (t.default = t, yw.exports = t) : window.classNames = t;
}()), f4.exports), tS = Mf(Cme), m4, Eo = Mf(function() {
  if (h4) return p4;
  h4 = 1;
  var e = NaN, t = "[object Symbol]", n = /^\s+|\s+$/g, r = /^[-+]0x[0-9a-f]+$/i, o = /^0b[01]+$/i, i = /^0o[0-7]+$/i, s = parseInt, u = Object.prototype.toString;
  function c(p) {
    var h = typeof p;
    return !!p && (h == "object" || h == "function");
  }
  function d(p) {
    if (typeof p == "number") return p;
    if (function(y) {
      return typeof y == "symbol" || /* @__PURE__ */ function(b) {
        return !!b && typeof b == "object";
      }(y) && u.call(y) == t;
    }(p)) return e;
    if (c(p)) {
      var h = typeof p.valueOf == "function" ? p.valueOf() : p;
      p = c(h) ? h + "" : h;
    }
    if (typeof p != "string") return p === 0 ? p : +p;
    p = p.replace(n, "");
    var g = o.test(p);
    return g || i.test(p) ? s(p.slice(2), g ? 2 : 8) : r.test(p) ? e : +p;
  }
  return p4 = function(p, h, g) {
    return g === void 0 && (g = h, h = void 0), g !== void 0 && (g = (g = d(g)) == g ? g : 0), h !== void 0 && (h = (h = d(h)) == h ? h : 0), function(y, b, v) {
      return y == y && (v !== void 0 && (y = y <= v ? y : v), b !== void 0 && (y = y >= b ? y : b)), y;
    }(d(p), h, g);
  };
}()), vw = {
  exports: {}
}, Ome = (m4 || (m4 = 1, function(e, t) {
  var n = "__lodash_hash_undefined__", r = 1, o = 2, i = 9007199254740991, s = "[object Arguments]", u = "[object Array]", c = "[object AsyncFunction]", d = "[object Boolean]", p = "[object Date]", h = "[object Error]", g = "[object Function]", y = "[object GeneratorFunction]", b = "[object Map]", v = "[object Number]", x = "[object Null]", _ = "[object Object]", O = "[object Promise]", C = "[object Proxy]", N = "[object RegExp]", R = "[object Set]", z = "[object String]", j = "[object Symbol]", I = "[object Undefined]", $ = "[object WeakMap]", A = "[object ArrayBuffer]", V = "[object DataView]", U = /^\[object .+?Constructor\]$/, W = /^(?:0|[1-9]\d*)$/, D = {};
  D["[object Float32Array]"] = D["[object Float64Array]"] = D["[object Int8Array]"] = D["[object Int16Array]"] = D["[object Int32Array]"] = D["[object Uint8Array]"] = D["[object Uint8ClampedArray]"] = D["[object Uint16Array]"] = D["[object Uint32Array]"] = !0, D[s] = D[u] = D[A] = D[d] = D[V] = D[p] = D[h] = D[g] = D[b] = D[v] = D[_] = D[N] = D[R] = D[z] = D[$] = !1;
  var F = typeof Za == "object" && Za && Za.Object === Object && Za, P = typeof self == "object" && self && self.Object === Object && self, H = F || P || Function("return this")(), Y = t && !t.nodeType && t, q = Y && e && !e.nodeType && e, M = q && q.exports === Y, X = M && F.process, K = function() {
    try {
      return X && X.binding && X.binding("util");
    } catch {
    }
  }(), L = K && K.isTypedArray;
  function ee(Q, ie) {
    for (var xe = -1, Ce = Q == null ? 0 : Q.length; ++xe < Ce; ) if (ie(Q[xe], xe, Q)) return !0;
    return !1;
  }
  function ae(Q) {
    var ie = -1, xe = Array(Q.size);
    return Q.forEach(function(Ce, Je) {
      xe[++ie] = [Je, Ce];
    }), xe;
  }
  function le(Q) {
    var ie = -1, xe = Array(Q.size);
    return Q.forEach(function(Ce) {
      xe[++ie] = Ce;
    }), xe;
  }
  var me, se, he, _e = Array.prototype, Se = Function.prototype, Ee = Object.prototype, Ie = H["__core-js_shared__"], $e = Se.toString, ct = Ee.hasOwnProperty, $t = (me = /[^.]+$/.exec(Ie && Ie.keys && Ie.keys.IE_PROTO || "")) ? "Symbol(src)_1." + me : "", ft = Ee.toString, br = RegExp("^" + $e.call(ct).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), on = M ? H.Buffer : void 0, vn = H.Symbol, De = H.Uint8Array, qr = Ee.propertyIsEnumerable, Xr = _e.splice, qn = vn ? vn.toStringTag : void 0, Wr = Object.getOwnPropertySymbols, ce = on ? on.isBuffer : void 0, ye = (se = Object.keys, he = Object, function(Q) {
    return se(he(Q));
  }), Ae = Bo(H, "DataView"), Ve = Bo(H, "Map"), ut = Bo(H, "Promise"), bn = Bo(H, "Set"), or = Bo(H, "WeakMap"), Xt = Bo(Object, "create"), ir = Cn(Ae), kn = Cn(Ve), Wt = Cn(ut), Dn = Cn(bn), Xn = Cn(or), fs = vn ? vn.prototype : void 0, da = fs ? fs.valueOf : void 0;
  function wr(Q) {
    var ie = -1, xe = Q == null ? 0 : Q.length;
    for (this.clear(); ++ie < xe; ) {
      var Ce = Q[ie];
      this.set(Ce[0], Ce[1]);
    }
  }
  function En(Q) {
    var ie = -1, xe = Q == null ? 0 : Q.length;
    for (this.clear(); ++ie < xe; ) {
      var Ce = Q[ie];
      this.set(Ce[0], Ce[1]);
    }
  }
  function mo(Q) {
    var ie = -1, xe = Q == null ? 0 : Q.length;
    for (this.clear(); ++ie < xe; ) {
      var Ce = Q[ie];
      this.set(Ce[0], Ce[1]);
    }
  }
  function Lo(Q) {
    var ie = -1, xe = Q == null ? 0 : Q.length;
    for (this.__data__ = new mo(); ++ie < xe; ) this.add(Q[ie]);
  }
  function xr(Q) {
    var ie = this.__data__ = new En(Q);
    this.size = ie.size;
  }
  function ps(Q, ie) {
    var xe = _r(Q), Ce = !xe && wi(Q), Je = !xe && !Ce && Lt(Q), Ye = !xe && !Ce && !Je && ys(Q), St = xe || Ce || Je || Ye, bt = St ? function(Yt, Wn) {
      for (var It = -1, sn = Array(Yt); ++It < Yt; ) sn[It] = Wn(It);
      return sn;
    }(Q.length, String) : [], On = bt.length;
    for (var Tt in Q) !ct.call(Q, Tt) || St && (Tt == "length" || Je && (Tt == "offset" || Tt == "parent") || Ye && (Tt == "buffer" || Tt == "byteLength" || Tt == "byteOffset") || hs(Tt, On)) || bt.push(Tt);
    return bt;
  }
  function Io(Q, ie) {
    for (var xe = Q.length; xe--; ) if (Gr(Q[xe][0], ie)) return xe;
    return -1;
  }
  function Vo(Q) {
    return Q == null ? Q === void 0 ? I : x : qn && qn in Object(Q) ? function(ie) {
      var xe = ct.call(ie, qn), Ce = ie[qn];
      try {
        ie[qn] = void 0;
        var Je = !0;
      } catch {
      }
      var Ye = ft.call(ie);
      return Je && (xe ? ie[qn] = Ce : delete ie[qn]), Ye;
    }(Q) : function(ie) {
      return ft.call(ie);
    }(Q);
  }
  function fl(Q) {
    return ar(Q) && Vo(Q) == s;
  }
  function Sr(Q, ie, xe, Ce, Je) {
    return Q === ie || (Q == null || ie == null || !ar(Q) && !ar(ie) ? Q != Q && ie != ie : function(Ye, St, bt, On, Tt, Yt) {
      var Wn = _r(Ye), It = _r(St), sn = Wn ? u : Pn(Ye), Gn = It ? u : Pn(St), kr = (sn = sn == s ? _ : sn) == _, xi = (Gn = Gn == s ? _ : Gn) == _, Zn = sn == Gn;
      if (Zn && Lt(Ye)) {
        if (!Lt(St)) return !1;
        Wn = !0, kr = !1;
      }
      if (Zn && !kr) return Yt || (Yt = new xr()), Wn || ys(Ye) ? go(Ye, St, bt, On, Tt, Yt) : function(pt, ot, vs, yo, Fo, sr, Kr) {
        switch (vs) {
          case V:
            if (pt.byteLength != ot.byteLength || pt.byteOffset != ot.byteOffset) return !1;
            pt = pt.buffer, ot = ot.buffer;
          case A:
            return !(pt.byteLength != ot.byteLength || !sr(new De(pt), new De(ot)));
          case d:
          case p:
          case v:
            return Gr(+pt, +ot);
          case h:
            return pt.name == ot.name && pt.message == ot.message;
          case N:
          case z:
            return pt == ot + "";
          case b:
            var vo = ae;
          case R:
            var _i = yo & r;
            if (vo || (vo = le), pt.size != ot.size && !_i) return !1;
            var ml = Kr.get(pt);
            if (ml) return ml == ot;
            yo |= o, Kr.set(pt, ot);
            var Ju = go(vo(pt), vo(ot), yo, Fo, sr, Kr);
            return Kr.delete(pt), Ju;
          case j:
            if (da) return da.call(pt) == da.call(ot);
        }
        return !1;
      }(Ye, St, sn, bt, On, Tt, Yt);
      if (!(bt & r)) {
        var Si = kr && ct.call(Ye, "__wrapped__"), An = xi && ct.call(St, "__wrapped__");
        if (Si || An) {
          var ha = Si ? Ye.value() : Ye, zf = An ? St.value() : St;
          return Yt || (Yt = new xr()), Tt(ha, zf, bt, On, Yt);
        }
      }
      return !!Zn && (Yt || (Yt = new xr()), function(pt, ot, vs, yo, Fo, sr) {
        var Kr = vs & r, vo = fa(pt), _i = vo.length, ml = fa(ot), Ju = ml.length;
        if (_i != Ju && !Kr) return !1;
        for (var ki = _i; ki--; ) {
          var bo = vo[ki];
          if (!(Kr ? bo in ot : ct.call(ot, bo))) return !1;
        }
        var gl = sr.get(pt);
        if (gl && sr.get(ot)) return gl == ot;
        var wo = !0;
        sr.set(pt, ot), sr.set(ot, pt);
        for (var Uo = Kr; ++ki < _i; ) {
          var bs = pt[bo = vo[ki]], ma = ot[bo];
          if (yo) var ec = Kr ? yo(ma, bs, bo, ot, pt, sr) : yo(bs, ma, bo, pt, ot, sr);
          if (!(ec === void 0 ? bs === ma || Fo(bs, ma, vs, yo, sr) : ec)) {
            wo = !1;
            break;
          }
          Uo || (Uo = bo == "constructor");
        }
        if (wo && !Uo) {
          var Ho = pt.constructor, lr = ot.constructor;
          Ho == lr || !("constructor" in pt) || !("constructor" in ot) || typeof Ho == "function" && Ho instanceof Ho && typeof lr == "function" && lr instanceof lr || (wo = !1);
        }
        return sr.delete(pt), sr.delete(ot), wo;
      }(Ye, St, bt, On, Tt, Yt));
    }(Q, ie, xe, Ce, Sr, Je));
  }
  function an(Q) {
    return !(!Zr(Q) || function(ie) {
      return !!$t && $t in ie;
    }(Q)) && (ms(Q) ? br : U).test(Cn(Q));
  }
  function wn(Q) {
    if (xe = (ie = Q) && ie.constructor, Ce = typeof xe == "function" && xe.prototype || Ee, ie !== Ce) return ye(Q);
    var ie, xe, Ce, Je = [];
    for (var Ye in Object(Q)) ct.call(Q, Ye) && Ye != "constructor" && Je.push(Ye);
    return Je;
  }
  function go(Q, ie, xe, Ce, Je, Ye) {
    var St = xe & r, bt = Q.length, On = ie.length;
    if (bt != On && !(St && On > bt)) return !1;
    var Tt = Ye.get(Q);
    if (Tt && Ye.get(ie)) return Tt == ie;
    var Yt = -1, Wn = !0, It = xe & o ? new Lo() : void 0;
    for (Ye.set(Q, ie), Ye.set(ie, Q); ++Yt < bt; ) {
      var sn = Q[Yt], Gn = ie[Yt];
      if (Ce) var kr = St ? Ce(Gn, sn, Yt, ie, Q, Ye) : Ce(sn, Gn, Yt, Q, ie, Ye);
      if (kr !== void 0) {
        if (kr) continue;
        Wn = !1;
        break;
      }
      if (It) {
        if (!ee(ie, function(xi, Zn) {
          if (Si = Zn, !It.has(Si) && (sn === xi || Je(sn, xi, xe, Ce, Ye))) return It.push(Zn);
          var Si;
        })) {
          Wn = !1;
          break;
        }
      } else if (sn !== Gn && !Je(sn, Gn, xe, Ce, Ye)) {
        Wn = !1;
        break;
      }
    }
    return Ye.delete(Q), Ye.delete(ie), Wn;
  }
  function fa(Q) {
    return function(ie, xe, Ce) {
      var Je = xe(ie);
      return _r(ie) ? Je : function(Ye, St) {
        for (var bt = -1, On = St.length, Tt = Ye.length; ++bt < On; ) Ye[Tt + bt] = St[bt];
        return Ye;
      }(Je, Ce(ie));
    }(Q, hl, pl);
  }
  function pa(Q, ie) {
    var xe, Ce, Je = Q.__data__;
    return ((Ce = typeof (xe = ie)) == "string" || Ce == "number" || Ce == "symbol" || Ce == "boolean" ? xe !== "__proto__" : xe === null) ? Je[typeof ie == "string" ? "string" : "hash"] : Je.map;
  }
  function Bo(Q, ie) {
    var xe = function(Ce, Je) {
      return Ce?.[Je];
    }(Q, ie);
    return an(xe) ? xe : void 0;
  }
  wr.prototype.clear = function() {
    this.__data__ = Xt ? Xt(null) : {}, this.size = 0;
  }, wr.prototype.delete = function(Q) {
    var ie = this.has(Q) && delete this.__data__[Q];
    return this.size -= ie ? 1 : 0, ie;
  }, wr.prototype.get = function(Q) {
    var ie = this.__data__;
    if (Xt) {
      var xe = ie[Q];
      return xe === n ? void 0 : xe;
    }
    return ct.call(ie, Q) ? ie[Q] : void 0;
  }, wr.prototype.has = function(Q) {
    var ie = this.__data__;
    return Xt ? ie[Q] !== void 0 : ct.call(ie, Q);
  }, wr.prototype.set = function(Q, ie) {
    var xe = this.__data__;
    return this.size += this.has(Q) ? 0 : 1, xe[Q] = Xt && ie === void 0 ? n : ie, this;
  }, En.prototype.clear = function() {
    this.__data__ = [], this.size = 0;
  }, En.prototype.delete = function(Q) {
    var ie = this.__data__, xe = Io(ie, Q);
    return !(xe < 0 || (xe == ie.length - 1 ? ie.pop() : Xr.call(ie, xe, 1), --this.size, 0));
  }, En.prototype.get = function(Q) {
    var ie = this.__data__, xe = Io(ie, Q);
    return xe < 0 ? void 0 : ie[xe][1];
  }, En.prototype.has = function(Q) {
    return Io(this.__data__, Q) > -1;
  }, En.prototype.set = function(Q, ie) {
    var xe = this.__data__, Ce = Io(xe, Q);
    return Ce < 0 ? (++this.size, xe.push([Q, ie])) : xe[Ce][1] = ie, this;
  }, mo.prototype.clear = function() {
    this.size = 0, this.__data__ = {
      hash: new wr(),
      map: new (Ve || En)(),
      string: new wr()
    };
  }, mo.prototype.delete = function(Q) {
    var ie = pa(this, Q).delete(Q);
    return this.size -= ie ? 1 : 0, ie;
  }, mo.prototype.get = function(Q) {
    return pa(this, Q).get(Q);
  }, mo.prototype.has = function(Q) {
    return pa(this, Q).has(Q);
  }, mo.prototype.set = function(Q, ie) {
    var xe = pa(this, Q), Ce = xe.size;
    return xe.set(Q, ie), this.size += xe.size == Ce ? 0 : 1, this;
  }, Lo.prototype.add = Lo.prototype.push = function(Q) {
    return this.__data__.set(Q, n), this;
  }, Lo.prototype.has = function(Q) {
    return this.__data__.has(Q);
  }, xr.prototype.clear = function() {
    this.__data__ = new En(), this.size = 0;
  }, xr.prototype.delete = function(Q) {
    var ie = this.__data__, xe = ie.delete(Q);
    return this.size = ie.size, xe;
  }, xr.prototype.get = function(Q) {
    return this.__data__.get(Q);
  }, xr.prototype.has = function(Q) {
    return this.__data__.has(Q);
  }, xr.prototype.set = function(Q, ie) {
    var xe = this.__data__;
    if (xe instanceof En) {
      var Ce = xe.__data__;
      if (!Ve || Ce.length < 199) return Ce.push([Q, ie]), this.size = ++xe.size, this;
      xe = this.__data__ = new mo(Ce);
    }
    return xe.set(Q, ie), this.size = xe.size, this;
  };
  var pl = Wr ? function(Q) {
    return Q == null ? [] : (Q = Object(Q), function(ie, xe) {
      for (var Ce = -1, Je = ie == null ? 0 : ie.length, Ye = 0, St = []; ++Ce < Je; ) {
        var bt = ie[Ce];
        xe(bt, Ce, ie) && (St[Ye++] = bt);
      }
      return St;
    }(Wr(Q), function(ie) {
      return qr.call(Q, ie);
    }));
  } : function() {
    return [];
  }, Pn = Vo;
  function hs(Q, ie) {
    return !!(ie = ie ?? i) && (typeof Q == "number" || W.test(Q)) && Q > -1 && Q % 1 == 0 && Q < ie;
  }
  function Cn(Q) {
    if (Q != null) {
      try {
        return $e.call(Q);
      } catch {
      }
      try {
        return Q + "";
      } catch {
      }
    }
    return "";
  }
  function Gr(Q, ie) {
    return Q === ie || Q != Q && ie != ie;
  }
  (Ae && Pn(new Ae(new ArrayBuffer(1))) != V || Ve && Pn(new Ve()) != b || ut && Pn(ut.resolve()) != O || bn && Pn(new bn()) != R || or && Pn(new or()) != $) && (Pn = function(Q) {
    var ie = Vo(Q), xe = ie == _ ? Q.constructor : void 0, Ce = xe ? Cn(xe) : "";
    if (Ce) switch (Ce) {
      case ir:
        return V;
      case kn:
        return b;
      case Wt:
        return O;
      case Dn:
        return R;
      case Xn:
        return $;
    }
    return ie;
  });
  var wi = fl(/* @__PURE__ */ function() {
    return arguments;
  }()) ? fl : function(Q) {
    return ar(Q) && ct.call(Q, "callee") && !qr.call(Q, "callee");
  }, _r = Array.isArray, Lt = ce || function() {
    return !1;
  };
  function ms(Q) {
    if (!Zr(Q)) return !1;
    var ie = Vo(Q);
    return ie == g || ie == y || ie == c || ie == C;
  }
  function gs(Q) {
    return typeof Q == "number" && Q > -1 && Q % 1 == 0 && Q <= i;
  }
  function Zr(Q) {
    var ie = typeof Q;
    return Q != null && (ie == "object" || ie == "function");
  }
  function ar(Q) {
    return Q != null && typeof Q == "object";
  }
  var ys = L ? /* @__PURE__ */ function(Q) {
    return function(ie) {
      return Q(ie);
    };
  }(L) : function(Q) {
    return ar(Q) && gs(Q.length) && !!D[Vo(Q)];
  };
  function hl(Q) {
    return (ie = Q) != null && gs(ie.length) && !ms(ie) ? ps(Q) : wn(Q);
    var ie;
  }
  e.exports = function(Q, ie) {
    return Sr(Q, ie);
  };
}(vw, vw.exports)), vw.exports), Ame = Mf(Ome);
function g4(e, t, n) {
  return e[t] ? e[t][0] ? e[t][0][n] : e[t][n] : t === "contentBoxSize" ? e.contentRect[n === "inlineSize" ? "width" : "height"] : void 0;
}
function Nme(e) {
  e === void 0 && (e = {});
  var t = e.onResize, n = S.useRef(void 0);
  n.current = t;
  var r = e.round || Math.round, o = S.useRef(), i = S.useState({
    width: void 0,
    height: void 0
  }), s = i[0], u = i[1], c = S.useRef(!1);
  S.useEffect(function() {
    return c.current = !1, function() {
      c.current = !0;
    };
  }, []);
  var d = S.useRef({
    width: void 0,
    height: void 0
  }), p = function(h, g) {
    var y = S.useRef(null), b = S.useRef(null);
    b.current = g;
    var v = S.useRef(null);
    S.useEffect(function() {
      x();
    });
    var x = S.useCallback(function() {
      var _ = v.current, O = b.current, C = _ || (O ? O instanceof Element ? O : O.current : null);
      y.current && y.current.element === C && y.current.subscriber === h || (y.current && y.current.cleanup && y.current.cleanup(), y.current = {
        element: C,
        subscriber: h,
        cleanup: C ? h(C) : void 0
      });
    }, [h]);
    return S.useEffect(function() {
      return function() {
        y.current && y.current.cleanup && (y.current.cleanup(), y.current = null);
      };
    }, []), S.useCallback(function(_) {
      v.current = _, x();
    }, [x]);
  }(S.useCallback(function(h) {
    return o.current && o.current.box === e.box && o.current.round === r || (o.current = {
      box: e.box,
      round: r,
      instance: new ResizeObserver(function(g) {
        var y = g[0], b = e.box === "border-box" ? "borderBoxSize" : e.box === "device-pixel-content-box" ? "devicePixelContentBoxSize" : "contentBoxSize", v = g4(y, b, "inlineSize"), x = g4(y, b, "blockSize"), _ = v ? r(v) : void 0, O = x ? r(x) : void 0;
        if (d.current.width !== _ || d.current.height !== O) {
          var C = {
            width: _,
            height: O
          };
          d.current.width = _, d.current.height = O, n.current ? n.current(C) : c.current || u(C);
        }
      })
    }), o.current.instance.observe(h, {
      box: e.box
    }), function() {
      o.current && o.current.instance.unobserve(h);
    };
  }, [e.box, r]), e.ref);
  return S.useMemo(function() {
    return {
      ref: p,
      width: s.width,
      height: s.height
    };
  }, [p, s.width, s.height]);
}
var Mme = "allotment-module_splitView__L-yRc", Rme = "allotment-module_sashContainer__fzwJF", jme = "allotment-module_splitViewContainer__rQnVa", ED = "allotment-module_splitViewView__MGZ6O", zme = "allotment-module_vertical__WSwwa", Tme = "allotment-module_horizontal__7doS8", Dme = "allotment-module_separatorBorder__x-rDS";
let id, CD = !1, OD = !1;
typeof navigator == "object" && (id = navigator.userAgent, OD = id.indexOf("Macintosh") >= 0, CD = (id.indexOf("Macintosh") >= 0 || id.indexOf("iPad") >= 0 || id.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
const AD = CD, Pme = OD, y4 = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? S.useLayoutEffect : S.useEffect;
class Lme {
  constructor() {
    this._size = void 0;
  }
  getSize() {
    return this._size;
  }
  setSize(t) {
    this._size = t;
  }
}
function yh(e, t) {
  const n = e.length, r = n - t.length;
  return r >= 0 && e.slice(r, n) === t;
}
var v4, b4 = {
  exports: {}
}, w4, x4, Ime = (v4 || (v4 = 1, function(e) {
  var t = Object.prototype.hasOwnProperty, n = "~";
  function r() {
  }
  function o(c, d, p) {
    this.fn = c, this.context = d, this.once = p || !1;
  }
  function i(c, d, p, h, g) {
    if (typeof p != "function") throw new TypeError("The listener must be a function");
    var y = new o(p, h || c, g), b = n ? n + d : d;
    return c._events[b] ? c._events[b].fn ? c._events[b] = [c._events[b], y] : c._events[b].push(y) : (c._events[b] = y, c._eventsCount++), c;
  }
  function s(c, d) {
    --c._eventsCount == 0 ? c._events = new r() : delete c._events[d];
  }
  function u() {
    this._events = new r(), this._eventsCount = 0;
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (n = !1)), u.prototype.eventNames = function() {
    var c, d, p = [];
    if (this._eventsCount === 0) return p;
    for (d in c = this._events) t.call(c, d) && p.push(n ? d.slice(1) : d);
    return Object.getOwnPropertySymbols ? p.concat(Object.getOwnPropertySymbols(c)) : p;
  }, u.prototype.listeners = function(c) {
    var d = n ? n + c : c, p = this._events[d];
    if (!p) return [];
    if (p.fn) return [p.fn];
    for (var h = 0, g = p.length, y = new Array(g); h < g; h++) y[h] = p[h].fn;
    return y;
  }, u.prototype.listenerCount = function(c) {
    var d = n ? n + c : c, p = this._events[d];
    return p ? p.fn ? 1 : p.length : 0;
  }, u.prototype.emit = function(c, d, p, h, g, y) {
    var b = n ? n + c : c;
    if (!this._events[b]) return !1;
    var v, x, _ = this._events[b], O = arguments.length;
    if (_.fn) {
      switch (_.once && this.removeListener(c, _.fn, void 0, !0), O) {
        case 1:
          return _.fn.call(_.context), !0;
        case 2:
          return _.fn.call(_.context, d), !0;
        case 3:
          return _.fn.call(_.context, d, p), !0;
        case 4:
          return _.fn.call(_.context, d, p, h), !0;
        case 5:
          return _.fn.call(_.context, d, p, h, g), !0;
        case 6:
          return _.fn.call(_.context, d, p, h, g, y), !0;
      }
      for (x = 1, v = new Array(O - 1); x < O; x++) v[x - 1] = arguments[x];
      _.fn.apply(_.context, v);
    } else {
      var C, N = _.length;
      for (x = 0; x < N; x++) switch (_[x].once && this.removeListener(c, _[x].fn, void 0, !0), O) {
        case 1:
          _[x].fn.call(_[x].context);
          break;
        case 2:
          _[x].fn.call(_[x].context, d);
          break;
        case 3:
          _[x].fn.call(_[x].context, d, p);
          break;
        case 4:
          _[x].fn.call(_[x].context, d, p, h);
          break;
        default:
          if (!v) for (C = 1, v = new Array(O - 1); C < O; C++) v[C - 1] = arguments[C];
          _[x].fn.apply(_[x].context, v);
      }
    }
    return !0;
  }, u.prototype.on = function(c, d, p) {
    return i(this, c, d, p, !1);
  }, u.prototype.once = function(c, d, p) {
    return i(this, c, d, p, !0);
  }, u.prototype.removeListener = function(c, d, p, h) {
    var g = n ? n + c : c;
    if (!this._events[g]) return this;
    if (!d) return s(this, g), this;
    var y = this._events[g];
    if (y.fn) y.fn !== d || h && !y.once || p && y.context !== p || s(this, g);
    else {
      for (var b = 0, v = [], x = y.length; b < x; b++) (y[b].fn !== d || h && !y[b].once || p && y[b].context !== p) && v.push(y[b]);
      v.length ? this._events[g] = v.length === 1 ? v[0] : v : s(this, g);
    }
    return this;
  }, u.prototype.removeAllListeners = function(c) {
    var d;
    return c ? (d = n ? n + c : c, this._events[d] && s(this, d)) : (this._events = new r(), this._eventsCount = 0), this;
  }, u.prototype.off = u.prototype.removeListener, u.prototype.addListener = u.prototype.on, u.prefixed = n, u.EventEmitter = u, e.exports = u;
}(b4)), b4.exports), v_ = Mf(Ime);
function S4(e, t) {
  const n = e.indexOf(t);
  n > -1 && (e.splice(n, 1), e.unshift(t));
}
function bw(e, t) {
  const n = e.indexOf(t);
  n > -1 && (e.splice(n, 1), e.push(t));
}
function io(e, t, n = 1) {
  const r = Math.max(0, Math.ceil((t - e) / n)), o = new Array(r);
  let i = -1;
  for (; ++i < r; ) o[i] = e + i * n;
  return o;
}
var Vme = Mf(function() {
  if (x4) return w4;
  x4 = 1;
  var e = NaN, t = "[object Symbol]", n = /^\s+|\s+$/g, r = /^[-+]0x[0-9a-f]+$/i, o = /^0b[01]+$/i, i = /^0o[0-7]+$/i, s = parseInt, u = typeof Za == "object" && Za && Za.Object === Object && Za, c = typeof self == "object" && self && self.Object === Object && self, d = u || c || Function("return this")(), p = Object.prototype.toString, h = Math.max, g = Math.min, y = function() {
    return d.Date.now();
  };
  function b(x) {
    var _ = typeof x;
    return !!x && (_ == "object" || _ == "function");
  }
  function v(x) {
    if (typeof x == "number") return x;
    if (function(C) {
      return typeof C == "symbol" || /* @__PURE__ */ function(N) {
        return !!N && typeof N == "object";
      }(C) && p.call(C) == t;
    }(x)) return e;
    if (b(x)) {
      var _ = typeof x.valueOf == "function" ? x.valueOf() : x;
      x = b(_) ? _ + "" : _;
    }
    if (typeof x != "string") return x === 0 ? x : +x;
    x = x.replace(n, "");
    var O = o.test(x);
    return O || i.test(x) ? s(x.slice(2), O ? 2 : 8) : r.test(x) ? e : +x;
  }
  return w4 = function(x, _, O) {
    var C, N, R, z, j, I, $ = 0, A = !1, V = !1, U = !0;
    if (typeof x != "function") throw new TypeError("Expected a function");
    function W(Y) {
      var q = C, M = N;
      return C = N = void 0, $ = Y, z = x.apply(M, q);
    }
    function D(Y) {
      var q = Y - I;
      return I === void 0 || q >= _ || q < 0 || V && Y - $ >= R;
    }
    function F() {
      var Y = y();
      if (D(Y)) return P(Y);
      j = setTimeout(F, function(q) {
        var M = _ - (q - I);
        return V ? g(M, R - (q - $)) : M;
      }(Y));
    }
    function P(Y) {
      return j = void 0, U && C ? W(Y) : (C = N = void 0, z);
    }
    function H() {
      var Y = y(), q = D(Y);
      if (C = arguments, N = this, I = Y, q) {
        if (j === void 0) return function(M) {
          return $ = M, j = setTimeout(F, _), A ? W(M) : z;
        }(I);
        if (V) return j = setTimeout(F, _), W(I);
      }
      return j === void 0 && (j = setTimeout(F, _)), z;
    }
    return _ = v(_) || 0, b(O) && (A = !!O.leading, R = (V = "maxWait" in O) ? h(v(O.maxWait) || 0, _) : R, U = "trailing" in O ? !!O.trailing : U), H.cancel = function() {
      j !== void 0 && clearTimeout(j), $ = 0, C = I = N = j = void 0;
    }, H.flush = function() {
      return j === void 0 ? z : P(y());
    }, H;
  };
}()), Bme = "sash-module_sash__K-9lB", Fme = "sash-module_disabled__Hm-wx", Ume = "sash-module_mac__Jf6OJ", _4 = "sash-module_vertical__pB-rs", Hme = "sash-module_minimum__-UKxp", $me = "sash-module_maximum__TCWxD", k4 = "sash-module_horizontal__kFbiw", ww = "sash-module_hover__80W6I", xw = "sash-module_active__bJspD";
let uo = function(e) {
  return e.Vertical = "VERTICAL", e.Horizontal = "HORIZONTAL", e;
}({}), Tr = function(e) {
  return e.Disabled = "DISABLED", e.Minimum = "MINIMUM", e.Maximum = "MAXIMUM", e.Enabled = "ENABLED", e;
}({}), ND = AD ? 20 : 8;
const MD = new v_();
class E4 extends v_ {
  get state() {
    return this._state;
  }
  set state(t) {
    this._state !== t && (this.el.classList.toggle(Fme, t === Tr.Disabled), this.el.classList.toggle("sash-disabled", t === Tr.Disabled), this.el.classList.toggle(Hme, t === Tr.Minimum), this.el.classList.toggle("sash-minimum", t === Tr.Minimum), this.el.classList.toggle($me, t === Tr.Maximum), this.el.classList.toggle("sash-maximum", t === Tr.Maximum), this._state = t, this.emit("enablementChange", t));
  }
  constructor(t, n, r) {
    var o;
    super(), this.el = void 0, this.layoutProvider = void 0, this.orientation = void 0, this.size = void 0, this.hoverDelay = 300, this.hoverDelayer = Vme((i) => i.classList.add("sash-hover", ww), this.hoverDelay), this._state = Tr.Enabled, this.onPointerStart = (i) => {
      const s = i.pageX, u = i.pageY, c = {
        startX: s,
        currentX: s,
        startY: u,
        currentY: u
      };
      this.el.classList.add("sash-active", xw), this.emit("start", c), this.el.setPointerCapture(i.pointerId);
      const d = (h) => {
        h.preventDefault();
        const g = {
          startX: s,
          currentX: h.pageX,
          startY: u,
          currentY: h.pageY
        };
        this.emit("change", g);
      }, p = (h) => {
        h.preventDefault(), this.el.classList.remove("sash-active", xw), this.hoverDelayer.cancel(), this.emit("end"), this.el.releasePointerCapture(h.pointerId), window.removeEventListener("pointermove", d), window.removeEventListener("pointerup", p);
      };
      window.addEventListener("pointermove", d), window.addEventListener("pointerup", p);
    }, this.onPointerDoublePress = () => {
      this.emit("reset");
    }, this.onMouseEnter = () => {
      this.el.classList.contains(xw) ? (this.hoverDelayer.cancel(), this.el.classList.add("sash-hover", ww)) : this.hoverDelayer(this.el);
    }, this.onMouseLeave = () => {
      this.hoverDelayer.cancel(), this.el.classList.remove("sash-hover", ww);
    }, this.el = document.createElement("div"), this.el.classList.add("sash", Bme), this.el.dataset.testid = "sash", t.append(this.el), Pme && this.el.classList.add("sash-mac", Ume), this.el.addEventListener("pointerdown", this.onPointerStart), this.el.addEventListener("dblclick", this.onPointerDoublePress), this.el.addEventListener("mouseenter", this.onMouseEnter), this.el.addEventListener("mouseleave", this.onMouseLeave), typeof r.size == "number" ? (this.size = r.size, r.orientation === uo.Vertical ? this.el.style.width = `${this.size}px` : this.el.style.height = `${this.size}px`) : (this.size = ND, MD.on("onDidChangeGlobalSize", (i) => {
      this.size = i, this.layout();
    })), this.layoutProvider = n, this.orientation = (o = r.orientation) != null ? o : uo.Vertical, this.orientation === uo.Horizontal ? (this.el.classList.add("sash-horizontal", k4), this.el.classList.remove("sash-vertical", _4)) : (this.el.classList.remove("sash-horizontal", k4), this.el.classList.add("sash-vertical", _4)), this.layout();
  }
  layout() {
    if (this.orientation === uo.Vertical) {
      const t = this.layoutProvider;
      this.el.style.left = t.getVerticalSashLeft(this) - this.size / 2 + "px", t.getVerticalSashTop && (this.el.style.top = t.getVerticalSashTop(this) + "px"), t.getVerticalSashHeight && (this.el.style.height = t.getVerticalSashHeight(this) + "px");
    } else {
      const t = this.layoutProvider;
      this.el.style.top = t.getHorizontalSashTop(this) - this.size / 2 + "px", t.getHorizontalSashLeft && (this.el.style.left = t.getHorizontalSashLeft(this) + "px"), t.getHorizontalSashWidth && (this.el.style.width = t.getHorizontalSashWidth(this) + "px");
    }
  }
  dispose() {
    this.el.removeEventListener("pointerdown", this.onPointerStart), this.el.removeEventListener("dblclick", this.onPointerDoublePress), this.el.removeEventListener("mouseenter", this.onMouseEnter), this.el.removeEventListener("mouseleave", () => this.onMouseLeave), this.el.remove();
  }
}
let Mm;
var Sw;
(Sw = Mm || (Mm = {})).Distribute = {
  type: "distribute"
}, Sw.Split = function(e) {
  return {
    type: "split",
    index: e
  };
}, Sw.Invisible = function(e) {
  return {
    type: "invisible",
    cachedVisibleSize: e
  };
};
let Fi = function(e) {
  return e.Normal = "NORMAL", e.Low = "LOW", e.High = "HIGH", e;
}({});
class RD {
  constructor(t, n, r) {
    this.container = void 0, this.view = void 0, this._size = void 0, this._cachedVisibleSize = void 0, this.container = t, this.view = n, this.container.classList.add("split-view-view", ED), this.container.dataset.testid = "split-view-view", typeof r == "number" ? (this._size = r, this._cachedVisibleSize = void 0, t.classList.add("split-view-view-visible")) : (this._size = 0, this._cachedVisibleSize = r.cachedVisibleSize);
  }
  set size(t) {
    this._size = t;
  }
  get size() {
    return this._size;
  }
  get priority() {
    return this.view.priority;
  }
  get snap() {
    return !!this.view.snap;
  }
  get cachedVisibleSize() {
    return this._cachedVisibleSize;
  }
  get visible() {
    return this._cachedVisibleSize === void 0;
  }
  setVisible(t, n) {
    t !== this.visible && (t ? (this.size = Eo(this._cachedVisibleSize, this.viewMinimumSize, this.viewMaximumSize), this._cachedVisibleSize = void 0) : (this._cachedVisibleSize = typeof n == "number" ? n : this.size, this.size = 0), this.container.classList.toggle("split-view-view-visible", t), this.view.setVisible && this.view.setVisible(t));
  }
  get minimumSize() {
    return this.visible ? this.view.minimumSize : 0;
  }
  get viewMinimumSize() {
    return this.view.minimumSize;
  }
  get maximumSize() {
    return this.visible ? this.view.maximumSize : 0;
  }
  get viewMaximumSize() {
    return this.view.maximumSize;
  }
  set enabled(t) {
    this.container.style.pointerEvents = t ? "" : "none";
  }
  layout(t) {
    this.layoutContainer(t), this.view.layout(this.size, t);
  }
}
class Yme extends RD {
  layoutContainer(t) {
    this.container.style.left = `${t}px`, this.container.style.width = `${this.size}px`;
  }
}
class qme extends RD {
  layoutContainer(t) {
    this.container.style.top = `${t}px`, this.container.style.height = `${this.size}px`;
  }
}
class Xme extends v_ {
  get startSnappingEnabled() {
    return this._startSnappingEnabled;
  }
  set startSnappingEnabled(t) {
    this._startSnappingEnabled !== t && (this._startSnappingEnabled = t, this.updateSashEnablement());
  }
  get endSnappingEnabled() {
    return this._endSnappingEnabled;
  }
  set endSnappingEnabled(t) {
    this._endSnappingEnabled !== t && (this._endSnappingEnabled = t, this.updateSashEnablement());
  }
  constructor(t, n = {}, r, o, i) {
    var s, u;
    if (super(), this.onDidChange = void 0, this.onDidDragStart = void 0, this.onDidDragEnd = void 0, this.orientation = void 0, this.sashContainer = void 0, this.size = 0, this.contentSize = 0, this.proportions = void 0, this.viewItems = [], this.sashItems = [], this.sashDragState = void 0, this.proportionalLayout = void 0, this.getSashOrthogonalSize = void 0, this._startSnappingEnabled = !0, this._endSnappingEnabled = !0, this.onSashEnd = (c) => {
      this.emit("sashchange", c), this.saveProportions();
      for (const d of this.viewItems) d.enabled = !0;
    }, this.orientation = (s = n.orientation) != null ? s : uo.Vertical, this.proportionalLayout = (u = n.proportionalLayout) != null ? u : !0, this.getSashOrthogonalSize = n.getSashOrthogonalSize, r && (this.onDidChange = r), o && (this.onDidDragStart = o), i && (this.onDidDragEnd = i), this.sashContainer = document.createElement("div"), this.sashContainer.classList.add("sash-container", Rme), t.prepend(this.sashContainer), n.descriptor) {
      this.size = n.descriptor.size;
      for (const [c, d] of n.descriptor.views.entries()) {
        const p = d.size, h = d.container, g = d.view;
        this.addView(h, g, p, c, !0);
      }
      this.contentSize = this.viewItems.reduce((c, d) => c + d.size, 0), this.saveProportions();
    }
  }
  addView(t, n, r, o = this.viewItems.length, i) {
    let s;
    s = typeof r == "number" ? r : r.type === "split" ? this.getViewSize(r.index) / 2 : r.type === "invisible" ? {
      cachedVisibleSize: r.cachedVisibleSize
    } : n.minimumSize;
    const u = this.orientation === uo.Vertical ? new qme(t, n, s) : new Yme(t, n, s);
    if (this.viewItems.splice(o, 0, u), this.viewItems.length > 1) {
      const c = this.orientation === uo.Vertical ? new E4(this.sashContainer, {
        getHorizontalSashTop: (h) => this.getSashPosition(h),
        getHorizontalSashWidth: this.getSashOrthogonalSize
      }, {
        orientation: uo.Horizontal
      }) : new E4(this.sashContainer, {
        getVerticalSashLeft: (h) => this.getSashPosition(h),
        getVerticalSashHeight: this.getSashOrthogonalSize
      }, {
        orientation: uo.Vertical
      }), d = this.orientation === uo.Vertical ? (h) => ({
        sash: c,
        start: h.startY,
        current: h.currentY
      }) : (h) => ({
        sash: c,
        start: h.startX,
        current: h.currentX
      });
      c.on("start", (h) => {
        var g;
        this.emit("sashDragStart"), this.onSashStart(d(h));
        const y = this.viewItems.map((b) => b.size);
        (g = this.onDidDragStart) == null || g.call(this, y);
      }), c.on("change", (h) => this.onSashChange(d(h))), c.on("end", () => {
        var h;
        this.emit("sashDragEnd"), this.onSashEnd(this.sashItems.findIndex((y) => y.sash === c));
        const g = this.viewItems.map((y) => y.size);
        (h = this.onDidDragEnd) == null || h.call(this, g);
      }), c.on("reset", () => {
        const h = this.sashItems.findIndex((x) => x.sash === c), g = io(h, -1, -1), y = io(h + 1, this.viewItems.length), b = this.findFirstSnapIndex(g), v = this.findFirstSnapIndex(y);
        (typeof b != "number" || this.viewItems[b].visible) && (typeof v != "number" || this.viewItems[v].visible) && this.emit("sashreset", h);
      });
      const p = {
        sash: c
      };
      this.sashItems.splice(o - 1, 0, p);
    }
    i || this.relayout(), i || typeof r == "number" || r.type !== "distribute" || this.distributeViewSizes();
  }
  removeView(t, n) {
    if (t < 0 || t >= this.viewItems.length) throw new Error("Index out of bounds");
    const r = this.viewItems.splice(t, 1)[0].view;
    if (this.viewItems.length >= 1) {
      const o = Math.max(t - 1, 0);
      this.sashItems.splice(o, 1)[0].sash.dispose();
    }
    return this.relayout(), n && n.type === "distribute" && this.distributeViewSizes(), r;
  }
  moveView(t, n, r) {
    const o = this.getViewCachedVisibleSize(n), i = o === void 0 ? this.getViewSize(n) : Mm.Invisible(o), s = this.removeView(n);
    this.addView(t, s, i, r);
  }
  getViewCachedVisibleSize(t) {
    if (t < 0 || t >= this.viewItems.length) throw new Error("Index out of bounds");
    return this.viewItems[t].cachedVisibleSize;
  }
  layout(t = this.size) {
    const n = Math.max(this.size, this.contentSize);
    if (this.size = t, this.proportions) for (let r = 0; r < this.viewItems.length; r++) {
      const o = this.viewItems[r];
      o.size = Eo(Math.round(this.proportions[r] * t), o.minimumSize, o.maximumSize);
    }
    else {
      const r = io(0, this.viewItems.length), o = r.filter((s) => this.viewItems[s].priority === Fi.Low), i = r.filter((s) => this.viewItems[s].priority === Fi.High);
      this.resize(this.viewItems.length - 1, t - n, void 0, o, i);
    }
    this.distributeEmptySpace(), this.layoutViews();
  }
  resizeView(t, n) {
    if (t < 0 || t >= this.viewItems.length) return;
    const r = io(0, this.viewItems.length).filter((u) => u !== t), o = [...r.filter((u) => this.viewItems[u].priority === Fi.Low), t], i = r.filter((u) => this.viewItems[u].priority === Fi.High), s = this.viewItems[t];
    n = Math.round(n), n = Eo(n, s.minimumSize, Math.min(s.maximumSize, this.size)), s.size = n, this.relayout(o, i);
  }
  resizeViews(t) {
    for (let n = 0; n < t.length; n++) {
      const r = this.viewItems[n];
      let o = t[n];
      o = Math.round(o), o = Eo(o, r.minimumSize, Math.min(r.maximumSize, this.size)), r.size = o;
    }
    this.contentSize = this.viewItems.reduce((n, r) => n + r.size, 0), this.saveProportions(), this.layout(this.size);
  }
  getViewSize(t) {
    return t < 0 || t >= this.viewItems.length ? -1 : this.viewItems[t].size;
  }
  isViewVisible(t) {
    if (t < 0 || t >= this.viewItems.length) throw new Error("Index out of bounds");
    return this.viewItems[t].visible;
  }
  setViewVisible(t, n) {
    if (t < 0 || t >= this.viewItems.length) throw new Error("Index out of bounds");
    this.viewItems[t].setVisible(n), this.distributeEmptySpace(t), this.layoutViews(), this.saveProportions();
  }
  distributeViewSizes() {
    const t = [];
    let n = 0;
    for (const u of this.viewItems) u.maximumSize - u.minimumSize > 0 && (t.push(u), n += u.size);
    const r = Math.floor(n / t.length);
    for (const u of t) u.size = Eo(r, u.minimumSize, u.maximumSize);
    const o = io(0, this.viewItems.length), i = o.filter((u) => this.viewItems[u].priority === Fi.Low), s = o.filter((u) => this.viewItems[u].priority === Fi.High);
    this.relayout(i, s);
  }
  dispose() {
    this.sashItems.forEach((t) => t.sash.dispose()), this.sashItems = [], this.sashContainer.remove();
  }
  relayout(t, n) {
    const r = this.viewItems.reduce((o, i) => o + i.size, 0);
    this.resize(this.viewItems.length - 1, this.size - r, void 0, t, n), this.distributeEmptySpace(), this.layoutViews(), this.saveProportions();
  }
  onSashStart({
    sash: t,
    start: n
  }) {
    const r = this.sashItems.findIndex((o) => o.sash === t);
    ((o) => {
      const i = this.viewItems.map((O) => O.size);
      let s, u, c = Number.NEGATIVE_INFINITY, d = Number.POSITIVE_INFINITY;
      const p = io(r, -1, -1), h = io(r + 1, this.viewItems.length), g = p.reduce((O, C) => O + (this.viewItems[C].minimumSize - i[C]), 0), y = p.reduce((O, C) => O + (this.viewItems[C].viewMaximumSize - i[C]), 0), b = h.length === 0 ? Number.POSITIVE_INFINITY : h.reduce((O, C) => O + (i[C] - this.viewItems[C].minimumSize), 0), v = h.length === 0 ? Number.NEGATIVE_INFINITY : h.reduce((O, C) => O + (i[C] - this.viewItems[C].viewMaximumSize), 0);
      c = Math.max(g, v), d = Math.min(b, y);
      const x = this.findFirstSnapIndex(p), _ = this.findFirstSnapIndex(h);
      if (typeof x == "number") {
        const O = this.viewItems[x], C = Math.floor(O.viewMinimumSize / 2);
        s = {
          index: x,
          limitDelta: O.visible ? c - C : c + C,
          size: O.size
        };
      }
      if (typeof _ == "number") {
        const O = this.viewItems[_], C = Math.floor(O.viewMinimumSize / 2);
        u = {
          index: _,
          limitDelta: O.visible ? d + C : d - C,
          size: O.size
        };
      }
      this.sashDragState = {
        start: o,
        current: o,
        index: r,
        sizes: i,
        minDelta: c,
        maxDelta: d,
        snapBefore: s,
        snapAfter: u
      };
    })(n);
  }
  onSashChange({
    current: t
  }) {
    const {
      index: n,
      start: r,
      sizes: o,
      minDelta: i,
      maxDelta: s,
      snapBefore: u,
      snapAfter: c
    } = this.sashDragState;
    this.sashDragState.current = t;
    const d = t - r;
    this.resize(n, d, o, void 0, void 0, i, s, u, c), this.distributeEmptySpace(), this.layoutViews();
  }
  getSashPosition(t) {
    let n = 0;
    for (let r = 0; r < this.sashItems.length; r++) if (n += this.viewItems[r].size, this.sashItems[r].sash === t) return n;
    return 0;
  }
  resize(t, n, r = this.viewItems.map((p) => p.size), o, i, s = Number.NEGATIVE_INFINITY, u = Number.POSITIVE_INFINITY, c, d) {
    if (t < 0 || t >= this.viewItems.length) return 0;
    const p = io(t, -1, -1), h = io(t + 1, this.viewItems.length);
    if (i) for (const j of i) S4(p, j), S4(h, j);
    if (o) for (const j of o) bw(p, j), bw(h, j);
    const g = p.map((j) => this.viewItems[j]), y = p.map((j) => r[j]), b = h.map((j) => this.viewItems[j]), v = h.map((j) => r[j]), x = p.reduce((j, I) => j + (this.viewItems[I].minimumSize - r[I]), 0), _ = p.reduce((j, I) => j + (this.viewItems[I].maximumSize - r[I]), 0), O = h.length === 0 ? Number.POSITIVE_INFINITY : h.reduce((j, I) => j + (r[I] - this.viewItems[I].minimumSize), 0), C = h.length === 0 ? Number.NEGATIVE_INFINITY : h.reduce((j, I) => j + (r[I] - this.viewItems[I].maximumSize), 0), N = Math.max(x, C, s), R = Math.min(O, _, u);
    let z = !1;
    if (c) {
      const j = this.viewItems[c.index], I = n >= c.limitDelta;
      z = I !== j.visible, j.setVisible(I, c.size);
    }
    if (!z && d) {
      const j = this.viewItems[d.index], I = n < d.limitDelta;
      z = I !== j.visible, j.setVisible(I, d.size);
    }
    if (z) return this.resize(t, n, r, o, i, s, u);
    for (let j = 0, I = n = Eo(n, N, R); j < g.length; j++) {
      const $ = g[j], A = Eo(y[j] + I, $.minimumSize, $.maximumSize);
      I -= A - y[j], $.size = A;
    }
    for (let j = 0, I = n; j < b.length; j++) {
      const $ = b[j], A = Eo(v[j] - I, $.minimumSize, $.maximumSize);
      I += A - v[j], $.size = A;
    }
    return n;
  }
  distributeEmptySpace(t) {
    const n = this.viewItems.reduce((i, s) => i + s.size, 0);
    let r = this.size - n;
    const o = io(this.viewItems.length - 1, -1, -1);
    typeof t == "number" && bw(o, t);
    for (let i = 0; r !== 0 && i < o.length; i++) {
      const s = this.viewItems[o[i]], u = Eo(s.size + r, s.minimumSize, s.maximumSize);
      r -= u - s.size, s.size = u;
    }
  }
  layoutViews() {
    var t;
    this.contentSize = this.viewItems.reduce((r, o) => r + o.size, 0);
    let n = 0;
    for (const r of this.viewItems) r.layout(n), n += r.size;
    (t = this.onDidChange) != null && t.call(this, this.viewItems.map((r) => r.size)), this.sashItems.forEach((r) => r.sash.layout()), this.updateSashEnablement();
  }
  saveProportions() {
    this.proportionalLayout && this.contentSize > 0 && (this.proportions = this.viewItems.map((t) => t.size / this.contentSize));
  }
  updateSashEnablement() {
    let t = !1;
    const n = this.viewItems.map((c) => t = c.size - c.minimumSize > 0 || t);
    t = !1;
    const r = this.viewItems.map((c) => t = c.maximumSize - c.size > 0 || t), o = [...this.viewItems].reverse();
    t = !1;
    const i = o.map((c) => t = c.size - c.minimumSize > 0 || t).reverse();
    t = !1;
    const s = o.map((c) => t = c.maximumSize - c.size > 0 || t).reverse();
    let u = 0;
    for (let c = 0; c < this.sashItems.length; c++) {
      const {
        sash: d
      } = this.sashItems[c];
      u += this.viewItems[c].size;
      const p = !(n[c] && s[c + 1]), h = !(r[c] && i[c + 1]);
      if (p && h) {
        const g = io(c, -1, -1), y = io(c + 1, this.viewItems.length), b = this.findFirstSnapIndex(g), v = this.findFirstSnapIndex(y), x = typeof b == "number" && !this.viewItems[b].visible, _ = typeof v == "number" && !this.viewItems[v].visible;
        x && i[c] && (u > 0 || this.startSnappingEnabled) ? d.state = Tr.Minimum : _ && n[c] && (u < this.contentSize || this.endSnappingEnabled) ? d.state = Tr.Maximum : d.state = Tr.Disabled;
      } else d.state = p && !h ? Tr.Minimum : !p && h ? Tr.Maximum : Tr.Enabled;
    }
  }
  findFirstSnapIndex(t) {
    for (const n of t) {
      const r = this.viewItems[n];
      if (r.visible && r.snap) return n;
    }
    for (const n of t) {
      const r = this.viewItems[n];
      if (r.visible && r.maximumSize - r.minimumSize > 0) return;
      if (!r.visible && r.snap) return n;
    }
  }
}
class iu {
  constructor(t) {
    this.size = void 0, this.size = t;
  }
  getPreferredSize() {
    return this.size;
  }
}
class C4 {
  constructor(t, n) {
    this.proportion = void 0, this.layoutService = void 0, this.proportion = t, this.layoutService = n;
  }
  getPreferredSize() {
    return this.proportion * this.layoutService.getSize();
  }
}
class vh {
  getPreferredSize() {
  }
}
class O4 {
  get preferredSize() {
    return this.layoutStrategy.getPreferredSize();
  }
  set preferredSize(t) {
    if (typeof t == "number") this.layoutStrategy = new iu(t);
    else if (typeof t == "string") {
      const n = t.trim();
      if (yh(n, "%")) {
        const r = Number(n.slice(0, -1)) / 100;
        this.layoutStrategy = new C4(r, this.layoutService);
      } else if (yh(n, "px")) {
        const r = Number(n.slice(0, -2)) / 100;
        this.layoutStrategy = new iu(r);
      } else if (typeof Number.parseFloat(n) == "number") {
        const r = Number.parseFloat(n);
        this.layoutStrategy = new iu(r);
      } else this.layoutStrategy = new vh();
    } else this.layoutStrategy = new vh();
  }
  constructor(t, n) {
    var r;
    if (this.minimumSize = 0, this.maximumSize = Number.POSITIVE_INFINITY, this.element = void 0, this.priority = void 0, this.snap = void 0, this.layoutService = void 0, this.layoutStrategy = void 0, this.layoutService = t, this.element = n.element, this.minimumSize = typeof n.minimumSize == "number" ? n.minimumSize : 30, this.maximumSize = typeof n.maximumSize == "number" ? n.maximumSize : Number.POSITIVE_INFINITY, typeof n.preferredSize == "number") this.layoutStrategy = new iu(n.preferredSize);
    else if (typeof n.preferredSize == "string") {
      const o = n.preferredSize.trim();
      if (yh(o, "%")) {
        const i = Number(o.slice(0, -1)) / 100;
        this.layoutStrategy = new C4(i, this.layoutService);
      } else if (yh(o, "px")) {
        const i = Number(o.slice(0, -2));
        this.layoutStrategy = new iu(i);
      } else if (typeof Number.parseFloat(o) == "number") {
        const i = Number.parseFloat(o);
        this.layoutStrategy = new iu(i);
      } else this.layoutStrategy = new vh();
    } else this.layoutStrategy = new vh();
    this.priority = (r = n.priority) != null ? r : Fi.Normal, this.snap = typeof n.snap == "boolean" && n.snap;
  }
  layout(t) {
  }
}
function A4(e) {
  return e.minSize !== void 0 || e.maxSize !== void 0 || e.preferredSize !== void 0 || e.priority !== void 0 || e.visible !== void 0;
}
const b_ = S.forwardRef(({
  className: e,
  children: t
}, n) => Qe.createElement("div", {
  ref: n,
  className: tS("split-view-view", ED, e)
}, t));
b_.displayName = "Allotment.Pane";
const jD = S.forwardRef(({
  children: e,
  className: t,
  id: n,
  maxSize: r = 1 / 0,
  minSize: o = 30,
  proportionalLayout: i = !0,
  separator: s = !0,
  sizes: u,
  defaultSizes: c = u,
  snap: d = !1,
  vertical: p = !1,
  onChange: h,
  onReset: g,
  onVisibleChange: y,
  onDragStart: b,
  onDragEnd: v
}, x) => {
  const _ = S.useRef(null), O = S.useRef([]), C = S.useRef(/* @__PURE__ */ new Map()), N = S.useRef(null), R = S.useRef(/* @__PURE__ */ new Map()), z = S.useRef(new Lme()), j = S.useRef([]), [I, $] = S.useState(!1), A = S.useMemo(() => Qe.Children.toArray(e).filter(Qe.isValidElement), [e]), V = S.useCallback((U) => {
    var W, D;
    const F = (W = j.current) == null ? void 0 : W[U];
    return typeof F?.preferredSize == "number" && ((D = N.current) != null && D.resizeView(U, Math.round(F.preferredSize)), !0);
  }, []);
  return S.useImperativeHandle(x, () => ({
    reset: () => {
      if (g) g();
      else {
        var U;
        (U = N.current) == null || U.distributeViewSizes();
        for (let W = 0; W < j.current.length; W++) V(W);
      }
    },
    resize: (U) => {
      var W;
      (W = N.current) == null || W.resizeViews(U);
    }
  })), y4(() => {
    let U = !0;
    c && R.current.size !== c.length && (U = !1, console.warn(`Expected ${c.length} children based on defaultSizes but found ${R.current.size}`)), U && c && (O.current = A.map((F) => F.key));
    const W = kd({
      orientation: p ? uo.Vertical : uo.Horizontal,
      proportionalLayout: i
    }, U && c && {
      descriptor: {
        size: c.reduce((F, P) => F + P, 0),
        views: c.map((F, P) => {
          var H, Y, q, M;
          const X = C.current.get(O.current[P]), K = new O4(z.current, kd({
            element: document.createElement("div"),
            minimumSize: (H = X?.minSize) != null ? H : o,
            maximumSize: (Y = X?.maxSize) != null ? Y : r,
            priority: (q = X?.priority) != null ? q : Fi.Normal
          }, X?.preferredSize && {
            preferredSize: X?.preferredSize
          }, {
            snap: (M = X?.snap) != null ? M : d
          }));
          return j.current.push(K), {
            container: [...R.current.values()][P],
            size: F,
            view: K
          };
        })
      }
    });
    N.current = new Xme(_.current, W, h, b, v), N.current.on("sashDragStart", () => {
      var F;
      (F = _.current) == null || F.classList.add("split-view-sash-dragging");
    }), N.current.on("sashDragEnd", () => {
      var F;
      (F = _.current) == null || F.classList.remove("split-view-sash-dragging");
    }), N.current.on("sashchange", (F) => {
      if (y && N.current) {
        const P = A.map((H) => H.key);
        for (let H = 0; H < P.length; H++) {
          const Y = C.current.get(P[H]);
          Y?.visible !== void 0 && Y.visible !== N.current.isViewVisible(H) && y(H, N.current.isViewVisible(H));
        }
      }
    }), N.current.on("sashreset", (F) => {
      if (g) g();
      else {
        var P;
        if (V(F) || V(F + 1)) return;
        (P = N.current) == null || P.distributeViewSizes();
      }
    });
    const D = N.current;
    return () => {
      D.dispose();
    };
  }, []), y4(() => {
    if (I) {
      const L = A.map((se) => se.key), ee = [...O.current], ae = L.filter((se) => !O.current.includes(se)), le = L.filter((se) => O.current.includes(se)), me = O.current.map((se) => !L.includes(se));
      for (let se = me.length - 1; se >= 0; se--) {
        var U;
        me[se] && ((U = N.current) != null && U.removeView(se), ee.splice(se, 1), j.current.splice(se, 1));
      }
      for (const se of ae) {
        var W, D, F, P, H;
        const he = C.current.get(se), _e = new O4(z.current, kd({
          element: document.createElement("div"),
          minimumSize: (W = he?.minSize) != null ? W : o,
          maximumSize: (D = he?.maxSize) != null ? D : r,
          priority: (F = he?.priority) != null ? F : Fi.Normal
        }, he?.preferredSize && {
          preferredSize: he?.preferredSize
        }, {
          snap: (P = he?.snap) != null ? P : d
        }));
        (H = N.current) != null && H.addView(R.current.get(se), _e, Mm.Distribute, L.findIndex((Se) => Se === se)), ee.splice(L.findIndex((Se) => Se === se), 0, se), j.current.splice(L.findIndex((Se) => Se === se), 0, _e);
      }
      for (; !Ame(L, ee); ) for (const [se, he] of L.entries()) {
        const _e = ee.findIndex((Se) => Se === he);
        if (_e !== se) {
          var Y;
          (Y = N.current) == null || Y.moveView(R.current.get(he), _e, se);
          const Se = ee[_e];
          ee.splice(_e, 1), ee.splice(se, 0, Se);
          break;
        }
      }
      for (const se of ae) {
        var q;
        const he = L.findIndex((Se) => Se === se), _e = j.current[he].preferredSize;
        _e !== void 0 && ((q = N.current) == null || q.resizeView(he, _e));
      }
      for (const se of [...ae, ...le]) {
        var M, X;
        const he = C.current.get(se), _e = L.findIndex((Se) => Se === se);
        he && A4(he) && he.visible !== void 0 && ((M = N.current) == null ? void 0 : M.isViewVisible(_e)) !== he.visible && ((X = N.current) == null || X.setViewVisible(_e, he.visible));
      }
      for (const se of le) {
        const he = C.current.get(se), _e = L.findIndex((Se) => Se === se);
        if (he && A4(he)) {
          var K;
          he.preferredSize !== void 0 && j.current[_e].preferredSize !== he.preferredSize && (j.current[_e].preferredSize = he.preferredSize);
          let Se = !1;
          he.minSize !== void 0 && j.current[_e].minimumSize !== he.minSize && (j.current[_e].minimumSize = he.minSize, Se = !0), he.maxSize !== void 0 && j.current[_e].maximumSize !== he.maxSize && (j.current[_e].maximumSize = he.maxSize, Se = !0), Se && ((K = N.current) == null || K.layout());
        }
      }
      (ae.length > 0 || me.length > 0) && (O.current = L);
    }
  }, [A, I, r, o, d]), S.useEffect(() => {
    N.current && (N.current.onDidChange = h);
  }, [h]), S.useEffect(() => {
    N.current && (N.current.onDidDragStart = b);
  }, [b]), S.useEffect(() => {
    N.current && (N.current.onDidDragEnd = v);
  }, [v]), Nme({
    ref: _,
    onResize: ({
      width: U,
      height: W
    }) => {
      var D;
      U && W && ((D = N.current) != null && D.layout(p ? W : U), z.current.setSize(p ? W : U), $(!0));
    }
  }), S.useEffect(() => {
    AD && Wme(20);
  }, []), Qe.createElement("div", {
    ref: _,
    className: tS("split-view", p ? "split-view-vertical" : "split-view-horizontal", {
      "split-view-separator-border": s
    }, Mme, p ? zme : Tme, {
      [Dme]: s
    }, t),
    id: n
  }, Qe.createElement("div", {
    className: tS("split-view-container", jme)
  }, Qe.Children.toArray(e).map((U) => {
    if (!Qe.isValidElement(U)) return null;
    const W = U.key;
    return U.type.displayName === "Allotment.Pane" ? (C.current.set(W, U.props), Qe.cloneElement(U, {
      key: W,
      ref: (D) => {
        const F = U.ref;
        F && (F.current = D), D ? R.current.set(W, D) : R.current.delete(W);
      }
    })) : Qe.createElement(b_, {
      key: W,
      ref: (D) => {
        D ? R.current.set(W, D) : R.current.delete(W);
      }
    }, U);
  })));
});
function Wme(e) {
  const t = Eo(e, 4, 20), n = Eo(e, 1, 8);
  document.documentElement.style.setProperty("--sash-size", t + "px"), document.documentElement.style.setProperty("--sash-hover-size", n + "px"), function(r) {
    ND = r, MD.emit("onDidChangeGlobalSize", r);
  }(t);
}
jD.displayName = "Allotment";
var Gme = Object.assign(jD, {
  Pane: b_
});
/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */
const Zme = {
  prefix: "fas",
  iconName: "circle-play",
  icon: [512, 512, [61469, "play-circle"], "f144", "M0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256zM188.3 147.1c-7.6 4.2-12.3 12.3-12.3 20.9l0 176c0 8.7 4.7 16.7 12.3 20.9s16.8 4.1 24.3-.5l144-88c7.1-4.4 11.5-12.1 11.5-20.5s-4.4-16.1-11.5-20.5l-144-88c-7.4-4.5-16.7-4.7-24.3-.5z"]
}, Kme = {
  prefix: "fas",
  iconName: "circle-pause",
  icon: [512, 512, [62092, "pause-circle"], "f28b", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM224 192l0 128c0 17.7-14.3 32-32 32s-32-14.3-32-32l0-128c0-17.7 14.3-32 32-32s32 14.3 32 32zm128 0l0 128c0 17.7-14.3 32-32 32s-32-14.3-32-32l0-128c0-17.7 14.3-32 32-32s32 14.3 32 32z"]
}, Qme = {
  prefix: "fas",
  iconName: "gears",
  icon: [640, 512, ["cogs"], "f085", "M308.5 135.3c7.1-6.3 9.9-16.2 6.2-25c-2.3-5.3-4.8-10.5-7.6-15.5L304 89.4c-3-5-6.3-9.9-9.8-14.6c-5.7-7.6-15.7-10.1-24.7-7.1l-28.2 9.3c-10.7-8.8-23-16-36.2-20.9L199 27.1c-1.9-9.3-9.1-16.7-18.5-17.8C173.9 8.4 167.2 8 160.4 8l-.7 0c-6.8 0-13.5 .4-20.1 1.2c-9.4 1.1-16.6 8.6-18.5 17.8L115 56.1c-13.3 5-25.5 12.1-36.2 20.9L50.5 67.8c-9-3-19-.5-24.7 7.1c-3.5 4.7-6.8 9.6-9.9 14.6l-3 5.3c-2.8 5-5.3 10.2-7.6 15.6c-3.7 8.7-.9 18.6 6.2 25l22.2 19.8C32.6 161.9 32 168.9 32 176s.6 14.1 1.7 20.9L11.5 216.7c-7.1 6.3-9.9 16.2-6.2 25c2.3 5.3 4.8 10.5 7.6 15.6l3 5.2c3 5.1 6.3 9.9 9.9 14.6c5.7 7.6 15.7 10.1 24.7 7.1l28.2-9.3c10.7 8.8 23 16 36.2 20.9l6.1 29.1c1.9 9.3 9.1 16.7 18.5 17.8c6.7 .8 13.5 1.2 20.4 1.2s13.7-.4 20.4-1.2c9.4-1.1 16.6-8.6 18.5-17.8l6.1-29.1c13.3-5 25.5-12.1 36.2-20.9l28.2 9.3c9 3 19 .5 24.7-7.1c3.5-4.7 6.8-9.5 9.8-14.6l3.1-5.4c2.8-5 5.3-10.2 7.6-15.5c3.7-8.7 .9-18.6-6.2-25l-22.2-19.8c1.1-6.8 1.7-13.8 1.7-20.9s-.6-14.1-1.7-20.9l22.2-19.8zM112 176a48 48 0 1 1 96 0 48 48 0 1 1 -96 0zM504.7 500.5c6.3 7.1 16.2 9.9 25 6.2c5.3-2.3 10.5-4.8 15.5-7.6l5.4-3.1c5-3 9.9-6.3 14.6-9.8c7.6-5.7 10.1-15.7 7.1-24.7l-9.3-28.2c8.8-10.7 16-23 20.9-36.2l29.1-6.1c9.3-1.9 16.7-9.1 17.8-18.5c.8-6.7 1.2-13.5 1.2-20.4s-.4-13.7-1.2-20.4c-1.1-9.4-8.6-16.6-17.8-18.5L583.9 307c-5-13.3-12.1-25.5-20.9-36.2l9.3-28.2c3-9 .5-19-7.1-24.7c-4.7-3.5-9.6-6.8-14.6-9.9l-5.3-3c-5-2.8-10.2-5.3-15.6-7.6c-8.7-3.7-18.6-.9-25 6.2l-19.8 22.2c-6.8-1.1-13.8-1.7-20.9-1.7s-14.1 .6-20.9 1.7l-19.8-22.2c-6.3-7.1-16.2-9.9-25-6.2c-5.3 2.3-10.5 4.8-15.6 7.6l-5.2 3c-5.1 3-9.9 6.3-14.6 9.9c-7.6 5.7-10.1 15.7-7.1 24.7l9.3 28.2c-8.8 10.7-16 23-20.9 36.2L315.1 313c-9.3 1.9-16.7 9.1-17.8 18.5c-.8 6.7-1.2 13.5-1.2 20.4s.4 13.7 1.2 20.4c1.1 9.4 8.6 16.6 17.8 18.5l29.1 6.1c5 13.3 12.1 25.5 20.9 36.2l-9.3 28.2c-3 9-.5 19 7.1 24.7c4.7 3.5 9.5 6.8 14.6 9.8l5.4 3.1c5 2.8 10.2 5.3 15.5 7.6c8.7 3.7 18.6 .9 25-6.2l19.8-22.2c6.8 1.1 13.8 1.7 20.9 1.7s14.1-.6 20.9-1.7l19.8 22.2zM464 304a48 48 0 1 1 0 96 48 48 0 1 1 0-96z"]
};
/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */
function Jme(e, t, n) {
  return (t = tge(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function N4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function be(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? N4(Object(n), !0).forEach(function(r) {
      Jme(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : N4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function ege(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function tge(e) {
  var t = ege(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
const M4 = () => {
};
let w_ = {}, zD = {}, TD = null, DD = {
  mark: M4,
  measure: M4
};
try {
  typeof window < "u" && (w_ = window), typeof document < "u" && (zD = document), typeof MutationObserver < "u" && (TD = MutationObserver), typeof performance < "u" && (DD = performance);
} catch {
}
const {
  userAgent: R4 = ""
} = w_.navigator || {}, as = w_, Pt = zD, j4 = TD, bh = DD;
as.document;
const ca = !!Pt.documentElement && !!Pt.head && typeof Pt.addEventListener == "function" && typeof Pt.createElement == "function", PD = ~R4.indexOf("MSIE") || ~R4.indexOf("Trident/");
var nge = /fa(s|r|l|t|d|dr|dl|dt|b|k|kd|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/, rge = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit)?.*/i, LD = {
  classic: {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fab: "brands",
    "fa-brands": "brands"
  },
  duotone: {
    fa: "solid",
    fad: "solid",
    "fa-solid": "solid",
    "fa-duotone": "solid",
    fadr: "regular",
    "fa-regular": "regular",
    fadl: "light",
    "fa-light": "light",
    fadt: "thin",
    "fa-thin": "thin"
  },
  sharp: {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular",
    fasl: "light",
    "fa-light": "light",
    fast: "thin",
    "fa-thin": "thin"
  },
  "sharp-duotone": {
    fa: "solid",
    fasds: "solid",
    "fa-solid": "solid",
    fasdr: "regular",
    "fa-regular": "regular",
    fasdl: "light",
    "fa-light": "light",
    fasdt: "thin",
    "fa-thin": "thin"
  }
}, oge = {
  GROUP: "duotone-group",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, ID = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"], $n = "classic", Yg = "duotone", ige = "sharp", age = "sharp-duotone", VD = [$n, Yg, ige, age], sge = {
  classic: {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  duotone: {
    900: "fad",
    400: "fadr",
    300: "fadl",
    100: "fadt"
  },
  sharp: {
    900: "fass",
    400: "fasr",
    300: "fasl",
    100: "fast"
  },
  "sharp-duotone": {
    900: "fasds",
    400: "fasdr",
    300: "fasdl",
    100: "fasdt"
  }
}, lge = {
  "Font Awesome 6 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 6 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  "Font Awesome 6 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 6 Duotone": {
    900: "fad",
    400: "fadr",
    normal: "fadr",
    300: "fadl",
    100: "fadt"
  },
  "Font Awesome 6 Sharp": {
    900: "fass",
    400: "fasr",
    normal: "fasr",
    300: "fasl",
    100: "fast"
  },
  "Font Awesome 6 Sharp Duotone": {
    900: "fasds",
    400: "fasdr",
    normal: "fasdr",
    300: "fasdl",
    100: "fasdt"
  }
}, uge = /* @__PURE__ */ new Map([["classic", {
  defaultShortPrefixId: "fas",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin", "brands"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp", {
  defaultShortPrefixId: "fass",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["duotone", {
  defaultShortPrefixId: "fad",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp-duotone", {
  defaultShortPrefixId: "fasds",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}]]), cge = {
  classic: {
    solid: "fas",
    regular: "far",
    light: "fal",
    thin: "fat",
    brands: "fab"
  },
  duotone: {
    solid: "fad",
    regular: "fadr",
    light: "fadl",
    thin: "fadt"
  },
  sharp: {
    solid: "fass",
    regular: "fasr",
    light: "fasl",
    thin: "fast"
  },
  "sharp-duotone": {
    solid: "fasds",
    regular: "fasdr",
    light: "fasdl",
    thin: "fasdt"
  }
}, dge = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], z4 = {
  kit: {
    fak: "kit",
    "fa-kit": "kit"
  },
  "kit-duotone": {
    fakd: "kit-duotone",
    "fa-kit-duotone": "kit-duotone"
  }
}, fge = ["kit"], pge = {
  kit: {
    "fa-kit": "fak"
  }
}, hge = ["fak", "fakd"], mge = {
  kit: {
    fak: "fa-kit"
  }
}, T4 = {
  kit: {
    kit: "fak"
  },
  "kit-duotone": {
    "kit-duotone": "fakd"
  }
}, wh = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, gge = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"], yge = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], vge = {
  "Font Awesome Kit": {
    400: "fak",
    normal: "fak"
  },
  "Font Awesome Kit Duotone": {
    400: "fakd",
    normal: "fakd"
  }
}, bge = {
  classic: {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
  },
  duotone: {
    "fa-regular": "fadr",
    "fa-light": "fadl",
    "fa-thin": "fadt"
  },
  sharp: {
    "fa-solid": "fass",
    "fa-regular": "fasr",
    "fa-light": "fasl",
    "fa-thin": "fast"
  },
  "sharp-duotone": {
    "fa-solid": "fasds",
    "fa-regular": "fasdr",
    "fa-light": "fasdl",
    "fa-thin": "fasdt"
  }
}, wge = {
  classic: ["fas", "far", "fal", "fat", "fad"],
  duotone: ["fadr", "fadl", "fadt"],
  sharp: ["fass", "fasr", "fasl", "fast"],
  "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"]
}, nS = {
  classic: {
    fab: "fa-brands",
    fad: "fa-duotone",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
  },
  duotone: {
    fadr: "fa-regular",
    fadl: "fa-light",
    fadt: "fa-thin"
  },
  sharp: {
    fass: "fa-solid",
    fasr: "fa-regular",
    fasl: "fa-light",
    fast: "fa-thin"
  },
  "sharp-duotone": {
    fasds: "fa-solid",
    fasdr: "fa-regular",
    fasdl: "fa-light",
    fasdt: "fa-thin"
  }
}, xge = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands"], rS = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", ...gge, ...xge], Sge = ["solid", "regular", "light", "thin", "duotone", "brands"], BD = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], _ge = BD.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), kge = [...Object.keys(wge), ...Sge, "2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", wh.GROUP, wh.SWAP_OPACITY, wh.PRIMARY, wh.SECONDARY].concat(BD.map((e) => "".concat(e, "x"))).concat(_ge.map((e) => "w-".concat(e))), Ege = {
  "Font Awesome 5 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 5 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal"
  },
  "Font Awesome 5 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 5 Duotone": {
    900: "fad"
  }
};
const ta = "___FONT_AWESOME___", oS = 16, FD = "fa", UD = "svg-inline--fa", al = "data-fa-i2svg", iS = "data-fa-pseudo-element", Cge = "data-fa-pseudo-element-pending", x_ = "data-prefix", S_ = "data-icon", D4 = "fontawesome-i2svg", Oge = "async", Age = ["HTML", "HEAD", "STYLE", "SCRIPT"], HD = (() => {
  try {
    return !0;
  } catch {
    return !1;
  }
})();
function Rf(e) {
  return new Proxy(e, {
    get(t, n) {
      return n in t ? t[n] : t[$n];
    }
  });
}
const $D = be({}, LD);
$D[$n] = be(be(be(be({}, {
  "fa-duotone": "duotone"
}), LD[$n]), z4.kit), z4["kit-duotone"]);
const Nge = Rf($D), aS = be({}, cge);
aS[$n] = be(be(be(be({}, {
  duotone: "fad"
}), aS[$n]), T4.kit), T4["kit-duotone"]);
const P4 = Rf(aS), sS = be({}, nS);
sS[$n] = be(be({}, sS[$n]), mge.kit);
const __ = Rf(sS), lS = be({}, bge);
lS[$n] = be(be({}, lS[$n]), pge.kit);
Rf(lS);
const Mge = nge, YD = "fa-layers-text", Rge = rge, jge = be({}, sge);
Rf(jge);
const zge = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], _w = oge, Tge = [...fge, ...kge], Ed = as.FontAwesomeConfig || {};
function Dge(e) {
  var t = Pt.querySelector("script[" + e + "]");
  if (t)
    return t.getAttribute(e);
}
function Pge(e) {
  return e === "" ? !0 : e === "false" ? !1 : e === "true" ? !0 : e;
}
Pt && typeof Pt.querySelector == "function" && [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]].forEach((t) => {
  let [n, r] = t;
  const o = Pge(Dge(n));
  o != null && (Ed[r] = o);
});
const qD = {
  styleDefault: "solid",
  familyDefault: $n,
  cssPrefix: FD,
  replacementClass: UD,
  autoReplaceSvg: !0,
  autoAddCss: !0,
  autoA11y: !0,
  searchPseudoElements: !1,
  observeMutations: !0,
  mutateApproach: "async",
  keepOriginalSource: !0,
  measurePerformance: !1,
  showMissingIcons: !0
};
Ed.familyPrefix && (Ed.cssPrefix = Ed.familyPrefix);
const Vu = be(be({}, qD), Ed);
Vu.autoReplaceSvg || (Vu.observeMutations = !1);
const Me = {};
Object.keys(qD).forEach((e) => {
  Object.defineProperty(Me, e, {
    enumerable: !0,
    set: function(t) {
      Vu[e] = t, Cd.forEach((n) => n(Me));
    },
    get: function() {
      return Vu[e];
    }
  });
});
Object.defineProperty(Me, "familyPrefix", {
  enumerable: !0,
  set: function(e) {
    Vu.cssPrefix = e, Cd.forEach((t) => t(Me));
  },
  get: function() {
    return Vu.cssPrefix;
  }
});
as.FontAwesomeConfig = Me;
const Cd = [];
function Lge(e) {
  return Cd.push(e), () => {
    Cd.splice(Cd.indexOf(e), 1);
  };
}
const Ua = oS, si = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: !1,
  flipY: !1
};
function Ige(e) {
  if (!e || !ca)
    return;
  const t = Pt.createElement("style");
  t.setAttribute("type", "text/css"), t.innerHTML = e;
  const n = Pt.head.childNodes;
  let r = null;
  for (let o = n.length - 1; o > -1; o--) {
    const i = n[o], s = (i.tagName || "").toUpperCase();
    ["STYLE", "LINK"].indexOf(s) > -1 && (r = i);
  }
  return Pt.head.insertBefore(t, r), e;
}
const Vge = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function ef() {
  let e = 12, t = "";
  for (; e-- > 0; )
    t += Vge[Math.random() * 62 | 0];
  return t;
}
function Qu(e) {
  const t = [];
  for (let n = (e || []).length >>> 0; n--; )
    t[n] = e[n];
  return t;
}
function k_(e) {
  return e.classList ? Qu(e.classList) : (e.getAttribute("class") || "").split(" ").filter((t) => t);
}
function XD(e) {
  return "".concat(e).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function Bge(e) {
  return Object.keys(e || {}).reduce((t, n) => t + "".concat(n, '="').concat(XD(e[n]), '" '), "").trim();
}
function qg(e) {
  return Object.keys(e || {}).reduce((t, n) => t + "".concat(n, ": ").concat(e[n].trim(), ";"), "");
}
function E_(e) {
  return e.size !== si.size || e.x !== si.x || e.y !== si.y || e.rotate !== si.rotate || e.flipX || e.flipY;
}
function Fge(e) {
  let {
    transform: t,
    containerWidth: n,
    iconWidth: r
  } = e;
  const o = {
    transform: "translate(".concat(n / 2, " 256)")
  }, i = "translate(".concat(t.x * 32, ", ").concat(t.y * 32, ") "), s = "scale(".concat(t.size / 16 * (t.flipX ? -1 : 1), ", ").concat(t.size / 16 * (t.flipY ? -1 : 1), ") "), u = "rotate(".concat(t.rotate, " 0 0)"), c = {
    transform: "".concat(i, " ").concat(s, " ").concat(u)
  }, d = {
    transform: "translate(".concat(r / 2 * -1, " -256)")
  };
  return {
    outer: o,
    inner: c,
    path: d
  };
}
function Uge(e) {
  let {
    transform: t,
    width: n = oS,
    height: r = oS,
    startCentered: o = !1
  } = e, i = "";
  return o && PD ? i += "translate(".concat(t.x / Ua - n / 2, "em, ").concat(t.y / Ua - r / 2, "em) ") : o ? i += "translate(calc(-50% + ".concat(t.x / Ua, "em), calc(-50% + ").concat(t.y / Ua, "em)) ") : i += "translate(".concat(t.x / Ua, "em, ").concat(t.y / Ua, "em) "), i += "scale(".concat(t.size / Ua * (t.flipX ? -1 : 1), ", ").concat(t.size / Ua * (t.flipY ? -1 : 1), ") "), i += "rotate(".concat(t.rotate, "deg) "), i;
}
var Hge = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 6 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 6 Sharp Duotone";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    animation-delay: -1ms;
    animation-duration: 1ms;
    animation-iteration-count: 1;
    transition-delay: 0s;
    transition-duration: 0s;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}`;
function WD() {
  const e = FD, t = UD, n = Me.cssPrefix, r = Me.replacementClass;
  let o = Hge;
  if (n !== e || r !== t) {
    const i = new RegExp("\\.".concat(e, "\\-"), "g"), s = new RegExp("\\--".concat(e, "\\-"), "g"), u = new RegExp("\\.".concat(t), "g");
    o = o.replace(i, ".".concat(n, "-")).replace(s, "--".concat(n, "-")).replace(u, ".".concat(r));
  }
  return o;
}
let L4 = !1;
function kw() {
  Me.autoAddCss && !L4 && (Ige(WD()), L4 = !0);
}
var $ge = {
  mixout() {
    return {
      dom: {
        css: WD,
        insertCss: kw
      }
    };
  },
  hooks() {
    return {
      beforeDOMElementCreation() {
        kw();
      },
      beforeI2svg() {
        kw();
      }
    };
  }
};
const na = as || {};
na[ta] || (na[ta] = {});
na[ta].styles || (na[ta].styles = {});
na[ta].hooks || (na[ta].hooks = {});
na[ta].shims || (na[ta].shims = []);
var li = na[ta];
const GD = [], ZD = function() {
  Pt.removeEventListener("DOMContentLoaded", ZD), Rm = 1, GD.map((e) => e());
};
let Rm = !1;
ca && (Rm = (Pt.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(Pt.readyState), Rm || Pt.addEventListener("DOMContentLoaded", ZD));
function Yge(e) {
  ca && (Rm ? setTimeout(e, 0) : GD.push(e));
}
function jf(e) {
  const {
    tag: t,
    attributes: n = {},
    children: r = []
  } = e;
  return typeof e == "string" ? XD(e) : "<".concat(t, " ").concat(Bge(n), ">").concat(r.map(jf).join(""), "</").concat(t, ">");
}
function I4(e, t, n) {
  if (e && e[t] && e[t][n])
    return {
      prefix: t,
      iconName: n,
      icon: e[t][n]
    };
}
var Ew = function(t, n, r, o) {
  var i = Object.keys(t), s = i.length, u = n, c, d, p;
  for (r === void 0 ? (c = 1, p = t[i[0]]) : (c = 0, p = r); c < s; c++)
    d = i[c], p = u(p, t[d], d, t);
  return p;
};
function qge(e) {
  const t = [];
  let n = 0;
  const r = e.length;
  for (; n < r; ) {
    const o = e.charCodeAt(n++);
    if (o >= 55296 && o <= 56319 && n < r) {
      const i = e.charCodeAt(n++);
      (i & 64512) == 56320 ? t.push(((o & 1023) << 10) + (i & 1023) + 65536) : (t.push(o), n--);
    } else
      t.push(o);
  }
  return t;
}
function uS(e) {
  const t = qge(e);
  return t.length === 1 ? t[0].toString(16) : null;
}
function Xge(e, t) {
  const n = e.length;
  let r = e.charCodeAt(t), o;
  return r >= 55296 && r <= 56319 && n > t + 1 && (o = e.charCodeAt(t + 1), o >= 56320 && o <= 57343) ? (r - 55296) * 1024 + o - 56320 + 65536 : r;
}
function V4(e) {
  return Object.keys(e).reduce((t, n) => {
    const r = e[n];
    return !!r.icon ? t[r.iconName] = r.icon : t[n] = r, t;
  }, {});
}
function cS(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    skipHooks: r = !1
  } = n, o = V4(t);
  typeof li.hooks.addPack == "function" && !r ? li.hooks.addPack(e, V4(t)) : li.styles[e] = be(be({}, li.styles[e] || {}), o), e === "fas" && cS("fa", t);
}
const {
  styles: tf,
  shims: Wge
} = li, KD = Object.keys(__), Gge = KD.reduce((e, t) => (e[t] = Object.keys(__[t]), e), {});
let C_ = null, QD = {}, JD = {}, eP = {}, tP = {}, nP = {};
function Zge(e) {
  return ~Tge.indexOf(e);
}
function Kge(e, t) {
  const n = t.split("-"), r = n[0], o = n.slice(1).join("-");
  return r === e && o !== "" && !Zge(o) ? o : null;
}
const rP = () => {
  const e = (r) => Ew(tf, (o, i, s) => (o[s] = Ew(i, r, {}), o), {});
  QD = e((r, o, i) => (o[3] && (r[o[3]] = i), o[2] && o[2].filter((u) => typeof u == "number").forEach((u) => {
    r[u.toString(16)] = i;
  }), r)), JD = e((r, o, i) => (r[i] = i, o[2] && o[2].filter((u) => typeof u == "string").forEach((u) => {
    r[u] = i;
  }), r)), nP = e((r, o, i) => {
    const s = o[2];
    return r[i] = i, s.forEach((u) => {
      r[u] = i;
    }), r;
  });
  const t = "far" in tf || Me.autoFetchSvg, n = Ew(Wge, (r, o) => {
    const i = o[0];
    let s = o[1];
    const u = o[2];
    return s === "far" && !t && (s = "fas"), typeof i == "string" && (r.names[i] = {
      prefix: s,
      iconName: u
    }), typeof i == "number" && (r.unicodes[i.toString(16)] = {
      prefix: s,
      iconName: u
    }), r;
  }, {
    names: {},
    unicodes: {}
  });
  eP = n.names, tP = n.unicodes, C_ = Xg(Me.styleDefault, {
    family: Me.familyDefault
  });
};
Lge((e) => {
  C_ = Xg(e.styleDefault, {
    family: Me.familyDefault
  });
});
rP();
function O_(e, t) {
  return (QD[e] || {})[t];
}
function Qge(e, t) {
  return (JD[e] || {})[t];
}
function Ys(e, t) {
  return (nP[e] || {})[t];
}
function oP(e) {
  return eP[e] || {
    prefix: null,
    iconName: null
  };
}
function Jge(e) {
  const t = tP[e], n = O_("fas", e);
  return t || (n ? {
    prefix: "fas",
    iconName: n
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function ss() {
  return C_;
}
const iP = () => ({
  prefix: null,
  iconName: null,
  rest: []
});
function eye(e) {
  let t = $n;
  const n = KD.reduce((r, o) => (r[o] = "".concat(Me.cssPrefix, "-").concat(o), r), {});
  return VD.forEach((r) => {
    (e.includes(n[r]) || e.some((o) => Gge[r].includes(o))) && (t = r);
  }), t;
}
function Xg(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    family: n = $n
  } = t, r = Nge[n][e];
  if (n === Yg && !e)
    return "fad";
  const o = P4[n][e] || P4[n][r], i = e in li.styles ? e : null;
  return o || i || null;
}
function tye(e) {
  let t = [], n = null;
  return e.forEach((r) => {
    const o = Kge(Me.cssPrefix, r);
    o ? n = o : r && t.push(r);
  }), {
    iconName: n,
    rest: t
  };
}
function B4(e) {
  return e.sort().filter((t, n, r) => r.indexOf(t) === n);
}
function Wg(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    skipLookups: n = !1
  } = t;
  let r = null;
  const o = rS.concat(yge), i = B4(e.filter((h) => o.includes(h))), s = B4(e.filter((h) => !rS.includes(h))), u = i.filter((h) => (r = h, !ID.includes(h))), [c = null] = u, d = eye(i), p = be(be({}, tye(s)), {}, {
    prefix: Xg(c, {
      family: d
    })
  });
  return be(be(be({}, p), iye({
    values: e,
    family: d,
    styles: tf,
    config: Me,
    canonical: p,
    givenPrefix: r
  })), nye(n, r, p));
}
function nye(e, t, n) {
  let {
    prefix: r,
    iconName: o
  } = n;
  if (e || !r || !o)
    return {
      prefix: r,
      iconName: o
    };
  const i = t === "fa" ? oP(o) : {}, s = Ys(r, o);
  return o = i.iconName || s || o, r = i.prefix || r, r === "far" && !tf.far && tf.fas && !Me.autoFetchSvg && (r = "fas"), {
    prefix: r,
    iconName: o
  };
}
const rye = VD.filter((e) => e !== $n || e !== Yg), oye = Object.keys(nS).filter((e) => e !== $n).map((e) => Object.keys(nS[e])).flat();
function iye(e) {
  const {
    values: t,
    family: n,
    canonical: r,
    givenPrefix: o = "",
    styles: i = {},
    config: s = {}
  } = e, u = n === Yg, c = t.includes("fa-duotone") || t.includes("fad"), d = s.familyDefault === "duotone", p = r.prefix === "fad" || r.prefix === "fa-duotone";
  if (!u && (c || d || p) && (r.prefix = "fad"), (t.includes("fa-brands") || t.includes("fab")) && (r.prefix = "fab"), !r.prefix && rye.includes(n) && (Object.keys(i).find((g) => oye.includes(g)) || s.autoFetchSvg)) {
    const g = uge.get(n).defaultShortPrefixId;
    r.prefix = g, r.iconName = Ys(r.prefix, r.iconName) || r.iconName;
  }
  return (r.prefix === "fa" || o === "fa") && (r.prefix = ss() || "fas"), r;
}
class aye {
  constructor() {
    this.definitions = {};
  }
  add() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r];
    const o = n.reduce(this._pullDefinitions, {});
    Object.keys(o).forEach((i) => {
      this.definitions[i] = be(be({}, this.definitions[i] || {}), o[i]), cS(i, o[i]);
      const s = __[$n][i];
      s && cS(s, o[i]), rP();
    });
  }
  reset() {
    this.definitions = {};
  }
  _pullDefinitions(t, n) {
    const r = n.prefix && n.iconName && n.icon ? {
      0: n
    } : n;
    return Object.keys(r).map((o) => {
      const {
        prefix: i,
        iconName: s,
        icon: u
      } = r[o], c = u[2];
      t[i] || (t[i] = {}), c.length > 0 && c.forEach((d) => {
        typeof d == "string" && (t[i][d] = u);
      }), t[i][s] = u;
    }), t;
  }
}
let F4 = [], pu = {};
const ku = {}, sye = Object.keys(ku);
function lye(e, t) {
  let {
    mixoutsTo: n
  } = t;
  return F4 = e, pu = {}, Object.keys(ku).forEach((r) => {
    sye.indexOf(r) === -1 && delete ku[r];
  }), F4.forEach((r) => {
    const o = r.mixout ? r.mixout() : {};
    if (Object.keys(o).forEach((i) => {
      typeof o[i] == "function" && (n[i] = o[i]), typeof o[i] == "object" && Object.keys(o[i]).forEach((s) => {
        n[i] || (n[i] = {}), n[i][s] = o[i][s];
      });
    }), r.hooks) {
      const i = r.hooks();
      Object.keys(i).forEach((s) => {
        pu[s] || (pu[s] = []), pu[s].push(i[s]);
      });
    }
    r.provides && r.provides(ku);
  }), n;
}
function dS(e, t) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
    r[o - 2] = arguments[o];
  return (pu[e] || []).forEach((s) => {
    t = s.apply(null, [t, ...r]);
  }), t;
}
function sl(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  (pu[e] || []).forEach((i) => {
    i.apply(null, n);
  });
}
function ls() {
  const e = arguments[0], t = Array.prototype.slice.call(arguments, 1);
  return ku[e] ? ku[e].apply(null, t) : void 0;
}
function fS(e) {
  e.prefix === "fa" && (e.prefix = "fas");
  let {
    iconName: t
  } = e;
  const n = e.prefix || ss();
  if (t)
    return t = Ys(n, t) || t, I4(aP.definitions, n, t) || I4(li.styles, n, t);
}
const aP = new aye(), uye = () => {
  Me.autoReplaceSvg = !1, Me.observeMutations = !1, sl("noAuto");
}, cye = {
  i2svg: function() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return ca ? (sl("beforeI2svg", e), ls("pseudoElements2svg", e), ls("i2svg", e)) : Promise.reject(new Error("Operation requires a DOM of some kind."));
  },
  watch: function() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      autoReplaceSvgRoot: t
    } = e;
    Me.autoReplaceSvg === !1 && (Me.autoReplaceSvg = !0), Me.observeMutations = !0, Yge(() => {
      fye({
        autoReplaceSvgRoot: t
      }), sl("watch", e);
    });
  }
}, dye = {
  icon: (e) => {
    if (e === null)
      return null;
    if (typeof e == "object" && e.prefix && e.iconName)
      return {
        prefix: e.prefix,
        iconName: Ys(e.prefix, e.iconName) || e.iconName
      };
    if (Array.isArray(e) && e.length === 2) {
      const t = e[1].indexOf("fa-") === 0 ? e[1].slice(3) : e[1], n = Xg(e[0]);
      return {
        prefix: n,
        iconName: Ys(n, t) || t
      };
    }
    if (typeof e == "string" && (e.indexOf("".concat(Me.cssPrefix, "-")) > -1 || e.match(Mge))) {
      const t = Wg(e.split(" "), {
        skipLookups: !0
      });
      return {
        prefix: t.prefix || ss(),
        iconName: Ys(t.prefix, t.iconName) || t.iconName
      };
    }
    if (typeof e == "string") {
      const t = ss();
      return {
        prefix: t,
        iconName: Ys(t, e) || e
      };
    }
  }
}, Yr = {
  noAuto: uye,
  config: Me,
  dom: cye,
  parse: dye,
  library: aP,
  findIconDefinition: fS,
  toHtml: jf
}, fye = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    autoReplaceSvgRoot: t = Pt
  } = e;
  (Object.keys(li.styles).length > 0 || Me.autoFetchSvg) && ca && Me.autoReplaceSvg && Yr.dom.i2svg({
    node: t
  });
};
function Gg(e, t) {
  return Object.defineProperty(e, "abstract", {
    get: t
  }), Object.defineProperty(e, "html", {
    get: function() {
      return e.abstract.map((n) => jf(n));
    }
  }), Object.defineProperty(e, "node", {
    get: function() {
      if (!ca) return;
      const n = Pt.createElement("div");
      return n.innerHTML = e.html, n.children;
    }
  }), e;
}
function pye(e) {
  let {
    children: t,
    main: n,
    mask: r,
    attributes: o,
    styles: i,
    transform: s
  } = e;
  if (E_(s) && n.found && !r.found) {
    const {
      width: u,
      height: c
    } = n, d = {
      x: u / c / 2,
      y: 0.5
    };
    o.style = qg(be(be({}, i), {}, {
      "transform-origin": "".concat(d.x + s.x / 16, "em ").concat(d.y + s.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes: o,
    children: t
  }];
}
function hye(e) {
  let {
    prefix: t,
    iconName: n,
    children: r,
    attributes: o,
    symbol: i
  } = e;
  const s = i === !0 ? "".concat(t, "-").concat(Me.cssPrefix, "-").concat(n) : i;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: be(be({}, o), {}, {
        id: s
      }),
      children: r
    }]
  }];
}
function A_(e) {
  const {
    icons: {
      main: t,
      mask: n
    },
    prefix: r,
    iconName: o,
    transform: i,
    symbol: s,
    title: u,
    maskId: c,
    titleId: d,
    extra: p,
    watchable: h = !1
  } = e, {
    width: g,
    height: y
  } = n.found ? n : t, b = hge.includes(r), v = [Me.replacementClass, o ? "".concat(Me.cssPrefix, "-").concat(o) : ""].filter((R) => p.classes.indexOf(R) === -1).filter((R) => R !== "" || !!R).concat(p.classes).join(" ");
  let x = {
    children: [],
    attributes: be(be({}, p.attributes), {}, {
      "data-prefix": r,
      "data-icon": o,
      class: v,
      role: p.attributes.role || "img",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 ".concat(g, " ").concat(y)
    })
  };
  const _ = b && !~p.classes.indexOf("fa-fw") ? {
    width: "".concat(g / y * 16 * 0.0625, "em")
  } : {};
  h && (x.attributes[al] = ""), u && (x.children.push({
    tag: "title",
    attributes: {
      id: x.attributes["aria-labelledby"] || "title-".concat(d || ef())
    },
    children: [u]
  }), delete x.attributes.title);
  const O = be(be({}, x), {}, {
    prefix: r,
    iconName: o,
    main: t,
    mask: n,
    maskId: c,
    transform: i,
    symbol: s,
    styles: be(be({}, _), p.styles)
  }), {
    children: C,
    attributes: N
  } = n.found && t.found ? ls("generateAbstractMask", O) || {
    children: [],
    attributes: {}
  } : ls("generateAbstractIcon", O) || {
    children: [],
    attributes: {}
  };
  return O.children = C, O.attributes = N, s ? hye(O) : pye(O);
}
function U4(e) {
  const {
    content: t,
    width: n,
    height: r,
    transform: o,
    title: i,
    extra: s,
    watchable: u = !1
  } = e, c = be(be(be({}, s.attributes), i ? {
    title: i
  } : {}), {}, {
    class: s.classes.join(" ")
  });
  u && (c[al] = "");
  const d = be({}, s.styles);
  E_(o) && (d.transform = Uge({
    transform: o,
    startCentered: !0,
    width: n,
    height: r
  }), d["-webkit-transform"] = d.transform);
  const p = qg(d);
  p.length > 0 && (c.style = p);
  const h = [];
  return h.push({
    tag: "span",
    attributes: c,
    children: [t]
  }), i && h.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [i]
  }), h;
}
function mye(e) {
  const {
    content: t,
    title: n,
    extra: r
  } = e, o = be(be(be({}, r.attributes), n ? {
    title: n
  } : {}), {}, {
    class: r.classes.join(" ")
  }), i = qg(r.styles);
  i.length > 0 && (o.style = i);
  const s = [];
  return s.push({
    tag: "span",
    attributes: o,
    children: [t]
  }), n && s.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [n]
  }), s;
}
const {
  styles: Cw
} = li;
function pS(e) {
  const t = e[0], n = e[1], [r] = e.slice(4);
  let o = null;
  return Array.isArray(r) ? o = {
    tag: "g",
    attributes: {
      class: "".concat(Me.cssPrefix, "-").concat(_w.GROUP)
    },
    children: [{
      tag: "path",
      attributes: {
        class: "".concat(Me.cssPrefix, "-").concat(_w.SECONDARY),
        fill: "currentColor",
        d: r[0]
      }
    }, {
      tag: "path",
      attributes: {
        class: "".concat(Me.cssPrefix, "-").concat(_w.PRIMARY),
        fill: "currentColor",
        d: r[1]
      }
    }]
  } : o = {
    tag: "path",
    attributes: {
      fill: "currentColor",
      d: r
    }
  }, {
    found: !0,
    width: t,
    height: n,
    icon: o
  };
}
const gye = {
  found: !1,
  width: 512,
  height: 512
};
function yye(e, t) {
  !HD && !Me.showMissingIcons && e && console.error('Icon with name "'.concat(e, '" and prefix "').concat(t, '" is missing.'));
}
function hS(e, t) {
  let n = t;
  return t === "fa" && Me.styleDefault !== null && (t = ss()), new Promise((r, o) => {
    if (n === "fa") {
      const i = oP(e) || {};
      e = i.iconName || e, t = i.prefix || t;
    }
    if (e && t && Cw[t] && Cw[t][e]) {
      const i = Cw[t][e];
      return r(pS(i));
    }
    yye(e, t), r(be(be({}, gye), {}, {
      icon: Me.showMissingIcons && e ? ls("missingIconAbstract") || {} : {}
    }));
  });
}
const H4 = () => {
}, mS = Me.measurePerformance && bh && bh.mark && bh.measure ? bh : {
  mark: H4,
  measure: H4
}, hd = 'FA "6.7.2"', vye = (e) => (mS.mark("".concat(hd, " ").concat(e, " begins")), () => sP(e)), sP = (e) => {
  mS.mark("".concat(hd, " ").concat(e, " ends")), mS.measure("".concat(hd, " ").concat(e), "".concat(hd, " ").concat(e, " begins"), "".concat(hd, " ").concat(e, " ends"));
};
var N_ = {
  begin: vye,
  end: sP
};
const Uh = () => {
};
function $4(e) {
  return typeof (e.getAttribute ? e.getAttribute(al) : null) == "string";
}
function bye(e) {
  const t = e.getAttribute ? e.getAttribute(x_) : null, n = e.getAttribute ? e.getAttribute(S_) : null;
  return t && n;
}
function wye(e) {
  return e && e.classList && e.classList.contains && e.classList.contains(Me.replacementClass);
}
function xye() {
  return Me.autoReplaceSvg === !0 ? Hh.replace : Hh[Me.autoReplaceSvg] || Hh.replace;
}
function Sye(e) {
  return Pt.createElementNS("http://www.w3.org/2000/svg", e);
}
function _ye(e) {
  return Pt.createElement(e);
}
function lP(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    ceFn: n = e.tag === "svg" ? Sye : _ye
  } = t;
  if (typeof e == "string")
    return Pt.createTextNode(e);
  const r = n(e.tag);
  return Object.keys(e.attributes || []).forEach(function(i) {
    r.setAttribute(i, e.attributes[i]);
  }), (e.children || []).forEach(function(i) {
    r.appendChild(lP(i, {
      ceFn: n
    }));
  }), r;
}
function kye(e) {
  let t = " ".concat(e.outerHTML, " ");
  return t = "".concat(t, "Font Awesome fontawesome.com "), t;
}
const Hh = {
  replace: function(e) {
    const t = e[0];
    if (t.parentNode)
      if (e[1].forEach((n) => {
        t.parentNode.insertBefore(lP(n), t);
      }), t.getAttribute(al) === null && Me.keepOriginalSource) {
        let n = Pt.createComment(kye(t));
        t.parentNode.replaceChild(n, t);
      } else
        t.remove();
  },
  nest: function(e) {
    const t = e[0], n = e[1];
    if (~k_(t).indexOf(Me.replacementClass))
      return Hh.replace(e);
    const r = new RegExp("".concat(Me.cssPrefix, "-.*"));
    if (delete n[0].attributes.id, n[0].attributes.class) {
      const i = n[0].attributes.class.split(" ").reduce((s, u) => (u === Me.replacementClass || u.match(r) ? s.toSvg.push(u) : s.toNode.push(u), s), {
        toNode: [],
        toSvg: []
      });
      n[0].attributes.class = i.toSvg.join(" "), i.toNode.length === 0 ? t.removeAttribute("class") : t.setAttribute("class", i.toNode.join(" "));
    }
    const o = n.map((i) => jf(i)).join(`
`);
    t.setAttribute(al, ""), t.innerHTML = o;
  }
};
function Y4(e) {
  e();
}
function uP(e, t) {
  const n = typeof t == "function" ? t : Uh;
  if (e.length === 0)
    n();
  else {
    let r = Y4;
    Me.mutateApproach === Oge && (r = as.requestAnimationFrame || Y4), r(() => {
      const o = xye(), i = N_.begin("mutate");
      e.map(o), i(), n();
    });
  }
}
let M_ = !1;
function cP() {
  M_ = !0;
}
function gS() {
  M_ = !1;
}
let jm = null;
function q4(e) {
  if (!j4 || !Me.observeMutations)
    return;
  const {
    treeCallback: t = Uh,
    nodeCallback: n = Uh,
    pseudoElementsCallback: r = Uh,
    observeMutationsRoot: o = Pt
  } = e;
  jm = new j4((i) => {
    if (M_) return;
    const s = ss();
    Qu(i).forEach((u) => {
      if (u.type === "childList" && u.addedNodes.length > 0 && !$4(u.addedNodes[0]) && (Me.searchPseudoElements && r(u.target), t(u.target)), u.type === "attributes" && u.target.parentNode && Me.searchPseudoElements && r(u.target.parentNode), u.type === "attributes" && $4(u.target) && ~zge.indexOf(u.attributeName))
        if (u.attributeName === "class" && bye(u.target)) {
          const {
            prefix: c,
            iconName: d
          } = Wg(k_(u.target));
          u.target.setAttribute(x_, c || s), d && u.target.setAttribute(S_, d);
        } else wye(u.target) && n(u.target);
    });
  }), ca && jm.observe(o, {
    childList: !0,
    attributes: !0,
    characterData: !0,
    subtree: !0
  });
}
function Eye() {
  jm && jm.disconnect();
}
function Cye(e) {
  const t = e.getAttribute("style");
  let n = [];
  return t && (n = t.split(";").reduce((r, o) => {
    const i = o.split(":"), s = i[0], u = i.slice(1);
    return s && u.length > 0 && (r[s] = u.join(":").trim()), r;
  }, {})), n;
}
function Oye(e) {
  const t = e.getAttribute("data-prefix"), n = e.getAttribute("data-icon"), r = e.innerText !== void 0 ? e.innerText.trim() : "";
  let o = Wg(k_(e));
  return o.prefix || (o.prefix = ss()), t && n && (o.prefix = t, o.iconName = n), o.iconName && o.prefix || (o.prefix && r.length > 0 && (o.iconName = Qge(o.prefix, e.innerText) || O_(o.prefix, uS(e.innerText))), !o.iconName && Me.autoFetchSvg && e.firstChild && e.firstChild.nodeType === Node.TEXT_NODE && (o.iconName = e.firstChild.data)), o;
}
function Aye(e) {
  const t = Qu(e.attributes).reduce((o, i) => (o.name !== "class" && o.name !== "style" && (o[i.name] = i.value), o), {}), n = e.getAttribute("title"), r = e.getAttribute("data-fa-title-id");
  return Me.autoA11y && (n ? t["aria-labelledby"] = "".concat(Me.replacementClass, "-title-").concat(r || ef()) : (t["aria-hidden"] = "true", t.focusable = "false")), t;
}
function Nye() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: si,
    symbol: !1,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function X4(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: !0
  };
  const {
    iconName: n,
    prefix: r,
    rest: o
  } = Oye(e), i = Aye(e), s = dS("parseNodeAttributes", {}, e);
  let u = t.styleParser ? Cye(e) : [];
  return be({
    iconName: n,
    title: e.getAttribute("title"),
    titleId: e.getAttribute("data-fa-title-id"),
    prefix: r,
    transform: si,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: !1,
    extra: {
      classes: o,
      styles: u,
      attributes: i
    }
  }, s);
}
const {
  styles: Mye
} = li;
function dP(e) {
  const t = Me.autoReplaceSvg === "nest" ? X4(e, {
    styleParser: !1
  }) : X4(e);
  return ~t.extra.classes.indexOf(YD) ? ls("generateLayersText", e, t) : ls("generateSvgReplacementMutation", e, t);
}
function Rye() {
  return [...dge, ...rS];
}
function W4(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!ca) return Promise.resolve();
  const n = Pt.documentElement.classList, r = (p) => n.add("".concat(D4, "-").concat(p)), o = (p) => n.remove("".concat(D4, "-").concat(p)), i = Me.autoFetchSvg ? Rye() : ID.concat(Object.keys(Mye));
  i.includes("fa") || i.push("fa");
  const s = [".".concat(YD, ":not([").concat(al, "])")].concat(i.map((p) => ".".concat(p, ":not([").concat(al, "])"))).join(", ");
  if (s.length === 0)
    return Promise.resolve();
  let u = [];
  try {
    u = Qu(e.querySelectorAll(s));
  } catch {
  }
  if (u.length > 0)
    r("pending"), o("complete");
  else
    return Promise.resolve();
  const c = N_.begin("onTree"), d = u.reduce((p, h) => {
    try {
      const g = dP(h);
      g && p.push(g);
    } catch (g) {
      HD || g.name === "MissingIcon" && console.error(g);
    }
    return p;
  }, []);
  return new Promise((p, h) => {
    Promise.all(d).then((g) => {
      uP(g, () => {
        r("active"), r("complete"), o("pending"), typeof t == "function" && t(), c(), p();
      });
    }).catch((g) => {
      c(), h(g);
    });
  });
}
function jye(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  dP(e).then((n) => {
    n && uP([n], t);
  });
}
function zye(e) {
  return function(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = (t || {}).icon ? t : fS(t || {});
    let {
      mask: o
    } = n;
    return o && (o = (o || {}).icon ? o : fS(o || {})), e(r, be(be({}, n), {}, {
      mask: o
    }));
  };
}
const Tye = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    transform: n = si,
    symbol: r = !1,
    mask: o = null,
    maskId: i = null,
    title: s = null,
    titleId: u = null,
    classes: c = [],
    attributes: d = {},
    styles: p = {}
  } = t;
  if (!e) return;
  const {
    prefix: h,
    iconName: g,
    icon: y
  } = e;
  return Gg(be({
    type: "icon"
  }, e), () => (sl("beforeDOMElementCreation", {
    iconDefinition: e,
    params: t
  }), Me.autoA11y && (s ? d["aria-labelledby"] = "".concat(Me.replacementClass, "-title-").concat(u || ef()) : (d["aria-hidden"] = "true", d.focusable = "false")), A_({
    icons: {
      main: pS(y),
      mask: o ? pS(o.icon) : {
        found: !1,
        width: null,
        height: null,
        icon: {}
      }
    },
    prefix: h,
    iconName: g,
    transform: be(be({}, si), n),
    symbol: r,
    title: s,
    maskId: i,
    titleId: u,
    extra: {
      attributes: d,
      styles: p,
      classes: c
    }
  })));
};
var Dye = {
  mixout() {
    return {
      icon: zye(Tye)
    };
  },
  hooks() {
    return {
      mutationObserverCallbacks(e) {
        return e.treeCallback = W4, e.nodeCallback = jye, e;
      }
    };
  },
  provides(e) {
    e.i2svg = function(t) {
      const {
        node: n = Pt,
        callback: r = () => {
        }
      } = t;
      return W4(n, r);
    }, e.generateSvgReplacementMutation = function(t, n) {
      const {
        iconName: r,
        title: o,
        titleId: i,
        prefix: s,
        transform: u,
        symbol: c,
        mask: d,
        maskId: p,
        extra: h
      } = n;
      return new Promise((g, y) => {
        Promise.all([hS(r, s), d.iconName ? hS(d.iconName, d.prefix) : Promise.resolve({
          found: !1,
          width: 512,
          height: 512,
          icon: {}
        })]).then((b) => {
          let [v, x] = b;
          g([t, A_({
            icons: {
              main: v,
              mask: x
            },
            prefix: s,
            iconName: r,
            transform: u,
            symbol: c,
            maskId: p,
            title: o,
            titleId: i,
            extra: h,
            watchable: !0
          })]);
        }).catch(y);
      });
    }, e.generateAbstractIcon = function(t) {
      let {
        children: n,
        attributes: r,
        main: o,
        transform: i,
        styles: s
      } = t;
      const u = qg(s);
      u.length > 0 && (r.style = u);
      let c;
      return E_(i) && (c = ls("generateAbstractTransformGrouping", {
        main: o,
        transform: i,
        containerWidth: o.width,
        iconWidth: o.width
      })), n.push(c || o.icon), {
        children: n,
        attributes: r
      };
    };
  }
}, Pye = {
  mixout() {
    return {
      layer(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          classes: n = []
        } = t;
        return Gg({
          type: "layer"
        }, () => {
          sl("beforeDOMElementCreation", {
            assembler: e,
            params: t
          });
          let r = [];
          return e((o) => {
            Array.isArray(o) ? o.map((i) => {
              r = r.concat(i.abstract);
            }) : r = r.concat(o.abstract);
          }), [{
            tag: "span",
            attributes: {
              class: ["".concat(Me.cssPrefix, "-layers"), ...n].join(" ")
            },
            children: r
          }];
        });
      }
    };
  }
}, Lye = {
  mixout() {
    return {
      counter(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          title: n = null,
          classes: r = [],
          attributes: o = {},
          styles: i = {}
        } = t;
        return Gg({
          type: "counter",
          content: e
        }, () => (sl("beforeDOMElementCreation", {
          content: e,
          params: t
        }), mye({
          content: e.toString(),
          title: n,
          extra: {
            attributes: o,
            styles: i,
            classes: ["".concat(Me.cssPrefix, "-layers-counter"), ...r]
          }
        })));
      }
    };
  }
}, Iye = {
  mixout() {
    return {
      text(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          transform: n = si,
          title: r = null,
          classes: o = [],
          attributes: i = {},
          styles: s = {}
        } = t;
        return Gg({
          type: "text",
          content: e
        }, () => (sl("beforeDOMElementCreation", {
          content: e,
          params: t
        }), U4({
          content: e,
          transform: be(be({}, si), n),
          title: r,
          extra: {
            attributes: i,
            styles: s,
            classes: ["".concat(Me.cssPrefix, "-layers-text"), ...o]
          }
        })));
      }
    };
  },
  provides(e) {
    e.generateLayersText = function(t, n) {
      const {
        title: r,
        transform: o,
        extra: i
      } = n;
      let s = null, u = null;
      if (PD) {
        const c = parseInt(getComputedStyle(t).fontSize, 10), d = t.getBoundingClientRect();
        s = d.width / c, u = d.height / c;
      }
      return Me.autoA11y && !r && (i.attributes["aria-hidden"] = "true"), Promise.resolve([t, U4({
        content: t.innerHTML,
        width: s,
        height: u,
        transform: o,
        title: r,
        extra: i,
        watchable: !0
      })]);
    };
  }
};
const Vye = new RegExp('"', "ug"), G4 = [1105920, 1112319], Z4 = be(be(be(be({}, {
  FontAwesome: {
    normal: "fas",
    400: "fas"
  }
}), lge), Ege), vge), yS = Object.keys(Z4).reduce((e, t) => (e[t.toLowerCase()] = Z4[t], e), {}), Bye = Object.keys(yS).reduce((e, t) => {
  const n = yS[t];
  return e[t] = n[900] || [...Object.entries(n)][0][1], e;
}, {});
function Fye(e) {
  const t = e.replace(Vye, ""), n = Xge(t, 0), r = n >= G4[0] && n <= G4[1], o = t.length === 2 ? t[0] === t[1] : !1;
  return {
    value: uS(o ? t[0] : t),
    isSecondary: r || o
  };
}
function Uye(e, t) {
  const n = e.replace(/^['"]|['"]$/g, "").toLowerCase(), r = parseInt(t), o = isNaN(r) ? "normal" : r;
  return (yS[n] || {})[o] || Bye[n];
}
function K4(e, t) {
  const n = "".concat(Cge).concat(t.replace(":", "-"));
  return new Promise((r, o) => {
    if (e.getAttribute(n) !== null)
      return r();
    const s = Qu(e.children).filter((g) => g.getAttribute(iS) === t)[0], u = as.getComputedStyle(e, t), c = u.getPropertyValue("font-family"), d = c.match(Rge), p = u.getPropertyValue("font-weight"), h = u.getPropertyValue("content");
    if (s && !d)
      return e.removeChild(s), r();
    if (d && h !== "none" && h !== "") {
      const g = u.getPropertyValue("content");
      let y = Uye(c, p);
      const {
        value: b,
        isSecondary: v
      } = Fye(g), x = d[0].startsWith("FontAwesome");
      let _ = O_(y, b), O = _;
      if (x) {
        const C = Jge(b);
        C.iconName && C.prefix && (_ = C.iconName, y = C.prefix);
      }
      if (_ && !v && (!s || s.getAttribute(x_) !== y || s.getAttribute(S_) !== O)) {
        e.setAttribute(n, O), s && e.removeChild(s);
        const C = Nye(), {
          extra: N
        } = C;
        N.attributes[iS] = t, hS(_, y).then((R) => {
          const z = A_(be(be({}, C), {}, {
            icons: {
              main: R,
              mask: iP()
            },
            prefix: y,
            iconName: O,
            extra: N,
            watchable: !0
          })), j = Pt.createElementNS("http://www.w3.org/2000/svg", "svg");
          t === "::before" ? e.insertBefore(j, e.firstChild) : e.appendChild(j), j.outerHTML = z.map((I) => jf(I)).join(`
`), e.removeAttribute(n), r();
        }).catch(o);
      } else
        r();
    } else
      r();
  });
}
function Hye(e) {
  return Promise.all([K4(e, "::before"), K4(e, "::after")]);
}
function $ye(e) {
  return e.parentNode !== document.head && !~Age.indexOf(e.tagName.toUpperCase()) && !e.getAttribute(iS) && (!e.parentNode || e.parentNode.tagName !== "svg");
}
function Q4(e) {
  if (ca)
    return new Promise((t, n) => {
      const r = Qu(e.querySelectorAll("*")).filter($ye).map(Hye), o = N_.begin("searchPseudoElements");
      cP(), Promise.all(r).then(() => {
        o(), gS(), t();
      }).catch(() => {
        o(), gS(), n();
      });
    });
}
var Yye = {
  hooks() {
    return {
      mutationObserverCallbacks(e) {
        return e.pseudoElementsCallback = Q4, e;
      }
    };
  },
  provides(e) {
    e.pseudoElements2svg = function(t) {
      const {
        node: n = Pt
      } = t;
      Me.searchPseudoElements && Q4(n);
    };
  }
};
let J4 = !1;
var qye = {
  mixout() {
    return {
      dom: {
        unwatch() {
          cP(), J4 = !0;
        }
      }
    };
  },
  hooks() {
    return {
      bootstrap() {
        q4(dS("mutationObserverCallbacks", {}));
      },
      noAuto() {
        Eye();
      },
      watch(e) {
        const {
          observeMutationsRoot: t
        } = e;
        J4 ? gS() : q4(dS("mutationObserverCallbacks", {
          observeMutationsRoot: t
        }));
      }
    };
  }
};
const eN = (e) => {
  let t = {
    size: 16,
    x: 0,
    y: 0,
    flipX: !1,
    flipY: !1,
    rotate: 0
  };
  return e.toLowerCase().split(" ").reduce((n, r) => {
    const o = r.toLowerCase().split("-"), i = o[0];
    let s = o.slice(1).join("-");
    if (i && s === "h")
      return n.flipX = !0, n;
    if (i && s === "v")
      return n.flipY = !0, n;
    if (s = parseFloat(s), isNaN(s))
      return n;
    switch (i) {
      case "grow":
        n.size = n.size + s;
        break;
      case "shrink":
        n.size = n.size - s;
        break;
      case "left":
        n.x = n.x - s;
        break;
      case "right":
        n.x = n.x + s;
        break;
      case "up":
        n.y = n.y - s;
        break;
      case "down":
        n.y = n.y + s;
        break;
      case "rotate":
        n.rotate = n.rotate + s;
        break;
    }
    return n;
  }, t);
};
var Xye = {
  mixout() {
    return {
      parse: {
        transform: (e) => eN(e)
      }
    };
  },
  hooks() {
    return {
      parseNodeAttributes(e, t) {
        const n = t.getAttribute("data-fa-transform");
        return n && (e.transform = eN(n)), e;
      }
    };
  },
  provides(e) {
    e.generateAbstractTransformGrouping = function(t) {
      let {
        main: n,
        transform: r,
        containerWidth: o,
        iconWidth: i
      } = t;
      const s = {
        transform: "translate(".concat(o / 2, " 256)")
      }, u = "translate(".concat(r.x * 32, ", ").concat(r.y * 32, ") "), c = "scale(".concat(r.size / 16 * (r.flipX ? -1 : 1), ", ").concat(r.size / 16 * (r.flipY ? -1 : 1), ") "), d = "rotate(".concat(r.rotate, " 0 0)"), p = {
        transform: "".concat(u, " ").concat(c, " ").concat(d)
      }, h = {
        transform: "translate(".concat(i / 2 * -1, " -256)")
      }, g = {
        outer: s,
        inner: p,
        path: h
      };
      return {
        tag: "g",
        attributes: be({}, g.outer),
        children: [{
          tag: "g",
          attributes: be({}, g.inner),
          children: [{
            tag: n.icon.tag,
            children: n.icon.children,
            attributes: be(be({}, n.icon.attributes), g.path)
          }]
        }]
      };
    };
  }
};
const Ow = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function tN(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return e.attributes && (e.attributes.fill || t) && (e.attributes.fill = "black"), e;
}
function Wye(e) {
  return e.tag === "g" ? e.children : [e];
}
var Gye = {
  hooks() {
    return {
      parseNodeAttributes(e, t) {
        const n = t.getAttribute("data-fa-mask"), r = n ? Wg(n.split(" ").map((o) => o.trim())) : iP();
        return r.prefix || (r.prefix = ss()), e.mask = r, e.maskId = t.getAttribute("data-fa-mask-id"), e;
      }
    };
  },
  provides(e) {
    e.generateAbstractMask = function(t) {
      let {
        children: n,
        attributes: r,
        main: o,
        mask: i,
        maskId: s,
        transform: u
      } = t;
      const {
        width: c,
        icon: d
      } = o, {
        width: p,
        icon: h
      } = i, g = Fge({
        transform: u,
        containerWidth: p,
        iconWidth: c
      }), y = {
        tag: "rect",
        attributes: be(be({}, Ow), {}, {
          fill: "white"
        })
      }, b = d.children ? {
        children: d.children.map(tN)
      } : {}, v = {
        tag: "g",
        attributes: be({}, g.inner),
        children: [tN(be({
          tag: d.tag,
          attributes: be(be({}, d.attributes), g.path)
        }, b))]
      }, x = {
        tag: "g",
        attributes: be({}, g.outer),
        children: [v]
      }, _ = "mask-".concat(s || ef()), O = "clip-".concat(s || ef()), C = {
        tag: "mask",
        attributes: be(be({}, Ow), {}, {
          id: _,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        }),
        children: [y, x]
      }, N = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: O
          },
          children: Wye(h)
        }, C]
      };
      return n.push(N, {
        tag: "rect",
        attributes: be({
          fill: "currentColor",
          "clip-path": "url(#".concat(O, ")"),
          mask: "url(#".concat(_, ")")
        }, Ow)
      }), {
        children: n,
        attributes: r
      };
    };
  }
}, Zye = {
  provides(e) {
    let t = !1;
    as.matchMedia && (t = as.matchMedia("(prefers-reduced-motion: reduce)").matches), e.missingIconAbstract = function() {
      const n = [], r = {
        fill: "currentColor"
      }, o = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      n.push({
        tag: "path",
        attributes: be(be({}, r), {}, {
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        })
      });
      const i = be(be({}, o), {}, {
        attributeName: "opacity"
      }), s = {
        tag: "circle",
        attributes: be(be({}, r), {}, {
          cx: "256",
          cy: "364",
          r: "28"
        }),
        children: []
      };
      return t || s.children.push({
        tag: "animate",
        attributes: be(be({}, o), {}, {
          attributeName: "r",
          values: "28;14;28;28;14;28;"
        })
      }, {
        tag: "animate",
        attributes: be(be({}, i), {}, {
          values: "1;0;1;1;0;1;"
        })
      }), n.push(s), n.push({
        tag: "path",
        attributes: be(be({}, r), {}, {
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        }),
        children: t ? [] : [{
          tag: "animate",
          attributes: be(be({}, i), {}, {
            values: "1;0;0;0;0;1;"
          })
        }]
      }), t || n.push({
        tag: "path",
        attributes: be(be({}, r), {}, {
          opacity: "0",
          d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
        }),
        children: [{
          tag: "animate",
          attributes: be(be({}, i), {}, {
            values: "0;0;1;1;0;0;"
          })
        }]
      }), {
        tag: "g",
        attributes: {
          class: "missing"
        },
        children: n
      };
    };
  }
}, Kye = {
  hooks() {
    return {
      parseNodeAttributes(e, t) {
        const n = t.getAttribute("data-fa-symbol"), r = n === null ? !1 : n === "" ? !0 : n;
        return e.symbol = r, e;
      }
    };
  }
}, Qye = [$ge, Dye, Pye, Lye, Iye, Yye, qye, Xye, Gye, Zye, Kye];
lye(Qye, {
  mixoutsTo: Yr
});
Yr.noAuto;
Yr.config;
Yr.library;
Yr.dom;
const vS = Yr.parse;
Yr.findIconDefinition;
Yr.toHtml;
const Jye = Yr.icon;
Yr.layer;
Yr.text;
Yr.counter;
var Aw = { exports: {} }, Nw, nN;
function eve() {
  if (nN) return Nw;
  nN = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Nw = e, Nw;
}
var Mw, rN;
function tve() {
  if (rN) return Mw;
  rN = 1;
  var e = /* @__PURE__ */ eve();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Mw = function() {
    function r(s, u, c, d, p, h) {
      if (h !== e) {
        var g = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw g.name = "Invariant Violation", g;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Mw;
}
var oN;
function nve() {
  return oN || (oN = 1, Aw.exports = /* @__PURE__ */ tve()()), Aw.exports;
}
var rve = /* @__PURE__ */ nve();
const nt = /* @__PURE__ */ Tm(rve);
function iN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ri(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iN(Object(n), !0).forEach(function(r) {
      hu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function zm(e) {
  "@babel/helpers - typeof";
  return zm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, zm(e);
}
function hu(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function ove(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function ive(e, t) {
  if (e == null) return {};
  var n = ove(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function bS(e) {
  return ave(e) || sve(e) || lve(e) || uve();
}
function ave(e) {
  if (Array.isArray(e)) return wS(e);
}
function sve(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function lve(e, t) {
  if (e) {
    if (typeof e == "string") return wS(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return wS(e, t);
  }
}
function wS(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function uve() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function cve(e) {
  var t, n = e.beat, r = e.fade, o = e.beatFade, i = e.bounce, s = e.shake, u = e.flash, c = e.spin, d = e.spinPulse, p = e.spinReverse, h = e.pulse, g = e.fixedWidth, y = e.inverse, b = e.border, v = e.listItem, x = e.flip, _ = e.size, O = e.rotation, C = e.pull, N = (t = {
    "fa-beat": n,
    "fa-fade": r,
    "fa-beat-fade": o,
    "fa-bounce": i,
    "fa-shake": s,
    "fa-flash": u,
    "fa-spin": c,
    "fa-spin-reverse": p,
    "fa-spin-pulse": d,
    "fa-pulse": h,
    "fa-fw": g,
    "fa-inverse": y,
    "fa-border": b,
    "fa-li": v,
    "fa-flip": x === !0,
    "fa-flip-horizontal": x === "horizontal" || x === "both",
    "fa-flip-vertical": x === "vertical" || x === "both"
  }, hu(t, "fa-".concat(_), typeof _ < "u" && _ !== null), hu(t, "fa-rotate-".concat(O), typeof O < "u" && O !== null && O !== 0), hu(t, "fa-pull-".concat(C), typeof C < "u" && C !== null), hu(t, "fa-swap-opacity", e.swapOpacity), t);
  return Object.keys(N).map(function(R) {
    return N[R] ? R : null;
  }).filter(function(R) {
    return R;
  });
}
function dve(e) {
  return e = e - 0, e === e;
}
function fP(e) {
  return dve(e) ? e : (e = e.replace(/[\-_\s]+(.)?/g, function(t, n) {
    return n ? n.toUpperCase() : "";
  }), e.substr(0, 1).toLowerCase() + e.substr(1));
}
var fve = ["style"];
function pve(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function hve(e) {
  return e.split(";").map(function(t) {
    return t.trim();
  }).filter(function(t) {
    return t;
  }).reduce(function(t, n) {
    var r = n.indexOf(":"), o = fP(n.slice(0, r)), i = n.slice(r + 1).trim();
    return o.startsWith("webkit") ? t[pve(o)] = i : t[o] = i, t;
  }, {});
}
function pP(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof t == "string")
    return t;
  var r = (t.children || []).map(function(c) {
    return pP(e, c);
  }), o = Object.keys(t.attributes || {}).reduce(function(c, d) {
    var p = t.attributes[d];
    switch (d) {
      case "class":
        c.attrs.className = p, delete t.attributes.class;
        break;
      case "style":
        c.attrs.style = hve(p);
        break;
      default:
        d.indexOf("aria-") === 0 || d.indexOf("data-") === 0 ? c.attrs[d.toLowerCase()] = p : c.attrs[fP(d)] = p;
    }
    return c;
  }, {
    attrs: {}
  }), i = n.style, s = i === void 0 ? {} : i, u = ive(n, fve);
  return o.attrs.style = ri(ri({}, o.attrs.style), s), e.apply(void 0, [t.tag, ri(ri({}, o.attrs), u)].concat(bS(r)));
}
var hP = !1;
try {
  hP = !0;
} catch {
}
function mve() {
  if (!hP && console && typeof console.error == "function") {
    var e;
    (e = console).error.apply(e, arguments);
  }
}
function aN(e) {
  if (e && zm(e) === "object" && e.prefix && e.iconName && e.icon)
    return e;
  if (vS.icon)
    return vS.icon(e);
  if (e === null)
    return null;
  if (e && zm(e) === "object" && e.prefix && e.iconName)
    return e;
  if (Array.isArray(e) && e.length === 2)
    return {
      prefix: e[0],
      iconName: e[1]
    };
  if (typeof e == "string")
    return {
      prefix: "fas",
      iconName: e
    };
}
function Rw(e, t) {
  return Array.isArray(t) && t.length > 0 || !Array.isArray(t) && t ? hu({}, e, t) : {};
}
var sN = {
  border: !1,
  className: "",
  mask: null,
  maskId: null,
  fixedWidth: !1,
  inverse: !1,
  flip: !1,
  icon: null,
  listItem: !1,
  pull: null,
  pulse: !1,
  rotation: null,
  size: null,
  spin: !1,
  spinPulse: !1,
  spinReverse: !1,
  beat: !1,
  fade: !1,
  beatFade: !1,
  bounce: !1,
  shake: !1,
  symbol: !1,
  title: "",
  titleId: null,
  transform: null,
  swapOpacity: !1
}, Od = /* @__PURE__ */ Qe.forwardRef(function(e, t) {
  var n = ri(ri({}, sN), e), r = n.icon, o = n.mask, i = n.symbol, s = n.className, u = n.title, c = n.titleId, d = n.maskId, p = aN(r), h = Rw("classes", [].concat(bS(cve(n)), bS((s || "").split(" ")))), g = Rw("transform", typeof n.transform == "string" ? vS.transform(n.transform) : n.transform), y = Rw("mask", aN(o)), b = Jye(p, ri(ri(ri(ri({}, h), g), y), {}, {
    symbol: i,
    title: u,
    titleId: c,
    maskId: d
  }));
  if (!b)
    return mve("Could not find icon", p), null;
  var v = b.abstract, x = {
    ref: t
  };
  return Object.keys(n).forEach(function(_) {
    sN.hasOwnProperty(_) || (x[_] = n[_]);
  }), gve(v[0], x);
});
Od.displayName = "FontAwesomeIcon";
Od.propTypes = {
  beat: nt.bool,
  border: nt.bool,
  beatFade: nt.bool,
  bounce: nt.bool,
  className: nt.string,
  fade: nt.bool,
  flash: nt.bool,
  mask: nt.oneOfType([nt.object, nt.array, nt.string]),
  maskId: nt.string,
  fixedWidth: nt.bool,
  inverse: nt.bool,
  flip: nt.oneOf([!0, !1, "horizontal", "vertical", "both"]),
  icon: nt.oneOfType([nt.object, nt.array, nt.string]),
  listItem: nt.bool,
  pull: nt.oneOf(["right", "left"]),
  pulse: nt.bool,
  rotation: nt.oneOf([0, 90, 180, 270]),
  shake: nt.bool,
  size: nt.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
  spin: nt.bool,
  spinPulse: nt.bool,
  spinReverse: nt.bool,
  symbol: nt.oneOfType([nt.bool, nt.string]),
  title: nt.string,
  titleId: nt.string,
  transform: nt.oneOfType([nt.string, nt.object]),
  swapOpacity: nt.bool
};
var gve = pP.bind(null, Qe.createElement);
const yve = ({
  state: e
}) => {
  const [t, n] = S.useState(
    e.getState().python_code || ""
  ), [r, o] = S.useState(!1), i = e((u) => u.python_code_error), s = (u) => {
    n(u || ""), r && e.setState({ python_code: u || "" });
  };
  return /* @__PURE__ */ Qn.jsxs(
    "div",
    {
      style: {
        // minWidth: "300px",
        // maxWidth: "50%",
        height: "100%",
        display: "flex",
        flexDirection: "column"
      },
      children: [
        /* @__PURE__ */ Qn.jsxs("div", { style: { flex: 1, minHeight: 0 }, children: [
          /* @__PURE__ */ Qn.jsx(
            Eme,
            {
              language: "python",
              theme: "vs-dark",
              onChange: s,
              value: t
            }
          ),
          /* @__PURE__ */ Qn.jsx("div", { className: "controll_icons", children: r ? /* @__PURE__ */ Qn.jsx(
            Od,
            {
              className: "controll_icon",
              icon: Kme,
              style: { color: "orange" },
              onClick: async () => {
                o(!1);
              },
              title: "Pause continuous run"
            }
          ) : /* @__PURE__ */ Qn.jsxs(Qn.Fragment, { children: [
            /* @__PURE__ */ Qn.jsx(
              Od,
              {
                className: "controll_icon",
                icon: Qme,
                onClick: async () => {
                  e.setState({ python_code: t });
                },
                title: "Run"
              }
            ),
            /* @__PURE__ */ Qn.jsx(
              Od,
              {
                className: "controll_icon",
                icon: Zme,
                onClick: async () => {
                  o(!0), e.setState({ python_code: t });
                },
                title: "Continuous run"
              }
            )
          ] }) })
        ] }),
        /* @__PURE__ */ Qn.jsx("code", { style: { maxHeight: "50%", overflowY: "auto" }, children: i })
      ]
    }
  );
}, vve = {
  //@ts-ignore
  id: void 0,
  show_python_editor: !0,
  index_url: "",
  store_code: !0
}, bve = (e) => {
  const { new_obj: t } = of(e, vve), n = t.ser_node || t.python_code, r = t.show_python_editor;
  if (!n && !r)
    throw new Error("no Node and no editor");
  if (t.id === void 0)
    throw new Error("id must be defined");
  if (t.worker || (t.worker = new hD({
    shared_worker: !1,
    uuid: t.id + "_worker",
    worker_classes: {
      Dedicated: vhe,
      Shared: whe
    }
  })), t.store_code) {
    const u = localStorage.getItem(t.id + "_python_code");
    u && (t.python_code = u);
  }
  const o = yhe(() => ({
    ...t
  })), i = async () => {
    const u = o.getState().python_code;
    u && (t.store_code && localStorage.setItem(t.id + "_python_code", u), t.worker?.postMessage({
      cmd: "worker:evalnode",
      msg: u,
      worker_id: t.worker?.uuid,
      id: "evalnode"
    }), t.worker?.stepwise_fullsync());
  };
  S.useEffect(() => {
    const u = t.worker?.add_hook("starting", async () => {
      await i(), await t.onload?.();
    }), c = setInterval(async () => {
      t.worker?.ready && (await i(), await t.onload?.(), clearInterval(c));
    }, 500), d = t.worker?.add_hook(
      "node_mounted",
      async ({ worker: g, data: y }) => {
        g._zustand?.center_node(y), await new Promise((b) => setTimeout(b, 0)), g._zustand?.center_node(y), await new Promise((b) => setTimeout(b, 10)), g._zustand?.center_node(y), await new Promise((b) => setTimeout(b, 100)), g._zustand?.center_node(y);
      }
    ), p = t.worker?.add_ns_event_intercept(
      "node_added",
      async (g) => {
        const y = g.data.node;
        return y && (y.frontend || (y.frontend = {}), y.frontend.pos = [0, 0]), g;
      }
    ), h = t.worker?.registerMessageHook(async (g) => {
      t.worker && g.id === "evalnode" && g.original.worker_id === t.worker.uuid && (g.error ? o.setState({ python_code_error: g.error }) : o.setState({ python_code_error: "" }));
    });
    return () => {
      u?.(), d?.(), p?.(), h?.(), clearInterval(c);
    };
  }), o.subscribe((u, c) => {
    u.python_code !== c.python_code && i();
  });
  const s = /* @__PURE__ */ Qn.jsx(
    Gpe,
    {
      worker: t.worker,
      id: t.id,
      useWorkerManager: !1,
      show_library: !1,
      header: { show: !1, showmenu: !1 },
      library: { show: !1 },
      flow: {
        minimap: !1,
        allowFullScreen: !1,
        allowExpand: !1,
        showNodeSettings: !1
      }
    }
  );
  return /* @__PURE__ */ Qn.jsx(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: "row",
        height: "100%",
        width: "100%"
      },
      children: t.show_python_editor ? /* @__PURE__ */ Qn.jsxs(
        Gme,
        {
          vertical: !1,
          defaultSizes: [50, 50],
          onDragEnd: () => {
            t.worker?._zustand?.center_all();
          },
          children: [
            s,
            /* @__PURE__ */ Qn.jsx(yve, { state: o })
          ]
        }
      ) : s
    }
  );
}, wve = (e, t) => {
  t === void 0 && (t = {});
  const { element: n, eleid: r } = typeof e == "string" ? {
    element: document.getElementById(e),
    eleid: e
  } : { element: e, eleid: e.id }, o = /* @__PURE__ */ Qn.jsx(bve, { id: r, ...t }), i = k9.createRoot(n);
  return i.render(o), {
    root: i,
    content: o
  };
};
window.NodeBuilder = wve;
window.FuncnodesPyodideWorker = hD;
